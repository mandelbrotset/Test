\chapter{Prestudy}
\section{Repositories to analyze}
Since we are going for a quantitative analysis, we want to analyse fairly big projects that contain many commits and many forks along with many branches. This is because we want to cover as much of variant possibilities as possible to gain the most accurate result. To satisfy these requirements, the 20 top starred Java repositories on GitHub were chosen.
\paragraph*{}
The projects listed in Table (no) were cloned so that Git commands could be used to analyze the repositories. Elasticsearch was chosen as the project for our initial analysis since it has a vast number of commits (more than 20000) and forks.
\paragraph*{}
Elasticsearch is a distributed search engine used for analysing data in realtime. 
\paragraph*{}
(As of 23/3-16)\\
\begin{tabular}{ l l l l}
\hline
\multicolumn{1}{c}{\textbf{Name}} & \multicolumn{1}{c}{\textbf{Commits}} & \multicolumn{1}{c}{\textbf{Branches}} & \multicolumn{1}{c}{\textbf{Forks}}\\
Elasticsearch & 20712 & 46 & 5229\\
Android-async-http & 856 & 3 & 4024\\
Android-best-practices & 201 & 1 & 1696\\
Android-universal-image-loader & 1025 & 3 & 5640\\
Curator & 1050 & 9 & 304\\
Eventbus & 404 & 5 & 2493\\
Fresco & 494 & 3 & 2453\\
Guava & 3372 & 4 & 1862\\
Iosched & 129 & 2 & 4071\\
Java-design-patterns & 1196 & 6 & 3495\\
Leakcanary & 238 & 15 & 1291\\
Libgdx & 12247 & 4 & 4479\\
Okhttp & 2449 & 37 & 2518\\
React-native & 5707 & 23 & 5609\\
Retrofit & 1285 & 21 & 2081\\
Rxjava & 4630 & 24 & 1919\\
Slidingmenu & 336 & 8 & 5306\\
Spring-framework & 11825 & 10 & 6860\\
Storm & 1764 & 44 & 1760\\
Zxing & 3203 & 3 & 4730
\end{tabular}
\subsection{Gathering parameter data}
When studying the code of Elasticsearch, we noticed that parameters were introduced and loaded from an external configuration file. These parameters were then used to set boolean variables that usually indicates whether to use a certain block of code or not. In Elasticsearch, the function use to set these boolean variables was called “getAsBoolean” and takes a string parameter name, and a boolean default value.\\
\lstset{language=Java}
\begin{lstlisting}[frame=single]
boolean example = getAsBoolean(“example_parameter”, true);
\end{lstlisting}
\paragraph*{}
The example\_parameter could be set by the user in the external configuration file and if it has not been set, a default value, in this example true, will be used. The boolean variable would in some cases be used to indicate which block of code to use, as in this example taken from a snippet of Elasticsearch code:\\
\lstset{language=Java}
\begin{lstlisting}[frame=single]
this.autoThrottle = indexSettings.getAsBoolean(AUTO_THROTTLE, true);
\\
if (autoThrottle) {
   concurrentMergeScheduler.enableAutoIOThrottle();
} else {
   concurrentMergeScheduler.disableAutoIOThrottle();
}
\end{lstlisting}
\paragraph*{}
To be able to identify the parameters, and collect data about them, a tool was developed in Java which would gather the data automatically. All data that is stored in Git is hashed using SHA-1. If not stated otherwise, in this document, the hash will be referred to by SHA-1. The data to be gathered includes:
\begin{itemize}
\item The parameter name that was introduced
\item The commit SHA
\item The if-statement that the boolean is used in
\item The code where the boolean variable is set by the function that takes the parameter name as one of its parameters.
\item The commit message
\item Whether or not the commit was a pull request \ldots
\end{itemize}
The data was gathered by developing a Java program which uses Linux bash scripts that executes Git commands to get the desired data.
\paragraph*{}
Git diff. As Git saves the data as snapshots and not as changes, one needs to compare two commits in order to see which changes that were introduced in a commit. To do this, we use the built in diff command in the following way: 
git --no-pager diff <SHA-1>\^ <SHA-1>
where \^ is a git shortcut to get the parent commit of a commit SHA-1.
\paragraph*{}
Parameter name. The parameter name was extracted from the line where the boolean is set by the getAsBoolean function. It is useful to include it in the data so that it can be used when manually looking through the code to understand what the parameter was used for.
\paragraph*{}
Commit SHA-1. For every commit that is checked out, we search for parameters and if there exist at least one, the commit SHA-1 is saved so that we know which commits to check out when we want to look manually at the code.
\paragraph*{}
If-statement the boolean is used in. In the beginning of developing the tool, we extracted the newly introduced boolean variables that was later used in if-statements. This proved to be not useful since the boolean variable names was not always the same as the parameter names used in the configuration file.
\paragraph*{}
getAsBoolean line. While extracting the name of the parameter in the getAsBoolean function, we also save the line itself to be able to quickly see the name of the boolean variable as well as the default value the boolean will be assigned to if the parameter is not set. This data is printed to the excel document.
\paragraph*{}
Commit message. The commit message is also extracted and printed in the excel document. In case the commit message contains important information which could indicate that the commit contains variant related code, it is vital to look at it to find which commits are good to analyse manually.
To get the commit message for a giver SHA-1, this command was used:
git log --format=\%B -n 1 <SHA-1>
\paragraph*{}
Pull request. When changes on a branch in a fork of a project is to be merged into the original project, pull-requests are used. It is interesting to know whether or not the commit was a pull request. Finding out if variant related code is more or less likely in pull requests would be interesting for the study. To know whether a given merge commit was a pull request, the commit message was parsed to see if it contains Merge pull request \# .
\paragraph*{}
We print the parsed information in the excel document using the following format:\\
table..
\subsection{Extend tool to recreate merges and extract the conflicting files}
Originally, the idea was to find merge-conflict resolution patterns in Git merges. To begin searching for such patterns, we first had to figure out what patterns exist. When looking at the git merge log, using the command git log --merges, it lists the merge commits with the commit messages which could contain a list of conflicting files. However, this approach is not reliable as the commit message could be altered by the commitér who can remove the list of conflicting files. Because of this, we extended the tool to recreate all of the historical merges in the repository to see which conflicts arises. To do this, we first needed to find the two ancestral commits of a merge commit, that is, the to commits that were merged. The following command prints the two commits:
git --no-pager log --merges --format=%p <SHA-1> | head -n1
where <SHA-1> is the merge commit SHA-1. We then parse the two commits and performs the merge using the following sequence of commands. The two commits are hereby referred to as C1 and C2:\\
\lstset{language=Bash}
\begin{lstlisting}[frame=single]
git reset --hard <SHA-1 of C1>
git clean -f
git branch <temp branch name>
git checkout <SHA-1 of C2>
git merge <temp branch name>
\end{lstlisting}
In 1, we set HEAD to commit C1 and changes the working copy to the state of that commit. In 2,  the working copy is cleaned to be ready for the merge. In 3, a new branch is created which points at commit C1. In 4, we checkout commit C2. In 5, we merge the two commits by merging the newly created branch into commit C2. Git will now print out the conflicting files, which we then can parse. Afterwards, we abort the merge and delete the branch.
\paragraph*{}
Fast forward. When merging two branches, Git first attempts to perform a so-called fast forward merge. It is a way of simplifying merges in cases where at least one of the branches points to the common ancestor of the commits pointed to by the two branches. In such a case, all that has to be done, is to change both branches to point at the latest commit. For example:\\
image
paragraph*{}
Three-way merge. If fast forward fails, that is, when commits has been made to both branches that are to be merged, Git has to merge all files that the commits contains. This consists of merging the two versions of every file separately, and to be able to know what has changed in the two branches, Git considers both the two versions and their common ancestor. If the files have not been changed at the same places in both branches, Git is able to do this automatically.
\paragraph*{}
Git conflicts. If the two commits, that are to be merged, have made changes to the same place in a file, Git will not be able to merge the two versions automatically. This is called a Git conflict. When a Git conflict occurs, Git will output the conflicting file paths in the commit message, which the tool parses.
\paragraph*{}
When resolving conflicts, it is usually done by manually merging the conflicting lines of the local file (the file in the current checked out branch) with the file of the remote file (the file of the branch which is being merged into the current checked out branch) and the common ancestor file (the original file before it was changed in the local- and remote branches). These files, along with the resulting resolution file in the merge commit, are copied and saved in a Conflict file tree. The Conflict file tree consist of folders and the versions of the conflicting files, structured according to the figure below.
\\image...\\
Having all the conflicting file versions in a structured manner will make it easier to analyse them further.




