% CREATED BY DAVID FRISK, 2015
\chapter{Methods}
To create the catalog of merge-conflict resolution patterns the following methodology will be used:
\begin{enumerate}
\item Select Merge Commits
\item Classify the merge conflicts
\item Manually identify the corresponding resolution patterns for each classified conflict pattern
\item Autonomously classify each resolution into patterns
\end{enumerate}
\section{Selection of Merge Commits}
To get a good sample of merge commits, we will clone each project and list all historical merges using the command “git --no-pager log --merges”. This command lists all merge commits in a project and allows for specification of exactly what information we are interested in. This includes the commit SHA-1, parent commits, commit message etc. For each merge commit, we will reproduce the merge using SSMerge and use all conflicts that it encounters. That is, the conflicts that even a semantical and syntactical merge tool is unable to solve automatically.
\section{Classify merge conflicts}
To classify conflicts, we aim to use the tool Conflicts Analyzer developed by Accioly(source). This tool automatically clones Github projects and performs the historical merges of the projects using the merge tool SSMerge(source), which is a semistructured merge tool. When semantic merge-conflicts occur, Conflicts Analyzer classifies them according to the conflict patterns defined by Accioly which is listed in table (no) in the Prestudy chapter.
\section{Identify resolution patterns}
For each conflict pattern, we will strive to identify the different corresponding resolution patterns. We will try to identify patterns that cover all ways of resolving each type of conflict. For example, the ModifierList conflict pattern requires the resolution to choose which modifiers to use. Let's assume a case where the common ancestor has the modifier “protected”, one revision has changed it to “private” and one has changed it to “public”. One pattern here may be to always choose the least restrictive one, namely the “public”, to reduce the chance of introducing an error. On the other hand, one pattern could be that the “private” modifier is chosen to increase information hiding, which is often desired in object oriented programming.
\paragraph*{}
A conflict pattern can have one or many resolution patterns. Likewise, a resolution pattern might solve one or more conflict patterns. We will create a catalog of these resolution patterns and map them to their corresponding conflict patterns. Below is an example of how the catalog could be formated:\\
\begin{tabular}{ p{8cm} p{6cm} }
\hline
\multicolumn{1}{c}{\textbf{Pattern}} & \multicolumn{1}{c}{\textbf{Description}}\\
ModifiedList &
\begin{itemize}
\item Resolution Pattern \#1
\item Resolution Pattern \#2
\item Resolution Pattern \#3
\end{itemize}
\end{tabular}
\section{Autonomously classify each resolution}
Using the catalog of identified merge-conflict resolution patterns, we will create an infrastructure which autonomously classifies all selected merge conflicts. The infrastructure will mine GitHub projects, starting with the top 20 starred projects listed in table (no). Using the data acquired we will conduct a statistical analysis of the frequency of the resolution patterns.