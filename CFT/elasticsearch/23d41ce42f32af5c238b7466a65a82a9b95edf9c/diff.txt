diff --git a/core/src/main/java/org/elasticsearch/bootstrap/Security.java b/core/src/main/java/org/elasticsearch/bootstrap/Security.java
index dc89ce3..fa3ad3e 100644
--- a/core/src/main/java/org/elasticsearch/bootstrap/Security.java
+++ b/core/src/main/java/org/elasticsearch/bootstrap/Security.java
@@ -27,7 +27,7 @@ import org.elasticsearch.common.settings.Settings;
 import org.elasticsearch.env.Environment;
 import org.elasticsearch.http.netty.NettyHttpServerTransport;
 import org.elasticsearch.plugins.PluginInfo;
-import org.elasticsearch.transport.netty.NettyTransport;
+import org.elasticsearch.transport.TransportSettings;
 
 import java.io.FilePermission;
 import java.io.IOException;
@@ -277,10 +277,10 @@ final class Security {
         // see SocketPermission implies() code
         policy.add(new SocketPermission("*:" + httpRange, "listen,resolve"));
         // transport is waaaay overengineered
-        Map<String, Settings> profiles = settings.getGroups("transport.profiles", true);
-        if (!profiles.containsKey(NettyTransport.DEFAULT_PROFILE)) {
+        Map<String, Settings> profiles = TransportSettings.TRANSPORT_PROFILES_SETTING.get(settings).getAsGroups();
+        if (!profiles.containsKey(TransportSettings.DEFAULT_PROFILE)) {
             profiles = new HashMap<>(profiles);
-            profiles.put(NettyTransport.DEFAULT_PROFILE, Settings.EMPTY);
+            profiles.put(TransportSettings.DEFAULT_PROFILE, Settings.EMPTY);
         }
 
         // loop through all profiles and add permissions for each one, if its valid.
@@ -288,12 +288,10 @@ final class Security {
         for (Map.Entry<String, Settings> entry : profiles.entrySet()) {
             Settings profileSettings = entry.getValue();
             String name = entry.getKey();
-            String transportRange = profileSettings.get("port",
-                                        settings.get("transport.tcp.port",
-                                                NettyTransport.DEFAULT_PORT_RANGE));
+            String transportRange = profileSettings.get("port", TransportSettings.PORT.get(settings));
 
             // a profile is only valid if its the default profile, or if it has an actual name and specifies a port
-            boolean valid = NettyTransport.DEFAULT_PROFILE.equals(name) || (Strings.hasLength(name) && profileSettings.get("port") != null);
+            boolean valid = TransportSettings.DEFAULT_PROFILE.equals(name) || (Strings.hasLength(name) && profileSettings.get("port") != null);
             if (valid) {
                 // listen is always called with 'localhost' but use wildcard to be sure, no name service is consulted.
                 // see SocketPermission implies() code
diff --git a/core/src/main/java/org/elasticsearch/client/transport/TransportClient.java b/core/src/main/java/org/elasticsearch/client/transport/TransportClient.java
index 419c4d5..2955623 100644
--- a/core/src/main/java/org/elasticsearch/client/transport/TransportClient.java
+++ b/core/src/main/java/org/elasticsearch/client/transport/TransportClient.java
@@ -110,11 +110,11 @@ public class TransportClient extends AbstractClient {
 
         private PluginsService newPluginService(final Settings settings) {
             final Settings.Builder settingsBuilder = settingsBuilder()
-                .put(NettyTransport.PING_SCHEDULE, "5s") // enable by default the transport schedule ping interval
-                .put( InternalSettingsPreparer.prepareSettings(settings))
-                .put("network.server", false)
-                .put(Node.NODE_CLIENT_SETTING.getKey(), true)
-                .put(CLIENT_TYPE_SETTING_S.getKey(), CLIENT_TYPE);
+                    .put(NettyTransport.PING_SCHEDULE.getKey(), "5s") // enable by default the transport schedule ping interval
+                    .put(InternalSettingsPreparer.prepareSettings(settings))
+                    .put(NettyTransport.NETWORK_SERVER.getKey(), false)
+                    .put(Node.NODE_CLIENT_SETTING.getKey(), true)
+                    .put(CLIENT_TYPE_SETTING_S.getKey(), CLIENT_TYPE);
             return new PluginsService(settingsBuilder.build(), null, null, pluginClasses);
         }
 
@@ -140,7 +140,7 @@ public class TransportClient extends AbstractClient {
                     modules.add(pluginModule);
                 }
                 modules.add(new PluginsModule(pluginsService));
-                modules.add(new SettingsModule(settings, settingsFilter ));
+                modules.add(new SettingsModule(settings, settingsFilter));
                 modules.add(new NetworkModule(networkService, settings, true, namedWriteableRegistry));
                 modules.add(new ClusterNameModule(settings));
                 modules.add(new ThreadPoolModule(threadPool));
diff --git a/core/src/main/java/org/elasticsearch/common/logging/ESLoggerFactory.java b/core/src/main/java/org/elasticsearch/common/logging/ESLoggerFactory.java
index 840c4ac..a0645c6 100644
--- a/core/src/main/java/org/elasticsearch/common/logging/ESLoggerFactory.java
+++ b/core/src/main/java/org/elasticsearch/common/logging/ESLoggerFactory.java
@@ -22,44 +22,12 @@ package org.elasticsearch.common.logging;
 import org.elasticsearch.common.logging.jdk.JdkESLoggerFactory;
 import org.elasticsearch.common.logging.log4j.Log4jESLoggerFactory;
 import org.elasticsearch.common.logging.slf4j.Slf4jESLoggerFactory;
-import org.elasticsearch.common.settings.AbstractScopedSettings;
-import org.elasticsearch.common.settings.Setting;
-import org.elasticsearch.common.settings.Settings;
-
-import java.util.Locale;
-import java.util.Map;
-import java.util.function.Consumer;
-import java.util.regex.Pattern;
 
 /**
  * Factory to get {@link ESLogger}s
  */
 public abstract class ESLoggerFactory {
 
-    public static final Setting<LogLevel> LOG_DEFAULT_LEVEL_SETTING = new Setting<>("logger.level", LogLevel.INFO.name(), LogLevel::parse, false, Setting.Scope.CLUSTER);
-    public static final Setting<LogLevel> LOG_LEVEL_SETTING = new Setting<LogLevel>("logger.", LogLevel.INFO.name(), LogLevel::parse, true, Setting.Scope.CLUSTER) {
-        private final Pattern KEY_PATTERN = Pattern.compile("^logger[.](?:[-\\w]+[.])*[-\\w]+$$");
-
-        @Override
-        protected boolean isGroupSetting() {
-            return true;
-        }
-
-        @Override
-        public boolean match(String toTest) {
-            return KEY_PATTERN.matcher(toTest).matches();
-        }
-
-        @Override
-        public Setting<LogLevel> getConcreteSetting(String key) {
-            if (match(key)) {
-                return new Setting<>(key, LogLevel.WARN.name(), LogLevel::parse, true, Setting.Scope.CLUSTER);
-            } else {
-                throw new IllegalArgumentException("key must match setting but didn't ["+key +"]");
-            }
-        }
-    };
-
     private static volatile ESLoggerFactory defaultFactory = new JdkESLoggerFactory();
 
     static {
@@ -117,11 +85,4 @@ public abstract class ESLoggerFactory {
     protected abstract ESLogger rootLogger();
 
     protected abstract ESLogger newInstance(String prefix, String name);
-
-    public enum LogLevel {
-        WARN, TRACE, INFO, DEBUG, ERROR;
-        public static LogLevel parse(String level) {
-            return valueOf(level.toUpperCase(Locale.ROOT));
-        }
-    }
 }
diff --git a/core/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java b/core/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java
index b301788..65db6d1 100644
--- a/core/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java
+++ b/core/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java
@@ -166,11 +166,7 @@ public abstract class AbstractScopedSettings extends AbstractComponent {
         if (setting != get(setting.getKey())) {
             throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]");
         }
-        addSettingsUpdater(setting.newUpdater(consumer, logger, validator));
-    }
-
-    synchronized void addSettingsUpdater(SettingUpdater<?> updater) {
-        this.settingUpdaters.add(updater);
+        this.settingUpdaters.add(setting.newUpdater(consumer, logger, validator));
     }
 
     /**
@@ -188,7 +184,7 @@ public abstract class AbstractScopedSettings extends AbstractComponent {
         if (b != get(b.getKey())) {
             throw new IllegalArgumentException("Setting is not registered for key [" + b.getKey() + "]");
         }
-        addSettingsUpdater(Setting.compoundUpdater(consumer, a, b, logger));
+        this.settingUpdaters.add(Setting.compoundUpdater(consumer, a, b, logger));
     }
 
     /**
@@ -292,7 +288,7 @@ public abstract class AbstractScopedSettings extends AbstractComponent {
         }
         for (Map.Entry<String, Setting<?>> entry : complexMatchers.entrySet()) {
             if (entry.getValue().match(key)) {
-                return entry.getValue().getConcreteSetting(key);
+                return entry.getValue();
             }
         }
         return null;
diff --git a/core/src/main/java/org/elasticsearch/common/settings/ClusterSettings.java b/core/src/main/java/org/elasticsearch/common/settings/ClusterSettings.java
index 24d7a0b..5819654 100644
--- a/core/src/main/java/org/elasticsearch/common/settings/ClusterSettings.java
+++ b/core/src/main/java/org/elasticsearch/common/settings/ClusterSettings.java
@@ -41,18 +41,19 @@ import org.elasticsearch.cluster.routing.allocation.decider.SnapshotInProgressAl
 import org.elasticsearch.cluster.routing.allocation.decider.ThrottlingAllocationDecider;
 import org.elasticsearch.cluster.service.InternalClusterService;
 import org.elasticsearch.common.logging.ESLoggerFactory;
+import org.elasticsearch.common.network.NetworkModule;
+import org.elasticsearch.common.network.NetworkService;
 import org.elasticsearch.common.util.concurrent.EsExecutors;
+import org.elasticsearch.common.util.concurrent.ThreadContext;
 import org.elasticsearch.discovery.DiscoveryModule;
 import org.elasticsearch.discovery.DiscoveryService;
-import org.elasticsearch.common.network.NetworkModule;
-import org.elasticsearch.common.network.NetworkService;
 import org.elasticsearch.discovery.DiscoverySettings;
 import org.elasticsearch.discovery.zen.ZenDiscovery;
 import org.elasticsearch.discovery.zen.elect.ElectMasterService;
-import org.elasticsearch.env.Environment;
-import org.elasticsearch.gateway.GatewayService;
 import org.elasticsearch.discovery.zen.fd.FaultDetection;
 import org.elasticsearch.discovery.zen.ping.unicast.UnicastZenPing;
+import org.elasticsearch.env.Environment;
+import org.elasticsearch.gateway.GatewayService;
 import org.elasticsearch.gateway.PrimaryShardAllocator;
 import org.elasticsearch.http.netty.NettyHttpServerTransport;
 import org.elasticsearch.index.IndexSettings;
@@ -75,220 +76,229 @@ import org.elasticsearch.search.SearchService;
 import org.elasticsearch.threadpool.ThreadPool;
 import org.elasticsearch.transport.Transport;
 import org.elasticsearch.transport.TransportService;
+import org.elasticsearch.transport.TransportSettings;
+import org.elasticsearch.transport.netty.NettyTransport;
 
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashSet;
+import java.util.Map;
 import java.util.Set;
-import java.util.function.Predicate;
 
 /**
  * Encapsulates all valid cluster level settings.
  */
 public final class ClusterSettings extends AbstractScopedSettings {
-    public ClusterSettings(Settings nodeSettings, Set<Setting<?>> settingsSet) {
-        super(nodeSettings, settingsSet, Setting.Scope.CLUSTER);
-        addSettingsUpdater(new LoggingSettingUpdater(nodeSettings));
-    }
-
-    private static final class LoggingSettingUpdater implements SettingUpdater<Settings> {
-        final Predicate<String> loggerPredicate = ESLoggerFactory.LOG_LEVEL_SETTING::match;
-        private final Settings settings;
-
-        LoggingSettingUpdater(Settings settings) {
-            this.settings = settings;
-        }
 
-        @Override
-        public boolean hasChanged(Settings current, Settings previous) {
-            return current.filter(loggerPredicate).getAsMap().equals(previous.filter(loggerPredicate).getAsMap()) == false;
-        }
+    public ClusterSettings(Settings settings, Set<Setting<?>> settingsSet) {
+        super(settings, settingsSet, Setting.Scope.CLUSTER);
+    }
 
-        @Override
-        public Settings getValue(Settings current, Settings previous) {
-            Settings.Builder builder = Settings.builder();
-            builder.put(current.filter(loggerPredicate).getAsMap());
-            for (String key : previous.getAsMap().keySet()) {
-                if (loggerPredicate.test(key) && builder.internalMap().containsKey(key) == false) {
-                    if (ESLoggerFactory.LOG_LEVEL_SETTING.getConcreteSetting(key).exists(settings) == false) {
-                        builder.putNull(key);
+    @Override
+    public synchronized Settings applySettings(Settings newSettings) {
+        Settings settings = super.applySettings(newSettings);
+        try {
+            for (Map.Entry<String, String> entry : settings.getAsMap().entrySet()) {
+                if (entry.getKey().startsWith("logger.")) {
+                    String component = entry.getKey().substring("logger.".length());
+                    if ("_root".equals(component)) {
+                        ESLoggerFactory.getRootLogger().setLevel(entry.getValue());
                     } else {
-                        builder.put(key, ESLoggerFactory.LOG_LEVEL_SETTING.getConcreteSetting(key).get(settings).name());
+                        ESLoggerFactory.getLogger(component).setLevel(entry.getValue());
                     }
                 }
             }
-            return builder.build();
+        } catch (Exception e) {
+            logger.warn("failed to refresh settings for [{}]", e, "logger");
         }
+        return settings;
+    }
+
+    @Override
+    public boolean hasDynamicSetting(String key) {
+        return isLoggerSetting(key) || super.hasDynamicSetting(key);
+    }
+
+    /**
+     * Returns <code>true</code> if the settings is a logger setting.
+     */
+    public boolean isLoggerSetting(String key) {
+        return key.startsWith("logger.");
+    }
 
-        @Override
-        public void apply(Settings value, Settings current, Settings previous) {
-            for (String key : value.getAsMap().keySet()) {
-                assert loggerPredicate.test(key);
-                String component = key.substring("logger.".length());
-                if ("_root".equals(component)) {
-                    final String rootLevel = value.get(key);
-                    ESLoggerFactory.getRootLogger().setLevel(rootLevel == null ? ESLoggerFactory.LOG_DEFAULT_LEVEL_SETTING.get(settings).name() : rootLevel);
-                } else {
-                    ESLoggerFactory.getLogger(component).setLevel(value.get(key));
-                }
-            }
-        }
-    };
 
-    public static Set<Setting<?>> BUILT_IN_CLUSTER_SETTINGS = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(AwarenessAllocationDecider.CLUSTER_ROUTING_ALLOCATION_AWARENESS_ATTRIBUTE_SETTING,
-        TransportClientNodesService.CLIENT_TRANSPORT_NODES_SAMPLER_INTERVAL, // TODO these transport client settings are kind of odd here and should only be valid if we are a transport client
-        TransportClientNodesService.CLIENT_TRANSPORT_PING_TIMEOUT,
-        TransportClientNodesService.CLIENT_TRANSPORT_IGNORE_CLUSTER_NAME,
-        AwarenessAllocationDecider.CLUSTER_ROUTING_ALLOCATION_AWARENESS_FORCE_GROUP_SETTING,
-        BalancedShardsAllocator.INDEX_BALANCE_FACTOR_SETTING,
-        BalancedShardsAllocator.SHARD_BALANCE_FACTOR_SETTING,
-        BalancedShardsAllocator.THRESHOLD_SETTING,
-        ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE_SETTING,
-        ConcurrentRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_CLUSTER_CONCURRENT_REBALANCE_SETTING,
-        EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING,
-        EnableAllocationDecider.CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING,
-        ZenDiscovery.REJOIN_ON_MASTER_GONE_SETTING,
-        FilterAllocationDecider.CLUSTER_ROUTING_INCLUDE_GROUP_SETTING,
-        FilterAllocationDecider.CLUSTER_ROUTING_EXCLUDE_GROUP_SETTING,
-        FilterAllocationDecider.CLUSTER_ROUTING_REQUIRE_GROUP_SETTING,
-        FsRepository.REPOSITORIES_CHUNK_SIZE_SETTING,
-        FsRepository.REPOSITORIES_COMPRESS_SETTING,
-        FsRepository.REPOSITORIES_LOCATION_SETTING,
-        IndexStoreConfig.INDICES_STORE_THROTTLE_TYPE_SETTING,
-        IndexStoreConfig.INDICES_STORE_THROTTLE_MAX_BYTES_PER_SEC_SETTING,
-        IndicesQueryCache.INDICES_CACHE_QUERY_SIZE_SETTING,
-        IndicesQueryCache.INDICES_CACHE_QUERY_COUNT_SETTING,
-        IndicesTTLService.INDICES_TTL_INTERVAL_SETTING,
-        MappingUpdatedAction.INDICES_MAPPING_DYNAMIC_TIMEOUT_SETTING,
-        MetaData.SETTING_READ_ONLY_SETTING,
-        RecoverySettings.INDICES_RECOVERY_MAX_BYTES_PER_SEC_SETTING,
-        RecoverySettings.INDICES_RECOVERY_RETRY_DELAY_STATE_SYNC_SETTING,
-        RecoverySettings.INDICES_RECOVERY_RETRY_DELAY_NETWORK_SETTING,
-        RecoverySettings.INDICES_RECOVERY_ACTIVITY_TIMEOUT_SETTING,
-        RecoverySettings.INDICES_RECOVERY_INTERNAL_ACTION_TIMEOUT_SETTING,
-        RecoverySettings.INDICES_RECOVERY_INTERNAL_LONG_ACTION_TIMEOUT_SETTING,
-        ThreadPool.THREADPOOL_GROUP_SETTING,
-        ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_INITIAL_PRIMARIES_RECOVERIES_SETTING,
-        ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_INCOMING_RECOVERIES_SETTING,
-        ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_OUTGOING_RECOVERIES_SETTING,
-        ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES_SETTING,
-        DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING,
-        DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING,
-        DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED_SETTING,
-        DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_INCLUDE_RELOCATIONS_SETTING,
-        DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_REROUTE_INTERVAL_SETTING,
-        InternalClusterInfoService.INTERNAL_CLUSTER_INFO_UPDATE_INTERVAL_SETTING,
-        InternalClusterInfoService.INTERNAL_CLUSTER_INFO_TIMEOUT_SETTING,
-        SnapshotInProgressAllocationDecider.CLUSTER_ROUTING_ALLOCATION_SNAPSHOT_RELOCATION_ENABLED_SETTING,
-        DestructiveOperations.REQUIRES_NAME_SETTING,
-        DiscoverySettings.PUBLISH_TIMEOUT_SETTING,
-        DiscoverySettings.PUBLISH_DIFF_ENABLE_SETTING,
-        DiscoverySettings.COMMIT_TIMEOUT_SETTING,
-        DiscoverySettings.NO_MASTER_BLOCK_SETTING,
-        GatewayService.EXPECTED_DATA_NODES_SETTING,
-        GatewayService.EXPECTED_MASTER_NODES_SETTING,
-        GatewayService.EXPECTED_NODES_SETTING,
-        GatewayService.RECOVER_AFTER_DATA_NODES_SETTING,
-        GatewayService.RECOVER_AFTER_MASTER_NODES_SETTING,
-        GatewayService.RECOVER_AFTER_NODES_SETTING,
-        GatewayService.RECOVER_AFTER_TIME_SETTING,
-        NetworkModule.HTTP_ENABLED,
-        NettyHttpServerTransport.SETTING_CORS_ALLOW_CREDENTIALS,
-        NettyHttpServerTransport.SETTING_CORS_ENABLED,
-        NettyHttpServerTransport.SETTING_CORS_MAX_AGE,
-        NettyHttpServerTransport.SETTING_HTTP_DETAILED_ERRORS_ENABLED,
-        NettyHttpServerTransport.SETTING_PIPELINING,
-        HierarchyCircuitBreakerService.TOTAL_CIRCUIT_BREAKER_LIMIT_SETTING,
-        HierarchyCircuitBreakerService.FIELDDATA_CIRCUIT_BREAKER_LIMIT_SETTING,
-        HierarchyCircuitBreakerService.FIELDDATA_CIRCUIT_BREAKER_OVERHEAD_SETTING,
-        HierarchyCircuitBreakerService.REQUEST_CIRCUIT_BREAKER_LIMIT_SETTING,
-        HierarchyCircuitBreakerService.REQUEST_CIRCUIT_BREAKER_OVERHEAD_SETTING,
-        InternalClusterService.CLUSTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING,
-        SearchService.DEFAULT_SEARCH_TIMEOUT_SETTING,
-        ElectMasterService.DISCOVERY_ZEN_MINIMUM_MASTER_NODES_SETTING,
-        TransportService.TRACE_LOG_EXCLUDE_SETTING,
-        TransportService.TRACE_LOG_INCLUDE_SETTING,
-        TransportCloseIndexAction.CLUSTER_INDICES_CLOSE_ENABLE_SETTING,
-        ShardsLimitAllocationDecider.CLUSTER_TOTAL_SHARDS_PER_NODE_SETTING,
-        InternalClusterService.CLUSTER_SERVICE_RECONNECT_INTERVAL_SETTING,
-        HierarchyCircuitBreakerService.FIELDDATA_CIRCUIT_BREAKER_TYPE_SETTING,
-        HierarchyCircuitBreakerService.REQUEST_CIRCUIT_BREAKER_TYPE_SETTING,
-        Transport.TRANSPORT_PROFILES_SETTING,
-        Transport.TRANSPORT_TCP_COMPRESS,
-        NetworkService.GLOBAL_NETWORK_HOST_SETTING,
-        NetworkService.GLOBAL_NETWORK_BINDHOST_SETTING,
-        NetworkService.GLOBAL_NETWORK_PUBLISHHOST_SETTING,
-        NetworkService.TcpSettings.TCP_NO_DELAY,
-        NetworkService.TcpSettings.TCP_KEEP_ALIVE,
-        NetworkService.TcpSettings.TCP_REUSE_ADDRESS,
-        NetworkService.TcpSettings.TCP_SEND_BUFFER_SIZE,
-        NetworkService.TcpSettings.TCP_RECEIVE_BUFFER_SIZE,
-        NetworkService.TcpSettings.TCP_BLOCKING,
-        NetworkService.TcpSettings.TCP_BLOCKING_SERVER,
-        NetworkService.TcpSettings.TCP_BLOCKING_CLIENT,
-        NetworkService.TcpSettings.TCP_CONNECT_TIMEOUT,
-        IndexSettings.QUERY_STRING_ANALYZE_WILDCARD,
-        IndexSettings.QUERY_STRING_ALLOW_LEADING_WILDCARD,
-        PrimaryShardAllocator.NODE_INITIAL_SHARDS_SETTING,
-        ScriptService.SCRIPT_CACHE_SIZE_SETTING,
-        IndicesFieldDataCache.INDICES_FIELDDATA_CLEAN_INTERVAL_SETTING,
-        IndicesFieldDataCache.INDICES_FIELDDATA_CACHE_SIZE_KEY,
-        IndicesRequestCache.INDICES_CACHE_QUERY_SIZE,
-        IndicesRequestCache.INDICES_CACHE_QUERY_EXPIRE,
-        HunspellService.HUNSPELL_LAZY_LOAD,
-        HunspellService.HUNSPELL_IGNORE_CASE,
-        HunspellService.HUNSPELL_DICTIONARY_OPTIONS,
-        IndicesStore.INDICES_STORE_DELETE_SHARD_TIMEOUT,
-        Environment.PATH_CONF_SETTING,
-        Environment.PATH_DATA_SETTING,
-        Environment.PATH_HOME_SETTING,
-        Environment.PATH_LOGS_SETTING,
-        Environment.PATH_PLUGINS_SETTING,
-        Environment.PATH_REPO_SETTING,
-        Environment.PATH_SCRIPTS_SETTING,
-        Environment.PATH_SHARED_DATA_SETTING,
-        Environment.PIDFILE_SETTING,
-        DiscoveryService.DISCOVERY_SEED_SETTING,
-        DiscoveryService.INITIAL_STATE_TIMEOUT_SETTING,
-        DiscoveryModule.DISCOVERY_TYPE_SETTING,
-        DiscoveryModule.ZEN_MASTER_SERVICE_TYPE_SETTING,
-        FaultDetection.PING_RETRIES_SETTING,
-        FaultDetection.PING_TIMEOUT_SETTING,
-        FaultDetection.REGISTER_CONNECTION_LISTENER_SETTING,
-        FaultDetection.PING_INTERVAL_SETTING,
-        FaultDetection.CONNECT_ON_NETWORK_DISCONNECT_SETTING,
-        ZenDiscovery.PING_TIMEOUT_SETTING,
-        ZenDiscovery.JOIN_TIMEOUT_SETTING,
-        ZenDiscovery.JOIN_RETRY_ATTEMPTS_SETTING,
-        ZenDiscovery.JOIN_RETRY_DELAY_SETTING,
-        ZenDiscovery.MAX_PINGS_FROM_ANOTHER_MASTER_SETTING,
-        ZenDiscovery.SEND_LEAVE_REQUEST_SETTING,
-        ZenDiscovery.MASTER_ELECTION_FILTER_CLIENT_SETTING,
-        ZenDiscovery.MASTER_ELECTION_WAIT_FOR_JOINS_TIMEOUT_SETTING,
-        ZenDiscovery.MASTER_ELECTION_FILTER_DATA_SETTING,
-        UnicastZenPing.DISCOVERY_ZEN_PING_UNICAST_HOSTS_SETTING,
-        UnicastZenPing.DISCOVERY_ZEN_PING_UNICAST_CONCURRENT_CONNECTS_SETTING,
-        SearchService.DEFAULT_KEEPALIVE_SETTING,
-        SearchService.KEEPALIVE_INTERVAL_SETTING,
-        Node.WRITE_PORTS_FIELD_SETTING,
-        Node.NODE_CLIENT_SETTING,
-        Node.NODE_DATA_SETTING,
-        Node.NODE_MASTER_SETTING,
-        Node.NODE_LOCAL_SETTING,
-        Node.NODE_MODE_SETTING,
-        Node.NODE_INGEST_SETTING,
-        URLRepository.ALLOWED_URLS_SETTING,
-        URLRepository.REPOSITORIES_LIST_DIRECTORIES_SETTING,
-        URLRepository.REPOSITORIES_URL_SETTING,
-        URLRepository.SUPPORTED_PROTOCOLS_SETTING,
-        TransportMasterNodeReadAction.FORCE_LOCAL_SETTING,
-        AutoCreateIndex.AUTO_CREATE_INDEX_SETTING,
-        BaseRestHandler.MULTI_ALLOW_EXPLICIT_INDEX,
-        ClusterName.CLUSTER_NAME_SETTING,
-        Client.CLIENT_TYPE_SETTING_S,
-        InternalSettingsPreparer.IGNORE_SYSTEM_PROPERTIES_SETTING,
-        ClusterModule.SHARDS_ALLOCATOR_TYPE_SETTING,
-        EsExecutors.PROCESSORS_SETTING,
-        ESLoggerFactory.LOG_DEFAULT_LEVEL_SETTING,
-        ESLoggerFactory.LOG_LEVEL_SETTING)));
+    public static Set<Setting<?>> BUILT_IN_CLUSTER_SETTINGS = Collections.unmodifiableSet(new HashSet<>(
+            Arrays.asList(AwarenessAllocationDecider.CLUSTER_ROUTING_ALLOCATION_AWARENESS_ATTRIBUTE_SETTING,
+                    TransportClientNodesService.CLIENT_TRANSPORT_NODES_SAMPLER_INTERVAL, // TODO these transport client settings are kind of odd here and should only be valid if we are a transport client
+                    TransportClientNodesService.CLIENT_TRANSPORT_PING_TIMEOUT,
+                    TransportClientNodesService.CLIENT_TRANSPORT_IGNORE_CLUSTER_NAME,
+                    AwarenessAllocationDecider.CLUSTER_ROUTING_ALLOCATION_AWARENESS_FORCE_GROUP_SETTING,
+                    BalancedShardsAllocator.INDEX_BALANCE_FACTOR_SETTING,
+                    BalancedShardsAllocator.SHARD_BALANCE_FACTOR_SETTING,
+                    BalancedShardsAllocator.THRESHOLD_SETTING,
+                    ClusterRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE_SETTING,
+                    ConcurrentRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_CLUSTER_CONCURRENT_REBALANCE_SETTING,
+                    EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING,
+                    EnableAllocationDecider.CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING,
+                    ZenDiscovery.REJOIN_ON_MASTER_GONE_SETTING,
+                    FilterAllocationDecider.CLUSTER_ROUTING_INCLUDE_GROUP_SETTING,
+                    FilterAllocationDecider.CLUSTER_ROUTING_EXCLUDE_GROUP_SETTING,
+                    FilterAllocationDecider.CLUSTER_ROUTING_REQUIRE_GROUP_SETTING,
+                    FsRepository.REPOSITORIES_CHUNK_SIZE_SETTING,
+                    FsRepository.REPOSITORIES_COMPRESS_SETTING,
+                    FsRepository.REPOSITORIES_LOCATION_SETTING,
+                    IndexStoreConfig.INDICES_STORE_THROTTLE_TYPE_SETTING,
+                    IndexStoreConfig.INDICES_STORE_THROTTLE_MAX_BYTES_PER_SEC_SETTING,
+                    IndicesQueryCache.INDICES_CACHE_QUERY_SIZE_SETTING,
+                    IndicesQueryCache.INDICES_CACHE_QUERY_COUNT_SETTING,
+                    IndicesTTLService.INDICES_TTL_INTERVAL_SETTING,
+                    MappingUpdatedAction.INDICES_MAPPING_DYNAMIC_TIMEOUT_SETTING,
+                    MetaData.SETTING_READ_ONLY_SETTING,
+                    RecoverySettings.INDICES_RECOVERY_MAX_BYTES_PER_SEC_SETTING,
+                    RecoverySettings.INDICES_RECOVERY_RETRY_DELAY_STATE_SYNC_SETTING,
+                    RecoverySettings.INDICES_RECOVERY_RETRY_DELAY_NETWORK_SETTING,
+                    RecoverySettings.INDICES_RECOVERY_ACTIVITY_TIMEOUT_SETTING,
+                    RecoverySettings.INDICES_RECOVERY_INTERNAL_ACTION_TIMEOUT_SETTING,
+                    RecoverySettings.INDICES_RECOVERY_INTERNAL_LONG_ACTION_TIMEOUT_SETTING,
+                    ThreadPool.THREADPOOL_GROUP_SETTING,
+                    ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_INITIAL_PRIMARIES_RECOVERIES_SETTING,
+                    ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_INCOMING_RECOVERIES_SETTING,
+                    ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_OUTGOING_RECOVERIES_SETTING,
+                    ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES_SETTING,
+                    DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING,
+                    DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING,
+                    DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED_SETTING,
+                    DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_INCLUDE_RELOCATIONS_SETTING,
+                    DiskThresholdDecider.CLUSTER_ROUTING_ALLOCATION_REROUTE_INTERVAL_SETTING,
+                    InternalClusterInfoService.INTERNAL_CLUSTER_INFO_UPDATE_INTERVAL_SETTING,
+                    InternalClusterInfoService.INTERNAL_CLUSTER_INFO_TIMEOUT_SETTING,
+                    SnapshotInProgressAllocationDecider.CLUSTER_ROUTING_ALLOCATION_SNAPSHOT_RELOCATION_ENABLED_SETTING,
+                    DestructiveOperations.REQUIRES_NAME_SETTING,
+                    DiscoverySettings.PUBLISH_TIMEOUT_SETTING,
+                    DiscoverySettings.PUBLISH_DIFF_ENABLE_SETTING,
+                    DiscoverySettings.COMMIT_TIMEOUT_SETTING,
+                    DiscoverySettings.NO_MASTER_BLOCK_SETTING,
+                    GatewayService.EXPECTED_DATA_NODES_SETTING,
+                    GatewayService.EXPECTED_MASTER_NODES_SETTING,
+                    GatewayService.EXPECTED_NODES_SETTING,
+                    GatewayService.RECOVER_AFTER_DATA_NODES_SETTING,
+                    GatewayService.RECOVER_AFTER_MASTER_NODES_SETTING,
+                    GatewayService.RECOVER_AFTER_NODES_SETTING,
+                    GatewayService.RECOVER_AFTER_TIME_SETTING,
+                    NetworkModule.HTTP_ENABLED,
+                    NettyHttpServerTransport.SETTING_CORS_ALLOW_CREDENTIALS,
+                    NettyHttpServerTransport.SETTING_CORS_ENABLED,
+                    NettyHttpServerTransport.SETTING_CORS_MAX_AGE,
+                    NettyHttpServerTransport.SETTING_HTTP_DETAILED_ERRORS_ENABLED,
+                    NettyHttpServerTransport.SETTING_PIPELINING,
+                    HierarchyCircuitBreakerService.TOTAL_CIRCUIT_BREAKER_LIMIT_SETTING,
+                    HierarchyCircuitBreakerService.FIELDDATA_CIRCUIT_BREAKER_LIMIT_SETTING,
+                    HierarchyCircuitBreakerService.FIELDDATA_CIRCUIT_BREAKER_OVERHEAD_SETTING,
+                    HierarchyCircuitBreakerService.REQUEST_CIRCUIT_BREAKER_LIMIT_SETTING,
+                    HierarchyCircuitBreakerService.REQUEST_CIRCUIT_BREAKER_OVERHEAD_SETTING,
+                    InternalClusterService.CLUSTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD_SETTING,
+                    SearchService.DEFAULT_SEARCH_TIMEOUT_SETTING,
+                    ElectMasterService.DISCOVERY_ZEN_MINIMUM_MASTER_NODES_SETTING,
+                    TransportService.TRACE_LOG_EXCLUDE_SETTING,
+                    TransportService.TRACE_LOG_INCLUDE_SETTING,
+                    TransportCloseIndexAction.CLUSTER_INDICES_CLOSE_ENABLE_SETTING,
+                    ShardsLimitAllocationDecider.CLUSTER_TOTAL_SHARDS_PER_NODE_SETTING,
+                    InternalClusterService.CLUSTER_SERVICE_RECONNECT_INTERVAL_SETTING,
+                    HierarchyCircuitBreakerService.FIELDDATA_CIRCUIT_BREAKER_TYPE_SETTING,
+                    HierarchyCircuitBreakerService.REQUEST_CIRCUIT_BREAKER_TYPE_SETTING,
+                    Transport.TRANSPORT_TCP_COMPRESS,
+                    TransportSettings.TRANSPORT_PROFILES_SETTING,
+                    TransportSettings.PORT,
+                    NettyTransport.WORKER_COUNT,
+                    NettyTransport.CONNECTIONS_PER_NODE_RECOVERY,
+                    NettyTransport.CONNECTIONS_PER_NODE_BULK,
+                    NettyTransport.CONNECTIONS_PER_NODE_REG,
+                    NettyTransport.CONNECTIONS_PER_NODE_STATE,
+                    NettyTransport.CONNECTIONS_PER_NODE_PING,
+                    NettyTransport.PING_SCHEDULE,
+                    NettyTransport.TCP_BLOCKING_CLIENT,
+                    NettyTransport.TCP_CONNECT_TIMEOUT,
+                    NettyTransport.NETTY_MAX_CUMULATION_BUFFER_CAPACITY,
+                    NettyTransport.NETTY_MAX_COMPOSITE_BUFFER_COMPONENTS,
+                    NettyTransport.NETTY_RECEIVE_PREDICTOR_SIZE,
+                    NettyTransport.NETTY_RECEIVE_PREDICTOR_MIN,
+                    NettyTransport.NETTY_RECEIVE_PREDICTOR_MAX,
+                    NettyTransport.NETWORK_SERVER,
+                    NettyTransport.NETTY_BOSS_COUNT,
+                    NetworkService.GLOBAL_NETWORK_HOST_SETTING,
+                    NetworkService.GLOBAL_NETWORK_BINDHOST_SETTING,
+                    NetworkService.GLOBAL_NETWORK_PUBLISHHOST_SETTING,
+                    NetworkService.TcpSettings.TCP_NO_DELAY,
+                    NetworkService.TcpSettings.TCP_KEEP_ALIVE,
+                    NetworkService.TcpSettings.TCP_REUSE_ADDRESS,
+                    NetworkService.TcpSettings.TCP_SEND_BUFFER_SIZE,
+                    NetworkService.TcpSettings.TCP_RECEIVE_BUFFER_SIZE,
+                    NetworkService.TcpSettings.TCP_BLOCKING,
+                    NetworkService.TcpSettings.TCP_BLOCKING_SERVER,
+                    NetworkService.TcpSettings.TCP_BLOCKING_CLIENT,
+                    NetworkService.TcpSettings.TCP_CONNECT_TIMEOUT,
+                    IndexSettings.QUERY_STRING_ANALYZE_WILDCARD,
+                    IndexSettings.QUERY_STRING_ALLOW_LEADING_WILDCARD,
+                    PrimaryShardAllocator.NODE_INITIAL_SHARDS_SETTING,
+                    ScriptService.SCRIPT_CACHE_SIZE_SETTING,
+                    IndicesFieldDataCache.INDICES_FIELDDATA_CLEAN_INTERVAL_SETTING,
+                    IndicesFieldDataCache.INDICES_FIELDDATA_CACHE_SIZE_KEY,
+                    IndicesRequestCache.INDICES_CACHE_QUERY_SIZE,
+                    IndicesRequestCache.INDICES_CACHE_QUERY_EXPIRE,
+                    IndicesRequestCache.INDICES_CACHE_REQUEST_CLEAN_INTERVAL,
+                    HunspellService.HUNSPELL_LAZY_LOAD,
+                    HunspellService.HUNSPELL_IGNORE_CASE,
+                    HunspellService.HUNSPELL_DICTIONARY_OPTIONS,
+                    IndicesStore.INDICES_STORE_DELETE_SHARD_TIMEOUT,
+                    Environment.PATH_CONF_SETTING,
+                    Environment.PATH_DATA_SETTING,
+                    Environment.PATH_HOME_SETTING,
+                    Environment.PATH_LOGS_SETTING,
+                    Environment.PATH_PLUGINS_SETTING,
+                    Environment.PATH_REPO_SETTING,
+                    Environment.PATH_SCRIPTS_SETTING,
+                    Environment.PATH_SHARED_DATA_SETTING,
+                    Environment.PIDFILE_SETTING,
+                    DiscoveryService.DISCOVERY_SEED_SETTING,
+                    DiscoveryService.INITIAL_STATE_TIMEOUT_SETTING,
+                    DiscoveryModule.DISCOVERY_TYPE_SETTING,
+                    DiscoveryModule.ZEN_MASTER_SERVICE_TYPE_SETTING,
+                    FaultDetection.PING_RETRIES_SETTING,
+                    FaultDetection.PING_TIMEOUT_SETTING,
+                    FaultDetection.REGISTER_CONNECTION_LISTENER_SETTING,
+                    FaultDetection.PING_INTERVAL_SETTING,
+                    FaultDetection.CONNECT_ON_NETWORK_DISCONNECT_SETTING,
+                    ZenDiscovery.PING_TIMEOUT_SETTING,
+                    ZenDiscovery.JOIN_TIMEOUT_SETTING,
+                    ZenDiscovery.JOIN_RETRY_ATTEMPTS_SETTING,
+                    ZenDiscovery.JOIN_RETRY_DELAY_SETTING,
+                    ZenDiscovery.MAX_PINGS_FROM_ANOTHER_MASTER_SETTING,
+                    ZenDiscovery.SEND_LEAVE_REQUEST_SETTING,
+                    ZenDiscovery.MASTER_ELECTION_FILTER_CLIENT_SETTING,
+                    ZenDiscovery.MASTER_ELECTION_WAIT_FOR_JOINS_TIMEOUT_SETTING,
+                    ZenDiscovery.MASTER_ELECTION_FILTER_DATA_SETTING,
+                    UnicastZenPing.DISCOVERY_ZEN_PING_UNICAST_HOSTS_SETTING,
+                    UnicastZenPing.DISCOVERY_ZEN_PING_UNICAST_CONCURRENT_CONNECTS_SETTING,
+                    SearchService.DEFAULT_KEEPALIVE_SETTING,
+                    SearchService.KEEPALIVE_INTERVAL_SETTING,
+                    Node.WRITE_PORTS_FIELD_SETTING,
+                    Node.NODE_CLIENT_SETTING,
+                    Node.NODE_DATA_SETTING,
+                    Node.NODE_MASTER_SETTING,
+                    Node.NODE_LOCAL_SETTING,
+                    Node.NODE_MODE_SETTING,
+                    Node.NODE_INGEST_SETTING,
+                    URLRepository.ALLOWED_URLS_SETTING,
+                    URLRepository.REPOSITORIES_LIST_DIRECTORIES_SETTING,
+                    URLRepository.REPOSITORIES_URL_SETTING,
+                    URLRepository.SUPPORTED_PROTOCOLS_SETTING,
+                    TransportMasterNodeReadAction.FORCE_LOCAL_SETTING,
+                    AutoCreateIndex.AUTO_CREATE_INDEX_SETTING,
+                    BaseRestHandler.MULTI_ALLOW_EXPLICIT_INDEX,
+                    ClusterName.CLUSTER_NAME_SETTING,
+                    Client.CLIENT_TYPE_SETTING_S,
+                    InternalSettingsPreparer.IGNORE_SYSTEM_PROPERTIES_SETTING,
+                    ClusterModule.SHARDS_ALLOCATOR_TYPE_SETTING,
+                    EsExecutors.PROCESSORS_SETTING,
+                    ThreadContext.DEFAULT_HEADERS_SETTING)));
 }
diff --git a/core/src/main/java/org/elasticsearch/common/settings/Setting.java b/core/src/main/java/org/elasticsearch/common/settings/Setting.java
index f8f7d4b..a76c5c7 100644
--- a/core/src/main/java/org/elasticsearch/common/settings/Setting.java
+++ b/core/src/main/java/org/elasticsearch/common/settings/Setting.java
@@ -111,7 +111,7 @@ public class Setting<T> extends ToXContentToBytes {
      * rather than a single value. The key, see {@link #getKey()}, in contrast to non-group settings is a prefix like <tt>cluster.store.</tt>
      * that matches all settings with this prefix.
      */
-    protected boolean isGroupSetting() {
+    boolean isGroupSetting() {
         return false;
     }
 
@@ -200,10 +200,6 @@ public class Setting<T> extends ToXContentToBytes {
         return get(secondary);
     }
 
-    public Setting<T> getConcreteSetting(String key) {
-        return this;
-    }
-
     /**
      * The settings scope - settings can either be cluster settings or per index settings.
      */
@@ -372,7 +368,15 @@ public class Setting<T> extends ToXContentToBytes {
     }
 
     public static Setting<ByteSizeValue> byteSizeSetting(String key, ByteSizeValue value, boolean dynamic, Scope scope) {
-        return new Setting<>(key, (s) -> value.toString(), (s) -> ByteSizeValue.parseBytesSizeValue(s, key), dynamic, scope);
+        return byteSizeSetting(key, (s) -> value.toString(), dynamic, scope);
+    }
+
+    public static Setting<ByteSizeValue> byteSizeSetting(String key, Setting<ByteSizeValue> fallbackSettings, boolean dynamic, Scope scope) {
+        return byteSizeSetting(key, fallbackSettings::getRaw, dynamic, scope);
+    }
+
+    public static Setting<ByteSizeValue> byteSizeSetting(String key, Function<Settings, String> defaultValue, boolean dynamic, Scope scope) {
+        return new Setting<>(key, defaultValue, (s) -> ByteSizeValue.parseBytesSizeValue(s, key), dynamic, scope);
     }
 
     public static Setting<TimeValue> positiveTimeSetting(String key, TimeValue defaultValue, boolean dynamic, Scope scope) {
@@ -525,7 +529,11 @@ public class Setting<T> extends ToXContentToBytes {
     }
 
     public static Setting<TimeValue> timeSetting(String key, TimeValue defaultValue, boolean dynamic, Scope scope) {
-        return new Setting<>(key, (s) -> defaultValue.toString(), (s) -> TimeValue.parseTimeValue(s, defaultValue, key), dynamic, scope);
+        return new Setting<>(key, (s) -> defaultValue.toString(), (s) -> TimeValue.parseTimeValue(s, key), dynamic, scope);
+    }
+
+    public static Setting<TimeValue> timeSetting(String key, Setting<TimeValue> fallbackSetting, boolean dynamic, Scope scope) {
+        return new Setting<>(key, fallbackSetting::getRaw, (s) -> TimeValue.parseTimeValue(s, key), dynamic, scope);
     }
 
     public static Setting<Double> doubleSetting(String key, double defaultValue, double minValue, boolean dynamic, Scope scope) {
diff --git a/core/src/main/java/org/elasticsearch/common/unit/TimeValue.java b/core/src/main/java/org/elasticsearch/common/unit/TimeValue.java
index b1081c2..bbe1fbb 100644
--- a/core/src/main/java/org/elasticsearch/common/unit/TimeValue.java
+++ b/core/src/main/java/org/elasticsearch/common/unit/TimeValue.java
@@ -250,6 +250,12 @@ public class TimeValue implements Streamable {
         }
     }
 
+    public static TimeValue parseTimeValue(String sValue, String settingName) {
+        Objects.requireNonNull(settingName);
+        Objects.requireNonNull(sValue);
+        return parseTimeValue(sValue, null, settingName);
+    }
+
     public static TimeValue parseTimeValue(String sValue, TimeValue defaultValue, String settingName) {
         settingName = Objects.requireNonNull(settingName);
         if (sValue == null) {
diff --git a/core/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java b/core/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java
index 5ad4b76..1928392 100644
--- a/core/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java
+++ b/core/src/main/java/org/elasticsearch/common/util/concurrent/ThreadContext.java
@@ -23,6 +23,7 @@ import org.elasticsearch.common.collect.Iterators;
 import org.elasticsearch.common.io.stream.StreamInput;
 import org.elasticsearch.common.io.stream.StreamOutput;
 import org.elasticsearch.common.io.stream.Writeable;
+import org.elasticsearch.common.settings.Setting;
 import org.elasticsearch.common.settings.Settings;
 
 import java.io.Closeable;
@@ -62,6 +63,7 @@ import java.util.concurrent.atomic.AtomicBoolean;
 public final class ThreadContext implements Closeable, Writeable<ThreadContext.ThreadContextStruct>{
 
     public static final String PREFIX = "request.headers";
+    public static final Setting<Settings> DEFAULT_HEADERS_SETTING = Setting.groupSetting(PREFIX + ".", false, Setting.Scope.CLUSTER);
     private final Map<String, String> defaultHeader;
     private static final ThreadContextStruct DEFAULT_CONTEXT = new ThreadContextStruct(Collections.emptyMap());
     private final ContextThreadLocal threadLocal;
@@ -71,7 +73,7 @@ public final class ThreadContext implements Closeable, Writeable<ThreadContext.T
      * @param settings the settings to read the default request headers from
      */
     public ThreadContext(Settings settings) {
-        Settings headers = settings.getAsSettings(PREFIX);
+        Settings headers = DEFAULT_HEADERS_SETTING.get(settings);
         if (headers == null) {
             this.defaultHeader = Collections.emptyMap();
         } else {
diff --git a/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java
index 73ba9d0..03c7e4e 100644
--- a/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java
+++ b/core/src/main/java/org/elasticsearch/index/shard/IndexShard.java
@@ -854,6 +854,10 @@ public class IndexShard extends AbstractIndexShardComponent {
         if (state != IndexShardState.RECOVERING) {
             throw new IndexShardNotRecoveringException(shardId, state);
         }
+        // We set active because we are now writing operations to the engine; this way, if we go idle after some time and become inactive,
+        // we still invoke any onShardInactive listeners ... we won't sync'd flush in this case because we only do that on primary and this
+        // is a replica
+        active.set(true);
         return engineConfig.getTranslogRecoveryPerformer().performBatchRecovery(getEngine(), operations);
     }
 
@@ -883,6 +887,11 @@ public class IndexShard extends AbstractIndexShardComponent {
         // but we need to make sure we don't loose deletes until we are done recovering
         engineConfig.setEnableGcDeletes(false);
         engineConfig.setCreate(indexExists == false);
+        if (skipTranslogRecovery == false) {
+            // We set active because we are now writing operations to the engine; this way, if we go idle after some time and become inactive,
+            // we still give sync'd flush a chance to run:
+            active.set(true);
+        }
         createNewEngine(skipTranslogRecovery, engineConfig);
 
     }
@@ -1043,6 +1052,10 @@ public class IndexShard extends AbstractIndexShardComponent {
         MetaDataStateFormat.deleteMetaState(shardPath().getDataPath());
     }
 
+    public boolean isActive() {
+        return active.get();
+    }
+
     public ShardPath shardPath() {
         return path;
     }
@@ -1302,6 +1315,15 @@ public class IndexShard extends AbstractIndexShardComponent {
             assert this.currentEngineReference.get() == null;
             this.currentEngineReference.set(newEngine(skipTranslogRecovery, config));
         }
+
+        // time elapses after the engine is created above (pulling the config settings) until we set the engine reference, during which
+        // settings changes could possibly have happened, so here we forcefully push any config changes to the new engine:
+        Engine engine = getEngineOrNull();
+
+        // engine could perhaps be null if we were e.g. concurrently closed:
+        if (engine != null) {
+            engine.onSettingsChanged();
+        }
     }
 
     protected Engine newEngine(boolean skipTranslogRecovery, EngineConfig config) {
diff --git a/core/src/main/java/org/elasticsearch/transport/Transport.java b/core/src/main/java/org/elasticsearch/transport/Transport.java
index 78b07e3..c930773 100644
--- a/core/src/main/java/org/elasticsearch/transport/Transport.java
+++ b/core/src/main/java/org/elasticsearch/transport/Transport.java
@@ -22,7 +22,6 @@ package org.elasticsearch.transport;
 import org.elasticsearch.cluster.node.DiscoveryNode;
 import org.elasticsearch.common.component.LifecycleComponent;
 import org.elasticsearch.common.settings.Setting;
-import org.elasticsearch.common.settings.Settings;
 import org.elasticsearch.common.transport.BoundTransportAddress;
 import org.elasticsearch.common.transport.TransportAddress;
 
@@ -36,7 +35,6 @@ import java.util.Map;
 public interface Transport extends LifecycleComponent<Transport> {
 
 
-    Setting<Settings> TRANSPORT_PROFILES_SETTING = Setting.groupSetting("transport.profiles.", true, Setting.Scope.CLUSTER);
     Setting<Boolean> TRANSPORT_TCP_COMPRESS = Setting.boolSetting("transport.tcp.compress", false, false, Setting.Scope.CLUSTER);
 
     void transportServiceAdapter(TransportServiceAdapter service);
diff --git a/core/src/main/java/org/elasticsearch/transport/TransportSettings.java b/core/src/main/java/org/elasticsearch/transport/TransportSettings.java
new file mode 100644
index 0000000..468e9b1
--- /dev/null
+++ b/core/src/main/java/org/elasticsearch/transport/TransportSettings.java
@@ -0,0 +1,37 @@
+/*
+ * Licensed to Elasticsearch under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.elasticsearch.transport;
+
+import org.elasticsearch.common.settings.Setting;
+import org.elasticsearch.common.settings.Settings;
+
+/**
+ * a collection of settings related to transport components, which are also needed in org.elasticsearch.bootstrap.Security
+ * This class should only contain static code which is *safe* to load before the security manager is enforced.
+ */
+final public class TransportSettings {
+
+    public static final Setting<String> PORT = new Setting<>("transport.tcp.port", "9300-9400", s -> s, false, Setting.Scope.CLUSTER);
+    public static final String DEFAULT_PROFILE = "default";
+    public static final Setting<Settings> TRANSPORT_PROFILES_SETTING = Setting.groupSetting("transport.profiles.", true, Setting.Scope.CLUSTER);
+
+    private TransportSettings() {
+
+    }
+}
diff --git a/core/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java b/core/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java
index f131ce1..a1ec7b2 100644
--- a/core/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java
+++ b/core/src/main/java/org/elasticsearch/transport/netty/NettyTransport.java
@@ -24,7 +24,6 @@ import org.elasticsearch.Version;
 import org.elasticsearch.cluster.node.DiscoveryNode;
 import org.elasticsearch.common.Booleans;
 import org.elasticsearch.common.Strings;
-import org.elasticsearch.common.SuppressForbidden;
 import org.elasticsearch.common.bytes.ReleasablePagedBytesReference;
 import org.elasticsearch.common.component.AbstractLifecycleComponent;
 import org.elasticsearch.common.compress.CompressorFactory;
@@ -40,7 +39,9 @@ import org.elasticsearch.common.netty.OpenChannelsHandler;
 import org.elasticsearch.common.netty.ReleaseChannelFutureListener;
 import org.elasticsearch.common.network.NetworkAddress;
 import org.elasticsearch.common.network.NetworkService;
+import org.elasticsearch.common.network.NetworkService.TcpSettings;
 import org.elasticsearch.common.network.NetworkUtils;
+import org.elasticsearch.common.settings.Setting;
 import org.elasticsearch.common.settings.Settings;
 import org.elasticsearch.common.transport.BoundTransportAddress;
 import org.elasticsearch.common.transport.InetSocketTransportAddress;
@@ -63,6 +64,7 @@ import org.elasticsearch.transport.TransportException;
 import org.elasticsearch.transport.TransportRequest;
 import org.elasticsearch.transport.TransportRequestOptions;
 import org.elasticsearch.transport.TransportServiceAdapter;
+import org.elasticsearch.transport.TransportSettings;
 import org.elasticsearch.transport.support.TransportStatus;
 import org.jboss.netty.bootstrap.ClientBootstrap;
 import org.jboss.netty.bootstrap.ServerBootstrap;
@@ -117,9 +119,7 @@ import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 import static java.util.Collections.unmodifiableMap;
-import static org.elasticsearch.common.network.NetworkService.TcpSettings.TCP_BLOCKING_CLIENT;
 import static org.elasticsearch.common.network.NetworkService.TcpSettings.TCP_BLOCKING_SERVER;
-import static org.elasticsearch.common.network.NetworkService.TcpSettings.TCP_CONNECT_TIMEOUT;
 import static org.elasticsearch.common.network.NetworkService.TcpSettings.TCP_KEEP_ALIVE;
 import static org.elasticsearch.common.network.NetworkService.TcpSettings.TCP_NO_DELAY;
 import static org.elasticsearch.common.network.NetworkService.TcpSettings.TCP_RECEIVE_BUFFER_SIZE;
@@ -148,16 +148,38 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
     public static final String TRANSPORT_CLIENT_WORKER_THREAD_NAME_PREFIX = "transport_client_worker";
     public static final String TRANSPORT_CLIENT_BOSS_THREAD_NAME_PREFIX = "transport_client_boss";
 
-    public static final String WORKER_COUNT = "transport.netty.worker_count";
-    public static final String CONNECTIONS_PER_NODE_RECOVERY = "transport.connections_per_node.recovery";
-    public static final String CONNECTIONS_PER_NODE_BULK = "transport.connections_per_node.bulk";
-    public static final String CONNECTIONS_PER_NODE_REG = "transport.connections_per_node.reg";
-    public static final String CONNECTIONS_PER_NODE_STATE = "transport.connections_per_node.state";
-    public static final String CONNECTIONS_PER_NODE_PING = "transport.connections_per_node.ping";
-    public static final String PING_SCHEDULE = "transport.ping_schedule"; // the scheduled internal ping interval setting
-    public static final TimeValue DEFAULT_PING_SCHEDULE = TimeValue.timeValueMillis(-1); // the default ping schedule, defaults to disabled (-1)
-    public static final String DEFAULT_PORT_RANGE = "9300-9400";
-    public static final String DEFAULT_PROFILE = "default";
+    public static final Setting<Integer> WORKER_COUNT = new Setting<>("transport.netty.worker_count",
+            (s) -> Integer.toString(EsExecutors.boundedNumberOfProcessors(s) * 2), (s) -> Setting.parseInt(s, 1, "transport.netty.worker_count"),
+            false, Setting.Scope.CLUSTER);
+    public static final Setting<Integer> CONNECTIONS_PER_NODE_RECOVERY = Setting.intSetting("transport.connections_per_node.recovery", 2, 1, false, Setting.Scope.CLUSTER);
+    public static final Setting<Integer> CONNECTIONS_PER_NODE_BULK = Setting.intSetting("transport.connections_per_node.bulk", 3, 1, false, Setting.Scope.CLUSTER);
+    public static final Setting<Integer> CONNECTIONS_PER_NODE_REG = Setting.intSetting("transport.connections_per_node.reg", 6, 1, false, Setting.Scope.CLUSTER);
+    public static final Setting<Integer> CONNECTIONS_PER_NODE_STATE = Setting.intSetting("transport.connections_per_node.state", 1, 1, false, Setting.Scope.CLUSTER);
+    public static final Setting<Integer> CONNECTIONS_PER_NODE_PING = Setting.intSetting("transport.connections_per_node.ping", 1, 1, false, Setting.Scope.CLUSTER);
+    // the scheduled internal ping interval setting, defaults to disabled (-1)
+    public static final Setting<TimeValue> PING_SCHEDULE = Setting.timeSetting("transport.ping_schedule", TimeValue.timeValueSeconds(-1), false, Setting.Scope.CLUSTER);
+    public static final Setting<Boolean> TCP_BLOCKING_CLIENT = Setting.boolSetting("transport." + TcpSettings.TCP_BLOCKING_CLIENT.getKey(), TcpSettings.TCP_BLOCKING_CLIENT, false, Setting.Scope.CLUSTER);
+    public static final Setting<TimeValue> TCP_CONNECT_TIMEOUT = Setting.timeSetting("transport." + TcpSettings.TCP_CONNECT_TIMEOUT.getKey(), TcpSettings.TCP_CONNECT_TIMEOUT, false, Setting.Scope.CLUSTER);
+    public static final Setting<ByteSizeValue> NETTY_MAX_CUMULATION_BUFFER_CAPACITY = Setting.byteSizeSetting("transport.netty.max_cumulation_buffer_capacity", new ByteSizeValue(-1), false, Setting.Scope.CLUSTER);
+    public static final Setting<Integer> NETTY_MAX_COMPOSITE_BUFFER_COMPONENTS = Setting.intSetting("transport.netty.max_composite_buffer_components", -1, -1, false, Setting.Scope.CLUSTER);
+
+
+    // See AdaptiveReceiveBufferSizePredictor#DEFAULT_XXX for default values in netty..., we can use higher ones for us, even fixed one
+    public static final Setting<ByteSizeValue> NETTY_RECEIVE_PREDICTOR_SIZE = Setting.byteSizeSetting("transport.netty.receive_predictor_size",
+            settings -> {
+                long defaultReceiverPredictor = 512 * 1024;
+                if (JvmInfo.jvmInfo().getMem().getDirectMemoryMax().bytes() > 0) {
+                    // we can guess a better default...
+                    long l = (long) ((0.3 * JvmInfo.jvmInfo().getMem().getDirectMemoryMax().bytes()) / WORKER_COUNT.get(settings));
+                    defaultReceiverPredictor = Math.min(defaultReceiverPredictor, Math.max(l, 64 * 1024));
+                }
+                return new ByteSizeValue(defaultReceiverPredictor).toString();
+            }, false, Setting.Scope.CLUSTER);
+    public static final Setting<ByteSizeValue> NETTY_RECEIVE_PREDICTOR_MIN = Setting.byteSizeSetting("transport.netty.receive_predictor_min", NETTY_RECEIVE_PREDICTOR_SIZE, false, Setting.Scope.CLUSTER);
+    public static final Setting<ByteSizeValue> NETTY_RECEIVE_PREDICTOR_MAX = Setting.byteSizeSetting("transport.netty.receive_predictor_max", NETTY_RECEIVE_PREDICTOR_SIZE, false, Setting.Scope.CLUSTER);
+    public static final Setting<Integer> NETTY_BOSS_COUNT = Setting.intSetting("transport.netty.boss_count", 1, 1, false, Setting.Scope.CLUSTER);
+
+    public static final Setting<Boolean> NETWORK_SERVER = Setting.boolSetting("network.server", true, false, Setting.Scope.CLUSTER);
 
     protected final NetworkService networkService;
     protected final Version version;
@@ -203,8 +225,6 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
     final ScheduledPing scheduledPing;
 
     @Inject
-    @SuppressForbidden(reason = "sets org.jboss.netty.epollBugWorkaround based on netty.epollBugWorkaround")
-    // TODO: why be confusing like this? just let the user do it with the netty parameter instead!
     public NettyTransport(Settings settings, ThreadPool threadPool, NetworkService networkService, BigArrays bigArrays, Version version, NamedWriteableRegistry namedWriteableRegistry) {
         super(settings);
         this.threadPool = threadPool;
@@ -212,44 +232,22 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
         this.bigArrays = bigArrays;
         this.version = version;
 
-        if (settings.getAsBoolean("netty.epollBugWorkaround", false)) {
-            System.setProperty("org.jboss.netty.epollBugWorkaround", "true");
-        }
-
-        this.workerCount = settings.getAsInt(WORKER_COUNT, EsExecutors.boundedNumberOfProcessors(settings) * 2);
-        this.blockingClient = settings.getAsBoolean("transport.netty.transport.tcp.blocking_client", TCP_BLOCKING_CLIENT.get(settings));
-        this.connectTimeout = this.settings.getAsTime("transport.netty.connect_timeout", settings.getAsTime("transport.tcp.connect_timeout", TCP_CONNECT_TIMEOUT.get(settings)));
-        this.maxCumulationBufferCapacity = this.settings.getAsBytesSize("transport.netty.max_cumulation_buffer_capacity", null);
-        this.maxCompositeBufferComponents = this.settings.getAsInt("transport.netty.max_composite_buffer_components", -1);
+        this.workerCount = WORKER_COUNT.get(settings);
+        this.blockingClient = TCP_BLOCKING_CLIENT.get(settings);
+        this.connectTimeout = TCP_CONNECT_TIMEOUT.get(settings);
+        this.maxCumulationBufferCapacity = NETTY_MAX_CUMULATION_BUFFER_CAPACITY.get(settings);
+        this.maxCompositeBufferComponents = NETTY_MAX_COMPOSITE_BUFFER_COMPONENTS.get(settings);
         this.compress = Transport.TRANSPORT_TCP_COMPRESS.get(settings);
 
-        this.connectionsPerNodeRecovery = this.settings.getAsInt("transport.netty.connections_per_node.recovery", settings.getAsInt(CONNECTIONS_PER_NODE_RECOVERY, 2));
-        this.connectionsPerNodeBulk = this.settings.getAsInt("transport.netty.connections_per_node.bulk", settings.getAsInt(CONNECTIONS_PER_NODE_BULK, 3));
-        this.connectionsPerNodeReg = this.settings.getAsInt("transport.netty.connections_per_node.reg", settings.getAsInt(CONNECTIONS_PER_NODE_REG, 6));
-        this.connectionsPerNodeState = this.settings.getAsInt("transport.netty.connections_per_node.high", settings.getAsInt(CONNECTIONS_PER_NODE_STATE, 1));
-        this.connectionsPerNodePing = this.settings.getAsInt("transport.netty.connections_per_node.ping", settings.getAsInt(CONNECTIONS_PER_NODE_PING, 1));
-
-        // we want to have at least 1 for reg/state/ping
-        if (this.connectionsPerNodeReg == 0) {
-            throw new IllegalArgumentException("can't set [connection_per_node.reg] to 0");
-        }
-        if (this.connectionsPerNodePing == 0) {
-            throw new IllegalArgumentException("can't set [connection_per_node.ping] to 0");
-        }
-        if (this.connectionsPerNodeState == 0) {
-            throw new IllegalArgumentException("can't set [connection_per_node.state] to 0");
-        }
-
-        long defaultReceiverPredictor = 512 * 1024;
-        if (JvmInfo.jvmInfo().getMem().getDirectMemoryMax().bytes() > 0) {
-            // we can guess a better default...
-            long l = (long) ((0.3 * JvmInfo.jvmInfo().getMem().getDirectMemoryMax().bytes()) / workerCount);
-            defaultReceiverPredictor = Math.min(defaultReceiverPredictor, Math.max(l, 64 * 1024));
-        }
+        this.connectionsPerNodeRecovery = CONNECTIONS_PER_NODE_RECOVERY.get(settings);
+        this.connectionsPerNodeBulk = CONNECTIONS_PER_NODE_BULK.get(settings);
+        this.connectionsPerNodeReg = CONNECTIONS_PER_NODE_REG.get(settings);
+        this.connectionsPerNodeState = CONNECTIONS_PER_NODE_STATE.get(settings);
+        this.connectionsPerNodePing = CONNECTIONS_PER_NODE_PING.get(settings);
 
         // See AdaptiveReceiveBufferSizePredictor#DEFAULT_XXX for default values in netty..., we can use higher ones for us, even fixed one
-        this.receivePredictorMin = this.settings.getAsBytesSize("transport.netty.receive_predictor_min", this.settings.getAsBytesSize("transport.netty.receive_predictor_size", new ByteSizeValue(defaultReceiverPredictor)));
-        this.receivePredictorMax = this.settings.getAsBytesSize("transport.netty.receive_predictor_max", this.settings.getAsBytesSize("transport.netty.receive_predictor_size", new ByteSizeValue(defaultReceiverPredictor)));
+        this.receivePredictorMin = NETTY_RECEIVE_PREDICTOR_MIN.get(settings);
+        this.receivePredictorMax = NETTY_RECEIVE_PREDICTOR_MAX.get(settings);
         if (receivePredictorMax.bytes() == receivePredictorMin.bytes()) {
             receiveBufferSizePredictorFactory = new FixedReceiveBufferSizePredictorFactory((int) receivePredictorMax.bytes());
         } else {
@@ -257,7 +255,7 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
         }
 
         this.scheduledPing = new ScheduledPing();
-        this.pingSchedule = settings.getAsTime(PING_SCHEDULE, DEFAULT_PING_SCHEDULE);
+        this.pingSchedule = PING_SCHEDULE.get(settings);
         if (pingSchedule.millis() > 0) {
             threadPool.schedule(pingSchedule, ThreadPool.Names.GENERIC, scheduledPing);
         }
@@ -286,19 +284,19 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
         boolean success = false;
         try {
             clientBootstrap = createClientBootstrap();
-            if (settings.getAsBoolean("network.server", true)) {
+            if (NETWORK_SERVER.get(settings)) {
                 final OpenChannelsHandler openChannels = new OpenChannelsHandler(logger);
                 this.serverOpenChannels = openChannels;
 
                 // extract default profile first and create standard bootstrap
-                Map<String, Settings> profiles = TRANSPORT_PROFILES_SETTING.get(settings()).getAsGroups(true);
-                if (!profiles.containsKey(DEFAULT_PROFILE)) {
+                Map<String, Settings> profiles = TransportSettings.TRANSPORT_PROFILES_SETTING.get(settings()).getAsGroups(true);
+                if (!profiles.containsKey(TransportSettings.DEFAULT_PROFILE)) {
                     profiles = new HashMap<>(profiles);
-                    profiles.put(DEFAULT_PROFILE, Settings.EMPTY);
+                    profiles.put(TransportSettings.DEFAULT_PROFILE, Settings.EMPTY);
                 }
 
                 Settings fallbackSettings = createFallbackSettings();
-                Settings defaultSettings = profiles.get(DEFAULT_PROFILE);
+                Settings defaultSettings = profiles.get(TransportSettings.DEFAULT_PROFILE);
 
                 // loop through all profiles and start them up, special handling for default one
                 for (Map.Entry<String, Settings> entry : profiles.entrySet()) {
@@ -308,10 +306,10 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
                     if (!Strings.hasLength(name)) {
                         logger.info("transport profile configured without a name. skipping profile with settings [{}]", profileSettings.toDelimitedString(','));
                         continue;
-                    } else if (DEFAULT_PROFILE.equals(name)) {
+                    } else if (TransportSettings.DEFAULT_PROFILE.equals(name)) {
                         profileSettings = settingsBuilder()
                                 .put(profileSettings)
-                                .put("port", profileSettings.get("port", this.settings.get("transport.tcp.port", DEFAULT_PORT_RANGE)))
+                                .put("port", profileSettings.get("port", TransportSettings.PORT.get(this.settings)))
                                 .build();
                     } else if (profileSettings.get("port") == null) {
                         // if profile does not have a port, skip it
@@ -348,7 +346,7 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
         if (blockingClient) {
             clientBootstrap = new ClientBootstrap(new OioClientSocketChannelFactory(Executors.newCachedThreadPool(daemonThreadFactory(settings, TRANSPORT_CLIENT_WORKER_THREAD_NAME_PREFIX))));
         } else {
-            int bossCount = settings.getAsInt("transport.netty.boss_count", 1);
+            int bossCount = NETTY_BOSS_COUNT.get(settings);
             clientBootstrap = new ClientBootstrap(new NioClientSocketChannelFactory(
                     Executors.newCachedThreadPool(daemonThreadFactory(settings, TRANSPORT_CLIENT_BOSS_THREAD_NAME_PREFIX)),
                     bossCount,
@@ -443,7 +441,7 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
 
         final BoundTransportAddress boundTransportAddress = createBoundTransportAddress(name, settings, boundAddresses);
 
-        if (DEFAULT_PROFILE.equals(name)) {
+        if (TransportSettings.DEFAULT_PROFILE.equals(name)) {
             this.boundAddress = boundTransportAddress;
         } else {
             profileBoundAddresses.put(name, boundTransportAddress);
@@ -496,7 +494,7 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
         }
 
         final String[] publishHosts;
-        if (DEFAULT_PROFILE.equals(name)) {
+        if (TransportSettings.DEFAULT_PROFILE.equals(name)) {
             publishHosts = settings.getAsArray("transport.netty.publish_host", settings.getAsArray("transport.publish_host", settings.getAsArray("transport.host", null)));
         } else {
             publishHosts = profileSettings.getAsArray("publish_host", boundAddressesHostStrings);
@@ -510,7 +508,7 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
         }
 
         Integer publishPort;
-        if (DEFAULT_PROFILE.equals(name)) {
+        if (TransportSettings.DEFAULT_PROFILE.equals(name)) {
             publishPort = settings.getAsInt("transport.netty.publish_port", settings.getAsInt("transport.publish_port", null));
         } else {
             publishPort = profileSettings.getAsInt("publish_port", null);
@@ -667,10 +665,7 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
 
     @Override
     public TransportAddress[] addressesFromString(String address, int perAddressLimit) throws Exception {
-        return parse(address, settings.get("transport.profiles.default.port",
-                              settings.get("transport.netty.port",
-                              settings.get("transport.tcp.port",
-                              DEFAULT_PORT_RANGE))), perAddressLimit);
+        return parse(address, settings.get("transport.profiles.default.port", TransportSettings.PORT.get(settings)), perAddressLimit);
     }
 
     // this code is a take on guava's HostAndPort, like a HostAndPortRange
@@ -1140,7 +1135,7 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
         public ChannelPipeline getPipeline() throws Exception {
             ChannelPipeline channelPipeline = Channels.pipeline();
             SizeHeaderFrameDecoder sizeHeader = new SizeHeaderFrameDecoder();
-            if (nettyTransport.maxCumulationBufferCapacity != null) {
+            if (nettyTransport.maxCumulationBufferCapacity.bytes() >= 0) {
                 if (nettyTransport.maxCumulationBufferCapacity.bytes() > Integer.MAX_VALUE) {
                     sizeHeader.setMaxCumulationBufferCapacity(Integer.MAX_VALUE);
                 } else {
@@ -1178,7 +1173,7 @@ public class NettyTransport extends AbstractLifecycleComponent<Transport> implem
             ChannelPipeline channelPipeline = Channels.pipeline();
             channelPipeline.addLast("openChannels", nettyTransport.serverOpenChannels);
             SizeHeaderFrameDecoder sizeHeader = new SizeHeaderFrameDecoder();
-            if (nettyTransport.maxCumulationBufferCapacity != null) {
+            if (nettyTransport.maxCumulationBufferCapacity.bytes() > 0) {
                 if (nettyTransport.maxCumulationBufferCapacity.bytes() > Integer.MAX_VALUE) {
                     sizeHeader.setMaxCumulationBufferCapacity(Integer.MAX_VALUE);
                 } else {
diff --git a/core/src/test/java/org/elasticsearch/bwcompat/UnicastBackwardsCompatibilityIT.java b/core/src/test/java/org/elasticsearch/bwcompat/UnicastBackwardsCompatibilityIT.java
index ab7e958..d6eea58 100644
--- a/core/src/test/java/org/elasticsearch/bwcompat/UnicastBackwardsCompatibilityIT.java
+++ b/core/src/test/java/org/elasticsearch/bwcompat/UnicastBackwardsCompatibilityIT.java
@@ -22,6 +22,7 @@ package org.elasticsearch.bwcompat;
 import org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;
 import org.elasticsearch.common.settings.Settings;
 import org.elasticsearch.test.ESBackcompatTestCase;
+import org.elasticsearch.transport.TransportSettings;
 
 import static org.hamcrest.Matchers.equalTo;
 
@@ -30,7 +31,7 @@ public class UnicastBackwardsCompatibilityIT extends ESBackcompatTestCase {
     protected Settings nodeSettings(int nodeOrdinal) {
         return Settings.builder()
                 .put(super.nodeSettings(nodeOrdinal))
-                .put("transport.tcp.port", 9380 + nodeOrdinal)
+                .put(TransportSettings.PORT.getKey(), 9380 + nodeOrdinal)
                 .put("discovery.zen.ping.unicast.hosts", "localhost:9380,localhost:9381,localhost:9390,localhost:9391")
                 .build();
     }
@@ -39,7 +40,7 @@ public class UnicastBackwardsCompatibilityIT extends ESBackcompatTestCase {
     protected Settings externalNodeSettings(int nodeOrdinal) {
         return Settings.settingsBuilder()
                 .put(super.externalNodeSettings(nodeOrdinal))
-                .put("transport.tcp.port", 9390 + nodeOrdinal)
+                .put(TransportSettings.PORT.getKey(), 9390 + nodeOrdinal)
                 .put("discovery.zen.ping.unicast.hosts", "localhost:9380,localhost:9381,localhost:9390,localhost:9391")
                 .build();
     }
diff --git a/core/src/test/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java b/core/src/test/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java
index fb0ff37..cf99879 100644
--- a/core/src/test/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java
+++ b/core/src/test/java/org/elasticsearch/cluster/settings/ClusterSettingsIT.java
@@ -21,11 +21,13 @@ package org.elasticsearch.cluster.settings;
 
 import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequestBuilder;
 import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsResponse;
+import org.elasticsearch.cluster.ClusterName;
+import org.elasticsearch.cluster.metadata.IndexMetaData;
 import org.elasticsearch.cluster.metadata.MetaData;
 import org.elasticsearch.cluster.routing.allocation.decider.EnableAllocationDecider;
-import org.elasticsearch.common.logging.ESLoggerFactory;
 import org.elasticsearch.common.settings.Settings;
 import org.elasticsearch.common.unit.ByteSizeUnit;
+import org.elasticsearch.common.util.concurrent.EsExecutors;
 import org.elasticsearch.discovery.DiscoverySettings;
 import org.elasticsearch.index.store.IndexStoreConfig;
 import org.elasticsearch.test.ESIntegTestCase;
@@ -327,30 +329,16 @@ public class ClusterSettingsIT extends ESIntegTestCase {
         }
     }
 
-    public void testLoggerLevelUpdate() {
-        assertAcked(prepareCreate("test"));
-        final String rootLevel = ESLoggerFactory.getRootLogger().getLevel();
-        final String testLevel = ESLoggerFactory.getLogger("test").getLevel();
-        try {
-            client().admin().cluster().prepareUpdateSettings().setTransientSettings(Settings.builder().put("logger._root", "BOOM")).execute().actionGet();
-            fail("Expected IllegalArgumentException");
-        } catch (IllegalArgumentException e) {
-            assertEquals("No enum constant org.elasticsearch.common.logging.ESLoggerFactory.LogLevel.BOOM", e.getMessage());
-        }
-
-        try {
-            client().admin().cluster().prepareUpdateSettings().setTransientSettings(Settings.builder().put("logger.test", "TRACE").put("logger._root", "trace")).execute().actionGet();
-            assertEquals("TRACE", ESLoggerFactory.getLogger("test").getLevel());
-            assertEquals("TRACE", ESLoggerFactory.getRootLogger().getLevel());
-        } finally {
-            if (randomBoolean()) {
-                client().admin().cluster().prepareUpdateSettings().setTransientSettings(Settings.builder().putNull("logger.test").putNull("logger._root")).execute().actionGet();
-            } else {
-                client().admin().cluster().prepareUpdateSettings().setTransientSettings(Settings.builder().putNull("logger.*")).execute().actionGet();
-            }
-            assertEquals(testLevel, ESLoggerFactory.getLogger("test").getLevel());
-            assertEquals(rootLevel, ESLoggerFactory.getRootLogger().getLevel());
-        }
+    private void createNode(Settings settings) {
+        internalCluster().startNode(Settings.builder()
+                        .put(ClusterName.CLUSTER_NAME_SETTING.getKey(), "ClusterSettingsIT")
+                        .put("node.name", "ClusterSettingsIT")
+                        .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)
+                        .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0)
+                        .put(EsExecutors.PROCESSORS_SETTING.getKey(), 1) // limit the number of threads created
+                        .put("http.enabled", false)
+                        .put("config.ignore_system_properties", true) // make sure we get what we set :)
+                        .put(settings)
+        );
     }
-
 }
diff --git a/core/src/test/java/org/elasticsearch/common/settings/ScopedSettingsTests.java b/core/src/test/java/org/elasticsearch/common/settings/ScopedSettingsTests.java
index 58f5cde..86a3772 100644
--- a/core/src/test/java/org/elasticsearch/common/settings/ScopedSettingsTests.java
+++ b/core/src/test/java/org/elasticsearch/common/settings/ScopedSettingsTests.java
@@ -22,7 +22,6 @@ import org.elasticsearch.Version;
 import org.elasticsearch.cluster.metadata.IndexMetaData;
 import org.elasticsearch.cluster.routing.allocation.decider.FilterAllocationDecider;
 import org.elasticsearch.cluster.routing.allocation.decider.ShardsLimitAllocationDecider;
-import org.elasticsearch.common.logging.ESLoggerFactory;
 import org.elasticsearch.index.IndexModule;
 import org.elasticsearch.test.ESTestCase;
 import org.elasticsearch.transport.TransportService;
@@ -255,48 +254,4 @@ public class ScopedSettingsTests extends ESTestCase {
             Settings.EMPTY, Collections.singleton(Setting.boolSetting("boo", true, false, Setting.Scope.INDEX)));
     }
 
-    public void testLoggingUpdates() {
-        final String level = ESLoggerFactory.getRootLogger().getLevel();
-        final String testLevel = ESLoggerFactory.getLogger("test").getLevel();
-        String property = System.getProperty("es.logger.level");
-        Settings.Builder builder = Settings.builder();
-        if (property != null) {
-            builder.put("logger.level", property);
-        }
-        try {
-            ClusterSettings settings = new ClusterSettings(builder.build(), ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
-            try {
-                settings.validate(Settings.builder().put("logger._root", "boom").build());
-                fail();
-            } catch (IllegalArgumentException ex) {
-                assertEquals("No enum constant org.elasticsearch.common.logging.ESLoggerFactory.LogLevel.BOOM", ex.getMessage());
-            }
-            assertEquals(level, ESLoggerFactory.getRootLogger().getLevel());
-            settings.applySettings(Settings.builder().put("logger._root", "TRACE").build());
-            assertEquals("TRACE", ESLoggerFactory.getRootLogger().getLevel());
-            settings.applySettings(Settings.builder().build());
-            assertEquals(level, ESLoggerFactory.getRootLogger().getLevel());
-            settings.applySettings(Settings.builder().put("logger.test", "TRACE").build());
-            assertEquals("TRACE", ESLoggerFactory.getLogger("test").getLevel());
-            settings.applySettings(Settings.builder().build());
-            assertEquals(testLevel, ESLoggerFactory.getLogger("test").getLevel());
-        } finally {
-            ESLoggerFactory.getRootLogger().setLevel(level);
-            ESLoggerFactory.getLogger("test").setLevel(testLevel);
-        }
-    }
-
-    public void testFallbackToLoggerLevel() {
-        final String level = ESLoggerFactory.getRootLogger().getLevel();
-        try {
-            ClusterSettings settings = new ClusterSettings(Settings.builder().put("logger.level", "ERROR").build(), ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
-            assertEquals(level, ESLoggerFactory.getRootLogger().getLevel());
-            settings.applySettings(Settings.builder().put("logger._root", "TRACE").build());
-            assertEquals("TRACE", ESLoggerFactory.getRootLogger().getLevel());
-            settings.applySettings(Settings.builder().build()); // here we fall back to 'logger.level' which is our default.
-            assertEquals("ERROR", ESLoggerFactory.getRootLogger().getLevel());
-        } finally {
-            ESLoggerFactory.getRootLogger().setLevel(level);
-        }
-    }
 }
diff --git a/core/src/test/java/org/elasticsearch/common/settings/SettingTests.java b/core/src/test/java/org/elasticsearch/common/settings/SettingTests.java
index 6f189bd..e5ae9bd 100644
--- a/core/src/test/java/org/elasticsearch/common/settings/SettingTests.java
+++ b/core/src/test/java/org/elasticsearch/common/settings/SettingTests.java
@@ -44,6 +44,12 @@ public class SettingTests extends ESTestCase {
         assertFalse(byteSizeValueSetting.isGroupSetting());
         ByteSizeValue byteSizeValue = byteSizeValueSetting.get(Settings.EMPTY);
         assertEquals(byteSizeValue.bytes(), 1024);
+
+        byteSizeValueSetting = Setting.byteSizeSetting("a.byte.size", s -> "2048b", true, Setting.Scope.CLUSTER);
+        byteSizeValue = byteSizeValueSetting.get(Settings.EMPTY);
+        assertEquals(byteSizeValue.bytes(), 2048);
+
+
         AtomicReference<ByteSizeValue> value = new AtomicReference<>(null);
         ClusterSettings.SettingUpdater<ByteSizeValue> settingUpdater = byteSizeValueSetting.newUpdater(value::set, logger);
         try {
diff --git a/core/src/test/java/org/elasticsearch/common/settings/SettingsModuleTests.java b/core/src/test/java/org/elasticsearch/common/settings/SettingsModuleTests.java
index 290eec0..731957c 100644
--- a/core/src/test/java/org/elasticsearch/common/settings/SettingsModuleTests.java
+++ b/core/src/test/java/org/elasticsearch/common/settings/SettingsModuleTests.java
@@ -78,24 +78,4 @@ public class SettingsModuleTests extends ModuleTestCase {
             }
         }
     }
-
-    public void testLoggerSettings() {
-        {
-            Settings settings = Settings.builder().put("logger._root", "TRACE").put("logger.transport", "INFO").build();
-            SettingsModule module = new SettingsModule(settings, new SettingsFilter(Settings.EMPTY));
-            assertInstanceBinding(module, Settings.class, (s) -> s == settings);
-        }
-
-        {
-            Settings settings = Settings.builder().put("logger._root", "BOOM").put("logger.transport", "WOW").build();
-            SettingsModule module = new SettingsModule(settings, new SettingsFilter(Settings.EMPTY));
-            try {
-                assertInstanceBinding(module, Settings.class, (s) -> s == settings);
-                fail();
-            } catch (IllegalArgumentException ex) {
-                assertEquals("No enum constant org.elasticsearch.common.logging.ESLoggerFactory.LogLevel.BOOM", ex.getMessage());
-            }
-        }
-
-    }
 }
diff --git a/core/src/test/java/org/elasticsearch/discovery/DiscoveryWithServiceDisruptionsIT.java b/core/src/test/java/org/elasticsearch/discovery/DiscoveryWithServiceDisruptionsIT.java
index 032b614..d3b9df8 100644
--- a/core/src/test/java/org/elasticsearch/discovery/DiscoveryWithServiceDisruptionsIT.java
+++ b/core/src/test/java/org/elasticsearch/discovery/DiscoveryWithServiceDisruptionsIT.java
@@ -170,7 +170,6 @@ public class DiscoveryWithServiceDisruptionsIT extends ESIntegTestCase {
             .put("discovery.zen.join_timeout", "10s")  // still long to induce failures but to long so test won't time out
             .put(DiscoverySettings.PUBLISH_TIMEOUT_SETTING.getKey(), "1s") // <-- for hitting simulated network failures quickly
             .put("http.enabled", false) // just to make test quicker
-            .put("gateway.local.list_timeout", "10s") // still long to induce failures but to long so test won't time out
             .build();
 
     @Override
diff --git a/core/src/test/java/org/elasticsearch/discovery/zen/ping/unicast/UnicastZenPingIT.java b/core/src/test/java/org/elasticsearch/discovery/zen/ping/unicast/UnicastZenPingIT.java
index a3b2cac..f44faea 100644
--- a/core/src/test/java/org/elasticsearch/discovery/zen/ping/unicast/UnicastZenPingIT.java
+++ b/core/src/test/java/org/elasticsearch/discovery/zen/ping/unicast/UnicastZenPingIT.java
@@ -37,6 +37,7 @@ import org.elasticsearch.node.service.NodeService;
 import org.elasticsearch.test.ESTestCase;
 import org.elasticsearch.threadpool.ThreadPool;
 import org.elasticsearch.transport.TransportService;
+import org.elasticsearch.transport.TransportSettings;
 import org.elasticsearch.transport.netty.NettyTransport;
 
 import java.net.InetSocketAddress;
@@ -48,7 +49,7 @@ public class UnicastZenPingIT extends ESTestCase {
         Settings settings = Settings.EMPTY;
         int startPort = 11000 + randomIntBetween(0, 1000);
         int endPort = startPort + 10;
-        settings = Settings.builder().put(settings).put("transport.tcp.port", startPort + "-" + endPort).build();
+        settings = Settings.builder().put(settings).put(TransportSettings.PORT.getKey(), startPort + "-" + endPort).build();
 
         ThreadPool threadPool = new ThreadPool(getClass().getName());
         ClusterName clusterName = new ClusterName("test");
diff --git a/core/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java b/core/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java
index e84b454..13fa55e 100644
--- a/core/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java
+++ b/core/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java
@@ -1087,4 +1087,65 @@ public class IndexShardTests extends ESSingleNodeTestCase {
         newShard.performBatchRecovery(operations);
         assertFalse(newShard.getTranslog().syncNeeded());
     }
+
+    public void testIndexingBufferDuringInternalRecovery() throws IOException {
+        createIndex("index");
+        client().admin().indices().preparePutMapping("index").setType("testtype").setSource(jsonBuilder().startObject()
+                .startObject("testtype")
+                .startObject("properties")
+                .startObject("foo")
+                .field("type", "string")
+                .endObject()
+                .endObject().endObject().endObject()).get();
+        ensureGreen();
+        IndicesService indicesService = getInstanceFromNode(IndicesService.class);
+        IndexService test = indicesService.indexService("index");
+        IndexShard shard = test.getShardOrNull(0);
+        ShardRouting routing = new ShardRouting(shard.routingEntry());
+        test.removeShard(0, "b/c britta says so");
+        IndexShard newShard = test.createShard(routing);
+        newShard.shardRouting = routing;
+        DiscoveryNode localNode = new DiscoveryNode("foo", DummyTransportAddress.INSTANCE, Version.CURRENT);
+        newShard.markAsRecovering("for testing", new RecoveryState(newShard.shardId(), routing.primary(), RecoveryState.Type.REPLICA, localNode, localNode));
+        // Shard is still inactive since we haven't started recovering yet
+        assertFalse(newShard.isActive());
+        newShard.prepareForIndexRecovery();
+        // Shard is still inactive since we haven't started recovering yet
+        assertFalse(newShard.isActive());
+        newShard.performTranslogRecovery(true);
+        // Shard should now be active since we did recover:
+        assertTrue(newShard.isActive());
+    }
+
+    public void testIndexingBufferDuringPeerRecovery() throws IOException {
+        createIndex("index");
+        client().admin().indices().preparePutMapping("index").setType("testtype").setSource(jsonBuilder().startObject()
+                .startObject("testtype")
+                .startObject("properties")
+                .startObject("foo")
+                .field("type", "string")
+                .endObject()
+                .endObject().endObject().endObject()).get();
+        ensureGreen();
+        IndicesService indicesService = getInstanceFromNode(IndicesService.class);
+        IndexService test = indicesService.indexService("index");
+        IndexShard shard = test.getShardOrNull(0);
+        ShardRouting routing = new ShardRouting(shard.routingEntry());
+        test.removeShard(0, "b/c britta says so");
+        IndexShard newShard = test.createShard(routing);
+        newShard.shardRouting = routing;
+        DiscoveryNode localNode = new DiscoveryNode("foo", DummyTransportAddress.INSTANCE, Version.CURRENT);
+        newShard.markAsRecovering("for testing", new RecoveryState(newShard.shardId(), routing.primary(), RecoveryState.Type.REPLICA, localNode, localNode));
+        // Shard is still inactive since we haven't started recovering yet
+        assertFalse(newShard.isActive());
+        List<Translog.Operation> operations = new ArrayList<>();
+        operations.add(new Translog.Index("testtype", "1", jsonBuilder().startObject().field("foo", "bar").endObject().bytes().toBytes()));
+        newShard.prepareForIndexRecovery();
+        newShard.skipTranslogRecovery();
+        // Shard is still inactive since we haven't started recovering yet
+        assertFalse(newShard.isActive());
+        newShard.performBatchRecovery(operations);
+        // Shard should now be active since we did recover:
+        assertTrue(newShard.isActive());
+    }
 }
diff --git a/core/src/test/java/org/elasticsearch/transport/NettySizeHeaderFrameDecoderTests.java b/core/src/test/java/org/elasticsearch/transport/NettySizeHeaderFrameDecoderTests.java
index 33d0f6e..39b9638 100644
--- a/core/src/test/java/org/elasticsearch/transport/NettySizeHeaderFrameDecoderTests.java
+++ b/core/src/test/java/org/elasticsearch/transport/NettySizeHeaderFrameDecoderTests.java
@@ -51,10 +51,10 @@ import static org.hamcrest.Matchers.is;
 public class NettySizeHeaderFrameDecoderTests extends ESTestCase {
 
     private final Settings settings = settingsBuilder()
-                                        .put("name", "foo")
-                                        .put("transport.host", "127.0.0.1")
-                                        .put("transport.tcp.port", "0")
-                                        .build();
+            .put("name", "foo")
+            .put("transport.host", "127.0.0.1")
+            .put(TransportSettings.PORT.getKey(), "0")
+            .build();
 
     private ThreadPool threadPool;
     private NettyTransport nettyTransport;
diff --git a/core/src/test/java/org/elasticsearch/transport/netty/NettyScheduledPingTests.java b/core/src/test/java/org/elasticsearch/transport/netty/NettyScheduledPingTests.java
index 7a939a5..ab32909 100644
--- a/core/src/test/java/org/elasticsearch/transport/netty/NettyScheduledPingTests.java
+++ b/core/src/test/java/org/elasticsearch/transport/netty/NettyScheduledPingTests.java
@@ -36,6 +36,7 @@ import org.elasticsearch.transport.TransportRequestHandler;
 import org.elasticsearch.transport.TransportRequestOptions;
 import org.elasticsearch.transport.TransportResponse;
 import org.elasticsearch.transport.TransportResponseOptions;
+import org.elasticsearch.transport.TransportSettings;
 
 import java.io.IOException;
 
@@ -49,7 +50,7 @@ public class NettyScheduledPingTests extends ESTestCase {
     public void testScheduledPing() throws Exception {
         ThreadPool threadPool = new ThreadPool(getClass().getName());
 
-        Settings settings = Settings.builder().put(NettyTransport.PING_SCHEDULE, "5ms").put("transport.tcp.port", 0).build();
+        Settings settings = Settings.builder().put(NettyTransport.PING_SCHEDULE.getKey(), "5ms").put(TransportSettings.PORT.getKey(), 0).build();
 
         final NettyTransport nettyA = new NettyTransport(settings, threadPool, new NetworkService(settings), BigArrays.NON_RECYCLING_INSTANCE, Version.CURRENT, new NamedWriteableRegistry());
         MockTransportService serviceA = new MockTransportService(settings, nettyA, threadPool);
diff --git a/core/src/test/java/org/elasticsearch/transport/netty/NettyTransportIT.java b/core/src/test/java/org/elasticsearch/transport/netty/NettyTransportIT.java
index 8304dd0..a8d06d3 100644
--- a/core/src/test/java/org/elasticsearch/transport/netty/NettyTransportIT.java
+++ b/core/src/test/java/org/elasticsearch/transport/netty/NettyTransportIT.java
@@ -43,6 +43,7 @@ import org.elasticsearch.threadpool.ThreadPool;
 import org.elasticsearch.transport.ActionNotFoundTransportException;
 import org.elasticsearch.transport.RequestHandlerRegistry;
 import org.elasticsearch.transport.TransportRequest;
+import org.elasticsearch.transport.TransportSettings;
 import org.jboss.netty.channel.Channel;
 import org.jboss.netty.channel.ChannelPipeline;
 import org.jboss.netty.channel.ChannelPipelineFactory;
@@ -85,7 +86,7 @@ public class NettyTransportIT extends ESIntegTestCase {
             fail("Expected exception, but didnt happen");
         } catch (ElasticsearchException e) {
             assertThat(e.getMessage(), containsString("MY MESSAGE"));
-            assertThat(channelProfileName, is(NettyTransport.DEFAULT_PROFILE));
+            assertThat(channelProfileName, is(TransportSettings.DEFAULT_PROFILE));
         }
     }
 
@@ -127,7 +128,7 @@ public class NettyTransportIT extends ESIntegTestCase {
             @Override
             public ChannelPipeline getPipeline() throws Exception {
                 ChannelPipeline pipeline = super.getPipeline();
-                pipeline.replace("dispatcher", "dispatcher", new MessageChannelHandler(nettyTransport, logger, NettyTransport.DEFAULT_PROFILE) {
+                pipeline.replace("dispatcher", "dispatcher", new MessageChannelHandler(nettyTransport, logger, TransportSettings.DEFAULT_PROFILE) {
 
                     @Override
                     protected String handleRequest(Channel channel, StreamInput buffer, long requestId, Version version) throws IOException {
diff --git a/core/src/test/java/org/elasticsearch/transport/netty/NettyTransportMultiPortTests.java b/core/src/test/java/org/elasticsearch/transport/netty/NettyTransportMultiPortTests.java
index 1c88697..6eaf738 100644
--- a/core/src/test/java/org/elasticsearch/transport/netty/NettyTransportMultiPortTests.java
+++ b/core/src/test/java/org/elasticsearch/transport/netty/NettyTransportMultiPortTests.java
@@ -31,6 +31,7 @@ import org.elasticsearch.indices.breaker.NoneCircuitBreakerService;
 import org.elasticsearch.test.ESTestCase;
 import org.elasticsearch.threadpool.ThreadPool;
 import org.elasticsearch.transport.TransportService;
+import org.elasticsearch.transport.TransportSettings;
 import org.junit.Before;
 
 import static org.elasticsearch.common.settings.Settings.settingsBuilder;
@@ -52,7 +53,7 @@ public class NettyTransportMultiPortTests extends ESTestCase {
     public void testThatNettyCanBindToMultiplePorts() throws Exception {
         Settings settings = settingsBuilder()
                 .put("network.host", host)
-                .put("transport.tcp.port", 22) // will not actually bind to this
+                .put(TransportSettings.PORT.getKey(), 22) // will not actually bind to this
                 .put("transport.profiles.default.port", 0)
                 .put("transport.profiles.client1.port", 0)
                 .build();
@@ -69,7 +70,7 @@ public class NettyTransportMultiPortTests extends ESTestCase {
     public void testThatDefaultProfileInheritsFromStandardSettings() throws Exception {
         Settings settings = settingsBuilder()
                 .put("network.host", host)
-                .put("transport.tcp.port", 0)
+                .put(TransportSettings.PORT.getKey(), 0)
                 .put("transport.profiles.client1.port", 0)
                 .build();
 
@@ -86,7 +87,7 @@ public class NettyTransportMultiPortTests extends ESTestCase {
 
         Settings settings = settingsBuilder()
                 .put("network.host", host)
-                .put("transport.tcp.port", 0)
+                .put(TransportSettings.PORT.getKey(), 0)
                 .put("transport.profiles.client1.whatever", "foo")
                 .build();
 
@@ -102,8 +103,7 @@ public class NettyTransportMultiPortTests extends ESTestCase {
     public void testThatDefaultProfilePortOverridesGeneralConfiguration() throws Exception {
         Settings settings = settingsBuilder()
                 .put("network.host", host)
-                .put("transport.tcp.port", 22) // will not actually bind to this
-                .put("transport.netty.port", 23) // will not actually bind to this
+                .put(TransportSettings.PORT.getKey(), 22) // will not actually bind to this
                 .put("transport.profiles.default.port", 0)
                 .build();
 
@@ -119,7 +119,7 @@ public class NettyTransportMultiPortTests extends ESTestCase {
     public void testThatProfileWithoutValidNameIsIgnored() throws Exception {
         Settings settings = settingsBuilder()
                 .put("network.host", host)
-                .put("transport.tcp.port", 0)
+                .put(TransportSettings.PORT.getKey(), 0)
                 // mimics someone trying to define a profile for .local which is the profile for a node request to itself
                 .put("transport.profiles." + TransportService.DIRECT_RESPONSE_PROFILE + ".port", 22) // will not actually bind to this
                 .put("transport.profiles..port", 23) // will not actually bind to this
diff --git a/core/src/test/java/org/elasticsearch/transport/netty/SimpleNettyTransportTests.java b/core/src/test/java/org/elasticsearch/transport/netty/SimpleNettyTransportTests.java
index bd26319..8364dea 100644
--- a/core/src/test/java/org/elasticsearch/transport/netty/SimpleNettyTransportTests.java
+++ b/core/src/test/java/org/elasticsearch/transport/netty/SimpleNettyTransportTests.java
@@ -29,6 +29,7 @@ import org.elasticsearch.common.util.BigArrays;
 import org.elasticsearch.test.transport.MockTransportService;
 import org.elasticsearch.transport.AbstractSimpleTransportTestCase;
 import org.elasticsearch.transport.ConnectTransportException;
+import org.elasticsearch.transport.TransportSettings;
 
 import java.net.InetAddress;
 import java.net.UnknownHostException;
@@ -39,7 +40,7 @@ public class SimpleNettyTransportTests extends AbstractSimpleTransportTestCase {
 
     @Override
     protected MockTransportService build(Settings settings, Version version, NamedWriteableRegistry namedWriteableRegistry) {
-        settings = Settings.builder().put(settings).put("transport.tcp.port", "0").build();
+        settings = Settings.builder().put(settings).put(TransportSettings.PORT.getKey(), "0").build();
         MockTransportService transportService = new MockTransportService(settings, new NettyTransport(settings, threadPool, new NetworkService(settings), BigArrays.NON_RECYCLING_INSTANCE, version, namedWriteableRegistry), threadPool);
         transportService.start();
         return transportService;
diff --git a/docs/plugins/analysis.asciidoc b/docs/plugins/analysis.asciidoc
index 453b720..6f51e96 100644
--- a/docs/plugins/analysis.asciidoc
+++ b/docs/plugins/analysis.asciidoc
@@ -49,6 +49,7 @@ A number of analysis plugins have been contributed by our community:
 * https://github.com/imotov/elasticsearch-analysis-morphology[Russian and English Morphological Analysis Plugin] (by Igor Motov)
 * https://github.com/medcl/elasticsearch-analysis-pinyin[Pinyin Analysis Plugin] (by Medcl)
 * https://github.com/duydo/elasticsearch-analysis-vietnamese[Vietnamese Analysis Plugin] (by Duy Do)
+* https://github.com/ofir123/elasticsearch-network-analysis[Network Addresses Analysis Plugin] (by Ofir123)
 
 These community plugins appear to have been abandoned:
 
diff --git a/docs/reference/indices/segments.asciidoc b/docs/reference/indices/segments.asciidoc
index f2d5106..7dfcd2b 100644
--- a/docs/reference/indices/segments.asciidoc
+++ b/docs/reference/indices/segments.asciidoc
@@ -74,6 +74,7 @@ compound::   Whether the segment is stored in a compound file. When true, this
              means that Lucene merged all files from the segment in a single
              one in order to save file descriptors.
 
+[float]
 === Verbose mode
 
 To add additional information that can be used for debugging, use the `verbose` flag.
@@ -112,4 +113,4 @@ Response:
         }
     ...
 }
---------------------------------------------------
\ No newline at end of file
+--------------------------------------------------
diff --git a/test/framework/src/main/java/org/elasticsearch/test/InternalTestCluster.java b/test/framework/src/main/java/org/elasticsearch/test/InternalTestCluster.java
index f2e00b2..c1136c2 100644
--- a/test/framework/src/main/java/org/elasticsearch/test/InternalTestCluster.java
+++ b/test/framework/src/main/java/org/elasticsearch/test/InternalTestCluster.java
@@ -89,6 +89,7 @@ import org.elasticsearch.test.transport.AssertingLocalTransport;
 import org.elasticsearch.test.transport.MockTransportService;
 import org.elasticsearch.transport.Transport;
 import org.elasticsearch.transport.TransportService;
+import org.elasticsearch.transport.TransportSettings;
 import org.elasticsearch.transport.netty.NettyTransport;
 import org.junit.Assert;
 
@@ -288,7 +289,7 @@ public final class InternalTestCluster extends TestCluster {
         builder.put(Environment.PATH_SHARED_DATA_SETTING.getKey(), baseDir.resolve("custom"));
         builder.put(Environment.PATH_HOME_SETTING.getKey(), baseDir);
         builder.put(Environment.PATH_REPO_SETTING.getKey(), baseDir.resolve("repos"));
-        builder.put("transport.tcp.port", TRANSPORT_BASE_PORT + "-" + (TRANSPORT_BASE_PORT + PORTS_PER_CLUSTER));
+        builder.put(TransportSettings.PORT.getKey(), TRANSPORT_BASE_PORT + "-" + (TRANSPORT_BASE_PORT + PORTS_PER_CLUSTER));
         builder.put("http.port", HTTP_BASE_PORT + "-" + (HTTP_BASE_PORT + PORTS_PER_CLUSTER));
         builder.put(InternalSettingsPreparer.IGNORE_SYSTEM_PROPERTIES_SETTING.getKey(), true);
         builder.put(Node.NODE_MODE_SETTING.getKey(), nodeMode);
@@ -401,10 +402,10 @@ public final class InternalTestCluster extends TestCluster {
 
         // randomize netty settings
         if (random.nextBoolean()) {
-            builder.put(NettyTransport.WORKER_COUNT, random.nextInt(3) + 1);
-            builder.put(NettyTransport.CONNECTIONS_PER_NODE_RECOVERY, random.nextInt(2) + 1);
-            builder.put(NettyTransport.CONNECTIONS_PER_NODE_BULK, random.nextInt(3) + 1);
-            builder.put(NettyTransport.CONNECTIONS_PER_NODE_REG, random.nextInt(6) + 1);
+            builder.put(NettyTransport.WORKER_COUNT.getKey(), random.nextInt(3) + 1);
+            builder.put(NettyTransport.CONNECTIONS_PER_NODE_RECOVERY.getKey(), random.nextInt(2) + 1);
+            builder.put(NettyTransport.CONNECTIONS_PER_NODE_BULK.getKey(), random.nextInt(3) + 1);
+            builder.put(NettyTransport.CONNECTIONS_PER_NODE_REG.getKey(), random.nextInt(6) + 1);
         }
 
         if (random.nextBoolean()) {
@@ -444,7 +445,7 @@ public final class InternalTestCluster extends TestCluster {
         }
 
         if (random.nextBoolean()) {
-            builder.put(NettyTransport.PING_SCHEDULE, RandomInts.randomIntBetween(random, 100, 2000) + "ms");
+            builder.put(NettyTransport.PING_SCHEDULE.getKey(), RandomInts.randomIntBetween(random, 100, 2000) + "ms");
         }
 
         if (random.nextBoolean()) {
diff --git a/test/framework/src/main/java/org/elasticsearch/test/discovery/ClusterDiscoveryConfiguration.java b/test/framework/src/main/java/org/elasticsearch/test/discovery/ClusterDiscoveryConfiguration.java
index 71c1cc2..1538504 100644
--- a/test/framework/src/main/java/org/elasticsearch/test/discovery/ClusterDiscoveryConfiguration.java
+++ b/test/framework/src/main/java/org/elasticsearch/test/discovery/ClusterDiscoveryConfiguration.java
@@ -27,6 +27,7 @@ import org.elasticsearch.common.util.CollectionUtils;
 import org.elasticsearch.discovery.DiscoveryModule;
 import org.elasticsearch.test.InternalTestCluster;
 import org.elasticsearch.test.NodeConfigurationSource;
+import org.elasticsearch.transport.TransportSettings;
 
 import java.io.IOException;
 import java.net.InetSocketAddress;
@@ -113,7 +114,7 @@ public class ClusterDiscoveryConfiguration extends NodeConfigurationSource {
                 throw new ElasticsearchException("nodeOrdinal [" + nodeOrdinal + "] is greater than the number unicast ports [" + unicastHostPorts.length + "]");
             } else {
                 // we need to pin the node port & host so we'd know where to point things
-                builder.put("transport.tcp.port", unicastHostPorts[nodeOrdinal]);
+                builder.put(TransportSettings.PORT.getKey(), unicastHostPorts[nodeOrdinal]);
                 builder.put("transport.host", IP_ADDR); // only bind on one IF we use v4 here by default
                 builder.put("transport.bind_host", IP_ADDR);
                 builder.put("transport.publish_host", IP_ADDR);
diff --git a/test/framework/src/test/java/org/elasticsearch/test/test/InternalTestClusterTests.java b/test/framework/src/test/java/org/elasticsearch/test/test/InternalTestClusterTests.java
index 03da807..8b75e7f 100644
--- a/test/framework/src/test/java/org/elasticsearch/test/test/InternalTestClusterTests.java
+++ b/test/framework/src/test/java/org/elasticsearch/test/test/InternalTestClusterTests.java
@@ -26,6 +26,7 @@ import org.elasticsearch.common.settings.Settings;
 import org.elasticsearch.test.ESTestCase;
 import org.elasticsearch.test.InternalTestCluster;
 import org.elasticsearch.test.NodeConfigurationSource;
+import org.elasticsearch.transport.TransportSettings;
 
 import java.nio.file.Path;
 import java.util.Collections;
@@ -72,8 +73,7 @@ public class InternalTestClusterTests extends ESTestCase {
 
     static {
         clusterUniqueSettings.add(ClusterName.CLUSTER_NAME_SETTING.getKey());
-        clusterUniqueSettings.add("transport.tcp.port");
-        clusterUniqueSettings.add("http.port");
+        clusterUniqueSettings.add(TransportSettings.PORT.getKey());
         clusterUniqueSettings.add("http.port");
     }
 
