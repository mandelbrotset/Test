diff --git a/CHANGES b/CHANGES
index 1d8456d..49bfafb 100644
--- a/CHANGES
+++ b/CHANGES
@@ -17,10 +17,6 @@
 - Android Music no longer throws exceptions if MediaPlayer is null.
 - PolygonSpriteBatch implements Batch.
 - New scene2d actions: EventAction, CountdownEventAction.
-- Adds cancelHttpRequest() method to Net interface
-- Update GWT/HTML5 Backend to GWT 2.6.0
-- Minimal Android version is 2.2, see http://www.badlogicgames.com/wordpress/?p=3297
-- Updated to LWJGL 2.9.1
 
 [0.9.9]
 - added setCursorImage method to Input interface to support custom mouse cursors on the desktop
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index db60af0..5716215 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -10,22 +10,16 @@ If you modify a public API, or add a new one, make sure to add these changes to
 If you want to poll the brains of other devs, either send a pull request and start a conversation on Github, or start a new thread in [this sub-forum](http://www.badlogicgames.com/forum/viewforum.php?f=23). You will need special forum permissions, write an e-mail to contact at badlogicgames dot com and tell me your forum id. You should also subscribe to that forum via e-mail, there's a button at the bottom of the page. You can also drop by on IRC (irc.freenode.org, #libgdx), where most core devs are lurking.
 
 ### Contributor License Agreement
-
 Libgdx is licensed under the [Apache 2.0 license](http://en.wikipedia.org/wiki/Apache_License). Before we can accept code contributions, we need you to sign our [contributor license agreement](https://github.com/libgdx/libgdx/blob/master/CLA.txt). Just print it out, fill in the blanks and send a copy to contact@badlogicgames.com, with the subject `[Libgdx] CLA`.
 
 Signing the CLA will allow us to use and distribute your code. This is a non-exclusive license, so you retain all rights to your code. It's a fail-safe for us should someone contribute essential code and later decide to take it back.
 
-### Eclipse Formatter
-
+### Eclipse Formatter 
 If you work on libgdx code, we require you to use the [Eclipse formatter](https://github.com/libgdx/libgdx/blob/master/eclipse-formatter.xml) located in the root directory of the repository.
 
 Failure to use the formatter will result in Nate being very upset.
 
-If you are using IntelliJ IDEA, you can still make use of the eclipse code formatter:
-see: [this article](http://blog.jetbrains.com/idea/2014/01/intellij-idea-13-importing-code-formatter-settings-from-eclipse/?utm_source=hootsuite&utm_campaign=hootsuite)
-
-### Code Style
-
+### Code Style 
 Libgdx does not have an official coding standard. We mostly follow the usual [Java style](http://www.oracle.com/technetwork/java/codeconv-138413.html), and so should you.
 
 A few things we'd rather not like to see:
@@ -45,7 +39,6 @@ If you create a new class, please add at least class documentation that explains
 If your class is explicitly thread-safe, mention it in the Javadoc. The default assumption is that classes are not thread-safe, to reduce the amount of costly locks in the code base.
 
 ### Performance Considerations
-
 Libgdx is meant to run on both desktop and mobile platforms, including browsers (JavaScript!). While the desktop HotSpot VM can take quite a beating in terms of unnecessary allocations, Dalvik and consorts don't.
 
 A couple of guidelines:
@@ -59,7 +52,6 @@ A couple of guidelines:
   * Use pooling if necessary, if possible, avoid exposing the pooling to the user as it complicates the API
 
 ### Git
-
 Most of the libdgx team members are Git novices, as such we are just learning the ropes ourself. To lower the risk of getting something wrong, we'd kindly ask you to keep your pull requests small if possible. A change-set of 3000 files is likely not to get merged.
 
 We do open new branches for bigger API changes. If you help out with a new API, make sure your pull request targets that specific branch.
diff --git a/backends/gdx-backend-android/.classpath b/backends/gdx-backend-android/.classpath
index 132e7f4..b77e844 100644
--- a/backends/gdx-backend-android/.classpath
+++ b/backends/gdx-backend-android/.classpath
@@ -4,5 +4,6 @@
 	<classpathentry excluding="**/.svn/*" kind="src" path="src"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
 	<classpathentry kind="lib" path="libs/android-4.4.jar"/>
+	<classpathentry kind="lib" path="libs/support-v4-19.0.1.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/backends/gdx-backend-android/libs/LICENSE.txt b/backends/gdx-backend-android/libs/LICENSE.txt
deleted file mode 100644
index 8b7dcd3..0000000
--- a/backends/gdx-backend-android/libs/LICENSE.txt
+++ /dev/null
@@ -1,160 +0,0 @@
-License
-Terms and Conditions
-
-This is the Android Software Development Kit License Agreement.
-
-
-1. Introduction
-
-
-1.1 The Android Software Development Kit (referred to in this License Agreement as the "SDK" and specifically including the Android system files, packaged APIs, and Google APIs add-ons) is licensed to you subject to the terms of this License Agreement. This License Agreement forms a legally binding contract between you and Google in relation to your use of the SDK.
-
-1.2 "Android" means the Android software stack for devices, as made available under the Android Open Source Project, which is located at the following URL: http://source.android.com/, as updated from time to time.
-
-1.3 "Google" means Google Inc., a Delaware corporation with principal place of business at 1600 Amphitheatre Parkway, Mountain View, CA 94043, United States.
-
-
-2. Accepting this License Agreement
-
-
-2.1 In order to use the SDK, you must first agree to this License Agreement. You may not use the SDK if you do not accept this License Agreement.
-
-2.2 By clicking to accept, you hereby agree to the terms of this License Agreement.
-
-2.3 You may not use the SDK and may not accept the License Agreement if you are a person barred from receiving the SDK under the laws of the United States or other countries including the country in which you are resident or from which you use the SDK.
-
-2.4 If you are agreeing to be bound by this License Agreement on behalf of your employer or other entity, you represent and warrant that you have full legal authority to bind your employer or such entity to this License Agreement. If you do not have the requisite authority, you may not accept the License Agreement or use the SDK on behalf of your employer or other entity.
-
-
-3. SDK License from Google
-
-
-3.1 Subject to the terms of this License Agreement, Google grants you a limited, worldwide, royalty-free, non-assignable and non-exclusive license to use the SDK solely to develop applications to run on the Android platform.
-
-3.2 You agree that Google or third parties own all legal right, title and interest in and to the SDK, including any Intellectual Property Rights that subsist in the SDK. "Intellectual Property Rights" means any and all rights under patent law, copyright law, trade secret law, trademark law, and any and all other proprietary rights. Google reserves all rights not expressly granted to you.
-
-3.3 You may not use the SDK for any purpose not expressly permitted by this License Agreement.  Except to the extent required by applicable third party licenses, you may not: (a) copy (except for backup purposes), modify, adapt, redistribute, decompile, reverse engineer, disassemble, or create derivative works of the SDK or any part of the SDK; or (b) load any part of the SDK onto a mobile handset or any other hardware device except a personal computer, combine any part of the SDK with other software, or distribute any software or device incorporating a part of the SDK.
-
-3.4 You agree that you will not take any actions that may cause or result in the fragmentation of Android, including but not limited to distributing, participating in the creation of, or promoting in any way a software development kit derived from the SDK.
-
-3.5 Use, reproduction and distribution of components of the SDK licensed under an open source software license are governed solely by the terms of that open source software license and not this License Agreement.
-
-3.6 You agree that the form and nature of the SDK that Google provides may change without prior notice to you and that future versions of the SDK may be incompatible with applications developed on previous versions of the SDK. You agree that Google may stop (permanently or temporarily) providing the SDK (or any features within the SDK) to you or to users generally at Google's sole discretion, without prior notice to you.
-
-3.7 Nothing in this License Agreement gives you a right to use any of Google's trade names, trademarks, service marks, logos, domain names, or other distinctive brand features.
-
-3.8 You agree that you will not remove, obscure, or alter any proprietary rights notices (including copyright and trademark notices) that may be affixed to or contained within the SDK.
-
-
-4. Use of the SDK by You
-
-
-4.1 Google agrees that it obtains no right, title or interest from you (or your licensors) under this License Agreement in or to any software applications that you develop using the SDK, including any intellectual property rights that subsist in those applications.
-
-4.2 You agree to use the SDK and write applications only for purposes that are permitted by (a) this License Agreement and (b) any applicable law, regulation or generally accepted practices or guidelines in the relevant jurisdictions (including any laws regarding the export of data or software to and from the United States or other relevant countries).
-
-4.3 You agree that if you use the SDK to develop applications for general public users, you will protect the privacy and legal rights of those users. If the users provide you with user names, passwords, or other login information or personal information, you must make the users aware that the information will be available to your application, and you must provide legally adequate privacy notice and protection for those users. If your application stores personal or sensitive information provided by users, it must do so securely. If the user provides your application with Google Account information, your application may only use that information to access the user's Google Account when, and for the limited purposes for which, the user has given you permission to do so.
-
-4.4 You agree that you will not engage in any activity with the SDK, including the development or distribution of an application, that interferes with, disrupts, damages, or accesses in an unauthorized manner the servers, networks, or other properties or services of any third party including, but not limited to, Google or any mobile communications carrier.
-
-4.5 You agree that you are solely responsible for (and that Google has no responsibility to you or to any third party for) any data, content, or resources that you create, transmit or display through Android and/or applications for Android, and for the consequences of your actions (including any loss or damage which Google may suffer) by doing so.
-
-4.6 You agree that you are solely responsible for (and that Google has no responsibility to you or to any third party for) any breach of your obligations under this License Agreement, any applicable third party contract or Terms of Service, or any applicable law or regulation, and for the consequences (including any loss or damage which Google or any third party may suffer) of any such breach.
-
-
-5. Your Developer Credentials
-
-
-5.1 You agree that you are responsible for maintaining the confidentiality of any developer credentials that may be issued to you by Google or which you may choose yourself and that you will be solely responsible for all applications that are developed under your developer credentials.
-
-
-6. Privacy and Information
-
-
-6.1 In order to continually innovate and improve the SDK, Google may collect certain usage statistics from the software including but not limited to a unique identifier, associated IP address, version number of the software, and information on which tools and/or services in the SDK are being used and how they are being used. Before any of this information is collected, the SDK will notify you and seek your consent. If you withhold consent, the information will not be collected.
-
-6.2 The data collected is examined in the aggregate to improve the SDK and is maintained in accordance with Google's Privacy Policy.
-
-
-7. Third Party Applications
-
-
-7.1 If you use the SDK to run applications developed by a third party or that access data, content or resources provided by a third party, you agree that Google is not responsible for those applications, data, content, or resources. You understand that all data, content or resources which you may access through such third party applications are the sole responsibility of the person from which they originated and that Google is not liable for any loss or damage that you may experience as a result of the use or access of any of those third party applications, data, content, or resources.
-
-7.2 You should be aware the data, content, and resources presented to you through such a third party application may be protected by intellectual property rights which are owned by the providers (or by other persons or companies on their behalf). You may not modify, rent, lease, loan, sell, distribute or create derivative works based on these data, content, or resources (either in whole or in part) unless you have been specifically given permission to do so by the relevant owners.
-
-7.3 You acknowledge that your use of such third party applications, data, content, or resources may be subject to separate terms between you and the relevant third party. In that case, this License Agreement does not affect your legal relationship with these third parties.
-
-
-8. Using Android APIs
-
-
-8.1 Google Data APIs
-
-8.1.1 If you use any API to retrieve data from Google, you acknowledge that the data may be protected by intellectual property rights which are owned by Google or those parties that provide the data (or by other persons or companies on their behalf). Your use of any such API may be subject to additional Terms of Service. You may not modify, rent, lease, loan, sell, distribute or create derivative works based on this data (either in whole or in part) unless allowed by the relevant Terms of Service.
-
-8.1.2 If you use any API to retrieve a user's data from Google, you acknowledge and agree that you shall retrieve data only with the user's explicit consent and only when, and for the limited purposes for which, the user has given you permission to do so.
-
-
-9. Terminating this License Agreement
-
-
-9.1 This License Agreement will continue to apply until terminated by either you or Google as set out below.
-
-9.2 If you want to terminate this License Agreement, you may do so by ceasing your use of the SDK and any relevant developer credentials.
-
-9.3 Google may at any time, terminate this License Agreement with you if:
-(A) you have breached any provision of this License Agreement; or
-(B) Google is required to do so by law; or
-(C) the partner with whom Google offered certain parts of SDK (such as APIs) to you has terminated its relationship with Google or ceased to offer certain parts of the SDK to you; or
-(D) Google decides to no longer provide the SDK or certain parts of the SDK to users in the country in which you are resident or from which you use the service, or the provision of the SDK or certain SDK services to you by Google is, in Google's sole discretion, no longer commercially viable.
-
-9.4 When this License Agreement comes to an end, all of the legal rights, obligations and liabilities that you and Google have benefited from, been subject to (or which have accrued over time whilst this License Agreement has been in force) or which are expressed to continue indefinitely, shall be unaffected by this cessation, and the provisions of paragraph 14.7 shall continue to apply to such rights, obligations and liabilities indefinitely.
-
-
-10. DISCLAIMER OF WARRANTIES
-
-
-10.1 YOU EXPRESSLY UNDERSTAND AND AGREE THAT YOUR USE OF THE SDK IS AT YOUR SOLE RISK AND THAT THE SDK IS PROVIDED "AS IS" AND "AS AVAILABLE" WITHOUT WARRANTY OF ANY KIND FROM GOOGLE.
-
-10.2 YOUR USE OF THE SDK AND ANY MATERIAL DOWNLOADED OR OTHERWISE OBTAINED THROUGH THE USE OF THE SDK IS AT YOUR OWN DISCRETION AND RISK AND YOU ARE SOLELY RESPONSIBLE FOR ANY DAMAGE TO YOUR COMPUTER SYSTEM OR OTHER DEVICE OR LOSS OF DATA THAT RESULTS FROM SUCH USE.
-
-10.3 GOOGLE FURTHER EXPRESSLY DISCLAIMS ALL WARRANTIES AND CONDITIONS OF ANY KIND, WHETHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO THE IMPLIED WARRANTIES AND CONDITIONS OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
-
-
-11. LIMITATION OF LIABILITY
-
-
-11.1 YOU EXPRESSLY UNDERSTAND AND AGREE THAT GOOGLE, ITS SUBSIDIARIES AND AFFILIATES, AND ITS LICENSORS SHALL NOT BE LIABLE TO YOU UNDER ANY THEORY OF LIABILITY FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL OR EXEMPLARY DAMAGES THAT MAY BE INCURRED BY YOU, INCLUDING ANY LOSS OF DATA, WHETHER OR NOT GOOGLE OR ITS REPRESENTATIVES HAVE BEEN ADVISED OF OR SHOULD HAVE BEEN AWARE OF THE POSSIBILITY OF ANY SUCH LOSSES ARISING.
-
-
-12. Indemnification
-
-
-12.1 To the maximum extent permitted by law, you agree to defend, indemnify and hold harmless Google, its affiliates and their respective directors, officers, employees and agents from and against any and all claims, actions, suits or proceedings, as well as any and all losses, liabilities, damages, costs and expenses (including reasonable attorneys fees) arising out of or accruing from (a) your use of the SDK, (b) any application you develop on the SDK that infringes any copyright, trademark, trade secret, trade dress, patent or other intellectual property right of any person or defames any person or violates their rights of publicity or privacy, and (c) any non-compliance by you with this License Agreement.
-
-
-13. Changes to the License Agreement
-
-
-13.1 Google may make changes to the License Agreement as it distributes new versions of the SDK. When these changes are made, Google will make a new version of the License Agreement available on the website where the SDK is made available.
-
-
-14. General Legal Terms
-
-
-14.1 This License Agreement constitutes the whole legal agreement between you and Google and governs your use of the SDK (excluding any services which Google may provide to you under a separate written agreement), and completely replaces any prior agreements between you and Google in relation to the SDK.
-
-14.2 You agree that if Google does not exercise or enforce any legal right or remedy which is contained in this License Agreement (or which Google has the benefit of under any applicable law), this will not be taken to be a formal waiver of Google's rights and that those rights or remedies will still be available to Google.
-
-14.3 If any court of law, having the jurisdiction to decide on this matter, rules that any provision of this License Agreement is invalid, then that provision will be removed from this License Agreement without affecting the rest of this License Agreement. The remaining provisions of this License Agreement will continue to be valid and enforceable.
-
-14.4 You acknowledge and agree that each member of the group of companies of which Google is the parent shall be third party beneficiaries to this License Agreement and that such other companies shall be entitled to directly enforce, and rely upon, any provision of this License Agreement that confers a benefit on (or rights in favor of) them. Other than this, no other person or company shall be third party beneficiaries to this License Agreement.
-
-14.5 EXPORT RESTRICTIONS. THE SDK IS SUBJECT TO UNITED STATES EXPORT LAWS AND REGULATIONS. YOU MUST COMPLY WITH ALL DOMESTIC AND INTERNATIONAL EXPORT LAWS AND REGULATIONS THAT APPLY TO THE SDK. THESE LAWS INCLUDE RESTRICTIONS ON DESTINATIONS, END USERS AND END USE.
-
-14.6 The rights granted in this License Agreement may not be assigned or transferred by either you or Google without the prior written approval of the other party. Neither you nor Google shall be permitted to delegate their responsibilities or obligations under this License Agreement without the prior written approval of the other party.
-
-14.7 This License Agreement, and your relationship with Google under this License Agreement, shall be governed by the laws of the State of California without regard to its conflict of laws provisions. You and Google agree to submit to the exclusive jurisdiction of the courts located within the county of Santa Clara, California to resolve any legal matter arising from this License Agreement. Notwithstanding this, you agree that Google shall still be allowed to apply for injunctive remedies (or an equivalent type of urgent legal relief) in any jurisdiction.
-
-November 13, 2012
\ No newline at end of file
diff --git a/backends/gdx-backend-android/libs/support-v4-19.0.1.jar b/backends/gdx-backend-android/libs/support-v4-19.0.1.jar
new file mode 100644
index 0000000..f469c58
Binary files /dev/null and b/backends/gdx-backend-android/libs/support-v4-19.0.1.jar differ
diff --git a/backends/gdx-backend-android/pom.xml b/backends/gdx-backend-android/pom.xml
index 50b3c85..bac3bca 100644
--- a/backends/gdx-backend-android/pom.xml
+++ b/backends/gdx-backend-android/pom.xml
@@ -11,7 +11,7 @@
   <artifactId>gdx-backend-android</artifactId>
   <packaging>jar</packaging>
   <name>libGDX Android Backend</name>
-
+  
   <dependencies>
     <dependency>
       <groupId>${project.groupId}</groupId>
@@ -28,6 +28,14 @@
       <systemPath>${basedir}/libs/android-4.4.jar</systemPath>
       <optional>true</optional>
     </dependency>
+    
+    <dependency>
+	    <groupId>com.android.support</groupId>
+	    <artifactId>support-v4</artifactId>
+	    <version>19.0.1</version>
+	    <scope>system</scope>
+      <systemPath>${basedir}/libs/support-v4-19.0.1.jar</systemPath>
+	  </dependency>
   </dependencies>
 
   <build>
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidApplication.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidApplication.java
index 1c50fb9..00622bc 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidApplication.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidApplication.java
@@ -56,7 +56,7 @@ import com.badlogic.gdx.utils.GdxNativesLoader;
  * configuration for the GLSurfaceView.
  * 
  * @author mzechner */
-public class AndroidApplication extends Activity implements Application {
+public class AndroidApplication extends Activity implements AndroidApplicationBase {
 	static {
 		GdxNativesLoader.load();
 	}
@@ -75,8 +75,6 @@ public class AndroidApplication extends Activity implements Application {
 	protected int logLevel = LOG_INFO;
 	protected boolean useImmersiveMode = false;
 	protected boolean hideStatusBar = false;
-	private int wasFocusChanged = -1;
-	private boolean isWaitingForAudio = false;
 
 	/** This method has to be called in the {@link Activity#onCreate(Bundle)} method. It sets up all the things necessary to get
 	 * input, render via OpenGL and so on. If useGL20IfAvailable is set the AndroidApplication will try to create an OpenGL ES 2.0
@@ -145,8 +143,8 @@ public class AndroidApplication extends Activity implements Application {
 	}
 
 	protected FrameLayout.LayoutParams createLayoutParams () {
-		FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(android.view.ViewGroup.LayoutParams.MATCH_PARENT,
-			android.view.ViewGroup.LayoutParams.MATCH_PARENT);
+		FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(android.view.ViewGroup.LayoutParams.FILL_PARENT,
+			android.view.ViewGroup.LayoutParams.FILL_PARENT);
 		layoutParams.gravity = Gravity.CENTER;
 		return layoutParams;
 	}
@@ -176,15 +174,6 @@ public class AndroidApplication extends Activity implements Application {
 		super.onWindowFocusChanged(hasFocus);
 		useImmersiveMode(this.useImmersiveMode);
 		hideStatusBar(this.hideStatusBar);
-		if (hasFocus) {
-			this.wasFocusChanged = 1;
-			if (this.isWaitingForAudio) {
-				this.audio.resume();
-				this.isWaitingForAudio = false;
-			}
-		} else {
-			this.wasFocusChanged = 0;
-		}
 	}
 
 	protected void useImmersiveMode (boolean use) {
@@ -321,12 +310,6 @@ public class AndroidApplication extends Activity implements Application {
 			graphics.resume();
 		} else
 			firstResume = false;
-
-		this.isWaitingForAudio = true;
-		if (this.wasFocusChanged == 1 || this.wasFocusChanged == -1) {
-			this.audio.resume();
-			this.isWaitingForAudio = false;
-		}
 		super.onResume();
 	}
 
@@ -372,7 +355,7 @@ public class AndroidApplication extends Activity implements Application {
 
 	@Override
 	public int getVersion () {
-		return android.os.Build.VERSION.SDK_INT;
+		return Integer.parseInt(android.os.Build.VERSION.SDK);
 	}
 
 	@Override
@@ -483,4 +466,24 @@ public class AndroidApplication extends Activity implements Application {
 			lifecycleListeners.removeValue(listener, true);
 		}
 	}
-}
+
+	@Override
+	public Context getContext () {
+		return this;
+	}
+
+	@Override
+	public Array<Runnable> getRunnables () {
+		return runnables;
+	}
+
+	@Override
+	public Array<Runnable> getExecutedRunnables () {
+		return executedRunnables;
+	}
+
+	@Override
+	public Array<LifecycleListener> getLifecycleListeners () {
+		return lifecycleListeners;
+	}
+}
\ No newline at end of file
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidApplicationBase.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidApplicationBase.java
new file mode 100644
index 0000000..c1fc10d
--- /dev/null
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidApplicationBase.java
@@ -0,0 +1,80 @@
+package com.badlogic.gdx.backends.android;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+
+import com.badlogic.gdx.Application;
+import com.badlogic.gdx.ApplicationListener;
+import com.badlogic.gdx.Audio;
+import com.badlogic.gdx.Input;
+import com.badlogic.gdx.LifecycleListener;
+import com.badlogic.gdx.utils.Array;
+
+/**
+ * Interface that abstracts the Android application class usages, so that libGDX can be used with a fragment (or with any other client code) 
+ * 
+ * @author Bartol Karuza (me@bartolkaruza.com)
+ *
+ */
+public interface AndroidApplicationBase extends Application {
+	
+	/**
+	 * The application or activity context
+	 * 
+	 * @return The {@link Context}
+	 * 
+	 */
+	Context getContext();
+	
+	/**
+	 * The provided application listener
+	 * 
+	 * @return the application listener
+	 */
+	ApplicationListener getApplicationListener();
+	
+	/**
+	 * A set of usable runnables
+	 * 
+	 * @return the {@link Runnable} array
+	 */
+	Array<Runnable> getRunnables();
+	
+	/**
+	 * The currently executed runnables
+	 *
+	 * @return the {@link Runnable} array 
+	 */
+	Array<Runnable> getExecutedRunnables();
+	
+	/**
+	 * Method signifies an intent of the caller to execute some action on the UI Thread.
+	 * 
+	 * @param runnable The runnable to be executed
+	 */
+	void runOnUiThread(Runnable runnable);
+	
+	/**
+	 * Method signifies an intent to start an activity, may be the default method of 
+	 * the {@link Activity} class
+	 *  
+	 * @param intent The {@link Intent} for starting an activity
+	 */
+	void startActivity(Intent intent);
+	
+	/**
+	 * Returns the {@link Audio} object associated with this {@link AndroidApplicationBase}
+	 * 
+	 * @return the {@link Audio} object
+	 */
+	Audio getAudio();
+	
+	/**
+	 * Returns the {@link LifecycleListener} array associated with this {@link AndroidApplicationBase}
+	 * 
+	 * @return the array of {@link LifecycleListener}'s
+	 */
+	Array<LifecycleListener> getLifecycleListeners();
+
+}
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidAudio.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidAudio.java
index 487e947..c0082a9 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidAudio.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidAudio.java
@@ -48,7 +48,7 @@ public final class AndroidAudio implements Audio {
 		if (!config.disableAudio) {
 			soundPool = new SoundPool(config.maxSimultaneousSounds, AudioManager.STREAM_MUSIC, 100);
 			manager = (AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
-			if (context instanceof Activity) {
+			if(context instanceof Activity) {
 				((Activity)context).setVolumeControlStream(AudioManager.STREAM_MUSIC);
 			}
 		} else {
@@ -71,7 +71,6 @@ public final class AndroidAudio implements Audio {
 					music.wasPlaying = false;
 			}
 		}
-		this.soundPool.autoPause();
 	}
 
 	protected void resume () {
@@ -83,7 +82,6 @@ public final class AndroidAudio implements Audio {
 				if (musics.get(i).wasPlaying == true) musics.get(i).play();
 			}
 		}
-		this.soundPool.autoResume();
 	}
 
 	/** {@inheritDoc} */
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidAudioDevice.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidAudioDevice.java
index 21c1813..4e289c7 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidAudioDevice.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidAudioDevice.java
@@ -40,10 +40,10 @@ class AndroidAudioDevice implements AudioDevice {
 
 	AndroidAudioDevice (int samplingRate, boolean isMono) {
 		this.isMono = isMono;
-		int minSize = AudioTrack.getMinBufferSize(samplingRate, isMono ? AudioFormat.CHANNEL_OUT_MONO
-			: AudioFormat.CHANNEL_OUT_STEREO, AudioFormat.ENCODING_PCM_16BIT);
-		track = new AudioTrack(AudioManager.STREAM_MUSIC, samplingRate, isMono ? AudioFormat.CHANNEL_OUT_MONO
-			: AudioFormat.CHANNEL_OUT_STEREO, AudioFormat.ENCODING_PCM_16BIT, minSize, AudioTrack.MODE_STREAM);
+		int minSize = AudioTrack.getMinBufferSize(samplingRate, isMono ? AudioFormat.CHANNEL_CONFIGURATION_MONO
+			: AudioFormat.CHANNEL_CONFIGURATION_STEREO, AudioFormat.ENCODING_PCM_16BIT);
+		track = new AudioTrack(AudioManager.STREAM_MUSIC, samplingRate, isMono ? AudioFormat.CHANNEL_CONFIGURATION_MONO
+			: AudioFormat.CHANNEL_CONFIGURATION_STEREO, AudioFormat.ENCODING_PCM_16BIT, minSize, AudioTrack.MODE_STREAM);
 		track.play();
 		latency = minSize / (isMono ? 1 : 2);
 	}
@@ -93,4 +93,4 @@ class AndroidAudioDevice implements AudioDevice {
 	public void setVolume (float volume) {
 		track.setStereoVolume(volume, volume);
 	}
-}
\ No newline at end of file
+}
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidDaydream.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidDaydream.java
index a6d3ec6..7422d17 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidDaydream.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidDaydream.java
@@ -123,8 +123,8 @@ public class AndroidDaydream extends DreamService implements Application {
 	}
 
 	protected FrameLayout.LayoutParams createLayoutParams () {
-		FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(android.view.ViewGroup.LayoutParams.MATCH_PARENT,
-			android.view.ViewGroup.LayoutParams.MATCH_PARENT);
+		FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(android.view.ViewGroup.LayoutParams.FILL_PARENT,
+			android.view.ViewGroup.LayoutParams.FILL_PARENT);
 		layoutParams.gravity = Gravity.CENTER;
 		return layoutParams;
 	}
@@ -294,7 +294,7 @@ public class AndroidDaydream extends DreamService implements Application {
 
 	@Override
 	public int getVersion () {
-		return android.os.Build.VERSION.SDK_INT;
+		return Integer.parseInt(android.os.Build.VERSION.SDK);
 	}
 
 	@Override
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidFragmentApplication.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidFragmentApplication.java
new file mode 100644
index 0000000..15d2c20
--- /dev/null
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidFragmentApplication.java
@@ -0,0 +1,386 @@
+package com.badlogic.gdx.backends.android;
+
+import java.lang.reflect.Method;
+import java.util.Arrays;
+
+import com.badlogic.gdx.ApplicationListener;
+import com.badlogic.gdx.Audio;
+import com.badlogic.gdx.Files;
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.Graphics;
+import com.badlogic.gdx.Input;
+import com.badlogic.gdx.LifecycleListener;
+import com.badlogic.gdx.Net;
+import com.badlogic.gdx.Preferences;
+import com.badlogic.gdx.backends.android.surfaceview.FillResolutionStrategy;
+import com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18;
+import com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewCupcake;
+import com.badlogic.gdx.graphics.GL10;
+import com.badlogic.gdx.graphics.GL11;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.Clipboard;
+import com.badlogic.gdx.utils.GdxNativesLoader;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.res.Configuration;
+import android.os.Debug;
+import android.os.Handler;
+import android.support.v4.app.Fragment;
+import android.util.Log;
+import android.view.Gravity;
+import android.view.View;
+import android.view.WindowManager;
+import android.widget.FrameLayout;
+
+/**
+ * Implementation of the {@link AndroidApplicationBase} that is based on the {@link Fragment} class. This class is similar
+ * in use to the {@link AndroidApplication} class, which is based on an {@link Activity}.
+ * 
+ * @author Bartol Karuza (me@bartolkaruza.com)
+ *
+ */
+public class AndroidFragmentApplication extends Fragment implements AndroidApplicationBase {
+	
+	/**
+	 * Callbacks interface for letting the fragment interact with the Activitiy, parent fragment or target fragment.
+	 * @author x077186
+	 *
+	 */
+	public interface Callbacks {
+		void exit();
+	}
+	
+	static {
+      GdxNativesLoader.load();
+  }
+
+  protected AndroidGraphics graphics;
+  protected AndroidInput input;
+  protected AndroidAudio audio;
+  protected AndroidFiles files;
+  protected AndroidNet net;
+  protected ApplicationListener listener;
+  public Handler handler;
+  protected boolean firstResume = true;
+  protected final Array<Runnable> runnables = new Array<Runnable>();
+  protected final Array<Runnable> executedRunnables = new Array<Runnable>();
+  protected final Array<LifecycleListener> lifecycleListeners = new Array<LifecycleListener>();
+  protected int logLevel = LOG_INFO;
+  
+  protected Callbacks callbacks;
+  
+  @Override
+	public void onAttach (Activity activity) {
+		if(activity instanceof Callbacks) {
+			this.callbacks = (Callbacks)activity;
+		} else if(getParentFragment() instanceof Callbacks) {
+			this.callbacks = (Callbacks)getParentFragment();
+		} else if (getTargetFragment() instanceof Callbacks) {
+			this.callbacks = (Callbacks)getTargetFragment();
+		} else {
+			throw new RuntimeException("Missing AndroidFragmentApplication.Callbacks. Please implement AndroidFragmentApplication.Callbacks on the parent activity, fragment or target fragment.");
+		}
+		super.onAttach(activity);
+	}
+  
+  @Override
+	public void onDetach () {
+		super.onDetach();
+		this.callbacks = null;
+	}
+
+  protected FrameLayout.LayoutParams createLayoutParams () {
+      FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(android.view.ViewGroup.LayoutParams.FILL_PARENT, android.view.ViewGroup.LayoutParams.FILL_PARENT);
+      layoutParams.gravity = Gravity.CENTER;
+      return layoutParams;
+  }
+
+  protected void createWakeLock (boolean use) {
+      if (use) {
+          getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
+      }
+  }
+
+  /** This method has to be called in the {@link Fragment#onCreateView(android.view.LayoutInflater, android.view.ViewGroup, android.os.Bundle)} method. 
+   * It sets up all the things necessary to get input, render via OpenGL and so on. If useGL20IfAvailable is set the AndroidApplication will try to 
+   * create an OpenGL ES 2.0 context which can then be used via {@link Graphics#getGL20()}. The {@link GL10} and {@link GL11} interfaces should not be
+   * used when OpenGL ES 2.0 is enabled. To query whether enabling OpenGL ES 2.0 was successful use the
+   * {@link Graphics#isGL20Available()} method. Uses a default {@link AndroidApplicationConfiguration}.
+   * <p/>
+   * Note: you have to return the returned view from the {@link Fragment#onCreateView(android.view.LayoutInflater, android.view.ViewGroup, android.os.Bundle)}!
+   *
+   * @param listener the {@link ApplicationListener} implementing the program logic
+   * @param useGL2IfAvailable whether to use OpenGL ES 2.0 if its available.
+   * @return the GLSurfaceView of the application */
+  public View initializeForView (ApplicationListener listener, boolean useGL2IfAvailable) {
+      AndroidApplicationConfiguration config = new AndroidApplicationConfiguration();
+      config.useGL20 = useGL2IfAvailable;
+      return initializeForView(listener, config);
+  }
+
+  /** This method has to be called in the {@link Fragment#onCreateView(android.view.LayoutInflater, android.view.ViewGroup, android.os.Bundle)} method. 
+   * It sets up all the things necessary to get input, render via OpenGL and so on. If config.useGL20 is set the AndroidApplication will try to create 
+   * an OpenGL ES 2.0 context which can then be used via {@link Graphics#getGL20()}. The {@link GL10} and {@link GL11} interfaces should not be
+   * used when OpenGL ES 2.0 is enabled. To query whether enabling OpenGL ES 2.0 was successful use the
+   * {@link Graphics#isGL20Available()} method. You can configure other aspects of the application with the rest of the fields in
+   * the {@link AndroidApplicationConfiguration} instance.
+   * <p/>
+   * Note: you have to return the returned view from {@link Fragment#onCreateView(android.view.LayoutInflater, android.view.ViewGroup, android.os.Bundle)}}
+   *
+   * @param listener the {@link ApplicationListener} implementing the program logic
+   * @param config the {@link AndroidApplicationConfiguration}, defining various settings of the application (use accelerometer,
+   *           etc.).
+   * @return the GLSurfaceView of the application */
+  public View initializeForView (ApplicationListener listener, AndroidApplicationConfiguration config) {
+      graphics = new AndroidGraphics(this, config, config.resolutionStrategy == null ? new FillResolutionStrategy(): config.resolutionStrategy);
+      input = AndroidInputFactory.newAndroidInput(this, getActivity(), graphics.view, config);
+      audio = new AndroidAudio(getActivity(), config);
+      files = new AndroidFiles(getResources().getAssets(), getActivity().getFilesDir().getAbsolutePath());
+      net = new AndroidNet(this);
+      this.listener = listener;
+      this.handler = new Handler();
+
+      Gdx.app = this;
+      Gdx.input = this.getInput();
+      Gdx.audio = this.getAudio();
+      Gdx.files = this.getFiles();
+      Gdx.graphics = this.getGraphics();
+      Gdx.net = this.getNet();
+      createWakeLock(config.useWakelock);
+      return graphics.getView();
+  }
+
+  @Override
+  public void onPause () {
+      boolean isContinuous = graphics.isContinuousRendering();
+      graphics.setContinuousRendering(true);
+      graphics.pause();
+
+      input.unregisterSensorListeners();
+
+      int[] realId = input.realId;
+      // erase pointer ids. this sucks donkeyballs...
+      Arrays.fill(realId, -1);
+      boolean[] touched = input.touched;
+      // erase touched state. this also sucks donkeyballs...
+      Arrays.fill(touched, false);
+
+      if (getActivity().isFinishing()) {
+          graphics.clearManagedCaches();
+          graphics.destroy();
+      }
+      graphics.setContinuousRendering(isContinuous);
+
+      if (graphics != null && graphics.view != null) {
+          if (graphics.view instanceof GLSurfaceViewCupcake) ((GLSurfaceViewCupcake)graphics.view).onPause();
+          if (graphics.view instanceof GLSurfaceViewAPI18) ((GLSurfaceViewAPI18)graphics.view).onPause();
+          if (graphics.view instanceof android.opengl.GLSurfaceView) ((android.opengl.GLSurfaceView)graphics.view).onPause();
+      }
+
+      super.onPause();
+  }
+
+  @Override
+  public void onResume () {
+      Gdx.app = this;
+      Gdx.input = this.getInput();
+      Gdx.audio = this.getAudio();
+      Gdx.files = this.getFiles();
+      Gdx.graphics = this.getGraphics();
+      Gdx.net = this.getNet();
+
+      ((AndroidInput)getInput()).registerSensorListeners();
+
+      if (graphics != null && graphics.view != null) {
+          if (graphics.view instanceof GLSurfaceViewCupcake) ((GLSurfaceViewCupcake)graphics.view).onResume();
+          if (graphics.view instanceof GLSurfaceViewAPI18) ((GLSurfaceViewAPI18)graphics.view).onResume();
+          if (graphics.view instanceof android.opengl.GLSurfaceView) ((android.opengl.GLSurfaceView)graphics.view).onResume();
+      }
+
+      if (!firstResume) {
+          graphics.resume();
+      } else
+          firstResume = false;
+      super.onResume();
+  }
+
+  @Override
+  public void onDestroy () {
+      super.onDestroy();
+  }
+
+  @Override
+  public ApplicationListener getApplicationListener () {
+      return listener;
+  }
+
+  @Override
+  public Audio getAudio () {
+      return audio;
+  }
+
+  @Override
+  public Files getFiles () {
+      return files;
+  }
+
+  @Override
+  public Graphics getGraphics () {
+      return graphics;
+  }
+
+  @Override
+  public Input getInput () {
+      return input;
+  }
+
+  @Override
+  public Net getNet () {
+      return net;
+  }
+
+  @Override
+  public ApplicationType getType () {
+      return ApplicationType.Android;
+  }
+
+  @Override
+  public int getVersion () {
+      return Integer.parseInt(android.os.Build.VERSION.SDK);
+  }
+
+  @Override
+  public long getJavaHeap () {
+      return Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
+  }
+
+  @Override
+  public long getNativeHeap () {
+      return Debug.getNativeHeapAllocatedSize();
+  }
+
+  @Override
+  public Preferences getPreferences (String name) {
+      return new AndroidPreferences(getActivity().getSharedPreferences(name, Context.MODE_PRIVATE));
+  }
+
+  AndroidClipboard clipboard;
+
+  @Override
+  public Clipboard getClipboard () {
+      if (clipboard == null) {
+          clipboard = new AndroidClipboard(getActivity());
+      }
+      return clipboard;
+  }
+
+  @Override
+  public void postRunnable (Runnable runnable) {
+      synchronized (runnables) {
+          runnables.add(runnable);
+          Gdx.graphics.requestRendering();
+      }
+  }
+
+  @Override
+  public void onConfigurationChanged (Configuration config) {
+      super.onConfigurationChanged(config);
+      boolean keyboardAvailable = false;
+      if (config.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_NO) keyboardAvailable = true;
+      input.keyboardAvailable = keyboardAvailable;
+  }
+
+  @Override
+  public void exit () {
+      handler.post(new Runnable() {
+          @Override
+          public void run () {
+              callbacks.exit();
+          }
+      });
+  }
+
+  @Override
+  public void debug (String tag, String message) {
+      if (logLevel >= LOG_DEBUG) {
+          Log.d(tag, message);
+      }
+  }
+
+  @Override
+  public void debug (String tag, String message, Throwable exception) {
+      if (logLevel >= LOG_DEBUG) {
+          Log.d(tag, message, exception);
+      }
+  }
+
+  @Override
+  public void log (String tag, String message) {
+      if (logLevel >= LOG_INFO) Log.i(tag, message);
+  }
+
+  @Override
+  public void log (String tag, String message, Throwable exception) {
+      if (logLevel >= LOG_INFO) Log.i(tag, message, exception);
+  }
+
+  @Override
+  public void error (String tag, String message) {
+      if (logLevel >= LOG_ERROR) Log.e(tag, message);
+  }
+
+  @Override
+  public void error (String tag, String message, Throwable exception) {
+      if (logLevel >= LOG_ERROR) Log.e(tag, message, exception);
+  }
+
+  @Override
+  public void setLogLevel (int logLevel) {
+      this.logLevel = logLevel;
+  }
+
+  @Override
+  public int getLogLevel () {
+      return logLevel;
+  }
+
+  @Override
+  public void addLifecycleListener (LifecycleListener listener) {
+      synchronized (lifecycleListeners) {
+          lifecycleListeners.add(listener);
+      }
+  }
+
+  @Override
+  public void removeLifecycleListener (LifecycleListener listener) {
+      synchronized (lifecycleListeners) {
+          lifecycleListeners.removeValue(listener, true);
+      }
+  }
+
+	@Override
+	public Context getContext () {
+		return getActivity();
+	}
+	
+	@Override
+	public Array<Runnable> getRunnables () {
+		return runnables;
+	}
+	
+	@Override
+	public Array<Runnable> getExecutedRunnables () {
+		return executedRunnables;
+	}
+
+	@Override
+	public void runOnUiThread (Runnable runnable) {
+		getActivity().runOnUiThread(runnable);
+	}
+
+	@Override
+	public Array<LifecycleListener> getLifecycleListeners () {
+		return lifecycleListeners;
+	}
+}
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphics.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphics.java
index c2e5380..ede8df9 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphics.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphics.java
@@ -17,6 +17,7 @@
 package com.badlogic.gdx.backends.android;
 
 import android.app.Activity;
+import android.content.Context;
 import android.opengl.GLSurfaceView;
 import android.opengl.GLSurfaceView.EGLConfigChooser;
 import android.opengl.GLSurfaceView.Renderer;
@@ -26,6 +27,7 @@ import android.view.Display;
 import android.view.KeyCharacterMap;
 import android.view.KeyEvent;
 import android.view.View;
+import android.view.WindowManager;
 import android.view.inputmethod.BaseInputConnection;
 import android.view.inputmethod.EditorInfo;
 import android.view.inputmethod.InputConnection;
@@ -58,12 +60,15 @@ import javax.microedition.khronos.egl.EGLDisplay;
 
 /** An implementation of {@link Graphics} for Android.
  * 
- * @author mzechner */
+ * @author mzechner 
+ * 
+ * 
+ * */
 public final class AndroidGraphics implements Graphics, Renderer {
 	final View view;
 	int width;
 	int height;
-	AndroidApplication app;
+	AndroidApplicationBase app;
 	GLCommon gl;
 	GL10 gl10;
 	GL11 gl11;
@@ -94,18 +99,18 @@ public final class AndroidGraphics implements Graphics, Renderer {
 	private BufferFormat bufferFormat = new BufferFormat(5, 6, 5, 0, 16, 0, 0, false);
 	private boolean isContinuous = true;
 
-	public AndroidGraphics (AndroidApplication activity, AndroidApplicationConfiguration config,
+	public AndroidGraphics (AndroidApplicationBase application, AndroidApplicationConfiguration config,
 		ResolutionStrategy resolutionStrategy) {
 		this.config = config;
-		view = createGLSurfaceView(activity, config.useGL20, resolutionStrategy);
+		view = createGLSurfaceView(application, config.useGL20, resolutionStrategy);
 		setPreserveContext(view);
 		view.setFocusable(true);
 		view.setFocusableInTouchMode(true);
-		this.app = activity;
+		this.app = application;
 	}
 
 	private void setPreserveContext (View view) {
-		int sdkVersion = android.os.Build.VERSION.SDK_INT;
+		int sdkVersion = Integer.parseInt(android.os.Build.VERSION.SDK);
 		if (sdkVersion >= 11 && view instanceof GLSurfaceView20) {
 			try {
 				Method method = null;
@@ -123,11 +128,11 @@ public final class AndroidGraphics implements Graphics, Renderer {
 		}
 	}
 
-	private View createGLSurfaceView (Activity activity, boolean useGL2, final ResolutionStrategy resolutionStrategy) {
+	private View createGLSurfaceView (AndroidApplicationBase application, boolean useGL2, final ResolutionStrategy resolutionStrategy) {
 		EGLConfigChooser configChooser = getEglConfigChooser();
 
 		if (useGL2 && checkGL20()) {
-			GLSurfaceView20 view = new GLSurfaceView20(activity, resolutionStrategy);
+			GLSurfaceView20 view = new GLSurfaceView20(application.getContext(), resolutionStrategy);
 			if (configChooser != null)
 				view.setEGLConfigChooser(configChooser);
 			else
@@ -137,10 +142,10 @@ public final class AndroidGraphics implements Graphics, Renderer {
 		} else {
 			config.useGL20 = false;
 			configChooser = getEglConfigChooser();
-			int sdkVersion = android.os.Build.VERSION.SDK_INT;
+			int sdkVersion = Integer.parseInt(android.os.Build.VERSION.SDK);
 
 			if (sdkVersion >= 11) {
-				GLSurfaceView view = new GLSurfaceView(activity) {
+				GLSurfaceView view = new GLSurfaceView(application.getContext()) {
 					@Override
 					protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {
 						ResolutionStrategy.MeasuredDimension measures = resolutionStrategy.calcMeasures(widthMeasureSpec,
@@ -153,12 +158,11 @@ public final class AndroidGraphics implements Graphics, Renderer {
 						BaseInputConnection connection = new BaseInputConnection(this, false) {
 							@Override
 							public boolean deleteSurroundingText (int beforeLength, int afterLength) {
-								int sdkVersion = android.os.Build.VERSION.SDK_INT;
+								int sdkVersion = Integer.parseInt(android.os.Build.VERSION.SDK);
 								if (sdkVersion >= 16) {
-									/*
-									 * In Jelly Bean, they don't send key events for delete. Instead, they send beforeLength = 1,
-									 * afterLength = 0. So, we'll just simulate what it used to do.
-									 */
+									/* In Jelly Bean, they don't send key events for delete.
+									 *  Instead, they send beforeLength = 1, afterLength = 0.
+									 *  So, we'll just simulate what it used to do. */
 									if (beforeLength == 1 && afterLength == 0) {
 										sendDownUpKeyEventForBackwardCompatibility(KeyEvent.KEYCODE_DEL);
 										return true;
@@ -166,7 +170,6 @@ public final class AndroidGraphics implements Graphics, Renderer {
 								}
 								return super.deleteSurroundingText(beforeLength, afterLength);
 							}
-
 							private void sendDownUpKeyEventForBackwardCompatibility (final int code) {
 								final long eventTime = SystemClock.uptimeMillis();
 								super.sendKeyEvent(new KeyEvent(eventTime, eventTime, KeyEvent.ACTION_DOWN, code, 0, 0,
@@ -187,15 +190,16 @@ public final class AndroidGraphics implements Graphics, Renderer {
 				return view;
 			} else {
 				if (config.useGLSurfaceViewAPI18) {
-					GLSurfaceViewAPI18 view = new GLSurfaceViewAPI18(activity, resolutionStrategy);
+					GLSurfaceViewAPI18 view = new GLSurfaceViewAPI18(application.getContext(), resolutionStrategy);
 					if (configChooser != null)
 						view.setEGLConfigChooser(configChooser);
 					else
 						view.setEGLConfigChooser(config.r, config.g, config.b, config.a, config.depth, config.stencil);
 					view.setRenderer(this);
 					return view;
-				} else {
-					GLSurfaceViewCupcake view = new GLSurfaceViewCupcake(activity, resolutionStrategy);
+				}
+				else {
+					GLSurfaceViewCupcake view = new GLSurfaceViewCupcake(application.getContext(), resolutionStrategy);
 					if (configChooser != null)
 						view.setEGLConfigChooser(configChooser);
 					else
@@ -214,7 +218,7 @@ public final class AndroidGraphics implements Graphics, Renderer {
 
 	private void updatePpi () {
 		DisplayMetrics metrics = new DisplayMetrics();
-		app.getWindowManager().getDefaultDisplay().getMetrics(metrics);
+		((WindowManager) app.getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getMetrics(metrics);
 
 		ppiX = metrics.xdpi;
 		ppiY = metrics.ydpi;
@@ -332,13 +336,13 @@ public final class AndroidGraphics implements Graphics, Renderer {
 		updatePpi();
 		gl.glViewport(0, 0, this.width, this.height);
 		if (created == false) {
-			app.listener.create();
+			app.getApplicationListener().create();
 			created = true;
 			synchronized (this) {
 				running = true;
 			}
 		}
-		app.listener.resize(width, height);
+		app.getApplicationListener().resize(width, height);
 	}
 
 	@Override
@@ -358,7 +362,7 @@ public final class AndroidGraphics implements Graphics, Renderer {
 		Gdx.app.log("AndroidGraphics", ShaderProgram.getManagedStatus());
 		Gdx.app.log("AndroidGraphics", FrameBuffer.getManagedStatus());
 
-		Display display = app.getWindowManager().getDefaultDisplay();
+		Display display = ((WindowManager)app.getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
 		this.width = display.getWidth();
 		this.height = display.getHeight();
 		mean = new WindowedMean(5);
@@ -423,7 +427,7 @@ public final class AndroidGraphics implements Graphics, Renderer {
 					synch.wait(4000);
 					if (pause) {
 						Gdx.app.error("AndroidGraphics", "waiting for pause synchronization took too "
-							+ "long; assuming deadlock and killing");
+						                                 + "long; assuming deadlock and killing");
 						android.os.Process.killProcess(android.os.Process.myPid());
 					}
 				} catch (InterruptedException ignored) {
@@ -453,11 +457,7 @@ public final class AndroidGraphics implements Graphics, Renderer {
 		long time = System.nanoTime();
 		deltaTime = (time - lastFrameTime) / 1000000000.0f;
 		lastFrameTime = time;
-		if(!resume) {
-			mean.addValue(deltaTime);
-		} else {
-			deltaTime = 0;
-		}
+		mean.addValue(deltaTime);
 
 		boolean lrunning = false;
 		boolean lpause = false;
@@ -486,54 +486,55 @@ public final class AndroidGraphics implements Graphics, Renderer {
 		}
 
 		if (lresume) {
-			Array<LifecycleListener> listeners = ((AndroidApplication)app).lifecycleListeners;
-			synchronized (listeners) {
-				for (LifecycleListener listener : listeners) {
+			((AndroidAudio)((AndroidApplicationBase)app).getAudio()).resume();
+			Array<LifecycleListener> listeners = ((AndroidApplicationBase)app).getLifecycleListeners();
+			synchronized(listeners) {
+				for(LifecycleListener listener: listeners) {
 					listener.resume();
 				}
 			}
-			app.listener.resume();
+			app.getApplicationListener().resume();
 			Gdx.app.log("AndroidGraphics", "resumed");
 		}
 
 		if (lrunning) {
-			synchronized (app.runnables) {
-				app.executedRunnables.clear();
-				app.executedRunnables.addAll(app.runnables);
-				app.runnables.clear();
+			synchronized (app.getRunnables()) {
+				app.getExecutedRunnables().clear();
+				app.getExecutedRunnables().addAll(app.getRunnables());
+				app.getRunnables().clear();
 			}
 
-			for (int i = 0; i < app.executedRunnables.size; i++) {
+			for (int i = 0; i < app.getExecutedRunnables().size; i++) {
 				try {
-					app.executedRunnables.get(i).run();
+					app.getExecutedRunnables().get(i).run();
 				} catch (Throwable t) {
 					t.printStackTrace();
 				}
 			}
-			app.input.processEvents();
-			app.listener.render();
+			((AndroidInput)app.getInput()).processEvents();
+			app.getApplicationListener().render();
 		}
 
 		if (lpause) {
-			Array<LifecycleListener> listeners = ((AndroidApplication)app).lifecycleListeners;
-			synchronized (listeners) {
-				for (LifecycleListener listener : listeners) {
+			Array<LifecycleListener> listeners = ((AndroidApplicationBase)app).getLifecycleListeners();
+			synchronized(listeners) {
+				for(LifecycleListener listener: listeners) {
 					listener.pause();
 				}
 			}
-			app.listener.pause();
-			((AndroidApplication)app).audio.pause();
+			app.getApplicationListener().pause();
+			((AndroidAudio)((AndroidApplicationBase)app).getAudio()).pause();
 			Gdx.app.log("AndroidGraphics", "paused");
 		}
 
 		if (ldestroy) {
 			Array<LifecycleListener> listeners = ((AndroidApplication)app).lifecycleListeners;
-			synchronized (listeners) {
-				for (LifecycleListener listener : listeners) {
+			synchronized(listeners) {
+				for(LifecycleListener listener: listeners) {
 					listener.dispose();
 				}
 			}
-			app.listener.dispose();
+			app.getApplicationListener().dispose();
 			((AndroidApplication)app).audio.dispose();
 			((AndroidApplication)app).audio = null;
 			Gdx.app.log("AndroidGraphics", "destroyed");
@@ -651,7 +652,7 @@ public final class AndroidGraphics implements Graphics, Renderer {
 	@Override
 	public DisplayMode getDesktopDisplayMode () {
 		DisplayMetrics metrics = new DisplayMetrics();
-		app.getWindowManager().getDefaultDisplay().getMetrics(metrics);
+		((WindowManager)app.getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getMetrics(metrics);
 		return new AndroidDisplayMode(metrics.widthPixels, metrics.heightPixels, 0, 0);
 	}
 
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphicsDaydream.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphicsDaydream.java
index 64a8999..f3ec3f4 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphicsDaydream.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphicsDaydream.java
@@ -146,7 +146,7 @@ public final class AndroidGraphicsDaydream implements Graphics, Renderer {
 		} else {
 			config.useGL20 = false;
 			configChooser = getEglConfigChooser();
-			int sdkVersion = android.os.Build.VERSION.SDK_INT;
+			int sdkVersion = Integer.parseInt(android.os.Build.VERSION.SDK);
 
 			if (sdkVersion >= 11) {
 				GLSurfaceView view = new GLSurfaceView(dream) {
@@ -421,11 +421,7 @@ public final class AndroidGraphicsDaydream implements Graphics, Renderer {
 		long time = System.nanoTime();
 		deltaTime = (time - lastFrameTime) / 1000000000.0f;
 		lastFrameTime = time;
-		if(!resume) {
-			mean.addValue(deltaTime);
-		} else {
-			deltaTime = 0;
-		}
+		mean.addValue(deltaTime);
 
 		boolean lrunning = false;
 		boolean lpause = false;
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphicsLiveWallpaper.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphicsLiveWallpaper.java
index a283df1..f956537 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphicsLiveWallpaper.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphicsLiveWallpaper.java
@@ -106,7 +106,7 @@ public final class AndroidGraphicsLiveWallpaper implements Graphics, Renderer {
 	// will be replaced by subclass of original GLSurfaceView, i'm working on it:)
 	// <- ok it is in use now
 	private void setPreserveContext (Object view) {
-		int sdkVersion = android.os.Build.VERSION.SDK_INT;
+		int sdkVersion = Integer.parseInt(android.os.Build.VERSION.SDK);
 		if (sdkVersion >= 11 && view instanceof GLSurfaceView) {
 			try {
 				Method method = null;
@@ -166,7 +166,7 @@ public final class AndroidGraphicsLiveWallpaper implements Graphics, Renderer {
 		} else {
 			config.useGL20 = false;
 			configChooser = getEglConfigChooser();
-			int sdkVersion = android.os.Build.VERSION.SDK_INT;
+			int sdkVersion = Integer.parseInt(android.os.Build.VERSION.SDK);
 
 			if (sdkVersion >= 11) {
 				GLSurfaceView view = new GLSurfaceView(context) {
@@ -573,11 +573,7 @@ public final class AndroidGraphicsLiveWallpaper implements Graphics, Renderer {
 		lastFrameTime = time;
 		
 		// jw: after pause deltaTime can have somewhat huge value and it destabilize mean, so I propose to just cut it of
-		if(!resume) {
-			mean.addValue(deltaTime);
-		} else {
-			deltaTime = 0;
-		}
+		mean.addValue(resume ? 0.0f : deltaTime);
 		//mean.addValue(deltaTime);
 
 		boolean lrunning = false;
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidInput.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidInput.java
index 05bd536..010c51e 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidInput.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidInput.java
@@ -153,7 +153,7 @@ public class AndroidInput implements Input, OnKeyListener, OnTouchListener {
 		this.app = activity;
 		this.context = context;
 		this.sleepTime = config.touchSleepTime;
-		int sdkVersion = android.os.Build.VERSION.SDK_INT;
+		int sdkVersion = Integer.parseInt(android.os.Build.VERSION.SDK);
 		if (sdkVersion >= 5)
 			touchHandler = new AndroidMultiTouchHandler();
 		else
@@ -717,9 +717,9 @@ public class AndroidInput implements Input, OnKeyListener, OnTouchListener {
 		int orientation = 0;
 
 		if (context instanceof Activity) {
-			orientation = ((Activity)context).getWindowManager().getDefaultDisplay().getRotation();
+			orientation = ((Activity)context).getWindowManager().getDefaultDisplay().getOrientation();
 		} else {
-			orientation = ((WindowManager)context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getRotation();
+			orientation = ((WindowManager)context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getOrientation();
 		}
 
 		switch (orientation) {
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidLiveWallpaper.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidLiveWallpaper.java
index f3e7726..96cd280 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidLiveWallpaper.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidLiveWallpaper.java
@@ -287,7 +287,7 @@ public class AndroidLiveWallpaper implements Application {
 
 	@Override
 	public int getVersion () {
-		return android.os.Build.VERSION.SDK_INT;
+		return Integer.parseInt(android.os.Build.VERSION.SDK);
 	}
 
 	@Override
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidLiveWallpaperService.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidLiveWallpaperService.java
index 27570c2..160240c 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidLiveWallpaperService.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidLiveWallpaperService.java
@@ -359,9 +359,6 @@ public abstract class AndroidLiveWallpaperService extends WallpaperService {
 			
 			notifyPreviewState();
 			notifyOffsetsChanged();
-			if (!Gdx.graphics.isContinuousRendering()) {
-				Gdx.graphics.requestRendering();
-			}
 		}
 		
 		
@@ -482,9 +479,6 @@ public abstract class AndroidLiveWallpaperService extends WallpaperService {
 
 				notifyPreviewState();
 				notifyOffsetsChanged();
-				if (!Gdx.graphics.isContinuousRendering()) {
-					Gdx.graphics.requestRendering();
-				}
 			}
 		}
 		
@@ -605,9 +599,6 @@ public abstract class AndroidLiveWallpaperService extends WallpaperService {
 			
 			// can fail if linkedApp == null, so we repeat it in Engine.onResume
 			notifyOffsetsChanged();
-			if (!Gdx.graphics.isContinuousRendering()) {
-				Gdx.graphics.requestRendering();
-			}
 			
 			super.onOffsetsChanged(xOffset, yOffset, xOffsetStep, yOffsetStep, xPixelOffset, yPixelOffset);
 		}
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidMultiTouchHandler.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidMultiTouchHandler.java
index bcfca62..8ad2754 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidMultiTouchHandler.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidMultiTouchHandler.java
@@ -29,7 +29,7 @@ import com.badlogic.gdx.backends.android.AndroidInput.TouchEvent;
 public class AndroidMultiTouchHandler implements AndroidTouchHandler {
 	public void onTouch (MotionEvent event, AndroidInput input) {
 		final int action = event.getAction() & MotionEvent.ACTION_MASK;
-		int pointerIndex = (event.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK) >> MotionEvent.ACTION_POINTER_INDEX_SHIFT;
+		int pointerIndex = (event.getAction() & MotionEvent.ACTION_POINTER_ID_MASK) >> MotionEvent.ACTION_POINTER_ID_SHIFT;
 		int pointerId = event.getPointerId(pointerIndex);
 
 		int x = 0, y = 0;
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidNet.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidNet.java
index 4bc214a..4b1b76a 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidNet.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidNet.java
@@ -20,7 +20,6 @@ import android.net.Uri;
 
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.Net;
-import com.badlogic.gdx.Net.HttpRequest;
 import com.badlogic.gdx.net.NetJavaImpl;
 import com.badlogic.gdx.net.ServerSocket;
 import com.badlogic.gdx.net.ServerSocketHints;
@@ -35,10 +34,10 @@ public class AndroidNet implements Net {
 
 	// IMPORTANT: The Gdx.net classes are a currently duplicated for JGLFW/LWJGL + Android!
 	// If you make changes here, make changes in the other backend as well.
-	final AndroidApplication app;
+	final AndroidApplicationBase app;
 	NetJavaImpl netJavaImpl;
 
-	public AndroidNet (AndroidApplication activity) {
+	public AndroidNet (AndroidApplicationBase activity) {
 		app = activity;
 		netJavaImpl = new NetJavaImpl();
 	}
@@ -47,11 +46,6 @@ public class AndroidNet implements Net {
 	public void sendHttpRequest (HttpRequest httpRequest, final HttpResponseListener httpResponseListener) {
 		netJavaImpl.sendHttpRequest(httpRequest, httpResponseListener);
 	}
-	
-	@Override
-	public void cancelHttpRequest (HttpRequest httpRequest) {
-		netJavaImpl.cancelHttpRequest(httpRequest);
-	}
 
 	@Override
 	public ServerSocket newServerSocket (Protocol protocol, int port, ServerSocketHints hints) {
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidOnscreenKeyboard.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidOnscreenKeyboard.java
index 22cd7d4..f1e5f90 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidOnscreenKeyboard.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidOnscreenKeyboard.java
@@ -65,7 +65,7 @@ class AndroidOnscreenKeyboard implements OnKeyListener, OnTouchListener {
 	Dialog createDialog () {
 		textView = createView(context);
 		textView.setOnKeyListener(this);
-		FrameLayout.LayoutParams textBoxLayoutParams = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT,
+		FrameLayout.LayoutParams textBoxLayoutParams = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.FILL_PARENT,
 			FrameLayout.LayoutParams.WRAP_CONTENT, Gravity.BOTTOM);
 		textView.setLayoutParams(textBoxLayoutParams);
 		textView.setFocusable(true);
@@ -73,7 +73,7 @@ class AndroidOnscreenKeyboard implements OnKeyListener, OnTouchListener {
 		textView.setImeOptions(textView.getImeOptions() | EditorInfo.IME_FLAG_NO_EXTRACT_UI);
 
 		final FrameLayout layout = new FrameLayout(context);
-		ViewGroup.LayoutParams layoutParams = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 0);
+		ViewGroup.LayoutParams layoutParams = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT, 0);
 		layout.setLayoutParams(layoutParams);
 		layout.addView(textView);
 		layout.setOnTouchListener(this);
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidVisibilityListener.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidVisibilityListener.java
index 8aef750..8c17d18 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidVisibilityListener.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidVisibilityListener.java
@@ -18,7 +18,7 @@ package com.badlogic.gdx.backends.android;
 import android.view.View;
 
 /**
- * Allows immersive mode support while maintaining compatibility with Android versions before API Level 19 (4.4)
+ * Allows immersive mode support while maintaining Android 1.5 compatibility
  * @author Unkn0wn0ne
  */
 public class AndroidVisibilityListener {
@@ -41,4 +41,4 @@ public class AndroidVisibilityListener {
 			application.log("AndroidApplication", "Can't create OnSystemUiVisibilityChangeListener", t);
 		}
 	}
-}
+}
\ No newline at end of file
diff --git a/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/HeadlessNet.java b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/HeadlessNet.java
index 258241f..4013370 100644
--- a/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/HeadlessNet.java
+++ b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/HeadlessNet.java
@@ -16,10 +16,6 @@
 
 package com.badlogic.gdx.backends.headless;
 
-import java.awt.Desktop;
-import java.awt.GraphicsEnvironment;
-import java.awt.Desktop.Action;
-
 import com.badlogic.gdx.Net;
 import com.badlogic.gdx.net.NetJavaImpl;
 import com.badlogic.gdx.net.ServerSocket;
@@ -54,19 +50,9 @@ public class HeadlessNet implements Net {
 
 	@Override
 	public void openURI (String URI) {
-		try {
-			if (!GraphicsEnvironment.isHeadless() && Desktop.isDesktopSupported()) {
-				if (Desktop.getDesktop().isSupported(Action.BROWSE)) {
-					Desktop.getDesktop().browse(java.net.URI.create(URI));
-					return;
-				}
-			}
-		} catch (Throwable t) {
-			t.printStackTrace();
-			return;
-		}
 		// don't throw the exception, don't want to kill the app, just let the headless app know it can't open URIs
 		Exception e = new GdxRuntimeException("ERROR: cannot open URI on a headless application");
 		e.printStackTrace();
 	}
-}
+
+}
\ No newline at end of file
diff --git a/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/audio/MockAudio.java b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/audio/MockAudio.java
index 0d4d788..f4915d6 100644
--- a/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/audio/MockAudio.java
+++ b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/audio/MockAudio.java
@@ -1,17 +1,17 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ******************************************************************************/
 
 package com.badlogic.gdx.backends.headless.mock.audio;
@@ -23,9 +23,6 @@ import com.badlogic.gdx.audio.Music;
 import com.badlogic.gdx.audio.Sound;
 import com.badlogic.gdx.files.FileHandle;
 
-/** The headless backend does its best to mock elements. This is intended to make code-sharing between
- * server and client as simple as possible.
- */
 public class MockAudio implements Audio {
 
 	@Override
diff --git a/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/audio/MockAudioDevice.java b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/audio/MockAudioDevice.java
index c3367c3..82149bf 100644
--- a/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/audio/MockAudioDevice.java
+++ b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/audio/MockAudioDevice.java
@@ -1,26 +1,23 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ******************************************************************************/
 
 package com.badlogic.gdx.backends.headless.mock.audio;
 
 import com.badlogic.gdx.audio.AudioDevice;
 
-/** The headless backend does its best to mock elements. This is intended to make code-sharing between
- * server and client as simple as possible.
- */
 public class MockAudioDevice implements AudioDevice {
 
 	@Override
diff --git a/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/audio/MockAudioRecorder.java b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/audio/MockAudioRecorder.java
index a450a4b..84ed630 100644
--- a/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/audio/MockAudioRecorder.java
+++ b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/audio/MockAudioRecorder.java
@@ -1,26 +1,23 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ******************************************************************************/
 
 package com.badlogic.gdx.backends.headless.mock.audio;
 
 import com.badlogic.gdx.audio.AudioRecorder;
 
-/** The headless backend does its best to mock elements. This is intended to make code-sharing between
- * server and client as simple as possible.
- */
 public class MockAudioRecorder implements AudioRecorder {
 
 	@Override
diff --git a/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/audio/MockMusic.java b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/audio/MockMusic.java
index 27d2ee8..8ed9110 100644
--- a/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/audio/MockMusic.java
+++ b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/audio/MockMusic.java
@@ -1,26 +1,23 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ******************************************************************************/
 
 package com.badlogic.gdx.backends.headless.mock.audio;
 
 import com.badlogic.gdx.audio.Music;
 
-/** The headless backend does its best to mock elements. This is intended to make code-sharing between
- * server and client as simple as possible.
- */
 public class MockMusic implements Music {
 	@Override
 	public void play() {
diff --git a/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/audio/MockSound.java b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/audio/MockSound.java
index 7685a1a..04676e5 100644
--- a/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/audio/MockSound.java
+++ b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/audio/MockSound.java
@@ -1,26 +1,23 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ******************************************************************************/
 
 package com.badlogic.gdx.backends.headless.mock.audio;
 
 import com.badlogic.gdx.audio.Sound;
 
-/** The headless backend does its best to mock elements. This is intended to make code-sharing between
- * server and client as simple as possible.
- */
 public class MockSound implements Sound {
 	@Override
 	public long play() {
diff --git a/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/graphics/MockGraphics.java b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/graphics/MockGraphics.java
index 825a016..510555d 100644
--- a/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/graphics/MockGraphics.java
+++ b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/graphics/MockGraphics.java
@@ -1,17 +1,17 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ******************************************************************************/
 
 package com.badlogic.gdx.backends.headless.mock.graphics;
@@ -22,9 +22,6 @@ import com.badlogic.gdx.graphics.GL11;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.GLCommon;
 
-/** The headless backend does its best to mock elements. This is intended to make code-sharing between
- * server and client as simple as possible.
- */
 public class MockGraphics implements Graphics {
 	float deltaTime = 0;
 	long frameStart = 0;
diff --git a/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/input/MockInput.java b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/input/MockInput.java
index 56b1853..f81c1ba 100644
--- a/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/input/MockInput.java
+++ b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/input/MockInput.java
@@ -1,17 +1,17 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ******************************************************************************/
 
 package com.badlogic.gdx.backends.headless.mock.input;
@@ -21,9 +21,6 @@ import com.badlogic.gdx.InputAdapter;
 import com.badlogic.gdx.InputProcessor;
 import com.badlogic.gdx.graphics.Pixmap;
 
-/** The headless backend does its best to mock elements. This is intended to make code-sharing between
- * server and client as simple as possible.
- */
 public class MockInput implements Input {
 
 	@Override
diff --git a/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/test.py b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/test.py
new file mode 100644
index 0000000..8ec60fb
--- /dev/null
+++ b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/test.py
@@ -0,0 +1,3 @@
+with open("Headless.java") as fin:
+    data = fin.read()
+    print data[-1] == "\n"
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwNet.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwNet.java
index 023fbb6..dcc79e6 100644
--- a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwNet.java
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwNet.java
@@ -17,7 +17,6 @@
 package com.badlogic.gdx.backends.jglfw;
 
 import com.badlogic.gdx.Net;
-import com.badlogic.gdx.Net.HttpRequest;
 import com.badlogic.gdx.net.NetJavaImpl;
 import com.badlogic.gdx.net.ServerSocket;
 import com.badlogic.gdx.net.ServerSocketHints;
@@ -38,11 +37,6 @@ public class JglfwNet implements Net {
 	public void sendHttpRequest (HttpRequest httpRequest, HttpResponseListener httpResponseListener) {
 		netJavaImpl.sendHttpRequest(httpRequest, httpResponseListener);
 	}
-	
-	@Override
-	public void cancelHttpRequest (HttpRequest httpRequest) {
-		netJavaImpl.cancelHttpRequest(httpRequest);
-	}
 
 	public ServerSocket newServerSocket (Protocol protocol, int port, ServerSocketHints hints) {
 		return new NetJavaServerSocketImpl(protocol, port, hints);
diff --git a/backends/gdx-backend-lwjgl/libs/gdx-backend-lwjgl-natives.jar b/backends/gdx-backend-lwjgl/libs/gdx-backend-lwjgl-natives.jar
index fdb7ffa..4f03e04 100644
Binary files a/backends/gdx-backend-lwjgl/libs/gdx-backend-lwjgl-natives.jar and b/backends/gdx-backend-lwjgl/libs/gdx-backend-lwjgl-natives.jar differ
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglNet.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglNet.java
index 859c097..1a6aae1 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglNet.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglNet.java
@@ -40,11 +40,6 @@ public class LwjglNet implements Net {
 	public void sendHttpRequest (HttpRequest httpRequest, HttpResponseListener httpResponseListener) {
 		netJavaImpl.sendHttpRequest(httpRequest, httpResponseListener);
 	}
-	
-	@Override
-	public void cancelHttpRequest (HttpRequest httpRequest) {
-		netJavaImpl.cancelHttpRequest(httpRequest);
-	}
 
 	@Override
 	public ServerSocket newServerSocket (Protocol protocol, int port, ServerSocketHints hints) {
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplication.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplication.java
index 931bc7c..784b37b 100644
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplication.java
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplication.java
@@ -167,8 +167,7 @@ public class IOSApplication implements Application {
 	 * @return Or real display dimension. */
 	CGSize getBounds (UIViewController viewController) {
 		// or screen size (always portrait)
-//		CGSize bounds = UIScreen.getMainScreen().getBounds().size();
-		CGSize bounds = UIScreen.getMainScreen().getApplicationFrame().size();
+		CGSize bounds = UIScreen.getMainScreen().getBounds().size();
 
 		// determine orientation and resulting width + height
 		UIInterfaceOrientation orientation = viewController != null 
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSNet.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSNet.java
index 554c01d..7ed2729 100644
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSNet.java
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSNet.java
@@ -40,11 +40,6 @@ public class IOSNet implements Net {
 	@Override
 	public void sendHttpRequest (HttpRequest httpRequest, HttpResponseListener httpResponseListener) {
 		netJavaImpl.sendHttpRequest(httpRequest, httpResponseListener);
-	}
-	
-	@Override
-	public void cancelHttpRequest (HttpRequest httpRequest) {
-		netJavaImpl.cancelHttpRequest(httpRequest);
 	}
 
 	@Override
diff --git a/backends/gdx-backends-gwt/libs/gwt-dev.jar b/backends/gdx-backends-gwt/libs/gwt-dev.jar
index 2979d5c..3ccb192 100644
Binary files a/backends/gdx-backends-gwt/libs/gwt-dev.jar and b/backends/gdx-backends-gwt/libs/gwt-dev.jar differ
diff --git a/backends/gdx-backends-gwt/libs/gwt-user.jar b/backends/gdx-backends-gwt/libs/gwt-user.jar
index c8f2511..458e978 100644
Binary files a/backends/gdx-backends-gwt/libs/gwt-user.jar and b/backends/gdx-backends-gwt/libs/gwt-user.jar differ
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGL20.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGL20.java
index 7668688..60eeffc 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGL20.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGL20.java
@@ -87,7 +87,7 @@ public class GwtGL20 implements GL20 {
 			shortBuffer = TypedArrays.createInt16Array(buffer.remaining());
 		}
 	}
-
+	
 	private void ensureCapacity (IntBuffer buffer) {
 		if (buffer.remaining() > intBuffer.length()) {
 			intBuffer = TypedArrays.createInt32Array(buffer.remaining());
@@ -117,7 +117,7 @@ public class GwtGL20 implements GL20 {
 			return shortBuffer.subarray(0, buffer.remaining());
 		}
 	}
-
+	
 	public Int32Array copy (IntBuffer buffer) {
 		if (GWT.isProdMode()) {
 			return ((Int32Array)((HasArrayBufferView)buffer).getTypedArray()).subarray(buffer.position(), buffer.remaining());
@@ -348,33 +348,18 @@ public class GwtGL20 implements GL20 {
 
 	@Override
 	public void glGetIntegerv (int pname, IntBuffer params) {
-		if (pname == GL20.GL_ACTIVE_TEXTURE || pname == GL20.GL_ALPHA_BITS || pname == GL20.GL_BLEND_DST_ALPHA
-			|| pname == GL20.GL_BLEND_DST_RGB || pname == GL20.GL_BLEND_EQUATION_ALPHA || pname == GL20.GL_BLEND_EQUATION_RGB
-			|| pname == GL20.GL_BLEND_SRC_ALPHA || pname == GL20.GL_BLEND_SRC_RGB || pname == GL20.GL_BLUE_BITS
-			|| pname == GL20.GL_CULL_FACE_MODE || pname == GL20.GL_DEPTH_BITS || pname == GL20.GL_DEPTH_FUNC
-			|| pname == GL20.GL_FRONT_FACE || pname == GL20.GL_GENERATE_MIPMAP_HINT || pname == GL20.GL_GREEN_BITS
-			|| pname == GL20.GL_IMPLEMENTATION_COLOR_READ_FORMAT || pname == GL20.GL_IMPLEMENTATION_COLOR_READ_TYPE
-			|| pname == GL20.GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS || pname == GL20.GL_MAX_CUBE_MAP_TEXTURE_SIZE
-			|| pname == GL20.GL_MAX_FRAGMENT_UNIFORM_VECTORS || pname == GL20.GL_MAX_RENDERBUFFER_SIZE
-			|| pname == GL20.GL_MAX_TEXTURE_IMAGE_UNITS || pname == GL20.GL_MAX_TEXTURE_SIZE || pname == GL20.GL_MAX_VARYING_VECTORS
-			|| pname == GL20.GL_MAX_VERTEX_ATTRIBS || pname == GL20.GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS
-			|| pname == GL20.GL_MAX_VERTEX_UNIFORM_VECTORS || pname == GL20.GL_NUM_COMPRESSED_TEXTURE_FORMATS
-			|| pname == GL20.GL_PACK_ALIGNMENT || pname == GL20.GL_RED_BITS || pname == GL20.GL_SAMPLE_BUFFERS
-			|| pname == GL20.GL_SAMPLES || pname == GL20.GL_STENCIL_BACK_FAIL || pname == GL20.GL_STENCIL_BACK_FUNC
-			|| pname == GL20.GL_STENCIL_BACK_PASS_DEPTH_FAIL || pname == GL20.GL_STENCIL_BACK_PASS_DEPTH_PASS
-			|| pname == GL20.GL_STENCIL_BACK_REF || pname == GL20.GL_STENCIL_BACK_VALUE_MASK
-			|| pname == GL20.GL_STENCIL_BACK_WRITEMASK || pname == GL20.GL_STENCIL_BITS || pname == GL20.GL_STENCIL_CLEAR_VALUE
-			|| pname == GL20.GL_STENCIL_FAIL || pname == GL20.GL_STENCIL_FUNC || pname == GL20.GL_STENCIL_PASS_DEPTH_FAIL
-			|| pname == GL20.GL_STENCIL_PASS_DEPTH_PASS || pname == GL20.GL_STENCIL_REF || pname == GL20.GL_STENCIL_VALUE_MASK
-			|| pname == GL20.GL_STENCIL_WRITEMASK || pname == GL20.GL_SUBPIXEL_BITS || pname == GL20.GL_UNPACK_ALIGNMENT)
-			params.put(0, gl.getParameteri(pname));
-		else
-			throw new GdxRuntimeException("glGetFloat not supported by GWT WebGL backend");
+		// FIXME this is a hack, a nasty nasty hack
+		if(pname == GL10.GL_MAX_TEXTURE_UNITS || pname == GL20.GL_MAX_TEXTURE_IMAGE_UNITS) {
+			params.put(16);
+			return;
+		}
+		throw new GdxRuntimeException("glGetInteger not supported by GWT WebGL backend");
 	}
 
 	@Override
 	public String glGetString (int name) {
-		return gl.getParameterString(name);
+		// FIXME
+		throw new GdxRuntimeException("not implemented");
 	}
 
 	@Override
@@ -406,14 +391,14 @@ public class GwtGL20 implements GL20 {
 		if (!(pixels instanceof ByteBuffer)) {
 			throw new GdxRuntimeException("Inputed pixels buffer needs to be of type ByteBuffer for glReadPixels(...).");
 		}
-
+		
 		// create new ArrayBufferView (4 bytes per pixel)
 		int size = 4 * width * height;
 		Uint8Array buffer = Uint8ArrayNative.create(size);
-
+		
 		// read bytes to ArrayBufferView
 		gl.readPixels(x, y, width, height, format, type, buffer);
-
+	
 		// copy ArrayBufferView to our pixels array
 		ByteBuffer pixelsByte = (ByteBuffer)pixels;
 		for (int i = 0; i < size; i++) {
@@ -705,11 +690,7 @@ public class GwtGL20 implements GL20 {
 
 	@Override
 	public void glGetFloatv (int pname, FloatBuffer params) {
-		if (pname == GL20.GL_DEPTH_CLEAR_VALUE || pname == GL20.GL_LINE_WIDTH || pname == GL20.GL_POLYGON_OFFSET_FACTOR
-			|| pname == GL20.GL_POLYGON_OFFSET_UNITS || pname == GL20.GL_SAMPLE_COVERAGE_VALUE)
-			params.put(0, gl.getParameterf(pname));
-		else
-			throw new GdxRuntimeException("glGetFloat not supported by GWT WebGL backend");
+		throw new GdxRuntimeException("glGetFloat not supported by GWT WebGL backend");
 	}
 
 	@Override
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtNet.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtNet.java
index 6b182f5..b431e6e 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtNet.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtNet.java
@@ -13,7 +13,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  ******************************************************************************/
-
 package com.badlogic.gdx.backends.gwt;
 
 import java.io.InputStream;
@@ -22,6 +21,8 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.Net;
@@ -32,7 +33,6 @@ import com.badlogic.gdx.net.ServerSocketHints;
 import com.badlogic.gdx.net.Socket;
 import com.badlogic.gdx.net.SocketHints;
 import com.badlogic.gdx.utils.GdxRuntimeException;
-import com.badlogic.gdx.utils.ObjectMap;
 import com.google.gwt.core.client.EntryPoint;
 import com.google.gwt.http.client.Header;
 import com.google.gwt.http.client.Request;
@@ -45,9 +45,6 @@ import com.google.gwt.user.client.Window;
 
 public class GwtNet implements Net {
 
-	private ObjectMap<HttpRequest, Request> requests;
-	private ObjectMap<HttpRequest, HttpResponseListener> listeners;
-
 	private final class HttpClientResponse implements HttpResponse {
 
 		private Response response;
@@ -91,20 +88,15 @@ public class GwtNet implements Net {
 				}
 				headerValues.add(responseHeaders[i].getValue());
 			}
-			return headers;
+			return headers;			
 		}
-
+		
 		@Override
 		public String getHeader (String name) {
 			return response.getHeader(name);
 		}
 	}
 
-	public GwtNet () {
-		requests = new ObjectMap<HttpRequest, Request>();
-		listeners = new ObjectMap<HttpRequest, HttpResponseListener>();
-	}
-
 	@Override
 	public void sendHttpRequest (HttpRequest httpRequest, final HttpResponseListener httpResultListener) {
 		if (httpRequest.getUrl() == null) {
@@ -127,34 +119,18 @@ public class GwtNet implements Net {
 		builder.setTimeoutMillis(httpRequest.getTimeOut());
 
 		try {
-			Request request = builder.sendRequest(is_get ? null : value, new RequestCallback() {
+			builder.sendRequest(is_get ? null : value, new RequestCallback() {
 
 				@Override
 				public void onResponseReceived (Request request, Response response) {
-					HttpRequest httpRequest = requests.findKey(requests, true);
-
-					if (httpRequest != null) {
-						httpResultListener.handleHttpResponse(new HttpClientResponse(response));
-						requests.remove(httpRequest);
-						listeners.remove(httpRequest);
-					}
+					httpResultListener.handleHttpResponse(new HttpClientResponse(response));
 				}
 
 				@Override
 				public void onError (Request request, Throwable exception) {
-					HttpRequest httpRequest = requests.findKey(requests, true);
-
-					if (httpRequest != null) {
-						httpResultListener.failed(exception);
-						requests.remove(httpRequest);
-						listeners.remove(httpRequest);
-					}
+					httpResultListener.failed(exception);
 				}
 			});
-
-			requests.put(httpRequest, request);
-			listeners.put(httpRequest, httpResultListener);
-
 		} catch (RequestException e) {
 			httpResultListener.failed(e);
 		}
@@ -162,19 +138,6 @@ public class GwtNet implements Net {
 	}
 
 	@Override
-	public void cancelHttpRequest (HttpRequest httpRequest) {
-		HttpResponseListener httpResponseListener = listeners.get(httpRequest);
-		Request request = requests.get(httpRequest);
-
-		if (httpResponseListener != null && request != null) {
-			request.cancel();
-			httpResponseListener.cancelled();
-			requests.remove(httpRequest);
-			listeners.remove(httpRequest);
-		}
-	}
-
-	@Override
 	public ServerSocket newServerSocket (Protocol protocol, int port, ServerSocketHints hints) {
 		throw new UnsupportedOperationException("Not implemented");
 	}
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/ArrayReflection.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/ArrayReflection.java
index 0aae89f..b0e1d81 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/ArrayReflection.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/ArrayReflection.java
@@ -12,33 +12,33 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.utils.reflect;
-
-import com.badlogic.gwtref.client.ReflectionCache;
-
-/** Utilities for Array reflection.
- * @author nexsoftware */
-public final class ArrayReflection {
-
-	/** Creates a new array with the specified component type and length. */
-	static public Object newInstance (Class c, int size) {
-		return ReflectionCache.newArray(c, size);
-	}
-
-	/** Returns the length of the supplied array. */
-	static public int getLength (Object array) {
-		return ReflectionCache.getType(array.getClass()).getArrayLength(array);
-	}
-
-	/** Returns the value of the indexed component in the supplied array. */
-	static public Object get (Object array, int index) {
-		return ReflectionCache.getType(array.getClass()).getArrayElement(array, index);
-	}
-
-	/** Sets the value of the indexed component in the supplied array to the supplied value. */
-	static public void set (Object array, int index, Object value) {
-		ReflectionCache.getType(array.getClass()).setArrayElement(array, index, value);
-	}
-}
+ ******************************************************************************/
+
+package com.badlogic.gdx.utils.reflect;
+
+import com.badlogic.gwtref.client.ReflectionCache;
+
+/** Utilities for Array reflection.
+ * @author nexsoftware */
+public final class ArrayReflection {
+
+	/** Creates a new array with the specified component type and length. */
+	static public Object newInstance (Class c, int size) {
+		return ReflectionCache.instance.newArray(c, size);
+	}
+
+	/** Returns the length of the supplied array. */
+	static public int getLength (Object array) {
+		return ReflectionCache.instance.getArrayLength(ReflectionCache.getType(array.getClass()), array);
+	}
+
+	/** Returns the value of the indexed component in the supplied array. */
+	static public Object get (Object array, int index) {
+		return ReflectionCache.instance.getArrayElement(ReflectionCache.getType(array.getClass()), array, index);
+	}
+
+	/** Sets the value of the indexed component in the supplied array to the supplied value. */
+	static public void set (Object array, int index, Object value) {
+		ReflectionCache.instance.setArrayElement(ReflectionCache.getType(array.getClass()), array, index, value);
+	}
+}
\ No newline at end of file
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/ClassReflection.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/ClassReflection.java
index 6db7964..6eb6532 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/ClassReflection.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/ClassReflection.java
@@ -39,7 +39,7 @@ public final class ClassReflection {
 
 	/** Determines if the supplied Object is assignment-compatible with the object represented by supplied Class. */
 	static public boolean isInstance (Class c, Object obj) {
-		return obj != null && isAssignableFrom(c, obj.getClass());
+		return isAssignableFrom(c, obj.getClass());
 	}
 
 	/** Determines if the class or interface represented by first Class parameter is either the same as, or is a superclass or
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/Method.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/Method.java
index 8e708bb..ce23cb6 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/Method.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/Method.java
@@ -46,7 +46,7 @@ public final class Method {
 		Parameter[] parameters = method.getParameters();
 		Class[] parameterTypes = new Class[parameters.length];
 		for (int i = 0, j = parameters.length; i < j; i++) {
-			parameterTypes[i] = parameters[i].getClazz();
+			parameterTypes[i] = parameters[i].getType();
 		}
 		return parameterTypes;
 	}
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/CachedTypeLookup.java b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/CachedTypeLookup.java
deleted file mode 100644
index 05affa5..0000000
--- a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/CachedTypeLookup.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gwtref.client;
-
-/** A cache for a Type lookups.
- * @author hneuer */
-class CachedTypeLookup {
-	final Class clazz;
-	private Type type;
-
-	CachedTypeLookup (Class clazz) {
-		this.clazz = clazz;
-	}
-
-	Type getType () {
-		if (type == null && clazz != null) type = ReflectionCache.getType(clazz);
-		return type;
-	}
-
-	@Override
-	public String toString () {
-		return String.valueOf(clazz);
-	}
-}
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Field.java b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Field.java
index 4d76fe6..ba2fa4f 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Field.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Field.java
@@ -16,12 +16,13 @@
 
 package com.badlogic.gwtref.client;
 
+import java.security.AccessControlException;
 import java.util.Arrays;
 
 public class Field {
 	final String name;
-	final CachedTypeLookup enclosingType;
-	final CachedTypeLookup type;
+	final Class enclosingType;
+	final Class type;
 	final boolean isFinal;
 	final boolean isDefaultAccess;
 	final boolean isPrivate;
@@ -32,14 +33,14 @@ public class Field {
 	final boolean isVolatile;
 	final int getter;
 	final int setter;
-	final CachedTypeLookup[] elementTypes;
+	final Class[] elementTypes;
 
 	Field (String name, Class enclosingType, Class type, boolean isFinal, boolean isDefaultAccess, boolean isPrivate,
 		boolean isProtected, boolean isPublic, boolean isStatic, boolean isTransient, boolean isVolatile, int getter, int setter,
 		Class[] elementTypes) {
 		this.name = name;
-		this.enclosingType = new CachedTypeLookup(enclosingType);
-		this.type = new CachedTypeLookup(type);
+		this.enclosingType = enclosingType;
+		this.type = type;
 		this.isFinal = isFinal;
 		this.isDefaultAccess = isDefaultAccess;
 		this.isPrivate = isPrivate;
@@ -50,27 +51,19 @@ public class Field {
 		this.isVolatile = isVolatile;
 		this.getter = getter;
 		this.setter = setter;
-
-		CachedTypeLookup[] tmp = null;
-		if (elementTypes != null) {
-			tmp = new CachedTypeLookup[elementTypes.length];
-			for (int i = 0; i < tmp.length; i++) {
-				tmp[i] = new CachedTypeLookup(elementTypes[i]);
-			}
-		}
-		this.elementTypes = tmp;
+		this.elementTypes = elementTypes;
 	}
 
 	public Object get (Object obj) throws IllegalAccessException {
-		return ReflectionCache.getFieldValue(this, obj);
+		return ReflectionCache.instance.get(this, obj);
 	}
 
 	public void set (Object obj, Object value) throws IllegalAccessException {
-		ReflectionCache.setFieldValue(this, obj, value);
+		ReflectionCache.instance.set(this, obj, value);
 	}
 
 	public Type getElementType (int index) {
-		if (elementTypes != null && index >= 0 && index < elementTypes.length) return elementTypes[index].getType();
+		if (elementTypes != null && index < elementTypes.length) return ReflectionCache.getType(elementTypes[index]);
 		return null;
 	}
 
@@ -79,11 +72,11 @@ public class Field {
 	}
 
 	public Type getEnclosingType () {
-		return enclosingType.getType();
+		return ReflectionCache.getType(enclosingType);
 	}
 
 	public Type getType () {
-		return type.getType();
+		return ReflectionCache.getType(type);
 	}
 
 	public boolean isSynthetic () {
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/IReflectionCache.java b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/IReflectionCache.java
index 27cc56e..521094c 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/IReflectionCache.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/IReflectionCache.java
@@ -24,7 +24,7 @@ public interface IReflectionCache {
 
 	public Type forName (String name);
 
-	public Object newArray (Type componentType, int size);
+	public Object newArray (Class componentType, int size);
 
 	public int getArrayLength (Type type, Object obj);
 
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Method.java b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Method.java
index 74f0462..769cf46 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Method.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Method.java
@@ -23,8 +23,8 @@ import java.util.Arrays;
 public class Method {
 	private static final Parameter[] EMPTY_PARAMS = new Parameter[0];
 	final String name;
-	final CachedTypeLookup enclosingType;
-	final CachedTypeLookup returnType;
+	final Class enclosingType;
+	final Class returnType;
 	final boolean isAbstract;
 	final boolean isFinal;
 	final boolean isStatic;
@@ -43,9 +43,9 @@ public class Method {
 		boolean isFinal, boolean isStatic, boolean isDefaultAccess, boolean isPrivate, boolean isProtected, boolean isPublic,
 		boolean isNative, boolean isVarArgs, boolean isMethod, boolean isConstructor, int methodId) {
 		this.name = name;
-		this.enclosingType = new CachedTypeLookup(enclosingType);
+		this.enclosingType = enclosingType;
 		this.parameters = parameters != null ? parameters : EMPTY_PARAMS;
-		this.returnType = new CachedTypeLookup(returnType);
+		this.returnType = returnType;
 		this.isAbstract = isAbstract;
 		this.isFinal = isFinal;
 		this.isStatic = isStatic;
@@ -62,12 +62,12 @@ public class Method {
 
 	/** @return the {@link Class} of the enclosing type. */
 	public Class getEnclosingType () {
-		return enclosingType.getClass();
+		return enclosingType;
 	}
 
 	/** @return the {@link Class} of the return type or null. */
 	public Class getReturnType () {
-		return returnType.getClass();
+		return returnType;
 	}
 
 	/** @return the list of parameters, can be a zero size array. */
@@ -132,7 +132,7 @@ public class Method {
 	public Object invoke (Object obj, Object... params) {
 		if (parameters.length != (params != null ? params.length : 0)) throw new IllegalArgumentException("Parameter mismatch");
 
-		return ReflectionCache.invoke(this, obj, params);
+		return ReflectionCache.instance.invoke(this, obj, params);
 	}
 
 	boolean match (String name, Class... types) {
@@ -143,8 +143,8 @@ public class Method {
 		if (types == null) return parameters.length == 0;
 		if (types.length != parameters.length) return false;
 		for (int i = 0; i < types.length; i++) {
-			Type t1 = parameters[i].getType();
-			Type t2 = ReflectionCache.getType(types[i]);
+			Type t1 = ReflectionCache.instance.forName(parameters[i].getType().getName());
+			Type t2 = ReflectionCache.instance.forName(types[i].getName());
 			if (t1 != t2 && !t1.isAssignableFrom(t2)) return false;
 		}
 		return true;
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Parameter.java b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Parameter.java
index 289454e..6e26a4a 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Parameter.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Parameter.java
@@ -18,12 +18,12 @@ package com.badlogic.gwtref.client;
 
 public class Parameter {
 	final String name;
-	final CachedTypeLookup type;
+	final Class type;
 	final String jnsi;
 
 	Parameter (String name, Class type, String jnsi) {
 		this.name = name;
-		this.type = new CachedTypeLookup(type);
+		this.type = type;
 		this.jnsi = jnsi;
 	}
 
@@ -31,12 +31,8 @@ public class Parameter {
 		return name;
 	}
 
-	public Type getType () {
-		return type.getType();
-	}
-
-	public Class getClazz () {
-		return type.clazz;
+	public Class getType () {
+		return type;
 	}
 
 	public String getJnsi () {
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/ReflectionCache.java b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/ReflectionCache.java
index d6920f5..6ba4f78 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/ReflectionCache.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/ReflectionCache.java
@@ -21,7 +21,7 @@ import java.util.Collection;
 import com.google.gwt.core.client.GWT;
 
 public class ReflectionCache {
-	private static IReflectionCache instance = GWT.create(IReflectionCache.class);
+	public static IReflectionCache instance = GWT.create(IReflectionCache.class);
 
 	public static Type forName (String name) throws ClassNotFoundException {
 		Type type = instance.forName(convert(name));
@@ -79,34 +79,10 @@ public class ReflectionCache {
 	}
 
 	public static Object newArray (Class componentType, int size) {
-		return instance.newArray(getType(componentType), size);
+		return instance.newArray(componentType, size);
 	}
 
 	public static Collection<Type> getKnownTypes () {
 		return instance.getKnownTypes();
 	}
-
-	public static Object getFieldValue (Field field, Object obj) throws IllegalAccessException {
-		return instance.get(field, obj);
-	}
-
-	public static void setFieldValue (Field field, Object obj, Object value) throws IllegalAccessException {
-		instance.set(field, obj, value);
-	}
-
-	public static Object invoke (Method method, Object obj, Object[] params) {
-		return instance.invoke(method, obj, params);
-	}
-
-	public static int getArrayLength (Type type, Object obj) {
-		return instance.getArrayLength(type, obj);
-	}
-
-	public static Object getArrayElement (Type type, Object obj, int i) {
-		return instance.getArrayElement(type, obj, i);
-	}
-
-	public static void setArrayElement (Type type, Object obj, int i, Object value) {
-		instance.setArrayElement(type, obj, i, value);
-	}
 }
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Test.java b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Test.java
new file mode 100644
index 0000000..4c8a0c1
--- /dev/null
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Test.java
@@ -0,0 +1,99 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gwtref.client;
+
+import com.google.gwt.core.client.EntryPoint;
+
+public class Test implements EntryPoint {
+	public static enum Enu {
+		Winter, Summer, Bleh;
+	}
+
+	public static class A {
+		String text;
+		float numberf;
+		int numberi;
+
+		public String getText () {
+			return text;
+		}
+
+		public void setText (String text) {
+			this.text = text;
+		}
+
+		public float getNumberf () {
+			return numberf;
+		}
+
+		public void setNumberf (float numberf) {
+			this.numberf = numberf;
+		}
+
+		public int getNumberi () {
+			return numberi;
+		}
+
+		public void setNumberi (int numberi) {
+			this.numberi = numberi;
+		}
+
+		public float getSum (float a, float b) {
+			return a + b;
+		}
+	}
+
+	public static class B extends A {
+		String text = "This is a string";
+
+		public void testWithPackagePrivate (C c, int a) {
+		}
+
+		public void testWidthPrivate (A c) {
+		}
+
+		public void testVoid () {
+		}
+
+		public native void test (A c) /*-{
+												//			this.@com.badlogic.gwtref.client.Test.B::testWidthPrivate(LC;)(c);
+												}-*/;
+	}
+
+	public static class C {
+	}
+
+	@Override
+	public void onModuleLoad () {
+		try {
+			Type ta = ReflectionCache.getType(A.class);
+			Type tb = ReflectionCache.getType(B.class);
+			B b = (B)tb.newInstance();
+			for (Field f : tb.getFields())
+				System.out.println(f);
+			for (Method m : tb.getMethods())
+				System.out.println(m);
+
+			tb.getDeclaredFields()[0].set(b, "Field of B");
+			ta.getDeclaredFields()[0].set(b, "Field of A");
+			System.out.println(ta.getMethod("getText").invoke(b));
+			System.out.println(ta.getMethod("getSum", float.class, float.class).invoke(b, 1, 2));
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+	}
+}
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Type.java b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Type.java
index de2269e..2c43473 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Type.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Type.java
@@ -18,7 +18,6 @@ package com.badlogic.gwtref.client;
 
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
 
@@ -29,13 +28,12 @@ public class Type {
 	private static final Field[] EMPTY_FIELDS = new Field[0];
 	private static final Method[] EMPTY_METHODS = new Method[0];
 	private static final Constructor[] EMPTY_CONSTRUCTORS = new Constructor[0];
-	private static final Set<Class> EMPTY_ASSIGNABLES = Collections.unmodifiableSet(new HashSet<Class>());
 
-	final String name;
-	final int id;
-	final Class clazz;
-	final CachedTypeLookup superClass;
-	final Set<Class> assignables;
+	String name;
+	int id;
+	Class clazz;
+	Class superClass;
+	Set<Class> assignables = new HashSet<Class>();
 	boolean isAbstract;
 	boolean isInterface;
 	boolean isPrimitive;
@@ -51,17 +49,6 @@ public class Type {
 	Class componentType;
 	Object[] enumConstants;
 
-	private Field[] allFields;
-	private Method[] allMethods;
-
-	public Type (String name, int id, Class clazz, Class superClass, Set<Class> assignables) {
-		this.name = name;
-		this.id = id;
-		this.clazz = clazz;
-		this.superClass = new CachedTypeLookup(superClass);
-		this.assignables = assignables != null ? assignables : EMPTY_ASSIGNABLES;
-	}
-
 	/** @return a new instance of this type created via the default constructor which must be public. */
 	public Object newInstance () throws NoSuchMethodException {
 		return getConstructor().newInstance();
@@ -79,40 +66,50 @@ public class Type {
 
 	/** @return the super class of this type or null */
 	public Type getSuperclass () {
-		return superClass.getType();
+		try {
+			return superClass == null ? null : ReflectionCache.forName(superClass.getName());
+		} catch (ClassNotFoundException e) {
+			return null;
+		}
 	}
 
 	/** @param otherType the other type
 	 * @return whether this type is assignable to the other type. */
 	public boolean isAssignableFrom (Type otherType) {
-		return clazz == otherType.clazz || (clazz == Object.class && !otherType.isPrimitive)
-			|| otherType.assignables.contains(clazz);
+		return otherType.assignables.contains(getClassOfType());
 	}
 
 	/** @param name the name of the field
 	 * @return the public field of this type or one of its super interfaces with the given name or null. See
 	 *         {@link Class#getField(String)}. */
 	public Field getField (String name) {
-		for (Field f : getFields()) {
-			if (f.name.equals(name)) return f;
+		Type t = this;
+		while (t != null) {
+			Field[] declFields = t.getDeclaredFields();
+			if (declFields != null) {
+				for (Field f : declFields) {
+					if (f.isPublic && f.name.equals(name)) return f;
+				}
+			}
+			t = t.getSuperclass();
 		}
 		return null;
 	}
 
 	/** @return an array containing all the public fields of this class and its super classes. See {@link Class#getFields()}. */
 	public Field[] getFields () {
-		if (allFields == null) {
-			ArrayList<Field> allFieldsList = new ArrayList<Field>();
-			Type t = this;
-			while (t != null) {
-				for (Field f : t.fields) {
-					if (f.isPublic) allFieldsList.add(f);
+		ArrayList<Field> allFields = new ArrayList<Field>();
+		Type t = this;
+		while (t != null) {
+			Field[] declFields = t.getDeclaredFields();
+			if (declFields != null) {
+				for (Field f : declFields) {
+					if (f.isPublic) allFields.add(f);
 				}
-				t = t.getSuperclass();
 			}
-			allFields = allFieldsList.toArray(new Field[allFieldsList.size()]);
+			t = t.getSuperclass();
 		}
-		return allFields;
+		return allFields.toArray(new Field[allFields.size()]);
 	}
 
 	/** @return an array containing all the fields of this class, including private and protected fields. See
@@ -126,26 +123,33 @@ public class Type {
 	 * @return the public method that matches the name and parameter types of this type or one of its super interfaces.
 	 * @throws NoSuchMethodException */
 	public Method getMethod (String name, Class... parameterTypes) throws NoSuchMethodException {
-		for (Method m : getMethods()) {
-			if (m.match(name, parameterTypes)) return m;
+		Type t = this;
+		while (t != null) {
+			Method[] declMethods = t.getDeclaredMethods();
+			if (declMethods != null) {
+				for (Method m : declMethods) {
+					if (m.isPublic() && m.match(name, parameterTypes)) return m;
+				}
+			}
+			t = t.getSuperclass();
 		}
 		throw new NoSuchMethodException();
 	}
 
 	/** s * @return an array containing all public methods of this class and its super classes. See {@link Class#getMethods()}. */
 	public Method[] getMethods () {
-		if (allMethods == null) {
-			ArrayList<Method> allMethodsList = new ArrayList<Method>();
-			Type t = this;
-			while (t != null) {
-				for (Method m : t.methods) {
-					if (m.isPublic()) allMethodsList.add(m);
+		ArrayList<Method> allMethods = new ArrayList<Method>();
+		Type t = this;
+		while (t != null) {
+			Method[] declMethods = t.getDeclaredMethods();
+			if (declMethods != null) {
+				for (Method m : declMethods) {
+					if (m.isPublic()) allMethods.add(m);
 				}
-				t = t.getSuperclass();
 			}
-			allMethods = allMethodsList.toArray(new Method[allMethodsList.size()]);
+			t = t.getSuperclass();
 		}
-		return allMethods;
+		return allMethods.toArray(new Method[allMethods.size()]);
 	}
 
 	/** @return an array containing all methods of this class, including abstract, private and protected methods. See
@@ -163,8 +167,10 @@ public class Type {
 	}
 
 	public Constructor getConstructor (Class... parameterTypes) throws NoSuchMethodException {
-		for (Constructor c : constructors) {
-			if (c.isPublic() && c.match(parameterTypes)) return c;
+		if (constructors != null) {
+			for (Constructor c : constructors) {
+				if (c.isPublic() && c.match(parameterTypes)) return c;
+			}
 		}
 		throw new NoSuchMethodException();
 	}
@@ -205,14 +211,14 @@ public class Type {
 	/** @param obj an array object of this type.
 	 * @return the length of the given array object. */
 	public int getArrayLength (Object obj) {
-		return ReflectionCache.getArrayLength(this, obj);
+		return ReflectionCache.instance.getArrayLength(this, obj);
 	}
 
 	/** @param obj an array object of this type.
 	 * @param i the index of the element to retrieve.
 	 * @return the element at position i in the array. */
 	public Object getArrayElement (Object obj, int i) {
-		return ReflectionCache.getArrayElement(this, obj, i);
+		return ReflectionCache.instance.getArrayElement(this, obj, i);
 	}
 
 	/** Sets the element i in the array object to value.
@@ -220,7 +226,7 @@ public class Type {
 	 * @param i the index of the element to set.
 	 * @param value the element value. */
 	public void setArrayElement (Object obj, int i, Object value) {
-		ReflectionCache.setArrayElement(this, obj, i, value);
+		ReflectionCache.instance.setArrayElement(this, obj, i, value);
 	}
 
 	/** @return the enumeration constants if this type is an enumeration or null. */
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/gen/ReflectionCacheSourceCreator.java b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/gen/ReflectionCacheSourceCreator.java
index 508edf7..5e2b86e 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/gen/ReflectionCacheSourceCreator.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/gen/ReflectionCacheSourceCreator.java
@@ -57,12 +57,10 @@ public class ReflectionCacheSourceCreator {
 	final String simpleName;
 	final String packageName;
 	SourceWriter sw;
-	final StringBuffer source = new StringBuffer();
-	final List<JType> types = new ArrayList<JType>();
-	final List<SetterGetterStub> setterGetterStubs = new ArrayList<SetterGetterStub>();
-	final List<MethodStub> methodStubs = new ArrayList<MethodStub>();
-	final Map<String, String> parameterName2ParameterInstantiation = new HashMap();
-	final Map<String, Integer> typeNames2typeIds = new HashMap();
+	StringBuffer source = new StringBuffer();
+	List<JType> types = new ArrayList<JType>();
+	List<SetterGetterStub> setterGetterStubs = new ArrayList<SetterGetterStub>();
+	List<MethodStub> methodStubs = new ArrayList<MethodStub>();
 	int nextId = 0;
 
 	class SetterGetterStub {
@@ -88,7 +86,6 @@ public class ReflectionCacheSourceCreator {
 		boolean isNative;
 		boolean isConstructor;
 		boolean isMethod;
-		boolean isPublic;
 		String name;
 		boolean unused;
 	}
@@ -189,16 +186,12 @@ public class ReflectionCacheSourceCreator {
 			String typeGen = createTypeGenerator(t);
 			p("private void c" + (id++) + "() {");
 			p(typeGen);
-			p("}");
+			p("}\n");
 		}
 
-		// generate reusable parameter objects
-		parameterInitialization();
-
 		// generate constructor that calls all the type generators
 		// that populate the map.
 		p("public " + simpleName + "() {");
-		p("initializeParameters();");
 		for (int i = 0; i < id; i++) {
 			p("c" + i + "();");
 		}
@@ -397,7 +390,7 @@ public class ReflectionCacheSourceCreator {
 				pbn(paramType + " p" + i + (i < stub.parameterTypes.size() - 1 ? "," : ""));
 				i++;
 			}
-			pbn(") /*-{");
+			pb(") /*-{");
 
 			if (!isVoid) pbn("return ");
 			if (stub.isStatic)
@@ -408,9 +401,9 @@ public class ReflectionCacheSourceCreator {
 			for (i = 0; i < stub.parameterTypes.size(); i++) {
 				pbn("p" + i + (i < stub.parameterTypes.size() - 1 ? ", " : ""));
 			}
-			pbn(");");
-			if (isVoid) pbn("return null;");
-			pbn("}-*/;");
+			pb(");");
+			if (isVoid) pb("return null;");
+			pb("}-*/;");
 		} else {
 			pbn("private static " + stub.returnType + " m" + stub.methodId + "(");
 			int i = 0;
@@ -418,19 +411,15 @@ public class ReflectionCacheSourceCreator {
 				pbn(paramType + " p" + i + (i < stub.parameterTypes.size() - 1 ? "," : ""));
 				i++;
 			}
-			pbn(") {");
+			pb(") {");
+
 			pbn("return new " + stub.returnType + "(");
 			for (i = 0; i < stub.parameterTypes.size(); i++) {
 				pbn("p" + i + (i < stub.parameterTypes.size() - 1 ? ", " : ""));
 			}
-			pbn(")");
-			if (!stub.isPublic) {
-				// Access non-public constructors through an anonymous class
-				pbn("{}");
-			}
-			pbn(";");
+			pb(");");
 
-			pbn("}");
+			pb("}");
 		}
 
 		return buffer.toString();
@@ -497,39 +486,30 @@ public class ReflectionCacheSourceCreator {
 		return true;
 	}
 
+	private Map<String, Integer> typeNames2typeIds = new HashMap();
+
 	private String createTypeGenerator (JType t) {
 		buffer.setLength(0);
 		String varName = "t";
 		if (t instanceof JPrimitiveType) varName = "p";
 		int id = nextId();
 		typeNames2typeIds.put(t.getErasedType().getQualifiedSourceName(), id);
-		JClassType c = t.isClass();
-
-		String name = t.getErasedType().getQualifiedSourceName();
-		String superClass = null;
-		if (c != null && (isVisible(c.getSuperclass())))
-			superClass = c.getSuperclass().getErasedType().getQualifiedSourceName() + ".class";
-		String assignables = null;
-
-		if (c != null && c.getFlattenedSupertypeHierarchy() != null) {
-			assignables = "new HashSet<Class>(Arrays.asList(";
-			boolean used = false;
-			for (JType i : c.getFlattenedSupertypeHierarchy()) {
-				if (!isVisible(i) || i.equals(t) || "java.lang.Object".equals(i.getErasedType().getQualifiedSourceName())) continue;
-				if (used) assignables += ", ";
-				assignables += i.getErasedType().getQualifiedSourceName() + ".class";
-				used = true;
+		pb("Type " + varName + " = new Type();");
+		pb(varName + ".name = \"" + t.getErasedType().getQualifiedSourceName() + "\";");
+		pb(varName + ".id = " + id + ";");
+		pb(varName + ".clazz = " + t.getErasedType().getQualifiedSourceName() + ".class;");
+		if (t instanceof JClassType) {
+			JClassType c = (JClassType)t;
+			if (isVisible(c.getSuperclass()))
+				pb(varName + ".superClass = " + c.getSuperclass().getErasedType().getQualifiedSourceName() + ".class;");
+			if (c.getFlattenedSupertypeHierarchy() != null) {
+				pb("Set<Class> " + varName + "Assignables = new HashSet<Class>();");
+				for (JType i : c.getFlattenedSupertypeHierarchy()) {
+					if (!isVisible(i)) continue;
+					pb(varName + "Assignables.add(" + i.getErasedType().getQualifiedSourceName() + ".class);");
+				}
+				pb(varName + ".assignables = " + varName + "Assignables;");
 			}
-			if (used)
-				assignables += "))";
-			else
-				assignables = null;
-		}
-
-		pb("Type " + varName + " = new Type(\"" + name + "\", " + id + ", " + name + ".class, " + superClass + ", " + assignables
-			+ ");");
-
-		if (c != null) {
 			if (c.isInterface() != null) pb(varName + ".isInterface = true;");
 			if (c.isEnum() != null) pb(varName + ".isEnum = true;");
 			if (c.isArray() != null) pb(varName + ".isArray = true;");
@@ -537,7 +517,7 @@ public class ReflectionCacheSourceCreator {
 			pb(varName + ".isStatic = " + c.isStatic() + ";");
 			pb(varName + ".isAbstract = " + c.isAbstract() + ";");
 
-			if (c.getFields() != null && c.getFields().length > 0) {
+			if (c.getFields() != null) {
 				pb(varName + ".fields = new Field[] {");
 				for (JField f : c.getFields()) {
 					String enclosingType = getType(c);
@@ -546,7 +526,7 @@ public class ReflectionCacheSourceCreator {
 					int getter = nextId();
 					String elementType = getElementTypes(f);
 
-					pb("    new Field(\"" + f.getName() + "\", " + enclosingType + ", " + fieldType + ", " + f.isFinal() + ", "
+					pb("new Field(\"" + f.getName() + "\", " + enclosingType + ", " + fieldType + ", " + f.isFinal() + ", "
 						+ f.isDefaultAccess() + ", " + f.isPrivate() + ", " + f.isProtected() + ", " + f.isPublic() + ", "
 						+ f.isStatic() + ", " + f.isTransient() + ", " + f.isVolatile() + ", " + getter + ", " + setter + ", "
 						+ elementType + "), ");
@@ -566,9 +546,9 @@ public class ReflectionCacheSourceCreator {
 				pb("};");
 			}
 
-			createTypeInvokables(c, varName, "Method", c.getMethods());
-			if (c.isPublic() && !c.isAbstract() && (c.getEnclosingType() == null || c.isStatic())) {
-				createTypeInvokables(c, varName, "Constructor", c.getConstructors());
+			printMethods(c, varName, "Method", c.getMethods());
+			if (!c.isAbstract() && (c.getEnclosingType() == null || c.isStatic())) {
+				printMethods(c, varName, "Constructor", c.getConstructors());
 			} else {
 				logger.log(Type.INFO, c.getName() + " can't be instantiated. Constructors not generated");
 			}
@@ -590,37 +570,15 @@ public class ReflectionCacheSourceCreator {
 			pb(varName + ".isPrimitive = true;");
 		}
 
-		pbn("types.put(\"" + t.getErasedType().getQualifiedSourceName() + "\", " + varName + ");");
+		pb("types.put(\"" + t.getErasedType().getQualifiedSourceName() + "\", " + varName + ");");
 		return buffer.toString();
 	}
 
-	private void parameterInitialization () {
-		p("private static final Parameter[] EMPTY_PARAMETERS = new Parameter[0];");
-		for (Map.Entry<String, String> e : parameterName2ParameterInstantiation.entrySet()) {
-			p("private Parameter " + e.getKey() + ";");
-		}
-
-		p("private void initializeParameters() {");
-		int i = 0;
-		for (Map.Entry<String, String> e : parameterName2ParameterInstantiation.entrySet()) {
-			p("    " + e.getKey() + " = " + e.getValue() + ";");
-			i++;
-			if (i % 1000 == 0) {
-				String nextCall = "initializeParameters" + (i / 1000);
-				p("    " + nextCall + "();");
-				p("}");
-				p("private void " + nextCall + "() {");
-			}
-		}
-		p("}");
-	}
-
-	private void createTypeInvokables (JClassType c, String varName, String methodType, JAbstractMethod[] methodTypes) {
-		if (methodTypes != null && methodTypes.length > 0) {
+	private void printMethods (JClassType c, String varName, String methodType, JAbstractMethod[] methodTypes) {
+		if (methodTypes != null) {
 			pb(varName + "." + methodType.toLowerCase() + "s = new " + methodType + "[] {");
 			for (JAbstractMethod m : methodTypes) {
 				MethodStub stub = new MethodStub();
-				stub.isPublic = m.isPublic();
 				stub.enclosingType = getType(c);
 				if (m.isMethod() != null) {
 					stub.isMethod = true;
@@ -630,43 +588,28 @@ public class ReflectionCacheSourceCreator {
 					stub.isNative = m.isMethod().isAbstract();
 					stub.isFinal = m.isMethod().isFinal();
 				} else {
-					if (m.isPrivate() || m.isDefaultAccess()) {
-						logger.log(Type.INFO, "Skipping non-visible constructor for class " + c.getName());
-						continue;
-					}
-					if (m.getEnclosingType().isFinal() && !m.isPublic()) {
-						logger.log(Type.INFO, "Skipping non-public constructor for final class" + c.getName());
-						continue;
-					}
 					stub.isConstructor = true;
 					stub.returnType = stub.enclosingType;
 				}
-
 				stub.jnsi = "";
 				stub.methodId = nextId();
 				stub.name = m.getName();
 				methodStubs.add(stub);
 
-				pbn("    new " + methodType + "(\"" + m.getName() + "\", ");
-				pbn(stub.enclosingType + ", ");
-				pbn(stub.returnType + ", ");
+				pb("new " + methodType + "(\"" + m.getName() + "\", ");
+				pb(stub.enclosingType + ", ");
+				pb(stub.returnType + ", ");
 
-				if (m.getParameters() != null && m.getParameters().length > 0) {
-					pbn("new Parameter[] {");
+				pb("new Parameter[] {");
+				if (m.getParameters() != null) {
 					for (JParameter p : m.getParameters()) {
 						stub.parameterTypes.add(getType(p.getType()));
 						stub.jnsi += p.getType().getErasedType().getJNISignature();
-						String paramName = (p.getName() + "__" + p.getType().getErasedType().getJNISignature()).replaceAll(
-							"[/;\\[\\]]", "_");
-						String paramInstantiation = "new Parameter(\"" + p.getName() + "\", " + getType(p.getType()) + ", \""
-							+ p.getType().getJNISignature() + "\")";
-						parameterName2ParameterInstantiation.put(paramName, paramInstantiation);
-						pbn(paramName + ", ");
+						pb("new Parameter(\"" + p.getName() + "\", " + getType(p.getType()) + ", \"" + p.getType().getJNISignature()
+							+ "\"), ");
 					}
-					pbn("}, ");
-				} else {
-					pbn("EMPTY_PARAMETERS,");
 				}
+				pb("}, ");
 
 				pb(stub.isAbstract + ", " + stub.isFinal + ", " + stub.isStatic + ", " + m.isDefaultAccess() + ", " + m.isPrivate()
 					+ ", " + m.isProtected() + ", " + m.isPublic() + ", " + stub.isNative + ", " + m.isVarArgs() + ", "
@@ -854,7 +797,8 @@ public class ReflectionCacheSourceCreator {
 	}
 
 	private void newArrayC () {
-		p("public Object newArray (Type t, int size) {");
+		p("public Object newArray (Class componentType, int size) {");
+		p("    Type t = forName(componentType.getName().replace('$', '.'));");
 		p("    if (t != null) {");
 		SwitchedCodeBlock pc = new SwitchedCodeBlock("t.id");
 		for (JType type : types) {
@@ -869,7 +813,7 @@ public class ReflectionCacheSourceCreator {
 		}
 		pc.print();
 		p("    }");
-		p("    throw new RuntimeException(\"Couldn't create array\");");
+		p("    throw new RuntimeException(\"Couldn't create array with element type \" + componentType.getName());");
 		p("}");
 	}
 
diff --git a/backends/gdx-openal/libs/lwjgl-debug.jar b/backends/gdx-openal/libs/lwjgl-debug.jar
index 04c4a1c..4625bff 100644
Binary files a/backends/gdx-openal/libs/lwjgl-debug.jar and b/backends/gdx-openal/libs/lwjgl-debug.jar differ
diff --git a/backends/gdx-openal/libs/lwjgl.jar b/backends/gdx-openal/libs/lwjgl.jar
index 8c663d6..4cb7cda 100644
Binary files a/backends/gdx-openal/libs/lwjgl.jar and b/backends/gdx-openal/libs/lwjgl.jar differ
diff --git a/backends/gdx-openal/src/com/badlogic/gdx/backends/openal/OpenALAudio.java b/backends/gdx-openal/src/com/badlogic/gdx/backends/openal/OpenALAudio.java
index 01f77a8..6a526a5 100644
--- a/backends/gdx-openal/src/com/badlogic/gdx/backends/openal/OpenALAudio.java
+++ b/backends/gdx-openal/src/com/badlogic/gdx/backends/openal/OpenALAudio.java
@@ -47,8 +47,6 @@ public class OpenALAudio implements Audio {
 	private long nextSoundId = 0;
 	private ObjectMap<String, Class<? extends OpenALSound>> extensionToSoundClass = new ObjectMap();
 	private ObjectMap<String, Class<? extends OpenALMusic>> extensionToMusicClass = new ObjectMap();
-	private OpenALSound[] recentSounds;
-	private int mostRecetSound = -1;
 
 	Array<OpenALMusic> music = new Array(false, 1, OpenALMusic.class);
 	boolean noDevice = false;
@@ -93,8 +91,6 @@ public class OpenALAudio implements Audio {
 		alListener(AL_VELOCITY, velocity);
 		FloatBuffer position = (FloatBuffer)BufferUtils.createFloatBuffer(3).put(new float[] {0.0f, 0.0f, 0.0f}).flip();
 		alListener(AL_POSITION, position);
-		
-		recentSounds = new OpenALSound[simultaneousSources];
 	}
 
 	public void registerSound (String extension, Class<? extends OpenALSound> soundClass) {
@@ -342,26 +338,4 @@ public class OpenALAudio implements Audio {
 		};
 		return new JavaSoundAudioRecorder(samplingRate, isMono);
 	}
-
-	/** Retains a list of the most recently played sounds and stops the sound played least recently if necessary for a new sound to
-	 * play */
-	protected void retain (OpenALSound sound, boolean stop) {
-		// Move the pointer ahead and wrap
-		mostRecetSound++;
-		mostRecetSound %= recentSounds.length;
-
-		if (stop) {
-			// Stop the least recent sound (the one we are about to bump off the buffer)
-			if (recentSounds[mostRecetSound] != null) recentSounds[mostRecetSound].stop();
-		}
-
-		recentSounds[mostRecetSound] = sound;
-	}
-
-	/** Removes the disposed sound from the least recently played list */
-	public void forget (OpenALSound sound) {
-		for (int i = 0; i < recentSounds.length; i++) {
-			if (recentSounds[i] == sound) recentSounds[i] = null;
-		}
-	}
 }
diff --git a/backends/gdx-openal/src/com/badlogic/gdx/backends/openal/OpenALSound.java b/backends/gdx-openal/src/com/badlogic/gdx/backends/openal/OpenALSound.java
index 366f969..4c83f6e 100644
--- a/backends/gdx-openal/src/com/badlogic/gdx/backends/openal/OpenALSound.java
+++ b/backends/gdx-openal/src/com/badlogic/gdx/backends/openal/OpenALSound.java
@@ -56,12 +56,6 @@ public class OpenALSound implements Sound {
 	public long play (float volume) {
 		if (audio.noDevice) return 0;
 		int sourceID = audio.obtainSource(false);
-		if (sourceID == -1) {
-			// Attempt to recover by stopping the least recently played sound
-			audio.retain(this, true);
-			sourceID = audio.obtainSource(false);
-		} else audio.retain(this, false);
-		// In case it still didn't work
 		if (sourceID == -1) return -1;
 		long soundId = audio.getSoundId(sourceID);
 		alSourcei(sourceID, AL_BUFFER, bufferID);
@@ -99,7 +93,6 @@ public class OpenALSound implements Sound {
 		audio.freeBuffer(bufferID);
 		alDeleteBuffers(bufferID);
 		bufferID = -1;
-		audio.forget(this);
 	}
 
 	@Override
@@ -107,13 +100,13 @@ public class OpenALSound implements Sound {
 		if (audio.noDevice) return;
 		audio.stopSound(soundId);
 	}
-
+	
 	@Override
 	public void pause () {
 		if (audio.noDevice) return;
 		audio.pauseSourcesWithBuffer(bufferID);
 	}
-
+	
 	@Override
 	public void pause (long soundId) {
 		if (audio.noDevice) return;
@@ -125,13 +118,13 @@ public class OpenALSound implements Sound {
 		if (audio.noDevice) return;
 		audio.resumeSourcesWithBuffer(bufferID);
 	}
-
+	
 	@Override
 	public void resume (long soundId) {
 		if (audio.noDevice) return;
 		audio.resumeSound(soundId);
 	}
-
+	
 	@Override
 	public void setPitch (long soundId, float pitch) {
 		if (audio.noDevice) return;
diff --git a/demos/superjumper/superjumper/src/com/badlogicgames/superjumper/MainMenuScreen.java b/demos/superjumper/superjumper/src/com/badlogicgames/superjumper/MainMenuScreen.java
index d5ec5c5..65b82cd 100644
--- a/demos/superjumper/superjumper/src/com/badlogicgames/superjumper/MainMenuScreen.java
+++ b/demos/superjumper/superjumper/src/com/badlogicgames/superjumper/MainMenuScreen.java
@@ -25,7 +25,6 @@ import com.badlogic.gdx.graphics.OrthographicCamera;
 import com.badlogic.gdx.graphics.g2d.SpriteBatch;
 import com.badlogic.gdx.math.Rectangle;
 import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.utils.TimeUtils;
 
 public class MainMenuScreen implements Screen {
 	Game game;
@@ -81,8 +80,7 @@ public class MainMenuScreen implements Screen {
 		}
 	}
 
-	long last = TimeUtils.nanoTime();
-
+	long last = System.nanoTime();
 	public void draw () {
 		GLCommon gl = Gdx.gl;
 		gl.glClearColor(1, 0, 0, 1);
@@ -101,15 +99,15 @@ public class MainMenuScreen implements Screen {
 		batcher.draw(Assets.mainMenu, 10, 200 - 110 / 2, 300, 110);
 		batcher.draw(Settings.soundEnabled ? Assets.soundOn : Assets.soundOff, 0, 0, 64, 64);
 		batcher.end();
-
-		if (TimeUtils.nanoTime() - last > 2000000000) {
-			Gdx.app.log("SuperJumper",
-				"version: " + Gdx.app.getVersion() + ", memory: " + Gdx.app.getJavaHeap() + ", " + Gdx.app.getNativeHeap()
-					+ ", native orientation:" + Gdx.input.getNativeOrientation() + ", orientation: " + Gdx.input.getRotation()
-					+ ", accel: " + (int)Gdx.input.getAccelerometerX() + ", " + (int)Gdx.input.getAccelerometerY() + ", "
-					+ (int)Gdx.input.getAccelerometerZ() + ", apr: " + (int)Gdx.input.getAzimuth() + ", " + (int)Gdx.input.getPitch()
-					+ ", " + (int)Gdx.input.getRoll());
-			last = TimeUtils.nanoTime();
+		
+		if(System.nanoTime() - last > 2000000000) {
+			Gdx.app.log("SuperJumper", "version: " + Gdx.app.getVersion() + 
+												", memory: " + Gdx.app.getJavaHeap() + ", " + Gdx.app.getNativeHeap() + 
+												", native orientation:" + Gdx.input.getNativeOrientation() + 
+												", orientation: " + Gdx.input.getRotation() + 
+												", accel: " + (int)Gdx.input.getAccelerometerX() + ", " + (int)Gdx.input.getAccelerometerY() + ", " + (int)Gdx.input.getAccelerometerZ() +
+												", apr: " + (int)Gdx.input.getAzimuth() + ", " + (int)Gdx.input.getPitch() + ", " + (int)Gdx.input.getRoll());
+			last = System.nanoTime();
 		}
 	}
 
diff --git a/extensions/gdx-remote/AndroidManifest.xml b/extensions/gdx-remote/AndroidManifest.xml
index feaaf18..27a0f48 100644
--- a/extensions/gdx-remote/AndroidManifest.xml
+++ b/extensions/gdx-remote/AndroidManifest.xml
@@ -3,8 +3,9 @@
       package="com.badlogic.gdx.remote"
       android:versionCode="1"
       android:versionName="1.0">     
-    <uses-sdk android:minSdkVersion="3" android:targetSdkVersion="19"/>
+    <uses-sdk android:minSdkVersion="3" android:targetSdkVersion="9"/>
     <uses-permission android:name="android.permission.INTERNET"/>
+    <uses-permission android:name="android.permission.WAKE_LOCK"/>
 
     <application android:icon="@drawable/icon" android:label="@string/app_name">
         <activity android:name=".GdxRemote"
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/GdxSetup.java b/extensions/gdx-setup/src/com/badlogic/gdx/setup/GdxSetup.java
index 104822e..c16e66f 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/GdxSetup.java
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/GdxSetup.java
@@ -178,10 +178,6 @@ public class GdxSetup {
 	
 	private static void printHelp() {
 		System.out.println("Usage: GdxSetup --dir <dir-name> --name <app-name> --package <package> --mainClass <mainClass>");
-		System.out.println("dir ... the directory to write the project files to");
-		System.out.println("name ... the name of the application");
-		System.out.println("package ... the Java package name of the application");
-		System.out.println("mainClass ... the name of your main ApplicationListener");
 	}
 	
 	private static Map<String, String> parseArgs(String[] args) {
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/build.gradle b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/build.gradle
index 3bba8b3..a03b92f 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/build.gradle
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/build.gradle
@@ -1,7 +1,4 @@
 buildscript {
-
-    ext.gdxVersion = "1.0-SNAPSHOT"
-
     repositories {
         maven {
             url 'https://github.com/steffenschaefer/gwt-gradle-plugin/raw/maven-repo/'
@@ -12,8 +9,7 @@ buildscript {
     dependencies {
         classpath 'de.richsource.gradle.plugins:gwt-gradle-plugin:0.2'
         classpath 'com.android.tools.build:gradle:0.7.3+'
-        classpath 'com.github.jtakakura:gradle-robovm-plugin:0.0.4'
-        classpath "com.badlogicgames.gdx:gdx-tools:$gdxVersion"
+        classpath 'com.github.jtakakura:gradle-robovm-plugin:0.0.2'
     }
 }
 
@@ -23,12 +19,7 @@ allprojects {
     
     version = "1.0"
     ext.appName = "%APP_NAME%"
-
-    // Uncomment line below with proper parameters to pass to TexturePacker
-    // and TexturePacker will be invoked automagically whenever the target
-    // "texurePacker" is invoked, e.g. "./gradlew texturePacker desktop:run"
-
-    // ext.texturePacker = ['images', 'android/assets/data', 'gamegdx']
+    ext.gdxVersion = "1.0-SNAPSHOT"
     
     repositories {
         mavenCentral()
@@ -104,7 +95,7 @@ project(":ios") {
 
     ext {
         mainClassName = "%PACKAGE%.IOSLauncher"
-        roboVMVersion = "0.0.9"
+        roboVMVersion = "0.0.8"
     }
 
     task wrapper(type: Wrapper) {
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/core/build.gradle b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/core/build.gradle
index ed56d85..6058a93 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/core/build.gradle
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/core/build.gradle
@@ -10,12 +10,4 @@ sourceSets.main.java.srcDirs = [ "src/" ]
 
 eclipse.project {
     name = appName + "-core"
-}
-
-import com.badlogic.gdx.tools.texturepacker.TexturePacker
-task texturePacker << {
-  if (project.ext.has('texturePacker')) {
-    logger.info "Calling TexturePacker: "+texturePacker
-    TexturePacker.process(texturePacker[0], texturePacker[1], texturePacker[2])
-  }
-}
+}
\ No newline at end of file
diff --git a/extensions/gdx-tools/assets/licence-header.txt b/extensions/gdx-tools/assets/licence-header.txt
index 2f23579..46a92fe 100644
--- a/extensions/gdx-tools/assets/licence-header.txt
+++ b/extensions/gdx-tools/assets/licence-header.txt
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright 2014 See AUTHORS file.
+ * Copyright 2011 See AUTHORS file.
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -12,4 +12,4 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- ******************************************************************************/
+ ******************************************************************************/
\ No newline at end of file
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/MaxRectsPacker.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/MaxRectsPacker.java
index 1260dda..a8adb67 100644
--- a/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/MaxRectsPacker.java
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/MaxRectsPacker.java
@@ -1,714 +1,698 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.tools.texturepacker;
-
-import com.badlogic.gdx.math.MathUtils;
-import com.badlogic.gdx.tools.texturepacker.TexturePacker.Packer;
-import com.badlogic.gdx.tools.texturepacker.TexturePacker.Page;
-import com.badlogic.gdx.tools.texturepacker.TexturePacker.Rect;
-import com.badlogic.gdx.tools.texturepacker.TexturePacker.Settings;
-import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.Sort;
-
-import java.util.Comparator;
-
-/** Packs pages of images using the maximal rectangles bin packing algorithm by Jukka Jylänki. A brute force binary search is used
- * to pack into the smallest bin possible.
- * @author Nathan Sweet */
-public class MaxRectsPacker implements Packer {
-	private RectComparator rectComparator = new RectComparator();
-	private FreeRectChoiceHeuristic[] methods = FreeRectChoiceHeuristic.values();
-	private MaxRects maxRects = new MaxRects();
-	Settings settings;
-	private Sort sort = new Sort();
-
-	public MaxRectsPacker (Settings settings) {
-		this.settings = settings;
-		if (settings.minWidth > settings.maxWidth) throw new RuntimeException("Page min width cannot be higher than max width.");
-		if (settings.minHeight > settings.maxHeight)
-			throw new RuntimeException("Page min height cannot be higher than max height.");
-	}
-
-	public Array<Page> pack (Array<Rect> inputRects) {
-		for (int i = 0, nn = inputRects.size; i < nn; i++) {
-			Rect rect = inputRects.get(i);
-			rect.width += settings.paddingX;
-			rect.height += settings.paddingY;
-		}
-
-		if (settings.fast) {
-			if (settings.rotation) {
-				// Sort by longest side if rotation is enabled.
-				sort.sort(inputRects, new Comparator<Rect>() {
-					public int compare (Rect o1, Rect o2) {
-						int n1 = o1.width > o1.height ? o1.width : o1.height;
-						int n2 = o2.width > o2.height ? o2.width : o2.height;
-						return n2 - n1;
-					}
-				});
-			} else {
-				// Sort only by width (largest to smallest) if rotation is disabled.
-				sort.sort(inputRects, new Comparator<Rect>() {
-					public int compare (Rect o1, Rect o2) {
-						return o2.width - o1.width;
-					}
-				});
-			}
-		}
-
-		Array<Page> pages = new Array();
-		while (inputRects.size > 0) {
-			Page result = packPage(inputRects);
-			pages.add(result);
-			inputRects = result.remainingRects;
-		}
-		return pages;
-	}
-
-	private Page packPage (Array<Rect> inputRects) {
-		int edgePaddingX = 0, edgePaddingY = 0;
-		if (!settings.duplicatePadding) { // if duplicatePadding, edges get only half padding.
-			edgePaddingX = settings.paddingX;
-			edgePaddingY = settings.paddingY;
-		}
-		// Find min size.
-		int minWidth = Integer.MAX_VALUE;
-		int minHeight = Integer.MAX_VALUE;
-		for (int i = 0, nn = inputRects.size; i < nn; i++) {
-			Rect rect = inputRects.get(i);
-			minWidth = Math.min(minWidth, rect.width);
-			minHeight = Math.min(minHeight, rect.height);
-			if (settings.rotation) {
-				if ((rect.width > settings.maxWidth || rect.height > settings.maxHeight)
-					&& (rect.width > settings.maxHeight || rect.height > settings.maxWidth)) {
-					throw new RuntimeException("Image does not fit with max page size " + settings.maxWidth + "x" + settings.maxHeight
-						+ " and padding " + settings.paddingX + "," + settings.paddingY + ": " + rect);
-				}
-			} else {
-				if (rect.width > settings.maxWidth) {
-					throw new RuntimeException("Image does not fit with max page width " + settings.maxWidth + " and paddingX "
-						+ settings.paddingX + ": " + rect);
-				}
-				if (rect.height > settings.maxHeight && (!settings.rotation || rect.width > settings.maxHeight)) {
-					throw new RuntimeException("Image does not fit in max page height " + settings.maxHeight + " and paddingY "
-						+ settings.paddingY + ": " + rect);
-				}
-			}
-		}
-		minWidth = Math.max(minWidth, settings.minWidth);
-		minHeight = Math.max(minHeight, settings.minHeight);
-
-		System.out.print("Packing");
-
-		// Find the minimal page size that fits all rects.
-		Page bestResult = null;
-		if (settings.square) {
-			int minSize = Math.max(minWidth, minHeight);
-			int maxSize = Math.min(settings.maxWidth, settings.maxHeight);
-			BinarySearch sizeSearch = new BinarySearch(minSize, maxSize, settings.fast ? 25 : 15, settings.pot);
-			int size = sizeSearch.reset(), i = 0;
-			while (size != -1) {
-				Page result = packAtSize(true, size - edgePaddingX, size - edgePaddingY, inputRects);
-				if (++i % 70 == 0) System.out.println();
-				System.out.print(".");
-				bestResult = getBest(bestResult, result);
-				size = sizeSearch.next(result == null);
-			}
-			System.out.println();
-			// Rects don't fit on one page. Fill a whole page and return.
-			if (bestResult == null) bestResult = packAtSize(false, maxSize - edgePaddingX, maxSize - edgePaddingY, inputRects);
-			sort.sort(bestResult.outputRects, rectComparator);
-			return bestResult;
-		} else {
-			BinarySearch widthSearch = new BinarySearch(minWidth, settings.maxWidth, settings.fast ? 25 : 15, settings.pot);
-			BinarySearch heightSearch = new BinarySearch(minHeight, settings.maxHeight, settings.fast ? 25 : 15, settings.pot);
-			int width = widthSearch.reset(), i = 0;
-			int height = settings.square ? width : heightSearch.reset();
-			while (true) {
-				Page bestWidthResult = null;
-				while (width != -1) {
-					Page result = packAtSize(true, width - edgePaddingX, height - edgePaddingY, inputRects);
-					if (++i % 70 == 0) System.out.println();
-					System.out.print(".");
-					bestWidthResult = getBest(bestWidthResult, result);
-					width = widthSearch.next(result == null);
-					if (settings.square) height = width;
-				}
-				bestResult = getBest(bestResult, bestWidthResult);
-				if (settings.square) break;
-				height = heightSearch.next(bestWidthResult == null);
-				if (height == -1) break;
-				width = widthSearch.reset();
-			}
-			System.out.println();
-			// Rects don't fit on one page. Fill a whole page and return.
-			if (bestResult == null)
-				bestResult = packAtSize(false, settings.maxWidth - edgePaddingX, settings.maxHeight - edgePaddingY, inputRects);
-			sort.sort(bestResult.outputRects, rectComparator);
-			return bestResult;
-		}
-	}
-
-	/** @param fully If true, the only results that pack all rects will be considered. If false, all results are considered, not all
-	 *           rects may be packed. */
-	private Page packAtSize (boolean fully, int width, int height, Array<Rect> inputRects) {
-		Page bestResult = null;
-		for (int i = 0, n = methods.length; i < n; i++) {
-			maxRects.init(width, height);
-			Page result;
-			if (!settings.fast) {
-				result = maxRects.pack(inputRects, methods[i]);
-			} else {
-				Array<Rect> remaining = new Array();
-				for (int ii = 0, nn = inputRects.size; ii < nn; ii++) {
-					Rect rect = inputRects.get(ii);
-					if (maxRects.insert(rect, methods[i]) == null) {
-						while (ii < nn)
-							remaining.add(inputRects.get(ii++));
-					}
-				}
-				result = maxRects.getResult();
-				result.remainingRects = remaining;
-			}
-			if (fully && result.remainingRects.size > 0) continue;
-			if (result.outputRects.size == 0) continue;
-			bestResult = getBest(bestResult, result);
-		}
-		return bestResult;
-	}
-
-	private Page getBest (Page result1, Page result2) {
-		if (result1 == null) return result2;
-		if (result2 == null) return result1;
-		return result1.occupancy > result2.occupancy ? result1 : result2;
-	}
-
-	static class BinarySearch {
-		int min, max, fuzziness, low, high, current;
-		boolean pot;
-
-		public BinarySearch (int min, int max, int fuzziness, boolean pot) {
-			this.pot = pot;
-			this.fuzziness = pot ? 0 : fuzziness;
-			this.min = pot ? (int)(Math.log(MathUtils.nextPowerOfTwo(min)) / Math.log(2)) : min;
-			this.max = pot ? (int)(Math.log(MathUtils.nextPowerOfTwo(max)) / Math.log(2)) : max;
-		}
-
-		public int reset () {
-			low = min;
-			high = max;
-			current = (low + high) >>> 1;
-			return pot ? (int)Math.pow(2, current) : current;
-		}
-
-		public int next (boolean result) {
-			if (low >= high) return -1;
-			if (result)
-				low = current + 1;
-			else
-				high = current - 1;
-			current = (low + high) >>> 1;
-			if (Math.abs(low - high) < fuzziness) return -1;
-			return pot ? (int)Math.pow(2, current) : current;
-		}
-	}
-
-	/** Maximal rectangles bin packing algorithm. Adapted from this C++ public domain source:
-	 * http://clb.demon.fi/projects/even-more-rectangle-bin-packing
-	 * @author Jukka Jyl�nki
-	 * @author Nathan Sweet */
-	class MaxRects {
-		private int binWidth;
-		private int binHeight;
-		private final Array<Rect> usedRectangles = new Array();
-		private final Array<Rect> freeRectangles = new Array();
-
-		public void init (int width, int height) {
-			binWidth = width;
-			binHeight = height;
-
-			usedRectangles.clear();
-			freeRectangles.clear();
-			Rect n = new Rect();
-			n.x = 0;
-			n.y = 0;
-			n.width = width;
-			n.height = height;
-			freeRectangles.add(n);
-		}
-
-		/** Packs a single image. Order is defined externally. */
-		public Rect insert (Rect rect, FreeRectChoiceHeuristic method) {
-			Rect newNode = scoreRect(rect, method);
-			if (newNode.height == 0) return null;
-
-			int numRectanglesToProcess = freeRectangles.size;
-			for (int i = 0; i < numRectanglesToProcess; ++i) {
-				if (splitFreeNode(freeRectangles.get(i), newNode)) {
-					freeRectangles.removeIndex(i);
-					--i;
-					--numRectanglesToProcess;
-				}
-			}
-
-			pruneFreeList();
-
-			Rect bestNode = new Rect();
-			bestNode.set(rect);
-			bestNode.score1 = newNode.score1;
-			bestNode.score2 = newNode.score2;
-			bestNode.x = newNode.x;
-			bestNode.y = newNode.y;
-			bestNode.width = newNode.width;
-			bestNode.height = newNode.height;
-			bestNode.rotated = newNode.rotated;
-
-			usedRectangles.add(bestNode);
-			return bestNode;
-		}
-
-		/** For each rectangle, packs each one then chooses the best and packs that. Slow! */
-		public Page pack (Array<Rect> rects, FreeRectChoiceHeuristic method) {
-			rects = new Array(rects);
-			while (rects.size > 0) {
-				int bestRectIndex = -1;
-				Rect bestNode = new Rect();
-				bestNode.score1 = Integer.MAX_VALUE;
-				bestNode.score2 = Integer.MAX_VALUE;
-
-				// Find the next rectangle that packs best.
-				for (int i = 0; i < rects.size; i++) {
-					Rect newNode = scoreRect(rects.get(i), method);
-					if (newNode.score1 < bestNode.score1 || (newNode.score1 == bestNode.score1 && newNode.score2 < bestNode.score2)) {
-						bestNode.set(rects.get(i));
-						bestNode.score1 = newNode.score1;
-						bestNode.score2 = newNode.score2;
-						bestNode.x = newNode.x;
-						bestNode.y = newNode.y;
-						bestNode.width = newNode.width;
-						bestNode.height = newNode.height;
-						bestNode.rotated = newNode.rotated;
-						bestRectIndex = i;
-					}
-				}
-
-				if (bestRectIndex == -1) break;
-
-				placeRect(bestNode);
-				rects.removeIndex(bestRectIndex);
-			}
-
-			Page result = getResult();
-			result.remainingRects = rects;
-			return result;
-		}
-
-		public Page getResult () {
-			int w = 0, h = 0;
-			for (int i = 0; i < usedRectangles.size; i++) {
-				Rect rect = usedRectangles.get(i);
-				w = Math.max(w, rect.x + rect.width);
-				h = Math.max(h, rect.y + rect.height);
-			}
-			Page result = new Page();
-			result.outputRects = new Array(usedRectangles);
-			result.occupancy = getOccupancy();
-			result.width = w;
-			result.height = h;
-			return result;
-		}
-
-		private void placeRect (Rect node) {
-			int numRectanglesToProcess = freeRectangles.size;
-			for (int i = 0; i < numRectanglesToProcess; i++) {
-				if (splitFreeNode(freeRectangles.get(i), node)) {
-					freeRectangles.removeIndex(i);
-					--i;
-					--numRectanglesToProcess;
-				}
-			}
-
-			pruneFreeList();
-
-			usedRectangles.add(node);
-		}
-
-		private Rect scoreRect (Rect rect, FreeRectChoiceHeuristic method) {
-			int width = rect.width;
-			int height = rect.height;
-			int rotatedWidth = height - settings.paddingY + settings.paddingX;
-			int rotatedHeight = width - settings.paddingX + settings.paddingY;
-			boolean rotate = rect.canRotate && settings.rotation;
-
-			Rect newNode = null;
-			switch (method) {
-			case BestShortSideFit:
-				newNode = findPositionForNewNodeBestShortSideFit(width, height, rotatedWidth, rotatedHeight, rotate);
-				break;
-			case BottomLeftRule:
-				newNode = findPositionForNewNodeBottomLeft(width, height, rotatedWidth, rotatedHeight, rotate);
-				break;
-			case ContactPointRule:
-				newNode = findPositionForNewNodeContactPoint(width, height, rotatedWidth, rotatedHeight, rotate);
-				newNode.score1 = -newNode.score1; // Reverse since we are minimizing, but for contact point score bigger is better.
-				break;
-			case BestLongSideFit:
-				newNode = findPositionForNewNodeBestLongSideFit(width, height, rotatedWidth, rotatedHeight, rotate);
-				break;
-			case BestAreaFit:
-				newNode = findPositionForNewNodeBestAreaFit(width, height, rotatedWidth, rotatedHeight, rotate);
-				break;
-			}
-
-			// Cannot fit the current rectangle.
-			if (newNode.height == 0) {
-				newNode.score1 = Integer.MAX_VALUE;
-				newNode.score2 = Integer.MAX_VALUE;
-			}
-
-			return newNode;
-		}
-
-		// / Computes the ratio of used surface area.
-		private float getOccupancy () {
-			int usedSurfaceArea = 0;
-			for (int i = 0; i < usedRectangles.size; i++)
-				usedSurfaceArea += usedRectangles.get(i).width * usedRectangles.get(i).height;
-			return (float)usedSurfaceArea / (binWidth * binHeight);
-		}
-
-		private Rect findPositionForNewNodeBottomLeft (int width, int height, int rotatedWidth, int rotatedHeight, boolean rotate) {
-			Rect bestNode = new Rect();
-
-			bestNode.score1 = Integer.MAX_VALUE; // best y, score2 is best x
-
-			for (int i = 0; i < freeRectangles.size; i++) {
-				// Try to place the rectangle in upright (non-rotated) orientation.
-				if (freeRectangles.get(i).width >= width && freeRectangles.get(i).height >= height) {
-					int topSideY = freeRectangles.get(i).y + height;
-					if (topSideY < bestNode.score1 || (topSideY == bestNode.score1 && freeRectangles.get(i).x < bestNode.score2)) {
-						bestNode.x = freeRectangles.get(i).x;
-						bestNode.y = freeRectangles.get(i).y;
-						bestNode.width = width;
-						bestNode.height = height;
-						bestNode.score1 = topSideY;
-						bestNode.score2 = freeRectangles.get(i).x;
-						bestNode.rotated = false;
-					}
-				}
-				if (rotate && freeRectangles.get(i).width >= rotatedWidth && freeRectangles.get(i).height >= rotatedHeight) {
-					int topSideY = freeRectangles.get(i).y + rotatedHeight;
-					if (topSideY < bestNode.score1 || (topSideY == bestNode.score1 && freeRectangles.get(i).x < bestNode.score2)) {
-						bestNode.x = freeRectangles.get(i).x;
-						bestNode.y = freeRectangles.get(i).y;
-						bestNode.width = rotatedWidth;
-						bestNode.height = rotatedHeight;
-						bestNode.score1 = topSideY;
-						bestNode.score2 = freeRectangles.get(i).x;
-						bestNode.rotated = true;
-					}
-				}
-			}
-			return bestNode;
-		}
-
-		private Rect findPositionForNewNodeBestShortSideFit (int width, int height, int rotatedWidth, int rotatedHeight,
-			boolean rotate) {
-			Rect bestNode = new Rect();
-			bestNode.score1 = Integer.MAX_VALUE;
-
-			for (int i = 0; i < freeRectangles.size; i++) {
-				// Try to place the rectangle in upright (non-rotated) orientation.
-				if (freeRectangles.get(i).width >= width && freeRectangles.get(i).height >= height) {
-					int leftoverHoriz = Math.abs(freeRectangles.get(i).width - width);
-					int leftoverVert = Math.abs(freeRectangles.get(i).height - height);
-					int shortSideFit = Math.min(leftoverHoriz, leftoverVert);
-					int longSideFit = Math.max(leftoverHoriz, leftoverVert);
-
-					if (shortSideFit < bestNode.score1 || (shortSideFit == bestNode.score1 && longSideFit < bestNode.score2)) {
-						bestNode.x = freeRectangles.get(i).x;
-						bestNode.y = freeRectangles.get(i).y;
-						bestNode.width = width;
-						bestNode.height = height;
-						bestNode.score1 = shortSideFit;
-						bestNode.score2 = longSideFit;
-						bestNode.rotated = false;
-					}
-				}
-
-				if (rotate && freeRectangles.get(i).width >= rotatedWidth && freeRectangles.get(i).height >= rotatedHeight) {
-					int flippedLeftoverHoriz = Math.abs(freeRectangles.get(i).width - rotatedWidth);
-					int flippedLeftoverVert = Math.abs(freeRectangles.get(i).height - rotatedHeight);
-					int flippedShortSideFit = Math.min(flippedLeftoverHoriz, flippedLeftoverVert);
-					int flippedLongSideFit = Math.max(flippedLeftoverHoriz, flippedLeftoverVert);
-
-					if (flippedShortSideFit < bestNode.score1
-						|| (flippedShortSideFit == bestNode.score1 && flippedLongSideFit < bestNode.score2)) {
-						bestNode.x = freeRectangles.get(i).x;
-						bestNode.y = freeRectangles.get(i).y;
-						bestNode.width = rotatedWidth;
-						bestNode.height = rotatedHeight;
-						bestNode.score1 = flippedShortSideFit;
-						bestNode.score2 = flippedLongSideFit;
-						bestNode.rotated = true;
-					}
-				}
-			}
-
-			return bestNode;
-		}
-
-		private Rect findPositionForNewNodeBestLongSideFit (int width, int height, int rotatedWidth, int rotatedHeight,
-			boolean rotate) {
-			Rect bestNode = new Rect();
-
-			bestNode.score2 = Integer.MAX_VALUE;
-
-			for (int i = 0; i < freeRectangles.size; i++) {
-				// Try to place the rectangle in upright (non-rotated) orientation.
-				if (freeRectangles.get(i).width >= width && freeRectangles.get(i).height >= height) {
-					int leftoverHoriz = Math.abs(freeRectangles.get(i).width - width);
-					int leftoverVert = Math.abs(freeRectangles.get(i).height - height);
-					int shortSideFit = Math.min(leftoverHoriz, leftoverVert);
-					int longSideFit = Math.max(leftoverHoriz, leftoverVert);
-
-					if (longSideFit < bestNode.score2 || (longSideFit == bestNode.score2 && shortSideFit < bestNode.score1)) {
-						bestNode.x = freeRectangles.get(i).x;
-						bestNode.y = freeRectangles.get(i).y;
-						bestNode.width = width;
-						bestNode.height = height;
-						bestNode.score1 = shortSideFit;
-						bestNode.score2 = longSideFit;
-						bestNode.rotated = false;
-					}
-				}
-
-				if (rotate && freeRectangles.get(i).width >= rotatedWidth && freeRectangles.get(i).height >= rotatedHeight) {
-					int leftoverHoriz = Math.abs(freeRectangles.get(i).width - rotatedWidth);
-					int leftoverVert = Math.abs(freeRectangles.get(i).height - rotatedHeight);
-					int shortSideFit = Math.min(leftoverHoriz, leftoverVert);
-					int longSideFit = Math.max(leftoverHoriz, leftoverVert);
-
-					if (longSideFit < bestNode.score2 || (longSideFit == bestNode.score2 && shortSideFit < bestNode.score1)) {
-						bestNode.x = freeRectangles.get(i).x;
-						bestNode.y = freeRectangles.get(i).y;
-						bestNode.width = rotatedWidth;
-						bestNode.height = rotatedHeight;
-						bestNode.score1 = shortSideFit;
-						bestNode.score2 = longSideFit;
-						bestNode.rotated = true;
-					}
-				}
-			}
-			return bestNode;
-		}
-
-		private Rect findPositionForNewNodeBestAreaFit (int width, int height, int rotatedWidth, int rotatedHeight, boolean rotate) {
-			Rect bestNode = new Rect();
-
-			bestNode.score1 = Integer.MAX_VALUE; // best area fit, score2 is best short side fit
-
-			for (int i = 0; i < freeRectangles.size; i++) {
-				int areaFit = freeRectangles.get(i).width * freeRectangles.get(i).height - width * height;
-
-				// Try to place the rectangle in upright (non-rotated) orientation.
-				if (freeRectangles.get(i).width >= width && freeRectangles.get(i).height >= height) {
-					int leftoverHoriz = Math.abs(freeRectangles.get(i).width - width);
-					int leftoverVert = Math.abs(freeRectangles.get(i).height - height);
-					int shortSideFit = Math.min(leftoverHoriz, leftoverVert);
-
-					if (areaFit < bestNode.score1 || (areaFit == bestNode.score1 && shortSideFit < bestNode.score2)) {
-						bestNode.x = freeRectangles.get(i).x;
-						bestNode.y = freeRectangles.get(i).y;
-						bestNode.width = width;
-						bestNode.height = height;
-						bestNode.score2 = shortSideFit;
-						bestNode.score1 = areaFit;
-						bestNode.rotated = false;
-					}
-				}
-
-				if (rotate && freeRectangles.get(i).width >= rotatedWidth && freeRectangles.get(i).height >= rotatedHeight) {
-					int leftoverHoriz = Math.abs(freeRectangles.get(i).width - rotatedWidth);
-					int leftoverVert = Math.abs(freeRectangles.get(i).height - rotatedHeight);
-					int shortSideFit = Math.min(leftoverHoriz, leftoverVert);
-
-					if (areaFit < bestNode.score1 || (areaFit == bestNode.score1 && shortSideFit < bestNode.score2)) {
-						bestNode.x = freeRectangles.get(i).x;
-						bestNode.y = freeRectangles.get(i).y;
-						bestNode.width = rotatedWidth;
-						bestNode.height = rotatedHeight;
-						bestNode.score2 = shortSideFit;
-						bestNode.score1 = areaFit;
-						bestNode.rotated = true;
-					}
-				}
-			}
-			return bestNode;
-		}
-
-		// / Returns 0 if the two intervals i1 and i2 are disjoint, or the length of their overlap otherwise.
-		private int commonIntervalLength (int i1start, int i1end, int i2start, int i2end) {
-			if (i1end < i2start || i2end < i1start) return 0;
-			return Math.min(i1end, i2end) - Math.max(i1start, i2start);
-		}
-
-		private int contactPointScoreNode (int x, int y, int width, int height) {
-			int score = 0;
-
-			if (x == 0 || x + width == binWidth) score += height;
-			if (y == 0 || y + height == binHeight) score += width;
-
-			for (int i = 0; i < usedRectangles.size; i++) {
-				if (usedRectangles.get(i).x == x + width || usedRectangles.get(i).x + usedRectangles.get(i).width == x)
-					score += commonIntervalLength(usedRectangles.get(i).y, usedRectangles.get(i).y + usedRectangles.get(i).height, y,
-						y + height);
-				if (usedRectangles.get(i).y == y + height || usedRectangles.get(i).y + usedRectangles.get(i).height == y)
-					score += commonIntervalLength(usedRectangles.get(i).x, usedRectangles.get(i).x + usedRectangles.get(i).width, x, x
-						+ width);
-			}
-			return score;
-		}
-
-		private Rect findPositionForNewNodeContactPoint (int width, int height, int rotatedWidth, int rotatedHeight, boolean rotate) {
-			Rect bestNode = new Rect();
-
-			bestNode.score1 = -1; // best contact score
-
-			for (int i = 0; i < freeRectangles.size; i++) {
-				// Try to place the rectangle in upright (non-rotated) orientation.
-				if (freeRectangles.get(i).width >= width && freeRectangles.get(i).height >= height) {
-					int score = contactPointScoreNode(freeRectangles.get(i).x, freeRectangles.get(i).y, width, height);
-					if (score > bestNode.score1) {
-						bestNode.x = freeRectangles.get(i).x;
-						bestNode.y = freeRectangles.get(i).y;
-						bestNode.width = width;
-						bestNode.height = height;
-						bestNode.score1 = score;
-						bestNode.rotated = false;
-					}
-				}
-				if (rotate && freeRectangles.get(i).width >= rotatedWidth && freeRectangles.get(i).height >= rotatedHeight) {
-					// This was width,height -- bug fixed?
-					int score = contactPointScoreNode(freeRectangles.get(i).x, freeRectangles.get(i).y, rotatedWidth, rotatedHeight);
-					if (score > bestNode.score1) {
-						bestNode.x = freeRectangles.get(i).x;
-						bestNode.y = freeRectangles.get(i).y;
-						bestNode.width = rotatedWidth;
-						bestNode.height = rotatedHeight;
-						bestNode.score1 = score;
-						bestNode.rotated = true;
-					}
-				}
-			}
-			return bestNode;
-		}
-
-		private boolean splitFreeNode (Rect freeNode, Rect usedNode) {
-			// Test with SAT if the rectangles even intersect.
-			if (usedNode.x >= freeNode.x + freeNode.width || usedNode.x + usedNode.width <= freeNode.x
-				|| usedNode.y >= freeNode.y + freeNode.height || usedNode.y + usedNode.height <= freeNode.y) return false;
-
-			if (usedNode.x < freeNode.x + freeNode.width && usedNode.x + usedNode.width > freeNode.x) {
-				// New node at the top side of the used node.
-				if (usedNode.y > freeNode.y && usedNode.y < freeNode.y + freeNode.height) {
-					Rect newNode = new Rect(freeNode);
-					newNode.height = usedNode.y - newNode.y;
-					freeRectangles.add(newNode);
-				}
-
-				// New node at the bottom side of the used node.
-				if (usedNode.y + usedNode.height < freeNode.y + freeNode.height) {
-					Rect newNode = new Rect(freeNode);
-					newNode.y = usedNode.y + usedNode.height;
-					newNode.height = freeNode.y + freeNode.height - (usedNode.y + usedNode.height);
-					freeRectangles.add(newNode);
-				}
-			}
-
-			if (usedNode.y < freeNode.y + freeNode.height && usedNode.y + usedNode.height > freeNode.y) {
-				// New node at the left side of the used node.
-				if (usedNode.x > freeNode.x && usedNode.x < freeNode.x + freeNode.width) {
-					Rect newNode = new Rect(freeNode);
-					newNode.width = usedNode.x - newNode.x;
-					freeRectangles.add(newNode);
-				}
-
-				// New node at the right side of the used node.
-				if (usedNode.x + usedNode.width < freeNode.x + freeNode.width) {
-					Rect newNode = new Rect(freeNode);
-					newNode.x = usedNode.x + usedNode.width;
-					newNode.width = freeNode.x + freeNode.width - (usedNode.x + usedNode.width);
-					freeRectangles.add(newNode);
-				}
-			}
-
-			return true;
-		}
-
-		private void pruneFreeList () {
-			/*
-			 * /// Would be nice to do something like this, to avoid a Theta(n^2) loop through each pair. /// But unfortunately it
-			 * doesn't quite cut it, since we also want to detect containment. /// Perhaps there's another way to do this faster than
-			 * Theta(n^2).
-			 * 
-			 * if (freeRectangles.size > 0) clb::sort::QuickSort(&freeRectangles[0], freeRectangles.size, NodeSortCmp);
-			 * 
-			 * for(int i = 0; i < freeRectangles.size-1; i++) if (freeRectangles[i].x == freeRectangles[i+1].x && freeRectangles[i].y
-			 * == freeRectangles[i+1].y && freeRectangles[i].width == freeRectangles[i+1].width && freeRectangles[i].height ==
-			 * freeRectangles[i+1].height) { freeRectangles.erase(freeRectangles.begin() + i); --i; }
-			 */
-
-			// / Go through each pair and remove any rectangle that is redundant.
-			for (int i = 0; i < freeRectangles.size; i++)
-				for (int j = i + 1; j < freeRectangles.size; ++j) {
-					if (isContainedIn(freeRectangles.get(i), freeRectangles.get(j))) {
-						freeRectangles.removeIndex(i);
-						--i;
-						break;
-					}
-					if (isContainedIn(freeRectangles.get(j), freeRectangles.get(i))) {
-						freeRectangles.removeIndex(j);
-						--j;
-					}
-				}
-		}
-
-		private boolean isContainedIn (Rect a, Rect b) {
-			return a.x >= b.x && a.y >= b.y && a.x + a.width <= b.x + b.width && a.y + a.height <= b.y + b.height;
-		}
-	}
-
-	static public enum FreeRectChoiceHeuristic {
-		// BSSF: Positions the rectangle against the short side of a free rectangle into which it fits the best.
-		BestShortSideFit,
-		// BLSF: Positions the rectangle against the long side of a free rectangle into which it fits the best.
-		BestLongSideFit,
-		// BAF: Positions the rectangle into the smallest free rect into which it fits.
-		BestAreaFit,
-		// BL: Does the Tetris placement.
-		BottomLeftRule,
-		// CP: Choosest the placement where the rectangle touches other rects as much as possible.
-		ContactPointRule
-	};
-
-	class RectComparator implements Comparator<Rect> {
-		public int compare (Rect o1, Rect o2) {
-			return Rect.getAtlasName(o1.name, settings.flattenPaths).compareTo(Rect.getAtlasName(o2.name, settings.flattenPaths));
-		}
-	}
-}
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.tools.texturepacker;
+
+import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.tools.texturepacker.TexturePacker.Packer;
+import com.badlogic.gdx.tools.texturepacker.TexturePacker.Page;
+import com.badlogic.gdx.tools.texturepacker.TexturePacker.Rect;
+import com.badlogic.gdx.tools.texturepacker.TexturePacker.Settings;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.Sort;
+
+import java.util.Comparator;
+
+/** Packs pages of images using the maximal rectangles bin packing algorithm by Jukka Jylänki. A brute force binary search is used
+ * to pack into the smallest bin possible.
+ * @author Nathan Sweet */
+public class MaxRectsPacker implements Packer {
+	private RectComparator rectComparator = new RectComparator();
+	private FreeRectChoiceHeuristic[] methods = FreeRectChoiceHeuristic.values();
+	private MaxRects maxRects = new MaxRects();
+	Settings settings;
+	private Sort sort = new Sort();
+
+	public MaxRectsPacker (Settings settings) {
+		this.settings = settings;
+		if (settings.minWidth > settings.maxWidth) throw new RuntimeException("Page min width cannot be higher than max width.");
+		if (settings.minHeight > settings.maxHeight)
+			throw new RuntimeException("Page min height cannot be higher than max height.");
+	}
+
+	public Array<Page> pack (Array<Rect> inputRects) {
+		for (int i = 0, nn = inputRects.size; i < nn; i++) {
+			Rect rect = inputRects.get(i);
+			rect.width += settings.paddingX;
+			rect.height += settings.paddingY;
+		}
+
+		if (settings.fast) {
+			if (settings.rotation) {
+				// Sort by longest side if rotation is enabled.
+				sort.sort(inputRects, new Comparator<Rect>() {
+					public int compare (Rect o1, Rect o2) {
+						int n1 = o1.width > o1.height ? o1.width : o1.height;
+						int n2 = o2.width > o2.height ? o2.width : o2.height;
+						return n2 - n1;
+					}
+				});
+			} else {
+				// Sort only by width (largest to smallest) if rotation is disabled.
+				sort.sort(inputRects, new Comparator<Rect>() {
+					public int compare (Rect o1, Rect o2) {
+						return o2.width - o1.width;
+					}
+				});
+			}
+		}
+
+		Array<Page> pages = new Array();
+		while (inputRects.size > 0) {
+			Page result = packPage(inputRects);
+			pages.add(result);
+			inputRects = result.remainingRects;
+		}
+		return pages;
+	}
+
+	private Page packPage (Array<Rect> inputRects) {
+		int edgePaddingX = 0, edgePaddingY = 0;
+		if (!settings.duplicatePadding) { // if duplicatePadding, edges get only half padding.
+			edgePaddingX = settings.paddingX;
+			edgePaddingY = settings.paddingY;
+		}
+		// Find min size.
+		int minWidth = Integer.MAX_VALUE;
+		int minHeight = Integer.MAX_VALUE;
+		for (int i = 0, nn = inputRects.size; i < nn; i++) {
+			Rect rect = inputRects.get(i);
+			minWidth = Math.min(minWidth, rect.width);
+			minHeight = Math.min(minHeight, rect.height);
+			if (settings.rotation) {
+				if ((rect.width > settings.maxWidth || rect.height > settings.maxHeight)
+					&& (rect.width > settings.maxHeight || rect.height > settings.maxWidth)) {
+					throw new RuntimeException("Image does not fit with max page size " + settings.maxWidth + "x" + settings.maxHeight
+						+ " and padding " + settings.paddingX + "," + settings.paddingY + ": " + rect);
+				}
+			} else {
+				if (rect.width > settings.maxWidth) {
+					throw new RuntimeException("Image does not fit with max page width " + settings.maxWidth + " and paddingX "
+						+ settings.paddingX + ": " + rect);
+				}
+				if (rect.height > settings.maxHeight && (!settings.rotation || rect.width > settings.maxHeight)) {
+					throw new RuntimeException("Image does not fit in max page height " + settings.maxHeight + " and paddingY "
+						+ settings.paddingY + ": " + rect);
+				}
+			}
+		}
+		minWidth = Math.max(minWidth, settings.minWidth);
+		minHeight = Math.max(minHeight, settings.minHeight);
+
+		System.out.print("Packing");
+
+		// Find the minimal page size that fits all rects.
+		BinarySearch widthSearch = new BinarySearch(minWidth, settings.maxWidth, settings.fast ? 25 : 15, settings.pot);
+		BinarySearch heightSearch = new BinarySearch(minHeight, settings.maxHeight, settings.fast ? 25 : 15, settings.pot);
+		int width = widthSearch.reset(), i = 0;
+		int height = settings.square ? width : heightSearch.reset();
+		Page bestResult = null;
+		while (true) {
+			Page bestWidthResult = null;
+			while (width != -1) {
+				Page result = packAtSize(true, width - edgePaddingX, height - edgePaddingY, inputRects);
+				if (++i % 70 == 0) System.out.println();
+				System.out.print(".");
+				bestWidthResult = getBest(bestWidthResult, result);
+				width = widthSearch.next(result == null);
+				if (settings.square) height = width;
+			}
+			bestResult = getBest(bestResult, bestWidthResult);
+			if (settings.square) break;
+			height = heightSearch.next(bestWidthResult == null);
+			if (height == -1) break;
+			width = widthSearch.reset();
+		}
+		System.out.println();
+
+		// Rects don't fit on one page. Fill a whole page and return.
+		if (bestResult == null)
+			bestResult = packAtSize(false, settings.maxWidth - edgePaddingX, settings.maxHeight - edgePaddingY, inputRects);
+
+		sort.sort(bestResult.outputRects, rectComparator);
+
+		return bestResult;
+	}
+
+	/** @param fully If true, the only results that pack all rects will be considered. If false, all results are considered, not all
+	 *           rects may be packed. */
+	private Page packAtSize (boolean fully, int width, int height, Array<Rect> inputRects) {
+		Page bestResult = null;
+		for (int i = 0, n = methods.length; i < n; i++) {
+			maxRects.init(width, height);
+			Page result;
+			if (!settings.fast) {
+				result = maxRects.pack(inputRects, methods[i]);
+			} else {
+				Array<Rect> remaining = new Array();
+				for (int ii = 0, nn = inputRects.size; ii < nn; ii++) {
+					Rect rect = inputRects.get(ii);
+					if (maxRects.insert(rect, methods[i]) == null) {
+						while (ii < nn)
+							remaining.add(inputRects.get(ii++));
+					}
+				}
+				result = maxRects.getResult();
+				result.remainingRects = remaining;
+			}
+			if (fully && result.remainingRects.size > 0) continue;
+			if (result.outputRects.size == 0) continue;
+			bestResult = getBest(bestResult, result);
+		}
+		return bestResult;
+	}
+
+	private Page getBest (Page result1, Page result2) {
+		if (result1 == null) return result2;
+		if (result2 == null) return result1;
+		return result1.occupancy > result2.occupancy ? result1 : result2;
+	}
+
+	static class BinarySearch {
+		int min, max, fuzziness, low, high, current;
+		boolean pot;
+
+		public BinarySearch (int min, int max, int fuzziness, boolean pot) {
+			this.pot = pot;
+			this.fuzziness = pot ? 0 : fuzziness;
+			this.min = pot ? (int)(Math.log(MathUtils.nextPowerOfTwo(min)) / Math.log(2)) : min;
+			this.max = pot ? (int)(Math.log(MathUtils.nextPowerOfTwo(max)) / Math.log(2)) : max;
+		}
+
+		public int reset () {
+			low = min;
+			high = max;
+			current = (low + high) >>> 1;
+			return pot ? (int)Math.pow(2, current) : current;
+		}
+
+		public int next (boolean result) {
+			if (low >= high) return -1;
+			if (result)
+				low = current + 1;
+			else
+				high = current - 1;
+			current = (low + high) >>> 1;
+			if (Math.abs(low - high) < fuzziness) return -1;
+			return pot ? (int)Math.pow(2, current) : current;
+		}
+	}
+
+	/** Maximal rectangles bin packing algorithm. Adapted from this C++ public domain source:
+	 * http://clb.demon.fi/projects/even-more-rectangle-bin-packing
+	 * @author Jukka Jyl�nki
+	 * @author Nathan Sweet */
+	class MaxRects {
+		private int binWidth;
+		private int binHeight;
+		private final Array<Rect> usedRectangles = new Array();
+		private final Array<Rect> freeRectangles = new Array();
+
+		public void init (int width, int height) {
+			binWidth = width;
+			binHeight = height;
+
+			usedRectangles.clear();
+			freeRectangles.clear();
+			Rect n = new Rect();
+			n.x = 0;
+			n.y = 0;
+			n.width = width;
+			n.height = height;
+			freeRectangles.add(n);
+		}
+
+		/** Packs a single image. Order is defined externally. */
+		public Rect insert (Rect rect, FreeRectChoiceHeuristic method) {
+			Rect newNode = scoreRect(rect, method);
+			if (newNode.height == 0) return null;
+
+			int numRectanglesToProcess = freeRectangles.size;
+			for (int i = 0; i < numRectanglesToProcess; ++i) {
+				if (splitFreeNode(freeRectangles.get(i), newNode)) {
+					freeRectangles.removeIndex(i);
+					--i;
+					--numRectanglesToProcess;
+				}
+			}
+
+			pruneFreeList();
+
+			Rect bestNode = new Rect();
+			bestNode.set(rect);
+			bestNode.score1 = newNode.score1;
+			bestNode.score2 = newNode.score2;
+			bestNode.x = newNode.x;
+			bestNode.y = newNode.y;
+			bestNode.width = newNode.width;
+			bestNode.height = newNode.height;
+			bestNode.rotated = newNode.rotated;
+
+			usedRectangles.add(bestNode);
+			return bestNode;
+		}
+
+		/** For each rectangle, packs each one then chooses the best and packs that. Slow! */
+		public Page pack (Array<Rect> rects, FreeRectChoiceHeuristic method) {
+			rects = new Array(rects);
+			while (rects.size > 0) {
+				int bestRectIndex = -1;
+				Rect bestNode = new Rect();
+				bestNode.score1 = Integer.MAX_VALUE;
+				bestNode.score2 = Integer.MAX_VALUE;
+
+				// Find the next rectangle that packs best.
+				for (int i = 0; i < rects.size; i++) {
+					Rect newNode = scoreRect(rects.get(i), method);
+					if (newNode.score1 < bestNode.score1 || (newNode.score1 == bestNode.score1 && newNode.score2 < bestNode.score2)) {
+						bestNode.set(rects.get(i));
+						bestNode.score1 = newNode.score1;
+						bestNode.score2 = newNode.score2;
+						bestNode.x = newNode.x;
+						bestNode.y = newNode.y;
+						bestNode.width = newNode.width;
+						bestNode.height = newNode.height;
+						bestNode.rotated = newNode.rotated;
+						bestRectIndex = i;
+					}
+				}
+
+				if (bestRectIndex == -1) break;
+
+				placeRect(bestNode);
+				rects.removeIndex(bestRectIndex);
+			}
+
+			Page result = getResult();
+			result.remainingRects = rects;
+			return result;
+		}
+
+		public Page getResult () {
+			int w = 0, h = 0;
+			for (int i = 0; i < usedRectangles.size; i++) {
+				Rect rect = usedRectangles.get(i);
+				w = Math.max(w, rect.x + rect.width);
+				h = Math.max(h, rect.y + rect.height);
+			}
+			Page result = new Page();
+			result.outputRects = new Array(usedRectangles);
+			result.occupancy = getOccupancy();
+			result.width = w;
+			result.height = h;
+			return result;
+		}
+
+		private void placeRect (Rect node) {
+			int numRectanglesToProcess = freeRectangles.size;
+			for (int i = 0; i < numRectanglesToProcess; i++) {
+				if (splitFreeNode(freeRectangles.get(i), node)) {
+					freeRectangles.removeIndex(i);
+					--i;
+					--numRectanglesToProcess;
+				}
+			}
+
+			pruneFreeList();
+
+			usedRectangles.add(node);
+		}
+
+		private Rect scoreRect (Rect rect, FreeRectChoiceHeuristic method) {
+			int width = rect.width;
+			int height = rect.height;
+			int rotatedWidth = height - settings.paddingY + settings.paddingX;
+			int rotatedHeight = width - settings.paddingX + settings.paddingY;
+			boolean rotate = rect.canRotate && settings.rotation;
+
+			Rect newNode = null;
+			switch (method) {
+			case BestShortSideFit:
+				newNode = findPositionForNewNodeBestShortSideFit(width, height, rotatedWidth, rotatedHeight, rotate);
+				break;
+			case BottomLeftRule:
+				newNode = findPositionForNewNodeBottomLeft(width, height, rotatedWidth, rotatedHeight, rotate);
+				break;
+			case ContactPointRule:
+				newNode = findPositionForNewNodeContactPoint(width, height, rotatedWidth, rotatedHeight, rotate);
+				newNode.score1 = -newNode.score1; // Reverse since we are minimizing, but for contact point score bigger is better.
+				break;
+			case BestLongSideFit:
+				newNode = findPositionForNewNodeBestLongSideFit(width, height, rotatedWidth, rotatedHeight, rotate);
+				break;
+			case BestAreaFit:
+				newNode = findPositionForNewNodeBestAreaFit(width, height, rotatedWidth, rotatedHeight, rotate);
+				break;
+			}
+
+			// Cannot fit the current rectangle.
+			if (newNode.height == 0) {
+				newNode.score1 = Integer.MAX_VALUE;
+				newNode.score2 = Integer.MAX_VALUE;
+			}
+
+			return newNode;
+		}
+
+		// / Computes the ratio of used surface area.
+		private float getOccupancy () {
+			int usedSurfaceArea = 0;
+			for (int i = 0; i < usedRectangles.size; i++)
+				usedSurfaceArea += usedRectangles.get(i).width * usedRectangles.get(i).height;
+			return (float)usedSurfaceArea / (binWidth * binHeight);
+		}
+
+		private Rect findPositionForNewNodeBottomLeft (int width, int height, int rotatedWidth, int rotatedHeight, boolean rotate) {
+			Rect bestNode = new Rect();
+
+			bestNode.score1 = Integer.MAX_VALUE; // best y, score2 is best x
+
+			for (int i = 0; i < freeRectangles.size; i++) {
+				// Try to place the rectangle in upright (non-rotated) orientation.
+				if (freeRectangles.get(i).width >= width && freeRectangles.get(i).height >= height) {
+					int topSideY = freeRectangles.get(i).y + height;
+					if (topSideY < bestNode.score1 || (topSideY == bestNode.score1 && freeRectangles.get(i).x < bestNode.score2)) {
+						bestNode.x = freeRectangles.get(i).x;
+						bestNode.y = freeRectangles.get(i).y;
+						bestNode.width = width;
+						bestNode.height = height;
+						bestNode.score1 = topSideY;
+						bestNode.score2 = freeRectangles.get(i).x;
+						bestNode.rotated = false;
+					}
+				}
+				if (rotate && freeRectangles.get(i).width >= rotatedWidth && freeRectangles.get(i).height >= rotatedHeight) {
+					int topSideY = freeRectangles.get(i).y + rotatedHeight;
+					if (topSideY < bestNode.score1 || (topSideY == bestNode.score1 && freeRectangles.get(i).x < bestNode.score2)) {
+						bestNode.x = freeRectangles.get(i).x;
+						bestNode.y = freeRectangles.get(i).y;
+						bestNode.width = rotatedWidth;
+						bestNode.height = rotatedHeight;
+						bestNode.score1 = topSideY;
+						bestNode.score2 = freeRectangles.get(i).x;
+						bestNode.rotated = true;
+					}
+				}
+			}
+			return bestNode;
+		}
+
+		private Rect findPositionForNewNodeBestShortSideFit (int width, int height, int rotatedWidth, int rotatedHeight,
+			boolean rotate) {
+			Rect bestNode = new Rect();
+			bestNode.score1 = Integer.MAX_VALUE;
+
+			for (int i = 0; i < freeRectangles.size; i++) {
+				// Try to place the rectangle in upright (non-rotated) orientation.
+				if (freeRectangles.get(i).width >= width && freeRectangles.get(i).height >= height) {
+					int leftoverHoriz = Math.abs(freeRectangles.get(i).width - width);
+					int leftoverVert = Math.abs(freeRectangles.get(i).height - height);
+					int shortSideFit = Math.min(leftoverHoriz, leftoverVert);
+					int longSideFit = Math.max(leftoverHoriz, leftoverVert);
+
+					if (shortSideFit < bestNode.score1 || (shortSideFit == bestNode.score1 && longSideFit < bestNode.score2)) {
+						bestNode.x = freeRectangles.get(i).x;
+						bestNode.y = freeRectangles.get(i).y;
+						bestNode.width = width;
+						bestNode.height = height;
+						bestNode.score1 = shortSideFit;
+						bestNode.score2 = longSideFit;
+						bestNode.rotated = false;
+					}
+				}
+
+				if (rotate && freeRectangles.get(i).width >= rotatedWidth && freeRectangles.get(i).height >= rotatedHeight) {
+					int flippedLeftoverHoriz = Math.abs(freeRectangles.get(i).width - rotatedWidth);
+					int flippedLeftoverVert = Math.abs(freeRectangles.get(i).height - rotatedHeight);
+					int flippedShortSideFit = Math.min(flippedLeftoverHoriz, flippedLeftoverVert);
+					int flippedLongSideFit = Math.max(flippedLeftoverHoriz, flippedLeftoverVert);
+
+					if (flippedShortSideFit < bestNode.score1
+						|| (flippedShortSideFit == bestNode.score1 && flippedLongSideFit < bestNode.score2)) {
+						bestNode.x = freeRectangles.get(i).x;
+						bestNode.y = freeRectangles.get(i).y;
+						bestNode.width = rotatedWidth;
+						bestNode.height = rotatedHeight;
+						bestNode.score1 = flippedShortSideFit;
+						bestNode.score2 = flippedLongSideFit;
+						bestNode.rotated = true;
+					}
+				}
+			}
+
+			return bestNode;
+		}
+
+		private Rect findPositionForNewNodeBestLongSideFit (int width, int height, int rotatedWidth, int rotatedHeight,
+			boolean rotate) {
+			Rect bestNode = new Rect();
+
+			bestNode.score2 = Integer.MAX_VALUE;
+
+			for (int i = 0; i < freeRectangles.size; i++) {
+				// Try to place the rectangle in upright (non-rotated) orientation.
+				if (freeRectangles.get(i).width >= width && freeRectangles.get(i).height >= height) {
+					int leftoverHoriz = Math.abs(freeRectangles.get(i).width - width);
+					int leftoverVert = Math.abs(freeRectangles.get(i).height - height);
+					int shortSideFit = Math.min(leftoverHoriz, leftoverVert);
+					int longSideFit = Math.max(leftoverHoriz, leftoverVert);
+
+					if (longSideFit < bestNode.score2 || (longSideFit == bestNode.score2 && shortSideFit < bestNode.score1)) {
+						bestNode.x = freeRectangles.get(i).x;
+						bestNode.y = freeRectangles.get(i).y;
+						bestNode.width = width;
+						bestNode.height = height;
+						bestNode.score1 = shortSideFit;
+						bestNode.score2 = longSideFit;
+						bestNode.rotated = false;
+					}
+				}
+
+				if (rotate && freeRectangles.get(i).width >= rotatedWidth && freeRectangles.get(i).height >= rotatedHeight) {
+					int leftoverHoriz = Math.abs(freeRectangles.get(i).width - rotatedWidth);
+					int leftoverVert = Math.abs(freeRectangles.get(i).height - rotatedHeight);
+					int shortSideFit = Math.min(leftoverHoriz, leftoverVert);
+					int longSideFit = Math.max(leftoverHoriz, leftoverVert);
+
+					if (longSideFit < bestNode.score2 || (longSideFit == bestNode.score2 && shortSideFit < bestNode.score1)) {
+						bestNode.x = freeRectangles.get(i).x;
+						bestNode.y = freeRectangles.get(i).y;
+						bestNode.width = rotatedWidth;
+						bestNode.height = rotatedHeight;
+						bestNode.score1 = shortSideFit;
+						bestNode.score2 = longSideFit;
+						bestNode.rotated = true;
+					}
+				}
+			}
+			return bestNode;
+		}
+
+		private Rect findPositionForNewNodeBestAreaFit (int width, int height, int rotatedWidth, int rotatedHeight, boolean rotate) {
+			Rect bestNode = new Rect();
+
+			bestNode.score1 = Integer.MAX_VALUE; // best area fit, score2 is best short side fit
+
+			for (int i = 0; i < freeRectangles.size; i++) {
+				int areaFit = freeRectangles.get(i).width * freeRectangles.get(i).height - width * height;
+
+				// Try to place the rectangle in upright (non-rotated) orientation.
+				if (freeRectangles.get(i).width >= width && freeRectangles.get(i).height >= height) {
+					int leftoverHoriz = Math.abs(freeRectangles.get(i).width - width);
+					int leftoverVert = Math.abs(freeRectangles.get(i).height - height);
+					int shortSideFit = Math.min(leftoverHoriz, leftoverVert);
+
+					if (areaFit < bestNode.score1 || (areaFit == bestNode.score1 && shortSideFit < bestNode.score2)) {
+						bestNode.x = freeRectangles.get(i).x;
+						bestNode.y = freeRectangles.get(i).y;
+						bestNode.width = width;
+						bestNode.height = height;
+						bestNode.score2 = shortSideFit;
+						bestNode.score1 = areaFit;
+						bestNode.rotated = false;
+					}
+				}
+
+				if (rotate && freeRectangles.get(i).width >= rotatedWidth && freeRectangles.get(i).height >= rotatedHeight) {
+					int leftoverHoriz = Math.abs(freeRectangles.get(i).width - rotatedWidth);
+					int leftoverVert = Math.abs(freeRectangles.get(i).height - rotatedHeight);
+					int shortSideFit = Math.min(leftoverHoriz, leftoverVert);
+
+					if (areaFit < bestNode.score1 || (areaFit == bestNode.score1 && shortSideFit < bestNode.score2)) {
+						bestNode.x = freeRectangles.get(i).x;
+						bestNode.y = freeRectangles.get(i).y;
+						bestNode.width = rotatedWidth;
+						bestNode.height = rotatedHeight;
+						bestNode.score2 = shortSideFit;
+						bestNode.score1 = areaFit;
+						bestNode.rotated = true;
+					}
+				}
+			}
+			return bestNode;
+		}
+
+		// / Returns 0 if the two intervals i1 and i2 are disjoint, or the length of their overlap otherwise.
+		private int commonIntervalLength (int i1start, int i1end, int i2start, int i2end) {
+			if (i1end < i2start || i2end < i1start) return 0;
+			return Math.min(i1end, i2end) - Math.max(i1start, i2start);
+		}
+
+		private int contactPointScoreNode (int x, int y, int width, int height) {
+			int score = 0;
+
+			if (x == 0 || x + width == binWidth) score += height;
+			if (y == 0 || y + height == binHeight) score += width;
+
+			for (int i = 0; i < usedRectangles.size; i++) {
+				if (usedRectangles.get(i).x == x + width || usedRectangles.get(i).x + usedRectangles.get(i).width == x)
+					score += commonIntervalLength(usedRectangles.get(i).y, usedRectangles.get(i).y + usedRectangles.get(i).height, y,
+						y + height);
+				if (usedRectangles.get(i).y == y + height || usedRectangles.get(i).y + usedRectangles.get(i).height == y)
+					score += commonIntervalLength(usedRectangles.get(i).x, usedRectangles.get(i).x + usedRectangles.get(i).width, x, x
+						+ width);
+			}
+			return score;
+		}
+
+		private Rect findPositionForNewNodeContactPoint (int width, int height, int rotatedWidth, int rotatedHeight, boolean rotate) {
+			Rect bestNode = new Rect();
+
+			bestNode.score1 = -1; // best contact score
+
+			for (int i = 0; i < freeRectangles.size; i++) {
+				// Try to place the rectangle in upright (non-rotated) orientation.
+				if (freeRectangles.get(i).width >= width && freeRectangles.get(i).height >= height) {
+					int score = contactPointScoreNode(freeRectangles.get(i).x, freeRectangles.get(i).y, width, height);
+					if (score > bestNode.score1) {
+						bestNode.x = freeRectangles.get(i).x;
+						bestNode.y = freeRectangles.get(i).y;
+						bestNode.width = width;
+						bestNode.height = height;
+						bestNode.score1 = score;
+						bestNode.rotated = false;
+					}
+				}
+				if (rotate && freeRectangles.get(i).width >= rotatedWidth && freeRectangles.get(i).height >= rotatedHeight) {
+					// This was width,height -- bug fixed?
+					int score = contactPointScoreNode(freeRectangles.get(i).x, freeRectangles.get(i).y, rotatedWidth, rotatedHeight);
+					if (score > bestNode.score1) {
+						bestNode.x = freeRectangles.get(i).x;
+						bestNode.y = freeRectangles.get(i).y;
+						bestNode.width = rotatedWidth;
+						bestNode.height = rotatedHeight;
+						bestNode.score1 = score;
+						bestNode.rotated = true;
+					}
+				}
+			}
+			return bestNode;
+		}
+
+		private boolean splitFreeNode (Rect freeNode, Rect usedNode) {
+			// Test with SAT if the rectangles even intersect.
+			if (usedNode.x >= freeNode.x + freeNode.width || usedNode.x + usedNode.width <= freeNode.x
+				|| usedNode.y >= freeNode.y + freeNode.height || usedNode.y + usedNode.height <= freeNode.y) return false;
+
+			if (usedNode.x < freeNode.x + freeNode.width && usedNode.x + usedNode.width > freeNode.x) {
+				// New node at the top side of the used node.
+				if (usedNode.y > freeNode.y && usedNode.y < freeNode.y + freeNode.height) {
+					Rect newNode = new Rect(freeNode);
+					newNode.height = usedNode.y - newNode.y;
+					freeRectangles.add(newNode);
+				}
+
+				// New node at the bottom side of the used node.
+				if (usedNode.y + usedNode.height < freeNode.y + freeNode.height) {
+					Rect newNode = new Rect(freeNode);
+					newNode.y = usedNode.y + usedNode.height;
+					newNode.height = freeNode.y + freeNode.height - (usedNode.y + usedNode.height);
+					freeRectangles.add(newNode);
+				}
+			}
+
+			if (usedNode.y < freeNode.y + freeNode.height && usedNode.y + usedNode.height > freeNode.y) {
+				// New node at the left side of the used node.
+				if (usedNode.x > freeNode.x && usedNode.x < freeNode.x + freeNode.width) {
+					Rect newNode = new Rect(freeNode);
+					newNode.width = usedNode.x - newNode.x;
+					freeRectangles.add(newNode);
+				}
+
+				// New node at the right side of the used node.
+				if (usedNode.x + usedNode.width < freeNode.x + freeNode.width) {
+					Rect newNode = new Rect(freeNode);
+					newNode.x = usedNode.x + usedNode.width;
+					newNode.width = freeNode.x + freeNode.width - (usedNode.x + usedNode.width);
+					freeRectangles.add(newNode);
+				}
+			}
+
+			return true;
+		}
+
+		private void pruneFreeList () {
+			/*
+			 * /// Would be nice to do something like this, to avoid a Theta(n^2) loop through each pair. /// But unfortunately it
+			 * doesn't quite cut it, since we also want to detect containment. /// Perhaps there's another way to do this faster than
+			 * Theta(n^2).
+			 * 
+			 * if (freeRectangles.size > 0) clb::sort::QuickSort(&freeRectangles[0], freeRectangles.size, NodeSortCmp);
+			 * 
+			 * for(int i = 0; i < freeRectangles.size-1; i++) if (freeRectangles[i].x == freeRectangles[i+1].x && freeRectangles[i].y
+			 * == freeRectangles[i+1].y && freeRectangles[i].width == freeRectangles[i+1].width && freeRectangles[i].height ==
+			 * freeRectangles[i+1].height) { freeRectangles.erase(freeRectangles.begin() + i); --i; }
+			 */
+
+			// / Go through each pair and remove any rectangle that is redundant.
+			for (int i = 0; i < freeRectangles.size; i++)
+				for (int j = i + 1; j < freeRectangles.size; ++j) {
+					if (isContainedIn(freeRectangles.get(i), freeRectangles.get(j))) {
+						freeRectangles.removeIndex(i);
+						--i;
+						break;
+					}
+					if (isContainedIn(freeRectangles.get(j), freeRectangles.get(i))) {
+						freeRectangles.removeIndex(j);
+						--j;
+					}
+				}
+		}
+
+		private boolean isContainedIn (Rect a, Rect b) {
+			return a.x >= b.x && a.y >= b.y && a.x + a.width <= b.x + b.width && a.y + a.height <= b.y + b.height;
+		}
+	}
+
+	static public enum FreeRectChoiceHeuristic {
+		// BSSF: Positions the rectangle against the short side of a free rectangle into which it fits the best.
+		BestShortSideFit,
+		// BLSF: Positions the rectangle against the long side of a free rectangle into which it fits the best.
+		BestLongSideFit,
+		// BAF: Positions the rectangle into the smallest free rect into which it fits.
+		BestAreaFit,
+		// BL: Does the Tetris placement.
+		BottomLeftRule,
+		// CP: Choosest the placement where the rectangle touches other rects as much as possible.
+		ContactPointRule
+	};
+
+	class RectComparator implements Comparator<Rect> {
+		public int compare (Rect o1, Rect o2) {
+			return Rect.getAtlasName(o1.name, settings.flattenPaths).compareTo(Rect.getAtlasName(o2.name, settings.flattenPaths));
+		}
+	}
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/TexturePacker.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/TexturePacker.java
index 14d0b50..3120da2 100644
--- a/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/TexturePacker.java
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/TexturePacker.java
@@ -1,660 +1,668 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.tools.texturepacker;
-
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.Pixmap.Format;
-import com.badlogic.gdx.graphics.Texture.TextureFilter;
-import com.badlogic.gdx.graphics.Texture.TextureWrap;
-import com.badlogic.gdx.graphics.g2d.TextureAtlas.TextureAtlasData;
-import com.badlogic.gdx.graphics.g2d.TextureAtlas.TextureAtlasData.Region;
-import com.badlogic.gdx.math.MathUtils;
-import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-
-import java.awt.Color;
-import java.awt.Graphics2D;
-import java.awt.image.BufferedImage;
-import java.io.File;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.util.Comparator;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Set;
-
-import javax.imageio.IIOImage;
-import javax.imageio.ImageIO;
-import javax.imageio.ImageWriteParam;
-import javax.imageio.ImageWriter;
-import javax.imageio.stream.ImageOutputStream;
-
-/** @author Nathan Sweet */
-public class TexturePacker {
-	private final Settings settings;
-	private final Packer packer;
-	private final ImageProcessor imageProcessor;
-	private final Array<InputImage> inputImages = new Array();
-	private File rootDir;
-
-	/** @param rootDir Used to strip the root directory prefix from image file names, can be null. */
-	public TexturePacker (File rootDir, Settings settings) {
-		this.rootDir = rootDir;
-		this.settings = settings;
-
-		if (settings.pot) {
-			if (settings.maxWidth != MathUtils.nextPowerOfTwo(settings.maxWidth))
-				throw new RuntimeException("If pot is true, maxWidth must be a power of two: " + settings.maxWidth);
-			if (settings.maxHeight != MathUtils.nextPowerOfTwo(settings.maxHeight))
-				throw new RuntimeException("If pot is true, maxHeight must be a power of two: " + settings.maxHeight);
-		}
-
-		if (settings.grid)
-			packer = new GridPacker(settings);
-		else
-			packer = new MaxRectsPacker(settings);
-		imageProcessor = new ImageProcessor(rootDir, settings);
-	}
-
-	public TexturePacker (Settings settings) {
-		this(null, settings);
-	}
-
-	public void addImage (File file) {
-		InputImage inputImage = new InputImage();
-		inputImage.file = file;
-		inputImages.add(inputImage);
-	}
-
-	public void addImage (BufferedImage image, String name) {
-		InputImage inputImage = new InputImage();
-		inputImage.image = image;
-		inputImage.name = name;
-		inputImages.add(inputImage);
-	}
-
-	public void pack (File outputDir, String packFileName) {
-		outputDir.mkdirs();
-
-		if (packFileName.indexOf('.') == -1 || packFileName.endsWith(".png") || packFileName.endsWith(".jpg"))
-			packFileName += ".atlas";
-
-		for (float scale : settings.scale) {
-			String scaledPackFileName = packFileName;
-			if (scale != 1 || settings.scale.length != 1) {
-				FileHandle file = new FileHandle(scaledPackFileName);
-				String suffix = scale == (int)scale ? Integer.toString((int)scale) : Float.toString(scale);
-				scaledPackFileName = file.nameWithoutExtension() + suffix + "." + file.extension();
-			}
-
-			imageProcessor.setScale(scale);
-			for (InputImage inputImage : inputImages) {
-				if (inputImage.file != null)
-					imageProcessor.addImage(inputImage.file);
-				else
-					imageProcessor.addImage(inputImage.image, inputImage.name);
-			}
-
-			Array<Page> pages = packer.pack(imageProcessor.getImages());
-			writeImages(outputDir, pages, scaledPackFileName);
-			try {
-				writePackFile(outputDir, pages, scaledPackFileName);
-			} catch (IOException ex) {
-				throw new RuntimeException("Error writing pack file.", ex);
-			}
-			imageProcessor.clear();
-		}
-	}
-
-	private void writeImages (File outputDir, Array<Page> pages, String packFileName) {
-		String imageName = packFileName;
-		int dotIndex = imageName.lastIndexOf('.');
-		if (dotIndex != -1) imageName = imageName.substring(0, dotIndex);
-
-		int fileIndex = 0;
-		for (Page page : pages) {
-			int width = page.width, height = page.height;
-			int paddingX = settings.paddingX;
-			int paddingY = settings.paddingY;
-			if (settings.duplicatePadding) {
-				paddingX /= 2;
-				paddingY /= 2;
-			}
-			width -= settings.paddingX;
-			height -= settings.paddingY;
-			if (settings.edgePadding) {
-				page.x = paddingX;
-				page.y = paddingY;
-				width += paddingX * 2;
-				height += paddingY * 2;
-			}
-			if (settings.pot) {
-				width = MathUtils.nextPowerOfTwo(width);
-				height = MathUtils.nextPowerOfTwo(height);
-			}
-			width = Math.max(settings.minWidth, width);
-			height = Math.max(settings.minHeight, height);
-
-			File outputFile;
-			while (true) {
-				fileIndex++;
-				outputFile = new File(outputDir, imageName + "-" + fileIndex + "." + settings.outputFormat);
-				if (!outputFile.exists()) break;
-			}
-			page.imageName = outputFile.getName();
-
-			BufferedImage canvas = new BufferedImage(width, height, getBufferedImageType(settings.format));
-			Graphics2D g = (Graphics2D)canvas.getGraphics();
-
-			System.out.println("Writing " + canvas.getWidth() + "x" + canvas.getHeight() + ": " + outputFile);
-
-			for (Rect rect : page.outputRects) {
-				BufferedImage image = rect.getImage(imageProcessor);
-				int iw = image.getWidth();
-				int ih = image.getHeight();
-				int rectX = page.x + rect.x, rectY = page.y + page.height - rect.y - rect.height;
-				if (settings.duplicatePadding) {
-					int amountX = settings.paddingX / 2;
-					int amountY = settings.paddingY / 2;
-					if (rect.rotated) {
-						// Copy corner pixels to fill corners of the padding.
-						for (int i = 1; i <= amountX; i++) {
-							for (int j = 1; j <= amountY; j++) {
-								plot(canvas, rectX - j, rectY + iw - 1 + i, image.getRGB(0, 0));
-								plot(canvas, rectX + ih - 1 + j, rectY + iw - 1 + i, image.getRGB(0, ih - 1));
-								plot(canvas, rectX - j, rectY - i, image.getRGB(iw - 1, 0));
-								plot(canvas, rectX + ih - 1 + j, rectY - i, image.getRGB(iw - 1, ih - 1));
-							}
-						}
-						// Copy edge pixels into padding.
-						for (int i = 1; i <= amountY; i++) {
-							for (int j = 0; j < iw; j++) {
-								plot(canvas, rectX - i, rectY + iw - 1 - j, image.getRGB(j, 0));
-								plot(canvas, rectX + ih - 1 + i, rectY + iw - 1 - j, image.getRGB(j, ih - 1));
-							}
-						}
-						for (int i = 1; i <= amountX; i++) {
-							for (int j = 0; j < ih; j++) {
-								plot(canvas, rectX + j, rectY - i, image.getRGB(iw - 1, j));
-								plot(canvas, rectX + j, rectY + iw - 1 + i, image.getRGB(0, j));
-							}
-						}
-					} else {
-						// Copy corner pixels to fill corners of the padding.
-						for (int i = 1; i <= amountX; i++) {
-							for (int j = 1; j <= amountY; j++) {
-								canvas.setRGB(rectX - i, rectY - j, image.getRGB(0, 0));
-								canvas.setRGB(rectX - i, rectY + ih - 1 + j, image.getRGB(0, ih - 1));
-								canvas.setRGB(rectX + iw - 1 + i, rectY - j, image.getRGB(iw - 1, 0));
-								canvas.setRGB(rectX + iw - 1 + i, rectY + ih - 1 + j, image.getRGB(iw - 1, ih - 1));
-							}
-						}
-						// Copy edge pixels into padding.
-						for (int i = 1; i <= amountY; i++) {
-							copy(image, 0, 0, iw, 1, canvas, rectX, rectY - i, rect.rotated);
-							copy(image, 0, ih - 1, iw, 1, canvas, rectX, rectY + ih - 1 + i, rect.rotated);
-						}
-						for (int i = 1; i <= amountX; i++) {
-							copy(image, 0, 0, 1, ih, canvas, rectX - i, rectY, rect.rotated);
-							copy(image, iw - 1, 0, 1, ih, canvas, rectX + iw - 1 + i, rectY, rect.rotated);
-						}
-					}
-				}
-				copy(image, 0, 0, iw, ih, canvas, rectX, rectY, rect.rotated);
-				if (settings.debug) {
-					g.setColor(Color.magenta);
-					g.drawRect(rectX, rectY, rect.width - settings.paddingX - 1, rect.height - settings.paddingY - 1);
-				}
-			}
-
-			if (settings.bleed && !settings.premultiplyAlpha && !settings.outputFormat.equalsIgnoreCase("jpg")) {
-				canvas = new ColorBleedEffect().processImage(canvas, 2);
-				g = (Graphics2D)canvas.getGraphics();
-			}
-
-			if (settings.debug) {
-				g.setColor(Color.magenta);
-				g.drawRect(0, 0, width - 1, height - 1);
-			}
-
-			ImageOutputStream ios = null;
-			try {
-				if (settings.outputFormat.equalsIgnoreCase("jpg")) {
-					BufferedImage newImage = new BufferedImage(canvas.getWidth(), canvas.getHeight(), BufferedImage.TYPE_3BYTE_BGR);
-					newImage.getGraphics().drawImage(canvas, 0, 0, null);
-					canvas = newImage;
-
-					Iterator<ImageWriter> writers = ImageIO.getImageWritersByFormatName("jpg");
-					ImageWriter writer = writers.next();
-					ImageWriteParam param = writer.getDefaultWriteParam();
-					param.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);
-					param.setCompressionQuality(settings.jpegQuality);
-					ios = ImageIO.createImageOutputStream(outputFile);
-					writer.setOutput(ios);
-					writer.write(null, new IIOImage(canvas, null, null), param);
-				} else {
-					if (settings.premultiplyAlpha) canvas.getColorModel().coerceData(canvas.getRaster(), true);
-					ImageIO.write(canvas, "png", outputFile);
-				}
-			} catch (IOException ex) {
-				throw new RuntimeException("Error writing file: " + outputFile, ex);
-			} finally {
-				if (ios != null) {
-					try {
-						ios.close();
-					} catch (Exception ignored) {
-					}
-				}
-			}
-		}
-	}
-
-	static private void plot (BufferedImage dst, int x, int y, int argb) {
-		if (0 <= x && x < dst.getWidth() && 0 <= y && y < dst.getHeight()) dst.setRGB(x, y, argb);
-	}
-
-	static private void copy (BufferedImage src, int x, int y, int w, int h, BufferedImage dst, int dx, int dy, boolean rotated) {
-		if (rotated) {
-			for (int i = 0; i < w; i++)
-				for (int j = 0; j < h; j++)
-					dst.setRGB(dx + j, dy + w - i - 1, src.getRGB(x + i, y + j));
-		} else {
-			for (int i = 0; i < w; i++)
-				for (int j = 0; j < h; j++)
-					dst.setRGB(dx + i, dy + j, src.getRGB(x + i, y + j));
-		}
-	}
-
-	private void writePackFile (File outputDir, Array<Page> pages, String packFileName) throws IOException {
-		File packFile = new File(outputDir, packFileName);
-
-		if (packFile.exists()) {
-			// Make sure there aren't duplicate names.
-			TextureAtlasData textureAtlasData = new TextureAtlasData(new FileHandle(packFile), new FileHandle(packFile), false);
-			for (Page page : pages) {
-				for (Rect rect : page.outputRects) {
-					String rectName = Rect.getAtlasName(rect.name, settings.flattenPaths);
-					for (Region region : textureAtlasData.getRegions()) {
-						if (region.name.equals(rectName)) {
-							throw new GdxRuntimeException("A region with the name \"" + rectName + "\" has already been packed: "
-								+ rect.name);
-						}
-					}
-				}
-			}
-		}
-
-		FileWriter writer = new FileWriter(packFile, true);
-		for (Page page : pages) {
-			writer.write("\n" + page.imageName + "\n");
-			writer.write("format: " + settings.format + "\n");
-			writer.write("filter: " + settings.filterMin + "," + settings.filterMag + "\n");
-			writer.write("repeat: " + getRepeatValue() + "\n");
-
-			for (Rect rect : page.outputRects) {
-				writeRect(writer, page, rect, rect.name);
-				for (Alias alias : rect.aliases) {
-					Rect aliasRect = new Rect();
-					aliasRect.set(rect);
-					alias.apply(aliasRect);
-					writeRect(writer, page, aliasRect, alias.name);
-				}
-			}
-		}
-		writer.close();
-	}
-
-	private void writeRect (FileWriter writer, Page page, Rect rect, String name) throws IOException {
-		writer.write(Rect.getAtlasName(name, settings.flattenPaths) + "\n");
-		writer.write("  rotate: " + rect.rotated + "\n");
-		writer.write("  xy: " + (page.x + rect.x) + ", " + (page.y + page.height - rect.height - rect.y) + "\n");
-
-		writer.write("  size: " + rect.regionWidth + ", " + rect.regionHeight + "\n");
-		if (rect.splits != null) {
-			writer.write("  split: " //
-				+ rect.splits[0] + ", " + rect.splits[1] + ", " + rect.splits[2] + ", " + rect.splits[3] + "\n");
-		}
-		if (rect.pads != null) {
-			if (rect.splits == null) writer.write("  split: 0, 0, 0, 0\n");
-			writer.write("  pad: " + rect.pads[0] + ", " + rect.pads[1] + ", " + rect.pads[2] + ", " + rect.pads[3] + "\n");
-		}
-		writer.write("  orig: " + rect.originalWidth + ", " + rect.originalHeight + "\n");
-		writer.write("  offset: " + rect.offsetX + ", " + (rect.originalHeight - rect.regionHeight - rect.offsetY) + "\n");
-		writer.write("  index: " + rect.index + "\n");
-	}
-
-	private String getRepeatValue () {
-		if (settings.wrapX == TextureWrap.Repeat && settings.wrapY == TextureWrap.Repeat) return "xy";
-		if (settings.wrapX == TextureWrap.Repeat && settings.wrapY == TextureWrap.ClampToEdge) return "x";
-		if (settings.wrapX == TextureWrap.ClampToEdge && settings.wrapY == TextureWrap.Repeat) return "y";
-		return "none";
-	}
-
-	private int getBufferedImageType (Format format) {
-		switch (settings.format) {
-		case RGBA8888:
-		case RGBA4444:
-			return BufferedImage.TYPE_INT_ARGB;
-		case RGB565:
-		case RGB888:
-			return BufferedImage.TYPE_INT_RGB;
-		case Alpha:
-			return BufferedImage.TYPE_BYTE_GRAY;
-		default:
-			throw new RuntimeException("Unsupported format: " + settings.format);
-		}
-	}
-
-	/** @author Nathan Sweet */
-	static public class Page {
-		public String imageName;
-		public Array<Rect> outputRects, remainingRects;
-		public float occupancy;
-		public int x, y, width, height;
-	}
-
-	/** @author Regnarock
-	 * @author Nathan Sweet */
-	static public class Alias {
-		public String name;
-		public int index;
-		public int[] splits;
-		public int[] pads;
-		public int offsetX, offsetY, originalWidth, originalHeight;
-
-		public Alias (Rect rect) {
-			name = rect.name;
-			index = rect.index;
-			splits = rect.splits;
-			pads = rect.pads;
-			offsetX = rect.offsetX;
-			offsetY = rect.offsetY;
-			originalWidth = rect.originalWidth;
-			originalHeight = rect.originalHeight;
-		}
-
-		public void apply (Rect rect) {
-			rect.name = name;
-			rect.index = index;
-			rect.splits = splits;
-			rect.pads = pads;
-			rect.offsetX = offsetX;
-			rect.offsetY = offsetY;
-			rect.originalWidth = originalWidth;
-			rect.originalHeight = originalHeight;
-		}
-	}
-
-	/** @author Nathan Sweet */
-	static public class Rect {
-		public String name;
-		public int offsetX, offsetY, regionWidth, regionHeight, originalWidth, originalHeight;
-		public int x, y;
-		public int width, height; // Portion of page taken by this region, including padding.
-		public int index;
-		public boolean rotated;
-		public Set<Alias> aliases = new HashSet<Alias>();
-		public int[] splits;
-		public int[] pads;
-		public boolean canRotate = true;
-
-		private boolean isPatch;
-		private BufferedImage image;
-		private File file;
-		int score1, score2;
-
-		Rect (BufferedImage source, int left, int top, int newWidth, int newHeight, boolean isPatch) {
-			image = new BufferedImage(source.getColorModel(), source.getRaster().createWritableChild(left, top, newWidth, newHeight,
-				0, 0, null), source.getColorModel().isAlphaPremultiplied(), null);
-			offsetX = left;
-			offsetY = top;
-			regionWidth = newWidth;
-			regionHeight = newHeight;
-			originalWidth = source.getWidth();
-			originalHeight = source.getHeight();
-			width = newWidth;
-			height = newHeight;
-			this.isPatch = isPatch;
-		}
-
-		/** Clears the image for this rect, which will be loaded from the specified file by {@link #getImage(ImageProcessor)}. */
-		public void unloadImage (File file) {
-			this.file = file;
-			image = null;
-		}
-
-		public BufferedImage getImage (ImageProcessor imageProcessor) {
-			if (image != null) return image;
-
-			BufferedImage image;
-			try {
-				image = ImageIO.read(file);
-			} catch (IOException ex) {
-				throw new RuntimeException("Error reading image: " + file, ex);
-			}
-			if (image == null) throw new RuntimeException("Unable to read image: " + file);
-			String name = this.name;
-			if (isPatch) name += ".9";
-			return imageProcessor.processImage(image, name).getImage(null);
-		}
-
-		Rect () {
-		}
-
-		Rect (Rect rect) {
-			x = rect.x;
-			y = rect.y;
-			width = rect.width;
-			height = rect.height;
-		}
-
-		void set (Rect rect) {
-			name = rect.name;
-			image = rect.image;
-			offsetX = rect.offsetX;
-			offsetY = rect.offsetY;
-			regionWidth = rect.regionWidth;
-			regionHeight = rect.regionHeight;
-			originalWidth = rect.originalWidth;
-			originalHeight = rect.originalHeight;
-			x = rect.x;
-			y = rect.y;
-			width = rect.width;
-			height = rect.height;
-			index = rect.index;
-			rotated = rect.rotated;
-			aliases = rect.aliases;
-			splits = rect.splits;
-			pads = rect.pads;
-			canRotate = rect.canRotate;
-			score1 = rect.score1;
-			score2 = rect.score2;
-			file = rect.file;
-			isPatch = rect.isPatch;
-		}
-
-		@Override
-		public boolean equals (Object obj) {
-			if (this == obj) return true;
-			if (obj == null) return false;
-			if (getClass() != obj.getClass()) return false;
-			Rect other = (Rect)obj;
-			if (name == null) {
-				if (other.name != null) return false;
-			} else if (!name.equals(other.name)) return false;
-			return true;
-		}
-
-		@Override
-		public String toString () {
-			return name + "[" + x + "," + y + " " + width + "x" + height + "]";
-		}
-
-		static public String getAtlasName (String name, boolean flattenPaths) {
-			return flattenPaths ? new FileHandle(name).name() : name;
-		}
-	}
-
-	/** @author Nathan Sweet */
-	static public class Settings {
-		public boolean pot = true;
-		public int paddingX = 2, paddingY = 2;
-		public boolean edgePadding = true;
-		public boolean duplicatePadding = false;
-		public boolean rotation;
-		public int minWidth = 16, minHeight = 16;
-		public int maxWidth = 1024, maxHeight = 1024;
-		public boolean square = false;
-		public boolean stripWhitespaceX, stripWhitespaceY;
-		public int alphaThreshold;
-		public TextureFilter filterMin = TextureFilter.Nearest, filterMag = TextureFilter.Nearest;
-		public TextureWrap wrapX = TextureWrap.ClampToEdge, wrapY = TextureWrap.ClampToEdge;
-		public Format format = Format.RGBA8888;
-		public boolean alias = true;
-		public String outputFormat = "png";
-		public float jpegQuality = 0.9f;
-		public boolean ignoreBlankImages = true;
-		public boolean fast;
-		public boolean debug;
-		public boolean combineSubdirectories;
-		public boolean flattenPaths;
-		public boolean premultiplyAlpha;
-		public boolean useIndexes = true;
-		public boolean bleed = true;
-		public boolean limitMemory = true;
-		public boolean grid;
-		public float[] scale = {1};
-
-		public Settings () {
-		}
-
-		public Settings (Settings settings) {
-			fast = settings.fast;
-			rotation = settings.rotation;
-			pot = settings.pot;
-			minWidth = settings.minWidth;
-			minHeight = settings.minHeight;
-			maxWidth = settings.maxWidth;
-			maxHeight = settings.maxHeight;
-			paddingX = settings.paddingX;
-			paddingY = settings.paddingY;
-			edgePadding = settings.edgePadding;
-			duplicatePadding = settings.duplicatePadding;
-			alphaThreshold = settings.alphaThreshold;
-			ignoreBlankImages = settings.ignoreBlankImages;
-			stripWhitespaceX = settings.stripWhitespaceX;
-			stripWhitespaceY = settings.stripWhitespaceY;
-			alias = settings.alias;
-			format = settings.format;
-			jpegQuality = settings.jpegQuality;
-			outputFormat = settings.outputFormat;
-			filterMin = settings.filterMin;
-			filterMag = settings.filterMag;
-			wrapX = settings.wrapX;
-			wrapY = settings.wrapY;
-			debug = settings.debug;
-			combineSubdirectories = settings.combineSubdirectories;
-			flattenPaths = settings.flattenPaths;
-			premultiplyAlpha = settings.premultiplyAlpha;
-			square = settings.square;
-			useIndexes = settings.useIndexes;
-			bleed = settings.bleed;
-			limitMemory = settings.limitMemory;
-			scale = settings.scale;
-		}
-	}
-
-	/** Packs using defaults settings.
-	 * @see TexturePacker#process(Settings, String, String, String) */
-	static public void process (String input, String output, String packFileName) {
-		process(new Settings(), input, output, packFileName);
-	}
-
-	/** @param input Directory containing individual images to be packed.
-	 * @param output Directory where the pack file and page images will be written.
-	 * @param packFileName The name of the pack file. Also used to name the page images. */
-	static public void process (Settings settings, String input, String output, String packFileName) {
-		try {
-			TexturePackerFileProcessor processor = new TexturePackerFileProcessor(settings, packFileName);
-			// Sort input files by name to avoid platform-dependent atlas output changes.
-			processor.setComparator(new Comparator<File>() {
-				public int compare (File file1, File file2) {
-					return file1.getName().compareTo(file2.getName());
-				}
-			});
-			processor.process(new File(input), new File(output));
-		} catch (Exception ex) {
-			throw new RuntimeException("Error packing files.", ex);
-		}
-	}
-
-	/** @return true if the output file does not yet exist or its last modification date is before the last modification date of the
-	 *         input file */
-	static public boolean isModified (String input, String output, String packFileName) {
-		String packFullFileName = output;
-		if (!packFullFileName.endsWith("/")) packFullFileName += "/";
-		packFullFileName += packFileName;
-		File outputFile = new File(packFullFileName);
-		if (!outputFile.exists()) return true;
-
-		File inputFile = new File(input);
-		if (!inputFile.exists()) throw new IllegalArgumentException("Input file does not exist: " + inputFile.getAbsolutePath());
-		return inputFile.lastModified() > outputFile.lastModified();
-	}
-
-	static public void processIfModified (String input, String output, String packFileName) {
-		if (isModified(input, output, packFileName)) process(input, output, packFileName);
-	}
-
-	static public void processIfModified (Settings settings, String input, String output, String packFileName) {
-		if (isModified(input, output, packFileName)) process(settings, input, output, packFileName);
-	}
-
-	static public interface Packer {
-		public Array<Page> pack (Array<Rect> inputRects);
-	}
-
-	static final class InputImage {
-		File file;
-		String name;
-		BufferedImage image;
-	}
-
-	static public void main (String[] args) throws Exception {
-		String input = null, output = null, packFileName = "pack.atlas";
-
-		switch (args.length) {
-		case 3:
-			packFileName = args[2];
-		case 2:
-			output = args[1];
-		case 1:
-			input = args[0];
-			break;
-		default:
-			System.out.println("Usage: inputDir [outputDir] [packFileName]");
-			System.exit(0);
-		}
-
-		if (output == null) {
-			File inputFile = new File(input);
-			output = new File(inputFile.getParentFile(), inputFile.getName() + "-packed").getAbsolutePath();
-		}
-
-		process(input, output, packFileName);
-	}
-}
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.tools.texturepacker;
+
+import com.badlogic.gdx.files.FileHandle;
+import com.badlogic.gdx.graphics.Pixmap.Format;
+import com.badlogic.gdx.graphics.Texture.TextureFilter;
+import com.badlogic.gdx.graphics.Texture.TextureWrap;
+import com.badlogic.gdx.graphics.g2d.TextureAtlas.TextureAtlasData;
+import com.badlogic.gdx.graphics.g2d.TextureAtlas.TextureAtlasData.Region;
+import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+import java.awt.Color;
+import java.awt.Graphics2D;
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.Comparator;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Set;
+
+import javax.imageio.IIOImage;
+import javax.imageio.ImageIO;
+import javax.imageio.ImageWriteParam;
+import javax.imageio.ImageWriter;
+import javax.imageio.stream.ImageOutputStream;
+
+/** @author Nathan Sweet */
+public class TexturePacker {
+	private final Settings settings;
+	private final Packer packer;
+	private final ImageProcessor imageProcessor;
+	private final Array<InputImage> inputImages = new Array();
+	private File rootDir;
+
+	/** @param rootDir Used to strip the root directory prefix from image file names, can be null. */
+	public TexturePacker (File rootDir, Settings settings) {
+		this.rootDir = rootDir;
+		this.settings = settings;
+
+		if (settings.pot) {
+			if (settings.maxWidth != MathUtils.nextPowerOfTwo(settings.maxWidth))
+				throw new RuntimeException("If pot is true, maxWidth must be a power of two: " + settings.maxWidth);
+			if (settings.maxHeight != MathUtils.nextPowerOfTwo(settings.maxHeight))
+				throw new RuntimeException("If pot is true, maxHeight must be a power of two: " + settings.maxHeight);
+		}
+
+		if (settings.grid)
+			packer = new GridPacker(settings);
+		else
+			packer = new MaxRectsPacker(settings);
+		imageProcessor = new ImageProcessor(rootDir, settings);
+	}
+
+	public TexturePacker (Settings settings) {
+		this(null, settings);
+	}
+
+	public void addImage (File file) {
+		InputImage inputImage = new InputImage();
+		inputImage.file = file;
+		inputImages.add(inputImage);
+	}
+
+	public void addImage (BufferedImage image, String name) {
+		InputImage inputImage = new InputImage();
+		inputImage.image = image;
+		inputImage.name = name;
+		inputImages.add(inputImage);
+	}
+
+	public void pack (File outputDir, String packFileName) {
+		outputDir.mkdirs();
+
+		if (packFileName.indexOf('.') == -1 || packFileName.endsWith(".png") || packFileName.endsWith(".jpg"))
+			packFileName += ".atlas";
+
+		for (float scale : settings.scale) {
+			String scaledPackFileName = packFileName;
+			if (scale != 1 || settings.scale.length != 1) {
+				FileHandle file = new FileHandle(scaledPackFileName);
+				String suffix = scale == (int)scale ? Integer.toString((int)scale) : Float.toString(scale);
+				scaledPackFileName = file.nameWithoutExtension() + suffix + "." + file.extension();
+			}
+
+			imageProcessor.setScale(scale);
+			for (InputImage inputImage : inputImages) {
+				if (inputImage.file != null)
+					imageProcessor.addImage(inputImage.file);
+				else
+					imageProcessor.addImage(inputImage.image, inputImage.name);
+			}
+
+			Array<Page> pages = packer.pack(imageProcessor.getImages());
+			writeImages(outputDir, pages, scaledPackFileName);
+			try {
+				writePackFile(outputDir, pages, scaledPackFileName);
+			} catch (IOException ex) {
+				throw new RuntimeException("Error writing pack file.", ex);
+			}
+			imageProcessor.clear();
+		}
+	}
+
+	private void writeImages (File outputDir, Array<Page> pages, String packFileName) {
+		String imageName = packFileName;
+		int dotIndex = imageName.lastIndexOf('.');
+		if (dotIndex != -1) imageName = imageName.substring(0, dotIndex);
+
+		int fileIndex = 0;
+		for (Page page : pages) {
+			int width = page.width, height = page.height;
+			int paddingX = settings.paddingX;
+			int paddingY = settings.paddingY;
+			if (settings.duplicatePadding) {
+				paddingX /= 2;
+				paddingY /= 2;
+			}
+			width -= settings.paddingX;
+			height -= settings.paddingY;
+			if (settings.edgePadding) {
+				page.x = paddingX;
+				page.y = paddingY;
+				width += paddingX * 2;
+				height += paddingY * 2;
+			}
+			if (settings.pot) {
+				width = MathUtils.nextPowerOfTwo(width);
+				height = MathUtils.nextPowerOfTwo(height);
+			}
+			width = Math.max(settings.minWidth, width);
+			height = Math.max(settings.minHeight, height);
+
+			if (settings.square) {
+				if (width > height) {
+					height = width;
+				} else {
+					width = height;
+				}
+			}
+
+			File outputFile;
+			while (true) {
+				fileIndex++;
+				outputFile = new File(outputDir, imageName + "-" + fileIndex + "." + settings.outputFormat);
+				if (!outputFile.exists()) break;
+			}
+			page.imageName = outputFile.getName();
+
+			BufferedImage canvas = new BufferedImage(width, height, getBufferedImageType(settings.format));
+			Graphics2D g = (Graphics2D)canvas.getGraphics();
+
+			System.out.println("Writing " + canvas.getWidth() + "x" + canvas.getHeight() + ": " + outputFile);
+
+			for (Rect rect : page.outputRects) {
+				BufferedImage image = rect.getImage(imageProcessor);
+				int iw = image.getWidth();
+				int ih = image.getHeight();
+				int rectX = page.x + rect.x, rectY = page.y + page.height - rect.y - rect.height;
+				if (settings.duplicatePadding) {
+					int amountX = settings.paddingX / 2;
+					int amountY = settings.paddingY / 2;
+					if (rect.rotated) {
+						// Copy corner pixels to fill corners of the padding.
+						for (int i = 1; i <= amountX; i++) {
+							for (int j = 1; j <= amountY; j++) {
+								plot(canvas, rectX - j, rectY + iw - 1 + i, image.getRGB(0, 0));
+								plot(canvas, rectX + ih - 1 + j, rectY + iw - 1 + i, image.getRGB(0, ih - 1));
+								plot(canvas, rectX - j, rectY - i, image.getRGB(iw - 1, 0));
+								plot(canvas, rectX + ih - 1 + j, rectY - i, image.getRGB(iw - 1, ih - 1));
+							}
+						}
+						// Copy edge pixels into padding.
+						for (int i = 1; i <= amountY; i++) {
+							for (int j = 0; j < iw; j++) {
+								plot(canvas, rectX - i, rectY + iw - 1 - j, image.getRGB(j, 0));
+								plot(canvas, rectX + ih - 1 + i, rectY + iw - 1 - j, image.getRGB(j, ih - 1));
+							}
+						}
+						for (int i = 1; i <= amountX; i++) {
+							for (int j = 0; j < ih; j++) {
+								plot(canvas, rectX + j, rectY - i, image.getRGB(iw - 1, j));
+								plot(canvas, rectX + j, rectY + iw - 1 + i, image.getRGB(0, j));
+							}
+						}
+					} else {
+						// Copy corner pixels to fill corners of the padding.
+						for (int i = 1; i <= amountX; i++) {
+							for (int j = 1; j <= amountY; j++) {
+								canvas.setRGB(rectX - i, rectY - j, image.getRGB(0, 0));
+								canvas.setRGB(rectX - i, rectY + ih - 1 + j, image.getRGB(0, ih - 1));
+								canvas.setRGB(rectX + iw - 1 + i, rectY - j, image.getRGB(iw - 1, 0));
+								canvas.setRGB(rectX + iw - 1 + i, rectY + ih - 1 + j, image.getRGB(iw - 1, ih - 1));
+							}
+						}
+						// Copy edge pixels into padding.
+						for (int i = 1; i <= amountY; i++) {
+							copy(image, 0, 0, iw, 1, canvas, rectX, rectY - i, rect.rotated);
+							copy(image, 0, ih - 1, iw, 1, canvas, rectX, rectY + ih - 1 + i, rect.rotated);
+						}
+						for (int i = 1; i <= amountX; i++) {
+							copy(image, 0, 0, 1, ih, canvas, rectX - i, rectY, rect.rotated);
+							copy(image, iw - 1, 0, 1, ih, canvas, rectX + iw - 1 + i, rectY, rect.rotated);
+						}
+					}
+				}
+				copy(image, 0, 0, iw, ih, canvas, rectX, rectY, rect.rotated);
+				if (settings.debug) {
+					g.setColor(Color.magenta);
+					g.drawRect(rectX, rectY, rect.width - settings.paddingX - 1, rect.height - settings.paddingY - 1);
+				}
+			}
+
+			if (settings.bleed && !settings.premultiplyAlpha && !settings.outputFormat.equalsIgnoreCase("jpg")) {
+				canvas = new ColorBleedEffect().processImage(canvas, 2);
+				g = (Graphics2D)canvas.getGraphics();
+			}
+
+			if (settings.debug) {
+				g.setColor(Color.magenta);
+				g.drawRect(0, 0, width - 1, height - 1);
+			}
+
+			ImageOutputStream ios = null;
+			try {
+				if (settings.outputFormat.equalsIgnoreCase("jpg")) {
+					BufferedImage newImage = new BufferedImage(canvas.getWidth(), canvas.getHeight(), BufferedImage.TYPE_3BYTE_BGR);
+					newImage.getGraphics().drawImage(canvas, 0, 0, null);
+					canvas = newImage;
+
+					Iterator<ImageWriter> writers = ImageIO.getImageWritersByFormatName("jpg");
+					ImageWriter writer = writers.next();
+					ImageWriteParam param = writer.getDefaultWriteParam();
+					param.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);
+					param.setCompressionQuality(settings.jpegQuality);
+					ios = ImageIO.createImageOutputStream(outputFile);
+					writer.setOutput(ios);
+					writer.write(null, new IIOImage(canvas, null, null), param);
+				} else {
+					if (settings.premultiplyAlpha) canvas.getColorModel().coerceData(canvas.getRaster(), true);
+					ImageIO.write(canvas, "png", outputFile);
+				}
+			} catch (IOException ex) {
+				throw new RuntimeException("Error writing file: " + outputFile, ex);
+			} finally {
+				if (ios != null) {
+					try {
+						ios.close();
+					} catch (Exception ignored) {
+					}
+				}
+			}
+		}
+	}
+
+	static private void plot (BufferedImage dst, int x, int y, int argb) {
+		if (0 <= x && x < dst.getWidth() && 0 <= y && y < dst.getHeight()) dst.setRGB(x, y, argb);
+	}
+
+	static private void copy (BufferedImage src, int x, int y, int w, int h, BufferedImage dst, int dx, int dy, boolean rotated) {
+		if (rotated) {
+			for (int i = 0; i < w; i++)
+				for (int j = 0; j < h; j++)
+					dst.setRGB(dx + j, dy + w - i - 1, src.getRGB(x + i, y + j));
+		} else {
+			for (int i = 0; i < w; i++)
+				for (int j = 0; j < h; j++)
+					dst.setRGB(dx + i, dy + j, src.getRGB(x + i, y + j));
+		}
+	}
+
+	private void writePackFile (File outputDir, Array<Page> pages, String packFileName) throws IOException {
+		File packFile = new File(outputDir, packFileName);
+
+		if (packFile.exists()) {
+			// Make sure there aren't duplicate names.
+			TextureAtlasData textureAtlasData = new TextureAtlasData(new FileHandle(packFile), new FileHandle(packFile), false);
+			for (Page page : pages) {
+				for (Rect rect : page.outputRects) {
+					String rectName = Rect.getAtlasName(rect.name, settings.flattenPaths);
+					for (Region region : textureAtlasData.getRegions()) {
+						if (region.name.equals(rectName)) {
+							throw new GdxRuntimeException("A region with the name \"" + rectName + "\" has already been packed: "
+								+ rect.name);
+						}
+					}
+				}
+			}
+		}
+
+		FileWriter writer = new FileWriter(packFile, true);
+		for (Page page : pages) {
+			writer.write("\n" + page.imageName + "\n");
+			writer.write("format: " + settings.format + "\n");
+			writer.write("filter: " + settings.filterMin + "," + settings.filterMag + "\n");
+			writer.write("repeat: " + getRepeatValue() + "\n");
+
+			for (Rect rect : page.outputRects) {
+				writeRect(writer, page, rect, rect.name);
+				for (Alias alias : rect.aliases) {
+					Rect aliasRect = new Rect();
+					aliasRect.set(rect);
+					alias.apply(aliasRect);
+					writeRect(writer, page, aliasRect, alias.name);
+				}
+			}
+		}
+		writer.close();
+	}
+
+	private void writeRect (FileWriter writer, Page page, Rect rect, String name) throws IOException {
+		writer.write(Rect.getAtlasName(name, settings.flattenPaths) + "\n");
+		writer.write("  rotate: " + rect.rotated + "\n");
+		writer.write("  xy: " + (page.x + rect.x) + ", " + (page.y + page.height - rect.height - rect.y) + "\n");
+
+		writer.write("  size: " + rect.regionWidth + ", " + rect.regionHeight + "\n");
+		if (rect.splits != null) {
+			writer.write("  split: " //
+				+ rect.splits[0] + ", " + rect.splits[1] + ", " + rect.splits[2] + ", " + rect.splits[3] + "\n");
+		}
+		if (rect.pads != null) {
+			if (rect.splits == null) writer.write("  split: 0, 0, 0, 0\n");
+			writer.write("  pad: " + rect.pads[0] + ", " + rect.pads[1] + ", " + rect.pads[2] + ", " + rect.pads[3] + "\n");
+		}
+		writer.write("  orig: " + rect.originalWidth + ", " + rect.originalHeight + "\n");
+		writer.write("  offset: " + rect.offsetX + ", " + (rect.originalHeight - rect.regionHeight - rect.offsetY) + "\n");
+		writer.write("  index: " + rect.index + "\n");
+	}
+
+	private String getRepeatValue () {
+		if (settings.wrapX == TextureWrap.Repeat && settings.wrapY == TextureWrap.Repeat) return "xy";
+		if (settings.wrapX == TextureWrap.Repeat && settings.wrapY == TextureWrap.ClampToEdge) return "x";
+		if (settings.wrapX == TextureWrap.ClampToEdge && settings.wrapY == TextureWrap.Repeat) return "y";
+		return "none";
+	}
+
+	private int getBufferedImageType (Format format) {
+		switch (settings.format) {
+		case RGBA8888:
+		case RGBA4444:
+			return BufferedImage.TYPE_INT_ARGB;
+		case RGB565:
+		case RGB888:
+			return BufferedImage.TYPE_INT_RGB;
+		case Alpha:
+			return BufferedImage.TYPE_BYTE_GRAY;
+		default:
+			throw new RuntimeException("Unsupported format: " + settings.format);
+		}
+	}
+
+	/** @author Nathan Sweet */
+	static public class Page {
+		public String imageName;
+		public Array<Rect> outputRects, remainingRects;
+		public float occupancy;
+		public int x, y, width, height;
+	}
+
+	/** @author Regnarock
+	 * @author Nathan Sweet */
+	static public class Alias {
+		public String name;
+		public int index;
+		public int[] splits;
+		public int[] pads;
+		public int offsetX, offsetY, originalWidth, originalHeight;
+
+		public Alias (Rect rect) {
+			name = rect.name;
+			index = rect.index;
+			splits = rect.splits;
+			pads = rect.pads;
+			offsetX = rect.offsetX;
+			offsetY = rect.offsetY;
+			originalWidth = rect.originalWidth;
+			originalHeight = rect.originalHeight;
+		}
+
+		public void apply (Rect rect) {
+			rect.name = name;
+			rect.index = index;
+			rect.splits = splits;
+			rect.pads = pads;
+			rect.offsetX = offsetX;
+			rect.offsetY = offsetY;
+			rect.originalWidth = originalWidth;
+			rect.originalHeight = originalHeight;
+		}
+	}
+
+	/** @author Nathan Sweet */
+	static public class Rect {
+		public String name;
+		public int offsetX, offsetY, regionWidth, regionHeight, originalWidth, originalHeight;
+		public int x, y;
+		public int width, height; // Portion of page taken by this region, including padding.
+		public int index;
+		public boolean rotated;
+		public Set<Alias> aliases = new HashSet<Alias>();
+		public int[] splits;
+		public int[] pads;
+		public boolean canRotate = true;
+
+		private boolean isPatch;
+		private BufferedImage image;
+		private File file;
+		int score1, score2;
+
+		Rect (BufferedImage source, int left, int top, int newWidth, int newHeight, boolean isPatch) {
+			image = new BufferedImage(source.getColorModel(), source.getRaster().createWritableChild(left, top, newWidth, newHeight,
+				0, 0, null), source.getColorModel().isAlphaPremultiplied(), null);
+			offsetX = left;
+			offsetY = top;
+			regionWidth = newWidth;
+			regionHeight = newHeight;
+			originalWidth = source.getWidth();
+			originalHeight = source.getHeight();
+			width = newWidth;
+			height = newHeight;
+			this.isPatch = isPatch;
+		}
+
+		/** Clears the image for this rect, which will be loaded from the specified file by {@link #getImage(ImageProcessor)}. */
+		public void unloadImage (File file) {
+			this.file = file;
+			image = null;
+		}
+
+		public BufferedImage getImage (ImageProcessor imageProcessor) {
+			if (image != null) return image;
+
+			BufferedImage image;
+			try {
+				image = ImageIO.read(file);
+			} catch (IOException ex) {
+				throw new RuntimeException("Error reading image: " + file, ex);
+			}
+			if (image == null) throw new RuntimeException("Unable to read image: " + file);
+			String name = this.name;
+			if (isPatch) name += ".9";
+			return imageProcessor.processImage(image, name).getImage(null);
+		}
+
+		Rect () {
+		}
+
+		Rect (Rect rect) {
+			x = rect.x;
+			y = rect.y;
+			width = rect.width;
+			height = rect.height;
+		}
+
+		void set (Rect rect) {
+			name = rect.name;
+			image = rect.image;
+			offsetX = rect.offsetX;
+			offsetY = rect.offsetY;
+			regionWidth = rect.regionWidth;
+			regionHeight = rect.regionHeight;
+			originalWidth = rect.originalWidth;
+			originalHeight = rect.originalHeight;
+			x = rect.x;
+			y = rect.y;
+			width = rect.width;
+			height = rect.height;
+			index = rect.index;
+			rotated = rect.rotated;
+			aliases = rect.aliases;
+			splits = rect.splits;
+			pads = rect.pads;
+			canRotate = rect.canRotate;
+			score1 = rect.score1;
+			score2 = rect.score2;
+			file = rect.file;
+			isPatch = rect.isPatch;
+		}
+
+		@Override
+		public boolean equals (Object obj) {
+			if (this == obj) return true;
+			if (obj == null) return false;
+			if (getClass() != obj.getClass()) return false;
+			Rect other = (Rect)obj;
+			if (name == null) {
+				if (other.name != null) return false;
+			} else if (!name.equals(other.name)) return false;
+			return true;
+		}
+
+		@Override
+		public String toString () {
+			return name + "[" + x + "," + y + " " + width + "x" + height + "]";
+		}
+
+		static public String getAtlasName (String name, boolean flattenPaths) {
+			return flattenPaths ? new FileHandle(name).name() : name;
+		}
+	}
+
+	/** @author Nathan Sweet */
+	static public class Settings {
+		public boolean pot = true;
+		public int paddingX = 2, paddingY = 2;
+		public boolean edgePadding = true;
+		public boolean duplicatePadding = false;
+		public boolean rotation;
+		public int minWidth = 16, minHeight = 16;
+		public int maxWidth = 1024, maxHeight = 1024;
+		public boolean square = false;
+		public boolean stripWhitespaceX, stripWhitespaceY;
+		public int alphaThreshold;
+		public TextureFilter filterMin = TextureFilter.Nearest, filterMag = TextureFilter.Nearest;
+		public TextureWrap wrapX = TextureWrap.ClampToEdge, wrapY = TextureWrap.ClampToEdge;
+		public Format format = Format.RGBA8888;
+		public boolean alias = true;
+		public String outputFormat = "png";
+		public float jpegQuality = 0.9f;
+		public boolean ignoreBlankImages = true;
+		public boolean fast;
+		public boolean debug;
+		public boolean combineSubdirectories;
+		public boolean flattenPaths;
+		public boolean premultiplyAlpha;
+		public boolean useIndexes = true;
+		public boolean bleed = true;
+		public boolean limitMemory = true;
+		public boolean grid;
+		public float[] scale = {1};
+
+		public Settings () {
+		}
+
+		public Settings (Settings settings) {
+			fast = settings.fast;
+			rotation = settings.rotation;
+			pot = settings.pot;
+			minWidth = settings.minWidth;
+			minHeight = settings.minHeight;
+			maxWidth = settings.maxWidth;
+			maxHeight = settings.maxHeight;
+			paddingX = settings.paddingX;
+			paddingY = settings.paddingY;
+			edgePadding = settings.edgePadding;
+			duplicatePadding = settings.duplicatePadding;
+			alphaThreshold = settings.alphaThreshold;
+			ignoreBlankImages = settings.ignoreBlankImages;
+			stripWhitespaceX = settings.stripWhitespaceX;
+			stripWhitespaceY = settings.stripWhitespaceY;
+			alias = settings.alias;
+			format = settings.format;
+			jpegQuality = settings.jpegQuality;
+			outputFormat = settings.outputFormat;
+			filterMin = settings.filterMin;
+			filterMag = settings.filterMag;
+			wrapX = settings.wrapX;
+			wrapY = settings.wrapY;
+			debug = settings.debug;
+			combineSubdirectories = settings.combineSubdirectories;
+			flattenPaths = settings.flattenPaths;
+			premultiplyAlpha = settings.premultiplyAlpha;
+			square = settings.square;
+			useIndexes = settings.useIndexes;
+			bleed = settings.bleed;
+			limitMemory = settings.limitMemory;
+			scale = settings.scale;
+		}
+	}
+
+	/** Packs using defaults settings.
+	 * @see TexturePacker#process(Settings, String, String, String) */
+	static public void process (String input, String output, String packFileName) {
+		process(new Settings(), input, output, packFileName);
+	}
+
+	/** @param input Directory containing individual images to be packed.
+	 * @param output Directory where the pack file and page images will be written.
+	 * @param packFileName The name of the pack file. Also used to name the page images. */
+	static public void process (Settings settings, String input, String output, String packFileName) {
+		try {
+			TexturePackerFileProcessor processor = new TexturePackerFileProcessor(settings, packFileName);
+			// Sort input files by name to avoid platform-dependent atlas output changes.
+			processor.setComparator(new Comparator<File>() {
+				public int compare (File file1, File file2) {
+					return file1.getName().compareTo(file2.getName());
+				}
+			});
+			processor.process(new File(input), new File(output));
+		} catch (Exception ex) {
+			throw new RuntimeException("Error packing files.", ex);
+		}
+	}
+
+	/** @return true if the output file does not yet exist or its last modification date is before the last modification date of the
+	 *         input file */
+	static public boolean isModified (String input, String output, String packFileName) {
+		String packFullFileName = output;
+		if (!packFullFileName.endsWith("/")) packFullFileName += "/";
+		packFullFileName += packFileName;
+		File outputFile = new File(packFullFileName);
+		if (!outputFile.exists()) return true;
+
+		File inputFile = new File(input);
+		if (!inputFile.exists()) throw new IllegalArgumentException("Input file does not exist: " + inputFile.getAbsolutePath());
+		return inputFile.lastModified() > outputFile.lastModified();
+	}
+
+	static public void processIfModified (String input, String output, String packFileName) {
+		if (isModified(input, output, packFileName)) process(input, output, packFileName);
+	}
+
+	static public void processIfModified (Settings settings, String input, String output, String packFileName) {
+		if (isModified(input, output, packFileName)) process(settings, input, output, packFileName);
+	}
+
+	static public interface Packer {
+		public Array<Page> pack (Array<Rect> inputRects);
+	}
+
+	static final class InputImage {
+		File file;
+		String name;
+		BufferedImage image;
+	}
+
+	static public void main (String[] args) throws Exception {
+		String input = null, output = null, packFileName = "pack.atlas";
+
+		switch (args.length) {
+		case 3:
+			packFileName = args[2];
+		case 2:
+			output = args[1];
+		case 1:
+			input = args[0];
+			break;
+		default:
+			System.out.println("Usage: inputDir [outputDir] [packFileName]");
+			System.exit(0);
+		}
+
+		if (output == null) {
+			File inputFile = new File(input);
+			output = new File(inputFile.getParentFile(), inputFile.getName() + "-packed").getAbsolutePath();
+		}
+
+		process(input, output, packFileName);
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx.gwt.xml b/gdx/src/com/badlogic/gdx.gwt.xml
index ea1d776..ee9bf6a 100644
--- a/gdx/src/com/badlogic/gdx.gwt.xml
+++ b/gdx/src/com/badlogic/gdx.gwt.xml
@@ -28,8 +28,8 @@
 		<include name="assets/AssetDescriptor.java"/>
 		<include name="assets/AssetErrorListener.java"/>
 		<include name="assets/AssetLoaderParameters.java"/>
-		<include name="assets/AssetLoadingTask.java"/>
-		<include name="assets/AssetManager.java"/>
+		<include name="assets/AssetLoadingTask.java"/> <!-- Emulated: Threading -->
+		<include name="assets/AssetManager.java"/> <!-- Emulated: Threading -->
 		<include name="assets/RefCountedContainer.java"/>
 
 	<!-- assets/loaders -->
@@ -39,13 +39,13 @@
 		<include name="assets/loaders/FileHandleResolver.java"/>
 		<include name="assets/loaders/ModelLoader.java"/>
 		<include name="assets/loaders/MusicLoader.java"/>
-		<include name="assets/loaders/ParticleEffectLoader.java"/>
 		<include name="assets/loaders/PixmapLoader.java"/>
 		<include name="assets/loaders/SkinLoader.java"/>
 		<include name="assets/loaders/SoundLoader.java"/>
 		<include name="assets/loaders/SynchronousAssetLoader.java"/>
 		<include name="assets/loaders/TextureAtlasLoader.java"/>
-		<include name="assets/loaders/TextureLoader.java"/> <!-- Emulated -->
+		<include name="assets/loaders/TextureLoader.java"/>
+		<include name="assets/loaders/ParticleEffectLoader.java"/>
 		
 	<!-- assets/loaders/resolvers -->		
 		<include name="assets/loaders/resolvers/ExternalFileHandleResolver.java"/>
@@ -71,14 +71,16 @@
 		<include name="graphics/GL11.java"/>
 		<include name="graphics/GL20.java"/>
 		<include name="graphics/GLCommon.java"/>
-		<include name="graphics/GLTexture.java"/>
+		<include name="graphics/GLTexture.java"/> <!-- emulated -->
 		<include name="graphics/Mesh.java"/>
 		<include name="graphics/OrthographicCamera.java"/>
 		<include name="graphics/PerspectiveCamera.java"/>
 		<include name="graphics/Pixmap.java"/> <!-- Emulated -->
 		<exclude name="graphics/PixmapIO.java"/> <!-- Reason: No DeflaterOutputStream -->
-		<include name="graphics/Texture.java"/>
+		<include name="graphics/Texture.java"/> <!-- Emulated -->
 		<include name="graphics/TextureData.java"/>
+		<include name="graphics/TextureDict.java"/>
+		<include name="graphics/TextureRef.java"/>
 		<include name="graphics/VertexAttribute.java"/>
 		<include name="graphics/VertexAttributes.java"/>
 		
@@ -141,9 +143,9 @@
 		<include name="graphics/g3d/environment/BaseLight.java"/>
 		<include name="graphics/g3d/environment/DirectionalLight.java"/>
 		<include name="graphics/g3d/environment/DirectionalShadowLight.java"/>
+		<include name="graphics/g3d/environment/Lights.java"/>
 		<include name="graphics/g3d/environment/PointLight.java"/>
 		<include name="graphics/g3d/environment/ShadowMap.java"/>
-		<include name="graphics/g3d/environment/Sphericalharmonics.java"/>
 				
 	<!-- graphics/g3d/loader -->		
 		<include name="graphics/g3d/loader/G3dModelLoader.java"/>
@@ -174,6 +176,9 @@
 		<include name="graphics/g3d/shaders/DefaultShader.java"/>
 		<include name="graphics/g3d/shaders/DepthShader.java"/>
 		<include name="graphics/g3d/shaders/GLES10Shader.java"/>
+		
+	<!-- graphics/g3d/shaders/graph -->
+		<include name="graphics/g3d/shaders/graph/*.java"/>
 
 	<!-- graphics/g3d/utils -->
 		<include name="graphics/g3d/utils/AnimationController.java"/>
@@ -228,9 +233,9 @@
 		<include name="maps/ImageResolver.java"/>
 		<include name="maps/Map.java"/>
 		<include name="maps/MapLayer.java"/>
-		<include name="maps/MapLayers.java"/>
+		<include name="maps/MapLayers.java"/> <!-- Emulated: Reflection -->
 		<include name="maps/MapObject.java"/>
-		<include name="maps/MapObjects.java"/>
+		<include name="maps/MapObjects.java"/> <!-- Emulated: Reflection -->
 		<include name="maps/MapProperties.java"/>
 		<include name="maps/MapRenderer.java"/>
 		
@@ -243,7 +248,6 @@
 		<include name="maps/objects/TextureMapObject.java"/>
 	
 	<!-- maps/tiled -->
-		<include name="maps/tiled/AtlasTmxMapLoader.java"/>
 		<include name="maps/tiled/TideMapLoader.java"/>
 		<include name="maps/tiled/TiledMap.java"/>
 		<include name="maps/tiled/TiledMapRenderer.java"/>
@@ -251,8 +255,9 @@
 		<include name="maps/tiled/TiledMapTileLayer.java"/>
 		<include name="maps/tiled/TiledMapTileSet.java"/>
 		<include name="maps/tiled/TiledMapTileSets.java"/>
+		<include name="maps/tiled/TmxMapLoader.java"/> <!-- Emulated: Compression -->
+		<include name="maps/tiled/AtlasTmxMapLoader.java"/>
 		<include name="maps/tiled/TmxMapHelper.java"/>
-		<include name="maps/tiled/TmxMapLoader.java"/>
 		
 	<!-- maps/tiled/renderers -->
 		<include name="maps/tiled/renderers/BatchTiledMapRenderer.java"/>
@@ -306,12 +311,12 @@
 		<include name="net/HttpParametersUtils.java"/>
 		<include name="net/HttpStatus.java"/>
 		<exclude name="net/NetJavaImpl.java"/> <!-- Reason: Networking -->
-		<exclude name="net/NetJavaServerSocketImpl.java"/> <!-- Reason: Networking -->
-		<exclude name="net/NetJavaSocketImpl.java"/> <!-- Reason: Networking -->
 		<include name="net/ServerSocket.java"/>
 		<include name="net/ServerSocketHints.java"/>
 		<include name="net/Socket.java"/>
 		<include name="net/SocketHints.java"/>
+		<exclude name="net/NetJavaSocketImpl.java"/> <!-- Reason: Networking -->
+		<exclude name="net/NetJavaServerSocketImpl.java"/> <!-- Reason: Networking -->
 	
 	<!-- physics/box2d -->
 	<!-- Box2d is fully emulated in GWT backend -->
@@ -337,10 +342,8 @@
 		<include name="scenes/scene2d/actions/AfterAction.java"/>
 		<include name="scenes/scene2d/actions/AlphaAction.java"/>
 		<include name="scenes/scene2d/actions/ColorAction.java"/>
-		<include name="scenes/scene2d/actions/CountdownEventAction.java"/>
 		<include name="scenes/scene2d/actions/DelayAction.java"/>
 		<include name="scenes/scene2d/actions/DelegateAction.java"/>
-		<include name="scenes/scene2d/actions/EventAction.java"/>
 		<include name="scenes/scene2d/actions/FloatAction.java"/>
 		<include name="scenes/scene2d/actions/IntAction.java"/>
 		<include name="scenes/scene2d/actions/LayoutAction.java"/>
@@ -385,9 +388,9 @@
 		<include name="scenes/scene2d/ui/Table.java"/>
 		<include name="scenes/scene2d/ui/TableLayout.java"/>
 		<include name="scenes/scene2d/ui/TableToolkit.java"/>
-		<include name="scenes/scene2d/ui/TextArea.java"/>
 		<include name="scenes/scene2d/ui/TextButton.java"/>
 		<include name="scenes/scene2d/ui/TextField.java"/>
+		<include name="scenes/scene2d/ui/TextArea.java"/>
 		<include name="scenes/scene2d/ui/Touchpad.java"/>
 		<include name="scenes/scene2d/ui/Tree.java"/>
 		<include name="scenes/scene2d/ui/VerticalGroup.java"/>
@@ -425,7 +428,6 @@
 		<include name="utils/Bits.java"/>
 		<include name="utils/BooleanArray.java"/>
 		<include name="utils/BufferUtils.java"/> <!-- Emulated -->
-		<include name="utils/ByteArray.java"/>
 		<include name="utils/CharArray.java"/>
 		<include name="utils/Clipboard.java"/>
 		<include name="utils/ComparableTimSort.java"/>
@@ -437,16 +439,17 @@
 		<exclude name="utils/GdxBuild.java"/> <!-- Reason: Natives -->
 		<exclude name="utils/GdxNativesLoader.java"/> <!-- Reason: Natives -->
 		<include name="utils/GdxRuntimeException.java"/>
+		<exclude name="utils/GwtModuleGenerator.java"/> <!-- Reason: Generator -->
 		<include name="utils/IdentityMap.java"/>
 		<include name="utils/IntArray.java"/>
 		<include name="utils/IntFloatMap.java"/>
 		<include name="utils/IntIntMap.java"/>
 		<include name="utils/IntMap.java"/>
 		<include name="utils/IntSet.java"/>
-		<include name="utils/Json.java"/>
+		<include name="utils/Json.java"/> <!-- Emulated: Reflection -->
 		<include name="utils/JsonReader.java"/>
 		<include name="utils/JsonValue.java"/>
-		<include name="utils/JsonWriter.java"/>
+		<include name="utils/JsonWriter.java"/> <!-- Emulated: Regex -->
 		<include name="utils/LittleEndianInputStream.java"/>
 		<include name="utils/Logger.java"/>
 		<include name="utils/LongArray.java"/>
@@ -465,7 +468,7 @@
 		<include name="utils/Pools.java"/>
 		<include name="utils/Predicate.java"/>
 		<include name="utils/QuickSelect.java"/>
-		<include name="utils/ReflectionPool.java"/>
+		<include name="utils/ReflectionPool.java"/> <!-- Emulated: Reflection -->
 		<include name="utils/Scaling.java"/>
 		<exclude name="utils/ScreenUtils.java"/> <!-- Reason: Type mismatch Buffer->ByteBuffer -->
 		<include name="utils/Select.java"/>
@@ -484,13 +487,7 @@
 		<include name="utils/UBJsonWriter.java"/>		
 		<include name="utils/XmlReader.java"/>
 		<include name="utils/XmlWriter.java"/>
-
-	<!-- utils/async -->
-		<include name="utils/async/AsyncExecutor.java"/> <!-- Emulated: Threading -->
-		<include name="utils/async/AsyncResult.java"/> <!-- Emulated: Threading -->
-		<include name="utils/async/AsyncTask.java"/> <!-- Emulated: Threading -->
-		<include name="utils/async/ThreadUtils.java"/> <!-- Emulated: Threading -->	
-
+		
 	<!-- utils/compression -->
 		<include name="utils/compression/CRC.java"/>
 		<include name="utils/compression/ICodeProgress.java"/>
@@ -512,13 +509,12 @@
 		<include name="utils/compression/rangecoder/Decoder.java"/>
 		<include name="utils/compression/rangecoder/Encoder.java"/>
 		
-	<!-- utils/reflect -->
-		<include name="utils/reflect/ArrayReflection.java"/> <!-- Emulated -->
-		<include name="utils/reflect/ClassReflection.java"/> <!-- Emulated -->
-		<include name="utils/reflect/Constructor.java"/> <!-- Emulated -->
-		<include name="utils/reflect/Field.java"/> <!-- Emulated -->
-		<include name="utils/reflect/Method.java"/>	 <!-- Emulated -->
-		<include name="utils/reflect/ReflectionException.java"/>
+	<!-- utils/compression/rangecoder -->
+		<include name="utils/reflect/Constructor.java"/>
+		<include name="utils/reflect/Field.java"/>
+		<include name="utils/reflect/Method.java"/>
+		<include name="utils/reflect/Reflection.java"/>
+		<include name="utils/reflect/ReflectionException.java"/>		
 	</source>
 	
 	<define-configuration-property name="gdx.files.classpath" is-multi-valued="true" />
diff --git a/gdx/src/com/badlogic/gdx/Net.java b/gdx/src/com/badlogic/gdx/Net.java
index b3d7797..546d46f 100644
--- a/gdx/src/com/badlogic/gdx/Net.java
+++ b/gdx/src/com/badlogic/gdx/Net.java
@@ -256,8 +256,7 @@ public interface Net {
 		 * other reason (not an HTTP error).
 		 * @param t If the HTTP request failed because an Exception, t encapsulates it to give more information. */
 		void failed (Throwable t);
-		
-		void cancelled();
+
 	}
 
 	/** Process the specified {@link HttpRequest} and reports the {@link HttpResponse} to the specified {@link HttpResponseListener}
@@ -266,8 +265,6 @@ public interface Net {
 	 * @param httpResponseListener The {@link HttpResponseListener} to call once the HTTP response is ready to be processed. Could
 	 *           be null, in that case no listener is called. */
 	public void sendHttpRequest (HttpRequest httpRequest, HttpResponseListener httpResponseListener);
-	
-	public void cancelHttpRequest(HttpRequest httpRequest);
 
 	/** Protocol used by {@link Net#newServerSocket(Protocol, int, ServerSocketHints)} and
 	 * {@link Net#newClientSocket(Protocol, String, int, SocketHints)}.
diff --git a/gdx/src/com/badlogic/gdx/assets/AssetManager.java b/gdx/src/com/badlogic/gdx/assets/AssetManager.java
index 4c7da89..25436f4 100644
--- a/gdx/src/com/badlogic/gdx/assets/AssetManager.java
+++ b/gdx/src/com/badlogic/gdx/assets/AssetManager.java
@@ -53,7 +53,6 @@ import com.badlogic.gdx.utils.JsonReader;
 import com.badlogic.gdx.utils.Logger;
 import com.badlogic.gdx.utils.ObjectIntMap;
 import com.badlogic.gdx.utils.ObjectMap;
-import com.badlogic.gdx.utils.ObjectSet;
 import com.badlogic.gdx.utils.TimeUtils;
 import com.badlogic.gdx.utils.UBJsonReader;
 import com.badlogic.gdx.utils.async.AsyncExecutor;
@@ -66,7 +65,6 @@ public class AssetManager implements Disposable {
 	final ObjectMap<Class, ObjectMap<String, RefCountedContainer>> assets = new ObjectMap();
 	final ObjectMap<String, Class> assetTypes = new ObjectMap();
 	final ObjectMap<String, Array<String>> assetDependencies = new ObjectMap();
-	final ObjectSet<String> injected = new ObjectSet();
 
 	final ObjectMap<Class, ObjectMap<String, AssetLoader>> loaders = new ObjectMap();
 	final Array<AssetDescriptor> loadQueue = new Array();
@@ -104,7 +102,7 @@ public class AssetManager implements Disposable {
 	 * @return the asset */
 	public synchronized <T> T get (String fileName) {
 		Class<T> type = assetTypes.get(fileName);
-		if (type == null) throw new GdxRuntimeException("Asset not loaded: " + fileName);
+		if(type==null) throw new GdxRuntimeException("Asset not loaded: " + fileName);
 		ObjectMap<String, RefCountedContainer> assetsByType = assets.get(type);
 		if (assetsByType == null) throw new GdxRuntimeException("Asset not loaded: " + fileName);
 		RefCountedContainer assetContainer = assetsByType.get(fileName);
@@ -133,7 +131,7 @@ public class AssetManager implements Disposable {
 		return get(assetDescriptor.fileName, assetDescriptor.type);
 	}
 
-	/** Removes the asset and all its dependencies, if they are not used by other assets.
+	/** Removes the asset and all its dependencies if they are not used by other assets.
 	 * @param fileName the file name */
 	public synchronized void unload (String fileName) {
 		// check if it's in the queue
@@ -145,7 +143,6 @@ public class AssetManager implements Disposable {
 			}
 		}
 		if (foundIndex != -1) {
-			toLoad--;
 			loadQueue.removeIndex(foundIndex);
 			log.debug("Unload (from queue): " + fileName);
 			return;
@@ -280,7 +277,6 @@ public class AssetManager implements Disposable {
 		AssetLoader loader = getLoader(type, fileName);
 		if (loader == null) throw new GdxRuntimeException("No loader for type: " + ClassReflection.getSimpleName(type));
 
-		// reset stats
 		if (loadQueue.size == 0) {
 			loaded = 0;
 			toLoad = 0;
@@ -380,13 +376,9 @@ public class AssetManager implements Disposable {
 	}
 
 	synchronized void injectDependencies (String parentAssetFilename, Array<AssetDescriptor> dependendAssetDescs) {
-		ObjectSet<String> injected = this.injected;
 		for (AssetDescriptor desc : dependendAssetDescs) {
-			if (injected.contains(desc.fileName)) continue; // Ignore subsequent dependencies if there are duplicates.
-			injected.add(desc.fileName);
 			injectDependency(parentAssetFilename, desc);
 		}
-		injected.clear();
 	}
 
 	private synchronized void injectDependency (String parentAssetFilename, AssetDescriptor dependendAssetDesc) {
diff --git a/gdx/src/com/badlogic/gdx/assets/loaders/BitmapFontLoader.java b/gdx/src/com/badlogic/gdx/assets/loaders/BitmapFontLoader.java
index a2a62b1..88fd7ee 100644
--- a/gdx/src/com/badlogic/gdx/assets/loaders/BitmapFontLoader.java
+++ b/gdx/src/com/badlogic/gdx/assets/loaders/BitmapFontLoader.java
@@ -47,17 +47,7 @@ public class BitmapFontLoader extends AsynchronousAssetLoader<BitmapFont, Bitmap
 		}
 		data = new BitmapFontData(file, parameter != null ? parameter.flip : false);
 		for (int i=0; i<data.getImagePaths().length; i++) {
-			TextureLoader.TextureParameter textureParams = new TextureLoader.TextureParameter();
-			
-			if (parameter != null) {
-				textureParams.genMipMaps = parameter.genMipMaps;
-				textureParams.minFilter = parameter.minFilter;
-				textureParams.magFilter = parameter.magFilter;
-			}
-			
-			AssetDescriptor descriptor = new AssetDescriptor(data.getImagePath(i), Texture.class, textureParams);
-			
-			deps.add(descriptor);
+			deps.add(new AssetDescriptor(data.getImagePath(i), Texture.class));
 		}
 		return deps;
 	}
@@ -70,7 +60,11 @@ public class BitmapFontLoader extends AsynchronousAssetLoader<BitmapFont, Bitmap
 	public BitmapFont loadSync (AssetManager manager, String fileName, FileHandle file, BitmapFontParameter parameter) {
 		TextureRegion[] regs = new TextureRegion[data.getImagePaths().length];
 		for (int i=0; i<regs.length; i++) {
-			regs[i] = new TextureRegion(manager.get(data.getImagePath(i), Texture.class));
+			TextureRegion region = new TextureRegion(manager.get(data.getImagePath(i), Texture.class));
+			if (parameter != null) { 
+				region.getTexture().setFilter(parameter.minFilter, parameter.magFilter);
+			}
+			regs[i] = region;
 		}
 		return new BitmapFont(data, regs, true);
 	}
@@ -81,8 +75,6 @@ public class BitmapFontLoader extends AsynchronousAssetLoader<BitmapFont, Bitmap
 	static public class BitmapFontParameter extends AssetLoaderParameters<BitmapFont> {
 		/** whether to flipY the font or not **/
 		public boolean flip = false;
-		/** whether to generate mipmaps **/
-		public boolean genMipMaps = false;
 		/** the minimum filter to be used for the backing texture */
 		public TextureFilter minFilter = TextureFilter.Nearest;
 		/** the maximum filter to be used for the backing texture */
diff --git a/gdx/src/com/badlogic/gdx/graphics/FPSLogger.java b/gdx/src/com/badlogic/gdx/graphics/FPSLogger.java
index 6af6cca..b3525f4 100644
--- a/gdx/src/com/badlogic/gdx/graphics/FPSLogger.java
+++ b/gdx/src/com/badlogic/gdx/graphics/FPSLogger.java
@@ -17,7 +17,6 @@
 package com.badlogic.gdx.graphics;
 
 import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.utils.TimeUtils;
 
 /** A simple helper class to log the frames per seconds achieved. Just invoke the {@link #log()} method in your rendering method.
  * The output will be logged once per second.
@@ -27,14 +26,14 @@ public class FPSLogger {
 	long startTime;
 
 	public FPSLogger () {
-		startTime = TimeUtils.nanoTime();
+		startTime = System.currentTimeMillis();
 	}
 
 	/** Logs the current frames per second to the console. */
 	public void log () {
-		if (TimeUtils.nanoTime() - startTime > 1000000000) /* 1,000,000,000ns == one second*/ {
+		if (System.currentTimeMillis() - startTime > 1000) {
 			Gdx.app.log("FPSLogger", "fps: " + Gdx.graphics.getFramesPerSecond());
-			startTime = TimeUtils.nanoTime();
+			startTime = System.currentTimeMillis();
 		}
 	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFont.java b/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFont.java
index 5455554..0a76a79 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFont.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFont.java
@@ -921,9 +921,7 @@ public class BitmapFont implements Disposable {
 					Glyph glyph = getGlyph((char)first);
 					tokens.nextToken();
 					int amount = Integer.parseInt(tokens.nextToken());
-					if(glyph != null) { // it appears BMFont outputs kerning for glyph pairs not contained in the font, hence the null check						
-						glyph.setKerning(second, amount);
-					}
+					glyph.setKerning(second, amount);
 				}
 
 				Glyph spaceGlyph = getGlyph(' ');
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/Shader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/Shader.java
index d1717f1..9518d54 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/Shader.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/Shader.java
@@ -17,69 +17,20 @@
 package com.badlogic.gdx.graphics.g3d;
 
 import com.badlogic.gdx.graphics.Camera;
-import com.badlogic.gdx.graphics.g3d.utils.BaseShaderProvider;
 import com.badlogic.gdx.graphics.g3d.utils.RenderContext;
-import com.badlogic.gdx.graphics.g3d.utils.ShaderProvider;
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
 import com.badlogic.gdx.utils.Disposable;
-
-/**
- * Interface which is used to render one or more {@link Renderable}s.</p>
- * 
- * A Shader is responsible for the actual rendering of an {@link Renderable}. Typically, when using OpenGL ES 2.0 or higher,
- * it encapsulates a {@link ShaderProgram} and takes care of all OpenGL calls necessary to render the {@link Renderable}.
- * When using OpenGL ES 1.x it takes care of the fixed pipeline.</p>
- * 
- * To start rendering the {@link #begin(Camera, RenderContext)} method must be called. After which the {@link #end()} method
- * must be called to stop rendering. In between one or more calls to the {@link #render(Renderable)} method can be made to
- * render a {@link Renderable}. The {@link #render(Renderable)} method must not be called before a call to 
- * {@link #begin(Camera, RenderContext)} or after a call to {@link #end()}. Each Shader needs exclusive access to the OpenGL
- * state and {@link RenderContext} between the {@link #begin(Camera, RenderContext)} and {@link #end()} methods, therefore
- * only one shader can be used at a time (they must not be nested).</p>
- * 
- * A specific Shader instance might be (and usually is) dedicated to a specific type of {@link Renderable}. For example it
- * might use a {@link ShaderProgram} that is compiled with uniforms (shader input) for specific {@link Attribute} types.
- * Therefore the {@link #canRender(Renderable)} method can be used to check if the Shader instance can be used for a specific
- * {@link Renderable}. Rendering a {@link Renderable} using a Shader for which {@link #canRender(Renderable)} returns false
- * might result in unpredicted behavior or crash the application.</p>
- * 
- * To manage multiple shaders and create a new shader when required, a {@link ShaderProvider} can be used. Therefore, in
- * practice, a specific Shader implementation is usually accompanied by a specific {@link ShaderProvider} implementation
- * (usually extending {@link BaseShaderProvider}).</p>
- * 
- * When a Shader is constructed, the {@link #init()} method must be called before it can be used. Most commonly, the 
- * {@link #init()} method compiles the {@link ShaderProgram}, fetches uniform locations and performs other preparations for
- * usage of the Shader. When the shader is no longer needed, it must disposed using the {@link Disposable#dispose()} method.
- * This, for example, disposed (unloads for memory) the used {@link ShaderProgram}.</p>
- * @author Xoppa
- */
+
 public interface Shader extends Disposable {
-	/** Initializes the Shader, must be called before the Shader can be used. This typically compiles a {@link ShaderProgram},
-	 * fetches uniform locations and performs other preparations for usage of the Shader. */
+	/** Initializes the Shader, must be called before the Shader can be used */
 	void init();
 	/** Compare this shader against the other, used for sorting, light weight shaders are rendered first. */
 	int compareTo(Shader other); // TODO: probably better to add some weight value to sort on
-	/** Checks whether this shader is intended to render the {@link Renderable}. Use this to make sure a call to the
-	 * {@link #render(Renderable)} method will succeed. This is expected to be a fast, non-blocking method. Note that
-	 * this method will only return true if it is intended to be used. Even when it returns false the Shader might still be
-	 * capable of rendering, but it's not preferred to do so.
-	 * @oaram instance The renderable to check against this shader. 
-	 * @return true if this shader is intended to render the {@Renderable}, false otherwise. */
+	/** Whether this shader is intended to render the {@link Renderable} */
 	boolean canRender(Renderable instance);
-	/** Initializes the context for exclusive rendering by this shader. Use the {@link #render(Renderable)} method to render
-	 * a {@link Renderable}. When done rendering the {@link #end()} method must be called.
-	 * @param camera The camera to use when rendering
-	 * @param context The context to be used, which must be exclusive available for the shader until the call to the
-	 * {@link #end()} method. */
+	/** Initializes the context for exclusive rendering by this shader */
 	void begin(Camera camera, RenderContext context);
-	/** Renders the {@link Renderable}, must be called between {@link #begin(Camera, RenderContext)} and {@link #end()}. The
-	 * Shader instance might not be able to render every type of {@link Renderable}s. Use the {@link #canRender(Renderable)}
-	 * method to check if the Shader is capable of rendering a specific {@link Renderable}.
-	 * @param renderable The renderable to render, all required fields (e.g. {@link Renderable#mesh}, 
-	 * {@link Renderable#material} and others) must be set. The {@link Renderable#shader} field will be ignored. */
+	/** Renders the {@link Renderable} must be called between {@link #begin(Camera, RenderContext)} and {@link #end()} */
 	void render(final Renderable renderable);
-	/** Cleanup the context so other shaders can render. Must be called when done rendering using the {@link #render(Renderable)}
-	 * method, which must be preceded by a call to {@link #begin(Camera, RenderContext)}. After a call to this method an call
-	 * to the {@link #render(Renderable)} method will fail until the {@link #begin(Camera, RenderContext)} is called. */
+	/** Cleanup the context so other shaders can render */
 	void end();
 }
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/Node.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/Node.java
index 0d5de8d..bc8f2e2 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/Node.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/model/Node.java
@@ -59,7 +59,7 @@ public class Node {
 	 */
 	public Matrix4 calculateLocalTransform() {
 		if (!isAnimated)
-			localTransform.set(translation, rotation, scale);
+			localTransform.set(translation, rotation, scale);
 		return localTransform;
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/utils/ModelBuilder.java b/gdx/src/com/badlogic/gdx/graphics/g3d/utils/ModelBuilder.java
index fdb5496..330faa1 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/utils/ModelBuilder.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/utils/ModelBuilder.java
@@ -97,7 +97,7 @@ public class ModelBuilder {
 		}
 	}
 
-	/** Adds the {@link Node} to the model and sets it active for building. Use any of the part(...) method to add a NodePart. */
+	/** Adds the {@link Node} to the model and sets it active for building. */
 	protected Node node(final Node node) {
 		if (model == null)
 			throw new GdxRuntimeException("Call begin() first");
@@ -110,7 +110,7 @@ public class ModelBuilder {
 		return node;
 	}
 	
-	/** Add a node to the model. Use any of the part(...) method to add a NodePart.
+	/** Add a node to the model. 
 	 * @return The node being created. */
 	public Node node() {
 		final Node node = new Node();
@@ -119,7 +119,7 @@ public class ModelBuilder {
 		return node;
 	}
 	
-	/** Adds the nodes of the specified model to a new node of the model being build.
+	/** Adds the nodes of the specified model to a new node the model being build.
 	 * After this method the given model can no longer be used. Do not call the {@link Model#dispose()} method on that model. 
 	 * @return The newly created node containing the nodes of the given model. */
 	public Node node(final String id, final Model model) {
@@ -171,9 +171,7 @@ public class ModelBuilder {
 		return part(id, mesh, primitiveType, 0, mesh.getNumIndices(), material);
 	}
 	
-	/** Creates a new MeshPart within the current Node and returns a {@link MeshPartBuilder} which can be used to build the
-	 * shape of the part. If possible a previously used {@link MeshPartBuilder} will be reused, to reduce the number of mesh
-	 * binds. Therefore you can only build one part at a time. 
+	/** Creates a new MeshPart within the current Node.
 	 * The resources the Material might contain are not managed, use {@link #manage(Disposable)} to add those to the model.
 	 * @return The {@link MeshPartBuilder} you can use to build the MeshPart. */ 
 	private MeshPartBuilder part(final String id, int primitiveType, final VertexAttributes attributes, final Material material) {
@@ -182,9 +180,7 @@ public class ModelBuilder {
 		return builder;
 	}
 	
-	/** Creates a new MeshPart within the current Node and returns a {@link MeshPartBuilder} which can be used to build the
-	 * shape of the part. If possible a previously used {@link MeshPartBuilder} will be reused, to reduce the number of mesh
-	 * binds. Therefore you can only build one part at a time.
+	/** Creates a new MeshPart within the current Node.
 	 * The resources the Material might contain are not managed, use {@link #manage(Disposable)} to add those to the model.
 	 * @param attributes bitwise mask of the {@link com.badlogic.gdx.graphics.VertexAttributes.Usage}, 
 	 * only Position, Color, Normal and TextureCoordinates is supported.
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/MipMapGenerator.java b/gdx/src/com/badlogic/gdx/graphics/glutils/MipMapGenerator.java
index 3e3b530..99c3746 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/MipMapGenerator.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/MipMapGenerator.java
@@ -53,7 +53,7 @@ public class MipMapGenerator {
 			return;
 		}
 
-		if (Gdx.app.getType() == ApplicationType.Android || Gdx.app.getType() == ApplicationType.WebGL || Gdx.app.getType() == ApplicationType.iOS) {
+		if (Gdx.app.getType() == ApplicationType.Android || Gdx.app.getType() == ApplicationType.WebGL) {
 			if (Gdx.graphics.isGL20Available())
 				generateMipMapGLES20(target, pixmap);
 			else
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/TmxMapHelper.java b/gdx/src/com/badlogic/gdx/maps/tiled/TmxMapHelper.java
index a5fab68..b349f3c 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/TmxMapHelper.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/TmxMapHelper.java
@@ -27,9 +27,9 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
 import com.badlogic.gdx.utils.StreamUtils;
 import com.badlogic.gdx.utils.XmlReader.Element;
 
-/** Helper class for common tiled map tasks.
+/** Package private helper class for common tiled map tasks.
  * @author hneuer */
-public final class TmxMapHelper {
+class TmxMapHelper {
 	static final int FLAG_FLIP_HORIZONTALLY = 0x80000000;
 	static final int FLAG_FLIP_VERTICALLY = 0x40000000;
 	static final int FLAG_FLIP_DIAGONALLY = 0x20000000;
@@ -39,7 +39,7 @@ public final class TmxMapHelper {
 
 	}
 
-	static public int[] getTileIds (Element element, int width, int height) {
+	static int[] getTileIds (Element element, int width, int height) {
 		Element data = element.getChildByName("data");
 		String encoding = data.getAttribute("encoding", null);
 		if (encoding == null) { // no 'encoding' attribute means that the encoding is XML
@@ -95,7 +95,7 @@ public final class TmxMapHelper {
 		return ids;
 	}
 
-	static public int unsignedByteToInt (byte b) {
+	static int unsignedByteToInt (byte b) {
 		return (int)b & 0xFF;
 	}
 }
diff --git a/gdx/src/com/badlogic/gdx/math/Bresenham2.java b/gdx/src/com/badlogic/gdx/math/Bresenham2.java
index 1ec26f2..d3c6fdb 100644
--- a/gdx/src/com/badlogic/gdx/math/Bresenham2.java
+++ b/gdx/src/com/badlogic/gdx/math/Bresenham2.java
@@ -45,7 +45,7 @@ public class Bresenham2 {
 	 * @return the list of points on the line at integer coordinates
 	 */
 	public Array<GridPoint2> line(GridPoint2 start, GridPoint2 end) {
-		return line(start.x, start.y, end.x, end.y);
+		return line(start.x, start.y, end.y, end.y);
 	}
 	
 	/**
diff --git a/gdx/src/com/badlogic/gdx/math/Frustum.java b/gdx/src/com/badlogic/gdx/math/Frustum.java
index fc9e35a..82e28c3 100644
--- a/gdx/src/com/badlogic/gdx/math/Frustum.java
+++ b/gdx/src/com/badlogic/gdx/math/Frustum.java
@@ -24,7 +24,7 @@ import com.badlogic.gdx.math.collision.BoundingBox;
 
 /**
  * A truncated rectangular pyramid.  Used to define the viewable region and its projection onto the screen.  
- * @see Camera#frustum
+ * See {@link Camera#frustum}.
  */
 public class Frustum {
 	protected static final Vector3[] clipSpacePlanePoints = {new Vector3(-1, -1, -1), new Vector3(1, -1, -1),
@@ -41,7 +41,7 @@ public class Frustum {
 		}
 	}
 
-	/** the six clipping planes, near, far, left, right, top, bottom **/
+	/** the six clipping planes, near, far, left, right, top, bottm **/
 	public final Plane[] planes = new Plane[6];
 
 	/** eight points making up the near and far clipping "rectangles". order is counter clockwise, starting at bottom left **/
@@ -173,30 +173,6 @@ public class Frustum {
 
 		return true;
 	}
-	
-	/** Returns whether the given bounding box is in the frustum.
-	 * @return Whether the bounding box is in the frustum */
-	public boolean boundsInFrustum (Vector3 center, Vector3 dimensions) {
-		return boundsInFrustum(center.x, center.y, center.z, dimensions.x/2, dimensions.y/2, dimensions.z/2);
-	}
-	
-	/** Returns whether the given bounding box is in the frustum.
-	 * @return Whether the bounding box is in the frustum */
-	public boolean boundsInFrustum (float x, float y, float z, float halfWidth, float halfHeight, float halfDepth) {
-		for (int i = 0, len2 = planes.length; i < len2; i++) {
-			if (planes[i].testPoint(x+halfWidth, y+halfHeight, z+halfDepth) != PlaneSide.Back) continue;
-			if (planes[i].testPoint(x+halfWidth, y+halfHeight, z-halfDepth) != PlaneSide.Back) continue;
-			if (planes[i].testPoint(x+halfWidth, y-halfHeight, z+halfDepth) != PlaneSide.Back) continue;
-			if (planes[i].testPoint(x+halfWidth, y-halfHeight, z-halfDepth) != PlaneSide.Back) continue;
-			if (planes[i].testPoint(x-halfWidth, y+halfHeight, z+halfDepth) != PlaneSide.Back) continue;
-			if (planes[i].testPoint(x-halfWidth, y+halfHeight, z-halfDepth) != PlaneSide.Back) continue;
-			if (planes[i].testPoint(x-halfWidth, y-halfHeight, z+halfDepth) != PlaneSide.Back) continue;
-			if (planes[i].testPoint(x-halfWidth, y-halfHeight, z-halfDepth) != PlaneSide.Back) continue;
-			return false;
-		}
-
-		return true;
-	}
 
 // /**
 // * Calculates the pick ray for the given window coordinates. Assumes the window coordinate system has it's y downwards. The
diff --git a/gdx/src/com/badlogic/gdx/math/MathUtils.java b/gdx/src/com/badlogic/gdx/math/MathUtils.java
index 410ba35..d695460 100644
--- a/gdx/src/com/badlogic/gdx/math/MathUtils.java
+++ b/gdx/src/com/badlogic/gdx/math/MathUtils.java
@@ -43,13 +43,11 @@ public class MathUtils {
 	static private final float radToIndex = SIN_COUNT / radFull;
 	static private final float degToIndex = SIN_COUNT / degFull;
 
-	/** multiply by this to convert from radians to degrees */
 	static public final float radiansToDegrees = 180f / PI;
 	static public final float radDeg = radiansToDegrees;
-	/** multiply by this to convert from degrees to radians */
 	static public final float degreesToRadians = PI / 180;
 	static public final float degRad = degreesToRadians;
-	
+
 	static private class Sin {
 		static final float[] table = new float[SIN_COUNT];
 		static {
diff --git a/gdx/src/com/badlogic/gdx/math/Matrix3.java b/gdx/src/com/badlogic/gdx/math/Matrix3.java
index 3f50596..3773a38 100644
--- a/gdx/src/com/badlogic/gdx/math/Matrix3.java
+++ b/gdx/src/com/badlogic/gdx/math/Matrix3.java
@@ -25,6 +25,7 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
  * @author mzechner */
 public class Matrix3 implements Serializable {
 	private static final long serialVersionUID = 7907569533774959788L;
+	private final static float DEGREE_TO_RAD = (float)Math.PI / 180;
 	public static final int M00 = 0;
 	public static final int M01 = 3;
 	public static final int M02 = 6;
@@ -105,15 +106,9 @@ public class Matrix3 implements Serializable {
 	 * @param degrees the angle in degrees.
 	 * @return This matrix for the purpose of chaining operations. */
 	public Matrix3 setToRotation (float degrees) {
-		return setToRotationRad(MathUtils.degreesToRadians * degrees);
-	}
-
-	/** Sets this matrix to a rotation matrix that will rotate any vector in counter-clockwise direction around the z-axis.
-	 * @param radians the angle in degrees.
-	 * @return This matrix for the purpose of chaining operations. */
-	public Matrix3 setToRotationRad (float radians) {
-		float cos = (float)Math.cos(radians);
-		float sin = (float)Math.sin(radians);
+		float angle = DEGREE_TO_RAD * degrees;
+		float cos = (float)Math.cos(angle);
+		float sin = (float)Math.sin(angle);
 
 		this.val[M00] = cos;
 		this.val[M10] = sin;
@@ -339,17 +334,10 @@ public class Matrix3 implements Serializable {
 	 * @param degrees The angle in degrees
 	 * @return This matrix for the purpose of chaining. */
 	public Matrix3 rotate (float degrees) {
-		return rotateRad(MathUtils.degreesToRadians * degrees);
-	}
-
-	/** Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x
-	 * glTranslate/glRotate/glScale.
-	 * @param radians The angle in degrees
-	 * @return This matrix for the purpose of chaining. */
-	public Matrix3 rotateRad (float radians) {
-		if (radians == 0) return this;
-		float cos = (float)Math.cos(radians);
-		float sin = (float)Math.sin(radians);
+		if (degrees == 0) return this;
+		degrees = DEGREE_TO_RAD * degrees;
+		float cos = (float)Math.cos(degrees);
+		float sin = (float)Math.sin(degrees);
 
 		tmp[M00] = cos;
 		tmp[M10] = sin;
@@ -422,11 +410,7 @@ public class Matrix3 implements Serializable {
 	}
 	
 	public float getRotation () {
-		return MathUtils.radiansToDegrees * (float)Math.atan2(val[M10], val[M00]);
-	}
-	
-	public float getRotationRad () {
-		return (float)Math.atan2(val[M10], val[M00]);
+		return MathUtils.radDeg * (float)Math.atan2(val[M10], val[M00]);
 	}
 	
 	/** Scale the matrix in the both the x and y components by the scalar value.
diff --git a/gdx/src/com/badlogic/gdx/math/Matrix4.java b/gdx/src/com/badlogic/gdx/math/Matrix4.java
index df44e77..9ef07c0 100644
--- a/gdx/src/com/badlogic/gdx/math/Matrix4.java
+++ b/gdx/src/com/badlogic/gdx/math/Matrix4.java
@@ -28,54 +28,22 @@ import java.io.Serializable;
  * @author badlogicgames@gmail.com */
 public class Matrix4 implements Serializable {
 	private static final long serialVersionUID = -2717655254359579617L;
-	/** XX: Typically the unrotated X component for scaling, also the cosine of the angle when rotated on the Y and/or Z axis. 
-	 * On Vector3 multiplication this value is multiplied with the source X component and added to the target X component. */ 
-	public static final int M00 = 0;
-	/** XY: Typically the negative sine of the angle when rotated on the Z axis.
-	 * On Vector3 multiplication this value is multiplied with the source Y component and added to the target X component. */
-	public static final int M01 = 4;
-	/** XZ: Typically the sine of the angle when rotated on the Y axis.
-	 * On Vector3 multiplication this value is multiplied with the source Z component and added to the target X component. */
-	public static final int M02 = 8;
-	/** XW: Typically the translation of the X component.
-	 * On Vector3 multiplication this value is added to the target X component. */ 
-	public static final int M03 = 12;
-	/** YX: Typically the sine of the angle when rotated on the Z axis.
-	 * On Vector3 multiplication this value is multiplied with the source X component and added to the target Y component. */
-	public static final int M10 = 1;
-	/** YY: Typically the unrotated Y component for scaling, also the cosine of the angle when rotated on the X and/or Z axis.
-	 * On Vector3 multiplication this value is multiplied with the source Y component and added to the target Y component. */
-	public static final int M11 = 5;
-	/** YZ: Typically the negative sine of the angle when rotated on the X axis.
-	 * On Vector3 multiplication this value is multiplied with the source Z component and added to the target Y component. */
-	public static final int M12 = 9;
-	/** YW: Typically the translation of the Y component.
-	 * On Vector3 multiplication this value is added to the target Y component. */
-	public static final int M13 = 13;
-	/** ZX: Typically the negative sine of the angle when rotated on the Y axis.
-	 * On Vector3 multiplication this value is multiplied with the source X component and added to the target Z component. */
-	public static final int M20 = 2;
-	/** ZY: Typical the sine of the angle when rotated on the X axis.
-	 * On Vector3 multiplication this value is multiplied with the source Y component and added to the target Z component. */
-	public static final int M21 = 6;
-	/** ZZ: Typically the unrotated Z component for scaling, also the cosine of the angle when rotated on the X and/or Y axis.
-	 * On Vector3 multiplication this value is multiplied with the source Z component and added to the target Z component. */
-	public static final int M22 = 10;
-	/** ZW: Typically the translation of the Z component.
-	 * On Vector3 multiplication this value is added to the target Z component. */
-	public static final int M23 = 14;
-	/** WX: Typically the value zero.
-	 * On Vector3 multiplication this value is ignored. */
-	public static final int M30 = 3;
-	/** WY: Typically the value zero.
-	 * On Vector3 multiplication this value is ignored. */
-	public static final int M31 = 7;
-	/** WZ: Typically the value zero.
-	 * On Vector3 multiplication this value is ignored. */
-	public static final int M32 = 11;
-	/** WW: Typically the value one.
-	 * On Vector3 multiplication this value is ignored. */
-	public static final int M33 = 15;
+	public static final int M00 = 0;// 0;
+	public static final int M01 = 4;// 1;
+	public static final int M02 = 8;// 2;
+	public static final int M03 = 12;// 3;
+	public static final int M10 = 1;// 4;
+	public static final int M11 = 5;// 5;
+	public static final int M12 = 9;// 6;
+	public static final int M13 = 13;// 7;
+	public static final int M20 = 2;// 8;
+	public static final int M21 = 6;// 9;
+	public static final int M22 = 10;// 10;
+	public static final int M23 = 14;// 11;
+	public static final int M30 = 3;// 12;
+	public static final int M31 = 7;// 13;
+	public static final int M32 = 11;// 14;
+	public static final int M33 = 15;// 15;
 
 	public final float tmp[] = new float[16];
 	public final float val[] = new float[16];
@@ -146,58 +114,38 @@ public class Matrix4 implements Serializable {
 	
 	/** Sets the matrix to a rotation matrix representing the quaternion.
 	 * 
-	 * @param quaternionX The X component of the quaternion that is to be used to set this matrix.
-	 * @param quaternionY The Y component of the quaternion that is to be used to set this matrix.
-	 * @param quaternionZ The Z component of the quaternion that is to be used to set this matrix.
-	 * @param quaternionW The W component of the quaternion that is to be used to set this matrix.
+	 * @param x The X component of the quaternion that is to be used to set this matrix.
+	 * @param y The Y component of the quaternion that is to be used to set this matrix.
+	 * @param z The Z component of the quaternion that is to be used to set this matrix.
+	 * @param w The W component of the quaternion that is to be used to set this matrix.
 	 * @return This matrix for the purpose of chaining methods together. */
-	public Matrix4 set(float quaternionX, float quaternionY, float quaternionZ, float quaternionW) {
-		return set(0f, 0f, 0f, quaternionX, quaternionY, quaternionZ, quaternionW);
-	}
-	
-	/** Set this matrix to the specified translation and rotation.
-	 * @param position The translation
-	 * @param orientation The rotation, must be normalized
-	 * @return This matrix for chaining */
-	public Matrix4 set (Vector3 position, Quaternion orientation) {
-		return set(position.x, position.y, position.z, orientation.x, orientation.y, orientation.z, orientation.w);
-	}
-		
-	/** Sets the matrix to a rotation matrix representing the translation and quaternion.
-	 * 
-	 * @param translationX The X component of the translation that is to be used to set this matrix.
-	 * @param translationY The Y component of the translation that is to be used to set this matrix.
-	 * @param translationZ The Z component of the translation that is to be used to set this matrix.
-	 * @param quaternionX The X component of the quaternion that is to be used to set this matrix.
-	 * @param quaternionY The Y component of the quaternion that is to be used to set this matrix.
-	 * @param quaternionZ The Z component of the quaternion that is to be used to set this matrix.
-	 * @param quaternionW The W component of the quaternion that is to be used to set this matrix.
-	 * @return This matrix for the purpose of chaining methods together. */
-	public Matrix4 set(float translationX, float translationY, float translationZ, float quaternionX, float quaternionY, float quaternionZ, float quaternionW) {
-		final float xs = quaternionX * 2f,	ys = quaternionY * 2f,	zs = quaternionZ * 2f;
-		final float wx = quaternionW * xs,	wy = quaternionW * ys, 	wz = quaternionW * zs;
-		final float xx = quaternionX * xs,	xy = quaternionX * ys, 	xz = quaternionX * zs;
-		final float yy = quaternionY * ys,	yz = quaternionY * zs,	zz = quaternionZ * zs;
-
-		val[M00] = (1.0f - (yy + zz));
-		val[M01] = (xy - wz);
-		val[M02] = (xz + wy);
-		val[M03] = translationX;
-		
-		val[M10] = (xy + wz);
-		val[M11] = (1.0f - (xx + zz));
-		val[M12] = (yz - wx);
-		val[M13] = translationY;
-		
-		val[M20] = (xz - wy);
-		val[M21] = (yz + wx);
-		val[M22] = (1.0f - (xx + yy));
-		val[M23] = translationZ;
-		
-		val[M30] = 0.f;
-		val[M31] = 0.f;
-		val[M32] = 0.f;
-		val[M33] = 1.0f;
+	public Matrix4 set(float x, float y, float z, float w) {
+		float l_xx = x * x;
+		float l_xy = x * y;
+		float l_xz = x * z;
+		float l_xw = x * w;
+		float l_yy = y * y;
+		float l_yz = y * z;
+		float l_yw = y * w;
+		float l_zz = z * z;
+		float l_zw = z * w;
+		// Set matrix from quaternion
+		val[M00] = 1 - 2 * (l_yy + l_zz);
+		val[M01] = 2 * (l_xy - l_zw);
+		val[M02] = 2 * (l_xz + l_yw);
+		val[M03] = 0;
+		val[M10] = 2 * (l_xy + l_zw);
+		val[M11] = 1 - 2 * (l_xx + l_zz);
+		val[M12] = 2 * (l_yz - l_xw);
+		val[M13] = 0;
+		val[M20] = 2 * (l_xz - l_yw);
+		val[M21] = 2 * (l_yz + l_xw);
+		val[M22] = 1 - 2 * (l_xx + l_yy);
+		val[M23] = 0;
+		val[M30] = 0;
+		val[M31] = 0;
+		val[M32] = 0;
+		val[M33] = 1;
 		return this;
 	}
 	
@@ -207,47 +155,31 @@ public class Matrix4 implements Serializable {
 	 * @param scale The scale
 	 * @return This matrix for chaining */
 	public Matrix4 set (Vector3 position, Quaternion orientation, Vector3 scale) {
-		return set(position.x, position.y, position.z, orientation.x, orientation.y, orientation.z, orientation.w, scale.x, scale.y, scale.z);
-	}
-	
-	/** Sets the matrix to a rotation matrix representing the translation and quaternion.
-	 * 
-	 * @param translationX The X component of the translation that is to be used to set this matrix.
-	 * @param translationY The Y component of the translation that is to be used to set this matrix.
-	 * @param translationZ The Z component of the translation that is to be used to set this matrix.
-	 * @param quaternionX The X component of the quaternion that is to be used to set this matrix.
-	 * @param quaternionY The Y component of the quaternion that is to be used to set this matrix.
-	 * @param quaternionZ The Z component of the quaternion that is to be used to set this matrix.
-	 * @param quaternionW The W component of the quaternion that is to be used to set this matrix.
-	 * @param scaleX The X component of the scaling that is to be used to set this matrix.
-	 * @param scaleY The Y component of the scaling that is to be used to set this matrix.
-	 * @param scaleZ The Z component of the scaling that is to be used to set this matrix. 
-	 * @return This matrix for the purpose of chaining methods together. */
-	public Matrix4 set(float translationX, float translationY, float translationZ, float quaternionX, float quaternionY, float quaternionZ, float quaternionW, float scaleX, float scaleY, float scaleZ) {
-		final float xs = quaternionX * 2f,	ys = quaternionY * 2f,	zs = quaternionZ * 2f;
-		final float wx = quaternionW * xs,	wy = quaternionW * ys, 	wz = quaternionW * zs;
-		final float xx = quaternionX * xs,	xy = quaternionX * ys, 	xz = quaternionX * zs;
-		final float yy = quaternionY * ys,	yz = quaternionY * zs,	zz = quaternionZ * zs;
-
-		val[M00] = scaleX * (1.0f - (yy + zz));
-		val[M01] = scaleY * (xy - wz);
-		val[M02] = scaleZ * (xz + wy);
-		val[M03] = translationX;
+		final float xs = orientation.x * 2f,	ys = orientation.y * 2f,	zs = orientation.z * 2f;
+		final float wx = orientation.w * xs,	wy = orientation.w * ys, 	wz = orientation.w * zs;
+		final float xx = orientation.x * xs,	xy = orientation.x * ys, 	xz = orientation.x * zs;
+		final float yy = orientation.y * ys,	yz = orientation.y * zs,	zz = orientation.z * zs;
+
+		val[M00] = scale.x * (1.0f - (yy + zz));
+		val[M01] = scale.x * (xy - wz);
+		val[M02] = scale.x * (xz + wy);
+		val[M03] = position.x;
 		
-		val[M10] = scaleX * (xy + wz);
-		val[M11] = scaleY * (1.0f - (xx + zz));
-		val[M12] = scaleZ * (yz - wx);
-		val[M13] = translationY;
+		val[M10] = scale.y * (xy + wz);
+		val[M11] = scale.y * (1.0f - (xx + zz));
+		val[M12] = scale.y * (yz - wx);
+		val[M13] = position.y;
 		
-		val[M20] = scaleX * (xz - wy);
-		val[M21] = scaleY * (yz + wx);
-		val[M22] = scaleZ * (1.0f - (xx + yy));
-		val[M23] = translationZ;
+		val[M20] = scale.z * (xz - wy);
+		val[M21] = scale.z * (yz + wx);
+		val[M22] = scale.z * (1.0f - (xx + yy));
+		val[M23] = position.z;
 		
-		val[M30] = 0.f;
-		val[M31] = 0.f;
-		val[M32] = 0.f;
+		val[M30] = 0.0f;
+		val[M31] = 0.0f;
+		val[M32] = 0.0f;
 		val[M33] = 1.0f;
+		
 		return this;
 	}
 
@@ -660,19 +592,6 @@ public class Matrix4 implements Serializable {
 
 	/** Sets the matrix to a rotation matrix around the given axis.
 	 * 
-	 * @param axis The axis
-	 * @param radians The angle in degrees
-	 * @return This matrix for the purpose of chaining methods together. */
-	public Matrix4 setToRotationRad (Vector3 axis, float radians) {
-		if (radians == 0) {
-			idt();
-			return this;
-		}
-		return set(quat.setFromAxisRad(axis, radians));
-	}
-
-	/** Sets the matrix to a rotation matrix around the given axis.
-	 * 
 	 * @param axisX The x-component of the axis
 	 * @param axisY The y-component of the axis
 	 * @param axisZ The z-component of the axis
@@ -686,21 +605,6 @@ public class Matrix4 implements Serializable {
 		return set(quat.setFromAxis(axisX, axisY, axisZ, degrees));
 	}
 
-	/** Sets the matrix to a rotation matrix around the given axis.
-	 * 
-	 * @param axisX The x-component of the axis
-	 * @param axisY The y-component of the axis
-	 * @param axisZ The z-component of the axis
-	 * @param radians The angle in degrees
-	 * @return This matrix for the purpose of chaining methods together. */
-	public Matrix4 setToRotationRad (float axisX, float axisY, float axisZ, float radians) {
-		if (radians == 0) {
-			idt();
-			return this;
-		}
-		return set(quat.setFromAxisRad(axisX, axisY, axisZ, radians));
-	}
-
 	/** Set the matrix to a rotation matrix between two vectors.
 	 * @param v1 The base vector
 	 * @param v2 The target vector
@@ -882,21 +786,6 @@ public class Matrix4 implements Serializable {
 		return position;
 	}
 
-	/**
-	 * Gets the rotation of this matrix.
-	 * @param rotation The {@link Quaternion} to receive the rotation
-	 * @param normalizeAxes True to normalize the axes, necessary when the matrix might also include scaling.
-	 * @return The provided {@link Quaternion} for chaining.
-	 */
-	public Quaternion getRotation (Quaternion rotation, boolean normalizeAxes) {
-		return rotation.setFromMatrix(normalizeAxes, this);
-	}
-	
-	/**
-	 * Gets the rotation of this matrix.
-	 * @param rotation The {@link Quaternion} to receive the rotation
-	 * @return The provided {@link Quaternion} for chaining.
-	 */
 	public Quaternion getRotation (Quaternion rotation) {
 		return rotation.setFromMatrix(this);
 	}
@@ -1220,18 +1109,6 @@ public class Matrix4 implements Serializable {
 	}
 
 	/** Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x
-	 * glTranslate/glRotate/glScale.
-	 * 
-	 * @param axis The vector axis to rotate around.
-	 * @param radians The angle in radians.
-	 * @return This matrix for the purpose of chaining methods together. */
-	public Matrix4 rotateRad (Vector3 axis, float radians) {
-		if (radians == 0) return this;
-		quat.setFromAxisRad(axis, radians);
-		return rotate(quat);
-	}
-
-	/** Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x
 	 * glTranslate/glRotate/glScale
 	 * @param axisX The x-axis component of the vector to rotate around.
 	 * @param axisY The y-axis component of the vector to rotate around.
@@ -1245,19 +1122,6 @@ public class Matrix4 implements Serializable {
 	}
 
 	/** Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x
-	 * glTranslate/glRotate/glScale
-	 * @param axisX The x-axis component of the vector to rotate around.
-	 * @param axisY The y-axis component of the vector to rotate around.
-	 * @param axisZ The z-axis component of the vector to rotate around.
-	 * @param radians The angle in radians
-	 * @return This matrix for the purpose of chaining methods together. */
-	public Matrix4 rotateRad (float axisX, float axisY, float axisZ, float radians) {
-		if (radians == 0) return this;
-		quat.setFromAxisRad(axisX, axisY, axisZ, radians);
-		return rotate(quat);
-	}
-
-	/** Postmultiplies this matrix with a (counter-clockwise) rotation matrix. Postmultiplication is also used by OpenGL ES' 1.x
 	 * glTranslate/glRotate/glScale.
 	 * 
 	 * @param rotation
diff --git a/gdx/src/com/badlogic/gdx/math/Quaternion.java b/gdx/src/com/badlogic/gdx/math/Quaternion.java
index 72f8fd3..c9de819 100644
--- a/gdx/src/com/badlogic/gdx/math/Quaternion.java
+++ b/gdx/src/com/badlogic/gdx/math/Quaternion.java
@@ -107,22 +107,16 @@ public class Quaternion implements Serializable {
 	public String toString () {
 		return "[" + x + "|" + y + "|" + z + "|" + w + "]";
 	}
-	
-	/** Sets the quaternion to the given euler angles in degrees.
+
+	/** Sets the quaternion to the given euler angles.
 	 * @param yaw the yaw in degrees
 	 * @param pitch the pitch in degress
 	 * @param roll the roll in degess
 	 * @return this quaternion */
 	public Quaternion setEulerAngles (float yaw, float pitch, float roll) {
-		return setEulerAnglesRad(yaw * MathUtils.degreesToRadians, pitch * MathUtils.degreesToRadians, roll * MathUtils.degreesToRadians);
-	}
-
-	/** Sets the quaternion to the given euler angles in radians.
-	 * @param yaw the yaw in radians
-	 * @param pitch the pitch in radians
-	 * @param roll the roll in radians
-	 * @return this quaternion */
-	public Quaternion setEulerAnglesRad (float yaw, float pitch, float roll) {
+		yaw = (float)Math.toRadians(yaw);
+		pitch = (float)Math.toRadians(pitch);
+		roll = (float)Math.toRadians(roll);
 		float num9 = roll * 0.5f;
 		float num6 = (float)Math.sin(num9);
 		float num5 = (float)Math.cos(num9);
@@ -264,72 +258,41 @@ public class Quaternion implements Serializable {
 	/** Sets the quaternion components from the given axis and angle around that axis.
 	 * 
 	 * @param axis The axis
-	 * @param degrees The angle in degrees
-	 * @return This quaternion for chaining. */
-	public Quaternion setFromAxis (final Vector3 axis, final float degrees) {
-		return setFromAxis(axis.x, axis.y, axis.z, degrees);
-	}
-	
-	/** Sets the quaternion components from the given axis and angle around that axis.
-	 * 
-	 * @param axis The axis
-	 * @param radians The angle in radians
-	 * @return This quaternion for chaining. */
-	public Quaternion setFromAxisRad (final Vector3 axis, final float radians) {
-		return setFromAxisRad(axis.x, axis.y, axis.z, radians);
-	}
-
-	/** Sets the quaternion components from the given axis and angle around that axis.
-	 * @param x X direction of the axis
-	 * @param y Y direction of the axis
-	 * @param z Z direction of the axis
-	 * @param degrees The angle in degrees
+	 * @param angle The angle in degrees
 	 * @return This quaternion for chaining. */
-	public Quaternion setFromAxis (final float x, final float y, final float z, final float degrees) {
-		return setFromAxisRad(x, y, z, degrees * MathUtils.degreesToRadians);
+	public Quaternion setFromAxis (final Vector3 axis, final float angle) {
+		return setFromAxis(axis.x, axis.y, axis.z, angle);
 	}
 
 	/** Sets the quaternion components from the given axis and angle around that axis.
 	 * @param x X direction of the axis
 	 * @param y Y direction of the axis
 	 * @param z Z direction of the axis
-	 * @param radians The angle in radians
+	 * @param angle The angle in degrees
 	 * @return This quaternion for chaining. */
-	public Quaternion setFromAxisRad (final float x, final float y, final float z, final float radians) {
+	public Quaternion setFromAxis (final float x, final float y, final float z, final float angle) {
 		float d = Vector3.len(x, y, z);
 		if (d == 0f)
 			return idt();
 		d = 1f /d;
-		float l_ang = radians;
+		float l_ang = angle * MathUtils.degreesToRadians;
 		float l_sin = (float)Math.sin(l_ang / 2);
 		float l_cos = (float)Math.cos(l_ang / 2);
 		return this.set(d * x * l_sin, d * y * l_sin, d * z * l_sin, l_cos).nor();
 	}
 
-	/** Sets the Quaternion from the given matrix, optionally removing any scaling. */
-	public Quaternion setFromMatrix (boolean normalizeAxes, Matrix4 matrix) {
-		return setFromAxes(normalizeAxes,  matrix.val[Matrix4.M00], matrix.val[Matrix4.M01], matrix.val[Matrix4.M02],
-			matrix.val[Matrix4.M10], matrix.val[Matrix4.M11], matrix.val[Matrix4.M12],
-			matrix.val[Matrix4.M20], matrix.val[Matrix4.M21], matrix.val[Matrix4.M22]);
-	}
-	
-	/** Sets the Quaternion from the given rotation matrix, which must not contain scaling. */
+// fromRotationMatrix(xAxis.x, yAxis.x, zAxis.x, xAxis.y, yAxis.y, zAxis.y,
+// xAxis.z, yAxis.z, zAxis.z);
+
+// final float m00, final float m01, final float m02, final float m10,
+// final float m11, final float m12, final float m20, final float m21, final float m22
+
 	public Quaternion setFromMatrix (Matrix4 matrix) {
-		return setFromMatrix(false, matrix);
-	}
-	
-	/** Sets the Quaternion from the given matrix, optionally removing any scaling. */
-	public Quaternion setFromMatrix (boolean normalizeAxes, Matrix3 matrix) {
-		return setFromAxes(normalizeAxes, matrix.val[Matrix3.M00], matrix.val[Matrix3.M01], matrix.val[Matrix3.M02],
-			matrix.val[Matrix3.M10], matrix.val[Matrix3.M11], matrix.val[Matrix3.M12],
-			matrix.val[Matrix3.M20], matrix.val[Matrix3.M21], matrix.val[Matrix3.M22]);
+		return setFromAxes(matrix.val[Matrix4.M00], matrix.val[Matrix4.M01], matrix.val[Matrix4.M02], matrix.val[Matrix4.M10],
+			matrix.val[Matrix4.M11], matrix.val[Matrix4.M12], matrix.val[Matrix4.M20], matrix.val[Matrix4.M21],
+			matrix.val[Matrix4.M22]);
 	}
-	
-	/** Sets the Quaternion from the given rotation matrix, which must not contain scaling. */ 
-	public Quaternion setFromMatrix (Matrix3 matrix) {
-		return setFromMatrix(false, matrix);
-	}
-	
+
 	/** <p>
 	 * Sets the Quaternion from the given x-, y- and z-axis which have to be orthonormal.
 	 * </p>
@@ -349,46 +312,12 @@ public class Quaternion implements Serializable {
 	 * @param zy z-axis y-coordinate
 	 * @param zz z-axis z-coordinate */
 	public Quaternion setFromAxes (float xx, float xy, float xz, float yx, float yy, float yz, float zx, float zy, float zz) {
-		return setFromAxes (false, xx, xy, xz, yx, yy, yz, zx, zy, zz);
-	}
-
-	/** <p>
-	 * Sets the Quaternion from the given x-, y- and z-axis.
-	 * </p>
-	 * 
-	 * <p>
-	 * Taken from Bones framework for JPCT, see http://www.aptalkarga.com/bones/ which in turn took it from Graphics Gem code at
-	 * ftp://ftp.cis.upenn.edu/pub/graphics/shoemake/quatut.ps.Z.
-	 * </p>
-	 * 
-	 * @param normalizeAxes whether to normalize the axes (necessary when they contain scaling)
-	 * @param xx x-axis x-coordinate
-	 * @param xy x-axis y-coordinate
-	 * @param xz x-axis z-coordinate
-	 * @param yx y-axis x-coordinate
-	 * @param yy y-axis y-coordinate
-	 * @param yz y-axis z-coordinate
-	 * @param zx z-axis x-coordinate
-	 * @param zy z-axis y-coordinate
-	 * @param zz z-axis z-coordinate */
-	public Quaternion setFromAxes (boolean normalizeAxes, float xx, float xy, float xz, float yx, float yy, float yz, float zx, float zy, float zz) {
-		if (normalizeAxes) {
-			final float lx = 1f / Vector3.len(xx, xy, xz);
-			final float ly = 1f / Vector3.len(yx, yy, yz);
-			final float lz = 1f / Vector3.len(zx, zy, zz);
-			xx *= lx;
-			xy *= lx;
-			xz *= lx;
-			yz *= ly;
-			yy *= ly;
-			yz *= ly;
-			zx *= lz;
-			zy *= lz;
-			zz *= lz;
-		}
 		// the trace is the sum of the diagonal elements; see
 		// http://mathworld.wolfram.com/MatrixTrace.html
-		final float t = xx + yy + zz;
+		final float m00 = xx, m01 = xy, m02 = xz;
+		final float m10 = yx, m11 = yy, m12 = yz;
+		final float m20 = zx, m21 = zy, m22 = zz;
+		final float t = m00 + m11 + m22;
 
 		// we protect the division by s by ensuring that s>=1
 		double x, y, z, w;
@@ -396,30 +325,30 @@ public class Quaternion implements Serializable {
 			double s = Math.sqrt(t + 1); // |s|>=1 ...
 			w = 0.5 * s;
 			s = 0.5 / s; // so this division isn't bad
-			x = (zy - yz) * s;
-			y = (xz - zx) * s;
-			z = (yx - xy) * s;
-		} else if ((xx > yy) && (xx > zz)) {
-			double s = Math.sqrt(1.0 + xx - yy - zz); // |s|>=1
+			x = (m21 - m12) * s;
+			y = (m02 - m20) * s;
+			z = (m10 - m01) * s;
+		} else if ((m00 > m11) && (m00 > m22)) {
+			double s = Math.sqrt(1.0 + m00 - m11 - m22); // |s|>=1
 			x = s * 0.5; // |x| >= .5
 			s = 0.5 / s;
-			y = (yx + xy) * s;
-			z = (xz + zx) * s;
-			w = (zy - yz) * s;
-		} else if (yy > zz) {
-			double s = Math.sqrt(1.0 + yy - xx - zz); // |s|>=1
+			y = (m10 + m01) * s;
+			z = (m02 + m20) * s;
+			w = (m21 - m12) * s;
+		} else if (m11 > m22) {
+			double s = Math.sqrt(1.0 + m11 - m00 - m22); // |s|>=1
 			y = s * 0.5; // |y| >= .5
 			s = 0.5 / s;
-			x = (yx + xy) * s;
-			z = (zy + yz) * s;
-			w = (xz - zx) * s;
+			x = (m10 + m01) * s;
+			z = (m21 + m12) * s;
+			w = (m02 - m20) * s;
 		} else {
-			double s = Math.sqrt(1.0 + zz - xx - yy); // |s|>=1
+			double s = Math.sqrt(1.0 + m22 - m00 - m11); // |s|>=1
 			z = s * 0.5; // |z| >= .5
 			s = 0.5 / s;
-			x = (xz + zx) * s;
-			y = (zy + yz) * s;
-			w = (yx - xy) * s;
+			x = (m02 + m20) * s;
+			y = (m21 + m12) * s;
+			w = (m10 - m01) * s;
 		}
 
 		return set((float)x, (float)y, (float)z, (float)w);
@@ -431,8 +360,8 @@ public class Quaternion implements Serializable {
 	 * @return This quaternion for chaining */
 	public Quaternion setFromCross (final Vector3 v1, final Vector3 v2) {
 		final float dot = MathUtils.clamp(v1.dot(v2), -1f, 1f);
-		final float angle = (float)Math.acos(dot);
-		return setFromAxisRad(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x, angle);
+		final float angle = (float)Math.acos(dot) * MathUtils.radiansToDegrees;
+		return setFromAxis(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x, angle);
 	}
 	
 	/** Set this quaternion to the rotation between two vectors.
@@ -445,8 +374,8 @@ public class Quaternion implements Serializable {
 	 * @return This quaternion for chaining */
 	public Quaternion setFromCross (final float x1, final float y1, final float z1, final float x2, final float y2, final float z2) {
 		final float dot = MathUtils.clamp(Vector3.dot(x1, y1, z1, x2, y2, z2), -1f, 1f);
-		final float angle = (float)Math.acos(dot);
-		return setFromAxisRad(y1 * z2 - z1 * y2, z1 * x2 - x1 * z2, x1 * y2 - y1 * x2, angle);
+		final float angle = (float)Math.acos(dot) * MathUtils.radiansToDegrees;
+		return setFromAxis(y1 * z2 - z1 * y2, z1 * x2 - x1 * z2, x1 * y2 - y1 * x2, angle);
 	}
 
 	/** Spherical linear interpolation between this quaternion and the other quaternion, based on the alpha value in the range
@@ -518,22 +447,13 @@ public class Quaternion implements Serializable {
 		this.w *= scalar;
 		return this;
 	}
-
-	/**
-	 * Get the angle and the axis of rotation in degrees
-	 * @param axis axis to get
-	 * @return the angle
-	 */
-	public float getAxisAngle(Vector3 axis) {
-		return getAxisAngleRad(axis) * MathUtils.radiansToDegrees;
-	}
 	
 	/**
-	 * Get the angle and the axis of rotation in radians
+	 * Get the angle and the axis of rotation
 	 * @param axis axis to get
 	 * @return the angle
 	 */
-	public float getAxisAngleRad(Vector3 axis) {
+	public float getAxisAngle(Vector3 axis) {
 		//source : http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/
       if (this.w > 1)
       	this.nor(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised
@@ -550,6 +470,6 @@ public class Quaternion implements Serializable {
               axis.z = (float) (this.z / s);
       }
 
-      return angle;
+      return MathUtils.radiansToDegrees * angle;
 	}
 }
diff --git a/gdx/src/com/badlogic/gdx/math/Vector2.java b/gdx/src/com/badlogic/gdx/math/Vector2.java
index f130ed8..553fb2c 100644
--- a/gdx/src/com/badlogic/gdx/math/Vector2.java
+++ b/gdx/src/com/badlogic/gdx/math/Vector2.java
@@ -288,23 +288,11 @@ public class Vector2 implements Serializable, Vector<Vector2> {
 		return angle;
 	}
 
-	/** @return the angle in radians of this vector (point) relative to the x-axis. Angles are towards the positive y-axis. (typically
-	 *         counter-clockwise) */
-	public float getAngleRad () {
-		return (float)Math.atan2(y, x);
-	}
-
 	/** Sets the angle of the vector in degrees relative to the x-axis, towards the positive y-axis (typically counter-clockwise).
-	 * @param degrees The angle in degrees to set. */
+	 * @param degrees The angle to set. */
 	public Vector2 setAngle (float degrees) {
-		return setAngleRad(degrees * MathUtils.degreesToRadians);
-	}
-
-	/** Sets the angle of the vector in radians relative to the x-axis, towards the positive y-axis (typically counter-clockwise).
-	 * @param radians The angle in radians to set. */
-	public Vector2 setAngleRad (float radians) {
 		this.set(len(), 0f);
-		this.rotateRad(radians);
+		this.rotate(degrees);
 
 		return this;
 	}
@@ -312,14 +300,9 @@ public class Vector2 implements Serializable, Vector<Vector2> {
 	/** Rotates the Vector2 by the given angle, counter-clockwise assuming the y-axis points up.
 	 * @param degrees the angle in degrees */
 	public Vector2 rotate (float degrees) {
-		return rotateRad(degrees * MathUtils.degreesToRadians);
-	}
-
-	/** Rotates the Vector2 by the given angle, counter-clockwise assuming the y-axis points up.
-	 * @param radians the angle in radians */
-	public Vector2 rotateRad (float radians) {
-		float cos = (float)Math.cos(radians);
-		float sin = (float)Math.sin(radians);
+		float rad = degrees * MathUtils.degreesToRadians;
+		float cos = (float)Math.cos(rad);
+		float sin = (float)Math.sin(rad);
 
 		float newX = this.x * cos - this.y * sin;
 		float newY = this.x * sin + this.y * cos;
diff --git a/gdx/src/com/badlogic/gdx/math/Vector3.java b/gdx/src/com/badlogic/gdx/math/Vector3.java
index 4951c6d..264d1d5 100644
--- a/gdx/src/com/badlogic/gdx/math/Vector3.java
+++ b/gdx/src/com/badlogic/gdx/math/Vector3.java
@@ -444,17 +444,6 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 		return this.mul(tmpMat.setToRotation(axisX, axisY, axisZ, degrees));
 	}
 
-	/** Rotates this vector by the given angle in radians around the given axis.
-	 *
-	 * @param radians the angle in radians
-	 * @param axisX the x-component of the axis
-	 * @param axisY the y-component of the axis
-	 * @param axisZ the z-component of the axis
-	 * @return This vector for chaining */
-	public Vector3 rotateRad (float radians, float axisX, float axisY, float axisZ) {
-		return this.mul(tmpMat.setToRotationRad(axisX, axisY, axisZ, radians));
-	}
-
 	/** Rotates this vector by the given angle in degrees around the given axis.
 	 *
 	 * @param axis the axis
@@ -465,16 +454,6 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 		return this.mul(tmpMat);
 	}
 
-	/** Rotates this vector by the given angle in radians around the given axis.
-	 *
-	 * @param axis the axis
-	 * @param radians the angle in radians
-	 * @return This vector for chaining */
-	public Vector3 rotateRad (final Vector3 axis, float radians) {
-		tmpMat.setToRotationRad(axis, radians);
-		return this.mul(tmpMat);
-	}
-
 	/** @return Whether this vector is a unit length vector */
 	public boolean isUnit () {
 		return isUnit(0.000000001f);
diff --git a/gdx/src/com/badlogic/gdx/net/NetJavaImpl.java b/gdx/src/com/badlogic/gdx/net/NetJavaImpl.java
index 16a4aab..ce70cc1 100644
--- a/gdx/src/com/badlogic/gdx/net/NetJavaImpl.java
+++ b/gdx/src/com/badlogic/gdx/net/NetJavaImpl.java
@@ -26,8 +26,6 @@ import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
 
 import com.badlogic.gdx.Net;
 import com.badlogic.gdx.Net.HttpMethods;
@@ -35,7 +33,6 @@ import com.badlogic.gdx.Net.HttpRequest;
 import com.badlogic.gdx.Net.HttpResponse;
 import com.badlogic.gdx.Net.HttpResponseListener;
 import com.badlogic.gdx.utils.GdxRuntimeException;
-import com.badlogic.gdx.utils.ObjectMap;
 import com.badlogic.gdx.utils.StreamUtils;
 
 /** Implements part of the {@link Net} API using {@link HttpURLConnection}, to be easily reused between the Android and Desktop
@@ -110,15 +107,9 @@ public class NetJavaImpl {
 	}
 
 	private final ExecutorService executorService;
-	final ObjectMap<HttpRequest, HttpURLConnection> connections;
-	final ObjectMap<HttpRequest, HttpResponseListener> listeners;
-	final Lock lock;
 
 	public NetJavaImpl () {
 		executorService = Executors.newCachedThreadPool();
-		connections = new ObjectMap<HttpRequest, HttpURLConnection>();
-		listeners = new ObjectMap<HttpRequest, HttpResponseListener>();
-		lock = new ReentrantLock();
 	}
 
 	public void sendHttpRequest (final HttpRequest httpRequest, final HttpResponseListener httpResponseListener) {
@@ -146,11 +137,6 @@ public class NetJavaImpl {
 			connection.setDoOutput(doingOutPut);
 			connection.setDoInput(true);
 			connection.setRequestMethod(method);
-			
-			lock.lock();
-			connections.put(httpRequest, connection);
-			listeners.put(httpRequest, httpResponseListener);
-			lock.unlock();
 
 			// Headers get set regardless of the method
 			for (Map.Entry<String, String> header : httpRequest.getHeaders().entrySet())
@@ -192,49 +178,20 @@ public class NetJavaImpl {
 
 						final HttpClientResponse clientResponse = new HttpClientResponse(connection);
 						try {
-							lock.lock();
-							HttpResponseListener listener = listeners.get(httpRequest);
-							
-							if (listener != null) {
-								listener.handleHttpResponse(clientResponse);
-								listeners.remove(httpRequest);
-							}
-							
-							connections.remove(httpRequest);
+							httpResponseListener.handleHttpResponse(clientResponse);
 						} finally {
 							connection.disconnect();
-							lock.unlock();
 						}
 					} catch (final Exception e) {
 						connection.disconnect();
-						lock.lock();
 						httpResponseListener.failed(e);
-						connections.remove(httpRequest);
-						listeners.remove(httpRequest);
-						lock.unlock();
 					}
 				}
 			});
 
 		} catch (Exception e) {
-			lock.lock();
 			httpResponseListener.failed(e);
-			connections.remove(httpRequest);
-			listeners.remove(httpRequest);
-			lock.unlock();
 			return;
 		}
 	}
-	
-	public void cancelHttpRequest (HttpRequest httpRequest) {
-		lock.lock();
-		HttpResponseListener httpResponseListener = listeners.get(httpRequest);
-		
-		if (httpResponseListener != null) {
-			httpResponseListener.cancelled();
-			connections.remove(httpRequest);
-			listeners.remove(httpRequest);
-		}
-		lock.unlock();
-	}
 }
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/EventAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/EventAction.java
index ea185d4..43d3cf6 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/EventAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/EventAction.java
@@ -5,7 +5,6 @@ import com.badlogic.gdx.scenes.scene2d.Action;
 import com.badlogic.gdx.scenes.scene2d.Actor;
 import com.badlogic.gdx.scenes.scene2d.Event;
 import com.badlogic.gdx.scenes.scene2d.EventListener;
-import com.badlogic.gdx.utils.reflect.ClassReflection;
 
 /** Adds a listener to the actor for a specific event type and does not complete until {@link #handle(Event)} returns true.
  * @author JavadocMD
@@ -15,8 +14,8 @@ abstract public class EventAction<T extends Event> extends Action {
 	boolean result;
 
 	private final EventListener listener = new EventListener() {
-		public boolean handle (Event event) {			
-			if (!ClassReflection.isInstance(eventClass, event)) return false;
+		public boolean handle (Event event) {
+			if (!eventClass.isInstance(event)) return false;
 			result = handle(event);
 			return result;
 		}
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Image.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Image.java
index b8757db..65c3b4d 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Image.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Image.java
@@ -26,7 +26,6 @@ import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
 import com.badlogic.gdx.scenes.scene2d.utils.NinePatchDrawable;
 import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
-import com.badlogic.gdx.scenes.scene2d.utils.TransformDrawable;
 import com.badlogic.gdx.utils.Scaling;
 
 /** Displays a {@link Drawable}, scaled various way within the widgets bounds. The preferred size is the min size of the drawable.
@@ -123,15 +122,19 @@ public class Image extends Widget {
 		float scaleX = getScaleX();
 		float scaleY = getScaleY();
 
-		if (drawable instanceof TransformDrawable) {
-			float rotation = getRotation();
-			if (scaleX != 1 || scaleY != 1 || rotation != 0) {
-				((TransformDrawable)drawable).draw(batch, x + imageX, y + imageY, getOriginX() - imageX, getOriginY() - imageY,
-					imageWidth, imageHeight, scaleX, scaleY, rotation);
-				return;
-			}
+		if (drawable != null) {
+			if (drawable.getClass() == TextureRegionDrawable.class) {
+				TextureRegion region = ((TextureRegionDrawable)drawable).getRegion();
+				float rotation = getRotation();
+				if (scaleX == 1 && scaleY == 1 && rotation == 0)
+					batch.draw(region, x + imageX, y + imageY, imageWidth, imageHeight);
+				else {
+					batch.draw(region, x + imageX, y + imageY, getOriginX() - imageX, getOriginY() - imageY, imageWidth, imageHeight,
+						scaleX, scaleY, rotation);
+				}
+			} else
+				drawable.draw(batch, x + imageX, y + imageY, imageWidth * scaleX, imageHeight * scaleY);
 		}
-		if (drawable != null) drawable.draw(batch, x + imageX, y + imageY, imageWidth * scaleX, imageHeight * scaleY);
 	}
 
 	public void setDrawable (Skin skin, String drawableName) {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Label.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Label.java
index daee62a..e3d1eac 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Label.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Label.java
@@ -307,11 +307,6 @@ public class Label extends Widget {
 		this.ellipse = ellipse;
 	}
 
-	/** Allows subclasses to access the cache in {@link #draw(Batch, float)}. */
-	protected BitmapFontCache getBitmapFontCache () {
-		return cache;
-	}
-
 	/** The style for a label, see {@link Label}.
 	 * @author Nathan Sweet */
 	static public class LabelStyle {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ScrollPane.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ScrollPane.java
index 6e63d24..7fa738a 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ScrollPane.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ScrollPane.java
@@ -798,16 +798,6 @@ public class ScrollPane extends WidgetGroup {
 		return style.vScrollKnob == null || !scrollY ? 0 : style.vScrollKnob.getMinWidth();
 	}
 
-	/** Returns the width of the scrolled viewport. */
-	public float getScrollWidth () {
-		return areaHeight;
-	}
-
-	/** Returns the height of the scrolled viewport. */
-	public float getScrollHeight () {
-		return areaHeight;
-	}
-
 	public boolean isScrollX () {
 		return scrollX;
 	}
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/DragAndDrop.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/DragAndDrop.java
index 1e5550c..1f382cc 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/DragAndDrop.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/DragAndDrop.java
@@ -24,13 +24,13 @@ import com.badlogic.gdx.scenes.scene2d.Stage;
 import com.badlogic.gdx.scenes.scene2d.Touchable;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.ObjectMap;
-import com.badlogic.gdx.utils.ObjectMap.Entry;
 
 /** Manages drag and drop operations through registered drag sources and drop targets.
  * @author Nathan Sweet */
 public class DragAndDrop {
 	static final Vector2 tmpVector = new Vector2();
 
+	Source source;
 	Payload payload;
 	Actor dragActor;
 	Target target;
@@ -40,7 +40,6 @@ public class DragAndDrop {
 	private float tapSquareSize = 8;
 	private int button;
 	float dragActorX = 14, dragActorY = -20;
-	float touchOffsetX, touchOffsetY;
 	long dragStartTime;
 	int dragTime = 250;
 	int activePointer = -1;
@@ -75,15 +74,14 @@ public class DragAndDrop {
 				// Find target.
 				Target newTarget = null;
 				isValidTarget = false;
-				float stageX = event.getStageX() + touchOffsetX, stageY = event.getStageY() + touchOffsetY;
-				Actor hit = event.getStage().hit(stageX, stageY, true); // Prefer touchable actors.
-				if (hit == null) hit = event.getStage().hit(stageX, stageY, false);
+				Actor hit = event.getStage().hit(event.getStageX(), event.getStageY(), true); // Prefer touchable actors.
+				if (hit == null) hit = event.getStage().hit(event.getStageX(), event.getStageY(), false);
 				if (hit != null) {
 					for (int i = 0, n = targets.size; i < n; i++) {
 						Target target = targets.get(i);
 						if (!target.actor.isAscendantOf(hit)) continue;
 						newTarget = target;
-						target.actor.stageToLocalCoordinates(tmpVector.set(stageX, stageY));
+						target.actor.stageToLocalCoordinates(tmpVector.set(event.getStageX(), event.getStageY()));
 						isValidTarget = target.drag(source, payload, tmpVector.x, tmpVector.y, pointer);
 						break;
 					}
@@ -122,12 +120,12 @@ public class DragAndDrop {
 				if (System.currentTimeMillis() - dragStartTime < dragTime) isValidTarget = false;
 				if (dragActor != null) dragActor.remove();
 				if (isValidTarget) {
-					float stageX = event.getStageX() + touchOffsetX, stageY = event.getStageY() + touchOffsetY;
-					target.actor.stageToLocalCoordinates(tmpVector.set(stageX, stageY));
+					target.actor.stageToLocalCoordinates(tmpVector.set(event.getStageX(), event.getStageY()));
 					target.drop(source, payload, tmpVector.x, tmpVector.y, pointer);
 				}
 				source.dragStop(event, x, y, pointer, isValidTarget ? target : null);
 				if (target != null) target.reset(source, payload);
+				DragAndDrop.this.source = null;
 				payload = null;
 				target = null;
 				isValidTarget = false;
@@ -153,14 +151,6 @@ public class DragAndDrop {
 		targets.removeValue(target, true);
 	}
 
-	/** Removes all targets and sources. */
-	public void clear () {
-		targets.clear();
-		for (Entry<Source, DragListener> entry : sourceListeners.entries())
-			entry.key.actor.removeCaptureListener(entry.value);
-		sourceListeners.clear();
-	}
-
 	/** Sets the distance a touch must travel before being considered a drag. */
 	public void setTapSquareSize (float halfTapSquareSize) {
 		tapSquareSize = halfTapSquareSize;
@@ -176,12 +166,6 @@ public class DragAndDrop {
 		this.dragActorY = dragActorY;
 	}
 
-	/** Sets an offset in stage coordinates from the touch position which is used to determine the drop location. Default is 0,0. */
-	public void setTouchOffset (float touchOffsetX, float touchOffsetY) {
-		this.touchOffsetX = touchOffsetX;
-		this.touchOffsetY = touchOffsetY;
-	}
-
 	public boolean isDragging () {
 		return payload != null;
 	}
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/ScissorStack.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/ScissorStack.java
index 72d823e..fd7719b 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/ScissorStack.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/ScissorStack.java
@@ -136,15 +136,13 @@ public class ScissorStack {
 	 * left and the the y-axis is pointing downwards
 	 * @param camera the {@link Camera}
 	 * @param transformMatrix the transformation {@link Matrix4}
-	 * @param point the point to be transformed.
-	 * @return point */
-	public static Vector2 toWindowCoordinates (Camera camera, Matrix4 transformMatrix, Vector2 point) {
+	 * @param point the point to be transformed. */
+	public static void toWindowCoordinates (Camera camera, Matrix4 transformMatrix, Vector2 point) {
 		tmp.set(point.x, point.y, 0);
 		tmp.mul(transformMatrix);
 		camera.project(tmp);
 		tmp.y = Gdx.graphics.getHeight() - tmp.y;
 		point.x = tmp.x;
 		point.y = tmp.y;
-		return point;
 	}
 }
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/SpriteDrawable.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/SpriteDrawable.java
index 638d6c6..eba1d2e 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/SpriteDrawable.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/SpriteDrawable.java
@@ -22,7 +22,7 @@ import com.badlogic.gdx.graphics.g2d.Sprite;
 
 /** Drawable for a {@link Sprite}.
  * @author Nathan Sweet */
-public class SpriteDrawable extends BaseDrawable implements TransformDrawable {
+public class SpriteDrawable extends BaseDrawable {
 	private Sprite sprite;
 
 	/** Creates an unitialized SpriteDrawable. The sprite must be set before use. */
@@ -46,18 +46,6 @@ public class SpriteDrawable extends BaseDrawable implements TransformDrawable {
 		sprite.setColor(color);
 	}
 
-	public void draw (Batch batch, float x, float y, float originX, float originY, float width, float height, float scaleX,
-		float scaleY, float rotation) {
-		sprite.setOrigin(originX, originY);
-		sprite.setRotation(rotation);
-		sprite.setScale(scaleX, scaleY);
-		sprite.setBounds(x, y, width, height);
-		Color color = sprite.getColor();
-		sprite.setColor(Color.tmp.set(color).mul(batch.getColor()));
-		sprite.draw(batch);
-		sprite.setColor(color);
-	}
-
 	public void setSprite (Sprite sprite) {
 		this.sprite = sprite;
 		setMinWidth(sprite.getWidth());
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/TextureRegionDrawable.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/TextureRegionDrawable.java
index 0ec2e1b..06c97b9 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/TextureRegionDrawable.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/TextureRegionDrawable.java
@@ -21,7 +21,7 @@ import com.badlogic.gdx.graphics.g2d.TextureRegion;
 
 /** Drawable for a {@link TextureRegion}.
  * @author Nathan Sweet */
-public class TextureRegionDrawable extends BaseDrawable implements TransformDrawable {
+public class TextureRegionDrawable extends BaseDrawable {
 	private TextureRegion region;
 
 	/** Creates an unitialized TextureRegionDrawable. The texture region must be set before use. */
@@ -41,11 +41,6 @@ public class TextureRegionDrawable extends BaseDrawable implements TransformDraw
 		batch.draw(region, x, y, width, height);
 	}
 
-	public void draw (Batch batch, float x, float y, float originX, float originY, float width, float height, float scaleX,
-		float scaleY, float rotation) {
-		batch.draw(region, x, y, originX, originY, width, height, scaleX, scaleY, rotation);
-	}
-
 	public void setRegion (TextureRegion region) {
 		this.region = region;
 		setMinWidth(region.getRegionWidth());
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/TransformDrawable.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/TransformDrawable.java
deleted file mode 100644
index a226dca..0000000
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/TransformDrawable.java
+++ /dev/null
@@ -1,10 +0,0 @@
-
-package com.badlogic.gdx.scenes.scene2d.utils;
-
-import com.badlogic.gdx.graphics.g2d.Batch;
-
-/** A drawable that supports scale and rotation. */
-public interface TransformDrawable extends Drawable {
-	public void draw (Batch batch, float x, float y, float originX, float originY, float width, float height, float scaleX,
-		float scaleY, float rotation);
-}
diff --git a/gdx/src/com/badlogic/gdx/utils/Array.java b/gdx/src/com/badlogic/gdx/utils/Array.java
index 646d350..48482d0 100644
--- a/gdx/src/com/badlogic/gdx/utils/Array.java
+++ b/gdx/src/com/badlogic/gdx/utils/Array.java
@@ -331,7 +331,7 @@ public class Array<T> implements Iterable<T> {
 	}
 
 	/** Sorts the array. This method is not thread safe (uses {@link Sort#instance()}). */
-	public void sort (Comparator<? super T> comparator) {
+	public void sort (Comparator<T> comparator) {
 		Sort.instance().sort(items, comparator, 0, size);
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/utils/DelayedRemovalArray.java b/gdx/src/com/badlogic/gdx/utils/DelayedRemovalArray.java
index aa0069f..5ca420b 100644
--- a/gdx/src/com/badlogic/gdx/utils/DelayedRemovalArray.java
+++ b/gdx/src/com/badlogic/gdx/utils/DelayedRemovalArray.java
@@ -131,7 +131,7 @@ public class DelayedRemovalArray<T> extends Array<T> {
 		super.sort();
 	}
 
-	public void sort (Comparator<? super T> comparator) {
+	public void sort (Comparator<T> comparator) {
 		if (iterating) throw new IllegalStateException("Invalid between begin/end.");
 		super.sort(comparator);
 	}
diff --git a/gdx/src/com/badlogic/gdx/utils/IdentityMap.java b/gdx/src/com/badlogic/gdx/utils/IdentityMap.java
index cd9e3b4..e01c98c 100644
--- a/gdx/src/com/badlogic/gdx/utils/IdentityMap.java
+++ b/gdx/src/com/badlogic/gdx/utils/IdentityMap.java
@@ -627,8 +627,6 @@ public class IdentityMap<K, V> {
 			if (currentIndex < 0) throw new IllegalStateException("next must be called before remove.");
 			if (currentIndex >= map.capacity) {
 				map.removeStashIndex(currentIndex);
-				nextIndex = currentIndex;
-				findNextIndex();
 			} else {
 				map.keyTable[currentIndex] = null;
 				map.valueTable[currentIndex] = null;
diff --git a/gdx/src/com/badlogic/gdx/utils/IntFloatMap.java b/gdx/src/com/badlogic/gdx/utils/IntFloatMap.java
index b94b1c8..4df1e91 100644
--- a/gdx/src/com/badlogic/gdx/utils/IntFloatMap.java
+++ b/gdx/src/com/badlogic/gdx/utils/IntFloatMap.java
@@ -677,8 +677,6 @@ public class IntFloatMap {
 				throw new IllegalStateException("next must be called before remove.");
 			} else if (currentIndex >= map.capacity) {
 				map.removeStashIndex(currentIndex);
-				nextIndex = currentIndex;
-				findNextIndex();
 			} else {
 				map.keyTable[currentIndex] = EMPTY;
 			}
diff --git a/gdx/src/com/badlogic/gdx/utils/IntIntMap.java b/gdx/src/com/badlogic/gdx/utils/IntIntMap.java
index 2411a18..236e9a7 100644
--- a/gdx/src/com/badlogic/gdx/utils/IntIntMap.java
+++ b/gdx/src/com/badlogic/gdx/utils/IntIntMap.java
@@ -16,11 +16,14 @@
 
 package com.badlogic.gdx.utils;
 
+import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.utils.IntFloatMap.Entries;
+import com.badlogic.gdx.utils.IntFloatMap.Keys;
+import com.badlogic.gdx.utils.IntFloatMap.Values;
+
 import java.util.Iterator;
 import java.util.NoSuchElementException;
 
-import com.badlogic.gdx.math.MathUtils;
-
 /** An unordered map where the keys and values are ints. This implementation is a cuckoo hash map using 3 hashes, random walking,
  * and a small stash for problematic keys. No allocation is done except when growing the table size. <br>
  * <br>
@@ -662,8 +665,6 @@ public class IntIntMap {
 				throw new IllegalStateException("next must be called before remove.");
 			} else if (currentIndex >= map.capacity) {
 				map.removeStashIndex(currentIndex);
-				nextIndex = currentIndex;
-				findNextIndex();
 			} else {
 				map.keyTable[currentIndex] = EMPTY;
 			}
diff --git a/gdx/src/com/badlogic/gdx/utils/IntMap.java b/gdx/src/com/badlogic/gdx/utils/IntMap.java
index 1d5f683..5f8f350 100644
--- a/gdx/src/com/badlogic/gdx/utils/IntMap.java
+++ b/gdx/src/com/badlogic/gdx/utils/IntMap.java
@@ -686,8 +686,6 @@ public class IntMap<V> {
 				throw new IllegalStateException("next must be called before remove.");
 			} else if (currentIndex >= map.capacity) {
 				map.removeStashIndex(currentIndex);
-				nextIndex = currentIndex;
-				findNextIndex();
 			} else {
 				map.keyTable[currentIndex] = EMPTY;
 				map.valueTable[currentIndex] = null;
diff --git a/gdx/src/com/badlogic/gdx/utils/IntSet.java b/gdx/src/com/badlogic/gdx/utils/IntSet.java
index f3fece5..2ac43f2 100644
--- a/gdx/src/com/badlogic/gdx/utils/IntSet.java
+++ b/gdx/src/com/badlogic/gdx/utils/IntSet.java
@@ -491,8 +491,6 @@ public class IntSet {
 				throw new IllegalStateException("next must be called before remove.");
 			} else if (currentIndex >= set.capacity) {
 				set.removeStashIndex(currentIndex);
-				nextIndex = currentIndex;
-				findNextIndex();
 			} else {
 				set.keyTable[currentIndex] = EMPTY;
 			}
diff --git a/gdx/src/com/badlogic/gdx/utils/Json.java b/gdx/src/com/badlogic/gdx/utils/Json.java
index 1795203..9e74b37 100644
--- a/gdx/src/com/badlogic/gdx/utils/Json.java
+++ b/gdx/src/com/badlogic/gdx/utils/Json.java
@@ -522,11 +522,6 @@ public class Json {
 
 			if (ClassReflection.isAssignableFrom(Enum.class, actualType)) {
 				if (knownType == null || !knownType.equals(actualType)) {
-					
-					// Ensures that enums with specific implementations (abstract logic) serialize correctly
-					if(actualType.getEnumConstants() == null)
-						actualType = actualType.getSuperclass();
-					
 					writeObjectStart(actualType, null);
 					writer.name("value");
 					writer.value(value);
@@ -832,7 +827,7 @@ public class Json {
 			if (type != null) {
 				if (type == String.class || type == Integer.class || type == Boolean.class || type == Float.class
 					|| type == Long.class || type == Double.class || type == Short.class || type == Byte.class
-					|| type == Character.class || ClassReflection.isAssignableFrom(Enum.class, type)) {
+					|| type == Character.class || type.isEnum()) {
 					return readValue("value", type, jsonData);
 				}
 
@@ -961,15 +956,9 @@ public class Json {
 				return constructor.newInstance();
 			} catch (SecurityException ignored) {
 			} catch (ReflectionException ignored) {
-				
-				if(ClassReflection.isAssignableFrom(Enum.class, type)){
-
-					if(type.getEnumConstants() == null)
-						type = type.getSuperclass();
-					
+				if (type.isEnum()) {
 					return type.getEnumConstants()[0];
 				}
-				
 				if (type.isArray())
 					throw new SerializationException("Encountered JSON object when expected array of type: " + type.getName(), ex);
 				else if (ClassReflection.isMemberClass(type) && !ClassReflection.isStaticClass(type))
diff --git a/gdx/src/com/badlogic/gdx/utils/LongMap.java b/gdx/src/com/badlogic/gdx/utils/LongMap.java
index ba96c4d..d28537b 100644
--- a/gdx/src/com/badlogic/gdx/utils/LongMap.java
+++ b/gdx/src/com/badlogic/gdx/utils/LongMap.java
@@ -678,8 +678,6 @@ public class LongMap<V> {
 				throw new IllegalStateException("next must be called before remove.");
 			} else if (currentIndex >= map.capacity) {
 				map.removeStashIndex(currentIndex);
-				nextIndex = currentIndex;
-				findNextIndex();
 			} else {
 				map.keyTable[currentIndex] = EMPTY;
 				map.valueTable[currentIndex] = null;
diff --git a/gdx/src/com/badlogic/gdx/utils/ObjectFloatMap.java b/gdx/src/com/badlogic/gdx/utils/ObjectFloatMap.java
index e9cac95..1edd70a 100644
--- a/gdx/src/com/badlogic/gdx/utils/ObjectFloatMap.java
+++ b/gdx/src/com/badlogic/gdx/utils/ObjectFloatMap.java
@@ -611,8 +611,6 @@ public class ObjectFloatMap<K> {
 			if (currentIndex < 0) throw new IllegalStateException("next must be called before remove.");
 			if (currentIndex >= map.capacity) {
 				map.removeStashIndex(currentIndex);
-				nextIndex = currentIndex;
-				findNextIndex();
 			} else {
 				map.keyTable[currentIndex] = null;
 			}
diff --git a/gdx/src/com/badlogic/gdx/utils/ObjectIntMap.java b/gdx/src/com/badlogic/gdx/utils/ObjectIntMap.java
index 2760eec..7e1e787 100644
--- a/gdx/src/com/badlogic/gdx/utils/ObjectIntMap.java
+++ b/gdx/src/com/badlogic/gdx/utils/ObjectIntMap.java
@@ -611,8 +611,6 @@ public class ObjectIntMap<K> {
 			if (currentIndex < 0) throw new IllegalStateException("next must be called before remove.");
 			if (currentIndex >= map.capacity) {
 				map.removeStashIndex(currentIndex);
-				nextIndex = currentIndex;
-				findNextIndex();
 			} else {
 				map.keyTable[currentIndex] = null;
 			}
diff --git a/gdx/src/com/badlogic/gdx/utils/ObjectMap.java b/gdx/src/com/badlogic/gdx/utils/ObjectMap.java
index d85c75a..acf0934 100644
--- a/gdx/src/com/badlogic/gdx/utils/ObjectMap.java
+++ b/gdx/src/com/badlogic/gdx/utils/ObjectMap.java
@@ -643,8 +643,6 @@ public class ObjectMap<K, V> {
 			if (currentIndex < 0) throw new IllegalStateException("next must be called before remove.");
 			if (currentIndex >= map.capacity) {
 				map.removeStashIndex(currentIndex);
-				nextIndex = currentIndex;
-				advance();
 			} else {
 				map.keyTable[currentIndex] = null;
 				map.valueTable[currentIndex] = null;
diff --git a/gdx/src/com/badlogic/gdx/utils/ObjectSet.java b/gdx/src/com/badlogic/gdx/utils/ObjectSet.java
index 0b89aaa..6b1ef90 100644
--- a/gdx/src/com/badlogic/gdx/utils/ObjectSet.java
+++ b/gdx/src/com/badlogic/gdx/utils/ObjectSet.java
@@ -471,8 +471,6 @@ public class ObjectSet<T> implements Iterable<T> {
 			if (currentIndex < 0) throw new IllegalStateException("next must be called before remove.");
 			if (currentIndex >= set.capacity) {
 				set.removeStashIndex(currentIndex);
-				nextIndex = currentIndex;
-				findNextIndex();
 			} else {
 				set.keyTable[currentIndex] = null;
 			}
diff --git a/gdx/src/com/badlogic/gdx/utils/SharedLibraryLoader.java b/gdx/src/com/badlogic/gdx/utils/SharedLibraryLoader.java
index c8bbee2..7042397 100644
--- a/gdx/src/com/badlogic/gdx/utils/SharedLibraryLoader.java
+++ b/gdx/src/com/badlogic/gdx/utils/SharedLibraryLoader.java
@@ -185,7 +185,7 @@ public class SharedLibraryLoader {
 
 	/** Returns true if the parent directories of the file can be created and the file can be written. */
 	private boolean canWrite (File file) {
-		if (file.canWrite() && file.canExecute()) return true; // File exists and is writable.
+		if (file.canWrite()) return true; // File exists and is writable.
 		File parent = file.getParentFile();
 		parent.mkdirs();
 		if (!parent.isDirectory()) return false;
diff --git a/gdx/src/com/badlogic/gdx/utils/SnapshotArray.java b/gdx/src/com/badlogic/gdx/utils/SnapshotArray.java
index fb3b03e..2aa57d1 100644
--- a/gdx/src/com/badlogic/gdx/utils/SnapshotArray.java
+++ b/gdx/src/com/badlogic/gdx/utils/SnapshotArray.java
@@ -144,7 +144,7 @@ public class SnapshotArray<T> extends Array<T> {
 		super.sort();
 	}
 
-	public void sort (Comparator<? super T> comparator) {
+	public void sort (Comparator<T> comparator) {
 		modified();
 		super.sort(comparator);
 	}
diff --git a/gdx/src/com/badlogic/gdx/utils/Sort.java b/gdx/src/com/badlogic/gdx/utils/Sort.java
index 94f52c2..1f6b410 100644
--- a/gdx/src/com/badlogic/gdx/utils/Sort.java
+++ b/gdx/src/com/badlogic/gdx/utils/Sort.java
@@ -42,17 +42,17 @@ public class Sort {
 		comparableTimSort.doSort(a, fromIndex, toIndex);
 	}
 
-	public <T> void sort (Array<T> a, Comparator<? super T> c) {
+	public <T> void sort (Array<? extends T> a, Comparator<? extends T> c) {
 		if (timSort == null) timSort = new TimSort();
 		timSort.doSort((Object[])a.items, (Comparator)c, 0, a.size);
 	}
 
-	public <T> void sort (T[] a, Comparator<? super T> c) {
+	public <T> void sort (T[] a, Comparator<T> c) {
 		if (timSort == null) timSort = new TimSort();
 		timSort.doSort(a, c, 0, a.length);
 	}
 
-	public <T> void sort (T[] a, Comparator<? super T> c, int fromIndex, int toIndex) {
+	public <T> void sort (T[] a, Comparator<T> c, int fromIndex, int toIndex) {
 		if (timSort == null) timSort = new TimSort();
 		timSort.doSort(a, c, fromIndex, toIndex);
 	}
diff --git a/gdx/src/com/badlogic/gdx/utils/XmlReader.java b/gdx/src/com/badlogic/gdx/utils/XmlReader.java
index 818c202..39fcd1c 100644
--- a/gdx/src/com/badlogic/gdx/utils/XmlReader.java
+++ b/gdx/src/com/badlogic/gdx/utils/XmlReader.java
@@ -175,13 +175,13 @@ public class XmlReader {
 						while (_nacts-- > 0) {
 							switch (_xml_actions[_acts++]) {
 							case 0:
-							// line 94 "XmlReader.rl"
+								// line 94 "XmlReader.rl"
 							{
 								s = p;
 							}
 								break;
 							case 1:
-							// line 95 "XmlReader.rl"
+								// line 95 "XmlReader.rl"
 							{
 								char c = data[s];
 								if (c == '?' || c == '!') {
@@ -218,7 +218,7 @@ public class XmlReader {
 							}
 								break;
 							case 2:
-							// line 125 "XmlReader.rl"
+								// line 125 "XmlReader.rl"
 							{
 								hasBody = false;
 								close();
@@ -230,7 +230,7 @@ public class XmlReader {
 							}
 								break;
 							case 3:
-							// line 130 "XmlReader.rl"
+								// line 130 "XmlReader.rl"
 							{
 								close();
 								{
@@ -241,7 +241,7 @@ public class XmlReader {
 							}
 								break;
 							case 4:
-							// line 134 "XmlReader.rl"
+								// line 134 "XmlReader.rl"
 							{
 								if (hasBody) {
 									cs = 15;
@@ -251,19 +251,19 @@ public class XmlReader {
 							}
 								break;
 							case 5:
-							// line 137 "XmlReader.rl"
+								// line 137 "XmlReader.rl"
 							{
 								attributeName = new String(data, s, p - s);
 							}
 								break;
 							case 6:
-							// line 140 "XmlReader.rl"
+								// line 140 "XmlReader.rl"
 							{
 								attribute(attributeName, new String(data, s, p - s));
 							}
 								break;
 							case 7:
-							// line 143 "XmlReader.rl"
+								// line 143 "XmlReader.rl"
 							{
 								int end = p;
 								while (end != s) {
@@ -301,7 +301,7 @@ public class XmlReader {
 									text(new String(data, s, end - s));
 							}
 								break;
-							// line 286 "XmlReader.java"
+								// line 286 "XmlReader.java"
 							}
 						}
 					}
@@ -436,7 +436,6 @@ public class XmlReader {
 		if (name.equals("amp")) return "&";
 		if (name.equals("apos")) return "'";
 		if (name.equals("quot")) return "\"";
-		if (name.startsWith("#x")) return Character.toString((char)Integer.parseInt(name.substring(2), 16));
 		return null;
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/utils/XmlReader.rl b/gdx/src/com/badlogic/gdx/utils/XmlReader.rl
index 79f07bb..74a2bdc 100644
--- a/gdx/src/com/badlogic/gdx/utils/XmlReader.rl
+++ b/gdx/src/com/badlogic/gdx/utils/XmlReader.rl
@@ -230,7 +230,6 @@ public class XmlReader {
 		if (name.equals("amp")) return "&";
 		if (name.equals("apos")) return "'";
 		if (name.equals("quot")) return "\"";
-		if (name.startsWith("#x")) return Character.toString((char)Integer.parseInt(name.substring(2), 16));
 		return null;
 	}
 
diff --git a/pom.xml b/pom.xml
index 0a35fb5..307ad5a 100644
--- a/pom.xml
+++ b/pom.xml
@@ -43,9 +43,9 @@
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
     <android.version>4.4</android.version>
-    <gwt.version>2.6.0</gwt.version>
-    <lwjgl.version>2.9.1</lwjgl.version>
-    <robovm.version>0.0.9</robovm.version>
+    <gwt.version>2.5.0</gwt.version>
+    <lwjgl.version>2.9.0</lwjgl.version>
+    <robovm.version>0.0.6</robovm.version>
   </properties>
 
   <modules>
diff --git a/tests/gdx-tests-android/assets/data/utf-font.fnt b/tests/gdx-tests-android/assets/data/utf-font.fnt
deleted file mode 100644
index e91d039..0000000
--- a/tests/gdx-tests-android/assets/data/utf-font.fnt
+++ /dev/null
@@ -1,335 +0,0 @@
-info face="Orbitron-Light" size=24 bold=0 italic=0 charset="" unicode=0 stretchH=100 smooth=1 aa=1 padding=0,0,0,0 spacing=2,2
-common lineHeight=29 base=18 scaleW=512 scaleH=256 pages=1 packed=0
-page id=0 file="utf-font.png"
-chars count=190
-char id=32     x=149   y=141   width=0     height=0     xoffset=0     yoffset=23    xadvance=7     page=0 chnl=0 letter="space"
-char id=33     x=452   y=103   width=3     height=19    xoffset=1     yoffset=4     xadvance=5     page=0 chnl=0 letter="!"
-char id=34     x=23    y=141   width=7     height=5     xoffset=1     yoffset=4     xadvance=9     page=0 chnl=0 letter="""
-char id=35     x=25    y=82    width=19    height=19    xoffset=1     yoffset=4     xadvance=19    page=0 chnl=0 letter="#"
-char id=36     x=418   y=2     width=19    height=24    xoffset=1     yoffset=2     xadvance=19    page=0 chnl=0 letter="$"
-char id=37     x=419   y=59    width=23    height=19    xoffset=1     yoffset=4     xadvance=23    page=0 chnl=0 letter="%"
-char id=38     x=444   y=59    width=22    height=19    xoffset=1     yoffset=4     xadvance=23    page=0 chnl=0 letter="&"
-char id=39     x=50    y=141   width=3     height=5     xoffset=1     yoffset=4     xadvance=5     page=0 chnl=0 letter="'"
-char id=40     x=424   y=103   width=5     height=19    xoffset=1     yoffset=4     xadvance=7     page=0 chnl=0 letter="("
-char id=41     x=431   y=103   width=5     height=19    xoffset=1     yoffset=4     xadvance=7     page=0 chnl=0 letter=")"
-char id=42     x=416   y=124   width=12    height=11    xoffset=1     yoffset=4     xadvance=12    page=0 chnl=0 letter="*"
-char id=43     x=444   y=124   width=11    height=11    xoffset=0     yoffset=10    xadvance=10    page=0 chnl=0 letter="+"
-char id=44     x=18    y=141   width=3     height=7     xoffset=1     yoffset=19    xadvance=5     page=0 chnl=0 letter=","
-char id=45     x=108   y=141   width=11    height=3     xoffset=1     yoffset=14    xadvance=12    page=0 chnl=0 letter="-"
-char id=46     x=144   y=141   width=3     height=3     xoffset=1     yoffset=20    xadvance=5     page=0 chnl=0 letter="."
-char id=47     x=337   y=103   width=14    height=19    xoffset=0     yoffset=4     xadvance=13    page=0 chnl=0 letter="/"
-char id=48     x=46    y=82    width=19    height=19    xoffset=1     yoffset=4     xadvance=20    page=0 chnl=0 letter="0"
-char id=49     x=397   y=103   width=9     height=19    xoffset=0     yoffset=4     xadvance=9     page=0 chnl=0 letter="1"
-char id=50     x=67    y=82    width=19    height=19    xoffset=1     yoffset=4     xadvance=20    page=0 chnl=0 letter="2"
-char id=51     x=88    y=82    width=19    height=19    xoffset=1     yoffset=4     xadvance=20    page=0 chnl=0 letter="3"
-char id=52     x=149   y=103   width=18    height=19    xoffset=0     yoffset=4     xadvance=18    page=0 chnl=0 letter="4"
-char id=53     x=109   y=82    width=19    height=19    xoffset=1     yoffset=4     xadvance=20    page=0 chnl=0 letter="5"
-char id=54     x=130   y=82    width=19    height=19    xoffset=1     yoffset=4     xadvance=20    page=0 chnl=0 letter="6"
-char id=55     x=284   y=103   width=16    height=19    xoffset=0     yoffset=4     xadvance=16    page=0 chnl=0 letter="7"
-char id=56     x=151   y=82    width=19    height=19    xoffset=1     yoffset=4     xadvance=20    page=0 chnl=0 letter="8"
-char id=57     x=172   y=82    width=19    height=19    xoffset=1     yoffset=4     xadvance=20    page=0 chnl=0 letter="9"
-char id=58     x=472   y=103   width=3     height=16    xoffset=1     yoffset=7     xadvance=5     page=0 chnl=0 letter=":"
-char id=59     x=457   y=103   width=3     height=19    xoffset=1     yoffset=7     xadvance=5     page=0 chnl=0 letter=";"
-char id=60     x=300   y=124   width=11    height=15    xoffset=0     yoffset=8     xadvance=11    page=0 chnl=0 letter="<"
-char id=61     x=2     y=141   width=14    height=8     xoffset=1     yoffset=11    xadvance=15    page=0 chnl=0 letter="="
-char id=62     x=313   y=124   width=11    height=15    xoffset=1     yoffset=8     xadvance=11    page=0 chnl=0 letter=">"
-char id=63     x=189   y=103   width=17    height=19    xoffset=1     yoffset=4     xadvance=16    page=0 chnl=0 letter="?"
-char id=64     x=193   y=82    width=19    height=19    xoffset=1     yoffset=4     xadvance=20    page=0 chnl=0 letter="@"
-char id=65     x=214   y=82    width=19    height=19    xoffset=1     yoffset=4     xadvance=20    page=0 chnl=0 letter="A"
-char id=66     x=235   y=82    width=19    height=19    xoffset=1     yoffset=4     xadvance=20    page=0 chnl=0 letter="B"
-char id=67     x=256   y=82    width=19    height=19    xoffset=1     yoffset=4     xadvance=20    page=0 chnl=0 letter="C"
-char id=68     x=277   y=82    width=19    height=19    xoffset=1     yoffset=4     xadvance=20    page=0 chnl=0 letter="D"
-char id=69     x=208   y=103   width=17    height=19    xoffset=1     yoffset=4     xadvance=18    page=0 chnl=0 letter="E"
-char id=70     x=227   y=103   width=17    height=19    xoffset=1     yoffset=4     xadvance=17    page=0 chnl=0 letter="F"
-char id=71     x=298   y=82    width=19    height=19    xoffset=1     yoffset=4     xadvance=20    page=0 chnl=0 letter="G"
-char id=72     x=319   y=82    width=19    height=19    xoffset=1     yoffset=4     xadvance=20    page=0 chnl=0 letter="H"
-char id=73     x=462   y=103   width=3     height=19    xoffset=1     yoffset=4     xadvance=5     page=0 chnl=0 letter="I"
-char id=74     x=340   y=82    width=19    height=19    xoffset=0     yoffset=4     xadvance=19    page=0 chnl=0 letter="J"
-char id=75     x=169   y=103   width=18    height=19    xoffset=1     yoffset=4     xadvance=19    page=0 chnl=0 letter="K"
-char id=76     x=361   y=82    width=19    height=19    xoffset=1     yoffset=4     xadvance=19    page=0 chnl=0 letter="L"
-char id=77     x=468   y=59    width=21    height=19    xoffset=1     yoffset=4     xadvance=22    page=0 chnl=0 letter="M"
-char id=78     x=382   y=82    width=19    height=19    xoffset=1     yoffset=4     xadvance=20    page=0 chnl=0 letter="N"
-char id=79     x=403   y=82    width=19    height=19    xoffset=1     yoffset=4     xadvance=20    page=0 chnl=0 letter="O"
-char id=80     x=424   y=82    width=19    height=19    xoffset=1     yoffset=4     xadvance=19    page=0 chnl=0 letter="P"
-char id=81     x=2     y=82    width=21    height=19    xoffset=1     yoffset=4     xadvance=21    page=0 chnl=0 letter="Q"
-char id=82     x=445   y=82    width=19    height=19    xoffset=1     yoffset=4     xadvance=20    page=0 chnl=0 letter="R"
-char id=83     x=466   y=82    width=19    height=19    xoffset=1     yoffset=4     xadvance=20    page=0 chnl=0 letter="S"
-char id=84     x=487   y=82    width=19    height=19    xoffset=0     yoffset=4     xadvance=18    page=0 chnl=0 letter="T"
-char id=85     x=2     y=103   width=19    height=19    xoffset=1     yoffset=4     xadvance=20    page=0 chnl=0 letter="U"
-char id=86     x=393   y=59    width=24    height=19    xoffset=1     yoffset=4     xadvance=24    page=0 chnl=0 letter="V"
-char id=87     x=363   y=59    width=28    height=19    xoffset=1     yoffset=4     xadvance=28    page=0 chnl=0 letter="W"
-char id=88     x=23    y=103   width=19    height=19    xoffset=1     yoffset=4     xadvance=19    page=0 chnl=0 letter="X"
-char id=89     x=44    y=103   width=19    height=19    xoffset=0     yoffset=4     xadvance=19    page=0 chnl=0 letter="Y"
-char id=90     x=65    y=103   width=19    height=19    xoffset=1     yoffset=4     xadvance=20    page=0 chnl=0 letter="Z"
-char id=91     x=438   y=103   width=5     height=19    xoffset=1     yoffset=4     xadvance=7     page=0 chnl=0 letter="["
-char id=92     x=353   y=103   width=14    height=19    xoffset=0     yoffset=4     xadvance=12    page=0 chnl=0 letter="\"
-char id=93     x=445   y=103   width=5     height=19    xoffset=1     yoffset=4     xadvance=7     page=0 chnl=0 letter="]"
-char id=94     x=326   y=124   width=14    height=14    xoffset=1     yoffset=4     xadvance=15    page=0 chnl=0 letter="^"
-char id=95     x=73    y=141   width=19    height=3     xoffset=1     yoffset=22    xadvance=20    page=0 chnl=0 letter="_"
-char id=96     x=32    y=141   width=4     height=5     xoffset=1     yoffset=-3    xadvance=5     page=0 chnl=0 letter="`"
-char id=97     x=76    y=124   width=16    height=15    xoffset=1     yoffset=8     xadvance=17    page=0 chnl=0 letter="a"
-char id=98     x=219   y=59    width=16    height=20    xoffset=1     yoffset=3     xadvance=16    page=0 chnl=0 letter="b"
-char id=99     x=94    y=124   width=16    height=15    xoffset=1     yoffset=8     xadvance=17    page=0 chnl=0 letter="c"
-char id=100    x=237   y=59    width=16    height=20    xoffset=1     yoffset=3     xadvance=16    page=0 chnl=0 letter="d"
-char id=101    x=112   y=124   width=16    height=15    xoffset=1     yoffset=8     xadvance=17    page=0 chnl=0 letter="e"
-char id=102    x=290   y=59    width=10    height=20    xoffset=1     yoffset=3     xadvance=10    page=0 chnl=0 letter="f"
-char id=103    x=484   y=33    width=16    height=21    xoffset=1     yoffset=8     xadvance=16    page=0 chnl=0 letter="g"
-char id=104    x=255   y=59    width=16    height=20    xoffset=1     yoffset=3     xadvance=16    page=0 chnl=0 letter="h"
-char id=105    x=323   y=59    width=3     height=20    xoffset=1     yoffset=3     xadvance=5     page=0 chnl=0 letter="i"
-char id=106    x=205   y=2     width=10    height=26    xoffset=-4    yoffset=3     xadvance=6     page=0 chnl=0 letter="j"
-char id=107    x=273   y=59    width=15    height=20    xoffset=1     yoffset=3     xadvance=16    page=0 chnl=0 letter="k"
-char id=108    x=314   y=59    width=7     height=20    xoffset=1     yoffset=3     xadvance=7     page=0 chnl=0 letter="l"
-char id=109    x=30    y=124   width=23    height=15    xoffset=1     yoffset=8     xadvance=23    page=0 chnl=0 letter="m"
-char id=110    x=130   y=124   width=16    height=15    xoffset=1     yoffset=8     xadvance=17    page=0 chnl=0 letter="n"
-char id=111    x=148   y=124   width=16    height=15    xoffset=1     yoffset=8     xadvance=17    page=0 chnl=0 letter="o"
-char id=112    x=2     y=59    width=16    height=21    xoffset=1     yoffset=8     xadvance=16    page=0 chnl=0 letter="p"
-char id=113    x=20    y=59    width=16    height=21    xoffset=0     yoffset=8     xadvance=16    page=0 chnl=0 letter="q"
-char id=114    x=286   y=124   width=12    height=15    xoffset=1     yoffset=8     xadvance=12    page=0 chnl=0 letter="r"
-char id=115    x=166   y=124   width=16    height=15    xoffset=1     yoffset=8     xadvance=16    page=0 chnl=0 letter="s"
-char id=116    x=302   y=59    width=10    height=20    xoffset=1     yoffset=3     xadvance=10    page=0 chnl=0 letter="t"
-char id=117    x=184   y=124   width=16    height=15    xoffset=1     yoffset=8     xadvance=17    page=0 chnl=0 letter="u"
-char id=118    x=55    y=124   width=19    height=15    xoffset=1     yoffset=8     xadvance=19    page=0 chnl=0 letter="v"
-char id=119    x=2     y=124   width=26    height=15    xoffset=1     yoffset=8     xadvance=26    page=0 chnl=0 letter="w"
-char id=120    x=202   y=124   width=16    height=15    xoffset=1     yoffset=8     xadvance=17    page=0 chnl=0 letter="x"
-char id=121    x=38    y=59    width=16    height=21    xoffset=1     yoffset=8     xadvance=16    page=0 chnl=0 letter="y"
-char id=122    x=220   y=124   width=16    height=15    xoffset=1     yoffset=8     xadvance=17    page=0 chnl=0 letter="z"
-char id=123    x=408   y=103   width=6     height=19    xoffset=1     yoffset=4     xadvance=7     page=0 chnl=0 letter="{"
-char id=124    x=31    y=33    width=3     height=24    xoffset=1     yoffset=2     xadvance=5     page=0 chnl=0 letter="|"
-char id=125    x=416   y=103   width=6     height=19    xoffset=1     yoffset=4     xadvance=7     page=0 chnl=0 letter="}"
-char id=126    x=55    y=141   width=10    height=4     xoffset=1     yoffset=13    xadvance=10    page=0 chnl=0 letter="~"
-char id=161    x=467   y=103   width=3     height=19    xoffset=1     yoffset=4     xadvance=5     page=0 chnl=0 letter="¡"
-char id=162    x=384   y=33    width=16    height=22    xoffset=1     yoffset=4     xadvance=15    page=0 chnl=0 letter="¢"
-char id=163    x=246   y=103   width=17    height=19    xoffset=1     yoffset=4     xadvance=18    page=0 chnl=0 letter="£"
-char id=164    x=342   y=124   width=14    height=14    xoffset=1     yoffset=7     xadvance=15    page=0 chnl=0 letter="¤"
-char id=165    x=320   y=103   width=15    height=19    xoffset=1     yoffset=4     xadvance=15    page=0 chnl=0 letter="¥"
-char id=166    x=358   y=33    width=3     height=23    xoffset=4     yoffset=3     xadvance=9     page=0 chnl=0 letter="¦"
-char id=167    x=324   y=33    width=12    height=23    xoffset=3     yoffset=4     xadvance=15    page=0 chnl=0 letter="§"
-char id=168    x=134   y=141   width=8     height=3     xoffset=1     yoffset=-1    xadvance=9     page=0 chnl=0 letter="¨"
-char id=169    x=71    y=59    width=20    height=20    xoffset=1     yoffset=3     xadvance=21    page=0 chnl=0 letter="©"
-char id=170    x=469   y=124   width=9     height=10    xoffset=2     yoffset=3     xadvance=11    page=0 chnl=0 letter="ª"
-char id=171    x=358   y=124   width=12    height=12    xoffset=1     yoffset=10    xadvance=13    page=0 chnl=0 letter="«"
-char id=172    x=492   y=124   width=15    height=8     xoffset=3     yoffset=12    xadvance=19    page=0 chnl=0 letter="¬"
-char id=173    x=94    y=141   width=12    height=3     xoffset=2     yoffset=14    xadvance=14    page=0 chnl=0 letter="­"
-char id=174    x=93    y=59    width=20    height=20    xoffset=1     yoffset=3     xadvance=21    page=0 chnl=0 letter="®"
-char id=175    x=121   y=141   width=11    height=3     xoffset=1     yoffset=3     xadvance=12    page=0 chnl=0 letter="¯"
-char id=176    x=480   y=124   width=10    height=9     xoffset=1     yoffset=4     xadvance=11    page=0 chnl=0 letter="°"
-char id=177    x=238   y=124   width=15    height=15    xoffset=3     yoffset=8     xadvance=19    page=0 chnl=0 letter="±"
-char id=178    x=386   y=124   width=8     height=12    xoffset=2     yoffset=-0    xadvance=10    page=0 chnl=0 letter="²"
-char id=179    x=396   y=124   width=8     height=12    xoffset=2     yoffset=-0    xadvance=10    page=0 chnl=0 letter="³"
-char id=180    x=38    y=141   width=4     height=5     xoffset=1     yoffset=-3    xadvance=5     page=0 chnl=0 letter="´"
-char id=181    x=369   y=103   width=12    height=19    xoffset=2     yoffset=9     xadvance=15    page=0 chnl=0 letter="µ"
-char id=182    x=86    y=103   width=19    height=19    xoffset=1     yoffset=4     xadvance=20    page=0 chnl=0 letter="¶"
-char id=183    x=67    y=141   width=4     height=4     xoffset=2     yoffset=13    xadvance=8     page=0 chnl=0 letter="·"
-char id=184    x=44    y=141   width=4     height=5     xoffset=1     yoffset=22    xadvance=5     page=0 chnl=0 letter="¸"
-char id=185    x=406   y=124   width=8     height=12    xoffset=2     yoffset=-0    xadvance=10    page=0 chnl=0 letter="¹"
-char id=186    x=457   y=124   width=10    height=10    xoffset=1     yoffset=3     xadvance=11    page=0 chnl=0 letter="º"
-char id=187    x=372   y=124   width=12    height=12    xoffset=1     yoffset=10    xadvance=13    page=0 chnl=0 letter="»"
-char id=188    x=137   y=59    width=19    height=20    xoffset=1     yoffset=3     xadvance=19    page=0 chnl=0 letter="¼"
-char id=189    x=158   y=59    width=19    height=20    xoffset=1     yoffset=3     xadvance=19    page=0 chnl=0 letter="½"
-char id=190    x=179   y=59    width=18    height=20    xoffset=1     yoffset=3     xadvance=19    page=0 chnl=0 letter="¾"
-char id=191    x=265   y=103   width=17    height=19    xoffset=0     yoffset=4     xadvance=16    page=0 chnl=0 letter="¿"
-char id=192    x=20    y=2     width=19    height=26    xoffset=1     yoffset=-3    xadvance=20    page=0 chnl=0 letter="À"
-char id=193    x=41    y=2     width=19    height=26    xoffset=1     yoffset=-3    xadvance=20    page=0 chnl=0 letter="Á"
-char id=194    x=229   y=2     width=19    height=25    xoffset=1     yoffset=-2    xadvance=20    page=0 chnl=0 letter="Â"
-char id=195    x=250   y=2     width=19    height=25    xoffset=1     yoffset=-2    xadvance=20    page=0 chnl=0 letter="Ã"
-char id=196    x=439   y=2     width=19    height=24    xoffset=1     yoffset=-1    xadvance=20    page=0 chnl=0 letter="Ä"
-char id=197    x=271   y=2     width=19    height=25    xoffset=1     yoffset=-2    xadvance=20    page=0 chnl=0 letter="Å"
-char id=198    x=328   y=59    width=33    height=19    xoffset=1     yoffset=4     xadvance=33    page=0 chnl=0 letter="Æ"
-char id=199    x=363   y=33    width=19    height=22    xoffset=1     yoffset=4     xadvance=20    page=0 chnl=0 letter="Ç"
-char id=200    x=167   y=2     width=17    height=26    xoffset=1     yoffset=-3    xadvance=18    page=0 chnl=0 letter="È"
-char id=201    x=186   y=2     width=17    height=26    xoffset=1     yoffset=-3    xadvance=18    page=0 chnl=0 letter="É"
-char id=202    x=376   y=2     width=17    height=25    xoffset=1     yoffset=-2    xadvance=18    page=0 chnl=0 letter="Ê"
-char id=203    x=2     y=33    width=17    height=24    xoffset=1     yoffset=-1    xadvance=18    page=0 chnl=0 letter="Ë"
-char id=204    x=217   y=2     width=4     height=26    xoffset=1     yoffset=-3    xadvance=5     page=0 chnl=0 letter="Ì"
-char id=205    x=223   y=2     width=4     height=26    xoffset=1     yoffset=-3    xadvance=5     page=0 chnl=0 letter="Í"
-char id=206    x=410   y=2     width=6     height=25    xoffset=-0    yoffset=-2    xadvance=5     page=0 chnl=0 letter="Î"
-char id=207    x=21    y=33    width=8     height=24    xoffset=-1    yoffset=-1    xadvance=5     page=0 chnl=0 letter="Ï"
-char id=208    x=107   y=103   width=19    height=19    xoffset=-0    yoffset=4     xadvance=18    page=0 chnl=0 letter="Ð"
-char id=209    x=292   y=2     width=19    height=25    xoffset=1     yoffset=-2    xadvance=20    page=0 chnl=0 letter="Ñ"
-char id=210    x=62    y=2     width=19    height=26    xoffset=1     yoffset=-3    xadvance=20    page=0 chnl=0 letter="Ò"
-char id=211    x=83    y=2     width=19    height=26    xoffset=1     yoffset=-3    xadvance=20    page=0 chnl=0 letter="Ó"
-char id=212    x=313   y=2     width=19    height=25    xoffset=1     yoffset=-2    xadvance=20    page=0 chnl=0 letter="Ô"
-char id=213    x=334   y=2     width=19    height=25    xoffset=1     yoffset=-2    xadvance=20    page=0 chnl=0 letter="Õ"
-char id=214    x=460   y=2     width=19    height=24    xoffset=1     yoffset=-1    xadvance=20    page=0 chnl=0 letter="Ö"
-char id=215    x=430   y=124   width=12    height=11    xoffset=1     yoffset=10    xadvance=13    page=0 chnl=0 letter="×"
-char id=216    x=199   y=59    width=18    height=20    xoffset=1     yoffset=3     xadvance=19    page=0 chnl=0 letter="Ø"
-char id=217    x=104   y=2     width=19    height=26    xoffset=1     yoffset=-3    xadvance=20    page=0 chnl=0 letter="Ù"
-char id=218    x=125   y=2     width=19    height=26    xoffset=1     yoffset=-3    xadvance=20    page=0 chnl=0 letter="Ú"
-char id=219    x=355   y=2     width=19    height=25    xoffset=1     yoffset=-2    xadvance=20    page=0 chnl=0 letter="Û"
-char id=220    x=481   y=2     width=19    height=24    xoffset=1     yoffset=-1    xadvance=20    page=0 chnl=0 letter="Ü"
-char id=221    x=146   y=2     width=19    height=26    xoffset=0     yoffset=-3    xadvance=19    page=0 chnl=0 letter="Ý"
-char id=222    x=383   y=103   width=12    height=19    xoffset=2     yoffset=4     xadvance=13    page=0 chnl=0 letter="Þ"
-char id=223    x=128   y=103   width=19    height=19    xoffset=1     yoffset=4     xadvance=20    page=0 chnl=0 letter="ß"
-char id=224    x=36    y=33    width=16    height=23    xoffset=1     yoffset=-0    xadvance=17    page=0 chnl=0 letter="à"
-char id=225    x=54    y=33    width=16    height=23    xoffset=1     yoffset=-0    xadvance=17    page=0 chnl=0 letter="á"
-char id=226    x=72    y=33    width=16    height=23    xoffset=1     yoffset=-0    xadvance=17    page=0 chnl=0 letter="â"
-char id=227    x=90    y=33    width=16    height=23    xoffset=1     yoffset=-0    xadvance=17    page=0 chnl=0 letter="ã"
-char id=228    x=402   y=33    width=16    height=22    xoffset=1     yoffset=1     xadvance=17    page=0 chnl=0 letter="ä"
-char id=229    x=108   y=33    width=16    height=23    xoffset=1     yoffset=-0    xadvance=17    page=0 chnl=0 letter="å"
-char id=230    x=477   y=103   width=28    height=15    xoffset=1     yoffset=8     xadvance=28    page=0 chnl=0 letter="æ"
-char id=231    x=302   y=103   width=16    height=19    xoffset=1     yoffset=7     xadvance=17    page=0 chnl=0 letter="ç"
-char id=232    x=126   y=33    width=16    height=23    xoffset=1     yoffset=-0    xadvance=15    page=0 chnl=0 letter="è"
-char id=233    x=144   y=33    width=16    height=23    xoffset=1     yoffset=-0    xadvance=15    page=0 chnl=0 letter="é"
-char id=234    x=162   y=33    width=16    height=23    xoffset=1     yoffset=-0    xadvance=15    page=0 chnl=0 letter="ê"
-char id=235    x=420   y=33    width=16    height=22    xoffset=1     yoffset=1     xadvance=15    page=0 chnl=0 letter="ë"
-char id=236    x=346   y=33    width=4     height=23    xoffset=0     yoffset=-0    xadvance=5     page=0 chnl=0 letter="ì"
-char id=237    x=352   y=33    width=4     height=23    xoffset=1     yoffset=-0    xadvance=5     page=0 chnl=0 letter="í"
-char id=238    x=338   y=33    width=6     height=23    xoffset=-0    yoffset=-0    xadvance=5     page=0 chnl=0 letter="î"
-char id=239    x=474   y=33    width=8     height=22    xoffset=-1    yoffset=1     xadvance=5     page=0 chnl=0 letter="ï"
-char id=240    x=56    y=59    width=13    height=21    xoffset=1     yoffset=2     xadvance=14    page=0 chnl=0 letter="ð"
-char id=241    x=180   y=33    width=16    height=23    xoffset=1     yoffset=-0    xadvance=17    page=0 chnl=0 letter="ñ"
-char id=242    x=198   y=33    width=16    height=23    xoffset=1     yoffset=-0    xadvance=17    page=0 chnl=0 letter="ò"
-char id=243    x=216   y=33    width=16    height=23    xoffset=1     yoffset=-0    xadvance=17    page=0 chnl=0 letter="ó"
-char id=244    x=234   y=33    width=16    height=23    xoffset=1     yoffset=-0    xadvance=17    page=0 chnl=0 letter="ô"
-char id=245    x=252   y=33    width=16    height=23    xoffset=1     yoffset=-0    xadvance=17    page=0 chnl=0 letter="õ"
-char id=246    x=438   y=33    width=16    height=22    xoffset=1     yoffset=1     xadvance=17    page=0 chnl=0 letter="ö"
-char id=247    x=271   y=124   width=13    height=15    xoffset=0     yoffset=8     xadvance=12    page=0 chnl=0 letter="÷"
-char id=248    x=255   y=124   width=14    height=15    xoffset=1     yoffset=8     xadvance=15    page=0 chnl=0 letter="ø"
-char id=249    x=270   y=33    width=16    height=23    xoffset=1     yoffset=-0    xadvance=17    page=0 chnl=0 letter="ù"
-char id=250    x=288   y=33    width=16    height=23    xoffset=1     yoffset=-0    xadvance=17    page=0 chnl=0 letter="ú"
-char id=251    x=306   y=33    width=16    height=23    xoffset=1     yoffset=-0    xadvance=17    page=0 chnl=0 letter="û"
-char id=252    x=456   y=33    width=16    height=22    xoffset=1     yoffset=1     xadvance=17    page=0 chnl=0 letter="ü"
-char id=253    x=2     y=2     width=16    height=29    xoffset=1     yoffset=-0    xadvance=17    page=0 chnl=0 letter="ý"
-char id=254    x=395   y=2     width=13    height=25    xoffset=2     yoffset=3     xadvance=15    page=0 chnl=0 letter="þ"
-char id=8984   x=115   y=59    width=20    height=20    xoffset=3     yoffset=3     xadvance=24    page=0 chnl=0 letter="⌘"
-kernings count=140
-kerning first=65 second=87 amount=-1
-kerning first=66 second=86 amount=-1
-kerning first=66 second=89 amount=-1
-kerning first=66 second=94 amount=-1
-kerning first=68 second=86 amount=-1
-kerning first=68 second=90 amount=-1
-kerning first=68 second=94 amount=-1
-kerning first=69 second=77 amount=-1
-kerning first=69 second=79 amount=-1
-kerning first=70 second=74 amount=-6
-kerning first=71 second=87 amount=-1
-kerning first=75 second=65 amount=-1
-kerning first=75 second=72 amount=-1
-kerning first=76 second=86 amount=-6
-kerning first=76 second=87 amount=-3
-kerning first=76 second=89 amount=-4
-kerning first=76 second=94 amount=-6
-kerning first=79 second=86 amount=-1
-kerning first=79 second=87 amount=-1
-kerning first=79 second=88 amount=-1
-kerning first=79 second=94 amount=-1
-kerning first=80 second=74 amount=-4
-kerning first=83 second=87 amount=-1
-kerning first=84 second=111 amount=-3
-kerning first=84 second=115 amount=-3
-kerning first=84 second=117 amount=-2
-kerning first=84 second=119 amount=-2
-kerning first=84 second=121 amount=-2
-kerning first=84 second=122 amount=-2
-kerning first=84 second=185 amount=-2
-kerning first=84 second=188 amount=-2
-kerning first=86 second=65 amount=-1
-kerning first=86 second=79 amount=-1
-kerning first=86 second=111 amount=-1
-kerning first=86 second=115 amount=-1
-kerning first=87 second=65 amount=-1
-kerning first=87 second=79 amount=-1
-kerning first=87 second=101 amount=-1
-kerning first=87 second=111 amount=-1
-kerning first=87 second=154 amount=-1
-kerning first=88 second=66 amount=-1
-kerning first=89 second=83 amount=-1
-kerning first=89 second=97 amount=-2
-kerning first=89 second=101 amount=-3
-kerning first=89 second=111 amount=-3
-kerning first=89 second=112 amount=-2
-kerning first=89 second=115 amount=-3
-kerning first=89 second=117 amount=-2
-kerning first=89 second=154 amount=-3
-kerning first=94 second=65 amount=-1
-kerning first=94 second=79 amount=-1
-kerning first=94 second=111 amount=-1
-kerning first=94 second=115 amount=-1
-kerning first=97 second=98 amount=-1
-kerning first=97 second=119 amount=-1
-kerning first=97 second=122 amount=-1
-kerning first=97 second=188 amount=-1
-kerning first=98 second=100 amount=1
-kerning first=98 second=146 amount=1
-kerning first=99 second=101 amount=-1
-kerning first=99 second=116 amount=-1
-kerning first=99 second=154 amount=-1
-kerning first=100 second=111 amount=-1
-kerning first=100 second=117 amount=-1
-kerning first=101 second=119 amount=-1
-kerning first=102 second=44 amount=-4
-kerning first=102 second=145 amount=-4
-kerning first=103 second=115 amount=-1
-kerning first=103 second=117 amount=-1
-kerning first=105 second=97 amount=-1
-kerning first=105 second=102 amount=-1
-kerning first=105 second=112 amount=-1
-kerning first=105 second=120 amount=-1
-kerning first=105 second=174 amount=-1
-kerning first=105 second=254 amount=-1
-kerning first=108 second=118 amount=-1
-kerning first=108 second=119 amount=-2
-kerning first=108 second=166 amount=-1
-kerning first=109 second=119 amount=-1
-kerning first=110 second=120 amount=-1
-kerning first=110 second=254 amount=-1
-kerning first=111 second=116 amount=-1
-kerning first=111 second=117 amount=-1
-kerning first=111 second=119 amount=-1
-kerning first=111 second=120 amount=-1
-kerning first=111 second=254 amount=-1
-kerning first=112 second=32 amount=-1
-kerning first=112 second=100 amount=1
-kerning first=112 second=146 amount=1
-kerning first=112 second=160 amount=-1
-kerning first=113 second=117 amount=-1
-kerning first=114 second=44 amount=-6
-kerning first=114 second=145 amount=-6
-kerning first=115 second=110 amount=-1
-kerning first=115 second=120 amount=-1
-kerning first=115 second=122 amount=-1
-kerning first=115 second=171 amount=-1
-kerning first=115 second=188 amount=-1
-kerning first=115 second=254 amount=-1
-kerning first=118 second=101 amount=-1
-kerning first=118 second=111 amount=-1
-kerning first=118 second=115 amount=-1
-kerning first=118 second=154 amount=-1
-kerning first=120 second=101 amount=-1
-kerning first=120 second=154 amount=-1
-kerning first=121 second=97 amount=-1
-kerning first=121 second=111 amount=-1
-kerning first=122 second=32 amount=-6
-kerning first=122 second=97 amount=-1
-kerning first=122 second=101 amount=-1
-kerning first=122 second=154 amount=-1
-kerning first=122 second=160 amount=-6
-kerning first=137 second=101 amount=-1
-kerning first=137 second=116 amount=-1
-kerning first=137 second=154 amount=-1
-kerning first=146 second=111 amount=-1
-kerning first=146 second=117 amount=-1
-kerning first=154 second=119 amount=-1
-kerning first=155 second=198 amount=-1
-kerning first=156 second=193 amount=-1
-kerning first=166 second=101 amount=-1
-kerning first=166 second=111 amount=-1
-kerning first=166 second=115 amount=-1
-kerning first=166 second=154 amount=-1
-kerning first=171 second=120 amount=-1
-kerning first=171 second=254 amount=-1
-kerning first=173 second=192 amount=-1
-kerning first=174 second=44 amount=-4
-kerning first=174 second=145 amount=-4
-kerning first=185 second=97 amount=-1
-kerning first=185 second=111 amount=-1
-kerning first=188 second=32 amount=-6
-kerning first=188 second=97 amount=-1
-kerning first=188 second=101 amount=-1
-kerning first=188 second=154 amount=-1
-kerning first=188 second=160 amount=-6
-kerning first=233 second=193 amount=-1
-kerning first=245 second=196 amount=-1
-kerning first=254 second=101 amount=-1
-kerning first=254 second=154 amount=-1
\ No newline at end of file
diff --git a/tests/gdx-tests-android/assets/data/utf-font.png b/tests/gdx-tests-android/assets/data/utf-font.png
deleted file mode 100644
index f258217..0000000
Binary files a/tests/gdx-tests-android/assets/data/utf-font.png and /dev/null differ
diff --git a/tests/gdx-tests-iosrobovm/Info.plist.xml b/tests/gdx-tests-iosrobovm/Info.plist.xml
index 3a10b49..a823fe8 100644
--- a/tests/gdx-tests-iosrobovm/Info.plist.xml
+++ b/tests/gdx-tests-iosrobovm/Info.plist.xml
@@ -24,10 +24,8 @@
     <string>${app.build}</string>
     <key>LSRequiresIPhoneOS</key>
     <true/>
-    <key>UIViewControllerBasedStatusBarAppearance</key>
-    <false/>
     <key>UIStatusBarHidden</key>
-    <false/>
+    <true/>
     <key>UIDeviceFamily</key>
     <array>
         <integer>1</integer>
diff --git a/tests/gdx-tests-iosrobovm/src/com/badlogic/gdx/tests/IOSRobovmTests.java b/tests/gdx-tests-iosrobovm/src/com/badlogic/gdx/tests/IOSRobovmTests.java
index 8e216d6..f304953 100644
--- a/tests/gdx-tests-iosrobovm/src/com/badlogic/gdx/tests/IOSRobovmTests.java
+++ b/tests/gdx-tests-iosrobovm/src/com/badlogic/gdx/tests/IOSRobovmTests.java
@@ -18,11 +18,10 @@ package com.badlogic.gdx.tests;
 
 import org.robovm.cocoatouch.foundation.NSAutoreleasePool;
 import org.robovm.cocoatouch.uikit.UIApplication;
-
+
 import com.badlogic.gdx.backends.iosrobovm.IOSApplication;
 import com.badlogic.gdx.backends.iosrobovm.IOSApplicationConfiguration;
 import com.badlogic.gdx.tests.net.PingPongSocketExample;
-import com.badlogic.gdx.tests.utils.GdxTest;
 
 public class IOSRobovmTests extends IOSApplication.Delegate {
 	class InnerClass {
@@ -31,13 +30,7 @@ public class IOSRobovmTests extends IOSApplication.Delegate {
 	@Override
 	protected IOSApplication createApplication() {
 		IOSApplicationConfiguration config = new IOSApplicationConfiguration();
-		return new IOSApplication(new GdxTest() {
-
-			@Override
-			public void resize (int width, int height) {
-				System.out.println(width + ", " + height);
-			}
-		}, config);
+		return new IOSApplication(new BulletTestCollection(), config);
 	}
 
 	public static void main(String[] argv) {
diff --git a/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java b/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java
index 796192c..eb8182f 100644
--- a/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java
+++ b/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java
@@ -16,15 +16,10 @@
 
 package com.badlogic.gdx.tests.lwjgl;
 
-import com.badlogic.gdx.ApplicationAdapter;
-import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.backends.lwjgl.LwjglApplication;
 import com.badlogic.gdx.backends.lwjgl.LwjglApplicationConfiguration;
-import com.badlogic.gdx.graphics.g2d.BitmapFont.BitmapFontData;
-import com.badlogic.gdx.tests.FullscreenTest;
 import com.badlogic.gdx.tests.Scene2dTest;
 import com.badlogic.gdx.tests.UBJsonTest;
-import com.badlogic.gdx.tests.UtfFontTest;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
 public class LwjglDebugStarter {
@@ -36,7 +31,7 @@ public class LwjglDebugStarter {
 //		new SharedLibraryLoader("../../extensions/gdx-controllers/gdx-controllers-desktop/libs/gdx-controllers-desktop-natives.jar").load("gdx-controllers-desktop");
 //		new SharedLibraryLoader("../../gdx/libs/gdx-natives.jar").load("gdx");
 
-		GdxTest test = new FullscreenTest();		
+		GdxTest test = new UBJsonTest();
 		LwjglApplicationConfiguration config = new LwjglApplicationConfiguration();
 		config.useGL20 = test.needsGL20();
 //		config.width = 320;
diff --git a/tests/gdx-tests/.settings/org.eclipse.core.resources.prefs b/tests/gdx-tests/.settings/org.eclipse.core.resources.prefs
index b779578..4b5f8d6 100644
--- a/tests/gdx-tests/.settings/org.eclipse.core.resources.prefs
+++ b/tests/gdx-tests/.settings/org.eclipse.core.resources.prefs
@@ -1,3 +1,3 @@
+#Sun Sep 16 18:28:43 CEST 2012
 eclipse.preferences.version=1
-encoding//src/com/badlogic/gdx/tests/UtfFontTest.java=UTF-8
 encoding//src/com/badlogic/gdx/tests/extensions/InternationalFontsTest.java=UTF-8
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/FullscreenTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/FullscreenTest.java
index 2dcc7a5..069451d 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/FullscreenTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/FullscreenTest.java
@@ -73,7 +73,6 @@ public class FullscreenTest extends GdxTest {
 	@Override
 	public void resize (int width, int height) {
 		Gdx.app.log("FullscreenTest", "resized: " + width + ", " + height);
-		Gdx.gl.glViewport(0, 0, width, height);
 	}
 
 	@Override
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/UtfFontTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/UtfFontTest.java
deleted file mode 100644
index 5e7b14e..0000000
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/UtfFontTest.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package com.badlogic.gdx.tests;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.g2d.BitmapFont;
-import com.badlogic.gdx.graphics.g2d.SpriteBatch;
-import com.badlogic.gdx.tests.utils.GdxTest;
-
-/**
- * See <a href="https://github.com/libgdx/libgdx/issues/1315">#1315</a>
- * @author badlogic
- *
- */
-public class UtfFontTest extends GdxTest {
-	BitmapFont font;
-	SpriteBatch batch;
-	
-	@Override
-	public boolean needsGL20 () {
-		return true;
-	}
-
-	@Override
-	public void create () {
-		batch = new SpriteBatch();
-		font = new BitmapFont(Gdx.files.internal("data/utf-font.fnt"));
-	}
-
-	@Override
-	public void render () {
-		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
-		batch.begin();
-		font.draw(batch, "test ⌘", 29, 20);
-		batch.end();
-	}
-}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/net/HttpRequestExample.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/net/HttpRequestExample.java
index 8688c21..c8ca0a9 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/net/HttpRequestExample.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/net/HttpRequestExample.java
@@ -44,11 +44,6 @@ public class HttpRequestExample extends GdxTest {
 			@Override
 			public void failed(Throwable t) {
 				Gdx.app.error("HttpRequestExample", "something went wrong", t);
-			}
-
-			@Override
-			public void cancelled () {
-				Gdx.app.log("HttpRequestExample", "cancelled");
 			}
 		});
 	}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/net/NetAPITest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/net/NetAPITest.java
index 20af330..068f868 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/net/NetAPITest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/net/NetAPITest.java
@@ -46,12 +46,10 @@ public class NetAPITest extends GdxTest implements HttpResponseListener {
 	TextButton btnDownloadText;
 	TextButton btnDownloadError;
 	TextButton btnPost;
-	TextButton btnCancel;
 	Label statusLabel;
 	Texture texture;
 	String text;
 	BitmapFont font;
-	HttpRequest httpRequest;
 
 	Object clickedButton;
 
@@ -114,7 +112,7 @@ public class NetAPITest extends GdxTest implements HttpResponseListener {
 						requestContent = "name1=value1&name2=value2";
 					}
 
-					httpRequest = new HttpRequest(httpMethod);
+					HttpRequest httpRequest = new HttpRequest(httpMethod);
 					httpRequest.setUrl(url);
 					httpRequest.setContent(requestContent);
 					Gdx.net.sendHttpRequest(httpRequest, NetAPITest.this);
@@ -122,23 +120,9 @@ public class NetAPITest extends GdxTest implements HttpResponseListener {
 					statusLabel.setText("Downloading data from " + httpRequest.getUrl());
 				}
 			};
-			
-			ClickListener cancelListener = new ClickListener() {
-				@Override
-				public void clicked (InputEvent event, float x, float y) {
-					super.clicked(event, x, y);
-					Gdx.net.cancelHttpRequest(httpRequest);					
-					statusLabel.setText("Cancelling request " + httpRequest.getUrl());
-				}
-			};
 
-			btnCancel = new TextButton("Cancel", skin);
-			btnCancel.setPosition(Gdx.graphics.getWidth() * 0.5f - btnCancel.getWidth() * 1.5f, 60f);
-			btnCancel.addListener(cancelListener);
-			stage.addActor(btnCancel);
-			
 			btnDownloadImage = new TextButton("GET Image", skin);
-			btnDownloadImage.setPosition(btnCancel.getX() + btnCancel.getWidth() + 10, 60f);
+			btnDownloadImage.setPosition(Gdx.graphics.getWidth() * 0.5f - btnDownloadImage.getWidth() * 1.5f, 60f);
 			btnDownloadImage.addListener(clickListener);
 			stage.addActor(btnDownloadImage);
 
@@ -250,14 +234,4 @@ public class NetAPITest extends GdxTest implements HttpResponseListener {
 		stage.setViewport(width, height, false);
 	}
 
-	@Override
-	public void cancelled () {
-		Gdx.app.postRunnable(new Runnable() {
-			public void run () {
-				setButtonDisabled(false);
-				statusLabel.setText("HTTP request cancelled");
-			}
-		});
-	}
-
 }
