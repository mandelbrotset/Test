diff --git a/CHANGES b/CHANGES
index b215751..96bb025 100644
--- a/CHANGES
+++ b/CHANGES
@@ -1,10 +1,18 @@
-[1.1.1]
+[1.2.1]
+- API Addition: 3d particle system and accompanying editor, contributed by lordjone, see https://github.com/libgdx/libgdx/pull/2005
+- API Addition: extended shape classes like Circle, Ellipse etc. with hashcode/equals and other helper methods, see https://github.com/libgdx/libgdx/pull/2018
+- minor API change (will not increase minor revision number): fixed a bug in handling of atlasPrefixes, https://github.com/libgdx/libgdx/pull/2023
+
+
+[1.2.0]
 - API Addition: Some OpenGL profiling utilities have been added, see https://github.com/libgdx/libgdx/wiki/Profiling
 - API Addition: A FreeTypeFontGeneratorLoader has been added to the gdx-freetype extension
 - API change: Animation#frameDuration and #animationDuration are now hidden behind a getter/setter and dynamic
 - API Addition: Vector#setZero
 - API Addition: gdx-ai, extension for AI algorithms. Currently supports FSMs, see https://github.com/libgdx/libgdx/wiki/Artificial-Intelligence
 - API change: TableLayout has been forked and integrated into libgdx more tightly, see http://www.badlogicgames.com/wordpress/?p=3458
+- API Addition: added equals/hashCode methods to Rectangle, may break old code (very, very unlikely)
+- API Addition: scene2D Actors now have a setCenterPosition method, see https://github.com/libgdx/libgdx/pull/2000
 
 [1.1.0]
 - Updated to RoboVM 0.0.13 and RoboVM Gradle plugin 0.0.9
diff --git a/backends/gdx-backend-android/pom.xml b/backends/gdx-backend-android/pom.xml
index 098f8dd..2421108 100644
--- a/backends/gdx-backend-android/pom.xml
+++ b/backends/gdx-backend-android/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.1-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/backends/gdx-backend-headless/pom.xml b/backends/gdx-backend-headless/pom.xml
index 4a5d349..a3bea65 100644
--- a/backends/gdx-backend-headless/pom.xml
+++ b/backends/gdx-backend-headless/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.1-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/backends/gdx-backend-jglfw/pom.xml b/backends/gdx-backend-jglfw/pom.xml
index c534b4a..026c2c0 100644
--- a/backends/gdx-backend-jglfw/pom.xml
+++ b/backends/gdx-backend-jglfw/pom.xml
@@ -4,7 +4,7 @@
 	<parent>
 		<groupId>com.badlogicgames.gdx</groupId>
 		<artifactId>gdx-parent</artifactId>
-		<version>1.1.1-SNAPSHOT</version>
+		<version>1.2.1-SNAPSHOT</version>
 		<relativePath>../../pom.xml</relativePath>
 	</parent>
 
diff --git a/backends/gdx-backend-lwjgl/pom.xml b/backends/gdx-backend-lwjgl/pom.xml
index fcf40cc..ca192da 100644
--- a/backends/gdx-backend-lwjgl/pom.xml
+++ b/backends/gdx-backend-lwjgl/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.1-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGraphics.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGraphics.java
index cf5c18d..2c0af30 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGraphics.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGraphics.java
@@ -152,10 +152,8 @@ public class LwjglGraphics implements Graphics {
 		Display.setInitialBackground(config.initialBackgroundColor.r, config.initialBackgroundColor.g,
 			config.initialBackgroundColor.b);
 
-		if (config.x != -1 && config.y != -1) Display.setLocation(config.x, config.y);
+		Display.setLocation(config.x, config.y);
 		createDisplayPixelFormat();
-		config.x = Display.getX();
-		config.y = Display.getY();
 		initiateGLInstances();
 	}
 
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/audio/OggInputStream.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/audio/OggInputStream.java
index 38d59f9..c976e7b 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/audio/OggInputStream.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/audio/OggInputStream.java
@@ -87,7 +87,7 @@ public class OggInputStream extends InputStream {
 	/** The index into the byte array we currently read from */
 	private int readIndex;
 	/** The byte array store used to hold the data read from the ogg */
-	private ByteBuffer pcmBuffer = BufferUtils.createByteBuffer(BUFFER_SIZE * 500);
+	private ByteBuffer pcmBuffer = BufferUtils.createByteBuffer(4096 * 500);
 	/** The total number of bytes */
 	private int total;
 
@@ -351,8 +351,8 @@ public class OggInputStream extends InputStream {
 									}
 
 									int bytesToWrite = 2 * oggInfo.channels * bout;
-									if (bytesToWrite >= pcmBuffer.remaining()) {
-										throw new GdxRuntimeException("Ogg block too big to be buffered: " + bytesToWrite);
+									if (bytesToWrite > pcmBuffer.remaining()) {
+										throw new GdxRuntimeException("Ogg block too big to be buffered: " + bytesToWrite + " :: " + pcmBuffer.remaining());
 									} else {
 										pcmBuffer.put(convbuffer, 0, bytesToWrite);
 									}
diff --git a/backends/gdx-backend-robovm/pom.xml b/backends/gdx-backend-robovm/pom.xml
index ce98b8b..f85dcb4 100644
--- a/backends/gdx-backend-robovm/pom.xml
+++ b/backends/gdx-backend-robovm/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.1-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplication.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplication.java
index b2f0e45..f241114 100644
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplication.java
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplication.java
@@ -19,6 +19,7 @@ package com.badlogic.gdx.backends.iosrobovm;
 import java.io.File;
 
 import org.robovm.apple.coregraphics.CGSize;
+import org.robovm.apple.foundation.Foundation;
 import org.robovm.apple.foundation.NSDictionary;
 import org.robovm.apple.foundation.NSMutableDictionary;
 import org.robovm.apple.foundation.NSObject;
@@ -43,6 +44,7 @@ import com.badlogic.gdx.Input;
 import com.badlogic.gdx.LifecycleListener;
 import com.badlogic.gdx.Net;
 import com.badlogic.gdx.Preferences;
+import com.badlogic.gdx.backends.iosrobovm.objectal.OALAudioSession;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.Clipboard;
@@ -67,6 +69,11 @@ public class IOSApplication implements Application {
 		}
 
 		@Override
+		public void willEnterForeground (UIApplication application) {
+			app.willEnterForeground(application);
+		}
+
+		@Override
 		public void willResignActive (UIApplication application) {
 			app.willResignActive(application);
 		}
@@ -174,7 +181,6 @@ public class IOSApplication implements Application {
 	 * @return Or real display dimension. */
 	CGSize getBounds (UIViewController viewController) {
 		// or screen size (always portrait)
-// CGSize bounds = UIScreen.getMainScreen().getBounds().size();
 		CGSize bounds = UIScreen.getMainScreen().getApplicationFrame().size();
 
 		// determine orientation and resulting width + height
@@ -220,11 +226,17 @@ public class IOSApplication implements Application {
 		Gdx.app.debug("IOSApplication", "resumed");
 		// workaround for ObjectAL crash problem
 		// see: https://groups.google.com/forum/?fromgroups=#!topic/objectal-for-iphone/ubRWltp_i1Q
-		// OALAudioSession.sharedInstance().forceEndInterrupt();
+		OALAudioSession.sharedInstance().forceEndInterruption();
 		graphics.makeCurrent();
 		graphics.resume();
 	}
 
+	final void willEnterForeground (UIApplication uiApp) {
+		// workaround for ObjectAL crash problem
+		// see: https://groups.google.com/forum/?fromgroups=#!topic/objectal-for-iphone/ubRWltp_i1Q
+		OALAudioSession.sharedInstance().forceEndInterruption();
+	}
+
 	final void willResignActive (UIApplication uiApp) {
 		Gdx.app.debug("IOSApplication", "paused");
 		graphics.makeCurrent();
@@ -355,20 +367,14 @@ public class IOSApplication implements Application {
 		File libraryPath = new File(System.getenv("HOME"), "Library");
 		File finalPath = new File(libraryPath, name + ".plist");
 
-		Gdx.app.debug("IOSApplication", "Loading NSDictionary from file " + finalPath);
 		@SuppressWarnings("unchecked")
 		NSMutableDictionary<NSString, NSObject> nsDictionary = (NSMutableDictionary<NSString, NSObject>)NSMutableDictionary
 			.read(finalPath);
 
 		// if it fails to get an existing dictionary, create a new one.
 		if (nsDictionary == null) {
-			Gdx.app.debug("IOSApplication", "NSDictionary not found, creating a new one");
 			nsDictionary = new NSMutableDictionary<NSString, NSObject>();
-			boolean fileWritten = nsDictionary.write(finalPath, false);
-			if (fileWritten)
-				Gdx.app.debug("IOSApplication", "NSDictionary file written");
-			else
-				Gdx.app.debug("IOSApplication", "Failed to write NSDictionary to file " + finalPath);
+			nsDictionary.write(finalPath, false);
 		}
 		return new IOSPreferences(nsDictionary, finalPath.getAbsolutePath());
 	}
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSAudio.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSAudio.java
index 2d94e8e..a063951 100644
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSAudio.java
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSAudio.java
@@ -17,6 +17,7 @@
 package com.badlogic.gdx.backends.iosrobovm;
 
 import com.badlogic.gdx.Audio;
+import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.audio.AudioDevice;
 import com.badlogic.gdx.audio.AudioRecorder;
 import com.badlogic.gdx.audio.Music;
@@ -29,8 +30,12 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
 public class IOSAudio implements Audio {
 
 	public IOSAudio (IOSApplicationConfiguration config) {
-		OALSimpleAudio.sharedInstance().setAllowIpod(config.allowIpod);
-		OALSimpleAudio.sharedInstance().setHonorSilentSwitch(true);
+		OALSimpleAudio audio = OALSimpleAudio.sharedInstance();
+		if (audio != null) {
+			audio.setAllowIpod(config.allowIpod);
+			audio.setHonorSilentSwitch(true);
+		} else
+			Gdx.app.error("IOSAudio", "No OALSimpleAudio instance available, audio will not be availabe");
 	}
 
 	@Override
@@ -62,4 +67,4 @@ public class IOSAudio implements Audio {
 		throw new GdxRuntimeException("Error opening music file at " + path);
 	}
 
-}
+}
\ No newline at end of file
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/OALAudioSession.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/OALAudioSession.java
new file mode 100644
index 0000000..f35df27
--- /dev/null
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/OALAudioSession.java
@@ -0,0 +1,22 @@
+
+package com.badlogic.gdx.backends.iosrobovm.objectal;
+
+import org.robovm.apple.foundation.NSObject;
+import org.robovm.objc.ObjCRuntime;
+import org.robovm.objc.annotation.Method;
+import org.robovm.objc.annotation.NativeClass;
+import org.robovm.rt.bro.annotation.Library;
+
+@Library(Library.INTERNAL)
+@NativeClass
+public final class OALAudioSession extends NSObject {
+	static {
+		ObjCRuntime.bind(OALAudioSession.class);
+	}
+
+	@Method
+	public native static OALAudioSession sharedInstance ();
+
+	@Method
+	public native void forceEndInterruption ();
+}
diff --git a/backends/gdx-backends-gwt/pom.xml b/backends/gdx-backends-gwt/pom.xml
index acc3f46..854a3d2 100644
--- a/backends/gdx-backends-gwt/pom.xml
+++ b/backends/gdx-backends-gwt/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.1-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtNet.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtNet.java
index f13a130..72be7f6 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtNet.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtNet.java
@@ -23,9 +23,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
-import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.Net;
-import com.badlogic.gdx.Net.HttpRequest;
 import com.badlogic.gdx.net.HttpStatus;
 import com.badlogic.gdx.net.ServerSocket;
 import com.badlogic.gdx.net.ServerSocketHints;
@@ -33,13 +31,11 @@ import com.badlogic.gdx.net.Socket;
 import com.badlogic.gdx.net.SocketHints;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 import com.badlogic.gdx.utils.ObjectMap;
-import com.google.gwt.core.client.EntryPoint;
 import com.google.gwt.http.client.Header;
 import com.google.gwt.http.client.Request;
 import com.google.gwt.http.client.RequestBuilder;
 import com.google.gwt.http.client.RequestCallback;
 import com.google.gwt.http.client.RequestException;
-import com.google.gwt.http.client.RequestTimeoutException;
 import com.google.gwt.http.client.Response;
 import com.google.gwt.user.client.Window;
 
@@ -112,19 +108,29 @@ public class GwtNet implements Net {
 			return;
 		}
 
-		final boolean is_get = (httpRequest.getMethod() == HttpMethods.GET);
+		final String method = httpRequest.getMethod();		
 		final String value = httpRequest.getContent();
-
+		final boolean valueInBody = method.equalsIgnoreCase(HttpMethods.POST) || method.equals(HttpMethods.PUT);
+		
 		RequestBuilder builder;
 		
 		String url = httpRequest.getUrl();
-		if (is_get) {
+		if (method.equalsIgnoreCase(HttpMethods.GET)) {
 			if (value != null) {
 				url += "?" + value;
-			}
+			}			
 			builder = new RequestBuilder(RequestBuilder.GET, url);
-		} else {
+		} else if (method.equalsIgnoreCase(HttpMethods.POST)) {
 			builder = new RequestBuilder(RequestBuilder.POST, url);
+		} else if (method.equalsIgnoreCase(HttpMethods.DELETE)) {
+			if (value != null) {
+				url += "?" + value;
+			}
+			builder = new RequestBuilder(RequestBuilder.DELETE, url);
+		} else if (method.equalsIgnoreCase(HttpMethods.PUT)) {
+			builder = new RequestBuilder(RequestBuilder.PUT, url);
+		} else {
+			throw new GdxRuntimeException("Unsupported HTTP Method");
 		}
 
 		Map<String, String> content = httpRequest.getHeaders();
@@ -136,7 +142,7 @@ public class GwtNet implements Net {
 		builder.setTimeoutMillis(httpRequest.getTimeOut());
 
 		try {
-			Request request = builder.sendRequest(is_get ? null : value, new RequestCallback() {
+			Request request = builder.sendRequest(valueInBody ? value : null, new RequestCallback() {
 
 				@Override
 				public void onResponseReceived (Request request, Response response) {					
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/Constructor.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/Constructor.java
index 257ce29..6aed79c 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/Constructor.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/Constructor.java
@@ -16,6 +16,8 @@
 
 package com.badlogic.gdx.utils.reflect;
 
+import com.badlogic.gwtref.client.Parameter;
+
 /** Provides information about, and access to, a single constructor for a Class.
  * @author nexsoftware */
 public final class Constructor {
@@ -28,7 +30,12 @@ public final class Constructor {
 
 	/** Returns an array of Class objects that represent the formal parameter types, in declaration order, of the constructor. */
 	public Class[] getParameterTypes () {
-		return null;
+		Parameter[] parameters = constructor.getParameters();
+		Class[] parameterTypes = new Class[parameters.length];
+		for (int i = 0, j = parameters.length; i < j; i++) {
+			parameterTypes[i] = parameters[i].getClazz();
+		}
+		return parameterTypes;
 	}
 
 	/** Returns the Class object representing the class or interface that declares the constructor. */
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/GwtReflect.gwt.xml b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/GwtReflect.gwt.xml
index a9a46b8..fdcff17 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/GwtReflect.gwt.xml
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/GwtReflect.gwt.xml
@@ -34,6 +34,21 @@
 		value="com.badlogic.gdx.graphics.VertexAttribute" />
 	<extend-configuration-property name="gdx.reflect.include"
 		value="com.badlogic.gdx.graphics.g3d.model" />
+
+	<extend-configuration-property name="gdx.reflect.include"
+		value="com.badlogic.gdx.graphics.g3d.particles.ParallelArray" />
+		
+	<extend-configuration-property name="gdx.reflect.include"
+		value="com.badlogic.gdx.graphics.g3d.particles.influencers" />
+	
+	<extend-configuration-property name="gdx.reflect.include"
+		value="com.badlogic.gdx.graphics.g3d.particles.renderers.BillboardControllerRenderData" />
+	<extend-configuration-property name="gdx.reflect.include"
+		value="com.badlogic.gdx.graphics.g3d.particle.renderers.ModelInstanceControllerRenderData" />
+	<extend-configuration-property name="gdx.reflect.include"
+		value="com.badlogic.gdx.graphics.g3d.particle.renderers.ParticleControllerRenderData" />
+	<extend-configuration-property name="gdx.reflect.include"
+		value="com.badlogic.gdx.graphics.g3d.particle.renderers.PointSpriteControllerRenderData" />
     <extend-configuration-property name="gdx.reflect.include"
         value="java.util.List" />
 	<extend-configuration-property name="gdx.reflect.include"
diff --git a/build.xml b/build.xml
index 793fd29..7153870 100644
--- a/build.xml
+++ b/build.xml
@@ -39,6 +39,8 @@
 			<pathelement location="${distDir}/extensions/gdx-jnigen/gdx-jnigen.jar"/>
 		</path>
 		<fileset id="resourcefiles" dir="gdx/src">
+			<include name="com/badlogic/gdx/graphics/g3d/particles/particles.fragment.glsl"/>
+			<include name="com/badlogic/gdx/graphics/g3d/particles/particles.vertex.glsl"/>
 			<include name="com/badlogic/gdx/graphics/g3d/shaders/default.fragment.glsl"/>
 			<include name="com/badlogic/gdx/graphics/g3d/shaders/default.vertex.glsl"/>
 			<include name="com/badlogic/gdx/graphics/g3d/shaders/depth.fragment.glsl"/>
diff --git a/extensions/gdx-ai/pom.xml b/extensions/gdx-ai/pom.xml
index c933018..0a68674 100644
--- a/extensions/gdx-ai/pom.xml
+++ b/extensions/gdx-ai/pom.xml
@@ -1,11 +1,10 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
 	<modelVersion>4.0.0</modelVersion>
 	<parent>
 		<groupId>com.badlogicgames.gdx</groupId>
 		<artifactId>gdx-parent</artifactId>
-		<version>1.1.1-SNAPSHOT</version>
+		<version>1.2.1-SNAPSHOT</version>
 		<relativePath>../../pom.xml</relativePath>
 	</parent>
 
diff --git a/extensions/gdx-ai/src/com/badlogic/gdx/ai/msg/PriorityQueue.java b/extensions/gdx-ai/src/com/badlogic/gdx/ai/msg/PriorityQueue.java
index f247038..994ec8b 100644
--- a/extensions/gdx-ai/src/com/badlogic/gdx/ai/msg/PriorityQueue.java
+++ b/extensions/gdx-ai/src/com/badlogic/gdx/ai/msg/PriorityQueue.java
@@ -16,8 +16,7 @@
 
 package com.badlogic.gdx.ai.msg;
 
-import java.util.Arrays;
-
+import com.badlogic.gdx.utils.GdxRuntimeException;
 import com.badlogic.gdx.utils.ObjectSet;
 
 /** An unbounded priority queue based on a priority heap. The elements of the priority queue are ordered according to their
@@ -204,14 +203,16 @@ public class PriorityQueue<E extends Comparable<E>> {
 	 * @param minCapacity the desired minimum capacity */
 	private void growToSize (int minCapacity) {
 		if (minCapacity < 0) // overflow
-			throw new OutOfMemoryError();
+			throw new GdxRuntimeException("Capacity upper limit exceeded.");
 		int oldCapacity = queue.length;
 		// Double size if small; else grow by 50%
 		int newCapacity = (int)((oldCapacity < 64) ? ((oldCapacity + 1) * CAPACITY_RATIO_HI) : (oldCapacity * CAPACITY_RATIO_LOW));
 		if (newCapacity < 0) // overflow
 			newCapacity = Integer.MAX_VALUE;
 		if (newCapacity < minCapacity) newCapacity = minCapacity;
-		queue = Arrays.copyOf(queue, newCapacity);
+		Object[] newQueue = new Object[newCapacity];
+		System.arraycopy(queue, 0, newQueue, 0, size);
+		queue = newQueue;
 	}
 
 }
diff --git a/extensions/gdx-box2d/gdx-box2d-gwt/pom.xml b/extensions/gdx-box2d/gdx-box2d-gwt/pom.xml
index 7c6fc8a..c82e274 100644
--- a/extensions/gdx-box2d/gdx-box2d-gwt/pom.xml
+++ b/extensions/gdx-box2d/gdx-box2d-gwt/pom.xml
@@ -4,7 +4,7 @@
 	<parent>
 		<groupId>com.badlogicgames.gdx</groupId>
 		<artifactId>gdx-box2d-parent</artifactId>
-		<version>1.1.1-SNAPSHOT</version>
+		<version>1.2.1-SNAPSHOT</version>
 		<relativePath>../pom.xml</relativePath>
 	</parent>
 
diff --git a/extensions/gdx-box2d/gdx-box2d/jni/maven/pom.xml b/extensions/gdx-box2d/gdx-box2d/jni/maven/pom.xml
index a231634..0175f77 100644
--- a/extensions/gdx-box2d/gdx-box2d/jni/maven/pom.xml
+++ b/extensions/gdx-box2d/gdx-box2d/jni/maven/pom.xml
@@ -4,7 +4,7 @@
     <parent>
         <groupId>com.badlogicgames.gdx</groupId>
         <artifactId>gdx-parent</artifactId>
-        <version>1.1.1-SNAPSHOT</version>
+        <version>1.2.1-SNAPSHOT</version>
         <relativePath>../../../../../</relativePath>
     </parent>
     
diff --git a/extensions/gdx-box2d/gdx-box2d/pom.xml b/extensions/gdx-box2d/gdx-box2d/pom.xml
index c527e9a..7a6e7c2 100644
--- a/extensions/gdx-box2d/gdx-box2d/pom.xml
+++ b/extensions/gdx-box2d/gdx-box2d/pom.xml
@@ -1,11 +1,10 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
 	<modelVersion>4.0.0</modelVersion>
 	<parent>
 		<groupId>com.badlogicgames.gdx</groupId>
 		<artifactId>gdx-box2d-parent</artifactId>
-		<version>1.1.1-SNAPSHOT</version>
+		<version>1.2.1-SNAPSHOT</version>
 		<relativePath>../pom.xml</relativePath>
 	</parent>
 
diff --git a/extensions/gdx-box2d/gdx-box2d/src/com/badlogic/gdx/physics/box2d/utils/Box2DBuild.java b/extensions/gdx-box2d/gdx-box2d/src/com/badlogic/gdx/physics/box2d/utils/Box2DBuild.java
index 9e95732..e061157 100644
--- a/extensions/gdx-box2d/gdx-box2d/src/com/badlogic/gdx/physics/box2d/utils/Box2DBuild.java
+++ b/extensions/gdx-box2d/gdx-box2d/src/com/badlogic/gdx/physics/box2d/utils/Box2DBuild.java
@@ -1,5 +1,7 @@
 package com.badlogic.gdx.physics.box2d.utils;
 
+import java.io.File;
+
 import com.badlogic.gdx.jnigen.AntScriptGenerator;
 import com.badlogic.gdx.jnigen.BuildConfig;
 import com.badlogic.gdx.jnigen.BuildTarget;
@@ -16,7 +18,7 @@ public class Box2DBuild {
 		BuildTarget mac32 = BuildTarget.newDefaultTarget(TargetOs.MacOsX, false);
 		BuildTarget mac64 = BuildTarget.newDefaultTarget(TargetOs.MacOsX, true);
 		BuildTarget ios = BuildTarget.newDefaultTarget(TargetOs.IOS, false);
-		new NativeCodeGenerator().generate();
+		new NativeCodeGenerator().generate("src", "bin" + File.pathSeparator + "../../../gdx/bin", "jni");
 		new AntScriptGenerator().generate(new BuildConfig("gdx-box2d"), win32, win64, lin32, lin64, mac32, mac64, android, ios);		
 	}
 }
\ No newline at end of file
diff --git a/extensions/gdx-box2d/pom.xml b/extensions/gdx-box2d/pom.xml
index 9c6270c..2e28e34 100644
--- a/extensions/gdx-box2d/pom.xml
+++ b/extensions/gdx-box2d/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.1-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/extensions/gdx-bullet/jni/maven/pom.xml b/extensions/gdx-bullet/jni/maven/pom.xml
index ff3f88a..9428ab2 100644
--- a/extensions/gdx-bullet/jni/maven/pom.xml
+++ b/extensions/gdx-bullet/jni/maven/pom.xml
@@ -4,7 +4,7 @@
     <parent>
         <groupId>com.badlogicgames.gdx</groupId>
         <artifactId>gdx-parent</artifactId>
-        <version>1.1.1-SNAPSHOT</version>
+        <version>1.2.1-SNAPSHOT</version>
         <relativePath>../../../../</relativePath>
     </parent>
     
diff --git a/extensions/gdx-bullet/pom.xml b/extensions/gdx-bullet/pom.xml
index 190c437..04b260c 100644
--- a/extensions/gdx-bullet/pom.xml
+++ b/extensions/gdx-bullet/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.1-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/extensions/gdx-controllers/gdx-controllers-android/pom.xml b/extensions/gdx-controllers/gdx-controllers-android/pom.xml
index be46a16..2dfef00 100644
--- a/extensions/gdx-controllers/gdx-controllers-android/pom.xml
+++ b/extensions/gdx-controllers/gdx-controllers-android/pom.xml
@@ -4,7 +4,7 @@
 	<parent>
 		<groupId>com.badlogicgames.gdx</groupId>
 		<artifactId>gdx-controllers-parent</artifactId>
-		<version>1.1.1-SNAPSHOT</version>
+		<version>1.2.1-SNAPSHOT</version>
 		<relativePath>../pom.xml</relativePath>
 	</parent>
 
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/maven/pom.xml b/extensions/gdx-controllers/gdx-controllers-desktop/jni/maven/pom.xml
index f569850..7c5b6ee 100644
--- a/extensions/gdx-controllers/gdx-controllers-desktop/jni/maven/pom.xml
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/maven/pom.xml
@@ -4,7 +4,7 @@
     <parent>
         <groupId>com.badlogicgames.gdx</groupId>
         <artifactId>gdx-controllers-parent</artifactId>
-        <version>1.1.1-SNAPSHOT</version>
+        <version>1.2.1-SNAPSHOT</version>
         <relativePath>../../../</relativePath>
     </parent>
     
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/pom.xml b/extensions/gdx-controllers/gdx-controllers-desktop/pom.xml
index d4cacac..4bb9647 100644
--- a/extensions/gdx-controllers/gdx-controllers-desktop/pom.xml
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-controllers-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/extensions/gdx-controllers/gdx-controllers-gwt/pom.xml b/extensions/gdx-controllers/gdx-controllers-gwt/pom.xml
index df56372..4dbc296 100644
--- a/extensions/gdx-controllers/gdx-controllers-gwt/pom.xml
+++ b/extensions/gdx-controllers/gdx-controllers-gwt/pom.xml
@@ -4,7 +4,7 @@
 	<parent>
 		<groupId>com.badlogicgames.gdx</groupId>
 		<artifactId>gdx-controllers-parent</artifactId>
-		<version>1.1.1-SNAPSHOT</version>
+		<version>1.2.1-SNAPSHOT</version>
 		<relativePath>../pom.xml</relativePath>
 	</parent>
 
diff --git a/extensions/gdx-controllers/gdx-controllers/pom.xml b/extensions/gdx-controllers/gdx-controllers/pom.xml
index 94b1043..2ac125e 100644
--- a/extensions/gdx-controllers/gdx-controllers/pom.xml
+++ b/extensions/gdx-controllers/gdx-controllers/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-controllers-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/extensions/gdx-controllers/gdx-controllers/src/com/badlogic/gdx/controllers/mappings/FireTV.java b/extensions/gdx-controllers/gdx-controllers/src/com/badlogic/gdx/controllers/mappings/FireTV.java
deleted file mode 100644
index 4e4fbb3..0000000
--- a/extensions/gdx-controllers/gdx-controllers/src/com/badlogic/gdx/controllers/mappings/FireTV.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.controllers.mappings;
-
-import java.lang.reflect.Field;
-
-/** Button and axis indices for the Amazon Kindle Fire TV {@link Controller}.
- * @author witnessmenow */
-public class FireTV 
-{
-	
-	/** whether the app is running on a real FireTV device **/
-	public static final boolean runningOnFireTV;
-	
-	/** To allow users to simulate running on FireTV **/
-	public static boolean simulateRunningOnFireTV = false;
-	
-	public static final String ID = "Amazon Fire Game Controller";
-	public static final int BUTTON_A;
-	public static final int BUTTON_X;
-	public static final int BUTTON_Y;
-	public static final int BUTTON_B;
-	public static final int BUTTON_MENU;
-	public static final int BUTTON_BACK;
-	
-	public static final int BUTTON_L1;
-	public static final int BUTTON_L3;
-	public static final int BUTTON_R1;
-	public static final int BUTTON_R3;
-	
-	public static final int BUTTON_REWIND;
-	public static final int BUTTON_PLAY_PAUSE;
-	public static final int BUTTON_FAST_FOREWARD;
-	
-	public static final int AXIS_LEFT_X;
-	public static final int AXIS_LEFT_Y;
-	public static final int AXIS_L2_TRIGGER;
-	public static final int AXIS_RIGHT_X;
-	public static final int AXIS_RIGHT_Y;
-	public static final int AXIS_R2_TRIGGER;
-	
-	public static final int AXIS_DPAD_X;
-	public static final int AXIS_DPAD_Y;
-	
-	public static final float STICK_DEADZONE = 0.25F;
-
-	static {
-		boolean isAFT= false;
-		try {
-			Class<?> buildClass = Class.forName("android.os.Build");
-			Field manufacturerField = buildClass.getDeclaredField("MANUFACTURER");
-			String manufacturer = manufacturerField.get(null).toString();
-			
-			Field modelField = buildClass.getDeclaredField("MODEL");
-			String model = modelField.get(null).toString();
-			
-			//Documentation says to only check first 3 letters for forward compatibility
-			model = model.substring(0, 3);
-			
-			isAFT = "Amazon".equals(manufacturer) && "AFT".equals(model);
-		} catch (Exception e) {
-		}
-		
-		runningOnFireTV = isAFT;
-		
-		
-		BUTTON_A = 96;
-		BUTTON_X = 99;
-		BUTTON_Y = 100;
-		BUTTON_B = 97;
-		BUTTON_MENU = 82;
-		BUTTON_L1 = 102;
-		BUTTON_R1 = 103;
-		BUTTON_R3 = 107;
-		BUTTON_L3 = 106;
-		BUTTON_BACK = 4;
-		BUTTON_REWIND = 89;
-		BUTTON_PLAY_PAUSE = 85;
-		BUTTON_FAST_FOREWARD = 90;
-		
-
-		AXIS_LEFT_X = 0;
-		AXIS_LEFT_Y = 1;
-		AXIS_L2_TRIGGER = 5;
-		AXIS_RIGHT_X = 2;
-		AXIS_RIGHT_Y = 3;
-		AXIS_R2_TRIGGER = 4;
-		
-		AXIS_DPAD_Y = 7;
-		AXIS_DPAD_X = 6;
-	}
-	
-	/** To allow users to have a single check to see if running on the FireTV 
-		that also consideres the simulation flag **/
-	public static boolean isRunningOnFireTV()
-	{
-		return runningOnFireTV || simulateRunningOnFireTV;
-	}
-}
diff --git a/extensions/gdx-controllers/pom.xml b/extensions/gdx-controllers/pom.xml
index 51484b8..c2cdc2b 100644
--- a/extensions/gdx-controllers/pom.xml
+++ b/extensions/gdx-controllers/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.1-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/extensions/gdx-freetype/jni/maven/pom.xml b/extensions/gdx-freetype/jni/maven/pom.xml
index 4aa3784..be978f8 100644
--- a/extensions/gdx-freetype/jni/maven/pom.xml
+++ b/extensions/gdx-freetype/jni/maven/pom.xml
@@ -4,7 +4,7 @@
     <parent>
         <groupId>com.badlogicgames.gdx</groupId>
         <artifactId>gdx-parent</artifactId>
-        <version>1.1.1-SNAPSHOT</version>
+        <version>1.2.1-SNAPSHOT</version>
         <relativePath>../../../../</relativePath>
     </parent>
     
diff --git a/extensions/gdx-freetype/pom.xml b/extensions/gdx-freetype/pom.xml
index 5e831b5..5a775f0 100644
--- a/extensions/gdx-freetype/pom.xml
+++ b/extensions/gdx-freetype/pom.xml
@@ -1,11 +1,10 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
 	<modelVersion>4.0.0</modelVersion>
 	<parent>
 		<groupId>com.badlogicgames.gdx</groupId>
 		<artifactId>gdx-parent</artifactId>
-		<version>1.1.1-SNAPSHOT</version>
+		<version>1.2.1-SNAPSHOT</version>
 		<relativePath>../../pom.xml</relativePath>
 	</parent>
 
diff --git a/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGenerator.java b/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGenerator.java
index 3cd4192..fd39212 100644
--- a/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGenerator.java
+++ b/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGenerator.java
@@ -417,21 +417,22 @@ public class FreeTypeFontGenerator implements Disposable {
 		}
 
 		// generate kerning
-		for (int i = 0; i < parameter.characters.length(); i++) {
-			for (int j = 0; j < parameter.characters.length(); j++) {
-				char firstChar = parameter.characters.charAt(i);
-				Glyph first = data.getGlyph(firstChar);
-				if (first == null) continue;
-				char secondChar = parameter.characters.charAt(j);
-				Glyph second = data.getGlyph(secondChar);
-				if (second == null) continue;
-				int kerning = FreeType.getKerning(face, FreeType.getCharIndex(face, firstChar),
-					FreeType.getCharIndex(face, secondChar), 0);
-				if (kerning == 0) continue;
-				first.setKerning(secondChar, FreeType.toInt(kerning));
+		if (parameter.kerning) {
+			for (int i = 0; i < parameter.characters.length(); i++) {
+				for (int j = 0; j < parameter.characters.length(); j++) {
+					char firstChar = parameter.characters.charAt(i);
+					Glyph first = data.getGlyph(firstChar);
+					if (first == null) continue;
+					char secondChar = parameter.characters.charAt(j);
+					Glyph second = data.getGlyph(secondChar);
+					if (second == null) continue;
+					int kerning = FreeType.getKerning(face, FreeType.getCharIndex(face, firstChar),
+						FreeType.getCharIndex(face, secondChar), 0);
+					if (kerning == 0) continue;
+					first.setKerning(secondChar, FreeType.toInt(kerning));
+				}
 			}
 		}
-
 		if (ownsAtlas) {
 			Array<Page> pages = packer.getPages();
 			data.regions = new TextureRegion[pages.size];
@@ -495,6 +496,8 @@ public class FreeTypeFontGenerator implements Disposable {
 		public int size = 16;
 		/** The characters the font should contain */
 		public String characters = DEFAULT_CHARS;
+		/** Whether the font should include kerning */
+		public boolean kerning = true;
 		/** The optional PixmapPacker to use */
 		public PixmapPacker packer = null;
 		/** Whether to flip the font horizontally */
diff --git a/extensions/gdx-jnigen/pom.xml b/extensions/gdx-jnigen/pom.xml
index eff4fcb..d4c3350 100644
--- a/extensions/gdx-jnigen/pom.xml
+++ b/extensions/gdx-jnigen/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.1-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/BuildExecutor.java b/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/BuildExecutor.java
index 4a5e94c..5620557 100644
--- a/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/BuildExecutor.java
+++ b/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/BuildExecutor.java
@@ -33,7 +33,7 @@ public class BuildExecutor {
 	public static boolean executeAnt (String buildFile, String params) {
 		FileDescriptor build = new FileDescriptor(buildFile);
 		String ant = System.getProperty("os.name").contains("Windows") ? "ant.bat" : "ant";
-		String command = ant + " -f " + build.file().getAbsolutePath() + " " + params;
+		String command = ant + " -f \"" + build.file().getAbsolutePath() + "\" " + params;
 		System.out.println("Executing '" + command + "'");
 		return startProcess(command, build.parent().file());
 	}
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/DependencyBank.java b/extensions/gdx-setup/src/com/badlogic/gdx/setup/DependencyBank.java
index 95bb7dc..96bb4bd 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/DependencyBank.java
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/DependencyBank.java
@@ -7,9 +7,9 @@ import java.util.LinkedHashMap;
 public class DependencyBank {
 
 	//Versions
-	static String libgdxVersion = "1.1.0";
+	static String libgdxVersion = "1.2.0";
 	//Temporary snapshot version, we need a more dynamic solution for pointing to the latest nightly
-	static String libgdxNightlyVersion = "1.1.1-SNAPSHOT";
+	static String libgdxNightlyVersion = "1.2.1-SNAPSHOT";
 	static String roboVMVersion = "0.0.13";
 	static String buildToolsVersion = "19.1.0";
 	static String androidAPILevel = "19";
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/android/build.gradle b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/android/build.gradle
index c209264..937b49f 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/android/build.gradle
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/android/build.gradle
@@ -45,7 +45,24 @@ task copyAndroidNatives() {
 }
 
 task run(type: Exec) {
-    def adb = "$System.env.ANDROID_HOME/platform-tools/adb"
+    def path
+    def localProperties = project.file("../local.properties")
+    if (localProperties.exists()) {
+        Properties properties = new Properties()
+        localProperties.withInputStream { instr ->
+            properties.load(instr)
+        }
+        def sdkDir = properties.getProperty('sdk.dir')
+        if (sdkDir) {
+            path = sdkDir
+        } else {
+            path = "$System.env.ANDROID_HOME"
+        }
+    } else {
+        path = "$System.env.ANDROID_HOME"
+    }
+
+    def adb = path + "/platform-tools/adb"
     commandLine "$adb", 'shell', 'am', 'start', '-n', '%PACKAGE%.android/%PACKAGE%.android.AndroidLauncher'
 }
 
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/android/proguard-project.txt b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/android/proguard-project.txt
index f2fe155..88c3958 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/android/proguard-project.txt
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/android/proguard-project.txt
@@ -18,3 +18,25 @@
 #-keepclassmembers class fqcn.of.javascript.interface.for.webview {
 #   public *;
 #}
+
+-verbose
+
+-dontwarn android.support.**
+-dontwarn com.badlogic.gdx.backends.android.AndroidFragmentApplication
+-dontwarn com.badlogic.gdx.utils.GdxBuild
+-dontwarn com.badlogic.gdx.physics.box2d.utils.Box2DBuild
+-dontwarn com.badlogic.gdx.jnigen.BuildTarget*
+
+-keepclassmembers class com.badlogic.gdx.backends.android.AndroidInput* {
+   <init>(com.badlogic.gdx.Application, android.content.Context, java.lang.Object, com.badlogic.gdx.backends.android.AndroidApplicationConfiguration);
+}
+
+-keepclassmembers class com.badlogic.gdx.physics.box2d.World {
+   boolean contactFilter(long, long);
+   void    beginContact(long);
+   void    endContact(long);
+   void    preSolve(long, long);
+   void    postSolve(long, long);
+   boolean reportFixture(long);
+   float   reportRayFixture(long, float, float, float, float, float);
+}
diff --git a/extensions/gdx-tools/assets/defaultTemplate.pfx b/extensions/gdx-tools/assets/defaultTemplate.pfx
new file mode 100644
index 0000000..a7cb7bf
--- /dev/null
+++ b/extensions/gdx-tools/assets/defaultTemplate.pfx
@@ -0,0 +1 @@
+{unique:{pointSpriteBatch:{class:com.badlogic.gdx.graphics.g3d.particles.ResourceData$SaveData,data:{},indices:[0]},billboardBatch:{class:com.badlogic.gdx.graphics.g3d.particles.ResourceData$SaveData,data:{cfg:{class:com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch$Config,mode:Screen}},indices:[0]}},data:[],assets:[{filename:pre_particle.png,type:com.badlogic.gdx.graphics.Texture}],resource:{class:com.badlogic.gdx.graphics.g3d.particles.ParticleEffect,controllers:[{name:"Billboard Controller",emitter:{class:com.badlogic.gdx.graphics.g3d.particles.emitters.RegularEmitter,minParticleCount:0,maxParticleCount:200,continous:true,emission:{active:true,lowMin:0,lowMax:0,highMin:250,highMax:250,relative:false,scaling:[1],timeline:[0]},delay:{active:false,lowMin:0,lowMax:0},duration:{active:true,lowMin:3000,lowMax:3000},life:{active:true,lowMin:0,lowMax:0,highMin:500,highMax:1000,relative:false,scaling:[1],timeline:[0]},lifeOffset:{active:false,lowMin:0,lowMax:0,highMin:0,highMax:0,relative:false,scaling:[1],timeline:[0]}},influencers:[{class:com.badlogic.gdx.graphics.g3d.particles.influencers.RegionInfluencer$Single,regions:[{halfInvAspectRatio:0.5,v2:1,u2:1}]},{class:com.badlogic.gdx.graphics.g3d.particles.influencers.SpawnInfluencer,spawnShape:{class:com.badlogic.gdx.graphics.g3d.particles.values.PointSpawnShapeValue,active:false,xOffsetValue:{active:true,lowMin:-0.15,lowMax:0.15},yOffsetValue:{active:true,lowMin:-0.15,lowMax:0.15},zOffsetValue:{active:true,lowMin:-0.15,lowMax:0.15},spawnWidthValue:{active:false,lowMin:0,lowMax:0,highMin:0,highMax:0,relative:false,scaling:[1],timeline:[0]},spawnHeightValue:{active:false,lowMin:0,lowMax:0,highMin:0,highMax:0,relative:false,scaling:[1],timeline:[0]},spawnDepthValue:{active:false,lowMin:0,lowMax:0,highMin:0,highMax:0,relative:false,scaling:[1],timeline:[0]},edges:false}},{class:com.badlogic.gdx.graphics.g3d.particles.influencers.ColorInfluencer$Single,alpha:{active:false,lowMin:0,lowMax:0,highMin:1,highMax:1,relative:false,scaling:[0,0.15,0.5,0],timeline:[0,0.5,0.8,1]},color:{active:false,colors:[1,0.12156863,0.047058824,0,0,0],timeline:[0,1]}},{class:com.badlogic.gdx.graphics.g3d.particles.influencers.ScaleInfluencer,value:{active:false,lowMin:0,lowMax:0,highMin:1,highMax:1,relative:false,scaling:[1],timeline:[0]}}],renderer:{class:com.badlogic.gdx.graphics.g3d.particles.renderers.BillboardRenderer}}]}}
\ No newline at end of file
diff --git a/extensions/gdx-tools/assets/monkey.g3db b/extensions/gdx-tools/assets/monkey.g3db
new file mode 100644
index 0000000..ff7b52f
Binary files /dev/null and b/extensions/gdx-tools/assets/monkey.g3db differ
diff --git a/extensions/gdx-tools/assets/pre_particle.png b/extensions/gdx-tools/assets/pre_particle.png
new file mode 100644
index 0000000..3ce4d1a
Binary files /dev/null and b/extensions/gdx-tools/assets/pre_particle.png differ
diff --git a/extensions/gdx-tools/assets/uiskin.json b/extensions/gdx-tools/assets/uiskin.json
index 176c810..7764030 100644
--- a/extensions/gdx-tools/assets/uiskin.json
+++ b/extensions/gdx-tools/assets/uiskin.json
@@ -17,16 +17,20 @@ com.badlogic.gdx.scenes.scene2d.ui.TextButton$TextButtonStyle: {
 	default: { down: default-round-down, up: default-round, font: default-font, fontColor: white },
 	toggle: { down: default-round-down, up: default-round, checked: default-round-down, font: default-font, fontColor: white, downFontColor: red }
 },
+com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$ScrollPaneStyle: {
+	default: { vScroll: default-scroll, hScrollKnob: default-round-large, background: default-rect, hScroll: default-scroll, vScrollKnob: default-round-large }
+},
 com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxStyle: {
-	default: { listBackground: default-rect, listSelection: default-select-selection, font: default-font, fontColor: white, background: default-select }
+	default: {
+		font: default-font, fontColor: white, background: default-select,
+		scrollStyle: default,
+		listStyle: { font: default-font, selection: default-select-selection }
+	}
 },
 com.badlogic.gdx.scenes.scene2d.ui.SplitPane$SplitPaneStyle: {
 	default-vertical: { handle: default-splitpane-vertical },
 	default-horizontal: { handle: default-splitpane }
 },
-com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$ScrollPaneStyle: {
-	default: { vScroll: default-scroll, hScrollKnob: default-round-large, background: default-rect, hScroll: default-scroll, vScrollKnob: default-round-large }
-},
 com.badlogic.gdx.scenes.scene2d.ui.Window$WindowStyle: {
 	default: { titleFont: default-font, background: default-window, titleFontColor: white },
 	dialog: { titleFont: default-font, background: default-window, titleFontColor: white, stageBackground: dialogDim }
@@ -44,7 +48,7 @@ com.badlogic.gdx.scenes.scene2d.ui.CheckBox$CheckBoxStyle: {
 	default: { checkboxOn: check-on, checkboxOff: check-off, font: default-font, fontColor: white }
 },
 com.badlogic.gdx.scenes.scene2d.ui.List$ListStyle: {
-	default: { fontColorUnselected: white, selection: default-rect-pad, fontColorSelected: white, font: default-font }
+	default: { fontColorUnselected: white, selection: selection, fontColorSelected: white, font: default-font }
 },
 com.badlogic.gdx.scenes.scene2d.ui.Touchpad$TouchpadStyle: {
 	default: { background: default-pane, knob: default-round-large }
diff --git a/extensions/gdx-tools/pom.xml b/extensions/gdx-tools/pom.xml
index 3565115..346f4f1 100644
--- a/extensions/gdx-tools/pom.xml
+++ b/extensions/gdx-tools/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.1-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/AngularVelocityPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/AngularVelocityPanel.java
new file mode 100644
index 0000000..f7d1313
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/AngularVelocityPanel.java
@@ -0,0 +1,97 @@
+package com.badlogic.gdx.tools.flame;
+
+import java.awt.Dimension;
+import java.awt.GridBagConstraints;
+import java.awt.Insets;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+
+import javax.swing.JCheckBox;
+import javax.swing.JLabel;
+import javax.swing.JPanel;
+
+import com.badlogic.gdx.graphics.g3d.particles.influencers.DynamicsModifier;
+
+/** @author Inferno */
+public class AngularVelocityPanel extends EditorPanel<DynamicsModifier.Angular> {
+	JCheckBox isGlobalCheckBox;
+	ScaledNumericPanel thetaPanel;
+	ScaledNumericPanel phiPanel;
+	ScaledNumericPanel magnitudePanel;
+
+	public AngularVelocityPanel(FlameMain editor, DynamicsModifier.Angular aValue, String charTitle, String name, String description) {
+		super(editor, name, description);
+		initializeComponents(aValue, charTitle);
+		setValue(value);
+	}
+	
+	@Override
+	public void setValue (DynamicsModifier.Angular value) {
+		super.setValue(value);
+		if(value == null) return;
+		setValue(isGlobalCheckBox, this.value.isGlobal);
+		magnitudePanel.setValue(this.value.strengthValue);
+		thetaPanel.setValue(this.value.thetaValue);
+		phiPanel.setValue(this.value.phiValue);
+	}
+
+	private void initializeComponents(DynamicsModifier.Angular aValue, String charTitle) {
+		JPanel contentPanel = getContentPanel();
+		{
+			JPanel panel = new JPanel();
+			panel.add(new JLabel("Global"), new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+				new Insets(0, 0, 0, 0), 0, 0));
+			panel.add(isGlobalCheckBox = new JCheckBox(), new GridBagConstraints(1, 0, 1, 1, 0, 0, 
+				GridBagConstraints.WEST, GridBagConstraints.NONE,
+				new Insets(0, 0, 0, 0), 0, 0));
+			contentPanel.add(panel,new GridBagConstraints(0, 1, 1, 1, 0, 0, 
+				GridBagConstraints.WEST, GridBagConstraints.NONE,
+				new Insets(0, 0, 0, 0), 0, 0));
+		}
+		{
+			contentPanel.add( magnitudePanel = new ScaledNumericPanel(editor, aValue == null ? null: aValue.strengthValue, charTitle, "Strength", "In world units per second.", true), 
+					new GridBagConstraints(0, 2, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+							new Insets(0, 0, 0, 6), 0, 0));
+		}
+		{
+			contentPanel.add(phiPanel = new ScaledNumericPanel(editor, aValue == null ? null: aValue.phiValue, charTitle, "Azimuth", "Rotation starting on Y", true), 
+					new GridBagConstraints(0, 4, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+							new Insets(0, 0, 0, 6), 0, 0));
+		}
+		{
+			contentPanel.add(thetaPanel = new ScaledNumericPanel(editor, aValue == null ? null: aValue.thetaValue, charTitle, "Polar angle", "around Y axis on XZ plane", true), 
+					new GridBagConstraints(0, 3, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+							new Insets(0, 0, 0, 6), 0, 0));
+		}
+		{
+			JPanel spacer = new JPanel();
+			spacer.setPreferredSize(new Dimension());
+			contentPanel.add(spacer, new GridBagConstraints(6, 0, 1, 1, 1, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+				new Insets(0, 0, 0, 0), 0, 0));
+		}
+		
+		magnitudePanel.setIsAlwayShown(true);
+		phiPanel.setIsAlwayShown(true);
+		thetaPanel.setIsAlwayShown(true);
+		
+		isGlobalCheckBox.addActionListener(new ActionListener() {
+			@Override
+			public void actionPerformed (ActionEvent e) {
+				AngularVelocityPanel.this.value.isGlobal = isGlobalCheckBox.isSelected();
+			}
+		});
+	}
+	
+	public ScaledNumericPanel getThetaPanel(){
+		return thetaPanel;
+	}
+	
+	public ScaledNumericPanel getPhiPanel(){
+		return phiPanel;
+	}
+	
+	public ScaledNumericPanel getMagnitudePanel(){
+		return magnitudePanel;
+	}
+	
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/BillboardBatchPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/BillboardBatchPanel.java
new file mode 100644
index 0000000..8884f9d
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/BillboardBatchPanel.java
@@ -0,0 +1,131 @@
+package com.badlogic.gdx.tools.flame;
+
+import java.awt.GridBagConstraints;
+import java.awt.Insets;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+
+import javax.swing.DefaultComboBoxModel;
+import javax.swing.JCheckBox;
+import javax.swing.JComboBox;
+import javax.swing.JLabel;
+import javax.swing.event.ChangeEvent;
+import javax.swing.event.ChangeListener;
+
+import com.badlogic.gdx.graphics.g3d.particles.ParticleShader.AlignMode;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleSorter;
+import com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch;
+
+/** @author Inferno */
+public class BillboardBatchPanel extends EditorPanel<BillboardParticleBatch> {
+	private enum AlignModeWrapper{
+		Screen( AlignMode.Screen, "Screen"),
+		ViewPoint(AlignMode.ViewPoint, "View Point");
+		//ParticleDirection( AlignMode.ParticleDirection, "Particle Direction");
+		
+		public String desc;
+		public AlignMode mode;
+		AlignModeWrapper(AlignMode mode, String desc){
+			this.mode = mode;
+			this.desc = desc;
+		}
+		
+		@Override
+		public String toString () {
+			return desc;
+		}
+	}
+	
+	private enum SortMode{
+		None( "None", new ParticleSorter.None()),
+		Distance("Distance", new ParticleSorter.Distance());
+		
+		public String desc;
+		public ParticleSorter sorter;
+		SortMode(String desc, ParticleSorter sorter){
+			this.sorter = sorter;
+			this.desc = desc;
+		}
+		
+		@Override
+		public String toString () {
+			return desc;
+		}
+	}
+	
+
+	JComboBox alignCombo;
+	JCheckBox useGPUBox;
+	JComboBox sortCombo;
+
+	public BillboardBatchPanel (FlameMain particleEditor3D, BillboardParticleBatch renderer) {
+		super(particleEditor3D, "Billboard Batch", "Renderer used to draw billboards particles.");
+		initializeComponents(renderer);
+		setValue(renderer);
+	}
+
+	private void initializeComponents (BillboardParticleBatch renderer) {
+		//Align
+		alignCombo = new JComboBox();
+		alignCombo.setModel(new DefaultComboBoxModel(AlignModeWrapper.values()));
+		alignCombo.setSelectedItem(getAlignModeWrapper(renderer.getAlignMode()));
+		alignCombo.addActionListener(new ActionListener() {
+			public void actionPerformed (ActionEvent event) {
+				AlignModeWrapper align = (AlignModeWrapper)alignCombo.getSelectedItem();
+				editor.getBillboardBatch().setAlignMode(align.mode);
+			}
+		});
+		
+		//Cpu/Gpu
+		useGPUBox = new JCheckBox();
+		useGPUBox.setSelected(renderer.isUseGPU());
+		useGPUBox.addChangeListener(new ChangeListener() {
+			public void stateChanged (ChangeEvent event) {
+				editor.getBillboardBatch().setUseGpu(useGPUBox.isSelected());
+			}
+		}); 
+		
+		//Sort
+		sortCombo = new JComboBox();
+		sortCombo.setModel(new DefaultComboBoxModel(SortMode.values()));
+		sortCombo.setSelectedItem(getSortMode(renderer.getSorter()));
+		sortCombo.addActionListener(new ActionListener() {
+			public void actionPerformed (ActionEvent event) {
+				SortMode mode = (SortMode)sortCombo.getSelectedItem();
+				editor.getBillboardBatch().setSorter(mode.sorter);
+			}
+		});
+		
+		int i =0;
+		contentPanel.add(new JLabel("Align"), new GridBagConstraints(0, i, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+			new Insets(6, 0, 0, 0), 0, 0));
+		contentPanel.add(alignCombo, new GridBagConstraints(1, i++, 1, 1, 1, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+			new Insets(6, 0, 0, 0), 0, 0));
+		contentPanel.add(new JLabel("Use GPU"), new GridBagConstraints(0, i, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+			new Insets(6, 0, 0, 0), 0, 0));
+		contentPanel.add(useGPUBox, new GridBagConstraints(1, i++, 1, 1, 1, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+			new Insets(6, 0, 0, 0), 0, 0));
+		contentPanel.add(new JLabel("Sort"), new GridBagConstraints(0, i, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+			new Insets(6, 0, 0, 0), 0, 0));
+		contentPanel.add(sortCombo, new GridBagConstraints(1, i, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+			new Insets(6, 0, 0, 0), 0, 0));
+	}
+
+	private Object getSortMode (ParticleSorter sorter) {
+		Class type = sorter.getClass();
+		for(SortMode wrapper : SortMode.values()){
+			if(wrapper.sorter.getClass() == type)
+				return wrapper;
+		}
+		return null;
+	}
+
+	private Object getAlignModeWrapper (AlignMode alignMode) {
+		for(AlignModeWrapper wrapper : AlignModeWrapper.values()){
+			if(wrapper.mode == alignMode)
+				return wrapper;
+		}
+		return null;
+	}
+
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/ColorInfluencerPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/ColorInfluencerPanel.java
new file mode 100644
index 0000000..5ab8067
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/ColorInfluencerPanel.java
@@ -0,0 +1,25 @@
+package com.badlogic.gdx.tools.flame;
+
+import com.badlogic.gdx.graphics.g3d.particles.influencers.ColorInfluencer;
+
+
+/** @author Inferno */
+public class ColorInfluencerPanel extends InfluencerPanel<ColorInfluencer.Single> {
+	
+	GradientPanel tintPanel;
+	PercentagePanel alphaPanel;
+	
+	public ColorInfluencerPanel (FlameMain particleEditor3D, ColorInfluencer.Single influencer) {
+		super(particleEditor3D, influencer, "Color Influencer", "Sets the particle color.");
+		initializeComponents(influencer);
+		setValue(influencer);
+	}
+
+	private void initializeComponents(ColorInfluencer.Single emitter){
+		int i=0;
+		addContent(i++, 0, tintPanel = new GradientPanel(editor, emitter.colorValue, "Tint", "", false));
+		addContent(i++, 0, alphaPanel = new PercentagePanel(editor, emitter.alphaValue, "Life", "Transparency", ""));
+		tintPanel.showContent(true);
+		alphaPanel.showContent(true);
+	}
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/CountPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/CountPanel.java
new file mode 100644
index 0000000..55e286e
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/CountPanel.java
@@ -0,0 +1,71 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.tools.flame;
+import java.awt.GridBagConstraints;
+import java.awt.Insets;
+
+import javax.swing.JLabel;
+import javax.swing.event.ChangeEvent;
+import javax.swing.event.ChangeListener;
+
+import com.badlogic.gdx.graphics.g3d.particles.ParticleController;
+
+/** @author Inferno */
+class CountPanel extends EditorPanel {
+	Slider maxSlider, minSlider;
+
+	public CountPanel (final FlameMain editor, String name, String description, int min, int max) {
+		super(editor, name, description);
+
+		initializeComponents(min, max);
+		setValue(null);
+	}
+	
+	private void initializeComponents (int min, int max) {
+		//Min
+		minSlider = new Slider(0, 0, 999999, 1);
+		minSlider.setValue(min);
+		minSlider.addChangeListener(new ChangeListener() {
+			public void stateChanged (ChangeEvent event) {
+				ParticleController controller = editor.getEmitter();
+				controller.emitter.minParticleCount = (int)minSlider.getValue();
+				editor.restart();
+			}
+		});
+
+		//Max
+		maxSlider = new Slider(0, 0, 999999, 1);
+		maxSlider.setValue(max);
+		maxSlider.addChangeListener(new ChangeListener() {
+			public void stateChanged (ChangeEvent event) {
+				ParticleController controller = editor.getEmitter();
+				controller.emitter.maxParticleCount = (int)maxSlider.getValue();
+				editor.restart();
+			}
+		});
+		
+		int i =0;
+		contentPanel.add(new JLabel("Min"), new GridBagConstraints(0, i, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+			new Insets(6, 0, 0, 0), 0, 0));
+		contentPanel.add(minSlider, new GridBagConstraints(1, i++, 1, 1, 1, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+			new Insets(6, 0, 0, 0), 0, 0));
+		contentPanel.add(new JLabel("Max"), new GridBagConstraints(0, i, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+			new Insets(6, 0, 0, 0), 0, 0));
+		contentPanel.add(maxSlider, new GridBagConstraints(1, i++, 1, 1, 1, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+			new Insets(6, 0, 0, 0), 0, 0));
+	}
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/CustomCardLayout.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/CustomCardLayout.java
new file mode 100644
index 0000000..1581121
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/CustomCardLayout.java
@@ -0,0 +1,31 @@
+package com.badlogic.gdx.tools.flame;
+
+import java.awt.CardLayout;
+import java.awt.Component;
+import java.awt.Container;
+import java.awt.Dimension;
+
+/** @author Inferno */
+public class CustomCardLayout extends CardLayout {
+
+	@Override
+	public Dimension preferredLayoutSize (Container parent) {
+		Component component = getCurrentCard(parent);
+		return component != null ? component.getPreferredSize() : super.preferredLayoutSize(parent);
+	}
+	
+	public <K> K getCurrentCard(Container container){
+		Component c[] = container.getComponents();
+		int i = 0;
+		int j = c.length;
+		while (i < j) {
+			if (c[i].isVisible()) {
+				return (K)c[i];
+			}
+			else
+				i ++;
+		}
+		return null;
+	}
+
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/DrawPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/DrawPanel.java
new file mode 100644
index 0000000..83bb050
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/DrawPanel.java
@@ -0,0 +1,70 @@
+package com.badlogic.gdx.tools.flame;
+
+import java.awt.GridBagConstraints;
+import java.awt.Insets;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+
+import javax.swing.JCheckBox;
+import javax.swing.JLabel;
+import javax.swing.JPanel;
+
+/** @author Inferno */
+public class DrawPanel extends EditorPanel 
+{
+	JCheckBox 	drawXYZCheckBox,
+				drawXZPlaneBox, drawXYPlaneBox;
+
+	public DrawPanel (FlameMain editor, String name, String description) {
+		super(editor, name, description);
+		setValue(null);
+	}
+
+	@Override
+	protected void initializeComponents () {
+		super.initializeComponents();
+		JPanel contentPanel = getContentPanel();
+		
+		//XYZ
+		contentPanel.add(new JLabel("XYZ:"), new GridBagConstraints(0, 1, 1, 1, 0, 0, GridBagConstraints.EAST, GridBagConstraints.NONE,
+				new Insets(6, 0, 0, 0), 0, 0));
+		drawXYZCheckBox = new JCheckBox();
+		contentPanel.add(drawXYZCheckBox, new GridBagConstraints(1, 1, 1, 1, 0, 0, GridBagConstraints.WEST,
+				GridBagConstraints.NONE, new Insets(6, 6, 0, 0), 0, 0));
+		
+		//XZ Plane
+		contentPanel.add(new JLabel("XZ Plane:"), new GridBagConstraints(0, 2, 1, 1, 0, 0, GridBagConstraints.EAST, GridBagConstraints.NONE,
+				new Insets(6, 0, 0, 0), 0, 0));
+		drawXZPlaneBox = new JCheckBox();
+		contentPanel.add(drawXZPlaneBox, new GridBagConstraints(1, 2, 1, 1, 1, 0, GridBagConstraints.WEST,
+				GridBagConstraints.NONE, new Insets(6, 6, 0, 0), 0, 0));
+		
+		//XY Plane
+		contentPanel.add(new JLabel("XY Plane:"), new GridBagConstraints(0, 3, 1, 1, 0, 0, GridBagConstraints.EAST, GridBagConstraints.NONE,
+				new Insets(6, 0, 0, 0), 0, 0));
+		drawXYPlaneBox = new JCheckBox();
+		contentPanel.add(drawXYPlaneBox, new GridBagConstraints(1, 3, 1, 1, 1, 0, GridBagConstraints.WEST,
+				GridBagConstraints.NONE, new Insets(6, 6, 0, 0), 0, 0));
+		
+		//Listeners
+		drawXYZCheckBox.addActionListener(new ActionListener() {
+			public void actionPerformed (ActionEvent event) {
+				DrawPanel.this.editor.getRenderer().setDrawXYZ(drawXYZCheckBox.isSelected());
+			}
+		});
+		drawXYZCheckBox.setSelected(editor.getRenderer().IsDrawXYZ());
+		
+		drawXZPlaneBox.addActionListener(new ActionListener() {
+			public void actionPerformed (ActionEvent event) {
+				DrawPanel.this.editor.getRenderer().setDrawXZPlane(drawXZPlaneBox.isSelected());
+			}
+		});
+		drawXZPlaneBox.setSelected(editor.getRenderer().IsDrawXZPlane());
+		
+		drawXYPlaneBox.addActionListener(new ActionListener() {
+			public void actionPerformed (ActionEvent event) {
+				DrawPanel.this.editor.getRenderer().setDrawXYPlane(drawXYPlaneBox.isSelected());
+			}
+		});
+	}
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/DynamicsInfluencerPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/DynamicsInfluencerPanel.java
new file mode 100644
index 0000000..dbcc0c9
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/DynamicsInfluencerPanel.java
@@ -0,0 +1,318 @@
+package com.badlogic.gdx.tools.flame;
+
+import java.awt.Dimension;
+import java.awt.GridBagConstraints;
+import java.awt.GridBagLayout;
+import java.awt.Insets;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+
+import javax.swing.DefaultComboBoxModel;
+import javax.swing.JButton;
+import javax.swing.JComboBox;
+import javax.swing.JPanel;
+import javax.swing.JScrollPane;
+import javax.swing.JTable;
+import javax.swing.ListSelectionModel;
+import javax.swing.event.ListSelectionEvent;
+import javax.swing.event.ListSelectionListener;
+import javax.swing.event.TableModelEvent;
+import javax.swing.event.TableModelListener;
+import javax.swing.table.DefaultTableModel;
+
+import com.badlogic.gdx.graphics.g3d.particles.ParticleController;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.DynamicsInfluencer;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.DynamicsModifier;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.DynamicsModifier.BrownianAcceleration;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.DynamicsModifier.CentripetalAcceleration;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.DynamicsModifier.FaceDirection;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.DynamicsModifier.PolarAcceleration;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.DynamicsModifier.Rotational3D;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.DynamicsModifier.TangentialAcceleration;
+import com.badlogic.gdx.tools.flame.FlameMain.ControllerType;
+import com.badlogic.gdx.utils.Array;
+
+/** @author Inferno */
+public class DynamicsInfluencerPanel extends InfluencerPanel<DynamicsInfluencer> {
+	
+	private static final String 	VEL_TYPE_ROTATIONAL_2D = "Angular Velocity 2D",
+															VEL_TYPE_ROTATIONAL_3D = "Angular Velocity 3D",
+											VEL_TYPE_CENTRIPETAL = "Centripetal",
+											VEL_TYPE_TANGENTIAL = "Tangential",
+											VEL_TYPE_POLAR = "Polar",
+											VEL_TYPE_BROWNIAN = "Brownian", 
+											VEL_TYPE_FACE = "Face";
+	
+	protected class VelocityWrapper{
+		public DynamicsModifier velocityValue;
+		public boolean isActive;
+		
+		public VelocityWrapper(DynamicsModifier value, boolean isActive){
+			this.velocityValue =  value;
+			this.isActive = isActive;
+		}
+	}
+	
+	JComboBox velocityBox;
+	JTable velocityTable;
+	DefaultTableModel velocityTableModel;
+	JPanel selectedVelocityPanel;
+	AngularVelocityPanel angularVelocityPanel;
+	StrengthVelocityPanel strengthVelocityPanel;
+	ParticleValuePanel emptyPanel;
+	Array<VelocityWrapper> velocities;
+	
+	public DynamicsInfluencerPanel (FlameMain editor, DynamicsInfluencer influencer) {
+		super(editor, influencer, "Dynamics Influencer", 
+							"Defines how the particles dynamics (acceleration, angular velocity).");
+		velocities = new Array<VelocityWrapper>();
+		setValue(value);
+		set(influencer);
+	}
+
+	private void set (DynamicsInfluencer influencer) {
+		//Clear
+		for (int i = velocityTableModel.getRowCount() - 1; i >= 0; i--) {
+			velocityTableModel.removeRow(i);
+		}
+		velocities.clear();
+		
+		//Add
+		for(int i=0, c = influencer.velocities.size; i < c; ++i){
+			velocities.add(new VelocityWrapper((DynamicsModifier)influencer.velocities.items[i], true));
+			velocityTableModel.addRow(new Object[] {"Velocity "+i, true});
+		}
+		
+		DefaultComboBoxModel model = (DefaultComboBoxModel) velocityBox.getModel();
+		model.removeAllElements();
+		for(Object velocityObject : getAvailableVelocities(editor.getControllerType())){
+			model.addElement(velocityObject);
+		}
+	}
+
+	private Object[] getAvailableVelocities (ControllerType type) {
+		if(type == ControllerType.Billboard || type == ControllerType.PointSprite) {
+			return new String[]{	VEL_TYPE_ROTATIONAL_2D, VEL_TYPE_CENTRIPETAL, VEL_TYPE_TANGENTIAL,
+				VEL_TYPE_POLAR, VEL_TYPE_BROWNIAN};
+		}
+		else if(type == ControllerType.ModelInstance|| type == ControllerType.ParticleController) {
+			return new String[]{	VEL_TYPE_ROTATIONAL_3D, VEL_TYPE_CENTRIPETAL, VEL_TYPE_TANGENTIAL,
+				VEL_TYPE_POLAR, VEL_TYPE_BROWNIAN, VEL_TYPE_FACE};
+		}
+		return null;
+	}
+
+	protected void initializeComponents () {
+		super.initializeComponents();
+		JPanel velocitiesPanel = new JPanel();
+		velocitiesPanel.setLayout(new GridBagLayout());
+		{
+			JPanel sideButtons = new JPanel(new GridBagLayout());
+			velocitiesPanel.add(sideButtons, new GridBagConstraints(1, 0, 1, 1, 1, 1, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE,
+				new Insets(0, 0, 0, 0), 0, 0));
+			{
+				sideButtons.add(velocityBox = new JComboBox(new DefaultComboBoxModel()), 
+					new GridBagConstraints(0, -1, 1, 1, 0, 0, GridBagConstraints.CENTER,
+					GridBagConstraints.HORIZONTAL, new Insets(0, 0, 6, 0), 0, 0));
+			}
+			{
+				JButton newButton = new JButton("New");
+				sideButtons.add(newButton, new GridBagConstraints(0, -1, 1, 1, 0, 0, GridBagConstraints.CENTER,
+					GridBagConstraints.HORIZONTAL, new Insets(0, 0, 6, 0), 0, 0));
+				newButton.addActionListener(new ActionListener() {
+					public void actionPerformed (ActionEvent event) {
+						createVelocity(velocityBox.getSelectedItem());
+					}
+				});
+			}
+			{
+				JButton deleteButton = new JButton("Delete");
+				sideButtons.add(deleteButton, new GridBagConstraints(0, -1, 1, 1, 0, 0, GridBagConstraints.CENTER,
+					GridBagConstraints.HORIZONTAL, new Insets(0, 0, 6, 0), 0, 0));
+				deleteButton.addActionListener(new ActionListener() {
+					public void actionPerformed (ActionEvent event) {
+						deleteVelocity();
+					}
+				});
+			}
+		}
+		JScrollPane scroll = new JScrollPane();
+		velocitiesPanel.add(scroll, new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0,
+			0, 0, 6), 0, 0));
+		velocityTable = new JTable() {
+			public Class getColumnClass (int column) {
+				return column == 1 ? Boolean.class : super.getColumnClass(column);
+			}
+			
+			@Override
+			public Dimension getPreferredScrollableViewportSize () {
+				Dimension dim = super.getPreferredScrollableViewportSize();
+				dim.height = getPreferredSize().height;
+				return dim;
+			}
+		};
+		velocityTable.getTableHeader().setReorderingAllowed(false);
+		velocityTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+		scroll.setViewportView(velocityTable);
+		velocityTableModel = new DefaultTableModel(new String[0][0], new String[] {"Velocity", "Active"});
+		velocityTable.setModel(velocityTableModel);
+		velocityTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {
+			public void valueChanged (ListSelectionEvent event) {
+				if (event.getValueIsAdjusting()) return;
+				velocitySelected();
+			}
+		});
+		velocityTableModel.addTableModelListener(new TableModelListener() {
+			public void tableChanged (TableModelEvent event) {
+				if (event.getColumn() != 1) return;
+				velocityChecked(event.getFirstRow(), (Boolean)velocityTable.getValueAt(event.getFirstRow(), 1));
+			}
+		});
+				
+		//Velocity values
+		emptyPanel = new ParticleValuePanel(editor, "", "",true, false);
+		strengthVelocityPanel = new StrengthVelocityPanel(editor, null, "Life", "", "");
+		angularVelocityPanel = new AngularVelocityPanel(editor, null, "Life", "", "");
+		strengthVelocityPanel.setVisible(false);
+		angularVelocityPanel.setVisible(false);
+		emptyPanel.setVisible(false);
+		strengthVelocityPanel.setIsAlwayShown(true);
+		angularVelocityPanel.setIsAlwayShown(true);
+		emptyPanel.setIsAlwayShown(true);
+		emptyPanel.setValue(null);
+		
+		//Assemble
+		int i=0;
+		addContent(i++, 0, velocitiesPanel);
+		addContent(i++, 0, strengthVelocityPanel);
+		addContent(i++, 0, angularVelocityPanel);
+		addContent(i++, 0, emptyPanel);
+	}
+
+	protected void velocityChecked (int index, boolean isChecked) {
+		ParticleController controller = editor.getEmitter();
+		DynamicsInfluencer influencer = (DynamicsInfluencer)controller.findInfluencer(DynamicsInfluencer.class);		
+		influencer.velocities.clear();
+		velocities.get(index).isActive = isChecked;
+		for(VelocityWrapper wrapper : velocities){
+			if(wrapper.isActive)
+				influencer.velocities.add(wrapper.velocityValue);
+		}
+		//Restart the effect and reinit the controller
+		editor.restart();
+	}
+
+	protected void velocitySelected () {
+		//Show the velocity value panel
+		int index = velocityTable.getSelectedRow();
+		if(index == -1) return;
+		
+		DynamicsModifier velocityValue = velocities.get(index).velocityValue;
+		EditorPanel velocityPanel = getVelocityPanel(velocityValue);
+		
+		//Show the selected velocity
+		if(selectedVelocityPanel != null && selectedVelocityPanel != velocityPanel) 
+			selectedVelocityPanel.setVisible(false);
+		velocityPanel.setVisible(true);
+		velocityPanel.showContent(true);
+		selectedVelocityPanel = velocityPanel;
+	}
+
+	private EditorPanel getVelocityPanel (DynamicsModifier velocityValue) {
+		EditorPanel panel = null;
+		//Billboards
+		if(velocityValue instanceof DynamicsModifier.Rotational2D ){
+			strengthVelocityPanel.setValue((DynamicsModifier.Strength) velocityValue);
+			strengthVelocityPanel.setName("Angular Velocity");
+			strengthVelocityPanel.setDescription("The angular speed around the billboard facing direction, in degrees/sec .");
+			panel = strengthVelocityPanel;
+		}
+		else if(	velocityValue instanceof CentripetalAcceleration){
+			strengthVelocityPanel.setValue((DynamicsModifier.CentripetalAcceleration) velocityValue);
+			strengthVelocityPanel.setName("Centripetal Acceleration");
+			strengthVelocityPanel.setDescription("A directional acceleration, the direction is towards the origin (global), or towards the emitter position (local), in world units/sec2 .");
+			panel = strengthVelocityPanel;
+		}
+		else if(	velocityValue instanceof TangentialAcceleration){
+			angularVelocityPanel.setValue((DynamicsModifier.Angular) velocityValue);
+			angularVelocityPanel.setName("Tangetial Velocity");
+			angularVelocityPanel.setDescription("A directional acceleration (axis and magnitude), the final direction is the cross product between particle position and the axis, in world units/sec2 .");
+			panel = angularVelocityPanel;
+		}
+		else if(	velocityValue instanceof PolarAcceleration){
+			angularVelocityPanel.setValue((DynamicsModifier.Angular) velocityValue);
+			angularVelocityPanel.setName("Polar Velocity");
+			angularVelocityPanel.setDescription("A directional acceleration (axis and magnitude), in world units/sec2 .");
+			panel = angularVelocityPanel;
+		}
+		else if(	velocityValue instanceof BrownianAcceleration){
+			strengthVelocityPanel.setValue((DynamicsModifier.Strength) velocityValue);
+			strengthVelocityPanel.setName("Brownian Velocity");
+			strengthVelocityPanel.setDescription("A directional acceleration which has random direction at each update, in world units/sec2.");
+			panel = strengthVelocityPanel;
+		}
+		else if(velocityValue instanceof Rotational3D ){
+			angularVelocityPanel.setValue((DynamicsModifier.Angular) velocityValue);
+			angularVelocityPanel.setName("Angular Velocity");
+			angularVelocityPanel.setDescription("An angular velocity (axis and magnitude), in degree/sec2.");
+			panel = angularVelocityPanel;
+		}
+		else if(	velocityValue instanceof FaceDirection){ 
+			emptyPanel.setName("Face");
+			emptyPanel.setDescription("Rotates the model to face its current velocity (Do not add any other angular velocity when using this).");
+			panel = emptyPanel;
+		}
+
+		return panel;
+	}
+	
+	private DynamicsModifier createVelocityValue (Object selectedItem) {
+		DynamicsModifier velocityValue = null;
+		if(selectedItem == VEL_TYPE_ROTATIONAL_2D) velocityValue = new DynamicsModifier.Rotational2D();
+		else if(selectedItem == VEL_TYPE_ROTATIONAL_3D) velocityValue = new DynamicsModifier.Rotational3D();
+		else if(selectedItem == VEL_TYPE_CENTRIPETAL) velocityValue = new DynamicsModifier.CentripetalAcceleration();
+		else if(selectedItem == VEL_TYPE_TANGENTIAL) velocityValue = new DynamicsModifier.TangentialAcceleration();
+		else if(selectedItem == VEL_TYPE_POLAR) velocityValue = new DynamicsModifier.PolarAcceleration();
+		else if(selectedItem == VEL_TYPE_BROWNIAN) velocityValue = new DynamicsModifier.BrownianAcceleration();
+		else if(selectedItem == VEL_TYPE_FACE) velocityValue = new DynamicsModifier.FaceDirection();
+		return velocityValue;
+	}
+	
+
+	protected void deleteVelocity () {
+		int row = velocityTable.getSelectedRow();
+		if (row == -1) return;
+		
+		//Remove the velocity from the table
+		ParticleController controller = editor.getEmitter();
+		DynamicsInfluencer influencer = (DynamicsInfluencer)controller.findInfluencer(DynamicsInfluencer.class);
+		influencer.velocities.removeValue(velocities.removeIndex(row).velocityValue, true);
+		velocityTableModel.removeRow(row);
+		
+		//Restart the effect and reinit the controller
+		editor.restart();
+
+		selectedVelocityPanel.setVisible(false);
+		selectedVelocityPanel = null;
+	}
+
+	protected void createVelocity (Object selectedItem) {
+		//Add the velocity to the table and to the influencer
+		ParticleController controller = editor.getEmitter();
+		DynamicsInfluencer influencer = (DynamicsInfluencer)controller.findInfluencer(DynamicsInfluencer.class);
+		VelocityWrapper wrapper = new VelocityWrapper(createVelocityValue(selectedItem), true);
+		velocities.add(wrapper);
+		influencer.velocities.add(wrapper.velocityValue);
+		int index = velocities.size-1;
+		velocityTableModel.addRow(new Object[] {"Velocity "+index, true});
+		
+		//Reinit
+		editor.restart();
+		
+		//Select new velocity
+		velocityTable.getSelectionModel().setSelectionInterval(index, index);
+		revalidate();
+		repaint();
+	}
+	
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/EditorPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/EditorPanel.java
new file mode 100644
index 0000000..dfb8bed
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/EditorPanel.java
@@ -0,0 +1,284 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.tools.flame;
+import java.awt.Container;
+import java.awt.Cursor;
+import java.awt.Font;
+import java.awt.GridBagConstraints;
+import java.awt.GridBagLayout;
+import java.awt.Insets;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+
+import javax.swing.BorderFactory;
+import javax.swing.JButton;
+import javax.swing.JCheckBox;
+import javax.swing.JComponent;
+import javax.swing.JLabel;
+import javax.swing.JPanel;
+import javax.swing.JSpinner;
+import javax.swing.JToggleButton;
+import javax.swing.event.ChangeListener;
+import javax.swing.event.TableModelListener;
+import javax.swing.table.DefaultTableModel;
+
+
+/** @author Inferno */
+public abstract class EditorPanel<T> extends JPanel {
+	private String name;
+	private String description;
+	protected  T value;
+	private JPanel titlePanel;
+	JToggleButton activeButton;
+	JPanel contentPanel;
+	JToggleButton advancedButton;
+	JButton removeButton;
+	JPanel advancedPanel;
+	private boolean hasAdvanced;
+	JLabel nameLabel, descriptionLabel;
+	protected boolean isAlwaysActive, isAlwaysShown = false, isRemovable;
+	protected FlameMain editor;
+	
+	public EditorPanel (FlameMain editor, String name, String description, boolean alwaysActive, boolean isRemovable) {
+		this.editor = editor;
+		this.name = name;
+		this.description = description;
+		this.isRemovable = isRemovable;
+		this.isAlwaysActive = alwaysActive;
+		initializeComponents();
+		showContent(false);
+	}
+	
+	public EditorPanel (FlameMain editor, String name, String description) {
+		this(editor, name, description, true, false);
+	}
+
+	protected void activate () {}
+	
+	public void showContent (boolean visible) {
+		contentPanel.setVisible(visible);
+		advancedPanel.setVisible(visible && advancedButton.isSelected());
+		advancedButton.setVisible(visible && hasAdvanced);
+		descriptionLabel.setText(visible ? description : "");
+	}
+	
+	public void setIsAlwayShown(boolean isAlwaysShown){
+		showContent(isAlwaysShown);
+		this.isAlwaysShown = isAlwaysShown;
+		titlePanel.setCursor(null);
+	}
+
+	public void update (FlameMain editor) {
+	}
+
+	public void setHasAdvanced (boolean hasAdvanced) {
+		this.hasAdvanced = hasAdvanced;
+		advancedButton.setVisible(hasAdvanced);
+	}
+
+	public JPanel getContentPanel () {
+		return contentPanel;
+	}
+
+	public JPanel getAdvancedPanel () {
+		return advancedPanel;
+	}
+
+	public String getName () {
+		return name;
+	}
+
+	public void setEmbedded () {
+		GridBagLayout layout = (GridBagLayout)getLayout();
+		GridBagConstraints constraints = layout.getConstraints(contentPanel);
+		constraints.insets = new Insets(0, 0, 0, 0);
+		layout.setConstraints(contentPanel, constraints);
+
+		titlePanel.setVisible(false);
+	}
+
+	protected void initializeComponents () {
+		setLayout(new GridBagLayout());
+		{
+			titlePanel = new JPanel(new GridBagLayout());
+			add(titlePanel, new GridBagConstraints(1, 0, 1, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL,
+				new Insets(3, 0, 3, 0), 0, 0));
+			titlePanel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
+			{
+				nameLabel = new JLabel(name);
+				titlePanel.add(nameLabel, new GridBagConstraints(0, 0, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+					new Insets(3, 6, 3, 6), 0, 0));
+				nameLabel.setFont(nameLabel.getFont().deriveFont(Font.BOLD));
+			}
+			{
+				descriptionLabel = new JLabel(description);
+				titlePanel.add(descriptionLabel, new GridBagConstraints(1, 0, 1, 1, 1.0, 0.0, GridBagConstraints.WEST,
+					GridBagConstraints.NONE, new Insets(3, 6, 3, 6), 0, 0));
+			}
+			{
+				advancedButton = new JToggleButton("Advanced");
+				titlePanel.add(advancedButton, new GridBagConstraints(2, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER,
+					GridBagConstraints.NONE, new Insets(0, 0, 0, 6), 0, 0));
+				advancedButton.setVisible(false);
+			}
+			{
+				activeButton = new JToggleButton("Active");
+				titlePanel.add(activeButton, new GridBagConstraints(3, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER,
+					GridBagConstraints.NONE, new Insets(0, 0, 0, 6), 0, 0));
+			}
+			{
+				removeButton = new JButton("X");
+				titlePanel.add(removeButton, new GridBagConstraints(4, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER,
+					GridBagConstraints.NONE, new Insets(0, 0, 0, 6), 0, 0));
+			}
+		}
+		{
+			contentPanel = new JPanel(new GridBagLayout());
+			add(contentPanel, new GridBagConstraints(1, 1, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.BOTH,
+				new Insets(0, 6, 6, 6), 0, 0));
+			contentPanel.setVisible(false);
+		}
+		{
+			advancedPanel = new JPanel(new GridBagLayout());
+			add(advancedPanel, new GridBagConstraints(1, 2, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.BOTH,
+				new Insets(0, 6, 6, 6), 0, 0));
+			advancedPanel.setVisible(false);
+		}
+		
+
+		titlePanel.addMouseListener(new MouseAdapter() {
+			public void mouseClicked (MouseEvent event) {
+				if(!isAlwaysShown)
+					showContent(!contentPanel.isVisible());
+			}
+		});
+		activeButton.addActionListener(new ActionListener() {
+			public void actionPerformed (ActionEvent event) {
+				activate();
+			}
+		});
+		advancedButton.addActionListener(new ActionListener() {
+			public void actionPerformed (ActionEvent event) {
+				advancedPanel.setVisible(advancedButton.isSelected());
+			}
+		});
+		
+		removeButton.addActionListener(new ActionListener() {
+			public void actionPerformed (ActionEvent event) {
+				removePanel();
+			}
+		});
+	}
+	
+	protected void removePanel () {
+		Container parent = this.getParent();
+		parent.remove(this);
+		parent.validate();
+		parent.repaint();
+	}
+
+	public void setName(String name){
+		this.name = name;
+		nameLabel.setText(name);
+	}
+	
+	public void setDescription(String desc){
+		description = desc;
+		descriptionLabel.setText(desc);
+	}
+	
+	
+	protected void addContent(int row, int column, JComponent component){
+		addContent(row, column, component, true, GridBagConstraints.CENTER, GridBagConstraints.BOTH);
+	}
+	
+	protected void addContent(int row, int column, JComponent component, boolean addBorder){
+		addContent(row, column, component, addBorder, GridBagConstraints.CENTER, GridBagConstraints.BOTH);
+	}
+	
+	protected void addContent(int row, int column, JComponent component, int anchor, int fill){
+		addContent(row, column, component, true, anchor, fill);
+	}
+	
+	protected void addContent(int row, int column, JComponent component, boolean addBorders, int anchor, int fill, float wx, float wy){
+		addContent(contentPanel, row, column, component, addBorders, anchor, fill, wx, wy);
+	}
+	
+	protected void addContent(int row, int column, JComponent component, boolean addBorders, int anchor, int fill){
+		addContent(row, column, component, addBorders, anchor, fill, 1, 1);
+	}
+
+	public void setValue (T value) {
+		this.value = value;
+		activeButton.setVisible(value == null ? false : !isAlwaysActive);
+		removeButton.setVisible(isRemovable);
+	}
+	
+	public static void addContent( JPanel panel, int row, int column, JComponent component, boolean addBorders, int anchor, int fill, float wx, float wy){
+		if(addBorders) component.setBorder(BorderFactory.createMatteBorder(0, 0, 1, 0, java.awt.Color.black));
+		panel.add(component, new GridBagConstraints(column, row, 1, 1, wx, wy, anchor, fill,
+			new Insets(0, 0, 0, 0), 0, 0));
+	}
+	
+	protected static <K> void setValue(JSpinner spinner, K object){
+		ChangeListener[] listeners = spinner.getChangeListeners();
+		ChangeListener listener = null;
+		if(listeners != null && listeners.length >0){
+			listener = listeners[0];
+			spinner.removeChangeListener(listener);
+		}
+		spinner.setValue(object);
+		if(listener != null) spinner.addChangeListener(listener);
+	}
+	
+	protected static void setValue(JCheckBox checkBox, boolean isSelected){
+		ActionListener[] listeners = checkBox.getActionListeners();
+		ActionListener listener = null;
+		if(listeners != null && listeners.length >0){
+			listener = listeners[0];
+			checkBox.removeActionListener(listener);
+		}
+		checkBox.setSelected(isSelected);
+		if(listener != null) checkBox.addActionListener(listener);
+	}
+	
+	protected static <K> void setValue(Slider slider, float value){
+		ChangeListener[] listeners = slider.spinner.getChangeListeners();
+		ChangeListener listener = null;
+		if(listeners != null && listeners.length >0){
+			listener = listeners[0];
+			slider.spinner.removeChangeListener(listener);
+		}
+		slider.setValue(value);
+		if(listener != null) slider.spinner.addChangeListener(listener);
+	}
+
+	protected static void setValue (DefaultTableModel tableModel, Object value, int row, int column) {
+		TableModelListener[] listeners = tableModel.getTableModelListeners();
+		TableModelListener listener = null;
+		if(listeners != null && listeners.length >0){
+			listener = listeners[0];
+			tableModel.removeTableModelListener(listener);
+		}
+		tableModel.setValueAt(value, row, column);
+		if(listener != null) tableModel.addTableModelListener(listener);
+	}
+	
+	
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/EffectPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/EffectPanel.java
new file mode 100644
index 0000000..a2d4ec1
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/EffectPanel.java
@@ -0,0 +1,534 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package com.badlogic.gdx.tools.flame;
+import java.awt.Dimension;
+import java.awt.GridBagConstraints;
+import java.awt.GridBagLayout;
+import java.awt.Insets;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.io.File;
+
+import javax.swing.DefaultComboBoxModel;
+import javax.swing.JButton;
+import javax.swing.JComboBox;
+import javax.swing.JPanel;
+import javax.swing.JScrollPane;
+import javax.swing.JSeparator;
+import javax.swing.JTable;
+import javax.swing.ListSelectionModel;
+import javax.swing.event.ListSelectionEvent;
+import javax.swing.event.ListSelectionListener;
+import javax.swing.event.TableModelEvent;
+import javax.swing.event.TableModelListener;
+import javax.swing.table.DefaultTableModel;
+
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.g3d.Model;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleController;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleEffect;
+import com.badlogic.gdx.graphics.g3d.particles.emitters.RegularEmitter;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.ColorInfluencer;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.DynamicsInfluencer;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.DynamicsModifier;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.ModelInfluencer;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.ParticleControllerFinalizerInfluencer;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.ParticleControllerInfluencer;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.RegionInfluencer;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.ScaleInfluencer;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.SpawnInfluencer;
+import com.badlogic.gdx.graphics.g3d.particles.renderers.BillboardRenderer;
+import com.badlogic.gdx.graphics.g3d.particles.renderers.ModelInstanceRenderer;
+import com.badlogic.gdx.graphics.g3d.particles.renderers.ParticleControllerControllerRenderer;
+import com.badlogic.gdx.graphics.g3d.particles.renderers.PointSpriteRenderer;
+import com.badlogic.gdx.graphics.g3d.particles.values.EllipseSpawnShapeValue;
+import com.badlogic.gdx.graphics.g3d.particles.values.PointSpawnShapeValue;
+import com.badlogic.gdx.graphics.g3d.particles.values.PrimitiveSpawnShapeValue.SpawnSide;
+import com.badlogic.gdx.tools.flame.FlameMain.ControllerData;
+import com.badlogic.gdx.tools.flame.FlameMain.ControllerType;
+
+/** @author Inferno */
+class EffectPanel extends JPanel {
+	FlameMain editor;
+	JTable emitterTable;
+	DefaultTableModel emitterTableModel;
+	int editIndex = -1;
+	String lastDir;
+	JComboBox controllerTypeCombo;
+	
+	
+	public EffectPanel (FlameMain editor) {
+		this.editor = editor;
+		initializeComponents();
+	}
+
+	public <T extends ParticleController> T createDefaultEmitter (ControllerType type, boolean select, boolean add) {
+
+		T controller = null;
+		if(type == ControllerType.Billboard){
+			controller = (T)createDefaultBillboardController();
+		}
+		else if(type == ControllerType.ModelInstance){
+			controller = (T) createDefaultModelInstanceController();
+		}
+		else if(type == ControllerType.PointSprite){
+			controller = (T) createDefaultPointController();
+		}
+		else if(type == ControllerType.ParticleController){
+			controller = (T) createDefaultParticleController();
+		}
+		
+		if(add){
+			controller.init();
+			addEmitter(controller, select);
+		}
+		return controller;
+	}
+
+	private ParticleController createDefaultModelInstanceController () {
+		//Emission
+		RegularEmitter emitter = new RegularEmitter();
+		emitter.getDuration().setLow(3000);
+		emitter.getEmission().setHigh(80);
+		emitter.getLife().setHigh(500, 1000);
+		emitter.getLife().setTimeline(new float[] {0, 0.66f, 1});
+		emitter.getLife().setScaling(new float[] {1, 1, 0.3f});
+		emitter.setMaxParticleCount(100);
+
+		//Color
+		ColorInfluencer.Random colorInfluencer = new ColorInfluencer.Random();
+
+		//Spawn
+		EllipseSpawnShapeValue spawnShapeValue = new EllipseSpawnShapeValue();
+		spawnShapeValue.setDimensions(1, 1, 1);
+		SpawnInfluencer spawnSource = new SpawnInfluencer(spawnShapeValue);
+
+		//Velocity
+		DynamicsInfluencer velocityInfluencer = new DynamicsInfluencer();
+
+		//Directional
+		DynamicsModifier.CentripetalAcceleration velocityValue = new DynamicsModifier.CentripetalAcceleration();
+		velocityValue.strengthValue.setHigh(5, 11);
+		velocityValue.strengthValue.setActive(true);
+		//velocityValue.setActive(true);
+		velocityInfluencer.velocities.add(velocityValue);
+		//VelocityModifier.FaceDirection faceVelocityValue = new VelocityModifier.FaceDirection();
+		//velocityInfluencer.velocities.add(faceVelocityValue);
+		
+		return new ParticleController("ModelInstance Controller", emitter, new ModelInstanceRenderer(editor.getModelInstanceParticleBatch()), 
+			new ModelInfluencer.Single((Model) editor.assetManager.get(FlameMain.DEFAULT_MODEL_PARTICLE) ),
+			spawnSource,
+			colorInfluencer,
+			velocityInfluencer
+			);
+	}
+
+	private ParticleController createDefaultBillboardController () {
+		//Emission
+		RegularEmitter emitter = new RegularEmitter();
+		emitter.getDuration().setLow(3000);
+		emitter.getEmission().setHigh(250);
+		emitter.getLife().setHigh(500, 1000);
+		emitter.getLife().setTimeline(new float[] {0, 0.66f, 1});
+		emitter.getLife().setScaling(new float[] {1, 1, 0.3f});
+		emitter.setMaxParticleCount(200);
+
+		//Spawn
+		PointSpawnShapeValue pointSpawnShapeValue = new PointSpawnShapeValue();
+		SpawnInfluencer spawnSource = new SpawnInfluencer(pointSpawnShapeValue);
+
+		//Color
+		ColorInfluencer.Single colorInfluencer = new ColorInfluencer.Single();
+		colorInfluencer.colorValue.setColors(new float[] {1, 0.12156863f, 0.047058824f, 0,0,0});
+		colorInfluencer.colorValue.setTimeline(new float[] {0, 1});
+		colorInfluencer.alphaValue.setHigh(1);
+		colorInfluencer.alphaValue.setTimeline(new float[] {0, 0.5f, 0.8f, 1});
+		colorInfluencer.alphaValue.setScaling(new float[] {0, 0.15f, 0.5f, 0});
+		
+		//Velocity
+		DynamicsInfluencer velocityInfluencer = new DynamicsInfluencer();
+
+		//Directional
+		DynamicsModifier.PolarAcceleration velocityValue = new DynamicsModifier.PolarAcceleration();
+		velocityValue.phiValue.setHigh(-35, 35);
+		velocityValue.phiValue.setActive(true);
+		velocityValue.phiValue.setTimeline(new float[] {0, 0.5f, 1});
+		velocityValue.phiValue.setScaling(new float[] {1, 0, 0});
+		velocityValue.thetaValue.setHigh(0, 360);
+		velocityValue.strengthValue.setHigh(5, 10);
+		velocityInfluencer.velocities.add(velocityValue);
+
+		return new ParticleController("Billboard Controller", emitter, new BillboardRenderer(editor.getBillboardBatch()), 
+			new RegionInfluencer.Single(editor.getTexture()),
+			spawnSource,
+			colorInfluencer,
+			velocityInfluencer
+			);
+	}
+	
+	private ParticleController createDefaultPointController () {
+		//Emission
+		RegularEmitter emitter = new RegularEmitter();
+		emitter.getDuration().setLow(3000);
+		emitter.getEmission().setHigh(250);
+		emitter.getLife().setHigh(500, 1000);
+		emitter.getLife().setTimeline(new float[] {0, 0.66f, 1});
+		emitter.getLife().setScaling(new float[] {1, 1, 0.3f});
+		emitter.setMaxParticleCount(200);
+		
+		//Scale
+		ScaleInfluencer scaleInfluencer = new ScaleInfluencer();
+		scaleInfluencer.value.setHigh(1);
+
+		//Color
+		ColorInfluencer.Single colorInfluencer = new ColorInfluencer.Single();
+		colorInfluencer.colorValue.setColors(new float[] {0.12156863f, 0.047058824f, 1, 0,0,0});
+		colorInfluencer.colorValue.setTimeline(new float[] {0, 1});
+		colorInfluencer.alphaValue.setHigh(1);
+		colorInfluencer.alphaValue.setTimeline(new float[] {0, 0.5f, 0.8f, 1});
+		colorInfluencer.alphaValue.setScaling(new float[] {0, 0.15f, 0.5f, 0});
+
+		//Spawn
+		PointSpawnShapeValue pointSpawnShapeValue = new PointSpawnShapeValue();
+		SpawnInfluencer spawnSource = new SpawnInfluencer(pointSpawnShapeValue);
+
+		//Velocity
+		DynamicsInfluencer velocityInfluencer = new DynamicsInfluencer();
+
+		//Directional
+		DynamicsModifier.PolarAcceleration velocityValue = new DynamicsModifier.PolarAcceleration();
+		velocityValue.phiValue.setHigh(-35, 35);
+		velocityValue.phiValue.setActive(true);
+		velocityValue.phiValue.setTimeline(new float[] {0, 0.5f, 1});
+		velocityValue.phiValue.setScaling(new float[] {1, 0, 0});
+		velocityValue.thetaValue.setHigh(0, 360);
+		velocityValue.strengthValue.setHigh(5, 10);
+
+		return new ParticleController("PointSprite Controller", emitter, new PointSpriteRenderer(editor.getPointSpriteBatch()),
+			new RegionInfluencer.Single((Texture) editor.assetManager.get(FlameMain.DEFAULT_BILLBOARD_PARTICLE) ),
+			spawnSource,
+			scaleInfluencer,
+			colorInfluencer,
+			velocityInfluencer
+			);
+	}
+	
+	private ParticleController createDefaultParticleController () {
+		//Emission
+		RegularEmitter emitter = new RegularEmitter();
+		emitter.getDuration().setLow(3000);
+		emitter.getEmission().setHigh(90);
+		emitter.getLife().setHigh(3000);
+		emitter.setMaxParticleCount(100);
+
+		//Spawn
+		EllipseSpawnShapeValue pointSpawnShapeValue = new EllipseSpawnShapeValue();
+		pointSpawnShapeValue.setDimensions(1, 1, 1);
+		pointSpawnShapeValue.setSide(SpawnSide.top);
+		SpawnInfluencer spawnSource = new SpawnInfluencer(pointSpawnShapeValue);
+
+		//Scale
+		ScaleInfluencer scaleInfluencer = new ScaleInfluencer();
+		scaleInfluencer.value.setHigh(1);
+		scaleInfluencer.value.setLow(0);
+		scaleInfluencer.value.setTimeline(new float[]{0,1});
+		scaleInfluencer.value.setScaling(new float[]{1, 0});
+		
+		//Velocity
+		DynamicsInfluencer velocityInfluencer = new DynamicsInfluencer();
+
+		//Directional
+		DynamicsModifier.CentripetalAcceleration velocityValue = new DynamicsModifier.CentripetalAcceleration();
+		velocityValue.strengthValue.setHigh(5, 10);
+		velocityValue.strengthValue.setActive(true);
+		velocityInfluencer.velocities.add(velocityValue);
+
+		return new ParticleController("ParticleController Controller", emitter, new ParticleControllerControllerRenderer(),
+			new ParticleControllerInfluencer.Single(editor.assetManager.get(FlameMain.DEFAULT_TEMPLATE_PFX, ParticleEffect.class).getControllers().get(0)),
+			spawnSource,
+			scaleInfluencer,
+			velocityInfluencer,
+			new ParticleControllerFinalizerInfluencer()
+			);
+	}
+	
+	public ParticleController createDefaultTemplateController(){
+		//Emission
+		RegularEmitter emitter = new RegularEmitter();
+		emitter.getDuration().setLow(3000);
+		emitter.getEmission().setHigh(90);
+		emitter.getLife().setHigh(1000);
+		emitter.getLife().setTimeline(new float[] {0, 0.66f, 1});
+		emitter.getLife().setScaling(new float[] {1, 1, 0.3f});
+		emitter.setMaxParticleCount(100);
+
+		//Spawn
+		PointSpawnShapeValue pointSpawnShapeValue = new PointSpawnShapeValue();		
+		pointSpawnShapeValue.xOffsetValue.setLow(0, 1f);
+		pointSpawnShapeValue.xOffsetValue.setActive(true);
+		pointSpawnShapeValue.yOffsetValue.setLow(0, 1f);
+		pointSpawnShapeValue.yOffsetValue.setActive(true);
+		pointSpawnShapeValue.zOffsetValue.setLow(0, 1f);
+		pointSpawnShapeValue.zOffsetValue.setActive(true);
+		SpawnInfluencer spawnSource = new SpawnInfluencer(pointSpawnShapeValue);
+
+		ScaleInfluencer scaleInfluencer = new ScaleInfluencer();
+		scaleInfluencer.value.setHigh(1f);
+		
+		//Color
+		ColorInfluencer.Single colorInfluencer = new ColorInfluencer.Single();
+		colorInfluencer.colorValue.setColors(new float[] {1, 0.12156863f, 0.047058824f, 0,0,0});
+		colorInfluencer.colorValue.setTimeline(new float[] {0, 1});
+		colorInfluencer.alphaValue.setHigh(1);
+		colorInfluencer.alphaValue.setTimeline(new float[] {0, 0.5f, 0.8f, 1});
+		colorInfluencer.alphaValue.setScaling(new float[] {0, 0.15f, 0.5f, 0});
+
+		return new ParticleController("Billboard Controller", emitter, new BillboardRenderer(editor.getBillboardBatch()), 
+			new RegionInfluencer.Single(editor.getTexture()),
+			spawnSource,
+			scaleInfluencer,
+			colorInfluencer
+			);
+	}
+
+	private void addEmitter (final ParticleController emitter, boolean select) {
+		editor.addEmitter(emitter);
+		emitterTableModel.addRow(new Object[] {emitter.name, true});
+		
+		int row = emitterTableModel.getRowCount() - 1;
+		emitterChecked (row, true); 
+		
+		if (select) {
+			emitterTable.getSelectionModel().setSelectionInterval(row, row);
+		}
+	}
+
+	void emitterSelected () {
+		int row = emitterTable.getSelectedRow();
+		if (row == editIndex) 
+			return;
+		
+		editIndex = row;
+		editor.reloadRows();
+	}
+
+	void emitterChecked (int index, boolean checked) {
+		editor.setEnabled(index, checked);
+	}
+	
+	void openEffect () {
+		File file = editor.showFileLoadDialog();
+		if(file != null){
+			if(editor.openEffect(file, true) != null){
+				emitterTableModel.getDataVector().removeAllElements();
+				for (ControllerData data : editor.controllersData) {
+					emitterTableModel.addRow(new Object[] {data.controller.name, true});
+				}
+				editIndex = 0;
+				emitterTable.getSelectionModel().setSelectionInterval(editIndex, editIndex);
+			}
+		}
+	}
+	
+	protected void importEffect () {
+		File file = editor.showFileLoadDialog();
+		if(file != null){
+			ParticleEffect effect;
+			if( (effect = editor.openEffect(file, false)) != null){
+				for(ParticleController controller : effect.getControllers())
+					addEmitter(controller, false);
+				editIndex = 0;
+				emitterTable.getSelectionModel().setSelectionInterval(editIndex, editIndex);
+			}
+		}
+	}
+
+	void saveEffect () {
+		File file = editor.showFileSaveDialog();
+		if(file != null){
+			int index = 0;
+			for (ControllerData data : editor.controllersData)
+				data.controller.name = ((String)emitterTableModel.getValueAt(index++, 0));
+			editor.saveEffect(file);
+		}
+	}
+
+	void deleteEmitter () {
+		int row = emitterTable.getSelectedRow();
+		if (row == -1) return;
+		
+		int newIndex = Math.min(editIndex, emitterTableModel.getRowCount()-2);
+		
+		editor.removeEmitter(row);
+		emitterTableModel.removeRow(row);
+
+		//Reload data check
+		emitterTable.getSelectionModel().setSelectionInterval(newIndex, newIndex);
+	}
+
+	protected void cloneEmitter () {
+		int row = emitterTable.getSelectedRow();
+		if (row == -1) return;
+		ParticleController controller = editor.controllersData.get(row).controller.copy();
+		controller.init();
+		controller.name +=" Clone";
+		addEmitter(controller, true);
+	}
+
+	void move (int direction) {
+		/*
+		Array<ParticleController> emitters = editor.effect.getControllers();
+		if ( (direction < 0 && editIndex == 0) || (direction > 0 && editIndex == emitters.size - 1)) return;
+		int insertIndex = editIndex + direction;
+		Object name = emitterTableModel.getValueAt(editIndex, 0);
+		boolean isEnabled = editor.isEnabled(editIndex);
+		ParticleController emitter = emitters.removeIndex(editIndex);
+		emitterTableModel.removeRow(editIndex);
+		emitterTableModel.insertRow(insertIndex, new Object[] {name, isEnabled});
+		emitters.insert(insertIndex, emitter);
+		editIndex = insertIndex;
+		emitterTable.getSelectionModel().setSelectionInterval(editIndex, editIndex);
+		*/
+	}
+
+	private void initializeComponents () {
+		setLayout(new GridBagLayout());
+		{
+			JScrollPane scroll = new JScrollPane();
+			add(scroll, new GridBagConstraints(0, 0, 1, 1, 1, 0, GridBagConstraints.CENTER, GridBagConstraints.BOTH, new Insets(0,
+				0, 0, 6), 0, 0));
+			{
+				emitterTable = new JTable() {
+					public Class getColumnClass (int column) {
+						return column == 1 ? Boolean.class : super.getColumnClass(column);
+					}
+					@Override
+					public Dimension getPreferredScrollableViewportSize () {
+						Dimension dim = super.getPreferredScrollableViewportSize();
+						dim.height = getPreferredSize().height;
+						return dim;
+					}
+				};
+				emitterTable.getTableHeader().setReorderingAllowed(false);
+				emitterTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+				scroll.setViewportView(emitterTable);
+				emitterTableModel = new DefaultTableModel(new String[0][0], new String[] {"Emitter", ""});
+				emitterTable.setModel(emitterTableModel);
+				emitterTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {
+					public void valueChanged (ListSelectionEvent event) {
+						if (event.getValueIsAdjusting()) return;
+						emitterSelected();
+					}
+				});
+				emitterTableModel.addTableModelListener(new TableModelListener() {
+					public void tableChanged (TableModelEvent event) {
+						if (event.getColumn() != 1) return;
+						emitterChecked(event.getFirstRow(), (Boolean)emitterTable.getValueAt(event.getFirstRow(), 1));
+					}
+				});
+			}
+		}
+		{
+			JPanel sideButtons = new JPanel(new GridBagLayout());
+			add(sideButtons, new GridBagConstraints(1, 0, 1, 1, 0, 0, GridBagConstraints.NORTHWEST, GridBagConstraints.BOTH,
+				new Insets(0, 0, 0, 0), 0, 0));
+			{
+				controllerTypeCombo = new JComboBox();
+				controllerTypeCombo.setModel(new DefaultComboBoxModel(ControllerType.values()));
+				sideButtons.add(controllerTypeCombo, new GridBagConstraints(0, -1, 1, 1, 0, 0, GridBagConstraints.CENTER,
+					GridBagConstraints.HORIZONTAL, new Insets(0, 0, 6, 0), 0, 0));
+			}
+			{
+				JButton newButton = new JButton("New");
+				sideButtons.add(newButton, new GridBagConstraints(0, -1, 1, 1, 0, 0, GridBagConstraints.CENTER,
+					GridBagConstraints.HORIZONTAL, new Insets(0, 0, 6, 0), 0, 0));
+				newButton.addActionListener(new ActionListener() {
+					public void actionPerformed (ActionEvent event) {
+						ControllerType item = (ControllerType)controllerTypeCombo.getSelectedItem();
+						createDefaultEmitter(item, true, true);
+					}
+				});
+			}
+			{
+				JButton deleteButton = new JButton("Delete");
+				sideButtons.add(deleteButton, new GridBagConstraints(0, -1, 1, 1, 0, 0, GridBagConstraints.CENTER,
+					GridBagConstraints.HORIZONTAL, new Insets(0, 0, 6, 0), 0, 0));
+				deleteButton.addActionListener(new ActionListener() {
+					public void actionPerformed (ActionEvent event) {
+						deleteEmitter();
+					}
+				});
+			}
+			{
+				JButton cloneButton = new JButton("Clone");
+				sideButtons.add(cloneButton, new GridBagConstraints(0, -1, 1, 1, 0, 0, GridBagConstraints.CENTER,
+					GridBagConstraints.HORIZONTAL, new Insets(0, 0, 6, 0), 0, 0));
+				cloneButton.addActionListener(new ActionListener() {
+					public void actionPerformed (ActionEvent event) {
+						cloneEmitter();
+					}
+				});
+			}
+			{
+				sideButtons.add(new JSeparator(JSeparator.HORIZONTAL), new GridBagConstraints(0, -1, 1, 1, 0, 0,
+					GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, new Insets(0, 0, 6, 0), 0, 0));
+			}
+			{
+				JButton saveButton = new JButton("Save");
+				sideButtons.add(saveButton, new GridBagConstraints(0, -1, 1, 1, 0, 0, GridBagConstraints.CENTER,
+					GridBagConstraints.HORIZONTAL, new Insets(0, 0, 6, 0), 0, 0));
+				saveButton.addActionListener(new ActionListener() {
+					public void actionPerformed (ActionEvent event) {
+						saveEffect();
+					}
+				});
+			}
+			{
+				JButton openButton = new JButton("Open");
+				sideButtons.add(openButton, new GridBagConstraints(0, -1, 1, 1, 0, 0, GridBagConstraints.CENTER,
+					GridBagConstraints.HORIZONTAL, new Insets(0, 0, 6, 0), 0, 0));
+				openButton.addActionListener(new ActionListener() {
+					public void actionPerformed (ActionEvent event) {
+						openEffect();
+					}
+				});
+			}
+			{
+				JButton importButton = new JButton("Import");
+				sideButtons.add(importButton, new GridBagConstraints(0, -1, 1, 1, 0, 0, GridBagConstraints.CENTER,
+					GridBagConstraints.HORIZONTAL, new Insets(0, 0, 6, 0), 0, 0));
+				importButton.addActionListener(new ActionListener() {
+					public void actionPerformed (ActionEvent event) {
+						importEffect();
+					}
+				});
+			}
+			/*
+			{
+				JButton importButton = new JButton("Export");
+				sideButtons.add(importButton, new GridBagConstraints(0, -1, 1, 1, 0, 0, GridBagConstraints.CENTER,
+					GridBagConstraints.HORIZONTAL, new Insets(0, 0, 6, 0), 0, 0));
+				importButton.addActionListener(new ActionListener() {
+					public void actionPerformed (ActionEvent event) {
+						exportEffect();
+					}
+				});
+			}
+			*/
+		}
+	}
+
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/EmptyPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/EmptyPanel.java
new file mode 100644
index 0000000..92588d6
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/EmptyPanel.java
@@ -0,0 +1,11 @@
+package com.badlogic.gdx.tools.flame;
+
+
+/** @author Inferno */
+public class EmptyPanel extends EditorPanel {
+
+	public EmptyPanel (FlameMain particleEditor3D, String name , String desc) {
+		super(particleEditor3D, name, desc);
+		setValue(null);
+	}
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/EventManager.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/EventManager.java
new file mode 100644
index 0000000..3cfc710
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/EventManager.java
@@ -0,0 +1,70 @@
+package com.badlogic.gdx.tools.flame;
+
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.ObjectMap;
+
+/** @author Inferno */
+public class EventManager 
+{
+	private static EventManager mInstance;
+	public interface Listener
+	{
+		public void handle( int aEventType, Object aEventData);
+	}
+	
+	private ObjectMap<Integer, Array<Listener>> mListeners;
+	
+	private EventManager()
+	{
+		mListeners = new ObjectMap<Integer, Array<Listener>>();
+	}
+	
+	public static EventManager get()
+	{
+		if(mInstance == null) mInstance = new EventManager();
+		return mInstance;
+	}
+	
+	public void attach(int aEventType, Listener aListener)
+	{
+		boolean isNew = false;
+		Array<Listener> listeners = mListeners.get(aEventType);
+		if(listeners == null)
+		{
+			listeners = new Array<EventManager.Listener>();
+			mListeners.put(aEventType, listeners);
+			isNew = true;
+		}
+		
+		if(isNew || !listeners.contains(aListener, true))
+		{
+			listeners.add(aListener);
+		}
+		
+	}
+	
+	public void detach(int aEventType, Listener aListener)
+	{
+		Array<Listener> listeners = mListeners.get(aEventType);
+		if(listeners != null)
+		{
+			listeners.removeValue(aListener, true);
+			if(listeners.size == 0) mListeners.remove(aEventType);
+		}	
+	}
+	
+	public void fire( int aEventType, Object aEventData)
+	{
+		Array<Listener> listeners = mListeners.get(aEventType);
+		if(listeners != null)
+		for(Listener listener : listeners)
+		{
+			listener.handle(aEventType, aEventData);
+		}
+	}
+	
+	public void clear(){
+		mListeners.clear();
+	}
+
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/FlameMain.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/FlameMain.java
new file mode 100644
index 0000000..620328e
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/FlameMain.java
@@ -0,0 +1,1023 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package com.badlogic.gdx.tools.flame;
+
+import java.awt.BorderLayout;
+import java.awt.Component;
+import java.awt.EventQueue;
+import java.awt.FileDialog;
+import java.awt.Graphics;
+import java.awt.GridBagConstraints;
+import java.awt.GridBagLayout;
+import java.awt.Insets;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.awt.event.WindowAdapter;
+import java.awt.event.WindowEvent;
+import java.io.File;
+import java.io.Writer;
+
+import javax.swing.BorderFactory;
+import javax.swing.DefaultComboBoxModel;
+import javax.swing.JButton;
+import javax.swing.JComboBox;
+import javax.swing.JComponent;
+import javax.swing.JFrame;
+import javax.swing.JOptionPane;
+import javax.swing.JPanel;
+import javax.swing.JScrollPane;
+import javax.swing.JSplitPane;
+import javax.swing.UIManager;
+import javax.swing.UIManager.LookAndFeelInfo;
+import javax.swing.border.CompoundBorder;
+import javax.swing.plaf.basic.BasicSplitPaneUI;
+
+import com.badlogic.gdx.ApplicationListener;
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.InputMultiplexer;
+import com.badlogic.gdx.assets.AssetDescriptor;
+import com.badlogic.gdx.assets.AssetErrorListener;
+import com.badlogic.gdx.assets.AssetLoaderParameters;
+import com.badlogic.gdx.assets.AssetManager;
+import com.badlogic.gdx.assets.loaders.AssetLoader;
+import com.badlogic.gdx.assets.loaders.resolvers.AbsoluteFileHandleResolver;
+import com.badlogic.gdx.assets.loaders.resolvers.InternalFileHandleResolver;
+import com.badlogic.gdx.backends.lwjgl.LwjglCanvas;
+import com.badlogic.gdx.files.FileHandle;
+import com.badlogic.gdx.graphics.Color;
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.gdx.graphics.PerspectiveCamera;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.VertexAttributes.Usage;
+import com.badlogic.gdx.graphics.g2d.TextureAtlas;
+import com.badlogic.gdx.graphics.g3d.Environment;
+import com.badlogic.gdx.graphics.g3d.Material;
+import com.badlogic.gdx.graphics.g3d.Model;
+import com.badlogic.gdx.graphics.g3d.ModelBatch;
+import com.badlogic.gdx.graphics.g3d.ModelInstance;
+import com.badlogic.gdx.graphics.g3d.attributes.BlendingAttribute;
+import com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute;
+import com.badlogic.gdx.graphics.g3d.environment.DirectionalLight;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleController;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleEffect;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleEffectLoader;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleEffectLoader.ParticleEffectSaveParameter;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleSystem;
+import com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch;
+import com.badlogic.gdx.graphics.g3d.particles.batches.ModelInstanceParticleBatch;
+import com.badlogic.gdx.graphics.g3d.particles.batches.ParticleBatch;
+import com.badlogic.gdx.graphics.g3d.particles.batches.PointSpriteParticleBatch;
+import com.badlogic.gdx.graphics.g3d.particles.emitters.Emitter;
+import com.badlogic.gdx.graphics.g3d.particles.emitters.RegularEmitter;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.ColorInfluencer;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.DynamicsInfluencer;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.Influencer;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.ModelInfluencer;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.ParticleControllerFinalizerInfluencer;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.ParticleControllerInfluencer;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.RegionInfluencer;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.ScaleInfluencer;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.SpawnInfluencer;
+import com.badlogic.gdx.graphics.g3d.particles.renderers.BillboardRenderer;
+import com.badlogic.gdx.graphics.g3d.particles.renderers.ModelInstanceRenderer;
+import com.badlogic.gdx.graphics.g3d.particles.renderers.ParticleControllerControllerRenderer;
+import com.badlogic.gdx.graphics.g3d.particles.renderers.PointSpriteRenderer;
+import com.badlogic.gdx.graphics.g3d.particles.values.GradientColorValue;
+import com.badlogic.gdx.graphics.g3d.particles.values.NumericValue;
+import com.badlogic.gdx.graphics.g3d.utils.CameraInputController;
+import com.badlogic.gdx.graphics.g3d.utils.ModelBuilder;
+import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.math.RandomXS128;
+import com.badlogic.gdx.scenes.scene2d.InputEvent;
+import com.badlogic.gdx.scenes.scene2d.Stage;
+import com.badlogic.gdx.scenes.scene2d.ui.Label;
+import com.badlogic.gdx.scenes.scene2d.ui.Skin;
+import com.badlogic.gdx.scenes.scene2d.ui.Table;
+import com.badlogic.gdx.scenes.scene2d.ui.TextButton;
+import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.StreamUtils;
+import com.badlogic.gdx.utils.StringBuilder;
+
+/** @author Inferno */
+public class FlameMain extends JFrame implements AssetErrorListener {
+	public static final String 	DEFAULT_FONT = "default.fnt",
+											DEFAULT_BILLBOARD_PARTICLE = "pre_particle.png",
+											DEFAULT_MODEL_PARTICLE = "monkey.g3db",
+											//DEFAULT_PFX = "default.pfx",
+											DEFAULT_TEMPLATE_PFX = "defaultTemplate.pfx",
+											DEFAULT_SKIN = "uiskin.json";
+	
+	public static final int EVT_ASSET_RELOADED = 0;
+	
+	static class ControllerData {
+		public boolean enabled = true;
+		public ParticleController controller;
+		public ControllerData (ParticleController emitter) {
+			controller = emitter;
+		}
+	}
+	
+	private static class InfluencerWrapper<T>{
+		String string;
+		Class<Influencer> type;
+		public InfluencerWrapper(String string, Class<Influencer> type){
+			this.string = string;
+			this.type = type;
+		}
+		
+		@Override
+		public String toString () {
+			return string;
+		}
+	}
+
+	public enum ControllerType{
+		Billboard( "Billboard", new InfluencerWrapper[]{
+			new InfluencerWrapper("Single Color", ColorInfluencer.Single.class),
+			new InfluencerWrapper("Random Color", ColorInfluencer.Random.class),
+			new InfluencerWrapper("Single Region", RegionInfluencer.Single.class),
+			new InfluencerWrapper("Random Region", RegionInfluencer.Random.class),
+			new InfluencerWrapper("Animated Region", RegionInfluencer.Animated.class),
+			new InfluencerWrapper("Scale", ScaleInfluencer.class),
+			new InfluencerWrapper("Spawn", SpawnInfluencer.class),
+			new InfluencerWrapper("Dynamics", DynamicsInfluencer.class)}), 
+		PointSprite("Point Sprite", new InfluencerWrapper[]{
+				new InfluencerWrapper("Single Color", ColorInfluencer.Single.class),
+				new InfluencerWrapper("Random Color", ColorInfluencer.Random.class),
+				new InfluencerWrapper("Single Region", RegionInfluencer.Single.class),
+				new InfluencerWrapper("Random Region", RegionInfluencer.Random.class),
+				new InfluencerWrapper("Animated Region", RegionInfluencer.Animated.class),
+				new InfluencerWrapper("Scale", ScaleInfluencer.class),
+				new InfluencerWrapper("Spawn", SpawnInfluencer.class),
+				new InfluencerWrapper("Dynamics", DynamicsInfluencer.class)}),
+		ModelInstance( "Model Instance", new InfluencerWrapper[]{
+					new InfluencerWrapper("Single Color", ColorInfluencer.Single.class),
+					new InfluencerWrapper("Random Color", ColorInfluencer.Random.class),
+					new InfluencerWrapper("Single Model", ModelInfluencer.Single.class),
+					new InfluencerWrapper("Random Model", ModelInfluencer.Random.class),
+					new InfluencerWrapper("Scale", ScaleInfluencer.class),
+					new InfluencerWrapper("Spawn", SpawnInfluencer.class),
+					new InfluencerWrapper("Dynamics", DynamicsInfluencer.class)}),
+		ParticleController("Particle Controller", new InfluencerWrapper[]{
+						new InfluencerWrapper("Single Particle Controller", ParticleControllerInfluencer.Single.class),
+						new InfluencerWrapper("Random Particle Controller", ParticleControllerInfluencer.Random.class),
+						new InfluencerWrapper("Scale", ScaleInfluencer.class),
+						new InfluencerWrapper("Spawn", SpawnInfluencer.class),
+						new InfluencerWrapper("Dynamics", DynamicsInfluencer.class)});
+
+		public String desc;
+		public InfluencerWrapper[] wrappers;
+		private ControllerType(String desc, InfluencerWrapper[] wrappers){
+			this.desc = desc;
+			this.wrappers = wrappers;
+		}
+	}
+	
+	LwjglCanvas lwjglCanvas;
+	JPanel controllerPropertiesPanel;
+	JPanel editorPropertiesPanel;
+	EffectPanel effectPanel;
+	JSplitPane splitPane;
+	NumericValue fovValue;
+	NumericValue deltaMultiplier;
+	GradientColorValue backgroundColor;
+	AppRenderer renderer;
+	AssetManager assetManager;
+	JComboBox influencerBox;
+	
+	private ParticleEffect effect;
+	/** READ only */
+	public Array<ControllerData> controllersData;
+	ParticleSystem particleSystem;
+
+	public FlameMain () {
+		super("Flame");
+		MathUtils.random = new RandomXS128();
+		particleSystem = ParticleSystem.get();
+		effect = new ParticleEffect();
+		particleSystem.add(effect);
+		assetManager = new AssetManager();
+		assetManager.setErrorListener(this);
+		assetManager.setLoader(ParticleEffect.class, new ParticleEffectLoader(new InternalFileHandleResolver()));
+		controllersData = new Array<ControllerData>();
+		
+		lwjglCanvas = new LwjglCanvas(renderer = new AppRenderer());
+		addWindowListener(new WindowAdapter() {
+			public void windowClosed (WindowEvent event) {
+				//System.exit(0);
+				Gdx.app.exit();
+			}
+		});
+
+		initializeComponents();
+
+		setSize(1280, 950);
+		setLocationRelativeTo(null);
+		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
+		setVisible(true);
+	}
+	
+	public ControllerType getControllerType () {
+		ParticleController controller = getEmitter();
+		ControllerType type = null;
+		if(controller.renderer instanceof BillboardRenderer)
+			type = ControllerType.Billboard;
+		else if(controller.renderer instanceof PointSpriteRenderer)
+			type = ControllerType.PointSprite;
+		else if(controller.renderer instanceof ModelInstanceRenderer)
+			type = ControllerType.ModelInstance;
+		else if(controller.renderer instanceof ParticleControllerControllerRenderer)
+			type = ControllerType.ParticleController;	
+		return type;
+	}
+
+	void reloadRows () {
+		EventQueue.invokeLater(new Runnable() {
+			public void run () {
+				
+				//Ensure no listener is left watching for events
+				EventManager.get().clear();
+				
+				//Clear
+				editorPropertiesPanel.removeAll();
+				influencerBox.removeAllItems();
+				controllerPropertiesPanel.removeAll();
+				
+				//Editor props
+				addRow(editorPropertiesPanel, new NumericPanel(FlameMain.this, fovValue, "Field of View", ""));
+				addRow(editorPropertiesPanel, new NumericPanel(FlameMain.this, deltaMultiplier, "Delta multiplier", ""));
+				addRow(editorPropertiesPanel, new GradientPanel(FlameMain.this,backgroundColor, "Background color", "", true));
+				addRow(editorPropertiesPanel, new DrawPanel(FlameMain.this, "Draw", ""));
+				addRow(editorPropertiesPanel, new TextureLoaderPanel(FlameMain.this, "Texture", ""));
+				addRow(editorPropertiesPanel, new BillboardBatchPanel(FlameMain.this, renderer.billboardBatch), 1, 1);
+				editorPropertiesPanel.repaint();
+				
+				//Controller props
+				ParticleController controller = getEmitter();
+				if(controller != null){
+					//Reload available influencers
+					DefaultComboBoxModel model = (DefaultComboBoxModel)influencerBox.getModel();			
+					ControllerType type = getControllerType();
+					if(type != null){
+						for(Object value : type.wrappers)
+							model.addElement(value);
+					}
+					JPanel panel = null;
+					addRow(controllerPropertiesPanel, getPanel(controller.emitter));
+					for(int i=0, c = controller.influencers.size; i < c; ++i){
+						Influencer influencer = (Influencer)controller.influencers.get(i);
+						panel = getPanel(influencer);
+						if(panel != null)
+							addRow(controllerPropertiesPanel, panel, 1, i == c-1 ? 1 : 0);
+					}
+					for (Component component : controllerPropertiesPanel.getComponents())
+						if (component instanceof EditorPanel) 
+							((EditorPanel)component).update(FlameMain.this);
+				}
+				controllerPropertiesPanel.repaint();
+			}
+		});
+	}
+
+	protected JPanel getPanel (Emitter emitter) {
+		if(emitter instanceof RegularEmitter){
+			return new RegularEmitterPanel(this, (RegularEmitter) emitter);
+		}
+		return null;
+	}
+
+	protected JPanel getPanel (Influencer influencer) {
+		if(influencer instanceof ColorInfluencer.Single){
+			return new ColorInfluencerPanel(this, (ColorInfluencer.Single) influencer);
+		}
+		if(influencer instanceof ColorInfluencer.Random){
+			return new InfluencerPanel<ColorInfluencer.Random>(this, (ColorInfluencer.Random) influencer, 
+				"Random Color Influencer", "Assign a random color to the particles") {};
+		}
+		else if(influencer instanceof ScaleInfluencer){
+			return  new ScaleInfluencerPanel(this, (ScaleInfluencer)influencer);
+		}
+		else if(influencer instanceof SpawnInfluencer){
+			return  new SpawnInfluencerPanel(this, (SpawnInfluencer)influencer);
+		}
+		else if(influencer instanceof DynamicsInfluencer){
+			return  new DynamicsInfluencerPanel(this, (DynamicsInfluencer)influencer);
+		}
+		else if(influencer instanceof ModelInfluencer){
+			boolean single = influencer instanceof ModelInfluencer.Single;
+			String name = single ? "Model Single Influencer" : "Model Random Influencer";
+			return  new ModelInfluencerPanel(this, (ModelInfluencer)influencer, single, name, "Defines what model will be used for the particles");
+		}
+		else if(influencer instanceof ParticleControllerInfluencer){
+			boolean single = influencer instanceof ParticleControllerInfluencer.Single;
+			String name = single ? "Particle Controller Single Influencer" : "Particle Controller Random Influencer";
+			return  new ParticleControllerInfluencerPanel(this, (ParticleControllerInfluencer)influencer, single, name, "Defines what controller will be used for the particles");
+		}
+		else if(influencer instanceof RegionInfluencer.Single){
+			return  new RegionInfluencerPanel(this, "Billboard Single Region Influencer", 
+				"Assign the chosen region to the particles", (RegionInfluencer.Single)influencer);
+		}
+		else if(influencer instanceof RegionInfluencer.Animated){
+			return  new RegionInfluencerPanel(this, "Billboard Animated Region Influencer", 
+				"Animates the region of the particles", (RegionInfluencer.Animated)influencer);
+		}
+		else if(influencer instanceof RegionInfluencer.Random){
+			return  new RegionInfluencerPanel(this, "Billboard Random Region Influencer", 
+				"Assigns a randomly picked (among those selected) region to the particles", (RegionInfluencer.Random)influencer);
+		}
+		else if(influencer instanceof ParticleControllerFinalizerInfluencer){
+			return new InfluencerPanel<ParticleControllerFinalizerInfluencer>(this, (ParticleControllerFinalizerInfluencer) influencer, 
+				"ParticleControllerFinalizer Influencer", "This is required when dealing with a controller of controllers, it will update the controller assigned to each particle, it MUST be the last influencer always.", 
+				true, false) {};
+		}
+		
+		return null;
+	}
+
+	protected JPanel getPanel (ParticleBatch renderer) {
+		if(renderer instanceof PointSpriteParticleBatch){
+			return new EmptyPanel(this, "Point Sprite Batch", "It renders particles as point sprites.");
+		}
+		if(renderer instanceof BillboardParticleBatch){
+			return new BillboardBatchPanel(this, (BillboardParticleBatch) renderer);
+		}
+		else if(renderer instanceof ModelInstanceParticleBatch){
+			return new EmptyPanel(this, "Model Instance Batch", "It renders particles as model instances.");
+		}
+		
+		return null;
+	}
+
+	void addRow(JPanel panel, JPanel row) {
+		addRow(panel, row, 1, 0);
+	}
+	
+	void addRow(JPanel panel, JPanel row, float wx, float wy) {
+		row.setBorder(BorderFactory.createMatteBorder(0, 0, 2, 0, java.awt.Color.black));
+		panel.add(row, new GridBagConstraints(0, -1, 1, 1, wx, wy, GridBagConstraints.NORTH, GridBagConstraints.HORIZONTAL,
+			new Insets(0, 0, 0, 0), 0, 0));
+	}
+
+	public void setVisible (String name, boolean visible) {
+		for (Component component : controllerPropertiesPanel.getComponents())
+			if (component instanceof EditorPanel && ((EditorPanel)component).getName().equals(name)) component.setVisible(visible);
+	}
+
+	private void rebuildActiveControllers () {
+		//rebuild list
+		Array<ParticleController> effectControllers = effect.getControllers();
+		effectControllers.clear();
+		for(ControllerData controllerData : controllersData){
+			if(controllerData.enabled)
+				effectControllers.add(controllerData.controller);
+		}
+		//System.out.println("rebuilding active controllers");
+
+		effect.init();
+		effect.start();
+	}
+
+	public ParticleController getEmitter () {
+		return effectPanel.editIndex >=0 ? controllersData.get(effectPanel.editIndex).controller : null;
+	}
+	
+	public void addEmitter (ParticleController emitter) {
+		controllersData.add(new ControllerData(emitter));
+		rebuildActiveControllers();
+	}
+
+	public void removeEmitter (int row) {
+		controllersData.removeIndex(row).controller.dispose();
+		rebuildActiveControllers();
+	}
+        
+	public void setEnabled (int emitterIndex, boolean enabled) {
+		ControllerData data = controllersData.get(emitterIndex);
+		data.enabled = enabled;
+		rebuildActiveControllers();
+	}
+
+	public boolean isEnabled (int emitterIndex) {
+		return controllersData.get(emitterIndex).enabled;
+	}
+
+	private void initializeComponents () {
+		splitPane = new JSplitPane();
+		splitPane.setUI(new BasicSplitPaneUI() {
+			public void paint (Graphics g, JComponent jc) {
+			}
+		});
+		splitPane.setDividerSize(4);
+		getContentPane().add(splitPane, BorderLayout.CENTER);
+		{
+			JSplitPane rightSplit = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
+			rightSplit.setUI(new BasicSplitPaneUI() {
+				public void paint (Graphics g, JComponent jc) {
+				}
+			});
+			rightSplit.setDividerSize(4);
+			splitPane.add(rightSplit, JSplitPane.RIGHT);
+
+			{
+				JPanel propertiesPanel = new JPanel(new GridBagLayout());
+				rightSplit.add(propertiesPanel, JSplitPane.TOP);
+				propertiesPanel.setBorder(new CompoundBorder(BorderFactory.createEmptyBorder(3, 0, 6, 6), BorderFactory
+					.createTitledBorder("Editor Properties")));
+				{
+					JScrollPane scroll = new JScrollPane();
+					propertiesPanel.add(scroll, new GridBagConstraints(0, 0, 1, 1, 1, 1, GridBagConstraints.NORTH,
+						GridBagConstraints.BOTH, new Insets(0, 0, 0, 0), 0, 0));
+					scroll.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
+					{
+						editorPropertiesPanel = new JPanel(new GridBagLayout());
+						scroll.setViewportView(editorPropertiesPanel);
+						scroll.getVerticalScrollBar().setUnitIncrement(70);
+					}
+				}
+			}
+
+			{	
+				JSplitPane rightSplitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
+				rightSplitPane.setUI(new BasicSplitPaneUI() {
+					public void paint (Graphics g, JComponent jc) {
+					}
+				});
+				rightSplitPane.setDividerSize(4);
+				rightSplitPane.setDividerLocation(100);
+				rightSplit.add(rightSplitPane, JSplitPane.BOTTOM);
+
+				JPanel propertiesPanel = new JPanel(new GridBagLayout());
+				rightSplitPane.add(propertiesPanel, JSplitPane.TOP);
+				propertiesPanel.setBorder(new CompoundBorder(BorderFactory.createEmptyBorder(3, 0, 6, 6), BorderFactory
+					.createTitledBorder("Influencers")));
+				{
+					JScrollPane scroll = new JScrollPane();
+					propertiesPanel.add(scroll, new GridBagConstraints(0, 0, 1, 1, 1, 1, GridBagConstraints.NORTH,
+						GridBagConstraints.BOTH, new Insets(0, 0, 0, 0), 0, 0));
+					scroll.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
+					{
+						JPanel influencersPanel = new JPanel(new GridBagLayout());
+						influencerBox = new JComboBox(new DefaultComboBoxModel());
+						JButton addInfluencerButton = new JButton("Add");
+						addInfluencerButton.addActionListener(new ActionListener() {
+							@Override
+							public void actionPerformed (ActionEvent e) {
+								InfluencerWrapper wrapper = (InfluencerWrapper)influencerBox.getSelectedItem();
+								ParticleController controller = getEmitter();
+								if(controller != null)
+									addInfluencer(wrapper.type, controller);
+
+							}
+						});
+						influencersPanel.add(influencerBox, new GridBagConstraints(0, 0, 1, 1, 0, 1, GridBagConstraints.NORTHWEST,
+							GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));
+						influencersPanel.add(addInfluencerButton, new GridBagConstraints(1, 0, 1, 1, 1, 1, GridBagConstraints.NORTHWEST,
+							GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));
+						scroll.setViewportView(influencersPanel);
+						scroll.getVerticalScrollBar().setUnitIncrement(70);
+					}
+				}
+				
+
+				propertiesPanel = new JPanel(new GridBagLayout());
+				rightSplitPane.add(propertiesPanel, JSplitPane.BOTTOM);
+				propertiesPanel.setBorder(new CompoundBorder(BorderFactory.createEmptyBorder(3, 0, 6, 6), BorderFactory
+					.createTitledBorder("Particle Controller Components")));
+				{
+					JScrollPane scroll = new JScrollPane();
+					propertiesPanel.add(scroll, new GridBagConstraints(0, 0, 1, 1, 1, 1, GridBagConstraints.NORTH,
+						GridBagConstraints.BOTH, new Insets(0, 0, 0, 0), 0, 0));
+					scroll.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
+					{
+						controllerPropertiesPanel = new JPanel(new GridBagLayout());
+						scroll.setViewportView(controllerPropertiesPanel);
+						scroll.getVerticalScrollBar().setUnitIncrement(70);
+					}
+				}
+			}
+			
+			rightSplit.setDividerLocation(250);
+
+		}
+		{
+			JSplitPane leftSplit = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
+			leftSplit.setUI(new BasicSplitPaneUI() {
+				public void paint (Graphics g, JComponent jc) {
+				}
+			});
+			leftSplit.setDividerSize(4);
+			splitPane.add(leftSplit, JSplitPane.LEFT);
+			{
+				JPanel spacer = new JPanel(new BorderLayout());
+				leftSplit.add(spacer, JSplitPane.TOP);
+				spacer.add(lwjglCanvas.getCanvas());
+				spacer.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 4));
+			}
+			{
+				JPanel emittersPanel = new JPanel(new BorderLayout());
+				leftSplit.add(emittersPanel, JSplitPane.BOTTOM);
+				emittersPanel.setBorder(new CompoundBorder(BorderFactory.createEmptyBorder(0, 6, 6, 0), BorderFactory
+					.createTitledBorder("Particle Controllers")));
+				{
+					effectPanel = new EffectPanel(this);
+					emittersPanel.add(effectPanel);
+				}
+			}
+			leftSplit.setDividerLocation(625);
+		}
+		splitPane.setDividerLocation(500);
+	}
+
+	protected void addInfluencer (Class<Influencer> type, ParticleController controller) {
+		if(controller.findInfluencer(type) != null) return;
+
+		try {
+			controller.end();
+			
+			Influencer newInfluencer = type.newInstance();
+			boolean replaced = false;
+			if(ColorInfluencer.class.isAssignableFrom(type)){
+				 replaced = controller.replaceInfluencer(ColorInfluencer.class, (ColorInfluencer)newInfluencer);
+			}
+			else if(RegionInfluencer.class.isAssignableFrom(type)){
+				 replaced = controller.replaceInfluencer(RegionInfluencer.class, (RegionInfluencer)newInfluencer);
+			}
+			else if(ModelInfluencer.class.isAssignableFrom(type)){
+				ModelInfluencer newModelInfluencer = (ModelInfluencer) newInfluencer;
+				ModelInfluencer currentInfluencer = (ModelInfluencer)controller.findInfluencer(ModelInfluencer.class);
+				if(currentInfluencer != null){
+						newModelInfluencer.models.add(currentInfluencer.models.first());
+				}
+				replaced = controller.replaceInfluencer(ModelInfluencer.class, (ModelInfluencer)newInfluencer);
+			}
+			else if(ParticleControllerInfluencer.class.isAssignableFrom(type)){		
+				ParticleControllerInfluencer newModelInfluencer = (ParticleControllerInfluencer) newInfluencer;
+				ParticleControllerInfluencer currentInfluencer = (ParticleControllerInfluencer)controller.findInfluencer(ParticleControllerInfluencer.class);
+				if(currentInfluencer != null){
+						newModelInfluencer.templates.add(currentInfluencer.templates.first());
+				}
+				replaced = controller.replaceInfluencer(ParticleControllerInfluencer.class, (ParticleControllerInfluencer)newInfluencer);
+			}
+			
+			if(!replaced){
+				if(getControllerType() != ControllerType.ParticleController)
+					controller.influencers.add(newInfluencer);
+				else{
+					Influencer finalizer = controller.influencers.pop();
+					controller.influencers.add(newInfluencer);
+					controller.influencers.add(finalizer);
+				}
+			}
+
+			controller.init();
+			effect.start();
+			reloadRows();
+		} catch (Exception e1) {
+			e1.printStackTrace();
+		}
+	}
+
+	protected boolean canAddInfluencer (Class influencerType, ParticleController controller) {
+		boolean hasSameInfluencer = controller.findInfluencer(influencerType) != null;
+		if(!hasSameInfluencer){
+			if( 	(ColorInfluencer.Single.class.isAssignableFrom(influencerType) && controller.findInfluencer(ColorInfluencer.Random.class) != null) ||
+					(ColorInfluencer.Random.class.isAssignableFrom(influencerType) && controller.findInfluencer(ColorInfluencer.Single.class) != null) ){
+				return false;
+			}
+			
+			if(RegionInfluencer.class.isAssignableFrom(influencerType)){
+				return controller.findInfluencer(RegionInfluencer.class) == null;
+			}
+			else if(ModelInfluencer.class.isAssignableFrom(influencerType)){
+				return controller.findInfluencer(ModelInfluencer.class) == null;
+			}
+			else if(ParticleControllerInfluencer.class.isAssignableFrom(influencerType)){
+				return controller.findInfluencer(ParticleControllerInfluencer.class) == null;
+			}
+		}
+		return !hasSameInfluencer;
+	}
+
+	class AppRenderer implements ApplicationListener {
+		//Stats
+		private float maxActiveTimer;
+		private int maxActive, lastMaxActive;
+		boolean isUpdate = true;
+		
+		//Controls
+		private CameraInputController cameraInputController;
+		
+		//UI
+		private Stage ui;
+		TextButton playPauseButton;
+		private Label fpsLabel, pointCountLabel, billboardCountLabel, modelInstanceCountLabel, maxLabel;
+		StringBuilder stringBuilder;
+		
+		//Render
+		public PerspectiveCamera worldCamera;
+		private boolean isDrawXYZ, isDrawXZPlane, isDrawXYPlane;
+		private Array<Model> models;
+		private ModelInstance xyzInstance, xzPlaneInstance, xyPlaneInstance;
+		private Environment environment;
+		private ModelBatch modelBatch;
+		PointSpriteParticleBatch pointSpriteBatch;
+		BillboardParticleBatch billboardBatch;
+		ModelInstanceParticleBatch modelInstanceParticleBatch;
+		
+		public void create () {
+			if (ui != null) return;
+			int w = Gdx.graphics.getWidth(), h = Gdx.graphics.getHeight();
+			modelBatch = new ModelBatch();
+			environment = new Environment();
+			environment.add(new DirectionalLight().set(Color.WHITE, 0,0,-1));
+			
+			worldCamera = new PerspectiveCamera(67, w, h);
+			worldCamera.position.set(10, 10, 10);
+			worldCamera.lookAt(0,0,0);
+			worldCamera.near = 0.1f;
+			worldCamera.far = 300f;
+			worldCamera.update();
+
+			cameraInputController = new CameraInputController(worldCamera);
+
+			//Batches
+			pointSpriteBatch = new PointSpriteParticleBatch();
+			pointSpriteBatch.setCamera(worldCamera);
+			
+			billboardBatch = new BillboardParticleBatch();
+			billboardBatch.setCamera(worldCamera);
+			modelInstanceParticleBatch = new ModelInstanceParticleBatch();
+			
+			particleSystem.add(billboardBatch);
+			particleSystem.add(pointSpriteBatch);
+			particleSystem.add(modelInstanceParticleBatch);
+			
+			fovValue = new NumericValue();
+			fovValue.setValue(67);
+			fovValue.setActive(true);
+
+			deltaMultiplier = new NumericValue();
+			deltaMultiplier.setValue(1.0f);
+			deltaMultiplier.setActive(true);
+
+			backgroundColor = new GradientColorValue();
+			Color color = Color.valueOf("878787");
+			backgroundColor.setColors(new float[] { color.r, color.g, color.b});
+
+			models = new Array<Model>();
+			ModelBuilder builder = new ModelBuilder();
+			Model 	xyzModel = builder.createXYZCoordinates(10, new Material(), Usage.Position|Usage.ColorPacked),
+				planeModel = builder.createLineGrid(10, 10, 1, 1, new Material(ColorAttribute.createDiffuse(Color.WHITE)), Usage.Position);
+			models.add(xyzModel);
+			models.add(planeModel);
+			xyzInstance = new ModelInstance(xyzModel);
+			xzPlaneInstance = new ModelInstance(planeModel);
+			xyPlaneInstance = new ModelInstance(planeModel);
+			xyPlaneInstance.transform.rotate(1f, 0f, 0f, 90f);
+
+			setDrawXYZ(true);
+			setDrawXZPlane(true);
+
+
+			//Load default resources
+			ParticleEffectLoader.ParticleEffectLoadParameter params = new ParticleEffectLoader.ParticleEffectLoadParameter(particleSystem.getBatches());
+			assetManager.load(DEFAULT_BILLBOARD_PARTICLE, Texture.class);
+			assetManager.load(DEFAULT_MODEL_PARTICLE, Model.class);
+			assetManager.load(DEFAULT_SKIN, Skin.class);
+			assetManager.load(DEFAULT_TEMPLATE_PFX, ParticleEffect.class, params);
+			
+			assetManager.finishLoading();
+			assetManager.setLoader(ParticleEffect.class, new ParticleEffectLoader(new AbsoluteFileHandleResolver()));
+			assetManager.get(DEFAULT_MODEL_PARTICLE, Model.class).materials.get(0).set(new BlendingAttribute(GL20.GL_ONE, GL20.GL_ONE_MINUS_SRC_ALPHA, 1));
+			
+			//Ui
+			stringBuilder = new StringBuilder();
+			Skin skin = assetManager.get(DEFAULT_SKIN, Skin.class);
+			ui = new Stage();
+			fpsLabel = new Label("", skin);
+			pointCountLabel = new Label("", skin);
+			billboardCountLabel = new Label("", skin);
+			modelInstanceCountLabel = new Label("", skin);
+			
+			maxLabel = new Label("", skin);
+			playPauseButton = new TextButton("Pause", skin);
+			playPauseButton.addListener(new ClickListener(){
+				@Override
+				public void clicked (InputEvent event, float x, float y) {
+					isUpdate = !isUpdate;
+					playPauseButton.setText(isUpdate ? "Pause" : "Play");
+				}
+			});
+			Table table = new Table(skin);
+			table.setFillParent(true);
+			table.pad(5);
+			table.add(fpsLabel).expandX().left().row();
+			table.add(pointCountLabel).expandX().left().row();
+			table.add(billboardCountLabel).expandX().left().row();
+			table.add(modelInstanceCountLabel).expandX().left().row();
+			table.add(maxLabel).expandX().left().row();
+			table.add(playPauseButton).expand().bottom().left().row();
+			ui.addActor(table);
+			
+			setTexture((Texture)assetManager.get(DEFAULT_BILLBOARD_PARTICLE));
+			effectPanel.createDefaultEmitter(ControllerType.Billboard, true, true);
+		}
+
+		@Override
+		public void resize (int width, int height) {
+			Gdx.input.setInputProcessor(new InputMultiplexer(ui, cameraInputController));
+			Gdx.gl.glViewport(0, 0, width, height);
+
+			worldCamera.viewportWidth = width;
+			worldCamera.viewportHeight = height;
+			worldCamera.update();
+			ui.getViewport().setWorldSize(width, height);
+			ui.getViewport().update(width, height, true);
+		}
+
+		public void render () {
+			//float delta = Math.max(0, Gdx.graphics.getDeltaTime() * deltaMultiplier.getValue());
+			update();
+			renderWorld();
+		}
+
+		private void update () {
+			worldCamera.fieldOfView = fovValue.getValue();
+			worldCamera.update();
+			cameraInputController.update();
+			if(isUpdate){
+				particleSystem.update();
+				//Update ui
+				stringBuilder.delete(0, stringBuilder.length);
+				stringBuilder.append("Point Sprites : ").append(pointSpriteBatch.getBufferedCount());
+				pointCountLabel.setText(stringBuilder);
+				stringBuilder.delete(0, stringBuilder.length);
+				stringBuilder.append("Billboards : ").append(billboardBatch.getBufferedCount());
+				billboardCountLabel.setText(stringBuilder);
+				stringBuilder.delete(0, stringBuilder.length);
+				stringBuilder.append("Model Instances : ").append(modelInstanceParticleBatch.getBufferedCount());
+				modelInstanceCountLabel.setText(stringBuilder);	
+			}
+			stringBuilder.delete(0, stringBuilder.length);
+			stringBuilder.append("FPS : ").append(Gdx.graphics.getFramesPerSecond());
+			fpsLabel.setText(stringBuilder);
+			ui.act(Gdx.graphics.getDeltaTime());
+		}
+
+		private void renderWorld () {
+			float[] colors = backgroundColor.getColors();
+			Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT | GL20.GL_DEPTH_BUFFER_BIT);
+			Gdx.gl.glClearColor(colors[0], colors[1], colors[2], 0);
+			modelBatch.begin(worldCamera);
+			if(isDrawXYZ) modelBatch.render(xyzInstance);
+			if(isDrawXZPlane) modelBatch.render(xzPlaneInstance);
+			if(isDrawXYPlane) modelBatch.render(xyPlaneInstance);
+			particleSystem.begin();
+			particleSystem.draw();
+			particleSystem.end();
+			
+			//Draw
+			modelBatch.render(particleSystem, environment);
+			modelBatch.end();
+			ui.draw();
+		}
+
+		@Override
+		public void dispose () {}
+
+		@Override
+		public void pause () {}
+
+		@Override
+		public void resume () {}
+		
+		public void setDrawXYZ(boolean isDraw) 
+		{
+			isDrawXYZ = isDraw;
+		}
+
+		public boolean IsDrawXYZ() 
+		{
+			return isDrawXYZ;
+		}
+
+		public void setDrawXZPlane(boolean isDraw) 
+		{
+			isDrawXZPlane = isDraw;
+		}
+
+		public boolean IsDrawXZPlane() 
+		{
+			return isDrawXZPlane;
+		}
+		
+		public void setDrawXYPlane(boolean isDraw) 
+		{
+			isDrawXYPlane = isDraw;
+		}
+
+		public boolean IsDrawXYPlane() 
+		{
+			return isDrawXYPlane;
+		}
+	}
+
+	public static void main (String[] args) {
+		for (LookAndFeelInfo info : UIManager.getInstalledLookAndFeels()) {
+			if ("Nimbus".equals(info.getName())) {
+				try {
+					UIManager.setLookAndFeel(info.getClassName());
+				} catch (Throwable ignored) {
+				}
+				break;
+			}
+		}
+		EventQueue.invokeLater(new Runnable() {
+			public void run () {
+				new FlameMain();
+			}
+		});
+	}
+
+	public AppRenderer getRenderer() {
+		return renderer;
+	}
+
+	String lastDir;
+	public File showFileLoadDialog () {
+		return showFileDialog("Open", FileDialog.LOAD);
+	}
+	
+	public File showFileSaveDialog () {
+		return showFileDialog("Save", FileDialog.SAVE);
+	}
+	
+	private File showFileDialog (String title, int mode ) {
+		FileDialog dialog = new FileDialog(this, title, mode);
+		if (lastDir != null) dialog.setDirectory(lastDir);
+		dialog.setVisible(true);
+		final String file = dialog.getFile();
+		final String dir = dialog.getDirectory();
+		if (dir == null || file == null || file.trim().length() == 0) 
+			return null;
+		lastDir = dir;
+		return new File(dir, file);
+	}
+	
+	@Override
+	public void error (AssetDescriptor asset, Throwable throwable) {
+		throwable.printStackTrace();
+	}
+
+	public PointSpriteParticleBatch getPointSpriteBatch () {
+		return renderer.pointSpriteBatch;
+	}
+
+	public BillboardParticleBatch getBillboardBatch () {
+		return renderer.billboardBatch;
+	}
+
+	public ModelInstanceParticleBatch getModelInstanceParticleBatch () {
+		return renderer.modelInstanceParticleBatch;
+	}
+	
+	public void setAtlas(TextureAtlas atlas){
+		//currentAtlas = atlas;
+		setTexture(atlas.getTextures().first());
+	}
+	
+	public void setTexture(Texture texture){
+		renderer.billboardBatch.setTexture(texture);
+		renderer.pointSpriteBatch.setTexture(texture);
+	}
+	
+	public Texture getTexture(){
+		return renderer.billboardBatch.getTexture();
+	}
+
+	public TextureAtlas getAtlas(Texture texture){
+		Array<TextureAtlas> atlases = assetManager.getAll(TextureAtlas.class, new Array<TextureAtlas>());
+		for(TextureAtlas atlas : atlases){
+			if(atlas.getTextures().contains(texture))
+				return atlas;
+		}
+		return null;
+	}
+	
+	public TextureAtlas getAtlas(){
+		return getAtlas(renderer.billboardBatch.getTexture());
+	}
+	
+	public boolean isUsingDefaultTexture () {
+		return renderer.billboardBatch.getTexture() == assetManager.get(DEFAULT_BILLBOARD_PARTICLE, Texture.class);
+	}
+
+	public Array<ParticleEffect> getParticleEffects (Array<ParticleController> controllers, Array<ParticleEffect> out) {
+		out.clear();
+		assetManager.getAll(ParticleEffect.class, out);
+		for(int i=0; i < out.size;){
+			ParticleEffect effect = out.get(i);
+			Array<ParticleController> effectControllers = effect.getControllers();
+			boolean remove = true;
+			for(ParticleController controller : controllers){
+				if(effectControllers.contains(controller, true)){
+					remove = false;
+					break;
+				}
+			}
+			
+			if(remove){
+				out.removeIndex(i);
+				continue;
+			}
+			
+			++i;
+		}
+		
+		return out;
+	}
+
+	public void saveEffect (File file) {
+		Writer fileWriter = null;
+		try {
+			ParticleEffectLoader loader = (ParticleEffectLoader)assetManager.getLoader(ParticleEffect.class);
+			loader.save(effect, new ParticleEffectSaveParameter(new FileHandle(file.getAbsolutePath()), assetManager, particleSystem.getBatches()));
+		} catch (Exception ex) {
+			System.out.println("Error saving effect: " + file.getAbsolutePath());
+			ex.printStackTrace();
+			JOptionPane.showMessageDialog(this, "Error saving effect.");
+		} finally {
+			StreamUtils.closeQuietly(fileWriter);
+		}
+	}
+
+	public ParticleEffect openEffect (File file, boolean replaceCurrentWorkspace) {
+		try {
+			ParticleEffect loadedEffect = load(file.getAbsolutePath(), ParticleEffect.class, null, 
+				new ParticleEffectLoader.ParticleEffectLoadParameter(particleSystem.getBatches()));
+			loadedEffect = loadedEffect.copy();
+			loadedEffect.init();
+			if(replaceCurrentWorkspace){
+				effect = loadedEffect;
+				controllersData.clear();
+				particleSystem.removeAll();
+				particleSystem.add(effect);
+				for(ParticleController controller : effect.getControllers())
+					controllersData.add(new ControllerData(controller));
+				rebuildActiveControllers();
+			}
+			reloadRows();
+			return loadedEffect;
+		} catch (Exception ex) {
+			System.out.println("Error loading effect: " + file.getAbsolutePath());
+			ex.printStackTrace();
+			JOptionPane.showMessageDialog(this, "Error opening effect.");
+		}
+		return null;
+	}
+	
+	public <T> T load (String resource, Class<T> type, AssetLoader loader, AssetLoaderParameters<T> params) {	
+		String resolvedPath = new String(resource).replaceAll("\\\\", "/");
+		boolean exist = assetManager.isLoaded(resolvedPath, type);
+		T oldAsset = null;
+		if(exist){
+			oldAsset = assetManager.get(resolvedPath, type);
+			for(int i=assetManager.getReferenceCount(resolvedPath); i > 0; --i)
+				assetManager.unload(resolvedPath);
+		}
+		
+		AssetLoader<T, AssetLoaderParameters<T>> currentLoader = assetManager.getLoader(type);
+		if(loader != null)
+			assetManager.setLoader(type, loader); 
+
+		assetManager.load(resource, type, params);
+		assetManager.finishLoading();
+		T res = assetManager.get(resolvedPath);
+		if(currentLoader != null)
+			assetManager.setLoader(type, currentLoader);
+		
+		if(exist)
+			EventManager.get().fire(EVT_ASSET_RELOADED, new Object[]{oldAsset, res});
+		
+		return res;
+	}
+
+	public void restart () {
+		effect.init();
+		effect.start();
+	}
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/GradientPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/GradientPanel.java
new file mode 100644
index 0000000..c007f91
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/GradientPanel.java
@@ -0,0 +1,395 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.tools.flame;
+import java.awt.Color;
+import java.awt.Dimension;
+import java.awt.GradientPaint;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.GridBagConstraints;
+import java.awt.GridBagLayout;
+import java.awt.Insets;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseMotionAdapter;
+import java.util.ArrayList;
+
+import javax.swing.BorderFactory;
+import javax.swing.JColorChooser;
+import javax.swing.JPanel;
+import javax.swing.JSlider;
+import javax.swing.event.ChangeEvent;
+import javax.swing.event.ChangeListener;
+
+import com.badlogic.gdx.graphics.g3d.particles.values.GradientColorValue;
+
+/** @author Inferno */
+class GradientPanel extends ParticleValuePanel<GradientColorValue> {
+	private GradientEditor gradientEditor;
+	ColorSlider saturationSlider, lightnessSlider;
+	JPanel colorPanel;
+	private ColorSlider hueSlider;
+
+	public GradientPanel (FlameMain editor, GradientColorValue value, String name, String description, 
+																boolean hideGradientEditor) {
+		super(editor, name, description);
+		setValue(value);
+
+		if (hideGradientEditor) {
+			gradientEditor.setVisible(false);
+		}
+		gradientEditor.percentages.clear();
+		for (float percent : value.getTimeline())
+			gradientEditor.percentages.add(percent);
+
+		gradientEditor.colors.clear();
+		float[] colors = value.getColors();
+		for (int i = 0; i < colors.length;) {
+			float r = colors[i++];
+			float g = colors[i++];
+			float b = colors[i++];
+			gradientEditor.colors.add(new Color(r, g, b));
+		}
+		if (gradientEditor.colors.isEmpty() || gradientEditor.percentages.isEmpty()) {
+			gradientEditor.percentages.clear();
+			gradientEditor.percentages.add(0f);
+			gradientEditor.percentages.add(1f);
+			gradientEditor.colors.clear();
+			gradientEditor.colors.add(Color.white);
+		}
+		setColor(gradientEditor.colors.get(0));
+	}
+
+	public Dimension getPreferredSize () {
+		Dimension size = super.getPreferredSize();
+		size.width = 10;
+		return size;
+	}
+
+	protected void initializeComponents () {
+		super.initializeComponents();
+		JPanel contentPanel = getContentPanel();
+		{
+			gradientEditor = new GradientEditor() {
+				public void handleSelected (Color color) {
+					GradientPanel.this.setColor(color);
+				}
+			};
+			contentPanel.add(gradientEditor, new GridBagConstraints(0, 1, 3, 1, 1.0, 0.0, GridBagConstraints.CENTER,
+				GridBagConstraints.HORIZONTAL, new Insets(0, 0, 6, 0), 0, 10));
+		}
+		{
+			hueSlider = new ColorSlider(new Color[] {Color.red, Color.yellow, Color.green, Color.cyan, Color.blue, Color.magenta,
+				Color.red}) {
+				protected void colorPicked () {
+					saturationSlider.setColors(new Color[] {new Color(Color.HSBtoRGB(getPercentage(), 1, 1)), Color.white});
+					updateColor();
+				}
+			};
+			contentPanel.add(hueSlider, new GridBagConstraints(1, 2, 2, 1, 1.0, 0.0, GridBagConstraints.CENTER,
+				GridBagConstraints.HORIZONTAL, new Insets(0, 0, 6, 0), 0, 0));
+		}
+		{
+			saturationSlider = new ColorSlider(new Color[] {Color.red, Color.white}) {
+				protected void colorPicked () {
+					updateColor();
+				}
+			};
+			contentPanel.add(saturationSlider, new GridBagConstraints(1, 3, 1, 1, 1.0, 0.0, GridBagConstraints.CENTER,
+				GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 6), 0, 0));
+		}
+		{
+			lightnessSlider = new ColorSlider(new Color[0]) {
+				protected void colorPicked () {
+					updateColor();
+				}
+			};
+			contentPanel.add(lightnessSlider, new GridBagConstraints(2, 3, 1, 1, 1, 0.0, GridBagConstraints.CENTER,
+				GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0), 0, 0));
+		}
+		{
+			colorPanel = new JPanel() {
+				public Dimension getPreferredSize () {
+					Dimension size = super.getPreferredSize();
+					size.width = 52;
+					return size;
+				}
+			};
+			contentPanel.add(colorPanel, new GridBagConstraints(0, 2, 1, 2, 0.0, 0.0, GridBagConstraints.CENTER,
+				GridBagConstraints.BOTH, new Insets(3, 0, 0, 6), 0, 0));
+		}
+
+		colorPanel.addMouseListener(new MouseAdapter() {
+			public void mouseClicked (MouseEvent e) {
+				Color color = JColorChooser.showDialog(colorPanel, "Set Color", colorPanel.getBackground());
+				if (color != null) setColor(color);
+			}
+		});
+		colorPanel.setBorder(BorderFactory.createMatteBorder(1, 1, 1, 1, Color.black));
+	}
+
+	public void setColor (Color color) {
+		float[] hsb = Color.RGBtoHSB(color.getRed(), color.getGreen(), color.getBlue(), null);
+		hueSlider.setPercentage(hsb[0]);
+		saturationSlider.setPercentage(1 - hsb[1]);
+		lightnessSlider.setPercentage(1 - hsb[2]);
+		colorPanel.setBackground(color);
+	}
+
+	void updateColor () {
+		Color color = new Color(Color.HSBtoRGB(hueSlider.getPercentage(), 1 - saturationSlider.getPercentage(), 1));
+		lightnessSlider.setColors(new Color[] {color, Color.black});
+		color = new Color(Color.HSBtoRGB(hueSlider.getPercentage(), 1 - saturationSlider.getPercentage(),
+			1 - lightnessSlider.getPercentage()));
+		colorPanel.setBackground(color);
+		gradientEditor.setColor(color);
+
+		float[] colors = new float[gradientEditor.colors.size() * 3];
+		int i = 0;
+		for (Color c : gradientEditor.colors) {
+			colors[i++] = c.getRed() / 255f;
+			colors[i++] = c.getGreen() / 255f;
+			colors[i++] = c.getBlue() / 255f;
+		}
+		float[] percentages = new float[gradientEditor.percentages.size()];
+		i = 0;
+		for (Float percent : gradientEditor.percentages)
+			percentages[i++] = percent;
+		value.setColors(colors);
+		value.setTimeline(percentages);
+	}
+
+	public class GradientEditor extends JPanel {
+		ArrayList<Color> colors = new ArrayList();
+		ArrayList<Float> percentages = new ArrayList();
+
+		int handleWidth = 12;
+		int handleHeight = 12;
+		int gradientX = handleWidth / 2;
+		int gradientY = 0;
+		int gradientWidth;
+		int gradientHeight;
+		int dragIndex = -1;
+		int selectedIndex;
+
+		public GradientEditor () {
+			setPreferredSize(new Dimension(100, 30));
+
+			addMouseListener(new MouseAdapter() {
+				public void mousePressed (MouseEvent event) {
+					dragIndex = -1;
+					int mouseX = event.getX();
+					int mouseY = event.getY();
+					int y = gradientY + gradientHeight;
+					for (int i = 0, n = colors.size(); i < n; i++) {
+						int x = gradientX + (int)(percentages.get(i) * gradientWidth) - handleWidth / 2;
+						if (mouseX >= x && mouseX <= x + handleWidth && mouseY >= gradientY && mouseY <= y + handleHeight) {
+							dragIndex = selectedIndex = i;
+							handleSelected(colors.get(selectedIndex));
+							repaint();
+							break;
+						}
+					}
+				}
+
+				public void mouseReleased (MouseEvent event) {
+					if (dragIndex != -1) {
+						dragIndex = -1;
+						repaint();
+					}
+				}
+
+				public void mouseClicked (MouseEvent event) {
+					int mouseX = event.getX();
+					int mouseY = event.getY();
+					if (event.getClickCount() == 2) {
+						if (percentages.size() <= 1) return;
+						if (selectedIndex == -1 || selectedIndex == 0) return;
+						int y = gradientY + gradientHeight;
+						int x = gradientX + (int)(percentages.get(selectedIndex) * gradientWidth) - handleWidth / 2;
+						if (mouseX >= x && mouseX <= x + handleWidth && mouseY >= gradientY && mouseY <= y + handleHeight) {
+							percentages.remove(selectedIndex);
+							colors.remove(selectedIndex);
+							selectedIndex--;
+							dragIndex = selectedIndex;
+							if (percentages.size() == 2) percentages.set(1, 1f);
+							handleSelected(colors.get(selectedIndex));
+							repaint();
+						}
+						return;
+					}
+					if (mouseX < gradientX || mouseX > gradientX + gradientWidth) return;
+					if (mouseY < gradientY || mouseY > gradientY + gradientHeight) return;
+					float percent = (event.getX() - gradientX) / (float)gradientWidth;
+					if (percentages.size() == 1) percent = 1f;
+					for (int i = 0, n = percentages.size(); i <= n; i++) {
+						if (i == n || percent < percentages.get(i)) {
+							percentages.add(i, percent);
+							colors.add(i, colors.get(i - 1));
+							dragIndex = selectedIndex = i;
+							handleSelected(colors.get(selectedIndex));
+							repaint();
+							break;
+						}
+					}
+				}
+			});
+			addMouseMotionListener(new MouseMotionAdapter() {
+				public void mouseDragged (MouseEvent event) {
+					if (dragIndex == -1 || dragIndex == 0 || dragIndex == percentages.size() - 1) return;
+					float percent = (event.getX() - gradientX) / (float)gradientWidth;
+					percent = Math.max(percent, percentages.get(dragIndex - 1) + 0.01f);
+					percent = Math.min(percent, percentages.get(dragIndex + 1) - 0.01f);
+					percentages.set(dragIndex, percent);
+					repaint();
+				}
+			});
+		}
+
+		public void setColor (Color color) {
+			if (selectedIndex == -1) return;
+			colors.set(selectedIndex, color);
+			repaint();
+		}
+
+		public void handleSelected (Color color) {
+		}
+
+		protected void paintComponent (Graphics graphics) {
+			super.paintComponent(graphics);
+			Graphics2D g = (Graphics2D)graphics;
+			int width = getWidth() - 1;
+			int height = getHeight();
+
+			gradientWidth = width - handleWidth;
+			gradientHeight = height - 16;
+
+			g.translate(gradientX, gradientY);
+			for (int i = 0, n = colors.size() == 1 ? 1 : colors.size() - 1; i < n; i++) {
+				Color color1 = colors.get(i);
+				Color color2 = colors.size() == 1 ? color1 : colors.get(i + 1);
+				float percent1 = percentages.get(i);
+				float percent2 = colors.size() == 1 ? 1 : percentages.get(i + 1);
+				int point1 = (int)(percent1 * gradientWidth);
+				int point2 = (int)Math.ceil(percent2 * gradientWidth);
+				g.setPaint(new GradientPaint(point1, 0, color1, point2, 0, color2, false));
+				g.fillRect(point1, 0, point2 - point1, gradientHeight);
+			}
+			g.setPaint(null);
+			g.setColor(Color.black);
+			g.drawRect(0, 0, gradientWidth, gradientHeight);
+
+			int y = gradientHeight;
+			int[] yPoints = new int[3];
+			yPoints[0] = y;
+			yPoints[1] = y + handleHeight;
+			yPoints[2] = y + handleHeight;
+			int[] xPoints = new int[3];
+			for (int i = 0, n = colors.size(); i < n; i++) {
+				int x = (int)(percentages.get(i) * gradientWidth);
+				xPoints[0] = x;
+				xPoints[1] = x - handleWidth / 2;
+				xPoints[2] = x + handleWidth / 2;
+				if (i == selectedIndex) {
+					g.setColor(colors.get(i));
+					g.fillPolygon(xPoints, yPoints, 3);
+					g.fillRect(xPoints[1], yPoints[1] + 2, handleWidth + 1, 2);
+					g.setColor(Color.black);
+				}
+				g.drawPolygon(xPoints, yPoints, 3);
+			}
+			g.translate(-gradientX, -gradientY);
+		}
+	}
+
+	static public class ColorSlider extends JPanel {
+		Color[] paletteColors;
+		JSlider slider;
+		private ColorPicker colorPicker;
+
+		public ColorSlider (Color[] paletteColors) {
+			this.paletteColors = paletteColors;
+			setLayout(new GridBagLayout());
+			{
+				slider = new JSlider(0, 1000, 0);
+				slider.setPaintTrack(false);
+				add(slider, new GridBagConstraints(1, 0, 1, 1, 1.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL,
+					new Insets(0, 6, 0, 6), 0, 0));
+			}
+			{
+				colorPicker = new ColorPicker();
+				add(colorPicker, new GridBagConstraints(1, 1, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER,
+					GridBagConstraints.HORIZONTAL, new Insets(0, 6, 0, 6), 0, 0));
+			}
+
+			slider.addChangeListener(new ChangeListener() {
+				public void stateChanged (ChangeEvent event) {
+					colorPicked();
+				}
+			});
+		}
+
+		public Dimension getPreferredSize () {
+			Dimension size = super.getPreferredSize();
+			size.width = 10;
+			return size;
+		}
+
+		public void setPercentage (float percent) {
+			slider.setValue((int)(1000 * percent));
+		}
+
+		public float getPercentage () {
+			return slider.getValue() / 1000f;
+		}
+
+		protected void colorPicked () {
+		}
+
+		public void setColors (Color[] colors) {
+			paletteColors = colors;
+			repaint();
+		}
+
+		public class ColorPicker extends JPanel {
+			public ColorPicker () {
+				addMouseListener(new MouseAdapter() {
+					public void mouseClicked (MouseEvent event) {
+						slider.setValue((int)(event.getX() / (float)getWidth() * 1000));
+					}
+				});
+			}
+
+			protected void paintComponent (Graphics graphics) {
+				Graphics2D g = (Graphics2D)graphics;
+				int width = getWidth() - 1;
+				int height = getHeight() - 1;
+				for (int i = 0, n = paletteColors.length - 1; i < n; i++) {
+					Color color1 = paletteColors[i];
+					Color color2 = paletteColors[i + 1];
+					float point1 = i / (float)n * width;
+					float point2 = (i + 1) / (float)n * width;
+					g.setPaint(new GradientPaint(point1, 0, color1, point2, 0, color2, false));
+					g.fillRect((int)point1, 0, (int)Math.ceil(point2 - point1), height);
+				}
+				g.setPaint(null);
+				g.setColor(Color.black);
+				g.drawRect(0, 0, width, height);
+			}
+		}
+	}
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/ImagePanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/ImagePanel.java
new file mode 100644
index 0000000..132d465
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/ImagePanel.java
@@ -0,0 +1,45 @@
+package com.badlogic.gdx.tools.flame;
+
+import java.awt.Dimension;
+import java.awt.Graphics;
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.IOException;
+
+import javax.imageio.ImageIO;
+import javax.swing.JPanel;
+
+/** @author Inferno */
+public class ImagePanel extends JPanel{
+	private BufferedImage image;
+
+	public ImagePanel() {}
+
+	public void setImage(BufferedImage image){
+		this.image = image;
+	}
+	
+	public void setImage (String file) {
+		try {
+			image = ImageIO.read( new File(file) );
+		} catch (IOException e) {
+			e.printStackTrace();
+		} 
+	}
+
+	@Override
+	protected void paintComponent(Graphics g) {
+		super.paintComponent(g);
+		g.drawImage(image, 0, 0, null); // see javadoc for more info on the parameters            
+	}
+
+	@Override
+	public Dimension getPreferredSize () {
+		Dimension dimension = super.getPreferredSize();
+		if(image != null){
+			dimension.width = image.getWidth();
+			dimension.height = image.getHeight();
+		}
+		return dimension;
+	}
+}
\ No newline at end of file
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/InfluencerPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/InfluencerPanel.java
new file mode 100644
index 0000000..445b04d
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/InfluencerPanel.java
@@ -0,0 +1,27 @@
+package com.badlogic.gdx.tools.flame;
+
+import com.badlogic.gdx.graphics.g3d.particles.influencers.Influencer;
+
+
+/** @author Inferno */
+public abstract class InfluencerPanel<T extends Influencer> extends EditorPanel<T> {
+	public InfluencerPanel (FlameMain editor, T influencer, String name, String description) {
+		super(editor, name, description, true, true);
+		setValue(influencer);
+	}
+	
+	public InfluencerPanel (FlameMain editor, T influencer, String name, String description, boolean isAlwaysActive, boolean isRemovable) {
+		super(editor, name, description, isAlwaysActive, isRemovable);
+		setValue(influencer);
+	}
+
+	@Override
+	protected void removePanel () {
+		super.removePanel();
+		editor.getEmitter().influencers.removeValue(value, true);
+		editor.getEmitter().init();
+		editor.getEmitter().start();
+		editor.reloadRows();
+	}
+
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/LoaderButton.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/LoaderButton.java
new file mode 100644
index 0000000..09ddfba
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/LoaderButton.java
@@ -0,0 +1,113 @@
+package com.badlogic.gdx.tools.flame;
+
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.io.File;
+
+import javax.swing.JButton;
+import javax.swing.JOptionPane;
+
+import com.badlogic.gdx.assets.loaders.ModelLoader;
+import com.badlogic.gdx.assets.loaders.resolvers.AbsoluteFileHandleResolver;
+import com.badlogic.gdx.graphics.g3d.Model;
+import com.badlogic.gdx.graphics.g3d.loader.G3dModelLoader;
+import com.badlogic.gdx.graphics.g3d.loader.ObjLoader;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleEffect;
+import com.badlogic.gdx.utils.JsonReader;
+import com.badlogic.gdx.utils.UBJsonReader;
+
+/** @author Inferno */
+public abstract class LoaderButton<T> extends JButton{
+
+	public static class ParticleEffectLoaderButton extends LoaderButton<ParticleEffect>{
+		public ParticleEffectLoaderButton (FlameMain editor) {
+			this(editor, null);
+		}
+		public ParticleEffectLoaderButton (FlameMain editor, Listener<ParticleEffect> listener) {
+			super(editor, "Load Controller", listener);
+		}
+		
+		protected void loadResource () {
+			File file = editor.showFileLoadDialog();
+			if(file != null){
+				try{
+					String resource = file.getAbsolutePath();
+					listener.onResourceLoaded(editor.openEffect(file, false));
+				} catch (Exception ex) {
+					System.out.println("Error loading effect: " + file.getAbsolutePath());
+					ex.printStackTrace();
+					JOptionPane.showMessageDialog(getParent(), "Error opening effect.");
+					return;
+				}
+			}
+		}
+	}
+	
+	public static class ModelLoaderButton extends LoaderButton<Model>{
+		public ModelLoaderButton (FlameMain editor) {
+			this(editor, null);
+		}
+		public ModelLoaderButton (FlameMain editor, Listener<Model> listener) {
+			super(editor, "Load Model", listener);
+		}
+		
+		protected void loadResource () {
+			File file = editor.showFileLoadDialog();
+			if(file != null){
+				try{
+					String resource = file.getAbsolutePath();
+					ModelLoader modelLoader = null;
+					if(resource.endsWith(".obj")){
+						modelLoader = new ObjLoader(new AbsoluteFileHandleResolver());
+					}
+					else if(resource.endsWith(".g3dj")){
+						modelLoader = new G3dModelLoader(new JsonReader(), new AbsoluteFileHandleResolver());
+					}
+					else if(resource.endsWith(".g3db")){
+						modelLoader = new G3dModelLoader(new UBJsonReader(), new AbsoluteFileHandleResolver());
+					}
+					else throw new Exception();
+					listener.onResourceLoaded(editor.load(resource, Model.class, modelLoader, null));
+
+				} catch (Exception ex) {
+					System.out.println("Error loading model: " + file.getAbsolutePath());
+					ex.printStackTrace();
+					JOptionPane.showMessageDialog(getParent(), "Error opening effect.");
+					return;
+				}
+			}
+		}
+	}
+	
+	public interface Listener<T>{
+		void onResourceLoaded (T resource);
+	}
+	
+	private String lastDir;
+	protected Listener<T> listener;
+	FlameMain editor;
+	
+	public LoaderButton (FlameMain editor, String text, Listener<T> listener) {
+		super(text);
+		this.editor = editor;
+		this.listener = listener;
+		addActionListener(new ActionListener() {
+			@Override
+			public void actionPerformed (ActionEvent e) {
+				loadResource();
+			}
+		});
+	}
+	
+	public LoaderButton (FlameMain editor, String text){
+		this(editor, text, null);
+	}
+	
+	public void setListener(Listener listener){
+		this.listener = listener;
+	}
+	
+
+	protected abstract void loadResource ();
+
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/ModelInfluencerPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/ModelInfluencerPanel.java
new file mode 100644
index 0000000..1e10c2d
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/ModelInfluencerPanel.java
@@ -0,0 +1,55 @@
+package com.badlogic.gdx.tools.flame;
+
+import java.awt.GridBagConstraints;
+import java.awt.Insets;
+
+import com.badlogic.gdx.graphics.g3d.Model;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.ModelInfluencer;
+
+/** @author Inferno */
+public class ModelInfluencerPanel extends InfluencerPanel<ModelInfluencer> implements TemplatePickerPanel.Listener<Model>, EventManager.Listener {
+
+	TemplatePickerPanel<Model> pickerPanel;
+	
+	public ModelInfluencerPanel (FlameMain editor, ModelInfluencer influencer, boolean single, String name, String desc) {
+		super(editor, influencer, name, desc, true, false);
+		pickerPanel.setMultipleSelectionAllowed(!single);
+		EventManager.get().attach(FlameMain.EVT_ASSET_RELOADED, this);
+	}
+	
+	@Override
+	public void setValue (ModelInfluencer value) {
+		super.setValue(value);
+		if(value == null) return;
+		pickerPanel.setValue(value.models);
+	}
+	
+	protected void initializeComponents () {
+		super.initializeComponents();
+		pickerPanel = new TemplatePickerPanel<Model>(editor, null, this, Model.class, new LoaderButton.ModelLoaderButton(editor));
+		pickerPanel.setIsAlwayShown(true);
+		contentPanel.add(pickerPanel, new GridBagConstraints(0, 0, 1, 1, 1, 1, GridBagConstraints.CENTER, GridBagConstraints.BOTH, new Insets(0,
+			0, 0, 6), 0, 0));
+	}
+
+	@Override
+	public void onTemplateChecked (Model model, boolean isChecked) {
+		editor.restart();
+	}
+
+	@Override
+	public void handle (int aEventType, Object aEventData) {
+		if(aEventType == FlameMain.EVT_ASSET_RELOADED){
+			Object[] data = (Object[])aEventData;
+			if(data[0] instanceof Model){
+				if(value.models.removeValue((Model)data[0], true)){
+					value.models.add((Model)data[1]);
+					pickerPanel.reloadTemplates();
+					pickerPanel.setValue(value.models);
+					editor.restart();
+				}
+			}
+		}
+	}
+
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/NumericPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/NumericPanel.java
new file mode 100644
index 0000000..3a0807b
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/NumericPanel.java
@@ -0,0 +1,66 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.tools.flame;
+import java.awt.GridBagConstraints;
+import java.awt.Insets;
+
+import javax.swing.JLabel;
+import javax.swing.JPanel;
+import javax.swing.JSpinner;
+import javax.swing.SpinnerNumberModel;
+import javax.swing.event.ChangeEvent;
+import javax.swing.event.ChangeListener;
+
+import com.badlogic.gdx.graphics.g3d.particles.values.NumericValue;
+
+
+/** @author Inferno */
+class NumericPanel extends ParticleValuePanel<NumericValue> {
+	JSpinner valueSpinner;
+	
+	public NumericPanel ( FlameMain editor, NumericValue value, String name, String description) {
+		super(editor, name, description);
+		setValue(value);
+	}
+	
+	@Override
+	public void setValue (NumericValue value) {
+		super.setValue(value);
+		if(value == null)return;
+		setValue(valueSpinner, value.getValue());
+	}
+
+	protected void initializeComponents () {
+		super.initializeComponents();
+		JPanel contentPanel = getContentPanel();
+		{
+			JLabel label = new JLabel("Value:");
+			contentPanel.add(label, new GridBagConstraints(0, 1, 1, 1, 0, 0, GridBagConstraints.EAST, GridBagConstraints.NONE,
+				new Insets(0, 0, 0, 6), 0, 0));
+		}
+		{
+			valueSpinner = new JSpinner(new SpinnerNumberModel(new Float(0), new Float(-99999), new Float(99999), new Float(0.1f)));
+			contentPanel.add(valueSpinner, new GridBagConstraints(1, 1, 1, 1, 1, 0, GridBagConstraints.WEST,
+				GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));
+		}
+		valueSpinner.addChangeListener(new ChangeListener() {
+			public void stateChanged (ChangeEvent event) {
+				NumericPanel.this.value.setValue((Float)valueSpinner.getValue());
+			}
+		});
+	}
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/ParticleControllerInfluencerPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/ParticleControllerInfluencerPanel.java
new file mode 100644
index 0000000..ca4428e
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/ParticleControllerInfluencerPanel.java
@@ -0,0 +1,99 @@
+package com.badlogic.gdx.tools.flame;
+
+import java.awt.GridBagConstraints;
+import java.awt.Insets;
+
+import com.badlogic.gdx.graphics.g3d.particles.ParticleController;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleEffect;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.ParticleControllerInfluencer;
+import com.badlogic.gdx.utils.Array;
+
+/** @author Inferno */
+public class ParticleControllerInfluencerPanel extends InfluencerPanel<ParticleControllerInfluencer> implements TemplatePickerPanel.Listener<ParticleController>, 
+																																									LoaderButton.Listener<ParticleEffect>, 
+																																									EventManager.Listener{
+	TemplatePickerPanel<ParticleController> controllerPicker;
+	
+	public ParticleControllerInfluencerPanel (FlameMain editor, ParticleControllerInfluencer influencer, boolean single, String name, String desc) {
+		super(editor, influencer, name, desc, true, false);
+		controllerPicker.setMultipleSelectionAllowed(!single);
+		EventManager.get().attach(FlameMain.EVT_ASSET_RELOADED, this);
+	}
+	
+	@Override
+	public void setValue (ParticleControllerInfluencer value) {
+		super.setValue(value);
+		if(value == null) return;
+		controllerPicker.setValue(value.templates);
+	}
+	
+	protected void initializeComponents () {
+		super.initializeComponents();
+		controllerPicker = new TemplatePickerPanel<ParticleController>(editor, null, this, ParticleController.class){
+			@Override
+			protected String getTemplateName (ParticleController template, int index) {
+				return template.name;
+			}
+		};
+		reloadControllers ();
+		controllerPicker.setIsAlwayShown(true);
+		
+		
+		contentPanel.add(new LoaderButton.ParticleEffectLoaderButton(editor, this), new GridBagConstraints(0, 0, 1, 1, 1, 1, GridBagConstraints.CENTER, GridBagConstraints.BOTH, new Insets(0,
+			0, 0, 6), 0, 0));
+		contentPanel.add(controllerPicker, new GridBagConstraints(0, 1, 1, 1, 1, 1, GridBagConstraints.CENTER, GridBagConstraints.BOTH, new Insets(0,
+			0, 0, 6), 0, 0));
+	}
+
+	@Override
+	public void onTemplateChecked (ParticleController model, boolean isChecked) {
+		editor.restart();
+	}
+
+	@Override
+	public void onResourceLoaded (ParticleEffect resource) {
+		reloadControllers();
+	}
+
+	private void reloadControllers () {
+		Array<ParticleEffect> effects = new Array<ParticleEffect>();
+		Array<ParticleController> controllers = new Array<ParticleController>();
+		editor.assetManager.getAll(ParticleEffect.class, effects);
+		for(ParticleEffect effect : effects){
+			controllers.addAll(effect.getControllers());
+		}
+		controllerPicker.setLoadedTemplates(controllers);
+	}
+
+	@Override
+	public void handle (int aEventType, Object aEventData) {
+		if(aEventType == FlameMain.EVT_ASSET_RELOADED){
+			Object[] data = (Object[])aEventData;
+			if(data[0] instanceof ParticleEffect){
+				ParticleEffect oldEffect = (ParticleEffect) data[0];
+				int currentCount = value.templates.size;
+				value.templates.removeAll(oldEffect.getControllers(), true);
+				if(value.templates.size != currentCount){
+					int diff = currentCount - value.templates.size;
+					if(diff > 0){
+						ParticleEffect newEffect = (ParticleEffect) data[1];
+						Array<ParticleController> newControllers = newEffect.getControllers();
+						if(newControllers.size > 0){
+							for(int i=0, c=Math.min(diff, newControllers.size); i<c; ++i)
+								value.templates.add(newControllers.get(i));
+						}
+					}
+					else {
+						value.templates.addAll( ((ParticleEffect)editor.assetManager.get(FlameMain.DEFAULT_BILLBOARD_PARTICLE)).getControllers());
+					}
+					
+					controllerPicker.reloadTemplates();
+					controllerPicker.setValue(value.templates);
+					editor.restart();
+				}
+			}
+		}
+	}
+	
+	
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/ParticleValuePanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/ParticleValuePanel.java
new file mode 100644
index 0000000..0039849
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/ParticleValuePanel.java
@@ -0,0 +1,39 @@
+package com.badlogic.gdx.tools.flame;
+
+import com.badlogic.gdx.graphics.g3d.particles.values.ParticleValue;
+
+/** @author Inferno */
+public class ParticleValuePanel<T extends ParticleValue> extends EditorPanel<T> {
+
+	public ParticleValuePanel (FlameMain editor, String name, String description) {
+		this(editor, name, description, true);
+	}
+	
+	public ParticleValuePanel (FlameMain editor, String name, String description, boolean isAlwaysActive) {
+		this(editor, name, description, isAlwaysActive, false);
+	}
+	
+	public ParticleValuePanel (FlameMain editor, String name, String description, boolean isAlwaysActive, boolean isRemovable) {
+		super(editor, name, description, isAlwaysActive, isRemovable);
+	}
+
+
+	public void setHasAdvanced (boolean hasAdvanced) {
+		super.setHasAdvanced(hasAdvanced);
+		advancedButton.setVisible(hasAdvanced && (value.isActive() || isAlwaysActive));
+	}
+	
+	@Override
+	public void setValue (T value) {
+		super.setValue(value);
+		if(value != null){
+			activeButton.setSelected(value.isActive());
+		}
+	}
+	
+	@Override
+	protected void activate () {
+		super.activate();
+		if (value != null) value.setActive(activeButton.isSelected());
+	}
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/PercentagePanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/PercentagePanel.java
new file mode 100644
index 0000000..48acf1c
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/PercentagePanel.java
@@ -0,0 +1,94 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.tools.flame;
+import java.awt.Dimension;
+import java.awt.GridBagConstraints;
+import java.awt.GridBagLayout;
+import java.awt.Insets;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+
+import javax.swing.BorderFactory;
+import javax.swing.JButton;
+import javax.swing.JPanel;
+
+import com.badlogic.gdx.graphics.g3d.particles.values.ScaledNumericValue;
+import com.badlogic.gdx.tools.particleeditor.Chart;
+
+/** @author Inferno */
+class PercentagePanel extends ParticleValuePanel<ScaledNumericValue> {
+	JButton expandButton;
+	Chart chart;
+
+	public PercentagePanel (FlameMain editor, ScaledNumericValue value, String chartTitle, String name, String description) {
+		super(editor, name, description);
+
+		initializeComponents(chartTitle);
+		setValue(value);
+	}
+	
+	@Override
+	public void setValue (ScaledNumericValue value) {
+		super.setValue(value);
+		if(value == null) return; 
+		chart.setValues(this.value.getTimeline(), this.value.getScaling());
+	}
+
+	private void initializeComponents (String chartTitle) {
+		JPanel contentPanel = getContentPanel();
+		{
+			chart = new Chart(chartTitle) {
+				public void pointsChanged () {
+					value.setTimeline(chart.getValuesX());
+					value.setScaling(chart.getValuesY());
+				}
+			};
+			chart.setPreferredSize(new Dimension(150, 62));
+			contentPanel.add(chart, new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.BOTH,
+				new Insets(0, 0, 0, 0), 0, 0));
+		}
+		{
+			expandButton = new JButton("+");
+			expandButton.setBorder(BorderFactory.createEmptyBorder(4, 10, 4, 10));
+			contentPanel.add(expandButton, new GridBagConstraints(1, 0, 1, 1, 1, 0, GridBagConstraints.NORTHWEST,
+				GridBagConstraints.NONE, new Insets(0, 6, 0, 0), 0, 0));
+		}
+		expandButton.addActionListener(new ActionListener() {
+			public void actionPerformed (ActionEvent event) {
+				chart.setExpanded(!chart.isExpanded());
+				boolean expanded = chart.isExpanded();
+				GridBagLayout layout = (GridBagLayout)getContentPanel().getLayout();
+				GridBagConstraints chartConstraints = layout.getConstraints(chart);
+				GridBagConstraints expandButtonConstraints = layout.getConstraints(expandButton);
+				if (expanded) {
+					chart.setPreferredSize(new Dimension(150, 200));
+					expandButton.setText("-");
+					chartConstraints.weightx = 1;
+					expandButtonConstraints.weightx = 0;
+				} else {
+					chart.setPreferredSize(new Dimension(150, 62));
+					expandButton.setText("+");
+					chartConstraints.weightx = 0;
+					expandButtonConstraints.weightx = 1;
+				}
+				layout.setConstraints(chart, chartConstraints);
+				layout.setConstraints(expandButton, expandButtonConstraints);
+				chart.revalidate();
+			}
+		});
+	}
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/PreAlpha.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/PreAlpha.java
new file mode 100644
index 0000000..3cfc085
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/PreAlpha.java
@@ -0,0 +1,167 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package com.badlogic.gdx.tools.flame;
+
+import java.awt.EventQueue;
+import java.awt.FileDialog;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.awt.event.WindowAdapter;
+import java.awt.event.WindowEvent;
+import java.awt.image.BufferedImage;
+import java.awt.image.WritableRaster;
+import java.io.File;
+import java.io.IOException;
+
+import javax.imageio.ImageIO;
+import javax.swing.JFrame;
+import javax.swing.JMenu;
+import javax.swing.JMenuBar;
+import javax.swing.JMenuItem;
+import javax.swing.JOptionPane;
+import javax.swing.UIManager;
+import javax.swing.UIManager.LookAndFeelInfo;
+
+/** @author Inferno */
+public class PreAlpha extends JFrame {
+	BufferedImage image;
+	ImagePanel imagePanel;
+	String lastDir;
+	
+	public PreAlpha () {
+		super("Premultiply alpha converter");
+		addWindowListener(new WindowAdapter() {
+			public void windowClosed (WindowEvent event) {
+				System.exit(0);
+			}
+		});
+
+		initializeComponents();
+		pack();
+		setLocationRelativeTo(null);
+		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
+		setVisible(true);
+	}
+        
+	private void initializeComponents () {
+		//Create the menu bar.
+		JMenuBar menuBar = new JMenuBar();
+
+		//Build the first menu.
+		JMenu menu = new JMenu("File");
+		menuBar.add(menu);
+
+		//a group of JMenuItems
+		JMenuItem menuItem = new JMenuItem("Open");
+		menuItem.addActionListener(new ActionListener() {
+			
+			@Override
+			public void actionPerformed (ActionEvent arg0) {
+				open();
+			}
+		});
+		menu.add(menuItem);
+		
+		menuItem = new JMenuItem("Save");
+		menuItem.addActionListener(new ActionListener() {
+			
+			@Override
+			public void actionPerformed (ActionEvent arg0) {
+				save();
+			}
+		});
+		menu.add(menuItem);
+		setJMenuBar(menuBar);
+		
+		imagePanel = new ImagePanel();
+		getContentPane().add(imagePanel);
+	}
+
+	protected void save () {
+		FileDialog dialog = new FileDialog(this, "Save Image", FileDialog.SAVE);
+		if (lastDir != null) dialog.setDirectory(lastDir);
+		dialog.setVisible(true);
+		final String file = dialog.getFile();
+		final String dir = dialog.getDirectory();
+		if (dir == null || file == null || file.trim().length() == 0) return;
+		lastDir = dir;
+		try {
+			generatePremultiplyAlpha(new File(dir, file));
+			JOptionPane.showMessageDialog(this, "Conversion complete!");
+		} catch (Exception ex) {
+			JOptionPane.showMessageDialog(this, "Error saving image.");
+			return;
+		}
+	}
+
+	protected void open () {
+		FileDialog dialog = new FileDialog(this, "Open Image", FileDialog.LOAD);
+		if (lastDir != null) dialog.setDirectory(lastDir);
+		dialog.setVisible(true);
+		final String file = dialog.getFile();
+		final String dir = dialog.getDirectory();
+		if (dir == null || file == null || file.trim().length() == 0) return;
+		lastDir = dir;
+		try {
+			image = ImageIO.read(new File(dir, file));
+			imagePanel.setImage(image);
+			imagePanel.revalidate();
+			imagePanel.repaint();
+			pack();
+		} catch (Exception ex) {
+			JOptionPane.showMessageDialog(this, "Error opening image.");
+			return;
+		}
+	}
+	
+	private void generatePremultiplyAlpha(File out){
+		try {
+			BufferedImage outImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_ARGB);
+			float[] color = new float[4];
+			WritableRaster raster = image.getRaster();
+			WritableRaster outRaster = outImage.getRaster();
+			for(int x =0, w = image.getWidth(); x< w; ++x)
+				for(int y =0, h = image.getHeight(); y< h; ++y){
+					raster.getPixel(x, y, color);
+					float alpha = color[3]/255f;
+					for(int i=0;i < 3; ++i) 
+						color[i] *= alpha;
+					outRaster.setPixel(x, y, color);
+				}
+			ImageIO.write(outImage, "png", out);
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+	}
+	
+
+	public static void main (String[] args) {
+		for (LookAndFeelInfo info : UIManager.getInstalledLookAndFeels()) {
+			if ("Nimbus".equals(info.getName())) {
+				try {
+					UIManager.setLookAndFeel(info.getClassName());
+				} catch (Throwable ignored) {
+				}
+				break;
+			}
+		}
+		EventQueue.invokeLater(new Runnable() {
+			public void run () {
+				new PreAlpha();
+			}
+		});
+	}
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/RangedNumericPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/RangedNumericPanel.java
new file mode 100644
index 0000000..e92ee97
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/RangedNumericPanel.java
@@ -0,0 +1,111 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.tools.flame;
+import java.awt.GridBagConstraints;
+import java.awt.Insets;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+
+import javax.swing.BorderFactory;
+import javax.swing.JButton;
+import javax.swing.JLabel;
+import javax.swing.JPanel;
+import javax.swing.event.ChangeEvent;
+import javax.swing.event.ChangeListener;
+
+import com.badlogic.gdx.graphics.g3d.particles.values.RangedNumericValue;
+
+/** @author Inferno */
+class RangedNumericPanel extends ParticleValuePanel<RangedNumericValue> {
+	Slider minSlider, maxSlider;
+	JButton rangeButton;
+	JLabel label;
+
+	public RangedNumericPanel (FlameMain editor, RangedNumericValue value, String name, String description) 
+	{
+		this(editor, value, name, description, true);
+	}
+	
+	public RangedNumericPanel (FlameMain editor, RangedNumericValue value, String name, String description, boolean isAlwaysActive) 
+	{
+		super(editor, name, description, isAlwaysActive);
+		setValue(value);
+	}
+
+	@Override
+	protected void initializeComponents () {
+		super.initializeComponents();
+		JPanel contentPanel = getContentPanel();
+		{
+			label = new JLabel("Value:");
+			contentPanel.add(label, new GridBagConstraints(2, 2, 1, 1, 0, 0, GridBagConstraints.EAST, GridBagConstraints.NONE,
+				new Insets(0, 0, 0, 6), 0, 0));
+		}
+		{
+			minSlider = new Slider(0, -99999, 99999, 1);
+			contentPanel.add(minSlider, new GridBagConstraints(3, 2, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+				new Insets(0, 0, 0, 0), 0, 0));
+		}
+		{
+			maxSlider = new Slider(0, -99999, 99999, 1);
+			contentPanel.add(maxSlider, new GridBagConstraints(4, 2, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+				new Insets(0, 6, 0, 0), 0, 0));
+		}
+		{
+			rangeButton = new JButton("<");
+			rangeButton.setBorder(BorderFactory.createEmptyBorder(6, 6, 6, 6));
+			contentPanel.add(rangeButton, new GridBagConstraints(5, 2, 1, 1, 1.0, 0, GridBagConstraints.WEST,
+				GridBagConstraints.NONE, new Insets(0, 1, 0, 0), 0, 0));
+		}
+		
+		
+		minSlider.addChangeListener(new ChangeListener() {
+			public void stateChanged (ChangeEvent event) {
+				RangedNumericPanel.this.value.setLowMin((Float)minSlider.getValue());
+				if (!maxSlider.isVisible()) RangedNumericPanel.this.value.setLowMax((Float)minSlider.getValue());
+			}
+		});
+
+		maxSlider.addChangeListener(new ChangeListener() {
+			public void stateChanged (ChangeEvent event) {
+				RangedNumericPanel.this.value.setLowMax((Float)maxSlider.getValue());
+			}
+		});
+
+		rangeButton.addActionListener(new ActionListener() {
+			public void actionPerformed (ActionEvent event) {
+				boolean visible = !maxSlider.isVisible();
+				maxSlider.setVisible(visible);
+				rangeButton.setText(visible ? "<" : ">");
+				Slider slider = visible ? maxSlider : minSlider;
+				RangedNumericPanel.this.value.setLowMax((Float)slider.getValue());
+			}
+		});
+	}
+
+	public void setValue (RangedNumericValue value) {
+		super.setValue(value);
+		if(value == null) return;
+		setValue(minSlider, value.getLowMin());
+		setValue(maxSlider, value.getLowMax());
+		//System.out.println("min "+value.getLowMin()+", max "+value.getLowMax());
+		if (minSlider.getValue() == maxSlider.getValue()) 
+			rangeButton.doClick(0);
+		else if(!maxSlider.isVisible())
+				maxSlider.setVisible(true);
+	}
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/RegionInfluencerPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/RegionInfluencerPanel.java
new file mode 100644
index 0000000..21a5d04
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/RegionInfluencerPanel.java
@@ -0,0 +1,75 @@
+package com.badlogic.gdx.tools.flame;
+
+import java.awt.GridBagConstraints;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+
+import javax.swing.JButton;
+import javax.swing.JDialog;
+import javax.swing.JOptionPane;
+import javax.swing.JScrollPane;
+
+import com.badlogic.gdx.graphics.g2d.TextureAtlas;
+import com.badlogic.gdx.graphics.g2d.TextureRegion;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.RegionInfluencer;
+import com.badlogic.gdx.utils.Array;
+
+/** @author Inferno */
+public class RegionInfluencerPanel extends InfluencerPanel<RegionInfluencer> implements RegionPickerPanel.Listener {
+	JDialog regionSelectDialog;
+	RegionPickerPanel regionPickerPanel;
+	
+	public RegionInfluencerPanel (FlameMain editor, String name, String desc, RegionInfluencer influencer) {
+		super(editor, influencer, name, desc);
+		setValue(influencer);
+	}
+	
+	@Override
+	protected void initializeComponents () {
+		super.initializeComponents();
+		
+		JButton pickButton;
+		regionSelectDialog = new JDialog(editor, "Pick regions", true);
+		regionPickerPanel = new RegionPickerPanel(this);
+		JScrollPane scrollPane = new JScrollPane();
+		scrollPane.setViewportView(regionPickerPanel);
+		regionSelectDialog.setContentPane(scrollPane);
+		regionSelectDialog.setDefaultCloseOperation( JDialog.HIDE_ON_CLOSE);
+
+		addContent(0, 0, pickButton = new JButton("Pick Regions"), false, GridBagConstraints.WEST, GridBagConstraints.NONE);
+
+		pickButton.addActionListener(new ActionListener() {
+			@Override
+			public void actionPerformed (ActionEvent arg0) {
+				if(editor.isUsingDefaultTexture()) {
+					JOptionPane.showMessageDialog(editor, "Load a Texture or an Atlas first.");
+					return;
+				}
+				
+				TextureAtlas atlas = editor.getAtlas();
+				if(atlas != null)
+					regionPickerPanel.setAtlas(atlas);
+				else 
+					regionPickerPanel.setTexture(editor.getTexture());
+				
+				regionPickerPanel.revalidate();
+				regionPickerPanel.repaint();
+				regionSelectDialog.validate();
+				regionSelectDialog.repaint();
+				regionSelectDialog.pack();
+				regionSelectDialog.setVisible(true);
+			}
+		});
+	}
+
+	@Override
+	public void onRegionsSelected (Array<TextureRegion> regions) {
+		regionSelectDialog.setVisible(false);
+		if(regions.size == 0) return;
+		value.clear();
+		value.add((TextureRegion[])regions.toArray(TextureRegion.class));
+		editor.setTexture(regions.get(0).getTexture());
+		editor.restart();
+	}
+
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/RegionPickerPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/RegionPickerPanel.java
new file mode 100644
index 0000000..7e2287f
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/RegionPickerPanel.java
@@ -0,0 +1,209 @@
+package com.badlogic.gdx.tools.flame;
+
+import java.awt.GridBagConstraints;
+import java.awt.GridBagLayout;
+import java.awt.Insets;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+
+import javax.swing.DefaultComboBoxModel;
+import javax.swing.JButton;
+import javax.swing.JComboBox;
+import javax.swing.JLabel;
+import javax.swing.JPanel;
+import javax.swing.JSeparator;
+
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.g2d.TextureAtlas;
+import com.badlogic.gdx.graphics.g2d.TextureRegion;
+import com.badlogic.gdx.utils.Array;
+
+/** @author Inferno */
+public class RegionPickerPanel extends JPanel{
+
+	private enum GenerationMode {
+		ByRows("Generate By Rows"), ByColumns("Generate By Columns");
+		String string;
+		private GenerationMode(String string){
+			this.string = string;
+		}
+		
+		@Override
+		public String toString () {
+			return string;
+		}
+	}
+	
+	public interface Listener{
+		void onRegionsSelected(Array<TextureRegion> regions);
+	}
+	
+	TextureAtlasPanel atlasPanel;
+	TexturePanel texturePanel;
+	JButton selectButton, selectAllButton, clearButton, generateButton, reverseButton;
+	JComboBox generateBox;
+	Slider rowSlider, columnSlider;
+	JPanel generationPanel, content;
+	Listener listener;
+	
+	public RegionPickerPanel(Listener listener){
+		initializeComponents();
+		this.listener = listener;
+	}
+
+	private void initializeComponents () {
+		setLayout(new GridBagLayout());
+		content = new JPanel();
+		atlasPanel = new TextureAtlasPanel();
+		texturePanel = new TexturePanel();
+		CustomCardLayout cardLayout = new CustomCardLayout();
+		content.setLayout(cardLayout);
+		content.add(atlasPanel, "atlas");
+		content.add(texturePanel, "texture");
+		
+		
+		add(content, new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+			new Insets(0, 0, 0, 0), 0, 0));
+		
+		JPanel controls = new JPanel(new GridBagLayout());
+		controls.add(selectButton = new JButton("Select"), new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE,
+			new Insets(0, 0, 0, 0), 0, 0));
+		
+		controls.add(new JSeparator(JSeparator.HORIZONTAL), new GridBagConstraints(0, -1, 1, 1, 0, 0,
+			GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, new Insets(0, 0, 6, 0), 0, 0));
+		
+		//Pick
+		JPanel pickPanel = new JPanel(new GridBagLayout());
+		pickPanel.add(selectAllButton = new JButton("Pick All"), new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE,
+			new Insets(0, 0, 0, 0), 0, 0));
+		pickPanel.add(clearButton = new JButton("Clear Selection"), new GridBagConstraints(1, 0, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE,
+			new Insets(0, 0, 0, 0), 0, 0));
+		pickPanel.add(reverseButton = new JButton("Reverse Selection"), new GridBagConstraints(0, 1, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE,
+			new Insets(0, 0, 0, 0), 0, 0));
+		controls.add(pickPanel, new GridBagConstraints(0, -1, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE,
+			new Insets(0, 0, 0, 0), 0, 0));
+		
+		//Generation
+		generationPanel = new JPanel(new GridBagLayout());
+		generationPanel.add(new JLabel("Rows"), new GridBagConstraints(0, 0, 1, 1, 1, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE,
+			new Insets(0, 0, 0, 0), 0, 0));
+		generationPanel.add(rowSlider = new Slider(1, 1, 9999, 1), new GridBagConstraints(1, 0, 1, 1, 1, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE,
+			new Insets(0, 0, 0, 0), 0, 0));
+		generationPanel.add(new JLabel("Columns"), new GridBagConstraints(0, 1, 1, 1, 1, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE,
+			new Insets(0, 0, 0, 0), 0, 0));
+		generationPanel.add(columnSlider = new Slider(1, 1, 9999, 1), new GridBagConstraints(1, 1, 1, 1, 1, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE,
+			new Insets(0, 0, 0, 0), 0, 0));
+		generationPanel.add(generateBox = new JComboBox(new DefaultComboBoxModel(GenerationMode.values())), new GridBagConstraints(0, 2, 1, 1, 1, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE,
+			new Insets(0, 0, 0, 0), 0, 0));
+		generationPanel.add(generateButton = new JButton("Generate"), new GridBagConstraints(1, 2, 1, 1, 1, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE,
+			new Insets(0, 0, 0, 0), 0, 0));
+		controls.add(new JSeparator(JSeparator.HORIZONTAL), new GridBagConstraints(0, -1, 1, 1, 0, 0,
+			GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, new Insets(0, 0, 6, 0), 0, 0));
+		controls.add(generationPanel, new GridBagConstraints(0, -1, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE,
+			new Insets(0, 0, 0, 0), 0, 0));
+		add(controls, new GridBagConstraints(1, 0, 1, 1, 1, 0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE,
+			new Insets(0, 0, 0, 0), 0, 0));
+		
+		selectButton.addActionListener(new ActionListener() {
+			@Override
+			public void actionPerformed (ActionEvent arg0) {
+				JPanel panel = ((CustomCardLayout)content.getLayout()).getCurrentCard(content);
+				TexturePanel currentTexturePanel = panel == atlasPanel ? atlasPanel.getCurrentRegionPanel() : texturePanel;
+				listener.onRegionsSelected(currentTexturePanel.selectedRegions);
+			}
+		});
+		
+		selectAllButton.addActionListener(new ActionListener() {
+			@Override
+			public void actionPerformed (ActionEvent arg0) {				
+				JPanel panel = ((CustomCardLayout)content.getLayout()).getCurrentCard(content);
+				TexturePanel currentTexturePanel = panel == atlasPanel ? atlasPanel.getCurrentRegionPanel() : texturePanel;
+				currentTexturePanel.selectAll();
+			}
+		});
+		
+		reverseButton.addActionListener(new ActionListener() {
+			@Override
+			public void actionPerformed (ActionEvent arg0) {
+				JPanel panel = ((CustomCardLayout)content.getLayout()).getCurrentCard(content);
+				TexturePanel currentTexturePanel = panel == atlasPanel ? atlasPanel.getCurrentRegionPanel() : texturePanel;
+				currentTexturePanel.selectedRegions.reverse();
+				currentTexturePanel.revalidate();
+				currentTexturePanel.repaint();
+			}
+		});
+		
+		clearButton.addActionListener(new ActionListener() {
+			@Override
+			public void actionPerformed (ActionEvent arg0) {
+				JPanel panel = ((CustomCardLayout)content.getLayout()).getCurrentCard(content);
+				TexturePanel currentPanel = panel == atlasPanel ? atlasPanel.getCurrentRegionPanel() : texturePanel;
+				currentPanel.clearSelection();
+			}
+		});
+		
+		generateButton.addActionListener(new ActionListener() {
+			@Override
+			public void actionPerformed (ActionEvent arg0) {
+				generateRegions((GenerationMode)generateBox.getSelectedItem());
+				texturePanel.revalidate();
+				texturePanel.repaint();
+			}
+		});
+		
+	}
+	
+	void generateRegions(GenerationMode mode){
+		//generate regions
+		texturePanel.clear();
+		Texture texture = texturePanel.getTexture();
+		int 	rows = (int)rowSlider.getValue(), columns = (int)columnSlider.getValue(),
+				yOffset = texture.getHeight()/rows, xOffset = texture.getWidth()/columns;
+		
+		if(mode == GenerationMode.ByRows){
+			for(int j=0; j < rows; ++j){
+				int rowOffset = j*yOffset;
+				for(int i=0; i < columns; ++i){
+					texturePanel.unselectedRegions.add(new TextureRegion(texture, i*xOffset, rowOffset, xOffset, yOffset) );
+				}
+			}	
+		}
+		else 	if(mode == GenerationMode.ByColumns){
+			for(int i=0; i < columns; ++i){
+				int columnOffset = i*xOffset;
+				for(int j=0; j <rows; ++j){
+					texturePanel.unselectedRegions.add(new TextureRegion(texture, columnOffset, j*yOffset, xOffset, yOffset) );
+				}
+			}	
+		}
+	}
+
+	public void setAtlas (TextureAtlas atlas) {
+		atlasPanel.clearSelection();
+		atlasPanel.setAtlas(atlas);
+		CustomCardLayout cardLayout = (CustomCardLayout)content.getLayout();
+		cardLayout.show(content, "atlas");
+		showGenerationPanel(false);
+		content.revalidate();
+		content.repaint();
+		revalidate();
+		repaint();
+	}
+	
+	public void setTexture(Texture texture){
+		texturePanel.clearSelection();
+		texturePanel.setTexture(texture);
+		CustomCardLayout cardLayout = (CustomCardLayout)content.getLayout();
+		cardLayout.show(content, "texture");
+		showGenerationPanel(true);
+		content.revalidate();
+		content.repaint();
+		revalidate();
+		repaint();
+	}
+	
+	private void showGenerationPanel(boolean isShown){
+		generationPanel.setVisible(isShown);
+	}
+	
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/RegularEmitterPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/RegularEmitterPanel.java
new file mode 100644
index 0000000..6700531
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/RegularEmitterPanel.java
@@ -0,0 +1,50 @@
+package com.badlogic.gdx.tools.flame;
+
+import java.awt.GridBagConstraints;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+
+import javax.swing.JCheckBox;
+import javax.swing.SwingConstants;
+
+import com.badlogic.gdx.graphics.g3d.particles.emitters.RegularEmitter;
+
+/** @author Inferno */
+public class RegularEmitterPanel extends EditorPanel<RegularEmitter> {
+
+	CountPanel countPanel;
+	RangedNumericPanel 	delayPanel,
+								durationPanel;
+	ScaledNumericPanel	emissionPanel,
+								lifePanel,
+								lifeOffsetPanel;
+	JCheckBox continuousCheckbox;
+	
+	public RegularEmitterPanel (FlameMain particleEditor3D, RegularEmitter emitter) {
+		super(particleEditor3D, "Regular Emitter", "This is a generic emitter used to generate particles regularly.");
+		initializeComponents(emitter);
+		setValue(null);
+	}
+	
+	private void initializeComponents(RegularEmitter emitter){
+		continuousCheckbox = new JCheckBox("Continuous");
+		continuousCheckbox.setSelected(emitter.isContinuous());
+		continuousCheckbox.addActionListener(new ActionListener() {
+			public void actionPerformed (ActionEvent event) {
+				RegularEmitter emitter = (RegularEmitter) editor.getEmitter().emitter;
+				emitter.setContinuous(continuousCheckbox.isSelected());
+			}
+		});
+		continuousCheckbox.setHorizontalTextPosition(SwingConstants.LEFT);
+		
+		int i =0;
+		addContent(i++, 0, continuousCheckbox, GridBagConstraints.WEST, GridBagConstraints.NONE);
+		addContent(i++, 0, countPanel = new CountPanel(editor, "Count", "Min number of particles at all times, max number of particles allowed.", emitter.minParticleCount, emitter.maxParticleCount));
+		addContent(i++, 0, delayPanel = new RangedNumericPanel(editor, emitter.getDelay(), "Delay", "Time from beginning of effect to emission start, in milliseconds.", false));
+		addContent(i++, 0, durationPanel = new RangedNumericPanel(editor, emitter.getDuration(), "Duration", "Time particles will be emitted, in milliseconds."));
+		addContent(i++, 0, emissionPanel = new ScaledNumericPanel(editor, emitter.getEmission(), "Duration", "Emission","Number of particles emitted per second."));
+		addContent(i++, 0, lifePanel = new ScaledNumericPanel(editor, emitter.getLife(), "Duration", "Life", "Time particles will live, in milliseconds."));
+		addContent(i++, 0, lifeOffsetPanel = new ScaledNumericPanel(editor, emitter.getLifeOffset(), "Duration", "Life Offset","Particle starting life consumed, in milliseconds.", false));
+	}
+	
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/ScaleInfluencerPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/ScaleInfluencerPanel.java
new file mode 100644
index 0000000..2b919a9
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/ScaleInfluencerPanel.java
@@ -0,0 +1,31 @@
+package com.badlogic.gdx.tools.flame;
+
+import com.badlogic.gdx.graphics.g3d.particles.influencers.ScaleInfluencer;
+
+
+/** @author Inferno */
+public class ScaleInfluencerPanel extends InfluencerPanel<ScaleInfluencer> {
+
+	ScaledNumericPanel scalePanel;
+	
+	public ScaleInfluencerPanel (FlameMain editor, ScaleInfluencer influencer) {
+		super(editor, influencer, "Scale Influencer", "Particle scale, in world units.");
+		setValue(influencer);
+	}
+	
+	@Override
+	public void setValue (ScaleInfluencer value) {
+		super.setValue(value);
+		if(value == null) return;
+		scalePanel.setValue(value.value);
+	}
+	
+	@Override
+	protected void initializeComponents () {
+		super.initializeComponents();
+		
+		addContent(0, 0, scalePanel = new ScaledNumericPanel(editor, null, "Life", "", ""));
+		scalePanel.setIsAlwayShown(true);
+	}
+
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/ScaledNumericPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/ScaledNumericPanel.java
new file mode 100644
index 0000000..b85c2ac
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/ScaledNumericPanel.java
@@ -0,0 +1,243 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.tools.flame;
+import java.awt.Dimension;
+import java.awt.GridBagConstraints;
+import java.awt.GridBagLayout;
+import java.awt.Insets;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+
+import javax.swing.BorderFactory;
+import javax.swing.JButton;
+import javax.swing.JCheckBox;
+import javax.swing.JLabel;
+import javax.swing.JPanel;
+import javax.swing.event.ChangeEvent;
+import javax.swing.event.ChangeListener;
+
+import com.badlogic.gdx.graphics.g3d.particles.values.ScaledNumericValue;
+import com.badlogic.gdx.tools.particleeditor.Chart;
+
+/** @author Inferno */
+class ScaledNumericPanel extends ParticleValuePanel<ScaledNumericValue> {
+	Slider lowMinSlider, lowMaxSlider;
+	Slider highMinSlider, highMaxSlider;
+	JCheckBox relativeCheckBox;
+	Chart chart;
+	JPanel formPanel;
+	JButton expandButton;
+	JButton lowRangeButton;
+	JButton highRangeButton;
+
+	public ScaledNumericPanel (FlameMain editor, ScaledNumericValue value, String chartTitle, String name, String description){
+		this(editor, value, chartTitle, name, description, true);
+	}
+	
+	public ScaledNumericPanel (FlameMain editor, ScaledNumericValue value, 
+												String chartTitle, String name, String description, boolean isAlwaysActive){
+		super(editor, name, description, isAlwaysActive);
+		initializeComponents(chartTitle);
+		setValue(value);
+	}
+
+	public JPanel getFormPanel () {
+		return formPanel;
+	}
+
+	private void initializeComponents (String chartTitle) {
+		JPanel contentPanel = getContentPanel();
+		{
+			formPanel = new JPanel(new GridBagLayout());
+			contentPanel.add(formPanel, new GridBagConstraints(5, 5, 1, 1, 0, 0, GridBagConstraints.EAST, GridBagConstraints.NONE,
+				new Insets(0, 0, 0, 6), 0, 0));
+			{
+				JLabel label = new JLabel("High:");
+				formPanel.add(label, new GridBagConstraints(2, 1, 1, 1, 0, 0, GridBagConstraints.EAST, GridBagConstraints.NONE,
+					new Insets(0, 0, 0, 6), 0, 0));
+			}
+			{
+				highMinSlider = new Slider(0, -999999, 999999, 1f);
+				formPanel.add(highMinSlider, new GridBagConstraints(3, 1, 1, 1, 0, 0, GridBagConstraints.WEST,
+					GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));
+			}
+			{
+				highMaxSlider = new Slider(0, -999999, 999999, 1f);
+				formPanel.add(highMaxSlider, new GridBagConstraints(4, 1, 1, 1, 0, 0, GridBagConstraints.WEST,
+					GridBagConstraints.NONE, new Insets(0, 6, 0, 0), 0, 0));
+			}
+			{
+				highRangeButton = new JButton("<");
+				highRangeButton.setBorder(BorderFactory.createEmptyBorder(6, 6, 6, 6));
+				formPanel.add(highRangeButton, new GridBagConstraints(5, 1, 1, 1, 0.0, 0, GridBagConstraints.WEST,
+					GridBagConstraints.NONE, new Insets(0, 1, 0, 0), 0, 0));
+			}
+			{
+				JLabel label = new JLabel("Low:");
+				formPanel.add(label, new GridBagConstraints(2, 2, 1, 1, 0, 0, GridBagConstraints.EAST, GridBagConstraints.NONE,
+					new Insets(0, 0, 0, 6), 0, 0));
+			}
+			{
+				lowMinSlider = new Slider(0, -999999, 999999, 1f);
+				formPanel.add(lowMinSlider, new GridBagConstraints(3, 2, 1, 1, 0, 0, GridBagConstraints.WEST,
+					GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));
+			}
+			{
+				lowMaxSlider = new Slider(0, -999999, 999999, 1f);
+				formPanel.add(lowMaxSlider, new GridBagConstraints(4, 2, 1, 1, 0, 0, GridBagConstraints.WEST,
+					GridBagConstraints.NONE, new Insets(0, 6, 0, 0), 0, 0));
+			}
+			{
+				lowRangeButton = new JButton("<");
+				lowRangeButton.setBorder(BorderFactory.createEmptyBorder(6, 6, 6, 6));
+				formPanel.add(lowRangeButton, new GridBagConstraints(5, 2, 1, 1, 0.0, 0, GridBagConstraints.WEST,
+					GridBagConstraints.NONE, new Insets(0, 1, 0, 0), 0, 0));
+			}
+		}
+		{
+			chart = new Chart(chartTitle) {
+				public void pointsChanged () {
+					value.setTimeline(chart.getValuesX());
+					value.setScaling(chart.getValuesY());
+				}
+			};
+			contentPanel.add(chart, new GridBagConstraints(6, 5, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.BOTH,
+				new Insets(0, 0, 0, 0), 0, 0));
+			chart.setPreferredSize(new Dimension(150, 30));
+		}
+		{
+			expandButton = new JButton("+");
+			contentPanel.add(expandButton, new GridBagConstraints(7, 5, 1, 1, 1, 0, GridBagConstraints.SOUTHWEST,
+				GridBagConstraints.NONE, new Insets(0, 5, 0, 0), 0, 0));
+			expandButton.setBorder(BorderFactory.createEmptyBorder(4, 8, 4, 8));
+		}
+		{
+			relativeCheckBox = new JCheckBox("Relative");
+			contentPanel.add(relativeCheckBox, new GridBagConstraints(7, 5, 1, 1, 0, 0, GridBagConstraints.NORTHWEST,
+				GridBagConstraints.NONE, new Insets(0, 6, 0, 0), 0, 0));
+		}
+		
+		lowMinSlider.addChangeListener(new ChangeListener() {
+			public void stateChanged (ChangeEvent event) {
+				ScaledNumericPanel.this.value.setLowMin(lowMinSlider.getValue());
+				if (!lowMaxSlider.isVisible()) ScaledNumericPanel.this.value.setLowMax(lowMinSlider.getValue());
+			}
+		});
+		lowMaxSlider.addChangeListener(new ChangeListener() {
+			public void stateChanged (ChangeEvent event) {
+				ScaledNumericPanel.this.value.setLowMax(lowMaxSlider.getValue());
+			}
+		});
+		highMinSlider.addChangeListener(new ChangeListener() {
+			public void stateChanged (ChangeEvent event) {
+				ScaledNumericPanel.this.value.setHighMin(highMinSlider.getValue());
+				if (!highMaxSlider.isVisible()) ScaledNumericPanel.this.value.setHighMax(highMinSlider.getValue());
+			}
+		});
+		highMaxSlider.addChangeListener(new ChangeListener() {
+			public void stateChanged (ChangeEvent event) {
+				ScaledNumericPanel.this.value.setHighMax(highMaxSlider.getValue());
+			}
+		});
+
+		relativeCheckBox.addActionListener(new ActionListener() {
+			public void actionPerformed (ActionEvent event) {
+				ScaledNumericPanel.this.value.setRelative(relativeCheckBox.isSelected());
+			}
+		});
+
+		lowRangeButton.addActionListener(new ActionListener() {
+			public void actionPerformed (ActionEvent event) {
+				boolean visible = !lowMaxSlider.isVisible();
+				lowMaxSlider.setVisible(visible);
+				lowRangeButton.setText(visible ? "<" : ">");
+				GridBagLayout layout = (GridBagLayout)formPanel.getLayout();
+				GridBagConstraints constraints = layout.getConstraints(lowRangeButton);
+				constraints.gridx = visible ? 5 : 4;
+				layout.setConstraints(lowRangeButton, constraints);
+				Slider slider = visible ? lowMaxSlider : lowMinSlider;
+				ScaledNumericPanel.this.value.setLowMax(slider.getValue());
+			}
+		});
+
+		highRangeButton.addActionListener(new ActionListener() {
+			public void actionPerformed (ActionEvent event) {
+				boolean visible = !highMaxSlider.isVisible();
+				highMaxSlider.setVisible(visible);
+				highRangeButton.setText(visible ? "<" : ">");
+				GridBagLayout layout = (GridBagLayout)formPanel.getLayout();
+				GridBagConstraints constraints = layout.getConstraints(highRangeButton);
+				constraints.gridx = visible ? 5 : 4;
+				layout.setConstraints(highRangeButton, constraints);
+				Slider slider = visible ? highMaxSlider : highMinSlider;
+				ScaledNumericPanel.this.value.setHighMax(slider.getValue());
+			}
+		});
+
+		expandButton.addActionListener(new ActionListener() {
+			public void actionPerformed (ActionEvent event) {
+				chart.setExpanded(!chart.isExpanded());
+				boolean expanded = chart.isExpanded();
+				GridBagLayout layout = (GridBagLayout)getContentPanel().getLayout();
+				GridBagConstraints chartConstraints = layout.getConstraints(chart);
+				GridBagConstraints expandButtonConstraints = layout.getConstraints(expandButton);
+				if (expanded) {
+					chart.setPreferredSize(new Dimension(150, 200));
+					expandButton.setText("-");
+					chartConstraints.weightx = 1;
+					expandButtonConstraints.weightx = 0;
+				} else {
+					chart.setPreferredSize(new Dimension(150, 30));
+					expandButton.setText("+");
+					chartConstraints.weightx = 0;
+					expandButtonConstraints.weightx = 1;
+				}
+				layout.setConstraints(chart, chartConstraints);
+				layout.setConstraints(expandButton, expandButtonConstraints);
+				relativeCheckBox.setVisible(!expanded);
+				formPanel.setVisible(!expanded);
+				chart.revalidate();
+			}
+		});
+		
+	}
+	
+	@Override
+	public void setValue(ScaledNumericValue value){
+		super.setValue(value);
+		if(this.value == null)return;
+		setValue(lowMinSlider, this.value.getLowMin());
+		setValue(lowMaxSlider, this.value.getLowMax());
+		setValue(highMinSlider, this.value.getHighMin());
+		setValue(highMaxSlider, this.value.getHighMax());
+		chart.setValues(this.value.getTimeline(), this.value.getScaling());
+		setValue(relativeCheckBox, this.value.isRelative());
+		
+		if (	(this.value.getLowMin() == this.value.getLowMax() && lowMaxSlider.isVisible()) || 
+				(this.value.getLowMin() != this.value.getLowMax() && !lowMaxSlider.isVisible()) ) {
+			lowRangeButton.doClick(0);
+		}
+		if ( 	((this.value.getHighMin() == this.value.getHighMax()) && highMaxSlider.isVisible()) ||
+				((this.value.getHighMin() != this.value.getHighMax()) && !highMaxSlider.isVisible()) ) 
+			highRangeButton.doClick(0);
+	}
+
+	public Chart getChart(){
+		return chart;
+	}
+
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/Slider.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/Slider.java
new file mode 100644
index 0000000..34078cd
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/Slider.java
@@ -0,0 +1,55 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.tools.flame;
+
+import java.awt.BorderLayout;
+import java.awt.Dimension;
+
+import javax.swing.JPanel;
+import javax.swing.JSpinner;
+import javax.swing.SpinnerNumberModel;
+import javax.swing.event.ChangeListener;
+
+/** @author Inferno */
+public class Slider extends JPanel {
+	public JSpinner spinner;
+
+	public Slider (float initialValue, final float min, final float max, float stepSize) {
+		spinner = new JSpinner(new SpinnerNumberModel(initialValue, min, max, stepSize));
+		setLayout(new BorderLayout());
+		add(spinner);
+	}
+
+	public void setValue (float value) {
+		spinner.setValue((double)value);
+	}
+
+	public float getValue () {
+		return ((Double)spinner.getValue()).floatValue();
+	}
+
+	public void addChangeListener (ChangeListener listener) {
+		spinner.addChangeListener(listener);
+	}
+
+	public Dimension getPreferredSize () {
+		Dimension size = super.getPreferredSize();
+		size.width = 75;
+		size.height = 26;
+		return size;
+	}
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/SpawnInfluencerPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/SpawnInfluencerPanel.java
new file mode 100644
index 0000000..8a0922c
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/SpawnInfluencerPanel.java
@@ -0,0 +1,293 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.tools.flame;
+import java.awt.GridBagConstraints;
+import java.awt.GridBagLayout;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+
+import javax.swing.DefaultComboBoxModel;
+import javax.swing.JCheckBox;
+import javax.swing.JComboBox;
+import javax.swing.JLabel;
+import javax.swing.JPanel;
+import javax.swing.SwingConstants;
+
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.g3d.Model;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.SpawnInfluencer;
+import com.badlogic.gdx.graphics.g3d.particles.values.CylinderSpawnShapeValue;
+import com.badlogic.gdx.graphics.g3d.particles.values.EllipseSpawnShapeValue;
+import com.badlogic.gdx.graphics.g3d.particles.values.LineSpawnShapeValue;
+import com.badlogic.gdx.graphics.g3d.particles.values.PointSpawnShapeValue;
+import com.badlogic.gdx.graphics.g3d.particles.values.PrimitiveSpawnShapeValue;
+import com.badlogic.gdx.graphics.g3d.particles.values.PrimitiveSpawnShapeValue.SpawnSide;
+import com.badlogic.gdx.graphics.g3d.particles.values.RectangleSpawnShapeValue;
+import com.badlogic.gdx.graphics.g3d.particles.values.SpawnShapeValue;
+import com.badlogic.gdx.graphics.g3d.particles.values.UnweightedMeshSpawnShapeValue;
+import com.badlogic.gdx.graphics.g3d.particles.values.WeightMeshSpawnShapeValue;
+import com.badlogic.gdx.utils.Array;
+
+/** @author Inferno */
+class SpawnInfluencerPanel extends InfluencerPanel<SpawnInfluencer> implements TemplatePickerPanel.Listener<Model> {
+	private static final String SPAWN_SHAPE_POINT = "Point",
+		SPAWN_SHAPE_LINE = "Line",
+		SPAWN_SHAPE_RECTANGLE = "Rectangle",
+		SPAWN_SHAPE_CYLINDER = "Cylinder",
+		SPAWN_SHAPE_ELLIPSE = "Ellipse",
+		SPAWN_SHAPE_MESH = "Unweighted Mesh",
+		SPAWN_SHAPE_WEIGHT_MESH = "Weighted Mesh";
+	private static String[] spawnShapes = new String[]{	SPAWN_SHAPE_POINT, SPAWN_SHAPE_LINE, SPAWN_SHAPE_RECTANGLE,
+		SPAWN_SHAPE_ELLIPSE, SPAWN_SHAPE_CYLINDER, 
+		SPAWN_SHAPE_MESH, SPAWN_SHAPE_WEIGHT_MESH};
+	JComboBox shapeCombo;
+	JCheckBox edgesCheckbox;
+	JLabel edgesLabel;
+	JComboBox sideCombo;
+	JLabel sideLabel;
+	TemplatePickerPanel<Model> meshPanel;
+	ScaledNumericPanel widthPanel, heightPanel, depthPanel;
+	RangedNumericPanel xPanel, yPanel, zPanel;
+	PointSpawnShapeValue pointSpawnShapeValue;
+	LineSpawnShapeValue lineSpawnShapeValue;
+	RectangleSpawnShapeValue rectangleSpawnShapeValue;
+	EllipseSpawnShapeValue ellipseSpawnShapeValue;
+	CylinderSpawnShapeValue cylinderSpawnShapeValue;
+	UnweightedMeshSpawnShapeValue meshSpawnShapeValue;
+	WeightMeshSpawnShapeValue weightMeshSpawnShapeValue;
+
+	public SpawnInfluencerPanel (final FlameMain editor, SpawnInfluencer influencer) {
+		super(editor, influencer, "Spawn Influencer", "Define where the particles are spawned.", true, false);
+		setValue(influencer);
+		setCurrentSpawnData(influencer.spawnShapeValue);
+		shapeCombo.setSelectedItem(spawnShapeToString(influencer.spawnShapeValue));
+	}
+
+	private void setCurrentSpawnData (SpawnShapeValue spawnShapeValue) {
+		SpawnShapeValue local = null;
+		if(spawnShapeValue instanceof PointSpawnShapeValue) 
+			local = pointSpawnShapeValue;
+		else if(spawnShapeValue instanceof LineSpawnShapeValue) 
+			local = lineSpawnShapeValue;
+		else if(spawnShapeValue instanceof RectangleSpawnShapeValue) 
+			local = rectangleSpawnShapeValue;
+		else if(spawnShapeValue instanceof EllipseSpawnShapeValue)
+			local = ellipseSpawnShapeValue;
+		else if(spawnShapeValue instanceof CylinderSpawnShapeValue)
+			local = cylinderSpawnShapeValue;
+		if(spawnShapeValue instanceof UnweightedMeshSpawnShapeValue)
+			local = meshSpawnShapeValue;
+		else if(spawnShapeValue instanceof WeightMeshSpawnShapeValue)
+			local = weightMeshSpawnShapeValue;
+		local.load(spawnShapeValue);
+	}
+	
+	protected void setSpawnShapeValue(SpawnShapeValue spawnShapeValue){
+		xPanel.setValue(spawnShapeValue.xOffsetValue);
+		yPanel.setValue(spawnShapeValue.yOffsetValue);
+		zPanel.setValue(spawnShapeValue.zOffsetValue);
+	}
+
+	protected void setPrimitiveSpawnShape (PrimitiveSpawnShapeValue shape, boolean showEdges, SpawnSide side) {
+		setSpawnShapeValue(shape);
+		SpawnInfluencer influencer = (SpawnInfluencer)editor.getEmitter().findInfluencer(SpawnInfluencer.class);
+		influencer.spawnShapeValue = shape;
+		widthPanel.setValue(shape.getSpawnWidth());
+		heightPanel.setValue(shape.getSpawnHeight());
+		depthPanel.setValue(shape.getSpawnDepth());
+		setEdgesVisible(showEdges);
+		if(showEdges) 
+			edgesCheckbox.setSelected(shape.isEdges());
+		if(side != null){
+			setSidesVisible(true);
+			sideCombo.setSelectedItem(side);
+		}
+		else {
+			setSidesVisible(false);
+		}
+
+		widthPanel.setVisible(true);
+		heightPanel.setVisible(true);
+		depthPanel.setVisible(true);
+		meshPanel.setVisible(false);
+	}
+	
+	protected void setMeshSpawnShape (SpawnShapeValue shape) {
+		setSpawnShapeValue(shape);
+		value.spawnShapeValue = shape;
+		setEdgesVisible(false);
+		setSidesVisible(false);
+		widthPanel.setVisible(false);
+		heightPanel.setVisible(false);
+		depthPanel.setVisible(false);
+		meshPanel.setVisible(true);
+	}
+
+	private Object spawnShapeToString (SpawnShapeValue spawnShapeValue) {
+		if(spawnShapeValue instanceof PrimitiveSpawnShapeValue){
+			if(spawnShapeValue instanceof PointSpawnShapeValue) return SPAWN_SHAPE_POINT;
+			else if(spawnShapeValue instanceof LineSpawnShapeValue) return SPAWN_SHAPE_LINE;
+			else if(spawnShapeValue instanceof RectangleSpawnShapeValue) return SPAWN_SHAPE_RECTANGLE;
+			else if(spawnShapeValue instanceof EllipseSpawnShapeValue) return SPAWN_SHAPE_ELLIPSE;
+			else if(spawnShapeValue instanceof CylinderSpawnShapeValue) return SPAWN_SHAPE_CYLINDER;
+		}
+		if(spawnShapeValue instanceof WeightMeshSpawnShapeValue){
+			return SPAWN_SHAPE_WEIGHT_MESH;
+		}
+		if(spawnShapeValue instanceof UnweightedMeshSpawnShapeValue){
+			return SPAWN_SHAPE_MESH;
+		}
+		
+		return null;
+	}
+
+	public void update (FlameMain editor) {
+		SpawnInfluencer influencer = (SpawnInfluencer)editor.getEmitter().findInfluencer(SpawnInfluencer.class);
+		shapeCombo.setSelectedItem( spawnShapeToString(influencer.spawnShapeValue));
+	}
+
+	void setEdgesVisible (boolean visible)
+	{
+		edgesCheckbox.setVisible(visible);
+		edgesLabel.setVisible(visible);
+	}
+	
+	void setSidesVisible(boolean visible)
+	{
+		sideCombo.setVisible(visible);
+		sideLabel.setVisible(visible);
+	}
+
+	protected void initializeComponents () {
+		super.initializeComponents();
+		
+		pointSpawnShapeValue = new PointSpawnShapeValue();
+		lineSpawnShapeValue = new LineSpawnShapeValue();
+		rectangleSpawnShapeValue = new RectangleSpawnShapeValue();
+		ellipseSpawnShapeValue = new EllipseSpawnShapeValue();
+		cylinderSpawnShapeValue = new CylinderSpawnShapeValue();
+		meshSpawnShapeValue = new UnweightedMeshSpawnShapeValue();
+		weightMeshSpawnShapeValue = new WeightMeshSpawnShapeValue();
+		
+		lineSpawnShapeValue.setDimensions(6, 6, 6);
+		rectangleSpawnShapeValue.setDimensions(6, 6, 6);
+		ellipseSpawnShapeValue.setDimensions(6, 6, 6);
+		cylinderSpawnShapeValue.setDimensions(6, 6, 6);
+
+		pointSpawnShapeValue.setActive(true);
+		lineSpawnShapeValue.setActive(true);
+		rectangleSpawnShapeValue.setActive(true);
+		ellipseSpawnShapeValue.setActive(true);
+		cylinderSpawnShapeValue.setActive(true);
+		meshSpawnShapeValue.setActive(true);
+		weightMeshSpawnShapeValue.setActive(true);
+		
+		Model defaultModel = editor.assetManager.get(FlameMain.DEFAULT_MODEL_PARTICLE);
+		Array<Model> models = new Array<Model>();
+		models.add(defaultModel);
+		
+		int i=0;
+		JPanel panel = new JPanel(new GridBagLayout());
+		EditorPanel.addContent(panel, i, 0, new JLabel("Shape"), false, GridBagConstraints.WEST, GridBagConstraints.NONE, 0,0);
+		EditorPanel.addContent(panel, i++,1, shapeCombo = new JComboBox(new DefaultComboBoxModel(spawnShapes)), false, GridBagConstraints.WEST, GridBagConstraints.NONE, 1,0);
+		EditorPanel.addContent(panel, i, 0, edgesLabel = new JLabel("Edges"), false, GridBagConstraints.WEST, GridBagConstraints.NONE, 0,0);	
+		EditorPanel.addContent(panel, i++, 1, edgesCheckbox = new JCheckBox(), false, GridBagConstraints.WEST, GridBagConstraints.NONE, 0,0);		
+		EditorPanel.addContent(panel, i, 0, sideLabel = new JLabel("Side"), false, GridBagConstraints.WEST, GridBagConstraints.NONE, 0,0);		
+		EditorPanel.addContent(panel, i++, 1, sideCombo = new JComboBox(new DefaultComboBoxModel(SpawnSide.values())), false, GridBagConstraints.WEST, GridBagConstraints.NONE, 1, 0);				
+		edgesCheckbox.setHorizontalTextPosition(SwingConstants.LEFT);
+
+		i=0;
+		addContent(i++, 0, panel, GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL);
+		addContent(i++, 0, meshPanel = new TemplatePickerPanel<Model>(editor, models, this, Model.class, new LoaderButton.ModelLoaderButton(editor), true, false)
+																																			, false, GridBagConstraints.WEST, GridBagConstraints.NONE);
+		addContent(i++, 0, xPanel = new RangedNumericPanel(editor, pointSpawnShapeValue.xOffsetValue, "X Offset", "Amount to offset a particle's starting X location, in world units.", false));
+		addContent(i++, 0, yPanel = new RangedNumericPanel(editor, pointSpawnShapeValue.yOffsetValue, "Y Offset", "Amount to offset a particle's starting Y location, in world units.", false));
+		addContent(i++, 0, zPanel = new RangedNumericPanel(editor, pointSpawnShapeValue.zOffsetValue, "Z Offset", "Amount to offset a particle's starting Z location, in world units.", false));
+		addContent(i++, 0, widthPanel = new ScaledNumericPanel(editor, pointSpawnShapeValue.getSpawnWidth(), "Duration", "Spawn Width", "Width of the spawn shape, in world units.", true));
+		addContent(i++, 0, heightPanel = new ScaledNumericPanel(editor, pointSpawnShapeValue.getSpawnWidth(), "Duration", "Spawn Height", "Height of the spawn shape, in world units.", true));
+		addContent(i++, 0, depthPanel = new ScaledNumericPanel(editor, pointSpawnShapeValue.getSpawnWidth(), "Duration", "Spawn Depth", "Depth of the spawn shape, in world units.", true), false);
+		
+		meshPanel.setIsAlwayShown(true);
+		onTemplateChecked(defaultModel, true);
+		
+		shapeCombo.addActionListener(new ActionListener() {
+			public void actionPerformed (ActionEvent event) {
+				String shape = (String)shapeCombo.getSelectedItem();
+				if(shape == SPAWN_SHAPE_POINT){
+					setPrimitiveSpawnShape(pointSpawnShapeValue, false, null);
+				}
+				else if(shape == SPAWN_SHAPE_LINE){
+					setPrimitiveSpawnShape(lineSpawnShapeValue, false, null);
+				}
+				else if(shape == SPAWN_SHAPE_RECTANGLE){
+					setPrimitiveSpawnShape(rectangleSpawnShapeValue, true, null);
+				}
+				else if(shape == SPAWN_SHAPE_ELLIPSE){
+					setPrimitiveSpawnShape(ellipseSpawnShapeValue, true, ellipseSpawnShapeValue.getSide());
+				}
+				else if(shape == SPAWN_SHAPE_CYLINDER){
+					setPrimitiveSpawnShape(cylinderSpawnShapeValue, true, null);
+				}
+				else if(shape == SPAWN_SHAPE_MESH){
+					setMeshSpawnShape(meshSpawnShapeValue);
+				}
+				else if(shape == SPAWN_SHAPE_WEIGHT_MESH){
+					setMeshSpawnShape(weightMeshSpawnShapeValue);
+				}
+				editor.restart();
+			}
+		});
+
+		edgesCheckbox.addActionListener(new ActionListener() {
+			public void actionPerformed (ActionEvent event) {
+				SpawnInfluencer influencer = (SpawnInfluencer)editor.getEmitter().findInfluencer(SpawnInfluencer.class);
+				PrimitiveSpawnShapeValue shapeValue = (PrimitiveSpawnShapeValue)influencer.spawnShapeValue;
+				shapeValue.setEdges(edgesCheckbox.isSelected());
+				setEdgesVisible(true);
+			}
+		});
+
+		sideCombo.addActionListener(new ActionListener() {
+			public void actionPerformed (ActionEvent event) {
+				SpawnSide side = (SpawnSide)sideCombo.getSelectedItem();
+				SpawnInfluencer influencer = (SpawnInfluencer)editor.getEmitter().findInfluencer(SpawnInfluencer.class);
+				EllipseSpawnShapeValue shapeValue = (EllipseSpawnShapeValue)influencer.spawnShapeValue;
+				shapeValue.setSide(side);
+			}
+		});
+
+	}
+
+	@Override
+	public void onTemplateChecked (Model model, boolean isChecked) {
+		//Update the shapes
+		SpawnShapeValue shapeValue = null;
+		Mesh mesh = model.meshes.get(0);
+		weightMeshSpawnShapeValue.setMesh(mesh, model);
+		meshSpawnShapeValue.setMesh(mesh, model);
+		if(shapeCombo.getSelectedItem() == SPAWN_SHAPE_WEIGHT_MESH){
+			SpawnInfluencer influencer = (SpawnInfluencer)editor.getEmitter().findInfluencer(SpawnInfluencer.class);
+			influencer.spawnShapeValue = weightMeshSpawnShapeValue;
+		}
+		else if(shapeCombo.getSelectedItem() == SPAWN_SHAPE_MESH){
+			SpawnInfluencer influencer = (SpawnInfluencer)editor.getEmitter().findInfluencer(SpawnInfluencer.class);
+			influencer.spawnShapeValue = meshSpawnShapeValue;
+		}
+		editor.restart();
+	}
+
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/StrengthVelocityPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/StrengthVelocityPanel.java
new file mode 100644
index 0000000..47f9ab3
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/StrengthVelocityPanel.java
@@ -0,0 +1,71 @@
+package com.badlogic.gdx.tools.flame;
+
+import java.awt.Dimension;
+import java.awt.GridBagConstraints;
+import java.awt.Insets;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+
+import javax.swing.JCheckBox;
+import javax.swing.JLabel;
+import javax.swing.JPanel;
+
+import com.badlogic.gdx.graphics.g3d.particles.influencers.DynamicsModifier;
+
+/** @author Inferno */
+public class StrengthVelocityPanel extends EditorPanel<DynamicsModifier.Strength> {
+
+	JCheckBox isGlobalCheckBox;
+	ScaledNumericPanel magnitudePanel;
+
+	public StrengthVelocityPanel(FlameMain editor, DynamicsModifier.Strength value, String charTitle, String name, String description) {
+		super(editor, name, description);
+		initializeComponents(charTitle);
+		setValue(value);
+	}
+
+	@Override
+	public void setValue (DynamicsModifier.Strength value) {
+		super.setValue(value);
+		if(value == null) return;
+		setValue(isGlobalCheckBox, this.value.isGlobal);
+		magnitudePanel.setValue(value.strengthValue);
+	}
+
+	private void initializeComponents(String charTitle) 
+	{
+		JPanel contentPanel = getContentPanel();
+		{
+			JPanel panel = new JPanel();
+			panel.add(new JLabel("Global"), new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+				new Insets(0, 0, 0, 0), 0, 0));
+			panel.add(isGlobalCheckBox = new JCheckBox(), new GridBagConstraints(1, 0, 1, 1, 0, 0, 
+				GridBagConstraints.WEST, GridBagConstraints.NONE,
+				new Insets(0, 0, 0, 0), 0, 0));
+			contentPanel.add(panel,new GridBagConstraints(0, 1, 1, 1, 0, 0, 
+				GridBagConstraints.WEST, GridBagConstraints.NONE,
+				new Insets(0, 0, 0, 0), 0, 0));
+		}
+		{
+			contentPanel.add( magnitudePanel = new ScaledNumericPanel(editor, null, charTitle, "Strength", "In world units per second.", true), 
+				new GridBagConstraints(0, 2, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+					new Insets(0, 0, 0, 6), 0, 0));
+		}
+		{
+			JPanel spacer = new JPanel();
+			spacer.setPreferredSize(new Dimension());
+			contentPanel.add(spacer, new GridBagConstraints(6, 0, 1, 1, 1, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+				new Insets(0, 0, 0, 0), 0, 0));
+		}
+
+		magnitudePanel.setIsAlwayShown(true);
+
+		isGlobalCheckBox.addActionListener(new ActionListener() {
+			@Override
+			public void actionPerformed (ActionEvent e) {
+				StrengthVelocityPanel.this.value.isGlobal = isGlobalCheckBox.isSelected();
+			}
+		});	
+	}
+
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/TemplatePickerPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/TemplatePickerPanel.java
new file mode 100644
index 0000000..30c8906
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/TemplatePickerPanel.java
@@ -0,0 +1,185 @@
+package com.badlogic.gdx.tools.flame;
+
+import java.awt.Dimension;
+import java.awt.GridBagConstraints;
+import java.awt.Insets;
+
+import javax.swing.JScrollPane;
+import javax.swing.JTable;
+import javax.swing.ListSelectionModel;
+import javax.swing.event.TableModelEvent;
+import javax.swing.event.TableModelListener;
+import javax.swing.table.DefaultTableModel;
+
+import com.badlogic.gdx.utils.Array;
+
+/** @author Inferno */
+public class TemplatePickerPanel<T> extends EditorPanel<Array<T>> implements LoaderButton.Listener<T> {
+
+	public interface Listener<T> {
+		void onTemplateChecked(T template, boolean isChecked);
+	}
+
+	Array<T> loadedTemplates;
+	Array<T> excludedTemplates;
+	Class<T> type;
+	JTable templatesTable;
+	DefaultTableModel templatesTableModel;
+	boolean 	isOneModelSelectedRequired = true, 
+				isMultipleSelectionAllowed = true;
+	Listener listener;
+	int lastSelected = -1;
+	
+	public TemplatePickerPanel (FlameMain editor, Array<T> value, Listener listener, Class<T> type){
+		this(editor, value, listener, type, null, true, true);
+	}
+	
+	public TemplatePickerPanel (FlameMain editor, Array<T> value, Listener listener, Class<T> type, LoaderButton<T> loaderButton){
+		this(editor, value, listener, type, loaderButton, true, true);
+	}
+
+	public TemplatePickerPanel (FlameMain editor, Array<T> value, Listener listener, Class<T> type, 
+									LoaderButton<T> loaderButton, boolean isOneModelSelectedRequired, boolean isMultipleSelectionAllowed) {
+		super(editor, "", "");
+		this.type = type;
+		this.listener = listener;
+		this.isOneModelSelectedRequired = isOneModelSelectedRequired;
+		this.isMultipleSelectionAllowed = isMultipleSelectionAllowed;
+		loadedTemplates = new Array<T>();
+		excludedTemplates = new Array<T>();
+		initializeComponents(type, loaderButton);
+		setValue(value);
+	}
+	
+	@Override
+	public void setValue (Array<T> value) {
+		super.setValue(value);
+		if(value == null) return;
+		if(!isMultipleSelectionAllowed && value.size >1)
+			throw new RuntimeException("Multiple selection must be enabled to ensure consistency between picked and available models.");
+		for(int i=0; i < value.size;++i ){
+			T model  = value.get(i);
+			int index = loadedTemplates.indexOf(model, true);
+			if(index >-1){
+				EditorPanel.setValue(templatesTableModel, true, index, 1);
+				lastSelected = index;
+			}
+		}
+	}
+	
+	public void setOneModelSelectionRequired(boolean isOneModelSelectionRequired){
+		this.isOneModelSelectedRequired = isOneModelSelectionRequired;
+	}
+	
+	public void setMultipleSelectionAllowed(boolean isMultipleSelectionAllowed){
+		this.isMultipleSelectionAllowed = isMultipleSelectionAllowed;
+	}
+	
+	public void setExcludedTemplates(Array<T> excludedTemplates){
+		this.excludedTemplates.clear();
+		this.excludedTemplates.addAll(excludedTemplates);
+	}
+	
+	public void setLoadedTemplates(Array<T> templates){
+		loadedTemplates.clear();
+		loadedTemplates.addAll(templates);
+		loadedTemplates.removeAll(excludedTemplates, true);
+		templatesTableModel.getDataVector().removeAllElements();
+		int i=0;
+		for(T template : templates){
+			templatesTableModel.addRow(new Object[] {getTemplateName(template, i), false});
+			i++;
+		}
+		lastSelected = -1;
+		setValue(value);
+	}
+	
+	protected String getTemplateName(T template, int index){
+		String name = editor.assetManager.getAssetFileName(template);
+		return name == null ? "template "+index:name; 
+	}
+	
+
+	public void reloadTemplates () {
+		setLoadedTemplates(editor.assetManager.getAll(type,  new Array<T>()));
+	}
+	
+	protected void initializeComponents (Class<T> type, LoaderButton<T> loaderButton) {
+		int i=0;
+		if(loaderButton != null){
+			loaderButton.setListener(this);
+			contentPanel.add(loaderButton, new GridBagConstraints(0, i++, 1, 1, 1, 0, GridBagConstraints.CENTER, GridBagConstraints.BOTH, new Insets(0,
+				0, 0, 6), 0, 0));
+		}
+		
+		JScrollPane scroll = new JScrollPane();
+		contentPanel.add(scroll, new GridBagConstraints(0, i, 1, 1, 1, 0, GridBagConstraints.CENTER, GridBagConstraints.BOTH, new Insets(0,
+			0, 0, 6), 0, 0));
+		{
+			templatesTable = new JTable() {
+				public Class getColumnClass (int column) {
+					return column == 1 ? Boolean.class : super.getColumnClass(column);
+				}
+				@Override
+				public Dimension getPreferredScrollableViewportSize () {
+					Dimension dim = super.getPreferredScrollableViewportSize();
+					dim.height = getPreferredSize().height;
+					return dim;
+				}
+			};
+			templatesTable.getTableHeader().setReorderingAllowed(false);
+			templatesTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+			scroll.setViewportView(templatesTable);
+			templatesTableModel = new DefaultTableModel(new String[0][0], new String[] {"Template", "Selected"});
+			templatesTable.setModel(templatesTableModel);
+			reloadTemplates();
+			
+			templatesTableModel.addTableModelListener(new TableModelListener() {
+				public void tableChanged (TableModelEvent event) {
+					if (event.getColumn() != 1) return;
+					int row = event.getFirstRow();
+					boolean checked = (Boolean)templatesTable.getValueAt(row, 1);
+					if( isOneModelSelectedRequired && (value.size == 1 && !checked) ){
+						EditorPanel.setValue(templatesTableModel, true, row, 1);
+						return;
+					}
+						
+					templateChecked(row, checked);
+				}
+			});
+		}
+	}
+
+	protected void templateChecked (int index, Boolean isChecked) {
+		T template = loadedTemplates.get(index);
+		if(isChecked){
+			if(!isMultipleSelectionAllowed){
+				if(lastSelected >-1){
+					value.removeValue(loadedTemplates.get(lastSelected), true);
+					EditorPanel.setValue(templatesTableModel, false, lastSelected, 1);
+				}
+			}
+			value.add(template);
+			lastSelected = index;
+		}
+		else {
+			value.removeValue(template, true);
+		}
+		listener.onTemplateChecked(template, isChecked);
+	}
+
+	@Override
+	public void onResourceLoaded (T model) {
+		reloadTemplates();
+		if(lastSelected == -1 && isOneModelSelectedRequired){
+			templateChecked(loadedTemplates.size-1, true);
+		}
+		else {
+			setValue(value);
+		}
+
+		revalidate();
+		repaint();
+	}
+
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/TextureAtlasPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/TextureAtlasPanel.java
new file mode 100644
index 0000000..b5e6d38
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/TextureAtlasPanel.java
@@ -0,0 +1,100 @@
+package com.badlogic.gdx.tools.flame;
+
+import java.awt.Component;
+import java.awt.GridBagConstraints;
+import java.awt.GridBagLayout;
+import java.awt.Insets;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+
+import javax.swing.JButton;
+import javax.swing.JPanel;
+
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.g2d.TextureAtlas;
+import com.badlogic.gdx.graphics.g2d.TextureAtlas.AtlasRegion;
+import com.badlogic.gdx.graphics.g2d.TextureRegion;
+import com.badlogic.gdx.graphics.glutils.FileTextureData;
+import com.badlogic.gdx.utils.Array;
+
+/** @author Inferno */
+public class TextureAtlasPanel extends JPanel {
+	JPanel regionsPanel;
+	TextureAtlas atlas;
+	
+	public TextureAtlasPanel(){
+		initializeComponents();
+	}
+
+	private void initializeComponents () {
+		setLayout(new GridBagLayout());
+		JButton backwardButton, forwardButton;
+		
+		add(backwardButton = new JButton("<"), new GridBagConstraints(0, 0, 1, 1, 1, 1, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL,
+			new Insets(0, 0, 0, 0), 0, 0));
+		add(regionsPanel = new JPanel(), new GridBagConstraints(1, 0, 1, 1, 1, 1, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL,
+			new Insets(0, 0, 0, 0), 0, 0));
+		add(forwardButton = new JButton(">"), new GridBagConstraints(2, 0, 1, 1, 1, 1, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL,
+			new Insets(0, 0, 0, 0), 0, 0));
+		
+		regionsPanel.setLayout(new CustomCardLayout());
+		
+		backwardButton.addActionListener(new ActionListener() {
+			@Override
+			public void actionPerformed (ActionEvent arg0) {
+				if(atlas == null) return;
+				CustomCardLayout layout = (CustomCardLayout)regionsPanel.getLayout();
+				layout.previous(regionsPanel);
+			}
+		});
+		
+		forwardButton.addActionListener(new ActionListener() {
+			@Override
+			public void actionPerformed (ActionEvent arg0) {
+				if(atlas == null) return;
+				CustomCardLayout layout = (CustomCardLayout)regionsPanel.getLayout();
+				layout.next(regionsPanel);
+			}
+		});	
+	}
+	
+	public void setAtlas(TextureAtlas atlas){
+		if(atlas == this.atlas) return;
+		regionsPanel.removeAll();
+		 Array<AtlasRegion> atlasRegions = atlas.getRegions();
+		 CustomCardLayout layout = (CustomCardLayout)regionsPanel.getLayout();
+		Array<TextureRegion> regions = new Array<TextureRegion>();
+		for(Texture texture : atlas.getTextures()){
+			FileTextureData file = (FileTextureData)texture.getTextureData();
+			regionsPanel.add(new TexturePanel( texture, getRegions(texture, atlasRegions, regions)));
+		}
+		layout.first(regionsPanel);
+		this.atlas = atlas;
+	}
+	
+	protected Array<TextureRegion> getRegions (Texture texture, Array<AtlasRegion> atlasRegions, Array<TextureRegion> out) {
+		out.clear();
+		for(TextureRegion region : atlasRegions){
+			if(region.getTexture() == texture)
+				out.add(region);
+		}
+		return out;
+	}
+
+	public Array<TextureRegion> getSelectedRegions () {
+		CustomCardLayout layout = (CustomCardLayout)regionsPanel.getLayout();
+		TexturePanel panel = getCurrentRegionPanel();
+		return panel.selectedRegions;
+	}
+	
+	public TexturePanel getCurrentRegionPanel(){
+		CustomCardLayout layout = (CustomCardLayout)regionsPanel.getLayout();
+		return layout.getCurrentCard(regionsPanel);
+	}
+
+	public void clearSelection () {
+		for(Component regionPanel : regionsPanel.getComponents())
+			((TexturePanel)regionPanel).clearSelection();
+	}
+	
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/TextureLoaderPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/TextureLoaderPanel.java
new file mode 100644
index 0000000..0b259b4
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/TextureLoaderPanel.java
@@ -0,0 +1,104 @@
+package com.badlogic.gdx.tools.flame;
+
+import java.awt.GridBagConstraints;
+import java.awt.Insets;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.io.File;
+
+import javax.swing.DefaultComboBoxModel;
+import javax.swing.JButton;
+import javax.swing.JCheckBox;
+import javax.swing.JComboBox;
+import javax.swing.JLabel;
+
+import com.badlogic.gdx.assets.loaders.TextureLoader.TextureParameter;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.Texture.TextureFilter;
+import com.badlogic.gdx.graphics.g2d.TextureAtlas;
+
+/** @author Inferno */
+public class TextureLoaderPanel extends EditorPanel {
+	public TextureLoaderPanel (FlameMain editor, String name, String description) {
+		super(editor, name, description);
+		setValue(null);
+	}
+
+	@Override
+	protected void initializeComponents () {
+		super.initializeComponents();
+		JButton atlasButton = new JButton("Open Atlas");
+		JButton textureButton = new JButton("Open Texture");
+		JButton defaultTextureButton = new JButton("Default Texture");
+		final JCheckBox genMipMaps = new JCheckBox("Generate MipMaps");
+		final JComboBox minFilterBox = new JComboBox(new DefaultComboBoxModel(TextureFilter.values()));
+		final JComboBox magFilterBox = new JComboBox(new DefaultComboBoxModel(TextureFilter.values()));
+
+		minFilterBox.setSelectedItem(editor.getTexture().getMinFilter());
+		magFilterBox.setSelectedItem(editor.getTexture().getMagFilter());
+		
+		ActionListener filterListener = new ActionListener() {
+			public void actionPerformed (ActionEvent event) {
+				editor.getTexture().setFilter((TextureFilter)minFilterBox.getSelectedItem(), (TextureFilter)magFilterBox.getSelectedItem());
+			}
+		};
+		
+		minFilterBox.addActionListener(filterListener);
+		magFilterBox.addActionListener(filterListener);
+		
+		atlasButton.addActionListener(new ActionListener() {
+			@Override
+			public void actionPerformed (ActionEvent e) {
+				File file = editor.showFileLoadDialog();
+				if(file != null){
+					TextureAtlas atlas = editor.load(file.getAbsolutePath(), TextureAtlas.class, null,  null);
+					if(atlas != null){
+						editor.setAtlas(atlas);
+					}
+				}
+			}
+		});
+		
+		textureButton.addActionListener(new ActionListener() {
+			@Override
+			public void actionPerformed (ActionEvent e) {
+				File file = editor.showFileLoadDialog();
+				if(file != null){
+					TextureParameter params = new TextureParameter();
+					params.genMipMaps = genMipMaps.isSelected();
+					params.minFilter = (TextureFilter)minFilterBox.getSelectedItem();
+					params.magFilter = (TextureFilter)magFilterBox.getSelectedItem();
+					Texture texture = editor.load(file.getAbsolutePath(), Texture.class, null, params);
+					if(texture != null){
+						editor.setTexture(texture);
+					}
+				}
+			}
+		});
+		
+		defaultTextureButton.addActionListener(new ActionListener() {
+			@Override
+			public void actionPerformed (ActionEvent e) {
+				editor.setTexture(editor.assetManager.get(FlameMain.DEFAULT_BILLBOARD_PARTICLE, Texture.class));
+			}
+		});
+		
+		contentPanel.add(new JLabel("Min. Filter"), new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+			new Insets(6, 0, 0, 0), 0, 0));
+		contentPanel.add(minFilterBox, new GridBagConstraints(1, 0, 1, 1, 1, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+			new Insets(6, 0, 0, 0), 0, 0));
+		contentPanel.add(new JLabel("Mag. Filter"), new GridBagConstraints(0, 1, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+			new Insets(6, 0, 0, 0), 0, 0));
+		contentPanel.add(magFilterBox, new GridBagConstraints(1, 1, 1, 1, 1, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+			new Insets(6, 0, 0, 0), 0, 0));
+		contentPanel.add(genMipMaps, new GridBagConstraints(0, 2, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+			new Insets(6, 0, 0, 0), 0, 0));
+		contentPanel.add(atlasButton, new GridBagConstraints(0, 3, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+			new Insets(6, 0, 0, 0), 0, 0));
+		contentPanel.add(textureButton, new GridBagConstraints(1, 3, 1, 1, 1, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+			new Insets(6, 0, 0, 0), 0, 0));
+		contentPanel.add(defaultTextureButton, new GridBagConstraints(2, 3, 1, 1, 1, 0, GridBagConstraints.WEST, GridBagConstraints.NONE,
+			new Insets(6, 0, 0, 0), 0, 0));
+		
+	}
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/TexturePanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/TexturePanel.java
new file mode 100644
index 0000000..3dbd024
--- /dev/null
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/flame/TexturePanel.java
@@ -0,0 +1,138 @@
+package com.badlogic.gdx.tools.flame;
+
+import java.awt.Color;
+import java.awt.Graphics;
+import java.awt.Rectangle;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.g2d.TextureRegion;
+import com.badlogic.gdx.graphics.glutils.FileTextureData;
+import com.badlogic.gdx.utils.Array;
+
+/** @author Inferno */
+public class TexturePanel extends ImagePanel {
+	private Color 	selectedColor = Color.GREEN, 
+						unselectedColor = Color.BLUE,
+						indexBackgroundColor = Color.BLACK,
+						indexColor = Color.WHITE;
+	Array<TextureRegion> selectedRegions;
+	Array<TextureRegion> unselectedRegions;
+	Texture texture;
+	
+	public TexturePanel(){
+		selectedRegions = new Array<TextureRegion>();
+		unselectedRegions = new Array<TextureRegion>();
+		
+		addMouseListener(new MouseAdapter() {
+			public void mouseClicked (MouseEvent event) {
+				float x = event.getX(), y = event.getY();
+				for(TextureRegion region : unselectedRegions){
+					if(isInsideRegion(region, x, y)){
+						select(region);
+						return;
+					}
+				}
+				
+				for(TextureRegion region : selectedRegions){
+					if(isInsideRegion(region, x, y)){
+						unselect(region);
+						return;
+					}
+				}
+			}
+		});
+	}
+	
+	protected boolean isInsideRegion (TextureRegion region, float x, float y) {
+		float rx = region.getRegionX(), ry = region.getRegionY();
+		return 	rx <= x && x <= rx +region.getRegionWidth() &&
+					ry <= y && y <= ry +region.getRegionHeight();
+	}
+
+	public TexturePanel(Texture texture, Array<TextureRegion> regions){
+		this();
+		setTexture(texture);
+		setRegions(regions);
+	}
+	
+	public void setTexture(Texture texture){
+		if(this.texture == texture) return;
+		this.texture = texture;
+		FileTextureData data = (FileTextureData)texture.getTextureData();
+		setImage(data.getFileHandle().file().getAbsolutePath());
+	}
+	
+	public Texture getTexture(){
+		return texture;
+	}
+	
+	public void clear(){
+		selectedRegions.clear();
+		unselectedRegions.clear();
+	}
+	
+	public void clearSelection(){
+		unselectedRegions.addAll(selectedRegions);
+		selectedRegions.clear();
+		repaint();
+	}
+	
+	public void setRegions(Array<TextureRegion> regions){
+		unselectedRegions.clear();
+		selectedRegions.clear();
+		unselectedRegions.addAll(regions);
+	}
+	
+	private void swap(TextureRegion region, Array<TextureRegion> src, Array<TextureRegion> dst)
+	{
+		int index = src.indexOf(region, true);
+		if(index > -1){
+			src.removeIndex(index);
+			dst.add(region);
+			repaint();
+		}
+	}
+	
+	public void select(TextureRegion region){
+		swap(region, unselectedRegions, selectedRegions);
+	}
+	
+	public void unselect(TextureRegion region){
+		swap(region, selectedRegions, unselectedRegions);
+	}
+	
+	public void selectAll () {
+		selectedRegions.addAll(unselectedRegions);
+		unselectedRegions.clear();
+		repaint();
+	}
+
+	
+	@Override
+	protected void paintComponent (Graphics g) {
+		super.paintComponent(g);
+		draw(g, unselectedRegions, unselectedColor, false);
+		draw(g, selectedRegions, selectedColor, true);
+	}
+
+	private void draw (Graphics g, Array<TextureRegion> regions, Color color, boolean drawIndex) {
+		int i=0;
+		for(TextureRegion region : regions){
+			int x = region.getRegionX(), y = region.getRegionY(),
+				h = region.getRegionHeight();
+			if(drawIndex){
+				String indexString = ""+i;
+				Rectangle bounds = g.getFontMetrics().getStringBounds(indexString, g).getBounds();
+				g.setColor(indexBackgroundColor);
+				g.fillRect(x, y+h-bounds.height, bounds.width, bounds.height);
+				g.setColor(indexColor);
+				g.drawString(indexString, x, y+h);
+				++i;
+			}
+			g.setColor(color);
+			g.drawRect(x, y, region.getRegionWidth(), h);
+		}
+	}
+}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/particleeditor/Chart.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/particleeditor/Chart.java
index a986405..621a784 100644
--- a/extensions/gdx-tools/src/com/badlogic/gdx/tools/particleeditor/Chart.java
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/particleeditor/Chart.java
@@ -30,7 +30,7 @@ import java.util.ArrayList;
 
 import javax.swing.JPanel;
 
-class Chart extends JPanel {
+public class Chart extends JPanel {
 	static private final int POINT_SIZE = 6;
 	static private final int POINT_SIZE_EXPANDED = 10;
 
@@ -60,7 +60,7 @@ class Chart extends JPanel {
 
 			public void mouseClicked (MouseEvent event) {
 				if (event.getClickCount() == 2) {
-					if (overIndex <= 0) return;
+					if (overIndex <= 0 || overIndex >= points.size()) return;
 					points.remove(overIndex);
 					pointsChanged();
 					repaint();
@@ -96,7 +96,7 @@ class Chart extends JPanel {
 		});
 		addMouseMotionListener(new MouseMotionListener() {
 			public void mouseDragged (MouseEvent event) {
-				if (movingIndex == -1) return;
+				if (movingIndex == -1 || movingIndex >= points.size()) return;
 				float nextX = movingIndex == points.size() - 1 ? maxX : points.get(movingIndex + 1).x - 0.001f;
 				if (movingIndex == 0) nextX = 0;
 				float prevX = movingIndex == 0 ? 0 : points.get(movingIndex - 1).x + 0.001f;
@@ -339,4 +339,8 @@ class Chart extends JPanel {
 	public void setExpanded (boolean isExpanded) {
 		this.isExpanded = isExpanded;
 	}
+	
+	public void setTitle(String title){
+		this.title = title;
+	}
 }
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/TextureUnpacker.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/TextureUnpacker.java
index 42bad08..82797e4 100644
--- a/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/TextureUnpacker.java
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/TextureUnpacker.java
@@ -169,13 +169,19 @@ public class TextureUnpacker {
 		g2.setColor(Color.BLACK);
 
 		// Draw the four lines to save the ninepatch's padding and splits
-		g2.drawLine(region.splits[0] + NINEPATCH_PADDING, 0, region.width - region.splits[1] + NINEPATCH_PADDING - 1, 0);
-		g2.drawLine(0, region.splits[2] + NINEPATCH_PADDING, 0, region.height - region.splits[3] + NINEPATCH_PADDING - 1);
+		int startX = region.splits[0] + NINEPATCH_PADDING;
+		int endX = region.width - region.splits[1] + NINEPATCH_PADDING - 1;
+		int startY = region.splits[2] + NINEPATCH_PADDING;
+		int endY = region.height - region.splits[3] + NINEPATCH_PADDING - 1;
+		if (endX >= startX) g2.drawLine(startX, 0, endX, 0);
+		if (endY >= startY) g2.drawLine(0, startY, 0, endY);
 		if (region.pads != null) {
-			g2.drawLine(region.pads[0] + NINEPATCH_PADDING, splitImage.getHeight() - 1, splitImage.getWidth() - region.pads[1]
-				+ NINEPATCH_PADDING - 1, splitImage.getHeight() - 1);
-			g2.drawLine(splitImage.getWidth() - 1, region.pads[2] + NINEPATCH_PADDING, splitImage.getWidth() - 1,
-				splitImage.getHeight() - region.pads[3] + NINEPATCH_PADDING - 1);
+			int padStartX = region.pads[0] + NINEPATCH_PADDING;
+			int padEndX = region.width - region.pads[1] + NINEPATCH_PADDING - 1;
+			int padStartY = region.pads[2] + NINEPATCH_PADDING;
+			int padEndY = region.height - region.pads[3] + NINEPATCH_PADDING - 1;
+			g2.drawLine(padStartX, splitImage.getHeight() - 1, padEndX, splitImage.getHeight() - 1);
+			g2.drawLine(splitImage.getWidth() - 1, padStartY, splitImage.getWidth() - 1, padEndY);
 		}
 		g2.dispose();
 
diff --git a/gdx/jni/maven/pom.xml b/gdx/jni/maven/pom.xml
index a79c675..8f9585b 100644
--- a/gdx/jni/maven/pom.xml
+++ b/gdx/jni/maven/pom.xml
@@ -4,7 +4,7 @@
     <parent>
         <groupId>com.badlogicgames.gdx</groupId>
         <artifactId>gdx-parent</artifactId>
-        <version>1.1.1-SNAPSHOT</version>
+        <version>1.2.1-SNAPSHOT</version>
         <relativePath>../../..</relativePath>
     </parent>
     
diff --git a/gdx/pom.xml b/gdx/pom.xml
index 94f2ae1..2cbbeaa 100644
--- a/gdx/pom.xml
+++ b/gdx/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>gdx</artifactId>
diff --git a/gdx/src/com/badlogic/gdx.gwt.xml b/gdx/src/com/badlogic/gdx.gwt.xml
index 4d769bb..3ffbd14 100644
--- a/gdx/src/com/badlogic/gdx.gwt.xml
+++ b/gdx/src/com/badlogic/gdx.gwt.xml
@@ -1,6 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <module rename-to="com.badlogic.gdx">
-	<inherits name="com.esotericsoftware.TableLayout"/>
 	<source path="gdx">
 	    
 	<!--  --> 
@@ -169,7 +168,10 @@
 		<include name="graphics/g3d/model/data/ModelNodeKeyframe.java"/>
 		<include name="graphics/g3d/model/data/ModelNodePart.java"/>
 		<include name="graphics/g3d/model/data/ModelTexture.java"/>
-				
+	
+	<!-- graphics/g3d/particles -->
+		<include name="graphics/g3d/particles/**/*.java"/>
+		
 	<!-- graphics/g3d/shaders -->
 		<include name="graphics/g3d/shaders/BaseShader.java"/>
 		<include name="graphics/g3d/shaders/DefaultShader.java"/>
@@ -219,7 +221,13 @@
 		<include name="graphics/glutils/VertexBufferObject.java"/> <!-- Emulated -->
 		<include name="graphics/glutils/VertexBufferObjectSubData.java"/>
 		<include name="graphics/glutils/VertexData.java"/>
+
+	<!-- graphics/profiling -->
+		<include name="graphics/profiling/GL20Profiler.java"/>
+		<include name="graphics/profiling/GL30Profiler.java"/>
+		<include name="graphics/profiling/GLProfiler.java"/>
 		
+						
 	<!-- input -->
 		<include name="input/GestureDetector.java"/>
 		<exclude name="input/RemoteInput.java"/> <!-- Reason: Networking -->
@@ -274,6 +282,7 @@
 		<include name="math/CatmullRomSpline.java"/>
 		<include name="math/Circle.java"/>
 		<include name="math/ConvexHull.java"/>
+		<include name="math/CumulativeDistribution.java"/>
 		<include name="math/DelaunayTriangulator.java"/>
 		<include name="math/EarClippingTriangulator.java"/>
 		<include name="math/Ellipse.java"/>
@@ -438,6 +447,8 @@
 	</source>
 
 	<define-configuration-property name="gdx.files.classpath" is-multi-valued="true" />
+	<extend-configuration-property name="gdx.files.classpath" value="com/badlogic/gdx/graphics/g3d/particles/particles.fragment.glsl" />
+	<extend-configuration-property name="gdx.files.classpath" value="com/badlogic/gdx/graphics/g3d/particles/particles.vertex.glsl" />
 	<extend-configuration-property name="gdx.files.classpath" value="com/badlogic/gdx/graphics/g3d/shaders/default.fragment.glsl" />
 	<extend-configuration-property name="gdx.files.classpath" value="com/badlogic/gdx/graphics/g3d/shaders/default.vertex.glsl" />
 	<extend-configuration-property name="gdx.files.classpath" value="com/badlogic/gdx/graphics/g3d/shaders/depth.fragment.glsl" />
diff --git a/gdx/src/com/badlogic/gdx/Version.java b/gdx/src/com/badlogic/gdx/Version.java
index ad47e59..ad2f535 100644
--- a/gdx/src/com/badlogic/gdx/Version.java
+++ b/gdx/src/com/badlogic/gdx/Version.java
@@ -23,7 +23,7 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
  * @author mzechner */
 public class Version {
 	/** the current version of libgdx as a String in the major.minor.revision format **/
-	public static final String VERSION = "1.1.1";
+	public static final String VERSION = "1.2.1";
 
 	/** the current major version of libgdx **/
 	public static final int MAJOR;
diff --git a/gdx/src/com/badlogic/gdx/assets/loaders/ParticleEffectLoader.java b/gdx/src/com/badlogic/gdx/assets/loaders/ParticleEffectLoader.java
index 6d6ab2d..b3c3ea2 100644
--- a/gdx/src/com/badlogic/gdx/assets/loaders/ParticleEffectLoader.java
+++ b/gdx/src/com/badlogic/gdx/assets/loaders/ParticleEffectLoader.java
@@ -59,8 +59,8 @@ public class ParticleEffectLoader extends SynchronousAssetLoader<ParticleEffect,
 	public static class ParticleEffectParameter extends AssetLoaderParameters<ParticleEffect> {
 		/** Atlas file name. */
 		public String atlasFile;
-		/** Prefix to be added to the image names **/
-		public String atlasPrefix = "";
+		/** Optional prefix to image names **/
+		public String atlasPrefix;
 		/** Image directory. */
 		public FileHandle imagesDir;
 	}
diff --git a/gdx/src/com/badlogic/gdx/audio/Music.java b/gdx/src/com/badlogic/gdx/audio/Music.java
index e86ffa1..9cdabc4 100644
--- a/gdx/src/com/badlogic/gdx/audio/Music.java
+++ b/gdx/src/com/badlogic/gdx/audio/Music.java
@@ -23,7 +23,7 @@ import com.badlogic.gdx.files.FileHandle;
 import com.badlogic.gdx.utils.Disposable;
 
 /** <p>
- * A Music instance represents a streamed audio file. The interface supports setting the play back position, pausing and resuming
+ * A Music instance represents a streamed audio file. The interface supports pausing, resuming
  * and so on. When you are done with using the Music instance you have to dispose it via the {@link #dispose()} method.
  * </p>
  * 
diff --git a/gdx/src/com/badlogic/gdx/graphics/Mesh.java b/gdx/src/com/badlogic/gdx/graphics/Mesh.java
index 5d96d79..0d80f6d 100644
--- a/gdx/src/com/badlogic/gdx/graphics/Mesh.java
+++ b/gdx/src/com/badlogic/gdx/graphics/Mesh.java
@@ -219,21 +219,23 @@ public class Mesh implements Disposable {
 
 		meshes[0].getVertices(vertices);
 		meshes[0].getIndices(indices);
-
-		int voffset = meshes[0].getNumVertices() * vertexSize;
+		int vcount = meshes[0].getNumVertices();
+		if (transformations != null)
+			transform(transformations[0], vertices, vertexSize, offset, numComponents, 0, vcount);
+		int voffset = vcount;
 		int ioffset = meshes[0].getNumIndices();
 		for (int i = 1; i < meshes.length; i++) {
 			final Mesh mesh = meshes[i];
-			final int vsize = mesh.getNumVertices() * vertexSize;
+			vcount = mesh.getNumVertices();
 			final int isize = mesh.getNumIndices();
-			mesh.getVertices(0, vsize, vertices, voffset);
+			mesh.getVertices(0, vcount * vertexSize, vertices, voffset * vertexSize);
 			if (transformations != null)
-				transform(transformations[i], vertices, vertexSize, offset, numComponents, voffset / vertexSize, vsize / vertexSize);
+				transform(transformations[i], vertices, vertexSize, offset, numComponents, voffset, vcount);
 			mesh.getIndices(indices, ioffset);
 			for (int j = 0; j < isize; j++)
 				indices[ioffset + j] = (short)(indices[ioffset + j] + voffset);
-			voffset += vsize;
 			ioffset += isize;
+			voffset += vcount;
 		}
 
 		final Mesh result = new Mesh(isStatic, vertices.length / vertexSize, indices.length, attributes);
diff --git a/gdx/src/com/badlogic/gdx/graphics/VertexAttribute.java b/gdx/src/com/badlogic/gdx/graphics/VertexAttribute.java
index 01fde2e..298e632 100644
--- a/gdx/src/com/badlogic/gdx/graphics/VertexAttribute.java
+++ b/gdx/src/com/badlogic/gdx/graphics/VertexAttribute.java
@@ -30,6 +30,10 @@ public final class VertexAttribute {
 	public final int usage;
 	/** the number of components this attribute has **/
 	public final int numComponents;
+	/** whether the values are normalized to either -1f and +1f (signed) or 0f and +1f (unsigned) */
+	public final boolean normalized;
+	/** the OpenGL type of each component, e.g. {@link GL20#GL_FLOAT} or {@link GL20#GL_UNSIGNED_BYTE}  */
+	public final int type;
 	/** the offset of this attribute in bytes, don't change this! **/
 	public int offset;
 	/** the alias for the attribute used in a {@link ShaderProgram} **/
@@ -56,11 +60,22 @@ public final class VertexAttribute {
 	 * @param alias the alias used in a shader for this attribute. Can be changed after construction.
 	 * @param index unit/index of the attribute, used for boneweights and texture coordinates. */
 	public VertexAttribute (int usage, int numComponents, String alias, int index) {
+		this(usage, numComponents, usage == Usage.ColorPacked ? GL20.GL_UNSIGNED_BYTE : GL20.GL_FLOAT, 
+				usage == Usage.ColorPacked, alias, index);
+	}
+	
+	private VertexAttribute (int usage, int numComponents, int type, boolean normalized, String alias) {
+		this(usage, numComponents, type, normalized, alias, 0);
+	}
+	
+	private VertexAttribute (int usage, int numComponents, int type, boolean normalized, String alias, int index) {
 		this.usage = usage;
 		this.numComponents = numComponents;
+		this.type = type;
+		this.normalized = normalized;
 		this.alias = alias;
 		this.unit = index;
-		this.usageIndex = Integer.numberOfTrailingZeros(usage);
+		this.usageIndex = Integer.numberOfTrailingZeros(usage);	
 	}
 
 	public static VertexAttribute Position () {
@@ -75,12 +90,18 @@ public final class VertexAttribute {
 		return new VertexAttribute(Usage.Normal, 3, ShaderProgram.NORMAL_ATTRIBUTE);
 	}
 
+	/** @deprecated use {@link #ColorPacked()} */
+	@Deprecated
 	public static VertexAttribute Color () {
-		return new VertexAttribute(Usage.ColorPacked, 4, ShaderProgram.COLOR_ATTRIBUTE);
+		return ColorPacked();
+	}
+	
+	public static VertexAttribute ColorPacked () {
+		return new VertexAttribute(Usage.ColorPacked, 4, GL20.GL_UNSIGNED_BYTE, true, ShaderProgram.COLOR_ATTRIBUTE);
 	}
 
 	public static VertexAttribute ColorUnpacked () {
-		return new VertexAttribute(Usage.Color, 4, ShaderProgram.COLOR_ATTRIBUTE);
+		return new VertexAttribute(Usage.Color, 4, GL20.GL_FLOAT, false, ShaderProgram.COLOR_ATTRIBUTE);
 	}
 
 	public static VertexAttribute Tangent () {
@@ -113,4 +134,12 @@ public final class VertexAttribute {
 	public int getKey () {
 		return (usageIndex << 8) + (unit & 0xFF);
 	}
+	
+	@Override
+	public int hashCode () {
+		int result = getKey();
+		result = 541 * result + numComponents;
+		result = 541 * result + alias.hashCode();
+		return result; 
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleEffect.java b/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleEffect.java
index 31a9b15..c5ee36b 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleEffect.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleEffect.java
@@ -139,6 +139,10 @@ public class ParticleEffect implements Disposable {
 		loadEmitterImages(imagesDir);
 	}
 
+	public void load (FileHandle effectFile, TextureAtlas atlas) {
+		load(effectFile, atlas, null);
+	}
+
 	public void load (FileHandle effectFile, TextureAtlas atlas, String atlasPrefix) {
 		loadEmitters(effectFile);
 		loadEmitterImages(atlas, atlasPrefix);
@@ -165,6 +169,10 @@ public class ParticleEffect implements Disposable {
 		}
 	}
 
+	public void loadEmitterImages (TextureAtlas atlas) {
+		loadEmitterImages(atlas, null);
+	}
+
 	public void loadEmitterImages (TextureAtlas atlas, String atlasPrefix) {
 		for (int i = 0, n = emitters.size; i < n; i++) {
 			ParticleEmitter emitter = emitters.get(i);
@@ -173,7 +181,7 @@ public class ParticleEffect implements Disposable {
 			String imageName = new File(imagePath.replace('\\', '/')).getName();
 			int lastDotIndex = imageName.lastIndexOf('.');
 			if (lastDotIndex != -1) imageName = imageName.substring(0, lastDotIndex);
-			if (atlasPrefix.length() > 0) imageName = atlasPrefix + "/" + imageName;
+			if (atlasPrefix != null) imageName = atlasPrefix + imageName;
 			Sprite sprite = atlas.createSprite(imageName);
 			if (sprite == null) throw new IllegalArgumentException("SpriteSheet missing image: " + imageName);
 			emitter.setSprite(sprite);
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/Renderable.java b/gdx/src/com/badlogic/gdx/graphics/g3d/Renderable.java
index aa69777..a91b868 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/Renderable.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/Renderable.java
@@ -91,9 +91,24 @@ public class Renderable {
 	 * combine multiple bones into a single transformation matrix, which is used to transform the vertex to model space. In other
 	 * words: the bone transformation is applied prior to the {@link #worldTransform}. */
 	public Matrix4 bones[];
-	/** The {@link Shader} to be used to render this Renderable using a {@link ModelBatch}, may be null. It is not guaranteed that
-	 * the shader will be used, the used {@link ShaderProvider} is responsible for actually choosing the correct shader to use. **/
+	/** The {@link Shader} to be used to render this Renderable using a {@link ModelBatch}, may be null.
+	 * It is not guaranteed that the shader will be used, the used {@link ShaderProvider} is responsible
+	 * for actually choosing the correct shader to use. **/
 	public Shader shader;
 	/** User definable value, may be null. */
 	public Object userData;
+	
+	public Renderable set(Renderable renderable) {
+		worldTransform.set(renderable.worldTransform);
+		material = renderable.material;
+		mesh = renderable.mesh;
+		meshPartOffset = renderable.meshPartOffset;
+		meshPartSize = renderable.meshPartSize;
+		primitiveType = renderable.primitiveType;
+		bones = renderable.bones;
+		environment = renderable.environment;
+		shader = renderable.shader;
+		userData = renderable.userData;
+		return this;
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/BlendingAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/BlendingAttribute.java
index 6afbb32..bb248df 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/BlendingAttribute.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/BlendingAttribute.java
@@ -18,6 +18,7 @@ package com.badlogic.gdx.graphics.g3d.attributes;
 
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.g3d.Attribute;
+import com.badlogic.gdx.utils.NumberUtils;
 
 public class BlendingAttribute extends Attribute {
 	public final static String Alias = "blended";
@@ -82,7 +83,7 @@ public class BlendingAttribute extends Attribute {
 		result = 947 * result + (blended ? 1 : 0);
 		result = 947 * result + sourceFunction;
 		result = 947 * result + destFunction;
-		result = 947 * result + Float.floatToRawIntBits(opacity);
+		result = 947 * result + NumberUtils.floatToRawIntBits(opacity);
 		return result; 
 	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/DepthTestAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/DepthTestAttribute.java
index 54c5ad4..d0387f8 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/DepthTestAttribute.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/DepthTestAttribute.java
@@ -19,6 +19,7 @@ package com.badlogic.gdx.graphics.g3d.attributes;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.g3d.Attribute;
 import com.badlogic.gdx.utils.GdxRuntimeException;
+import com.badlogic.gdx.utils.NumberUtils;
 
 public class DepthTestAttribute extends Attribute {
 	public final static String Alias = "depthStencil";
@@ -85,8 +86,8 @@ public class DepthTestAttribute extends Attribute {
 	public int hashCode () {
 		int result = (int)type;
 		result = 971 * result + depthFunc;
-		result = 971 * result + Float.floatToRawIntBits(depthRangeNear);
-		result = 971 * result + Float.floatToRawIntBits(depthRangeFar);
+		result = 971 * result + NumberUtils.floatToRawIntBits(depthRangeNear);
+		result = 971 * result + NumberUtils.floatToRawIntBits(depthRangeFar);
 		result = 971 * result + (depthMask ? 1 : 0);
 		return result; 
 	}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/FloatAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/FloatAttribute.java
index f52e45b..5260265 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/FloatAttribute.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/FloatAttribute.java
@@ -18,6 +18,7 @@ package com.badlogic.gdx.graphics.g3d.attributes;
 
 import com.badlogic.gdx.graphics.g3d.Attribute;
 import com.badlogic.gdx.utils.GdxRuntimeException;
+import com.badlogic.gdx.utils.NumberUtils;
 
 public class FloatAttribute extends Attribute {
 	public static final String ShininessAlias = "shininess";
@@ -53,7 +54,7 @@ public class FloatAttribute extends Attribute {
 	@Override
 	public int hashCode () {
 		int result = (int)type;
-		result = 977 * result + Float.floatToRawIntBits(value);
+		result = 977 * result + NumberUtils.floatToRawIntBits(value);
 		return result; 
 	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParallelArray.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParallelArray.java
new file mode 100644
index 0000000..821d38d
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParallelArray.java
@@ -0,0 +1,266 @@
+package com.badlogic.gdx.graphics.g3d.particles;
+
+import java.util.Arrays;
+
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+import com.badlogic.gdx.utils.reflect.ArrayReflection;
+
+/** This class represents an group of elements like an array, but the properties of the elements are stored as separate arrays.
+ *  These arrays are called {@link Channel} and are represented by {@link ChannelDescriptor}.
+ *  It's not necessary to store primitive types in the channels but doing so will "exploit" data locality 
+ *  in the JVM, which is ensured for primitive types.
+ *  Use {@link FloatChannel}, {@link IntChannel}, {@link ObjectChannel} to store the data. 
+ *  @author inferno */
+public class ParallelArray {
+	
+	/** This class describes the content of a {@link Channel}*/
+	public static class ChannelDescriptor{
+		public int id;
+		public Class<?> type;
+		public int count;
+		public ChannelDescriptor(int id, Class<?> type, int count){
+			this.id = id;
+			this.type = type;
+			this.count = count;
+		}
+	}
+	
+	/** This class represents a container of values for all the elements for a given property*/
+	public abstract class Channel{
+		public int id;
+		public Object data;
+		public int strideSize;
+		public Channel(int id, Object data, int strideSize){
+			this.id = id;
+			this.strideSize = strideSize;
+			this.data = data;
+		}
+		public abstract void add(int index, Object...objects);
+		public abstract void swap(int i, int k);
+		protected abstract void setCapacity (int requiredCapacity);
+	}
+	
+	/** This interface is used to provide custom initialization of the {@link Channel} data */
+	public static interface ChannelInitializer<T extends Channel>{
+		public void init(T channel);
+	}
+	
+	public class FloatChannel extends Channel{
+		public float[] data;
+		public FloatChannel (int id, int strideSize, int size) {
+			super(id, new float[size*strideSize], strideSize);
+			this.data = (float[])super.data;
+		}
+
+		@Override
+		public void add (int index, Object...objects) {
+			for(int i=strideSize*size, c = i+strideSize, k=0; i < c; ++i, ++k){
+				data[i] = (Float)objects[k];
+			}
+		}
+
+		@Override
+		public void swap (int i, int k) {
+			float t;
+			i=strideSize*i; 
+			k =strideSize*k;
+			for(int c = i+strideSize; i < c; ++i, ++k){
+				t = data[i];
+				data[i] = data[k];
+				data[k] = t;
+			}
+		}
+
+		@Override
+		public void setCapacity (int requiredCapacity) {
+			float[] newData = new float[strideSize * requiredCapacity];
+			System.arraycopy(data, 0, newData, 0, Math.min(data.length, newData.length));
+			super.data = data = newData;
+		}
+	}
+	
+	public class IntChannel extends Channel{
+		public int[] data;
+		public IntChannel (int id, int strideSize, int size) {
+			super(id, new int[size*strideSize], strideSize);
+			this.data = (int[])super.data;
+		}
+
+		@Override
+		public void add (int index, Object...objects) {
+			for(int i=strideSize*size, c = i+strideSize, k=0; i < c; ++i, ++k){
+				data[i] = (Integer)objects[k];
+			}
+		}
+
+		@Override
+		public void swap (int i, int k) {
+			int t;
+			i=strideSize*i; 
+			k =strideSize*k;
+			for(int c = i+strideSize; i < c; ++i, ++k){
+				t = data[i];
+				data[i] = data[k];
+				data[k] = t;
+			}
+		}
+		
+		@Override
+		public void setCapacity (int requiredCapacity) {
+			int[] newData = new int[strideSize * requiredCapacity];
+			System.arraycopy(data, 0, newData, 0, Math.min(data.length, newData.length));
+			super.data = data = newData;
+		}
+	}
+	
+	@SuppressWarnings("unchecked")
+	public class ObjectChannel<T> extends Channel{
+		Class<T> componentType;
+		public T[] data;
+		public ObjectChannel (int id, int strideSize, int size, Class<T> type) {
+			super(id, ArrayReflection.newInstance(type, size*strideSize), strideSize);
+			componentType = type;
+			this.data = (T[]) super.data;
+		}
+
+		@Override
+		public void add (int index, Object...objects) {
+			for(int i=strideSize*size, c = i+strideSize, k=0; i < c; ++i, ++k){
+				this.data[i] = (T) objects[k];
+			}
+		}
+
+		@Override
+		public void swap (int i, int k) {
+			T t;
+			i=strideSize*i; 
+			k =strideSize*k;
+			for(int c = i+strideSize; i < c; ++i, ++k){
+				t = data[i];
+				data[i] = data[k];
+				data[k] = t;
+			}
+		}
+		
+		@Override
+		public void setCapacity (int requiredCapacity) {
+			T[] newData = (T[]) ArrayReflection.newInstance(componentType, strideSize * requiredCapacity);
+			System.arraycopy(data, 0, newData, 0, Math.min(data.length, newData.length));
+			super.data = data = newData;
+		}
+	}
+	
+	/**the channels added to the array*/
+	Array<Channel> arrays;
+	/** the maximum amount of elements that this array can hold */
+	public int capacity;
+	/** the current amount of defined elements, do not change manually unless you know what you are doing.*/
+	public int size;
+	
+	public ParallelArray(int capacity){
+		arrays = new Array<Channel>(false, 2,  Channel.class);
+		this.capacity = capacity;
+		size = 0;
+	}
+	
+	/** Adds and returns a channel described by the channel descriptor parameter.
+	 *  If a channel with the same id already exists, no allocation is performed and that channel is returned. */
+	public <T extends Channel> T addChannel(ChannelDescriptor channelDescriptor){
+		return addChannel(channelDescriptor, null);
+	}
+	
+	/** Adds and returns a channel described by the channel descriptor parameter.
+	 *  If a channel with the same id already exists, no allocation is performed and that channel is returned.
+	 *  Otherwise a new channel is allocated and initialized with the initializer. */
+	public <T extends Channel> T addChannel(ChannelDescriptor channelDescriptor, ChannelInitializer<T> initializer){
+		T channel = getChannel(channelDescriptor);
+		if(channel == null){
+			channel = allocateChannel(channelDescriptor);
+			if(initializer != null)
+				initializer.init(channel);
+			arrays.add(channel);
+		}
+		return channel;
+	}
+	
+	@SuppressWarnings({"unchecked", "rawtypes"})
+	private <T extends Channel> T allocateChannel(ChannelDescriptor channelDescriptor){
+		if(channelDescriptor.type == float.class){
+			return (T)new FloatChannel(channelDescriptor.id, channelDescriptor.count, capacity);
+		}
+		else if(channelDescriptor.type == int.class){
+			return (T)new IntChannel(channelDescriptor.id, channelDescriptor.count, capacity);
+		}
+		else {
+			return (T)new ObjectChannel(channelDescriptor.id, channelDescriptor.count, capacity, channelDescriptor.type);
+		}
+	}
+	
+	/**Removes the channel with the given id*/
+	public <T> void removeArray(int id){
+		arrays.removeIndex(findIndex(id));
+	}
+	
+	private int findIndex (int id) {
+		for(int i=0; i < arrays.size;++i){
+			Channel array = arrays.items[i];
+			if(array.id == id)
+				return i;
+		}
+		return -1;
+	}
+	
+	/**Adds an element considering the values in the same order as the current channels in the array.
+	 * The n_th value  must have the same type and stride of the given channel at position n*/
+	public void addElement(Object...values){
+		/*FIXME make it grow...*/
+		if(size == capacity) 
+			throw new GdxRuntimeException("Capacity reached, cannot add other elements");
+
+		int k=0;
+		for(Channel strideArray : arrays){
+			strideArray.add(k, values);
+			k+= strideArray.strideSize;
+		}
+		++size;
+	}
+	
+	/**Removes the element at the given index and swaps it with the last available element */
+	public void removeElement(int index){
+		int last = size -1;
+		//Swap
+		for(Channel strideArray : arrays){
+			strideArray.swap(index, last);
+		}
+		size = last;
+	}
+	
+	/**@return the channel with the same id as the one in the descriptor */
+	@SuppressWarnings("unchecked")
+	public <T extends Channel> T getChannel (ChannelDescriptor descriptor) {
+		for(Channel array : arrays){
+			if(array.id == descriptor.id)
+				return (T) array;
+		}
+		return null;
+	}
+
+	/** Removes all the channels and sets size to 0 */
+	public void clear () {
+		arrays.clear();
+		size = 0;
+	}
+
+	/** Sets the capacity. 
+	 * Each contained channel will be resized to match the required capacity and the current data will be preserved. */
+	public void setCapacity (int requiredCapacity) {
+		if(capacity != requiredCapacity){
+			for(Channel channel : arrays){
+				channel.setCapacity(requiredCapacity);
+			}
+			capacity = requiredCapacity;
+		}
+	}
+	
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleChannels.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleChannels.java
new file mode 100644
index 0000000..f80866c
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleChannels.java
@@ -0,0 +1,147 @@
+package com.badlogic.gdx.graphics.g3d.particles;
+
+import java.util.Arrays;
+
+import com.badlogic.gdx.graphics.g3d.ModelInstance;
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.ChannelDescriptor;
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.ChannelInitializer;
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.FloatChannel;
+
+/** This contains all the definitions of particle related channels and channel initializers.
+ * It is also used by the {@link ParticleController} to handle temporary channels allocated by influencers.
+ * @author inferno */
+public class ParticleChannels {
+	private static int currentGlobalId;
+	public static int newGlobalId(){
+		return currentGlobalId++;
+	}
+	
+	//Initializers
+	public static class TextureRegionInitializer implements ChannelInitializer<FloatChannel>{
+		private static TextureRegionInitializer instance;
+		public static TextureRegionInitializer get(){
+				if(instance == null)
+					instance = new TextureRegionInitializer();
+				return instance;
+		}
+		
+		@Override
+		public void init (FloatChannel channel) {
+			for(int i=0, c = channel.data.length; i < c; i+= channel.strideSize){
+				channel.data[i + ParticleChannels.UOffset] = 0;
+				channel.data[i + ParticleChannels.VOffset] = 0;
+				channel.data[i + ParticleChannels.U2Offset] = 1;
+				channel.data[i + ParticleChannels.V2Offset] = 1;
+				channel.data[i + ParticleChannels.HalfWidthOffset] = 0.5f;
+				channel.data[i + ParticleChannels.HalfHeightOffset] = 0.5f;
+			}
+		}
+	}
+
+	public static class ColorInitializer implements ChannelInitializer<FloatChannel>{
+		private static ColorInitializer instance;
+		public static ColorInitializer get(){
+			if(instance == null)
+				instance = new ColorInitializer();
+			return instance;
+		}
+		@Override
+		public void init (FloatChannel channel) {
+			Arrays.fill(channel.data, 0, channel.data.length, 1);
+		}
+	}
+
+	public static class ScaleInitializer implements ChannelInitializer<FloatChannel>{
+		private static ScaleInitializer instance;
+		public static ScaleInitializer get(){
+			if(instance == null)
+				instance = new ScaleInitializer();
+			return instance;
+		}
+		@Override
+		public void init (FloatChannel channel) {
+			Arrays.fill(channel.data, 0, channel.data.length, 1);
+		}
+	}
+	
+	public static class Rotation2dInitializer implements ChannelInitializer<FloatChannel>{
+		private static Rotation2dInitializer instance;
+		public static Rotation2dInitializer get(){
+			if(instance == null)
+				instance = new Rotation2dInitializer();
+			return instance;
+		}
+		@Override
+		public void init (FloatChannel channel) {
+			for(int i=0, c = channel.data.length; i < c; i+= channel.strideSize){
+				channel.data[i + ParticleChannels.CosineOffset] = 1;
+				channel.data[i + ParticleChannels.SineOffset] = 0;
+			}
+		}
+	}
+	
+	public static class Rotation3dInitializer implements ChannelInitializer<FloatChannel>{
+		private static Rotation3dInitializer instance;
+		public static Rotation3dInitializer get(){
+			if(instance == null)
+				instance = new Rotation3dInitializer();
+			return instance;
+		}
+		@Override
+		public void init (FloatChannel channel) {
+			for(int i=0, c = channel.data.length; i < c; i+= channel.strideSize){
+				channel.data[i + ParticleChannels.XOffset] = 
+				channel.data[i + ParticleChannels.YOffset] = 
+				channel.data[i + ParticleChannels.ZOffset] = 0;
+				channel.data[i + ParticleChannels.WOffset] = 1;
+			}
+		}
+	}
+
+	//Channels
+	/** Channels of common use like position, life, color, etc...*/
+	public static final ChannelDescriptor Life = new ChannelDescriptor(newGlobalId(), float.class, 3);
+	public static final ChannelDescriptor Position = new ChannelDescriptor(newGlobalId(), float.class, 3); //gl units
+	public static final ChannelDescriptor PreviousPosition = new ChannelDescriptor(newGlobalId(), float.class, 3);
+	public static final ChannelDescriptor Color = new ChannelDescriptor(newGlobalId(), float.class, 4);
+	public static final ChannelDescriptor TextureRegion = new ChannelDescriptor(newGlobalId(), float.class, 6);
+	public static final ChannelDescriptor Rotation2D = new ChannelDescriptor(newGlobalId(), float.class, 2);
+	public static final ChannelDescriptor Rotation3D = new ChannelDescriptor(newGlobalId(), float.class, 4);
+	public static final ChannelDescriptor Scale = new ChannelDescriptor(newGlobalId(), float.class, 1);
+	public static final ChannelDescriptor ModelInstance = new ChannelDescriptor(newGlobalId(), ModelInstance.class, 1);
+	public static final ChannelDescriptor ParticleController = new ChannelDescriptor(newGlobalId(), ParticleController.class, 1);
+	public static final ChannelDescriptor Acceleration = new ChannelDescriptor(newGlobalId(), float.class, 3); //gl units/s2
+	public static final ChannelDescriptor AngularVelocity2D = new ChannelDescriptor(newGlobalId(), float.class, 1);
+	public static final ChannelDescriptor AngularVelocity3D = new ChannelDescriptor(newGlobalId(), float.class, 3);
+	public static final ChannelDescriptor Interpolation = new ChannelDescriptor(-1, float.class, 2);
+	public static final ChannelDescriptor Interpolation4 = new ChannelDescriptor(-1, float.class, 4);
+	public static final ChannelDescriptor Interpolation6 = new ChannelDescriptor(-1, float.class, 6);
+	
+	//Offsets
+	/** Offsets to acess a particular value inside a stride of a given channel */
+	public static final int CurrentLifeOffset = 0, TotalLifeOffset = 1, LifePercentOffset =2;
+	public static final int RedOffset = 0, GreenOffset =1, BlueOffset = 2, AlphaOffset =3;
+	public static final int InterpolationStartOffset = 0, InterpolationDiffOffset =1;
+	public static final int VelocityStrengthStartOffset = 0, VelocityStrengthDiffOffset =1,
+												VelocityThetaStartOffset = 0, VelocityThetaDiffOffset =1,
+												VelocityPhiStartOffset = 2, VelocityPhiDiffOffset =3;
+	public static final int XOffset = 0, YOffset = 1, ZOffset = 2, WOffset = 3;
+	public static final int UOffset = 0, VOffset= 1, U2Offset = 2, V2Offset = 3,
+												HalfWidthOffset = 4, HalfHeightOffset= 5;
+	public static final int CosineOffset = 0, SineOffset= 1;
+
+	private int currentId; 
+
+	public ParticleChannels(){
+		resetIds();
+	}
+	
+	public int newId(){
+		return currentId++;
+	}
+	
+	protected void resetIds(){
+		currentId = currentGlobalId;
+	}
+	
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleController.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleController.java
new file mode 100644
index 0000000..340f03a
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleController.java
@@ -0,0 +1,320 @@
+package com.badlogic.gdx.graphics.g3d.particles;
+
+import com.badlogic.gdx.assets.AssetManager;
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.FloatChannel;
+import com.badlogic.gdx.graphics.g3d.particles.emitters.Emitter;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.Influencer;
+import com.badlogic.gdx.graphics.g3d.particles.renderers.ParticleControllerRenderer;
+import com.badlogic.gdx.math.Matrix4;
+import com.badlogic.gdx.math.Quaternion;
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.math.collision.BoundingBox;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.Json;
+import com.badlogic.gdx.utils.JsonValue;
+import com.badlogic.gdx.utils.reflect.ClassReflection;
+
+/** Base class of all the particle controllers.
+ * Encapsulate the generic structure of a controller and methods to update the particles simulation.
+ * @author Inferno */
+public class ParticleController implements Json.Serializable, ResourceData.Configurable{
+	
+	/** the default time step used to update the simulation */
+	protected static final float DEFAULT_TIME_STEP = 1f/60; 
+	
+	/** Name of the controller */
+	public String name;
+	
+	/** Controls the emission of the particles */
+	public Emitter emitter;
+	
+	/** Update the properties of the particles */
+	public Array<Influencer> influencers;
+	
+	/** Controls the graphical representation of the particles */
+	public  ParticleControllerRenderer<?, ?> renderer;
+	
+	/** Particles components */
+	public ParallelArray particles;
+	public ParticleChannels particleChannels;
+	
+	/** Current transform of the controller
+	 *	 DO NOT CHANGE MANUALLY */
+	public Matrix4 transform;
+	
+	/** Transform flags */
+	public Vector3 scale;
+	
+	/** Not used by the simulation, it should represent the bounding box containing all the particles*/
+	protected BoundingBox boundingBox;
+	
+	/** Time step, DO NOT CHANGE MANUALLY */
+	public float deltaTime, deltaTimeSqr;
+	
+	public ParticleController(){
+		transform = new Matrix4();
+		scale = new Vector3(1,1,1);
+		influencers = new Array<Influencer>(true, 3, Influencer.class);
+		setTimeStep(DEFAULT_TIME_STEP);
+	}
+
+	public ParticleController(String name, Emitter emitter, ParticleControllerRenderer<?, ?> renderer, Influencer...influencers){
+		this();
+		this.name = name;
+		this.emitter = emitter;
+		this.renderer = renderer;
+		this.particleChannels = new ParticleChannels();
+		this.influencers = new Array<Influencer>(influencers);
+	}
+
+	/**Sets the delta used to step the simulation */
+	private void setTimeStep (float timeStep) {
+		deltaTime = timeStep;
+		deltaTimeSqr = deltaTime*deltaTime;
+	}
+	
+	/** Sets the current transformation to the given one.
+	 * @param transform the new transform matrix */
+	public void setTransform (Matrix4 transform) {
+		this.transform.set(transform);
+		transform.getScale(scale);
+	}
+
+	/** Sets the current transformation. */
+	public void setTransform(float x, float y, float z, float qx, float qy, float qz, float qw, float scale ){
+		transform.set(x, y, z, qx, qy, qz, qw, scale, scale, scale);
+		this.scale.set(scale, scale, scale);
+	}
+
+	/** Post-multiplies the current transformation with a rotation matrix represented by the given quaternion.*/
+	public void rotate(Quaternion rotation){
+		this.transform.rotate(rotation);
+	}
+	
+	/** Post-multiplies the current transformation with a rotation matrix by the given angle around the given axis.
+	 * @param axis the rotation axis
+	 * @param angle the rotation angle in degrees*/
+	public void rotate(Vector3 axis, float angle){
+		this.transform.rotate(axis, angle);
+	}
+	
+	/** Postmultiplies the current transformation with a translation matrix represented by the given translation.*/
+	public void translate(Vector3 translation){
+		this.transform.translate(translation);
+	}
+	
+	public void setTranslation (Vector3 translation) {
+		this.transform.setTranslation(translation);
+	}
+	
+	/** Postmultiplies the current transformation with a scale matrix represented by the given scale on x,y,z.*/
+	public void scale(float scaleX, float scaleY, float scaleZ){
+		this.transform.scale(scaleX, scaleY, scaleZ);
+		this.transform.getScale(scale);
+	}
+	
+	/** Postmultiplies the current transformation with a scale matrix represented by the given scale vector.*/
+	public void scale(Vector3 scale){
+		scale(scale.x, scale.y, scale.z);
+	}
+	
+	/** Postmultiplies the current transformation with the given matrix.*/
+	public void mul(Matrix4 transform){
+		this.transform.mul(transform);
+		this.transform.getScale(scale);
+	}
+	
+	/** Set the given matrix to the current transformation matrix.*/
+	public void getTransform(Matrix4 transform){
+		transform.set(this.transform);
+	}
+	
+	/** Initialize the controller.
+	 *  All the sub systems will be initialized and binded to the controller. 
+	 *  Must be called before any other method. */
+	public void init(){
+		bind();
+		if(particles != null) {
+			end();
+			particleChannels.resetIds();
+		}
+		allocateChannels(emitter.maxParticleCount);
+
+		emitter.init();
+		for(Influencer influencer : influencers)
+			influencer.init();
+		renderer.init();
+	}
+
+	protected void allocateChannels (int maxParticleCount){
+		particles = new ParallelArray(maxParticleCount);
+		//Alloc additional channels
+		emitter.allocateChannels();
+		for(Influencer influencer : influencers)
+			influencer.allocateChannels();
+		renderer.allocateChannels();
+	}
+
+	/** Bind the sub systems to the controller
+	 *  Called once during the init phase.*/
+	protected void bind(){
+		emitter.set(this);
+		for(Influencer influencer : influencers)
+			influencer.set(this);
+		renderer.set(this);
+	}
+	
+	/** Start the simulation. */
+	public void start () {
+		emitter.start();
+		for(Influencer influencer : influencers)
+			influencer.start();
+	}
+	
+	/** Reset the simulation. */
+	public void reset(){
+		end();
+		start();
+	}
+	
+	/** End the simulation. */
+	public void end () {
+		for(Influencer influencer : influencers)
+			influencer.end();
+		emitter.end();
+	}
+	
+	/** Generally called by the Emitter. 
+	 * This method will notify all the sub systems that a given amount 
+	 * of particles has been activated. */
+	public void activateParticles (int startIndex, int count) {
+		emitter.activateParticles(startIndex, count);
+		for(Influencer influencer : influencers)
+			influencer.activateParticles(startIndex, count);
+	}
+	
+	/** Generally called by the Emitter. 
+	 * This method will notify all the sub systems that a given amount 
+	 * of particles has been killed. */
+	public void killParticles (int startIndex, int count){
+		emitter.killParticles(startIndex, count);
+		for(Influencer influencer : influencers)
+			influencer.killParticles(startIndex, count);
+	}
+	
+	/** Updates the particles data */
+	public void update(){
+		emitter.update();
+		for(Influencer influencer : influencers)
+			influencer.update();
+	}
+
+	/**Updates the renderer used by this controller, usually this means the particles will be draw inside a batch. */
+	public void draw () {
+		if(particles.size > 0){
+			renderer.update();
+		}
+	}
+	
+	/** @return a copy of this controller*/
+	public ParticleController copy () {
+		Emitter emitter = (Emitter)this.emitter.copy();
+		Influencer[] influencers = new Influencer[this.influencers.size];
+		int i=0;
+		for(Influencer influencer : this.influencers){
+			influencers[i++] = (Influencer)influencer.copy();
+		}
+		return new ParticleController(new String(this.name), emitter, (ParticleControllerRenderer<?, ?>)renderer.copy(), influencers);
+	}
+
+	public void dispose(){
+		emitter.dispose();
+		for(Influencer influencer : influencers)
+			influencer.dispose();
+	}
+
+	/** @return a copy of this controller, should be used after the particle effect has been loaded. */
+	public BoundingBox getBoundingBox (){
+		if(boundingBox == null) boundingBox = new BoundingBox();
+		calculateBoundingBox();
+		return boundingBox;
+	}
+	
+	/** Updates the bounding box using the position channel. */
+	protected void calculateBoundingBox () {
+		boundingBox.clr();
+		FloatChannel positionChannel = particles.getChannel(ParticleChannels.Position);
+		for(int pos = 0, c = positionChannel.strideSize*particles.size ; pos < c; pos += positionChannel.strideSize){
+			boundingBox.ext(	positionChannel.data[pos + ParticleChannels.XOffset], 
+												positionChannel.data[pos + ParticleChannels.YOffset], 
+												positionChannel.data[pos + ParticleChannels.ZOffset]);
+		}
+	}
+
+	/** @return the index of the Influencer of the given type. */
+	private <K extends Influencer> int findIndex(Class<K> type){
+		for(int i = 0; i< influencers.size; ++i){
+			Influencer influencer = influencers.get(i);
+			if(ClassReflection.isAssignableFrom(type, influencer.getClass())){
+				return i;
+			}
+		}
+		return -1;
+	}
+	
+	/** @return the influencer having the given type. */
+	public <K extends Influencer> K findInfluencer (Class<K> influencerClass) {
+		int index = findIndex(influencerClass);
+		return index >-1 ? (K)influencers.get(index) : null;
+	}
+	
+	/** Removes the Influencer of the given type. */
+	public  <K extends Influencer> void removeInfluencer (Class<K> type) {
+		int index = findIndex(type);
+		if(index > -1 )
+			influencers.removeIndex(index);
+	}
+	
+	/** Replaces the Influencer of the given type with the one passed as parameter. */
+	public <K extends Influencer> boolean replaceInfluencer (Class<K> type, K newInfluencer) {
+		int index = findIndex(type);
+		if(index > -1){
+			influencers.insert(index, newInfluencer);
+			influencers.removeIndex(index+1);
+			return true;
+		}
+		return false;
+	}
+
+	@Override
+	public void write (Json json) {
+      json.writeValue("name", name);
+      json.writeValue("emitter", emitter, Emitter.class);
+      json.writeValue("influencers", influencers, Array.class, Influencer.class);
+      json.writeValue("renderer", renderer, ParticleControllerRenderer.class);
+   }
+
+	@Override
+	public void read (Json json, JsonValue jsonMap) {
+		name = json.readValue("name", String.class, jsonMap);
+		emitter = json.readValue("emitter", Emitter.class, jsonMap);
+		influencers.addAll(json.readValue("influencers", Array.class, Influencer.class, jsonMap));
+		renderer = json.readValue("renderer", ParticleControllerRenderer.class, jsonMap);
+	}
+
+	@Override
+	public void save (AssetManager manager, ResourceData data) {
+		emitter.save(manager, data);
+		for(Influencer influencer : influencers)
+			influencer.save(manager, data);
+		renderer.save(manager, data);
+	}
+
+	@Override
+	public void load (AssetManager manager, ResourceData data) {
+		emitter.load(manager, data);
+		for(Influencer influencer : influencers)
+			influencer.load(manager, data);
+		renderer.load(manager, data);
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleControllerComponent.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleControllerComponent.java
new file mode 100644
index 0000000..a7e8f6e
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleControllerComponent.java
@@ -0,0 +1,58 @@
+package com.badlogic.gdx.graphics.g3d.particles;
+
+import com.badlogic.gdx.assets.AssetManager;
+import com.badlogic.gdx.math.Matrix3;
+import com.badlogic.gdx.math.Matrix4;
+import com.badlogic.gdx.math.Quaternion;
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.utils.Disposable;
+import com.badlogic.gdx.utils.Json;
+import com.badlogic.gdx.utils.JsonValue;
+
+
+/** It's the base class of every {@link ParticleController} component.
+ * A component duty is to participate in one or some events during the simulation.
+ * (i.e it can handle the particles emission or modify particle properties, etc.).
+ * @author inferno */
+public abstract class ParticleControllerComponent implements Disposable, Json.Serializable, ResourceData.Configurable {
+	protected static final Vector3 TMP_V1 = new Vector3(), 
+		 TMP_V2 = new Vector3(), 
+		 TMP_V3 = new Vector3(), 
+		 TMP_V4 = new Vector3(), 
+		 TMP_V5 = new Vector3(),
+		 TMP_V6 = new Vector3();
+	protected static final Quaternion 	TMP_Q = new Quaternion(),
+													TMP_Q2 = new Quaternion();
+	protected static final Matrix3 TMP_M3 = new Matrix3();
+	protected static final Matrix4 TMP_M4 = new Matrix4();
+	protected ParticleController controller;
+	/** Called to initialize new emitted particles. */
+	public void activateParticles (int startIndex, int count){};
+	/** Called to notify which particles have been killed. */
+	public void killParticles (int startIndex, int count){};
+	/** Called to execute the component behavior. */
+	public void update (){};
+	/** Called once during intialization */
+	public void init (){};
+	/** Called at the start of the simulation. */
+	public void start(){};
+	/** Called at the end of the simulation. */
+	public void end(){};
+	public void dispose(){}
+	public abstract ParticleControllerComponent copy();
+	/** Called during initialization to allocate additional particles channels*/
+	public void allocateChannels(){}
+	public void set(ParticleController particleController) {
+		controller = particleController;
+	}
+	
+	@Override
+	public void save (AssetManager manager, ResourceData data) {}
+	@Override
+	public void load (AssetManager manager, ResourceData data) {}
+	@Override
+	public void write (Json json) {}
+	@Override
+	public void read (Json json, JsonValue jsonData) {}
+	
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleEffect.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleEffect.java
new file mode 100644
index 0000000..596658c
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleEffect.java
@@ -0,0 +1,175 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package com.badlogic.gdx.graphics.g3d.particles;
+
+import com.badlogic.gdx.assets.AssetManager;
+import com.badlogic.gdx.graphics.g3d.particles.batches.ParticleBatch;
+import com.badlogic.gdx.math.Matrix4;
+import com.badlogic.gdx.math.Quaternion;
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.math.collision.BoundingBox;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.Disposable;
+
+/** It's a set of particles controllers.
+ * It can be updated, rendered, transformed which means the changes will be applied
+ * on all the particles controllers.
+ * @author inferno */
+public class ParticleEffect implements Disposable, ResourceData.Configurable{
+	private Array<ParticleController> controllers;
+	private BoundingBox bounds;
+
+	public ParticleEffect () {
+		controllers = new Array<ParticleController>(true, 3, ParticleController.class);
+	}
+
+	public ParticleEffect (ParticleEffect effect) {
+		controllers = new Array<ParticleController>(true, effect.controllers.size);
+		for (int i = 0, n = effect.controllers.size; i < n; i++)
+			controllers.add(effect.controllers.get(i).copy());
+	}
+
+	public ParticleEffect (ParticleController...emitters) {
+		this.controllers = new Array<ParticleController>(emitters);
+	}
+
+	public void init(){
+		for (int i = 0, n = controllers.size; i < n; i++)
+			controllers.get(i).init();
+	}
+
+	public void start () {
+		for (int i = 0, n = controllers.size; i < n; i++)
+			controllers.get(i).start();
+	}
+	public void end () {
+		for (int i = 0, n = controllers.size; i < n; i++)
+			controllers.get(i).end();
+	}
+	public void reset() {
+		for (int i = 0, n = controllers.size; i < n; i++)
+			controllers.get(i).reset();
+	}
+
+	public void update () {
+		for (int i = 0, n = controllers.size; i < n; i++)
+			controllers.get(i).update();
+	}
+
+	public void draw () {
+		for (int i = 0, n = controllers.size; i < n; i++)
+			controllers.get(i).draw();
+	}
+
+	/** Sets the given transform matrix on each controller.*/
+	public void setTransform (Matrix4 transform) {
+		for (int i = 0, n = controllers.size; i < n; i++)
+			controllers.get(i).setTransform(transform);
+	}
+
+	/** Applies the rotation to the current transformation matrix of each controller.*/
+	public void rotate(Quaternion rotation){
+		for (int i = 0, n = controllers.size; i < n; i++)
+			controllers.get(i).rotate(rotation);
+	}
+
+	/** Applies the rotation by the given angle around the given axis to the current transformation matrix of each controller.
+	 * @param axis the rotation axis
+	 * @param angle the rotation angle in degrees*/
+	public void rotate(Vector3 axis, float angle){
+		for (int i = 0, n = controllers.size; i < n; i++)
+			controllers.get(i).rotate(axis, angle);
+	}
+
+	/** Applies the translation to the current transformation matrix of each controller.*/
+	public void translate(Vector3 translation){
+		for (int i = 0, n = controllers.size; i < n; i++)
+			controllers.get(i).translate(translation);
+	}
+
+	/** Applies the scale to the current transformation matrix of each controller.*/
+	public void scale(float scaleX, float scaleY, float scaleZ){
+		for (int i = 0, n = controllers.size; i < n; i++)
+			controllers.get(i).scale(scaleX, scaleY, scaleZ);
+	}
+
+	/** Applies the scale to the current transformation matrix of each controller.*/
+	public void scale(Vector3 scale){
+		for (int i = 0, n = controllers.size; i < n; i++)
+			controllers.get(i).scale(scale.x, scale.y, scale.z);
+	}
+
+	/**@return all particle controllers. */
+	public Array<ParticleController> getControllers () {
+		return controllers;
+	}
+
+	/** Returns the controller with the specified name, or null. */
+	public ParticleController findController (String name) {
+		for (int i = 0, n = controllers.size; i < n; i++) {
+			ParticleController emitter = controllers.get(i);
+			if (emitter.name.equals(name)) return emitter;
+		}
+		return null;
+	}
+
+	public void dispose () {
+		for (int i = 0, n = controllers.size; i < n; i++) {
+			controllers.get(i).dispose();
+		}
+	}
+
+	/** @return the merged bounding box of all controllers. */
+	public BoundingBox getBoundingBox () {
+		if (bounds == null) bounds = new BoundingBox();
+
+		BoundingBox bounds = this.bounds;
+		bounds.inf();
+		for (ParticleController emitter : controllers)
+			bounds.ext(emitter.getBoundingBox());
+		return bounds;
+	}
+
+	/** Assign one batch, among those passed in, to each controller.
+	 * The batch must be compatible with the controller to be assigned.*/
+	public void setBatch(Array<ParticleBatch<?>> batches){
+		for(ParticleController controller : controllers){
+			for(ParticleBatch<?> batch : batches)
+				if(controller.renderer.setBatch(batch))
+					break;
+		}
+	}
+
+	/** @return a copy of this effect, should be used after the particle effect has been loaded. */
+	public ParticleEffect copy () {
+		return new ParticleEffect(this);
+	}
+	
+	/** Saves all the assets required by all the controllers inside this effect. */
+	public void save (AssetManager assetManager, ResourceData data){
+		for(ParticleController controller : controllers){
+			controller.save(assetManager, data);
+		}
+	}
+	
+	/** Loads all the assets required by all the controllers inside this effect. */
+	public void load (AssetManager assetManager, ResourceData data){
+		int i=0;
+		for(ParticleController controller : controllers){
+			controller.load(assetManager, data);
+		}
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleEffectLoader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleEffectLoader.java
new file mode 100644
index 0000000..33cf656
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleEffectLoader.java
@@ -0,0 +1,155 @@
+package com.badlogic.gdx.graphics.g3d.particles;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.Writer;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.assets.AssetDescriptor;
+import com.badlogic.gdx.assets.AssetLoaderParameters;
+import com.badlogic.gdx.assets.AssetManager;
+import com.badlogic.gdx.assets.loaders.AsynchronousAssetLoader;
+import com.badlogic.gdx.assets.loaders.FileHandleResolver;
+import com.badlogic.gdx.files.FileHandle;
+import com.badlogic.gdx.graphics.g3d.particles.ResourceData.AssetData;
+import com.badlogic.gdx.graphics.g3d.particles.batches.ParticleBatch;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.Json;
+import com.badlogic.gdx.utils.ObjectMap;
+import com.badlogic.gdx.utils.reflect.ClassReflection;
+
+/**This class can save and load a {@link ParticleEffect}.
+ * It should be added as {@link AsynchronousAssetLoader} to the {@link AssetManager} so it will be able to load the effects.
+ * It's important to note that the two classes {@link ParticleEffectLoadParameter} and {@link ParticleEffectSaveParameter} should
+ * be passed in whenever possible, because when present the batches settings will be loaded automatically.
+ * When the load and save parameters are absent, once the effect will be created, one will have to set the required batches
+ * manually otherwise the {@link ParticleController} instances contained inside the effect will not be able to render themselves. 
+ * @author inferno */
+public class ParticleEffectLoader extends AsynchronousAssetLoader<ParticleEffect, ParticleEffectLoader.ParticleEffectLoadParameter> {
+	protected Array<ObjectMap.Entry<String, ResourceData<ParticleEffect>>> items = new Array<ObjectMap.Entry<String, ResourceData<ParticleEffect>>>(); 
+	
+	public ParticleEffectLoader (FileHandleResolver resolver) {
+		super(resolver);
+	}
+
+	@Override
+	public void loadAsync (AssetManager manager, String fileName, FileHandle file, ParticleEffectLoadParameter parameter) {}
+
+	@Override
+	public Array<AssetDescriptor> getDependencies (String fileName, FileHandle file, ParticleEffectLoadParameter parameter) {
+		Json json = new Json();
+		ResourceData<ParticleEffect> data = json.fromJson(ResourceData.class, file);
+		Array<AssetData> assets = null;
+		synchronized (items) {
+			ObjectMap.Entry<String, ResourceData<ParticleEffect>> entry = new ObjectMap.Entry<String, ResourceData<ParticleEffect>>();
+			entry.key = fileName;
+			entry.value = data;
+			items.add(entry);
+			assets = data.getAssets();
+		}
+		
+		Array<AssetDescriptor> descriptors = new Array<AssetDescriptor>();
+		for(AssetData<?> assetData : assets){
+			
+			//If the asset doesn't exist try to load it from loading effect directory
+			if (!resolve(assetData.filename).exists()){
+				assetData.filename = file.parent().child(Gdx.files.absolute(assetData.filename).name()).path();
+			}
+
+			if(assetData.type == ParticleEffect.class){
+				descriptors.add(new AssetDescriptor(assetData.filename, assetData.type, parameter));
+			}
+			else 
+				descriptors.add(new AssetDescriptor(assetData.filename, assetData.type));
+		}
+		
+		return descriptors;
+		
+	}
+	
+	/** Saves the effect to the given file contained in the passed in parameter. */
+	public void save(ParticleEffect effect, ParticleEffectSaveParameter parameter) throws IOException{
+		ResourceData<ParticleEffect> data =  new ResourceData<ParticleEffect>(effect);
+		
+		//effect assets
+		effect.save(parameter.manager, data);
+		
+		//Batches configurations
+		if(parameter.batches != null){
+			for(ParticleBatch<?> batch : parameter.batches){
+				boolean save = false;
+				for(ParticleController controller : effect.getControllers()){
+					if(controller.renderer.isCompatible(batch)){
+						save = true;
+						break;
+					}
+				}
+				
+				if(save)
+					batch.save(parameter.manager, data);
+			}
+		}
+		
+		//save
+		Json json = new Json();
+		json.toJson(data, parameter.file);
+	}
+	
+	@Override
+	public ParticleEffect loadSync (AssetManager manager, String fileName, FileHandle file, ParticleEffectLoadParameter parameter) {
+		ResourceData<ParticleEffect> effectData = null;
+		synchronized(items) {
+			for(int i=0; i < items.size; ++i){
+				ObjectMap.Entry<String, ResourceData<ParticleEffect>> entry = items.get(i);
+				if(entry.key.equals(fileName)){
+					effectData = entry.value;
+					items.removeIndex(i);
+					break;
+				}
+			}
+		}
+
+		effectData.resource.load(manager, effectData);
+		if(parameter != null){
+			if(parameter.batches != null){
+				for(ParticleBatch<?> batch : parameter.batches){
+					batch.load(manager, effectData);
+				}
+			}
+			effectData.resource.setBatch(parameter.batches);	
+		}
+		return effectData.resource;
+	}
+	
+	private <T> T find(Array<?> array, Class<T> type){
+		for(Object object : array){
+			if(ClassReflection.isAssignableFrom(type, object.getClass()))
+				return (T)object;
+		}
+		return null;
+	}
+	
+	public static class ParticleEffectLoadParameter extends AssetLoaderParameters<ParticleEffect> {
+		Array<ParticleBatch<?>> batches;
+		
+		public ParticleEffectLoadParameter(Array<ParticleBatch<?>>batches){
+			this.batches = batches;
+		}
+	}
+	
+	public static class ParticleEffectSaveParameter extends AssetLoaderParameters<ParticleEffect> {
+		/**Optional parameters, but should be present to correctly load the settings*/
+		Array<ParticleBatch<?>> batches;
+		
+		/** Required parameters */
+		FileHandle file;
+		AssetManager manager;
+		public ParticleEffectSaveParameter(FileHandle file, AssetManager manager, Array<ParticleBatch<?>> batches){
+			this.batches = batches;
+			this.file = file;
+			this.manager = manager;
+		}
+	}
+	
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleShader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleShader.java
new file mode 100644
index 0000000..557220d
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleShader.java
@@ -0,0 +1,322 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.particles;
+
+import com.badlogic.gdx.Application.ApplicationType;
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.Camera;
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.gdx.graphics.g3d.Attribute;
+import com.badlogic.gdx.graphics.g3d.Attributes;
+import com.badlogic.gdx.graphics.g3d.Material;
+import com.badlogic.gdx.graphics.g3d.Renderable;
+import com.badlogic.gdx.graphics.g3d.Shader;
+import com.badlogic.gdx.graphics.g3d.attributes.BlendingAttribute;
+import com.badlogic.gdx.graphics.g3d.attributes.DepthTestAttribute;
+import com.badlogic.gdx.graphics.g3d.attributes.IntAttribute;
+import com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute;
+import com.badlogic.gdx.graphics.g3d.shaders.BaseShader;
+import com.badlogic.gdx.graphics.g3d.shaders.DefaultShader;
+import com.badlogic.gdx.graphics.g3d.utils.RenderContext;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.badlogic.gdx.math.Matrix4;
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+/** This is a custom shader to render the particles.
+ * Usually is not required, because the {@link DefaultShader} will be used instead.
+ * This shader will be used when dealing with billboards using GPU mode or point sprites. 
+ * @author inferno */
+public class ParticleShader extends BaseShader {
+	public enum ParticleType{
+		Billboard,
+		Point
+	}
+	
+	public static enum AlignMode{
+		Screen, ViewPoint//, ParticleDirection
+	}
+
+	public static class Config {
+		/** The uber vertex shader to use, null to use the default vertex shader. */
+		public String vertexShader = null;
+		/** The uber fragment shader to use, null to use the default fragment shader. */
+		public String fragmentShader = null;
+		public boolean ignoreUnimplemented = true;
+		/** Set to 0 to disable culling*/
+		public int defaultCullFace = -1;
+		/** Set to 0 to disable depth test */
+		public int defaultDepthFunc = -1;
+		public AlignMode align = AlignMode.Screen;
+		public ParticleType type = ParticleType.Billboard;
+		public Config() { }
+		public Config(AlignMode align, ParticleType type) {
+			this.align = align;
+			this.type = type;
+		}
+		
+		public Config(AlignMode align) {
+			this.align = align;
+		}
+		
+		public Config(ParticleType type) {
+			this.type = type;
+		}
+		
+		public Config(final String vertexShader, final String fragmentShader) {
+			this.vertexShader = vertexShader;
+			this.fragmentShader = fragmentShader;
+		}
+	}
+
+	private static String defaultVertexShader = null;
+	public static String getDefaultVertexShader() {
+		if (defaultVertexShader == null)
+			defaultVertexShader = Gdx.files.classpath("com/badlogic/gdx/graphics/g3d/particles/particles.vertex.glsl").readString();
+		return defaultVertexShader;
+	}
+	
+	private static String defaultFragmentShader = null;
+	public static String getDefaultFragmentShader() {
+		if (defaultFragmentShader == null)
+			defaultFragmentShader = Gdx.files.classpath("com/badlogic/gdx/graphics/g3d/particles/particles.fragment.glsl").readString();
+		return defaultFragmentShader;
+	}
+	
+	protected static long implementedFlags = BlendingAttribute.Type | TextureAttribute.Diffuse ;
+	
+	static final Vector3 TMP_VECTOR3 = new Vector3();
+	public static class Inputs{
+		public final static Uniform cameraRight = new Uniform("u_cameraRight");
+		public final static Uniform cameraInvDirection = new Uniform("u_cameraInvDirection");
+		public final static Uniform screenWidth = new Uniform("u_screenWidth");
+		public final static Uniform regionSize = new Uniform("u_regionSize");
+	}
+	public static class Setters{
+		public final static Setter cameraRight = new Setter() {
+			@Override public boolean isGlobal (BaseShader shader, int inputID) { return true; }
+			@Override public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
+				shader.set(inputID,  TMP_VECTOR3.set(shader.camera.direction).crs(shader.camera.up).nor());
+			}
+		};
+
+		public final static Setter cameraUp = new Setter() {
+			@Override public boolean isGlobal (BaseShader shader, int inputID) { return true; }
+			@Override public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
+				shader.set(inputID,  TMP_VECTOR3.set(shader.camera.up).nor());
+			}
+		};
+		
+		public final static Setter cameraInvDirection = new Setter() {
+			@Override public boolean isGlobal (BaseShader shader, int inputID) { return true; }
+			@Override public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
+				shader.set(inputID,  TMP_VECTOR3.set(-shader.camera.direction.x, -shader.camera.direction.y, -shader.camera.direction.z).nor());
+			}
+		};
+		public final static Setter cameraPosition = new Setter() {
+			@Override public boolean isGlobal (BaseShader shader, int inputID) { return true; }
+			@Override public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
+				shader.set(inputID,  shader.camera.position);
+			}
+		};
+		public final static Setter screenWidth = new Setter() {
+			@Override public boolean isGlobal (BaseShader shader, int inputID) { return true; }
+			@Override public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
+				shader.set(inputID,  (float)Gdx.graphics.getWidth());
+			}
+		};
+		public final static Setter worldViewTrans = new Setter() {
+			final Matrix4 temp = new Matrix4();
+			@Override public boolean isGlobal (BaseShader shader, int inputID) { return false; }
+			@Override public void set (BaseShader shader, int inputID, Renderable renderable, Attributes combinedAttributes) {
+				shader.set(inputID, temp.set(shader.camera.view).mul(renderable.worldTransform));
+			}
+		};
+	}
+	
+	/** The renderable used to create this shader, invalid after the call to init */
+	private Renderable renderable;
+	private long materialMask;
+	private long vertexMask;
+	protected final Config config;
+	/** Material attributes which are not required but always supported. */
+	private final static long optionalAttributes = IntAttribute.CullFace | DepthTestAttribute.Type;
+	
+	public ParticleShader(final Renderable renderable) {
+		this(renderable, new Config());
+	}
+	
+	public ParticleShader(final Renderable renderable, final Config config) {
+		this(renderable, config, createPrefix(renderable, config));
+	}
+
+	public ParticleShader(final Renderable renderable, final Config config, final String prefix) {
+		this(renderable, config, prefix, 
+				config.vertexShader != null ? config.vertexShader : getDefaultVertexShader(), 
+				config.fragmentShader != null ? config.fragmentShader : getDefaultFragmentShader());
+	}
+	
+	public ParticleShader(final Renderable renderable, final Config config, final String prefix, final String vertexShader, final String fragmentShader) {
+		this(renderable, config, new ShaderProgram(prefix + vertexShader, prefix + fragmentShader));
+	}
+	
+	public ParticleShader(final Renderable renderable, final Config config, final ShaderProgram shaderProgram) {
+		this.config = config;
+		this.program = shaderProgram;
+		this.renderable = renderable;
+		materialMask = renderable.material.getMask() | optionalAttributes;
+		vertexMask = renderable.mesh.getVertexAttributes().getMask();
+
+		if (!config.ignoreUnimplemented && (implementedFlags & materialMask) != materialMask)
+			throw new GdxRuntimeException("Some attributes not implemented yet ("+materialMask+")");
+
+		// Global uniforms
+		register(DefaultShader.Inputs.viewTrans, DefaultShader.Setters.viewTrans);
+		register(DefaultShader.Inputs.projViewTrans, DefaultShader.Setters.projViewTrans);
+		register(DefaultShader.Inputs.projTrans, DefaultShader.Setters.projTrans);
+		register(Inputs.screenWidth, Setters.screenWidth);
+		register(DefaultShader.Inputs.cameraUp, Setters.cameraUp);
+		register(Inputs.cameraRight, Setters.cameraRight);
+		register(Inputs.cameraInvDirection, Setters.cameraInvDirection);
+		register(DefaultShader.Inputs.cameraPosition, Setters.cameraPosition);
+		
+		// Object uniforms
+		register(DefaultShader.Inputs.diffuseTexture, DefaultShader.Setters.diffuseTexture);
+	}
+
+	@Override
+	public void init () {
+		final ShaderProgram program = this.program;
+		this.program = null;
+		init(program, renderable);
+		renderable = null;
+	}
+	
+	public static String createPrefix(final Renderable renderable, final Config config) {
+		String prefix = "";
+		if(Gdx.app.getType() == ApplicationType.Desktop)
+			prefix +="#version 120\n";
+		else
+			prefix +="#version 100\n";
+		if(config.type == ParticleType.Billboard){
+			prefix +="#define billboard\n";
+			if(config.align == AlignMode.Screen) 
+				prefix += "#define screenFacing\n";
+			else if(config.align == AlignMode.ViewPoint) 
+				prefix += "#define viewPointFacing\n";
+			//else if(config.align == AlignMode.ParticleDirection) 
+			//	prefix += "#define paticleDirectionFacing\n";
+		}
+		return prefix;
+	}
+	
+	@Override
+	public boolean canRender(final Renderable renderable) {
+		return (materialMask == (renderable.material.getMask() | optionalAttributes)) && 
+			(vertexMask == renderable.mesh.getVertexAttributes().getMask());
+	}
+	
+	@Override
+	public int compareTo(Shader other) {
+		if (other == null) return -1;
+		if (other == this) return 0;
+		return 0; // FIXME compare shaders on their impact on performance
+	}
+	
+	@Override
+	public boolean equals (Object obj) {
+		return (obj instanceof ParticleShader) ? equals((ParticleShader)obj) : false;
+	}
+	
+	public boolean equals (ParticleShader obj) {
+		return (obj == this);
+	}
+
+	@Override
+	public void begin (final Camera camera, final RenderContext context) {
+		super.begin(camera, context);
+	}
+	
+	@Override
+	public void render (final Renderable renderable) {
+		if (!renderable.material.has(BlendingAttribute.Type))
+			context.setBlending(false, GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA);
+		bindMaterial(renderable);
+		super.render(renderable);
+	}
+
+	@Override
+	public void end () {
+		currentMaterial = null;
+		super.end();
+	}
+	
+	Material currentMaterial;
+	protected void bindMaterial(final Renderable renderable) {
+		if (currentMaterial == renderable.material)
+			return;
+		
+		int cullFace = config.defaultCullFace == -1 ? GL20.GL_BACK : config.defaultCullFace;
+		int depthFunc = config.defaultDepthFunc == -1 ? GL20.GL_LEQUAL : config.defaultDepthFunc;
+		float depthRangeNear = 0f;
+		float depthRangeFar = 1f;
+		boolean depthMask = true;
+		
+		currentMaterial = renderable.material;
+		for (final Attribute attr : currentMaterial) {
+			final long t = attr.type;
+			if (BlendingAttribute.is(t)) {
+				context.setBlending(true, ((BlendingAttribute)attr).sourceFunction, ((BlendingAttribute)attr).destFunction);
+			}
+			else if ((t & DepthTestAttribute.Type) == DepthTestAttribute.Type) {
+				DepthTestAttribute dta = (DepthTestAttribute)attr;
+				depthFunc = dta.depthFunc;
+				depthRangeNear = dta.depthRangeNear;
+				depthRangeFar = dta.depthRangeFar;
+				depthMask = dta.depthMask;
+			}
+			else if(!config.ignoreUnimplemented)
+				throw new GdxRuntimeException("Unknown material attribute: "+attr.toString());
+		}
+		
+		context.setCullFace(cullFace);
+		context.setDepthTest(depthFunc, depthRangeNear, depthRangeFar);
+		context.setDepthMask(depthMask);
+	}
+
+	@Override
+	public void dispose () {
+		program.dispose();
+		super.dispose();
+	}
+	
+	public int getDefaultCullFace() {
+		return config.defaultCullFace == -1 ? GL20.GL_BACK : config.defaultCullFace; 
+	}
+	
+	public void setDefaultCullFace(int cullFace) {
+		config.defaultCullFace = cullFace;
+	}
+	
+	public int getDefaultDepthFunc() {
+		return config.defaultDepthFunc == -1 ? GL20.GL_LEQUAL : config.defaultDepthFunc; 
+	}
+	
+	public void setDefaultDepthFunc(int depthFunc) {
+		config.defaultDepthFunc = depthFunc;
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleSorter.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleSorter.java
new file mode 100644
index 0000000..2bace50
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleSorter.java
@@ -0,0 +1,141 @@
+package com.badlogic.gdx.graphics.g3d.particles;
+
+import com.badlogic.gdx.graphics.Camera;
+import com.badlogic.gdx.graphics.g3d.particles.renderers.ParticleControllerRenderData;
+import com.badlogic.gdx.math.Matrix4;
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.utils.Array;
+
+/** This class is used by particle batches to sort the particles before rendering.
+ * @author Inferno */
+public abstract class ParticleSorter {
+	static final Vector3 TMP_V1 = new Vector3();
+	
+	/** Using this class will not apply sorting */
+	public static class None extends ParticleSorter{
+		int currentCapacity = 0;
+		int[] indices;
+		
+		@Override
+		public void ensureCapacity (int capacity) {
+			if(currentCapacity < capacity){
+				indices = new int[capacity];
+				for(int i=0; i < capacity; ++i)
+					indices[i] = i;
+				currentCapacity = capacity;
+			}
+		}
+		
+		@Override
+		public  <T extends ParticleControllerRenderData> int[] sort(Array<T> renderData){
+			return indices;
+		}
+	}
+
+	/** This class will sort all the particles using the distance from camera. */
+	public static class Distance extends ParticleSorter{
+		private float[] distances;
+		private int[] particleIndices, particleOffsets;
+		private int currentSize = 0;
+		
+		@Override
+		public void ensureCapacity (int capacity) {
+			if(currentSize < capacity){
+				distances = new float[capacity];
+				particleIndices = new int[capacity];
+				particleOffsets = new int[capacity];
+				currentSize = capacity;
+			}
+		}
+
+		@Override
+		public  <T extends ParticleControllerRenderData> int[] sort(Array<T> renderData){
+			float[] val = camera.view.val;
+			float cx = val[Matrix4.M20], cy = val[Matrix4.M21], cz = val[Matrix4.M22];
+			int count = 0, i = 0;
+			for(ParticleControllerRenderData data : renderData){
+				for(int k=0, c = i+data.controller.particles.size; i <c; ++i, k+=data.positionChannel.strideSize){
+					distances[i] = cx*data.positionChannel.data[k+ParticleChannels.XOffset] + cy*data.positionChannel.data[k+ParticleChannels.YOffset] + cz*data.positionChannel.data[k+ParticleChannels.ZOffset];
+					particleIndices[i] = i;
+				}
+				count += data.controller.particles.size;
+			}
+			
+			qsort(0, count-1);
+			
+			for(i=0; i < count; ++i){
+				particleOffsets[particleIndices[i]] = i;
+			}
+			return particleOffsets;
+		}
+
+		public void qsort( int si, int ei){
+			//base case
+			if(si< ei){
+				float tmp;
+				int 	tmpIndex, particlesPivotIndex;
+				//insertion
+				if (ei-si <= 8) {
+					for (int i=si; i <= ei; i++)
+						for (int j=i; j > si && distances[j-1]>distances[j]; j--){
+				           tmp = distances[j]; 
+				           distances[j] = distances[j-1]; 
+				           distances[j-1] = tmp;
+
+				           //Swap indices
+				           tmpIndex = particleIndices[j]; 
+				           particleIndices[j] = particleIndices[j-1]; 
+				           particleIndices[j-1] = tmpIndex;       
+						}
+					return;
+				}
+				
+				//Quick
+				float pivot = distances[si]; 
+				int i = si+1;
+				particlesPivotIndex = particleIndices[si];
+
+				//partition array 
+				for(int j = si+1; j<= ei; j++){
+					if(pivot  > distances[j]){
+						if(j>i){
+							//Swap distances
+							tmp = distances[j]; 
+							distances[j] = distances[i]; 
+							distances[i] = tmp;
+
+							//Swap indices
+							tmpIndex = particleIndices[j]; 
+							particleIndices[j] = particleIndices[i]; 
+							particleIndices[i] = tmpIndex;            
+						}
+						i++; 
+					}
+				}
+
+				//put pivot in right position
+				distances[si] = distances[i-1]; 
+				distances[i-1] = pivot; 
+				particleIndices[si] = particleIndices[i-1]; 
+				particleIndices[i-1] = particlesPivotIndex;
+
+				//call qsort on right and left sides of pivot
+				qsort(si, i-2); 
+				qsort(i, ei); 
+			}
+		}
+	}
+
+	protected Camera camera;
+	
+	/**@return an array of offsets where each particle should be put in the resulting mesh 
+	 * (also if more than one mesh will be generated, this is an absolute offset considering a BIG output array). */
+	public abstract <T extends ParticleControllerRenderData> int[] sort(Array<T> renderData);
+	
+	public void setCamera(Camera camera){
+		this.camera = camera;
+	}
+	/** This method is called when the batch has increased the underlying particle buffer.
+	 * In this way the sorter can increase the data structures used to sort the particles (i.e increase backing array size) */
+	public void ensureCapacity (int capacity) {}	
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleSystem.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleSystem.java
new file mode 100644
index 0000000..df63978
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleSystem.java
@@ -0,0 +1,89 @@
+package com.badlogic.gdx.graphics.g3d.particles;
+
+import com.badlogic.gdx.graphics.g3d.Renderable;
+import com.badlogic.gdx.graphics.g3d.RenderableProvider;
+import com.badlogic.gdx.graphics.g3d.particles.batches.ParticleBatch;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.Pool;
+
+/**Singleton class which manages the particle effects.
+ * It's a utility class to ease particle batches management and particle effects update. 
+ * @author inferno*/
+public final class ParticleSystem implements RenderableProvider{
+	private static ParticleSystem instance;
+	
+	public static ParticleSystem get(){
+		if(instance == null)
+			instance = new ParticleSystem();
+		return instance;
+	}
+	
+	private Array<ParticleBatch<?>> batches;
+	private Array<ParticleEffect> effects;
+	
+	private ParticleSystem () {
+		batches = new Array<ParticleBatch<?>>();
+		effects = new Array<ParticleEffect>();
+	}
+	
+	public void add(ParticleBatch<?> batch){
+		batches.add(batch);
+	}
+	
+	public void add(ParticleEffect effect){
+		effects.add(effect);
+	}
+	
+	public void remove(ParticleEffect effect){
+		effects.removeValue(effect, true);
+	}
+	
+	/**Removes all the effects added to the system */
+	public void removeAll () {
+		effects.clear();
+	}
+	
+	/** Updates the simulation of all effects */
+	public void update(){
+		for(ParticleEffect effect : effects){
+			effect.update();
+		}
+	}
+	
+	public void updateAndDraw(){
+		for(ParticleEffect effect : effects){
+			effect.update();
+			effect.draw();
+		}
+	}
+
+	/** Must be called one time per frame before any particle effect drawing operation will occur. */
+	public void begin(){
+		for(ParticleBatch<?> batch : batches)
+			batch.begin();
+	}
+
+	/** Draws all the particle effects. 
+	 * Call {@link #begin()} before this method and {@link #end()} after.*/
+	public void draw(){
+		for(ParticleEffect effect : effects){
+			effect.draw();
+		}
+	}
+	
+	/** Must be called one time per frame at the end of all drawing operations. */
+	public void end(){
+		for(ParticleBatch<?> batch : batches)
+			batch.end();
+	}
+
+	@Override
+	public void getRenderables (Array<Renderable> renderables, Pool<Renderable> pool) {
+		for(ParticleBatch<?> batch : batches)
+			batch.getRenderables(renderables, pool);
+	}
+
+	public Array<ParticleBatch<?>> getBatches () {
+		return batches;
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ResourceData.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ResourceData.java
new file mode 100644
index 0000000..82ac7d3
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ResourceData.java
@@ -0,0 +1,216 @@
+package com.badlogic.gdx.graphics.g3d.particles;
+
+import com.badlogic.gdx.assets.AssetDescriptor;
+import com.badlogic.gdx.assets.AssetManager;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+import com.badlogic.gdx.utils.Json;
+import com.badlogic.gdx.utils.JsonValue;
+import com.badlogic.gdx.utils.ObjectMap;
+import com.badlogic.gdx.utils.ObjectMap.Entry;
+import com.badlogic.gdx.utils.reflect.ClassReflection;
+import com.badlogic.gdx.utils.reflect.ReflectionException;
+
+/** This class handles the assets and configurations required by a given resource when de/serialized. 
+ * It's handy when a given object or one of its members requires some assets to be loaded to work properly after
+ * being deserialized. To save the assets, the object should implement the {@link Configurable} interface and obtain
+ * a {@link SaveData} object to store every required asset or information which will be used during the loading phase.
+ * The passed in {@link AssetManager} is generally used to find the asset file name for a given resource of a given type.
+ * The class can also store global configurations, this is useful when dealing with objects which should be allocated once
+ * (i.e singleton).
+ * The deserialization process must happen in the same order of serialization, because the per object {@link SaveData} blocks are stored
+ * as an {@link Array} within the {@link ResourceData}, while the global {@link SaveData} instances can be accessed in any order because
+ * require a unique {@link String} and are stored in an {@link ObjectMap}.
+ * @author Inferno */
+public class ResourceData<T> implements Json.Serializable{
+	
+	/** This interface must be implemented by any class requiring additional assets to be loaded/saved */
+	public static interface Configurable<T>{
+		public void save(AssetManager manager, ResourceData<T> resources);
+		public void load(AssetManager manager, ResourceData<T> resources);
+	}
+	
+	/** Contains all the saved data.
+	 * {@link #data} is a map which link an asset name to its instance.
+	 * {@link #assets} is an array of indices addressing a given 
+	 * {@link com.badlogic.gdx.graphics.g3d.particles.ResourceData.AssetData} in the {@link ResourceData} */
+	public static class SaveData implements Json.Serializable{
+		ObjectMap<String, Object> data;
+		Array<Integer> assets;
+		private int loadIndex;
+		protected ResourceData resources;
+		
+		public SaveData(){
+			data = new ObjectMap<String, Object>();
+			assets = new Array<Integer>();
+			loadIndex = 0;
+		}
+		
+		public SaveData(ResourceData resources){
+			data = new ObjectMap<String, Object>();
+			assets = new Array<Integer>();
+			loadIndex = 0;
+			this.resources = resources;
+		}
+
+		public <K> void saveAsset(String filename, Class<K> type){
+			int i = resources.getAssetData(filename, type);
+			if(i == -1){
+				resources.sharedAssets.add(new AssetData(filename, type));
+				i = resources.sharedAssets.size -1;
+			}
+			assets.add(i);
+		}
+		
+		public void save(String key, Object value){
+			data.put(key, value);
+		}
+		
+		public AssetDescriptor loadAsset(){
+			if(loadIndex == assets.size) return null;
+			AssetData data = (AssetData)resources.sharedAssets.get(assets.get(loadIndex++));
+			return new AssetDescriptor(data.filename, data.type);
+		}
+
+		public <K> K load(String key){
+			return (K)data.get(key);
+		}
+		
+		@Override
+		public void write (Json json) {
+			json.writeValue("data", data, ObjectMap.class);
+			json.writeValue("indices", assets.toArray(Integer.class), Integer[].class);
+		}
+
+		@Override
+		public void read (Json json, JsonValue jsonData) {
+			data = json.readValue("data", ObjectMap.class, jsonData);
+			assets.addAll(json.readValue("indices", Integer[].class, jsonData));
+		}
+	}
+	
+	/** This class contains all the information related to a given asset */
+	public static class AssetData<T> implements Json.Serializable{
+		public String filename;
+		public Class<T> type;
+		public AssetData(){}
+		public AssetData(String filename, Class<T> type){
+			this.filename = filename;
+			this.type = type;
+		}
+		@Override
+		public void write (Json json) {
+			json.writeValue("filename", filename);
+			json.writeValue("type", type.getName());
+		}
+		@Override
+		public void read (Json json, JsonValue jsonData) {
+			filename = json.readValue("filename", String.class, jsonData);
+			String className = json.readValue("type", String.class, jsonData);
+			try {
+				type = (Class<T>)ClassReflection.forName(className);
+			} catch (ReflectionException e) {
+				throw new GdxRuntimeException("Class not found: " + className, e);
+			}
+		}
+	}
+	
+	/** Unique data, can be used to save/load generic data which is not always loaded back after saving.
+	 * Must be used to store data which is uniquely addressable by a given string (i.e a system configuration).*/
+	private ObjectMap<String, SaveData> uniqueData;
+	
+	/** Objects save data, must be loaded in the same saving order*/
+	private Array<SaveData> data;
+	
+	/** Shared assets among all the configurable objects*/
+	Array<AssetData> sharedAssets;
+	private int currentLoadIndex;
+	public T resource;
+
+	public ResourceData(){
+		uniqueData = new ObjectMap<String, SaveData>();
+		data = new Array<SaveData>(true, 3, SaveData.class);
+		sharedAssets = new Array<AssetData>();
+		currentLoadIndex = 0;
+	}
+	
+	public ResourceData(T resource){
+		this();
+		this.resource = resource;
+	}
+	
+	<K> int getAssetData(String filename, Class<K> type){
+		int i=0;
+		for(AssetData data : sharedAssets){
+			if(data.filename.equals(filename) && data.type.equals(type)){
+				return i;
+			}
+			++i;
+		}
+		return -1;
+	}
+	
+	public Array<AssetDescriptor> getAssetDescriptors () {
+		Array<AssetDescriptor> descriptors = new Array<AssetDescriptor>();
+		for(AssetData data : sharedAssets){
+			descriptors.add(new AssetDescriptor<T>(data.filename, data.type));
+		}
+		return descriptors;
+	}
+	
+	public Array<AssetData> getAssets(){
+		return sharedAssets;
+	}
+
+	/** Creates and adds a new SaveData object to the save data list*/
+	public SaveData createSaveData() {
+		SaveData saveData = new SaveData(this);
+		data.add(saveData);
+		return saveData;
+	}
+
+	/** Creates and adds a new and unique SaveData object to the save data map*/
+	public SaveData createSaveData(String key) {
+		SaveData saveData = new SaveData(this);
+		if(uniqueData.containsKey(key))
+			throw new RuntimeException("Key already used, data must be unique, use a different key");
+		uniqueData.put(key, saveData);
+		return saveData;
+	}
+
+	/** @return the next save data in the list */
+	public SaveData getSaveData() {
+		return data.get(currentLoadIndex++);
+	}
+	
+	/** @return the unique save data in the map */
+	public SaveData getSaveData(String key) {
+		return uniqueData.get(key);
+	}
+
+	@Override
+	public void write (Json json) {
+		json.writeValue("unique", uniqueData, ObjectMap.class);
+		json.writeValue("data", data, Array.class, SaveData.class);
+		json.writeValue("assets", sharedAssets.toArray(AssetData.class), AssetData[].class);
+		json.writeValue("resource", resource, null);
+	}
+
+	@Override
+	public void read (Json json, JsonValue jsonData) {
+		uniqueData = json.readValue("unique", ObjectMap.class, jsonData);
+		for(Entry<String, SaveData> entry : uniqueData.entries()){
+			entry.value.resources = this;
+		}
+		
+		data = json.readValue("data", Array.class, SaveData.class, jsonData);
+		for(SaveData saveData : data){
+			saveData.resources = this;
+		}
+		
+		sharedAssets.addAll(json.readValue("assets", AssetData[].class, jsonData));
+		resource = json.readValue("resource", null, jsonData);
+	}
+
+	
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/BillboardParticleBatch.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/BillboardParticleBatch.java
new file mode 100644
index 0000000..f40baa6
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/BillboardParticleBatch.java
@@ -0,0 +1,684 @@
+package com.badlogic.gdx.graphics.g3d.particles.batches;
+
+import com.badlogic.gdx.assets.AssetManager;
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.VertexAttribute;
+import com.badlogic.gdx.graphics.VertexAttributes;
+import com.badlogic.gdx.graphics.VertexAttributes.Usage;
+import com.badlogic.gdx.graphics.g3d.Material;
+import com.badlogic.gdx.graphics.g3d.Renderable;
+import com.badlogic.gdx.graphics.g3d.Shader;
+import com.badlogic.gdx.graphics.g3d.attributes.BlendingAttribute;
+import com.badlogic.gdx.graphics.g3d.attributes.DepthTestAttribute;
+import com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute;
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.FloatChannel;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleShader;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleShader.AlignMode;
+import com.badlogic.gdx.graphics.g3d.particles.ResourceData;
+import com.badlogic.gdx.graphics.g3d.particles.ResourceData.SaveData;
+import com.badlogic.gdx.graphics.g3d.particles.renderers.BillboardControllerRenderData;
+import com.badlogic.gdx.graphics.g3d.shaders.DefaultShader;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.math.Matrix3;
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.Pool;
+
+
+/** This class is used to render billboard particles.
+ * @author Inferno */
+public class BillboardParticleBatch extends BufferedParticleBatch<BillboardControllerRenderData> {
+	protected static final Vector3 TMP_V1 = new Vector3(), 
+		 TMP_V2 = new Vector3(), 
+		 TMP_V3 = new Vector3(), 
+		 TMP_V4 = new Vector3(), 
+		 TMP_V5 = new Vector3(),
+		 TMP_V6 = new Vector3();
+	protected static final Matrix3 TMP_M3 = new Matrix3();
+	//Attributes	
+	protected static final int sizeAndRotationUsage = 1 << 9, directionUsage = 1 << 10;
+	private static final VertexAttributes 
+		GPU_ATTRIBUTES = new VertexAttributes(new VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE), 
+															new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE+"0"), 
+															new VertexAttribute(Usage.Color, 4, ShaderProgram.COLOR_ATTRIBUTE), 
+															new VertexAttribute(sizeAndRotationUsage, 4, "a_sizeAndRotation")),
+															/*
+		GPU_EXT_ATTRIBUTES = new VertexAttributes(new VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE), 
+									new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE+"0"), 
+									new VertexAttribute(Usage.Color, 4, ShaderProgram.COLOR_ATTRIBUTE), 
+									new VertexAttribute(sizeAndRotationUsage, 4, "a_sizeAndRotation"),
+									new VertexAttribute(directionUsage, 3, "a_direction")),
+									*/
+		CPU_ATTRIBUTES = new VertexAttributes(	new VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE), 
+															new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE+"0"), 
+															new VertexAttribute(Usage.Color, 4, ShaderProgram.COLOR_ATTRIBUTE) );
+	
+	//Offsets
+	private static final int 	GPU_POSITION_OFFSET = (short)(GPU_ATTRIBUTES.findByUsage(Usage.Position).offset/4),
+										GPU_UV_OFFSET = (short)(GPU_ATTRIBUTES.findByUsage(Usage.TextureCoordinates).offset/4),
+										GPU_SIZE_ROTATION_OFFSET = (short)(GPU_ATTRIBUTES.findByUsage(sizeAndRotationUsage).offset/4),
+										GPU_COLOR_OFFSET = (short)(GPU_ATTRIBUTES.findByUsage(Usage.Color).offset/4),
+										GPU_VERTEX_SIZE = GPU_ATTRIBUTES.vertexSize/4,
+
+										//Ext
+										/*
+										GPU_EXT_POSITION_OFFSET = (short)(GPU_EXT_ATTRIBUTES.findByUsage(Usage.Position).offset/4),
+										GPU_EXT_UV_OFFSET = (short)(GPU_EXT_ATTRIBUTES.findByUsage(Usage.TextureCoordinates).offset/4),
+										GPU_EXT_SIZE_ROTATION_OFFSET = (short)(GPU_EXT_ATTRIBUTES.findByUsage(sizeAndRotationUsage).offset/4),
+										GPU_EXT_COLOR_OFFSET = (short)(GPU_EXT_ATTRIBUTES.findByUsage(Usage.Color).offset/4),
+										GPU_EXT_DIRECTION_OFFSET = (short)(GPU_EXT_ATTRIBUTES.findByUsage(directionUsage).offset/4),
+										GPU_EXT_VERTEX_SIZE = GPU_EXT_ATTRIBUTES.vertexSize/4,
+										*/
+										
+										//Cpu
+										CPU_POSITION_OFFSET = (short)(CPU_ATTRIBUTES.findByUsage(Usage.Position).offset/4),
+										CPU_UV_OFFSET = (short)(CPU_ATTRIBUTES.findByUsage(Usage.TextureCoordinates).offset/4),
+										CPU_COLOR_OFFSET = (short)(CPU_ATTRIBUTES.findByUsage(Usage.Color).offset/4),
+										CPU_VERTEX_SIZE= CPU_ATTRIBUTES.vertexSize/4;
+	private final static int 	MAX_PARTICLES_PER_MESH = Short.MAX_VALUE/4,
+										MAX_VERTICES_PER_MESH = MAX_PARTICLES_PER_MESH*4;
+	
+	private class RenderablePool extends Pool<Renderable>{
+		public RenderablePool () {}
+
+		@Override
+		public Renderable newObject () {
+			return allocRenderable();
+		}	
+	}
+	
+	public static class Config{
+		public Config(){}
+		public Config (boolean useGPU, AlignMode mode) {
+			this.useGPU = useGPU;
+			this.mode = mode;
+		}
+		boolean useGPU;
+		AlignMode mode;
+	}
+	
+	private RenderablePool renderablePool;
+	private Array<Renderable> renderables;
+	private float[] vertices;
+	private short[] indices;
+	private int currentVertexSize = 0;
+	private VertexAttributes currentAttributes;
+	protected boolean useGPU = false;
+	protected AlignMode mode = AlignMode.Screen;
+	protected Texture texture;
+	Shader shader;
+	
+	public BillboardParticleBatch(AlignMode mode, boolean useGPU, int capacity){
+		super(BillboardControllerRenderData.class);
+		renderables = new Array<Renderable>();
+		renderablePool = new RenderablePool();
+		allocIndices();
+		initRenderData();
+		ensureCapacity(capacity);
+		setUseGpu(useGPU);
+		setAlignMode(mode);
+	}
+
+	public BillboardParticleBatch () {
+		this(AlignMode.Screen, false, 100);
+	}
+	
+	public BillboardParticleBatch (int capacity) {
+		this(AlignMode.Screen, false, capacity);
+	}
+
+	@Override
+	public void allocParticlesData(int capacity){
+		vertices = new float[currentVertexSize*4*capacity];
+		allocRenderables(capacity);
+	}
+
+	protected Renderable allocRenderable(){
+		Renderable renderable = new Renderable();
+		renderable.primitiveType = GL20.GL_TRIANGLES;
+		renderable.meshPartOffset = 0;
+		renderable.material = new Material(	new BlendingAttribute(GL20.GL_ONE, GL20.GL_ONE_MINUS_SRC_ALPHA, 1f),
+			new DepthTestAttribute(GL20.GL_LEQUAL, false),
+			TextureAttribute.createDiffuse(texture));
+		renderable.mesh = new Mesh(false, MAX_VERTICES_PER_MESH, MAX_PARTICLES_PER_MESH*6, currentAttributes);
+		renderable.mesh.setIndices(indices);
+		renderable.shader = shader;
+		return renderable;
+	}
+	
+	private void allocIndices(){
+		int indicesCount = MAX_PARTICLES_PER_MESH * 6;
+		indices = new short[indicesCount];
+		for(int i=0, vertex = 0; i < indicesCount; i+=6, vertex+=4){
+			indices[i] = (short)vertex;
+			indices[i+1] = (short)(vertex+1);
+			indices[i+2] = (short)(vertex+2);
+			indices[i+3] = (short)(vertex+2);
+			indices[i+4] = (short)(vertex+3);
+			indices[i+5] = (short)vertex;
+		}
+	}
+	
+	private void allocRenderables(int capacity){			
+		//Free old meshes
+		int 	meshCount = MathUtils.ceil( capacity/MAX_PARTICLES_PER_MESH),
+				free = renderablePool.getFree();
+		if(free < meshCount){
+			for(int i=0, left = meshCount - free; i < left;++i)
+				renderablePool.free(renderablePool.newObject());
+		}
+	}
+	
+	private Shader getShader (Renderable renderable) {
+		Shader shader = useGPU 	? 	new ParticleShader(renderable, new ParticleShader.Config(mode)) :
+								new DefaultShader(renderable);
+		shader.init();
+		return shader;
+	}
+	
+	private void allocShader () {
+		Renderable newRenderable = allocRenderable();
+		shader = newRenderable.shader = getShader(newRenderable);
+		renderablePool.free(newRenderable);
+	}
+	
+	private void clearRenderablesPool(){
+		renderablePool.freeAll(renderables);
+		for(int i=0, free = renderablePool.getFree(); i < free; ++i){
+			Renderable renderable = renderablePool.obtain();
+			renderable.mesh.dispose();
+		}
+		renderables.clear();
+	}
+	
+	/** Sets vertex attributes and size */
+	public void setVertexData(){
+		if(useGPU){
+			currentAttributes = GPU_ATTRIBUTES;
+			currentVertexSize = GPU_VERTEX_SIZE;
+			/*
+			if(mode == AlignMode.ParticleDirection){
+				currentAttributes = GPU_EXT_ATTRIBUTES;
+				currentVertexSize = GPU_EXT_VERTEX_SIZE;
+			}
+			else{
+				currentAttributes = GPU_ATTRIBUTES;
+				currentVertexSize = GPU_VERTEX_SIZE;
+			}
+			*/
+		}
+		else {
+			currentAttributes = CPU_ATTRIBUTES;
+			currentVertexSize = CPU_VERTEX_SIZE;
+		}
+	}
+	
+	/** Allocates all the require rendering resources like Renderables,Shaders,Meshes
+	 *  according to the current batch configuration.*/
+	private void initRenderData () {
+		setVertexData();
+		clearRenderablesPool();
+		allocShader();
+		resetCapacity();
+	}
+	
+	/** Sets the current align mode.
+	 *  It will reallocate internal data, use only when necessary. */
+	public void setAlignMode(AlignMode mode){
+		if(mode != this.mode){
+			this.mode = mode;
+			if(useGPU){
+				initRenderData();
+				allocRenderables(bufferedParticlesCount);
+			}
+		}
+	}
+	
+	public AlignMode getAlignMode(){
+		return mode;
+	}
+	
+	/** Sets the current align mode.
+	*  It will reallocate internal data, use only when necessary. */
+	public void setUseGpu(boolean useGPU){
+		if(this.useGPU != useGPU){
+			this.useGPU = useGPU;
+			initRenderData();
+			allocRenderables(bufferedParticlesCount);
+		}
+	}
+
+	public boolean isUseGPU(){
+		return useGPU;
+	}
+	
+	public void setTexture(Texture texture){
+		renderablePool.freeAll(renderables);
+		renderables.clear();
+		for(int i=0, free = renderablePool.getFree(); i < free; ++i){
+			Renderable renderable = renderablePool.obtain();
+			TextureAttribute attribute = (TextureAttribute) renderable.material.get(TextureAttribute.Diffuse);
+			attribute.textureDescription.texture = texture;
+		}
+		this.texture = texture;
+	}
+	
+	public Texture getTexture () {
+		return texture;
+	}
+	
+	@Override
+	public void begin () {
+		super.begin();
+		renderablePool.freeAll(renderables);
+		renderables.clear();
+	}
+	
+	//GPU
+	//Required + Color + Rotation
+	private static void putVertex( float[] vertices,  int offset, float x, float y, float z, float u, float v, float scaleX, float scaleY,  float cosRotation, float sinRotation, float r, float g, float b, float a) {
+		//Position
+		vertices[offset + GPU_POSITION_OFFSET] = x;
+		vertices[offset + GPU_POSITION_OFFSET+1] = y;
+		vertices[offset + GPU_POSITION_OFFSET+2] = z;
+		//UV
+		vertices[offset + GPU_UV_OFFSET] = u;
+		vertices[offset + GPU_UV_OFFSET+1] = v;
+		//Scale
+		vertices[offset + GPU_SIZE_ROTATION_OFFSET] = scaleX;
+		vertices[offset + GPU_SIZE_ROTATION_OFFSET+1] = scaleY;
+		vertices[offset + GPU_SIZE_ROTATION_OFFSET+2] = cosRotation;
+		vertices[offset + GPU_SIZE_ROTATION_OFFSET+3] = sinRotation;
+		//Color
+		vertices[offset + GPU_COLOR_OFFSET] = r;
+		vertices[offset + GPU_COLOR_OFFSET+1] = g;
+		vertices[offset + GPU_COLOR_OFFSET+2] = b;
+		vertices[offset + GPU_COLOR_OFFSET+3] = a;
+	}
+
+	/*
+	//Required + Color + Rotation + Direction
+	private static void putVertex( float[] vertices,  int offset, float x, float y, float z, float u, float v, float scaleX, float scaleY,  float cosRotation, float sinRotation, float r, float g, float b, float a, Vector3 direction) {
+		//Position
+		vertices[offset + GPU_EXT_POSITION_OFFSET] = x;
+		vertices[offset + GPU_EXT_POSITION_OFFSET+1] = y;
+		vertices[offset + GPU_EXT_POSITION_OFFSET+2] = z;
+		//UV
+		vertices[offset + GPU_EXT_UV_OFFSET] = u;
+		vertices[offset + GPU_EXT_UV_OFFSET+1] = v;
+		//Scale
+		vertices[offset + GPU_EXT_SIZE_ROTATION_OFFSET] = scaleX;
+		vertices[offset + GPU_EXT_SIZE_ROTATION_OFFSET+1] = scaleY;
+		vertices[offset + GPU_EXT_SIZE_ROTATION_OFFSET+2] = cosRotation;
+		vertices[offset + GPU_EXT_SIZE_ROTATION_OFFSET+3] = sinRotation;
+		//Color
+		vertices[offset + GPU_EXT_COLOR_OFFSET] = r;
+		vertices[offset + GPU_EXT_COLOR_OFFSET+1] = g;
+		vertices[offset + GPU_EXT_COLOR_OFFSET+2] = b;
+		vertices[offset + GPU_EXT_COLOR_OFFSET+3] = a;
+		//Direction
+		vertices[offset + GPU_EXT_DIRECTION_OFFSET] = direction.x;
+		vertices[offset + GPU_EXT_DIRECTION_OFFSET +1] = direction.y;
+		vertices[offset + GPU_EXT_DIRECTION_OFFSET +2] = direction.z;
+	}
+	*/
+	
+	
+	//CPU
+	//Required
+	private static void putVertex(float[] vertices, int offset, Vector3 p, float u, float v, float r, float g, float b, float a) {
+		//Position
+		vertices[offset + CPU_POSITION_OFFSET] = p.x;
+		vertices[offset + CPU_POSITION_OFFSET+1] = p.y;
+		vertices[offset + CPU_POSITION_OFFSET+2] = p.z;
+		//UV
+		vertices[offset + CPU_UV_OFFSET] = u;
+		vertices[offset + CPU_UV_OFFSET+1] = v;
+		//Color
+		vertices[offset + CPU_COLOR_OFFSET] = r;
+		vertices[offset + CPU_COLOR_OFFSET+1] = g;
+		vertices[offset + CPU_COLOR_OFFSET+2] = b;
+		vertices[offset + CPU_COLOR_OFFSET+3] = a;
+	}
+
+	private void fillVerticesGPU (int[] particlesOffset) {
+		int tp=0;
+		for(BillboardControllerRenderData data : renderData){
+			FloatChannel scaleChannel = data.scaleChannel;
+			FloatChannel regionChannel = data.regionChannel;
+			FloatChannel positionChannel = data.positionChannel;
+			FloatChannel colorChannel = data.colorChannel;
+			FloatChannel rotationChannel = data.rotationChannel;
+			for(int p=0, c = data.controller.particles.size; p < c; ++p, ++tp){
+				int baseOffset = particlesOffset[tp]*currentVertexSize*4;
+				float scale = scaleChannel.data[p* scaleChannel.strideSize];
+				int regionOffset = p*regionChannel.strideSize;
+				int positionOffset = p*positionChannel.strideSize;
+				int colorOffset = p*colorChannel.strideSize;
+				int rotationOffset = p*rotationChannel.strideSize;
+				float 	px = positionChannel.data[positionOffset + ParticleChannels.XOffset], 
+					py = positionChannel.data[positionOffset + ParticleChannels.YOffset], 
+					pz = positionChannel.data[positionOffset + ParticleChannels.ZOffset];
+				float u = regionChannel.data[regionOffset +ParticleChannels.UOffset];
+				float v = regionChannel.data[regionOffset +ParticleChannels.VOffset];
+				float u2 = regionChannel.data[regionOffset +ParticleChannels.U2Offset];
+				float v2 = regionChannel.data[regionOffset +ParticleChannels.V2Offset];
+				float 	sx = regionChannel.data[regionOffset +ParticleChannels.HalfWidthOffset] * scale, 
+							sy = regionChannel.data[regionOffset+ParticleChannels.HalfHeightOffset]  * scale;
+				float r = colorChannel.data[colorOffset +ParticleChannels.RedOffset];
+				float g = colorChannel.data[colorOffset +ParticleChannels.GreenOffset];
+				float b = colorChannel.data[colorOffset +ParticleChannels.BlueOffset];
+				float a = colorChannel.data[colorOffset +ParticleChannels.AlphaOffset];
+				float cosRotation = rotationChannel.data[rotationOffset +ParticleChannels.CosineOffset];
+				float sinRotation = rotationChannel.data[rotationOffset +ParticleChannels.SineOffset];
+
+				//bottom left, bottom right, top right, top left
+				putVertex(vertices, baseOffset, px, py, pz, u, v2, -sx, -sy, cosRotation, sinRotation, r, g, b, a);
+				baseOffset += currentVertexSize;
+				putVertex(vertices, baseOffset, px, py, pz, u2, v2, sx, -sy, cosRotation, sinRotation, r, g, b, a);
+				baseOffset += currentVertexSize;
+				putVertex(vertices, baseOffset, px, py, pz, u2, v, sx, sy, cosRotation, sinRotation, r, g, b, a);
+				baseOffset += currentVertexSize;
+				putVertex(vertices, baseOffset, px, py, pz, u, v, -sx, sy, cosRotation, sinRotation, r, g, b, a);
+				baseOffset += currentVertexSize;
+			}
+		}
+	}
+
+	/*
+	private void fillVerticesToParticleDirectionGPU (int[] particlesOffset) {
+		int tp=0;
+		for(BillboardControllerRenderData data : renderData){
+			FloatChannel scaleChannel = data.scaleChannel;
+			FloatChannel regionChannel = data.regionChannel;
+			FloatChannel positionChannel = data.positionChannel;
+			FloatChannel colorChannel = data.colorChannel;
+			FloatChannel rotationChannel = data.rotationChannel;
+
+			for(int p=0, c = data.controller.particles.size; p < c; ++p, ++tp){
+				int baseOffset = particlesOffset[tp]*currentVertexSize*4;
+				float scale = scaleChannel.data[p* scaleChannel.strideSize];
+				int regionOffset = p*regionChannel.strideSize;
+				int positionOffset = p*positionChannel.strideSize;
+				int colorOffset = p*colorChannel.strideSize;
+				int rotationOffset = p*rotationChannel.strideSize;
+				int velocityOffset = p* velocityChannel.strideSize;
+				float 	px = positionChannel.data[positionOffset + ParticleChannels.XOffset], 
+					py = positionChannel.data[positionOffset + ParticleChannels.YOffset], 
+					pz = positionChannel.data[positionOffset + ParticleChannels.ZOffset];
+				float u = regionChannel.data[regionOffset +ParticleChannels.UOffset];
+				float v = regionChannel.data[regionOffset +ParticleChannels.VOffset];
+				float u2 = regionChannel.data[regionOffset +ParticleChannels.U2Offset];
+				float v2 = regionChannel.data[regionOffset +ParticleChannels.V2Offset];
+				float 	sx = regionChannel.data[regionOffset +ParticleChannels.HalfWidthOffset] * scale, 
+							sy = regionChannel.data[regionOffset+ParticleChannels.HalfHeightOffset]  * scale;
+				float r = colorChannel.data[colorOffset +ParticleChannels.RedOffset];
+				float g = colorChannel.data[colorOffset +ParticleChannels.GreenOffset];
+				float b = colorChannel.data[colorOffset +ParticleChannels.BlueOffset];
+				float a = colorChannel.data[colorOffset +ParticleChannels.AlphaOffset];
+				float cosRotation = rotationChannel.data[rotationOffset +ParticleChannels.CosineOffset];
+				float sinRotation = rotationChannel.data[rotationOffset +ParticleChannels.SineOffset];
+				float 	vx = velocityChannel.data[velocityOffset + ParticleChannels.XOffset], 
+							vy = velocityChannel.data[velocityOffset + ParticleChannels.YOffset], 
+							vz = velocityChannel.data[velocityOffset + ParticleChannels.ZOffset];
+				
+				//bottom left, bottom right, top right, top left
+				TMP_V1.set(vx, vy, vz).nor();
+				putVertex(vertices, baseOffset, px, py, pz, u, v2, -sx, -sy, cosRotation, sinRotation, r, g, b, a, TMP_V1);
+				baseOffset += currentVertexSize;
+				putVertex(vertices, baseOffset, px, py, pz, u2, v2, sx, -sy, cosRotation, sinRotation, r, g, b, a, TMP_V1);
+				baseOffset += currentVertexSize;
+				putVertex(vertices, baseOffset, px, py, pz, u2, v, sx, sy, cosRotation, sinRotation, r, g, b, a, TMP_V1);
+				baseOffset += currentVertexSize;
+				putVertex(vertices, baseOffset, px, py, pz, u, v, -sx, sy, cosRotation, sinRotation, r, g, b, a, TMP_V1);
+			}
+		}
+	}
+	
+	private void fillVerticesToParticleDirectionCPU (int[] particlesOffset) {
+		int tp=0;
+		for(ParticleController controller : renderData){
+			FloatChannel scaleChannel = controller.particles.getChannel(ParticleChannels.Scale);
+			FloatChannel regionChannel = controller.particles.getChannel(ParticleChannels.TextureRegion);
+			FloatChannel positionChannel = controller.particles.getChannel(ParticleChannels.Position);
+			FloatChannel colorChannel = controller.particles.getChannel(ParticleChannels.Color);
+			FloatChannel rotationChannel = controller.particles.getChannel(ParticleChannels.Rotation2D);
+			FloatChannel velocityChannel = controller.particles.getChannel(ParticleChannels.Accelleration);
+
+			for(int p=0, c = controller.particles.size; p < c; ++p, ++tp){
+				int baseOffset = particlesOffset[tp]*currentVertexSize*4;
+				float scale = scaleChannel.data[p* scaleChannel.strideSize];
+				int regionOffset = p*regionChannel.strideSize;
+				int positionOffset = p*positionChannel.strideSize;
+				int colorOffset = p*colorChannel.strideSize;
+				int rotationOffset = p*rotationChannel.strideSize;
+				int velocityOffset = p* velocityChannel.strideSize;
+				float 	px = positionChannel.data[positionOffset + ParticleChannels.XOffset], 
+					py = positionChannel.data[positionOffset + ParticleChannels.YOffset], 
+					pz = positionChannel.data[positionOffset + ParticleChannels.ZOffset];
+				float u = regionChannel.data[regionOffset +ParticleChannels.UOffset];
+				float v = regionChannel.data[regionOffset +ParticleChannels.VOffset];
+				float u2 = regionChannel.data[regionOffset +ParticleChannels.U2Offset];
+				float v2 = regionChannel.data[regionOffset +ParticleChannels.V2Offset];
+				float 	sx = regionChannel.data[regionOffset +ParticleChannels.HalfWidthOffset] * scale, 
+							sy = regionChannel.data[regionOffset+ParticleChannels.HalfHeightOffset]  * scale;
+				float r = colorChannel.data[colorOffset +ParticleChannels.RedOffset];
+				float g = colorChannel.data[colorOffset +ParticleChannels.GreenOffset];
+				float b = colorChannel.data[colorOffset +ParticleChannels.BlueOffset];
+				float a = colorChannel.data[colorOffset +ParticleChannels.AlphaOffset];
+				float cosRotation = rotationChannel.data[rotationOffset +ParticleChannels.CosineOffset];
+				float sinRotation = rotationChannel.data[rotationOffset +ParticleChannels.SineOffset];
+				float 	vx = velocityChannel.data[velocityOffset + ParticleChannels.XOffset], 
+							vy = velocityChannel.data[velocityOffset + ParticleChannels.YOffset], 
+							vz = velocityChannel.data[velocityOffset + ParticleChannels.ZOffset];
+				Vector3 up = TMP_V1.set(vx,vy,vz).nor(),		
+								look = TMP_V3.set(camera.position).sub(px,py,pz).nor(), //normal
+								right = TMP_V2.set(up).crs(look).nor(); //tangent
+				look.set(right).crs(up).nor();
+				right.scl(sx);
+				up.scl(sy);
+
+				if(cosRotation != 1){
+					TMP_M3.setToRotation(look, cosRotation, sinRotation);
+					putVertex(vertices, baseOffset, TMP_V6.set(-TMP_V1.x-TMP_V2.x, -TMP_V1.y-TMP_V2.y, -TMP_V1.z-TMP_V2.z).mul(TMP_M3).add(px, py, pz), u, v2, r, g, b, a);
+					baseOffset += currentVertexSize;
+					putVertex(vertices, baseOffset,TMP_V6.set(TMP_V1.x-TMP_V2.x, TMP_V1.y-TMP_V2.y, TMP_V1.z-TMP_V2.z).mul(TMP_M3).add(px, py, pz), u2, v2, r, g, b, a);
+					baseOffset += currentVertexSize;
+					putVertex(vertices, baseOffset,TMP_V6.set(TMP_V1.x+TMP_V2.x, TMP_V1.y+TMP_V2.y, TMP_V1.z+TMP_V2.z).mul(TMP_M3).add(px, py, pz), u2, v, r, g, b, a);
+					baseOffset += currentVertexSize;
+					putVertex(vertices, baseOffset, TMP_V6.set(-TMP_V1.x+TMP_V2.x, -TMP_V1.y+TMP_V2.y, -TMP_V1.z+TMP_V2.z).mul(TMP_M3).add(px, py, pz), u, v, r, g, b, a);
+				}
+				else {
+					putVertex(vertices, baseOffset,TMP_V6.set(-TMP_V1.x-TMP_V2.x+px, -TMP_V1.y-TMP_V2.y+py, -TMP_V1.z-TMP_V2.z+pz), u, v2, r, g, b, a);
+					baseOffset += currentVertexSize;
+					putVertex(vertices, baseOffset,TMP_V6.set(TMP_V1.x-TMP_V2.x+px, TMP_V1.y-TMP_V2.y+py, TMP_V1.z-TMP_V2.z+pz), u2, v2, r, g, b, a);
+					baseOffset += currentVertexSize;
+					putVertex(vertices, baseOffset,TMP_V6.set(TMP_V1.x+TMP_V2.x+px, TMP_V1.y+TMP_V2.y+py, TMP_V1.z+TMP_V2.z+pz), u2, v, r, g, b, a);
+					baseOffset += currentVertexSize;
+					putVertex(vertices, baseOffset, TMP_V6.set(-TMP_V1.x+TMP_V2.x+px, -TMP_V1.y+TMP_V2.y+py, -TMP_V1.z+TMP_V2.z+pz), u, v, r, g, b, a);
+				}
+			}
+		}
+	}
+	*/
+
+	private void fillVerticesToViewPointCPU (int[] particlesOffset) {
+		int tp=0;
+		for(BillboardControllerRenderData data : renderData){
+			FloatChannel scaleChannel = data.scaleChannel;
+			FloatChannel regionChannel = data.regionChannel;
+			FloatChannel positionChannel = data.positionChannel;
+			FloatChannel colorChannel = data.colorChannel;
+			FloatChannel rotationChannel = data.rotationChannel;
+
+			for(int p=0, c = data.controller.particles.size; p < c; ++p, ++tp){
+				int baseOffset = particlesOffset[tp]*currentVertexSize*4;
+				float scale = scaleChannel.data[p* scaleChannel.strideSize];
+				int regionOffset = p*regionChannel.strideSize;
+				int positionOffset = p*positionChannel.strideSize;
+				int colorOffset = p*colorChannel.strideSize;
+				int rotationOffset = p*rotationChannel.strideSize;
+				float 	px = positionChannel.data[positionOffset + ParticleChannels.XOffset], 
+					py = positionChannel.data[positionOffset + ParticleChannels.YOffset], 
+					pz = positionChannel.data[positionOffset + ParticleChannels.ZOffset];
+				float u = regionChannel.data[regionOffset +ParticleChannels.UOffset];
+				float v = regionChannel.data[regionOffset +ParticleChannels.VOffset];
+				float u2 = regionChannel.data[regionOffset +ParticleChannels.U2Offset];
+				float v2 = regionChannel.data[regionOffset +ParticleChannels.V2Offset];
+				float 	sx = regionChannel.data[regionOffset +ParticleChannels.HalfWidthOffset] * scale, 
+							sy = regionChannel.data[regionOffset+ParticleChannels.HalfHeightOffset]  * scale;
+				float r = colorChannel.data[colorOffset +ParticleChannels.RedOffset];
+				float g = colorChannel.data[colorOffset +ParticleChannels.GreenOffset];
+				float b = colorChannel.data[colorOffset +ParticleChannels.BlueOffset];
+				float a = colorChannel.data[colorOffset +ParticleChannels.AlphaOffset];
+				float cosRotation = rotationChannel.data[rotationOffset +ParticleChannels.CosineOffset];
+				float sinRotation = rotationChannel.data[rotationOffset +ParticleChannels.SineOffset];
+				Vector3 look = TMP_V3.set(camera.position).sub(px, py, pz).nor(), //normal
+								right = TMP_V1.set(camera.up).crs(look).nor(), //tangent
+								up = TMP_V2.set(look).crs(right);
+				right.scl(sx);
+				up.scl(sy);
+
+				if(cosRotation != 1){
+					TMP_M3.setToRotation(look, cosRotation, sinRotation);
+					putVertex(vertices, baseOffset, TMP_V6.set(-TMP_V1.x-TMP_V2.x, -TMP_V1.y-TMP_V2.y, -TMP_V1.z-TMP_V2.z).mul(TMP_M3).add(px, py, pz), u, v2, r, g, b, a);
+					baseOffset += currentVertexSize;
+					putVertex(vertices, baseOffset, TMP_V6.set(TMP_V1.x-TMP_V2.x, TMP_V1.y-TMP_V2.y, TMP_V1.z-TMP_V2.z).mul(TMP_M3).add(px, py, pz), u2, v2, r, g, b, a);
+					baseOffset += currentVertexSize;
+					putVertex(vertices, baseOffset, TMP_V6.set(TMP_V1.x+TMP_V2.x, TMP_V1.y+TMP_V2.y, TMP_V1.z+TMP_V2.z).mul(TMP_M3).add(px, py, pz), u2, v, r, g, b, a);
+					baseOffset += currentVertexSize;
+					putVertex(vertices, baseOffset, TMP_V6.set(-TMP_V1.x+TMP_V2.x, -TMP_V1.y+TMP_V2.y, -TMP_V1.z+TMP_V2.z).mul(TMP_M3).add(px, py, pz), u, v, r, g, b, a);
+				}
+				else {
+					putVertex(vertices, baseOffset, TMP_V6.set(-TMP_V1.x-TMP_V2.x+px, -TMP_V1.y-TMP_V2.y+py, -TMP_V1.z-TMP_V2.z+pz), u, v2, r, g, b, a);
+					baseOffset += currentVertexSize;
+					putVertex(vertices, baseOffset, TMP_V6.set(TMP_V1.x-TMP_V2.x+px, TMP_V1.y-TMP_V2.y+py, TMP_V1.z-TMP_V2.z+pz), u2, v2, r, g, b, a);
+					baseOffset += currentVertexSize;
+					putVertex(vertices, baseOffset, TMP_V6.set(TMP_V1.x+TMP_V2.x+px, TMP_V1.y+TMP_V2.y+py, TMP_V1.z+TMP_V2.z+pz), u2, v, r, g, b, a);
+					baseOffset += currentVertexSize;
+					putVertex(vertices, baseOffset, TMP_V6.set(-TMP_V1.x+TMP_V2.x+px, -TMP_V1.y+TMP_V2.y+py, -TMP_V1.z+TMP_V2.z+pz), u, v, r, g, b, a);
+				}
+			}
+		}
+	}
+
+	private void fillVerticesToScreenCPU (int[] particlesOffset) {
+		Vector3 look = TMP_V3.set(camera.direction).scl(-1),  //normal
+			right = TMP_V4.set(camera.up).crs(look).nor(), //tangent
+			up = camera.up;
+
+		int tp=0;
+		for(BillboardControllerRenderData data : renderData){
+			FloatChannel scaleChannel = data.scaleChannel;
+			FloatChannel regionChannel = data.regionChannel;
+			FloatChannel positionChannel = data.positionChannel;
+			FloatChannel colorChannel = data.colorChannel;
+			FloatChannel rotationChannel = data.rotationChannel;
+
+			for(int p=0, c = data.controller.particles.size; p < c; ++p, ++tp){
+				int baseOffset = particlesOffset[tp]*currentVertexSize*4;
+				float scale = scaleChannel.data[p* scaleChannel.strideSize];
+				int regionOffset = p*regionChannel.strideSize;
+				int positionOffset = p*positionChannel.strideSize;
+				int colorOffset = p*colorChannel.strideSize;
+				int rotationOffset = p*rotationChannel.strideSize;
+				float 	px = positionChannel.data[positionOffset + ParticleChannels.XOffset], 
+					py = positionChannel.data[positionOffset + ParticleChannels.YOffset], 
+					pz = positionChannel.data[positionOffset + ParticleChannels.ZOffset];
+				float u = regionChannel.data[regionOffset +ParticleChannels.UOffset];
+				float v = regionChannel.data[regionOffset +ParticleChannels.VOffset];
+				float u2 = regionChannel.data[regionOffset +ParticleChannels.U2Offset];
+				float v2 = regionChannel.data[regionOffset +ParticleChannels.V2Offset];
+				float 	sx = regionChannel.data[regionOffset +ParticleChannels.HalfWidthOffset] * scale, 
+							sy = regionChannel.data[regionOffset+ParticleChannels.HalfHeightOffset]  * scale;
+				float r = colorChannel.data[colorOffset +ParticleChannels.RedOffset];
+				float g = colorChannel.data[colorOffset +ParticleChannels.GreenOffset];
+				float b = colorChannel.data[colorOffset +ParticleChannels.BlueOffset];
+				float a = colorChannel.data[colorOffset +ParticleChannels.AlphaOffset];
+				float cosRotation = rotationChannel.data[rotationOffset +ParticleChannels.CosineOffset];
+				float sinRotation = rotationChannel.data[rotationOffset +ParticleChannels.SineOffset];
+				TMP_V1.set(right).scl(sx);
+				TMP_V2.set(up).scl(sy);
+
+				if(cosRotation != 1){
+					TMP_M3.setToRotation(look, cosRotation, sinRotation);
+					putVertex( vertices, baseOffset, TMP_V6.set(-TMP_V1.x-TMP_V2.x, -TMP_V1.y-TMP_V2.y, -TMP_V1.z-TMP_V2.z).mul(TMP_M3).add(px, py, pz), u, v2, r, g, b, a);
+					baseOffset += currentVertexSize;
+					putVertex(vertices, baseOffset, TMP_V6.set(TMP_V1.x-TMP_V2.x, TMP_V1.y-TMP_V2.y, TMP_V1.z-TMP_V2.z).mul(TMP_M3).add(px, py, pz), u2, v2, r, g, b, a);
+					baseOffset += currentVertexSize;
+					putVertex(vertices, baseOffset, TMP_V6.set(TMP_V1.x+TMP_V2.x, TMP_V1.y+TMP_V2.y, TMP_V1.z+TMP_V2.z).mul(TMP_M3).add(px, py, pz), u2, v, r, g, b, a);
+					baseOffset += currentVertexSize;
+					putVertex(vertices, baseOffset, TMP_V6.set(-TMP_V1.x+TMP_V2.x, -TMP_V1.y+TMP_V2.y, -TMP_V1.z+TMP_V2.z).mul(TMP_M3).add(px, py, pz), u, v, r, g, b, a);
+				}
+				else {
+					putVertex(vertices, baseOffset, TMP_V6.set(-TMP_V1.x-TMP_V2.x+px, -TMP_V1.y-TMP_V2.y+py, -TMP_V1.z-TMP_V2.z+pz), u, v2, r, g, b, a);
+					baseOffset += currentVertexSize;
+					putVertex(vertices, baseOffset, TMP_V6.set(TMP_V1.x-TMP_V2.x+px, TMP_V1.y-TMP_V2.y+py, TMP_V1.z-TMP_V2.z+pz), u2, v2, r, g, b, a);
+					baseOffset += currentVertexSize;
+					putVertex(vertices, baseOffset, TMP_V6.set(TMP_V1.x+TMP_V2.x+px, TMP_V1.y+TMP_V2.y+py, TMP_V1.z+TMP_V2.z+pz), u2, v, r, g, b, a);
+					baseOffset += currentVertexSize;
+					putVertex(vertices, baseOffset, TMP_V6.set(-TMP_V1.x+TMP_V2.x+px, -TMP_V1.y+TMP_V2.y+py, -TMP_V1.z+TMP_V2.z+pz), u, v, r, g, b, a);
+				}
+			}
+		}
+	}
+	
+	@Override
+	protected void flush(int[] offsets){
+		
+		//fill vertices
+		if(useGPU){
+			//if(mode != AlignMode.ParticleDirection)
+				fillVerticesGPU(offsets);
+			//else
+				//fillVerticesToParticleDirectionGPU(offsets);
+		}
+		else {
+			if(mode == AlignMode.Screen)
+				fillVerticesToScreenCPU(offsets);
+			else if(mode == AlignMode.ViewPoint)
+				fillVerticesToViewPointCPU(offsets);
+			//else 
+				//fillVerticesToParticleDirectionCPU(offsets);
+		}
+			
+		//send vertices to meshes
+		int addedVertexCount = 0;
+		int vCount = bufferedParticlesCount*4;
+		for(int v = 0; v < vCount; v += addedVertexCount){
+			addedVertexCount = Math.min(vCount-v, MAX_VERTICES_PER_MESH);
+			Renderable renderable = renderablePool.obtain();
+			renderable.meshPartSize = (addedVertexCount/4)*6;
+			renderable.mesh.setVertices(vertices, currentVertexSize *v, currentVertexSize * addedVertexCount);
+			renderables.add(renderable);
+		}
+	}
+
+	@Override
+	public void getRenderables (Array<Renderable> renderables, Pool<Renderable> pool) {
+			for(Renderable renderable : this.renderables)
+				renderables.add(pool.obtain().set(renderable));
+	}
+
+	@Override
+	public void save (AssetManager manager, ResourceData resources) {
+		SaveData data = resources.createSaveData("billboardBatch");
+		data.save("cfg", new Config(useGPU, mode));
+		data.saveAsset(manager.getAssetFileName(texture), Texture.class);
+	}
+
+	@Override
+	public void load (AssetManager manager, ResourceData resources) {
+		SaveData data = resources.getSaveData("billboardBatch");
+		if(data != null){
+			setTexture((Texture)manager.get(data.loadAsset()));
+			Config cfg = (Config)data.load("cfg");
+			setUseGpu(cfg.useGPU);
+			setAlignMode(cfg.mode);
+		}
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/BufferedParticleBatch.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/BufferedParticleBatch.java
new file mode 100644
index 0000000..a30348c
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/BufferedParticleBatch.java
@@ -0,0 +1,80 @@
+package com.badlogic.gdx.graphics.g3d.particles.batches;
+
+import com.badlogic.gdx.graphics.Camera;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleSorter;
+import com.badlogic.gdx.graphics.g3d.particles.renderers.ParticleControllerRenderData;
+import com.badlogic.gdx.utils.Array;
+
+/** Base class of all the batches requiring to buffer {@link ParticleControllerRenderData} 
+* @author Inferno */
+public abstract class BufferedParticleBatch<T extends ParticleControllerRenderData> implements ParticleBatch<T> {
+	protected Array<T> renderData;
+	protected int bufferedParticlesCount, currentCapacity = 0;
+	protected ParticleSorter sorter;
+	protected Camera camera;
+	
+	protected BufferedParticleBatch(Class<T> type){
+		this.sorter = new ParticleSorter.Distance();
+		renderData = new com.badlogic.gdx.utils.Array<T>(false, 10, type);
+	}
+	
+	public void begin(){
+		renderData.clear();
+		bufferedParticlesCount = 0;
+	}
+	
+	@Override
+	public void draw (T data) {
+		if(data.controller.particles.size > 0){
+			renderData.add(data);
+			bufferedParticlesCount += data.controller.particles.size;
+		}
+	}
+	
+	/** */
+	public void end(){
+		if(bufferedParticlesCount > 0){
+			ensureCapacity(bufferedParticlesCount);
+			flush(sorter.sort(renderData));
+		}
+	}
+
+	/**Ensure the batch can contain the passed in amount of particles*/
+	public void ensureCapacity(int capacity){
+		if(currentCapacity >= capacity) return;
+		sorter.ensureCapacity(capacity);
+		allocParticlesData(capacity);
+		currentCapacity = capacity;
+	}
+	
+	public void resetCapacity(){
+		currentCapacity = bufferedParticlesCount = 0;
+	}
+	
+	protected abstract void allocParticlesData(int capacity);
+
+	public void setCamera(Camera camera){
+		this.camera = camera;
+		sorter.setCamera(camera);
+	}
+
+	public ParticleSorter getSorter(){
+		return sorter;
+	}
+	
+	public void setSorter(ParticleSorter sorter){
+		this.sorter = sorter;
+		sorter.setCamera(camera);
+		sorter.ensureCapacity(currentCapacity);
+	}
+	
+	/** Sends the data to the gpu. 
+	 * This method must use the calculated offsets to build the particles meshes.
+	 * The offsets represent the position at which a particle should be placed into the vertex array.
+	 * @param offsets the calculated offsets */
+	protected abstract void flush(int[] offsets);
+	
+	public int getBufferedCount () {
+		return bufferedParticlesCount;
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/ModelInstanceParticleBatch.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/ModelInstanceParticleBatch.java
new file mode 100644
index 0000000..f90ad11
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/ModelInstanceParticleBatch.java
@@ -0,0 +1,52 @@
+package com.badlogic.gdx.graphics.g3d.particles.batches;
+
+import com.badlogic.gdx.assets.AssetManager;
+import com.badlogic.gdx.graphics.g3d.Renderable;
+import com.badlogic.gdx.graphics.g3d.particles.ResourceData;
+import com.badlogic.gdx.graphics.g3d.particles.renderers.ModelInstanceControllerRenderData;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.Pool;
+
+/*** This class is used to render particles having a model instance channel.
+ * @author Inferno */
+public class ModelInstanceParticleBatch implements ParticleBatch<ModelInstanceControllerRenderData> {
+	Array<ModelInstanceControllerRenderData> controllersRenderData;
+	int bufferedParticlesCount;
+	public ModelInstanceParticleBatch () {
+		controllersRenderData = new Array<ModelInstanceControllerRenderData>(false, 5);
+	}
+
+	@Override
+	public void getRenderables (Array<Renderable> renderables, Pool<Renderable> pool) {
+		for(ModelInstanceControllerRenderData data : controllersRenderData){
+			for(int i=0, count = data.controller.particles.size; i < count; ++i){
+				data.modelInstanceChannel.data[i].getRenderables(renderables, pool);
+			}
+		}
+	}
+	
+	public int getBufferedCount(){
+		return bufferedParticlesCount;
+	}
+
+	@Override
+	public void begin () {
+		controllersRenderData.clear();
+		bufferedParticlesCount = 0;
+	}
+	
+	@Override
+	public void end () {}
+
+	@Override
+	public void draw (ModelInstanceControllerRenderData data) {
+		controllersRenderData.add(data);
+		bufferedParticlesCount += data.controller.particles.size;
+	}
+
+	@Override
+	public void save (AssetManager manager, ResourceData assetDependencyData) {}
+
+	@Override
+	public void load (AssetManager manager, ResourceData assetDependencyData) {}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/ParticleBatch.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/ParticleBatch.java
new file mode 100644
index 0000000..fa94cbf
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/ParticleBatch.java
@@ -0,0 +1,20 @@
+package com.badlogic.gdx.graphics.g3d.particles.batches;
+
+import com.badlogic.gdx.assets.AssetManager;
+import com.badlogic.gdx.graphics.g3d.RenderableProvider;
+import com.badlogic.gdx.graphics.g3d.particles.ResourceData;
+import com.badlogic.gdx.graphics.g3d.particles.renderers.ParticleControllerRenderData;
+
+/** Common interface to all the batches that render particles. 
+ * @author Inferno */
+public interface ParticleBatch<T extends ParticleControllerRenderData> extends RenderableProvider, ResourceData.Configurable {
+	
+	/** Must be called once before any drawing operation*/
+	public void begin();
+	public void draw (T controller);
+	/** Must be called after all the drawing operations */
+	public void end();
+
+	public void save (AssetManager manager, ResourceData assetDependencyData);
+	public void load (AssetManager manager, ResourceData assetDependencyData);
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/PointSpriteParticleBatch.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/PointSpriteParticleBatch.java
new file mode 100644
index 0000000..e9d6ce4
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/PointSpriteParticleBatch.java
@@ -0,0 +1,156 @@
+package com.badlogic.gdx.graphics.g3d.particles.batches;
+
+import com.badlogic.gdx.Application.ApplicationType;
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.assets.AssetManager;
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.VertexAttribute;
+import com.badlogic.gdx.graphics.VertexAttributes;
+import com.badlogic.gdx.graphics.VertexAttributes.Usage;
+import com.badlogic.gdx.graphics.g3d.Material;
+import com.badlogic.gdx.graphics.g3d.Renderable;
+import com.badlogic.gdx.graphics.g3d.attributes.BlendingAttribute;
+import com.badlogic.gdx.graphics.g3d.attributes.DepthTestAttribute;
+import com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute;
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.FloatChannel;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleShader;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleShader.ParticleType;
+import com.badlogic.gdx.graphics.g3d.particles.ResourceData;
+import com.badlogic.gdx.graphics.g3d.particles.ResourceData.SaveData;
+import com.badlogic.gdx.graphics.g3d.particles.renderers.PointSpriteControllerRenderData;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.Pool;
+
+/** This class is used to draw particles as point sprites. 
+ * @author Inferno */
+public class PointSpriteParticleBatch extends BufferedParticleBatch<PointSpriteControllerRenderData> {
+	private static boolean pointSpritesEnabled = false;
+	protected static final Vector3 TMP_V1 = new Vector3();
+	protected static final int sizeAndRotationUsage = 1 << 9;
+	protected static final VertexAttributes CPU_ATTRIBUTES = new VertexAttributes(
+		new VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE),
+		new VertexAttribute(Usage.Color, 4, ShaderProgram.COLOR_ATTRIBUTE),
+		new VertexAttribute(Usage.TextureCoordinates, 4, "a_region"),
+		new VertexAttribute(sizeAndRotationUsage, 3, "a_sizeAndRotation"));
+	protected static final int CPU_VERTEX_SIZE = (short)(CPU_ATTRIBUTES.vertexSize / 4),
+										CPU_POSITION_OFFSET = (short)(CPU_ATTRIBUTES.findByUsage(Usage.Position).offset/4),
+										CPU_COLOR_OFFSET = (short)(CPU_ATTRIBUTES.findByUsage(Usage.Color).offset/4),
+										CPU_REGION_OFFSET = (short)(CPU_ATTRIBUTES.findByUsage(Usage.TextureCoordinates).offset/4),
+										CPU_SIZE_AND_ROTATION_OFFSET = (short)(CPU_ATTRIBUTES.findByUsage(sizeAndRotationUsage).offset/4);
+
+	private static void enablePointSprites () {
+		Gdx.gl.glEnable(GL20.GL_VERTEX_PROGRAM_POINT_SIZE);
+		if(Gdx.app.getType() == ApplicationType.Desktop) {
+			Gdx.gl.glEnable(0x8861); // GL_POINT_OES
+		}
+		pointSpritesEnabled = true;
+	}
+	
+	private float[] vertices;
+	Renderable renderable;
+	
+	public PointSpriteParticleBatch () {
+		this(1000);
+	}
+	
+	public PointSpriteParticleBatch (int capacity) {
+		super(PointSpriteControllerRenderData.class);
+		
+		if(!pointSpritesEnabled)
+			enablePointSprites();
+			
+		allocRenderable();
+		ensureCapacity(capacity);
+		renderable.shader = new ParticleShader(renderable, new ParticleShader.Config(ParticleType.Point));
+		renderable.shader.init();
+	}
+
+	@Override
+	protected void allocParticlesData(int capacity){
+		vertices = new float[capacity * CPU_VERTEX_SIZE];
+		if(renderable.mesh != null) 
+			renderable.mesh.dispose();
+		renderable.mesh = new Mesh(false, capacity, 0, CPU_ATTRIBUTES);
+	}
+	
+	protected void allocRenderable(){
+		renderable = new Renderable();
+		renderable.primitiveType = GL20.GL_POINTS;
+		renderable.meshPartOffset = 0;
+		renderable.material = new Material(	new BlendingAttribute(GL20.GL_ONE, GL20.GL_ONE_MINUS_SRC_ALPHA, 1f),
+			new DepthTestAttribute(GL20.GL_LEQUAL, false),
+			TextureAttribute.createDiffuse(null));
+	}
+
+	public void setTexture(Texture texture){
+		TextureAttribute attribute = (TextureAttribute) renderable.material.get(TextureAttribute.Diffuse);
+		attribute.textureDescription.texture = texture;
+	}
+
+	public Texture getTexture () {
+		TextureAttribute attribute = (TextureAttribute) renderable.material.get(TextureAttribute.Diffuse);
+		return attribute.textureDescription.texture;
+	}
+	
+	@Override
+	protected void flush(int[] offsets){
+		int tp = 0;
+		for(PointSpriteControllerRenderData data: renderData){
+			FloatChannel scaleChannel = data.scaleChannel;
+			FloatChannel regionChannel = data.regionChannel;
+			FloatChannel positionChannel = data.positionChannel;
+			FloatChannel colorChannel = data.colorChannel;
+			FloatChannel rotationChannel = data.rotationChannel;
+			
+			for (int p = 0; p < data.controller.particles.size; ++p, ++tp) {
+				int offset = offsets[tp]*CPU_VERTEX_SIZE;
+				int regionOffset = p*regionChannel.strideSize;
+				int positionOffset = p*positionChannel.strideSize;
+				int colorOffset = p*colorChannel.strideSize;
+				int rotationOffset = p*rotationChannel.strideSize;
+				
+				vertices[offset + CPU_POSITION_OFFSET] = positionChannel.data[positionOffset + ParticleChannels.XOffset];
+				vertices[offset + CPU_POSITION_OFFSET+1] = positionChannel.data[positionOffset + ParticleChannels.YOffset];
+				vertices[offset + CPU_POSITION_OFFSET+2] = positionChannel.data[positionOffset + ParticleChannels.ZOffset];
+				vertices[offset + CPU_COLOR_OFFSET] = colorChannel.data[colorOffset + ParticleChannels.RedOffset];
+				vertices[offset + CPU_COLOR_OFFSET+1] = colorChannel.data[colorOffset + ParticleChannels.GreenOffset];
+				vertices[offset + CPU_COLOR_OFFSET+2] = colorChannel.data[colorOffset + ParticleChannels.BlueOffset];
+				vertices[offset + CPU_COLOR_OFFSET+3] = colorChannel.data[colorOffset + ParticleChannels.AlphaOffset];
+				vertices[offset + CPU_SIZE_AND_ROTATION_OFFSET] = scaleChannel.data[p* scaleChannel.strideSize];
+				vertices[offset + CPU_SIZE_AND_ROTATION_OFFSET+1] = rotationChannel.data[rotationOffset + ParticleChannels.CosineOffset];
+				vertices[offset + CPU_SIZE_AND_ROTATION_OFFSET+2] = rotationChannel.data[rotationOffset + ParticleChannels.SineOffset];
+				vertices[offset + CPU_REGION_OFFSET] = regionChannel.data[regionOffset + ParticleChannels.UOffset];
+				vertices[offset + CPU_REGION_OFFSET+1] = regionChannel.data[regionOffset + ParticleChannels.VOffset];
+				vertices[offset + CPU_REGION_OFFSET+2] = regionChannel.data[regionOffset + ParticleChannels.U2Offset];
+				vertices[offset + CPU_REGION_OFFSET+3] = regionChannel.data[regionOffset + ParticleChannels.V2Offset];
+			}
+		}
+
+		renderable.meshPartSize = bufferedParticlesCount;
+		renderable.mesh.setVertices(vertices, 0, bufferedParticlesCount*CPU_VERTEX_SIZE);
+	}
+
+	@Override
+	public void getRenderables (Array<Renderable> renderables, Pool<Renderable> pool) {
+		if(bufferedParticlesCount > 0)
+			renderables.add(pool.obtain().set(renderable));
+	}
+
+	@Override
+	public void save (AssetManager manager, ResourceData resources) {
+		SaveData data = resources.createSaveData("pointSpriteBatch");
+		data.saveAsset(manager.getAssetFileName(getTexture()), Texture.class);
+	}
+
+	@Override
+	public void load (AssetManager manager, ResourceData resources) {
+		SaveData data = resources.getSaveData("pointSpriteBatch");
+		if(data != null)
+			setTexture((Texture)manager.get(data.loadAsset()));
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/emitters/Emitter.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/emitters/Emitter.java
new file mode 100644
index 0000000..76fc848
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/emitters/Emitter.java
@@ -0,0 +1,74 @@
+package com.badlogic.gdx.graphics.g3d.particles.emitters;
+
+import com.badlogic.gdx.graphics.g3d.particles.ParticleControllerComponent;
+import com.badlogic.gdx.utils.Json;
+import com.badlogic.gdx.utils.JsonValue;
+
+/** An {@link Emitter} is a {@link ParticleControllerComponent} which will handle the particles emission.
+ * It must update the {@link Emitter#percent} to reflect the current percentage of the current emission cycle. 
+ * It should consider {@link Emitter#minParticleCount} and {@link Emitter#maxParticleCount} to rule particle emission.
+ * It should notify the particle controller when particles are activated, killed, or when an emission cycle begins.
+ * @author Inferno */
+public abstract class  Emitter extends ParticleControllerComponent implements Json.Serializable{
+	/** The min/max quantity of particles */
+	public int minParticleCount, maxParticleCount = 4;
+
+	/** Current state of the emission, should be currentTime/ duration
+	 * Must be updated on each update */
+	public float percent;
+	
+	public Emitter (Emitter regularEmitter) {
+		set(regularEmitter);
+	}
+
+	public Emitter () {}
+	
+	@Override
+	public void init () {
+		controller.particles.size = 0;
+	}
+	
+	@Override
+	public void end () {	
+		controller.particles.size = 0;
+	}
+	
+	public int getMinParticleCount () {
+		return minParticleCount;
+	}
+
+	public void setMinParticleCount (int minParticleCount) {
+		this.minParticleCount = minParticleCount;
+	}
+
+	public int getMaxParticleCount () {
+		return maxParticleCount;
+	}
+	
+	public void setMaxParticleCount (int maxParticleCount) {
+		this.maxParticleCount = maxParticleCount;
+	}
+	
+	public void setParticleCount(int aMin, int aMax){
+		setMinParticleCount(aMin);
+		setMaxParticleCount(aMax);
+	}
+	
+	public void set(Emitter emitter){
+		minParticleCount = emitter.minParticleCount;
+		maxParticleCount = emitter.maxParticleCount;
+	}
+	
+	@Override
+	public void write (Json json) {
+		json.writeValue("minParticleCount", minParticleCount);
+		json.writeValue("maxParticleCount", maxParticleCount);
+	}
+	
+	@Override
+	public void read (Json json, JsonValue jsonData) {
+		minParticleCount = json.readValue("minParticleCount", Integer.class, jsonData);
+		maxParticleCount = json.readValue("maxParticleCount", Integer.class, jsonData);
+	}
+
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/emitters/RegularEmitter.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/emitters/RegularEmitter.java
new file mode 100644
index 0000000..c1bd6d4
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/emitters/RegularEmitter.java
@@ -0,0 +1,274 @@
+package com.badlogic.gdx.graphics.g3d.particles.emitters;
+
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.FloatChannel;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleControllerComponent;
+import com.badlogic.gdx.graphics.g3d.particles.values.RangedNumericValue;
+import com.badlogic.gdx.graphics.g3d.particles.values.ScaledNumericValue;
+import com.badlogic.gdx.utils.Json;
+import com.badlogic.gdx.utils.JsonValue;
+
+/** It's a generic use {@link Emitter} which fits most of the particles simulation scenarios. 
+ * @author Inferno */
+public class RegularEmitter extends Emitter implements Json.Serializable {
+	
+	/** Possible emission modes. Emission mode does not affect already emitted particles. */
+	public enum EmissionMode {
+		/** New particles can be emitted. */
+		Enabled,
+		/** Only valid for continuous emitters. 
+		 * It will only emit particles until the end of the effect duration. 
+		 * After that emission cycle will not be restarted.*/
+		EnabledUntilCycleEnd,
+		/** Prevents new particle emission.*/
+		Disabled
+	}
+	
+	public RangedNumericValue delayValue, durationValue;
+	public ScaledNumericValue 	lifeOffsetValue,
+								lifeValue, 
+								emissionValue;
+	protected int emission, emissionDiff, emissionDelta;
+	protected int lifeOffset, lifeOffsetDiff;
+	protected int life, lifeDiff;
+	protected float duration, delay, durationTimer, delayTimer;
+	private boolean continuous;
+	private EmissionMode emissionMode;
+	
+	private FloatChannel lifeChannel;
+
+	public RegularEmitter(){
+		delayValue = new RangedNumericValue(); 
+		durationValue = new RangedNumericValue();
+		lifeOffsetValue = new ScaledNumericValue();
+		lifeValue = new ScaledNumericValue();
+		emissionValue = new ScaledNumericValue();
+		
+		durationValue.setActive(true);
+		emissionValue.setActive(true);
+		lifeValue.setActive(true);
+		continuous = true;
+		emissionMode = EmissionMode.Enabled;
+	}
+	
+	public RegularEmitter (RegularEmitter regularEmitter) {
+		this();
+		set(regularEmitter);
+	}
+	
+	@Override
+	public void allocateChannels() {
+		lifeChannel = controller.particles.addChannel(ParticleChannels.Life);
+	}
+
+	@Override
+	public void start () {
+		delay = delayValue.active ? delayValue.newLowValue() : 0;
+		delayTimer = 0;
+		durationTimer = 0f;
+		
+		duration = durationValue.newLowValue();
+		percent = durationTimer / (float)duration;
+		
+		emission = (int)emissionValue.newLowValue();
+		emissionDiff = (int)emissionValue.newHighValue();
+		if (!emissionValue.isRelative()) 
+			emissionDiff -= emission;
+
+		life = (int)lifeValue.newLowValue();
+		lifeDiff = (int)lifeValue.newHighValue();
+		if (!lifeValue.isRelative()) 
+			lifeDiff -= life;
+
+		lifeOffset = lifeOffsetValue.active ? (int)lifeOffsetValue.newLowValue() : 0;
+		lifeOffsetDiff = (int)lifeOffsetValue.newHighValue();
+		if (!lifeOffsetValue.isRelative()) 
+			lifeOffsetDiff -= lifeOffset;
+	}
+	
+	public void init(){
+		super.init();
+		emissionDelta = 0; 
+		durationTimer = duration;
+	}
+	
+	public void activateParticles (int startIndex, int count){
+		int 	currentTotaLife = life + (int)(lifeDiff * lifeValue.getScale(percent)),
+				currentLife = currentTotaLife;
+		int offsetTime = (int)(lifeOffset + lifeOffsetDiff * lifeOffsetValue.getScale(percent));
+		if (offsetTime > 0) {
+			if (offsetTime >= currentLife) 
+				offsetTime = currentLife - 1;
+			currentLife -= offsetTime;
+		}
+		float lifePercent = 1 - currentLife / (float)currentTotaLife;
+		
+		for(int i=startIndex*lifeChannel.strideSize, c = i +count*lifeChannel.strideSize; i < c;  i+=lifeChannel.strideSize){
+			lifeChannel.data[i+ParticleChannels.CurrentLifeOffset] = currentLife;
+			lifeChannel.data[i+ParticleChannels.TotalLifeOffset] = currentTotaLife;
+			lifeChannel.data[i+ParticleChannels.LifePercentOffset] = lifePercent;
+		}
+	}
+	
+	public void update () {
+		int deltaMillis = (int)(controller.deltaTime * 1000);
+		
+		if (delayTimer < delay) {
+			delayTimer += deltaMillis;
+		} else {
+			boolean emit = emissionMode != EmissionMode.Disabled;
+			//End check
+			if (durationTimer < duration) {
+				durationTimer += deltaMillis;
+				percent = durationTimer / (float)duration;
+			}
+			else {
+				if (continuous && emit && emissionMode == EmissionMode.Enabled) 
+					controller.start();
+				else 
+					emit = false;
+			}
+			
+			if(emit) {
+				//Emit particles
+				emissionDelta += deltaMillis;
+				float emissionTime = emission + emissionDiff * emissionValue.getScale(percent);
+				if (emissionTime > 0) {
+					emissionTime = 1000 / emissionTime;
+					if (emissionDelta >= emissionTime) {
+						int emitCount = (int)(emissionDelta / emissionTime);
+						emitCount = Math.min(emitCount, maxParticleCount - controller.particles.size);
+						emissionDelta -= emitCount * emissionTime;
+						emissionDelta %= emissionTime;
+						addParticles(emitCount);
+					}
+				}
+				if (controller.particles.size < minParticleCount)
+					addParticles(minParticleCount - controller.particles.size);
+			}
+		}
+
+		//Update particles
+		int activeParticles = controller.particles.size;
+		for (int i = 0, k=0; i < controller.particles.size; ) {
+			if ( (lifeChannel.data[k+ParticleChannels.CurrentLifeOffset] -= deltaMillis) <= 0) {
+				controller.particles.removeElement(i);
+				continue;
+			}
+			else {
+				lifeChannel.data[k+ParticleChannels.LifePercentOffset] = 1- lifeChannel.data[k+ParticleChannels.CurrentLifeOffset]/lifeChannel.data[k+ParticleChannels.TotalLifeOffset];  
+			}
+			++i;
+			k+=lifeChannel.strideSize;
+		}
+		
+		if(controller.particles.size < activeParticles){
+			controller.killParticles(controller.particles.size, activeParticles - controller.particles.size);
+		}
+	}
+	
+	private void addParticles (int count) {
+		count = Math.min(count, maxParticleCount - controller.particles.size);
+		if (count <= 0) return;
+		controller.activateParticles (controller.particles.size, count);
+		controller.particles.size += count;
+	}
+	
+	public ScaledNumericValue getLife () {
+		return lifeValue;
+	}
+
+	public ScaledNumericValue getEmission () {
+		return emissionValue;
+	}
+
+	public RangedNumericValue getDuration () {
+		return durationValue;
+	}
+
+	public RangedNumericValue getDelay () {
+		return delayValue;
+	}
+
+	public ScaledNumericValue getLifeOffset () {
+		return lifeOffsetValue;
+	}
+
+	public boolean isContinuous () {
+		return continuous;
+	}
+
+	public void setContinuous (boolean continuous) {
+		this.continuous = continuous;
+	}
+	
+	/** Gets current emission mode.
+	 * @return Current emission mode.*/
+	public EmissionMode getEmissionMode(){
+		return emissionMode;
+	}
+	
+	/** Sets emission mode. Emission mode does not affect already emitted particles.
+	 * @param emissionMode Emission mode to set.*/
+	public void setEmissionMode(EmissionMode emissionMode){
+		this.emissionMode = emissionMode;
+	}
+	
+	public boolean isComplete () {
+		if (delayTimer < delay) return false;
+		return durationTimer >= duration && controller.particles.size == 0;
+	}
+
+	public float getPercentComplete () {
+		if (delayTimer < delay) return 0;
+		return Math.min(1, durationTimer / (float)duration);
+	}
+
+	public void set (RegularEmitter emitter) {
+		super.set(emitter);
+		delayValue.load(emitter.delayValue); 
+		durationValue.load(emitter.durationValue);
+		lifeOffsetValue.load(emitter.lifeOffsetValue);
+		lifeValue.load(emitter.lifeValue); 
+		emissionValue.load(emitter.emissionValue);
+		emission = emitter.emission;
+		emissionDiff = emitter.emissionDiff; 
+		emissionDelta = emitter.emissionDelta;
+		lifeOffset = emitter.lifeOffset; 
+		lifeOffsetDiff = emitter.lifeOffsetDiff;
+		life = emitter.life; 
+		lifeDiff = emitter.lifeDiff;
+		duration = emitter.duration; 
+		delay = emitter.delay; 
+		durationTimer = emitter.durationTimer;
+		delayTimer = emitter.delayTimer;
+		continuous = emitter.continuous;
+	}
+
+	@Override
+	public ParticleControllerComponent copy () {
+		return new RegularEmitter(this);
+	}
+
+	@Override
+	public void write (Json json) {
+		super.write(json);
+		json.writeValue("continous", continuous);
+		json.writeValue("emission", emissionValue);
+		json.writeValue("delay", delayValue);
+		json.writeValue("duration", durationValue);
+		json.writeValue("life", lifeValue);
+		json.writeValue("lifeOffset", lifeOffsetValue);
+	}
+
+	@Override
+	public void read (Json json, JsonValue jsonData) {
+		super.read(json, jsonData);
+		continuous = json.readValue("continous", boolean.class, jsonData);
+		emissionValue = json.readValue("emission", ScaledNumericValue.class, jsonData);
+		delayValue = json.readValue("delay", RangedNumericValue.class, jsonData);
+		durationValue = json.readValue("duration", RangedNumericValue.class, jsonData);
+		lifeValue = json.readValue("life", ScaledNumericValue.class, jsonData);
+		lifeOffsetValue = json.readValue("lifeOffset", ScaledNumericValue.class, jsonData);
+	}	
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/ColorInfluencer.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/ColorInfluencer.java
new file mode 100644
index 0000000..1f40141
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/ColorInfluencer.java
@@ -0,0 +1,131 @@
+package com.badlogic.gdx.graphics.g3d.particles.influencers;
+
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.FloatChannel;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels;
+import com.badlogic.gdx.graphics.g3d.particles.values.GradientColorValue;
+import com.badlogic.gdx.graphics.g3d.particles.values.ScaledNumericValue;
+import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.utils.Json;
+import com.badlogic.gdx.utils.JsonValue;
+
+/** It's an {@link Influencer} which controls particles color and transparency. 
+ * @author Inferno */
+public abstract class ColorInfluencer extends Influencer{
+	
+	/** It's an {@link Influencer} which assigns a random color when a particle is activated. */
+	public static class Random extends ColorInfluencer{
+		FloatChannel colorChannel;
+		
+		@Override
+		public void allocateChannels() {
+			colorChannel = controller.particles.addChannel(ParticleChannels.Color);
+		}
+		
+		@Override
+		public void activateParticles (int startIndex, int count) {
+			for(int 	i=startIndex*colorChannel.strideSize,  c = i +count*colorChannel.strideSize; 
+				i < c; 
+				i +=colorChannel.strideSize){
+				colorChannel.data[i+ParticleChannels.RedOffset] = MathUtils.random();
+				colorChannel.data[i+ParticleChannels.GreenOffset] = MathUtils.random();
+				colorChannel.data[i+ParticleChannels.BlueOffset] = MathUtils.random();
+				colorChannel.data[i+ParticleChannels.AlphaOffset] = MathUtils.random();
+			}
+		}
+
+		@Override
+		public Random copy () {
+			return new Random();
+		}
+	}
+	
+	/** It's an {@link Influencer} which manages the particle color during its life time. */
+	public static class Single extends ColorInfluencer {
+		FloatChannel alphaInterpolationChannel;
+		FloatChannel lifeChannel;
+		public ScaledNumericValue alphaValue;
+		public GradientColorValue colorValue;
+		
+		public Single(){
+			colorValue = new GradientColorValue();
+			alphaValue = new ScaledNumericValue();
+			alphaValue.setHigh(1);
+		}
+
+		public Single (Single billboardColorInfluencer) {
+			this();
+			set(billboardColorInfluencer);
+		}
+
+		public void set(Single colorInfluencer){
+			this.colorValue.load(colorInfluencer.colorValue);
+			this.alphaValue.load(colorInfluencer.alphaValue);
+		}
+		
+		@Override
+		public void allocateChannels () {
+			super.allocateChannels();
+			//Hack this allows to share the channel descriptor structure but using a different id temporary
+			ParticleChannels.Interpolation.id = controller.particleChannels.newId();
+			alphaInterpolationChannel = controller.particles.addChannel(ParticleChannels.Interpolation);
+			lifeChannel = controller.particles.addChannel(ParticleChannels.Life);
+		}
+		
+		@Override
+		public void activateParticles (int startIndex, int count) {
+			for(int 	i=startIndex*colorChannel.strideSize, 
+							a = startIndex*alphaInterpolationChannel.strideSize,
+							l = startIndex*lifeChannel.strideSize + ParticleChannels.LifePercentOffset,
+							c = i +count*colorChannel.strideSize; 
+							i < c; 
+							i +=colorChannel.strideSize, 
+							a +=alphaInterpolationChannel.strideSize,
+							l +=lifeChannel.strideSize){
+				float alphaStart = alphaValue.newLowValue();
+				float alphaDiff = alphaValue.newHighValue() - alphaStart;
+				colorValue.getColor(0, colorChannel.data, i);
+				colorChannel.data[i+ParticleChannels.AlphaOffset] = alphaStart + alphaDiff*alphaValue.getScale(lifeChannel.data[l]);
+				alphaInterpolationChannel.data[a+ParticleChannels.InterpolationStartOffset] = alphaStart;
+				alphaInterpolationChannel.data[a+ParticleChannels.InterpolationDiffOffset] = alphaDiff;
+			}
+		}
+
+		@Override
+		public void update () {
+			for(int 	i=0, a = 0, l = ParticleChannels.LifePercentOffset,
+				c = i +controller.particles.size*colorChannel.strideSize; 
+				i < c; 
+				i +=colorChannel.strideSize, a +=alphaInterpolationChannel.strideSize, l +=lifeChannel.strideSize){
+				
+				float lifePercent = lifeChannel.data[l];
+				colorValue.getColor(lifePercent, colorChannel.data, i);
+				colorChannel.data[i+ParticleChannels.AlphaOffset] = alphaInterpolationChannel.data[a+ParticleChannels.InterpolationStartOffset] 
+					+ alphaInterpolationChannel.data[a+ParticleChannels.InterpolationDiffOffset] *alphaValue.getScale(lifePercent);
+			}
+		}
+		
+		@Override
+		public Single copy () {
+			return new  Single(this);
+		}
+		
+		@Override
+		public void write (Json json) {
+			json.writeValue("alpha", alphaValue);
+			json.writeValue("color", colorValue);
+		}
+		
+		@Override
+		public void read (Json json, JsonValue jsonData) {
+			alphaValue = json.readValue("alpha", ScaledNumericValue.class, jsonData);
+			colorValue = json.readValue("color", GradientColorValue.class, jsonData);
+		}
+	}
+	
+	FloatChannel colorChannel;
+	
+	@Override
+	public void allocateChannels() {
+		colorChannel = controller.particles.addChannel(ParticleChannels.Color);
+	}	
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/DynamicsInfluencer.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/DynamicsInfluencer.java
new file mode 100644
index 0000000..2d5ac0a
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/DynamicsInfluencer.java
@@ -0,0 +1,212 @@
+package com.badlogic.gdx.graphics.g3d.particles.influencers;
+
+import java.util.Arrays;
+
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.FloatChannel;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleController;
+import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.Json;
+import com.badlogic.gdx.utils.JsonValue;
+
+/** It's an {@link Influencer} which controls the particles dynamics (movement, rotations).
+ *  @author Inferno */
+public class DynamicsInfluencer extends Influencer {
+	public Array<DynamicsModifier> velocities;
+	private FloatChannel 	accellerationChannel, 
+												positionChannel, previousPositionChannel, 
+												rotationChannel, angularVelocityChannel;
+	boolean hasAcceleration, has2dAngularVelocity, has3dAngularVelocity;
+
+	public DynamicsInfluencer(){
+		this.velocities = new Array<DynamicsModifier>(true, 3, DynamicsModifier.class);
+	}
+
+	public DynamicsInfluencer(DynamicsModifier...velocities){
+		this.velocities = new Array<DynamicsModifier>(true, velocities.length, DynamicsModifier.class);
+		for(DynamicsModifier value : velocities){
+			this.velocities.add((DynamicsModifier)value.copy());
+		}
+	}
+	
+	public DynamicsInfluencer (DynamicsInfluencer velocityInfluencer) {
+		this((DynamicsModifier[])velocityInfluencer.velocities.toArray(DynamicsModifier.class));
+	}
+	
+	@Override
+	public void allocateChannels() {
+		for(int k=0; k < velocities.size; ++k){
+			velocities.items[k].allocateChannels();
+		}
+		
+		//Hack, shouldn't be done but after all the modifiers allocated their channels
+		//it's possible to check if we need to allocate previous position channel
+		accellerationChannel = controller.particles.getChannel(ParticleChannels.Acceleration);
+		hasAcceleration = accellerationChannel != null;
+		if(hasAcceleration){
+			positionChannel = controller.particles.addChannel(ParticleChannels.Position);
+			previousPositionChannel = controller.particles.addChannel(ParticleChannels.PreviousPosition);
+		}
+		
+		//Angular velocity check
+		angularVelocityChannel = controller.particles.getChannel(ParticleChannels.AngularVelocity2D);
+		has2dAngularVelocity = angularVelocityChannel != null;
+		if(has2dAngularVelocity){
+			rotationChannel = controller.particles.addChannel(ParticleChannels.Rotation2D);
+			has3dAngularVelocity = false;
+		}
+		else{
+			angularVelocityChannel = controller.particles.getChannel(ParticleChannels.AngularVelocity3D);
+			has3dAngularVelocity = angularVelocityChannel != null;
+			if(has3dAngularVelocity)
+				rotationChannel = controller.particles.addChannel(ParticleChannels.Rotation3D);
+		}
+	}
+	
+	@Override
+	public void set(ParticleController particleController) {
+		super.set(particleController);
+		for(int k=0; k < velocities.size; ++k){
+			velocities.items[k].set(particleController);
+		}
+	}
+	
+	@Override
+	public void init () {
+		for(int k=0; k < velocities.size; ++k){
+			velocities.items[k].init();
+		}
+	}
+
+	public void activateParticles (int startIndex, int count) {
+		if(hasAcceleration){
+			//Previous position is the current position
+			//Attention, this requires that some other influencer setting the position channel must execute before this influencer.
+			for(int i=startIndex*positionChannel.strideSize, c = i +count*positionChannel.strideSize; i< c;  i+= positionChannel.strideSize){
+				previousPositionChannel.data[i+ParticleChannels.XOffset] = positionChannel.data[i+ParticleChannels.XOffset];
+				previousPositionChannel.data[i+ParticleChannels.YOffset] = positionChannel.data[i+ParticleChannels.YOffset];
+				previousPositionChannel.data[i+ParticleChannels.ZOffset] = positionChannel.data[i+ParticleChannels.ZOffset];
+				/*
+				//Euler intialization
+				previousPositionChannel.data[i+ParticleChannels.XOffset] = 
+				previousPositionChannel.data[i+ParticleChannels.YOffset] = 
+				previousPositionChannel.data[i+ParticleChannels.ZOffset] = 0;
+				*/
+			}	
+		}
+		
+		if(has2dAngularVelocity){
+			//Rotation back to 0
+			for(int i=startIndex*rotationChannel.strideSize, c = i +count*rotationChannel.strideSize; i< c;  i+= rotationChannel.strideSize){
+				rotationChannel.data[i+ParticleChannels.CosineOffset] = 1;
+				rotationChannel.data[i+ParticleChannels.SineOffset] = 0;
+			}	
+		}
+		else if(has3dAngularVelocity){
+			//Rotation back to 0
+			for(int i=startIndex*rotationChannel.strideSize, c = i +count*rotationChannel.strideSize; i< c;  i+= rotationChannel.strideSize){
+				rotationChannel.data[i+ParticleChannels.XOffset] = 0;
+				rotationChannel.data[i+ParticleChannels.YOffset] = 0;
+				rotationChannel.data[i+ParticleChannels.ZOffset] = 0;
+				rotationChannel.data[i+ParticleChannels.WOffset] = 1;
+			}	
+		}
+		
+		for(int k=0; k < velocities.size; ++k){
+			velocities.items[k].activateParticles(startIndex, count);
+		}
+	}
+	
+	public void update(){
+		//Clean previouse frame velocities
+		if(hasAcceleration)
+			Arrays.fill(accellerationChannel.data, 0, controller.particles.size*accellerationChannel.strideSize, 0);
+		if(has2dAngularVelocity || has3dAngularVelocity) 
+			Arrays.fill(angularVelocityChannel.data, 0, controller.particles.size*angularVelocityChannel.strideSize, 0);
+
+		//Sum all the forces/accelerations
+		for(int k=0; k < velocities.size; ++k){
+			velocities.items[k].update();
+		}
+		
+		//Apply the forces
+		if(hasAcceleration){
+			/*
+			 //Euler Integration
+			for(int 	i=0, offset = 0; i < controller.particles.size; ++i, offset +=positionChannel.strideSize){
+				previousPositionChannel.data[offset + ParticleChannels.XOffset] += accellerationChannel.data[offset + ParticleChannels.XOffset]*controller.deltaTime;
+				previousPositionChannel.data[offset + ParticleChannels.YOffset] += accellerationChannel.data[offset + ParticleChannels.YOffset]*controller.deltaTime;
+				previousPositionChannel.data[offset + ParticleChannels.ZOffset] += accellerationChannel.data[offset + ParticleChannels.ZOffset]*controller.deltaTime;
+				
+				positionChannel.data[offset + ParticleChannels.XOffset] += previousPositionChannel.data[offset + ParticleChannels.XOffset]*controller.deltaTime;
+				positionChannel.data[offset + ParticleChannels.YOffset] += previousPositionChannel.data[offset + ParticleChannels.YOffset]*controller.deltaTime;
+				positionChannel.data[offset + ParticleChannels.ZOffset] += previousPositionChannel.data[offset + ParticleChannels.ZOffset]*controller.deltaTime;
+			}
+			*/
+			//Verlet integration
+			for(int 	i=0, offset = 0; i < controller.particles.size; ++i, offset +=positionChannel.strideSize){
+				float 	x = positionChannel.data[offset + ParticleChannels.XOffset],
+							y = positionChannel.data[offset + ParticleChannels.YOffset],
+							z = positionChannel.data[offset + ParticleChannels.ZOffset];
+				positionChannel.data[offset + ParticleChannels.XOffset] = 2*x - previousPositionChannel.data[offset + ParticleChannels.XOffset] + 
+									accellerationChannel.data[offset + ParticleChannels.XOffset]*controller.deltaTimeSqr;
+				positionChannel.data[offset + ParticleChannels.YOffset] = 2*y- previousPositionChannel.data[offset + ParticleChannels.YOffset] + 
+									accellerationChannel.data[offset + ParticleChannels.YOffset]*controller.deltaTimeSqr;
+				positionChannel.data[offset + ParticleChannels.ZOffset] = 2*z - previousPositionChannel.data[offset + ParticleChannels.ZOffset] + 
+									accellerationChannel.data[offset + ParticleChannels.ZOffset]*controller.deltaTimeSqr;
+				previousPositionChannel.data[offset + ParticleChannels.XOffset] = x;
+				previousPositionChannel.data[offset + ParticleChannels.YOffset] = y;
+				previousPositionChannel.data[offset + ParticleChannels.ZOffset] = z;
+			}
+		}
+
+		if(has2dAngularVelocity){
+			for(int 	i=0, offset = 0; i < controller.particles.size; ++i, offset +=rotationChannel.strideSize){
+				float rotation = angularVelocityChannel.data[i]*controller.deltaTime;
+				if(rotation != 0){
+					float cosBeta = MathUtils.cosDeg(rotation), sinBeta = MathUtils.sinDeg(rotation);
+					float currentCosine = rotationChannel.data[offset + ParticleChannels.CosineOffset];
+					float currentSine = rotationChannel.data[offset + ParticleChannels.SineOffset];
+					float 	newCosine = currentCosine*cosBeta - currentSine*sinBeta,
+						newSine = currentSine*cosBeta + currentCosine*sinBeta;
+					rotationChannel.data[offset + ParticleChannels.CosineOffset] = newCosine;
+					rotationChannel.data[offset + ParticleChannels.SineOffset] = newSine;
+				}
+			}
+		}		
+		else if(has3dAngularVelocity){
+			for(int 	i=0, offset = 0, angularOffset = 0; i < controller.particles.size; ++i, 
+					offset +=rotationChannel.strideSize, angularOffset += angularVelocityChannel.strideSize){
+				
+				float	wx = angularVelocityChannel.data[angularOffset + ParticleChannels.XOffset],
+							wy = angularVelocityChannel.data[angularOffset + ParticleChannels.YOffset],
+							wz = angularVelocityChannel.data[angularOffset + ParticleChannels.ZOffset],
+							qx = rotationChannel.data[offset + ParticleChannels.XOffset],
+							qy = rotationChannel.data[offset + ParticleChannels.YOffset],
+							qz = rotationChannel.data[offset + ParticleChannels.ZOffset],
+							qw = rotationChannel.data[offset + ParticleChannels.WOffset];
+				TMP_Q.set(wx, wy, wz, 0).mul(qx, qy, qz, qw).mul(0.5f*controller.deltaTime).add(qx, qy, qz, qw).nor();
+				rotationChannel.data[offset + ParticleChannels.XOffset] = TMP_Q.x;
+				rotationChannel.data[offset + ParticleChannels.YOffset] = TMP_Q.y;
+				rotationChannel.data[offset + ParticleChannels.ZOffset] = TMP_Q.z;
+				rotationChannel.data[offset + ParticleChannels.WOffset] = TMP_Q.w;
+			}	
+		}
+	}
+
+	@Override
+	public DynamicsInfluencer copy () {
+		return new DynamicsInfluencer(this);
+	}
+	
+	@Override
+	public void write (Json json) {
+		json.writeValue("velocities", velocities, Array.class, DynamicsModifier.class);
+	}
+	
+	@Override
+	public void read (Json json, JsonValue jsonData) {
+		velocities.addAll(json.readValue("velocities", Array.class, DynamicsModifier.class, jsonData));
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/DynamicsModifier.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/DynamicsModifier.java
new file mode 100644
index 0000000..241317f
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/DynamicsModifier.java
@@ -0,0 +1,503 @@
+package com.badlogic.gdx.graphics.g3d.particles.influencers;
+
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.FloatChannel;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleControllerComponent;
+import com.badlogic.gdx.graphics.g3d.particles.values.ScaledNumericValue;
+import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.math.Matrix4;
+import com.badlogic.gdx.math.Quaternion;
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.utils.Json;
+import com.badlogic.gdx.utils.JsonValue;
+
+/** It's the base class for any kind of influencer which operates on angular velocity and acceleration of the particles.
+ * All the classes that will inherit this base class can and should be used 
+ * only as sub-influencer of an instance of {@link DynamicsInfluencer} .
+ *  @author Inferno */
+public abstract class DynamicsModifier extends Influencer{
+	protected static final Vector3 	TMP_V1 = new Vector3(), 
+		 										TMP_V2 = new Vector3(), 
+		 										TMP_V3 = new Vector3();
+	protected static final Quaternion TMP_Q = new Quaternion();
+	
+	public static class FaceDirection extends DynamicsModifier {
+		FloatChannel rotationChannel, accellerationChannel;
+		
+		public FaceDirection(){}
+		
+		public FaceDirection (FaceDirection rotation) {
+			super(rotation);
+		}
+		@Override
+		public void allocateChannels() {
+			rotationChannel = controller.particles.addChannel(ParticleChannels.Rotation3D);
+			accellerationChannel = controller.particles.addChannel(ParticleChannels.Acceleration);
+		}
+		
+		@Override
+		public void update () {
+			for(int 	i=0, accelOffset = 0, c = i +controller.particles.size *rotationChannel.strideSize; 
+				i < c; 
+				i +=rotationChannel.strideSize, accelOffset += accellerationChannel.strideSize){
+				
+				Vector3 	axisZ = TMP_V1.set(	accellerationChannel.data[accelOffset +ParticleChannels.XOffset], 
+																				accellerationChannel.data[accelOffset +ParticleChannels.YOffset], 
+																				accellerationChannel.data[accelOffset +ParticleChannels.ZOffset]).nor(),
+					axisY = TMP_V2.set(TMP_V1).crs(Vector3.Y).nor().crs(TMP_V1).nor(),
+					axisX = TMP_V3.set(axisY).crs(axisZ).nor();
+				TMP_Q.setFromAxes(false, 	axisX.x,  axisY.x, axisZ.x,
+															axisX.y,  axisY.y, axisZ.y,
+															axisX.z,  axisY.z, axisZ.z);
+				rotationChannel.data[i +ParticleChannels.XOffset] = TMP_Q.x;
+				rotationChannel.data[i +ParticleChannels.YOffset] = TMP_Q.y;
+				rotationChannel.data[i +ParticleChannels.ZOffset] = TMP_Q.z;
+				rotationChannel.data[i +ParticleChannels.WOffset] = TMP_Q.w;	
+			}
+		}
+
+		@Override
+		public ParticleControllerComponent copy () {
+			return new FaceDirection(this);
+		}
+	}
+	
+	public static abstract class Strength extends DynamicsModifier {
+		protected FloatChannel strengthChannel;
+		public ScaledNumericValue strengthValue;
+		
+		public Strength(){
+			strengthValue = new ScaledNumericValue();
+		}
+		
+		public Strength (Strength rotation) {
+			super(rotation);
+			strengthValue = new ScaledNumericValue();
+			strengthValue.load(rotation.strengthValue);
+		}
+		
+		@Override
+		public void allocateChannels() {
+			super.allocateChannels();
+			ParticleChannels.Interpolation.id = controller.particleChannels.newId();
+			strengthChannel = controller.particles.addChannel(ParticleChannels.Interpolation);			
+		}
+		
+		@Override
+		public void activateParticles (int startIndex, int count) {
+			float start, diff;
+			for(int 	i=startIndex*strengthChannel.strideSize, c = i +count*strengthChannel.strideSize; 
+				i < c; 
+				i +=strengthChannel.strideSize){
+				start = strengthValue.newLowValue(); 
+				diff = strengthValue.newHighValue();
+				if(!strengthValue.isRelative())
+					diff -= start;
+				strengthChannel.data[i + ParticleChannels.VelocityStrengthStartOffset] = start;
+				strengthChannel.data[i + ParticleChannels.VelocityStrengthDiffOffset] = diff;
+			}
+		}
+
+		@Override
+		public void write (Json json) {
+			super.write(json);
+			json.writeValue("strengthValue", strengthValue);
+		}
+
+		@Override
+		public void read (Json json, JsonValue jsonData) {
+			super.read(json, jsonData);
+			strengthValue = json.readValue("strengthValue", ScaledNumericValue.class, jsonData);
+		}
+	}
+	
+	public static abstract class Angular extends Strength {
+		protected FloatChannel angularChannel;
+		/** Polar angle, XZ plane */
+		public ScaledNumericValue thetaValue;
+		/** Azimuth, Y */
+		public ScaledNumericValue phiValue;
+
+		public Angular(){
+			thetaValue = new ScaledNumericValue();
+			phiValue = new ScaledNumericValue();
+		}
+		
+		public Angular (Angular value) {
+			super(value);
+			thetaValue = new ScaledNumericValue();
+			phiValue = new ScaledNumericValue();
+			thetaValue.load(value.thetaValue);
+			phiValue.load(value.phiValue);
+		}
+		
+		@Override
+		public void allocateChannels() {
+			super.allocateChannels();
+			ParticleChannels.Interpolation4.id = controller.particleChannels.newId();
+			angularChannel = controller.particles.addChannel(ParticleChannels.Interpolation4);			
+		}
+		
+		@Override
+		public void activateParticles (int startIndex, int count) {
+			super.activateParticles(startIndex, count);
+			float start, diff;
+			for(int 	i=startIndex*angularChannel.strideSize, c = i +count*angularChannel.strideSize; 
+				i < c; 
+				i +=angularChannel.strideSize){
+				
+				//Theta
+				start = thetaValue.newLowValue();
+				diff = thetaValue.newHighValue();
+				if(!thetaValue.isRelative())
+					diff -= start;
+				angularChannel.data[i + ParticleChannels.VelocityThetaStartOffset] = start;
+				angularChannel.data[i + ParticleChannels.VelocityThetaDiffOffset] = diff;
+
+				//Phi
+				start = phiValue.newLowValue();
+				diff = phiValue.newHighValue();
+				if(!phiValue.isRelative())
+					diff -= start;
+				angularChannel.data[i + ParticleChannels.VelocityPhiStartOffset] = start;
+				angularChannel.data[i + ParticleChannels.VelocityPhiDiffOffset] = diff;
+			}
+		}
+		
+		@Override
+		public void write (Json json) {
+			super.write(json);
+			json.writeValue("thetaValue", thetaValue);
+			json.writeValue("phiValue", phiValue);
+		}
+
+		@Override
+		public void read (Json json, JsonValue jsonData) {
+			super.read(json, jsonData);
+			thetaValue = json.readValue("thetaValue", ScaledNumericValue.class, jsonData);
+			phiValue = json.readValue("phiValue", ScaledNumericValue.class, jsonData);
+		}
+	}
+	
+	
+	public static class Rotational2D extends Strength {
+		FloatChannel rotationalVelocity2dChannel;
+		
+		public Rotational2D (){}
+		
+		public Rotational2D (Rotational2D rotation) {
+			super(rotation);
+		}
+
+		@Override
+		public void allocateChannels() {
+			super.allocateChannels();
+			rotationalVelocity2dChannel = controller.particles.addChannel(ParticleChannels.AngularVelocity2D);
+		}
+		
+		@Override
+		public void update () {
+			for(int 	i=0, l = ParticleChannels.LifePercentOffset, s =0,
+				c = i +controller.particles.size*rotationalVelocity2dChannel.strideSize; 
+				i < c; 
+				s += strengthChannel.strideSize, i +=rotationalVelocity2dChannel.strideSize,  l +=lifeChannel.strideSize){
+				rotationalVelocity2dChannel.data[i] += 	strengthChannel.data[s + ParticleChannels.VelocityStrengthStartOffset] + 
+																									strengthChannel.data[s + ParticleChannels.VelocityStrengthDiffOffset]* strengthValue.getScale(lifeChannel.data[l]);
+			}
+		}
+
+		@Override
+		public Rotational2D copy () {
+			return new Rotational2D(this);
+		}
+	}
+	
+	public static class Rotational3D extends Angular {
+		FloatChannel rotationChannel, rotationalForceChannel;
+		
+		public Rotational3D(){}
+		
+		public Rotational3D (Rotational3D rotation) {
+			super(rotation);
+		}
+
+		@Override
+		public void allocateChannels() {
+			super.allocateChannels();
+			rotationChannel = controller.particles.addChannel(ParticleChannels.Rotation3D);
+			rotationalForceChannel = controller.particles.addChannel(ParticleChannels.AngularVelocity3D);
+		}
+		
+		@Override
+		public void update () {
+			
+			//Matrix3 I_t = defined by the shape, it's the inertia tensor
+			//Vector3 r = position vector
+			//Vector3 L = r.cross(v.mul(m)), It's the angular momentum, where mv it's the linear momentum
+			//Inverse(I_t) = a diagonal matrix where the diagonal is IyIz, IxIz, IxIy
+			//Vector3 w = L/I_t = inverse(I_t)*L, It's the angular velocity
+			//Quaternion spin = 0.5f*Quaternion(w, 0)*currentRotation
+			//currentRotation += spin*dt
+			//normalize(currentRotation)
+		
+			//Algorithm 1
+			//Consider a simple channel which represent an angular velocity w
+			//Sum each w for each rotation 
+			//Update rotation
+			
+			//Algorithm 2
+			//Consider a channel which represent a sort of angular momentum L  (r, v)
+			//Sum each L for each rotation 
+			//Multiply sum by constant quantity k = m*I_to(-1) , m could be optional while I is constant and can be calculated at start 
+			//Update rotation			
+			
+			//Algorithm 3
+			//Consider a channel which represent a simple angular momentum L
+			//Proceed as Algorithm 2
+			
+			for(int 	i=0, l = ParticleChannels.LifePercentOffset, s =0, a = 0,
+				c = controller.particles.size*rotationalForceChannel.strideSize; 
+				i < c; 
+				s += strengthChannel.strideSize, i +=rotationalForceChannel.strideSize, 
+				a += angularChannel.strideSize, l += lifeChannel.strideSize){
+				
+				float 	lifePercent = lifeChannel.data[l],
+							strength = 	strengthChannel.data[s + ParticleChannels.VelocityStrengthStartOffset] + 
+													strengthChannel.data[s + ParticleChannels.VelocityStrengthDiffOffset]* strengthValue.getScale(lifePercent),
+							phi = 	angularChannel.data[a + ParticleChannels.VelocityPhiStartOffset] + 
+											angularChannel.data[a + ParticleChannels.VelocityPhiDiffOffset]* phiValue.getScale(lifePercent),
+							theta = 	angularChannel.data[a + ParticleChannels.VelocityThetaStartOffset] + 
+												angularChannel.data[a + ParticleChannels.VelocityThetaDiffOffset]* thetaValue.getScale(lifePercent);
+				
+				float 	cosTheta = MathUtils.cosDeg(theta), sinTheta = MathUtils.sinDeg(theta),
+							cosPhi = MathUtils.cosDeg(phi), sinPhi = MathUtils.sinDeg(phi);
+				
+				TMP_V3.set(cosTheta *sinPhi, cosPhi, sinTheta*sinPhi);
+				TMP_V3.scl(strength*MathUtils.degreesToRadians);
+				
+				rotationalForceChannel.data[i +ParticleChannels.XOffset] += TMP_V3.x;
+				rotationalForceChannel.data[i +ParticleChannels.YOffset] += TMP_V3.y;
+				rotationalForceChannel.data[i +ParticleChannels.ZOffset] += TMP_V3.z;				
+			}
+		}
+
+		@Override
+		public Rotational3D copy () {
+			return new Rotational3D(this);
+		}
+	}
+	
+	
+	public static class CentripetalAcceleration extends Strength {
+		FloatChannel accelerationChannel;
+		FloatChannel positionChannel;
+		public CentripetalAcceleration(){}
+		
+		public CentripetalAcceleration (CentripetalAcceleration rotation) {
+			super(rotation);
+		}
+
+		@Override
+		public void allocateChannels() {
+			super.allocateChannels();
+			accelerationChannel = controller.particles.addChannel(ParticleChannels.Acceleration);
+			positionChannel = controller.particles.addChannel(ParticleChannels.Position);
+		}
+		
+		@Override
+		public void update () {
+			float cx = 0, cy = 0, cz = 0;
+			if(!isGlobal){
+				float[] val = controller.transform.val;
+				cx = val[Matrix4.M03]; 
+				cy = val[Matrix4.M13]; 
+				cz = val[Matrix4.M23];
+			}
+			
+			int lifeOffset=ParticleChannels.LifePercentOffset, strengthOffset = 0, positionOffset = 0, forceOffset = 0;
+			for(int 	i=0,  c= controller.particles.size; i < c; ++i,  
+				positionOffset += positionChannel.strideSize,
+				strengthOffset += strengthChannel.strideSize, 
+				forceOffset +=accelerationChannel.strideSize, 
+				lifeOffset += lifeChannel.strideSize){
+			
+				float 	strength = 	strengthChannel.data[strengthOffset + ParticleChannels.VelocityStrengthStartOffset] + 
+													strengthChannel.data[strengthOffset + ParticleChannels.VelocityStrengthDiffOffset]* strengthValue.getScale(lifeChannel.data[lifeOffset]);
+				TMP_V3.set(	positionChannel.data[positionOffset +ParticleChannels.XOffset] -cx, 
+											positionChannel.data[positionOffset +ParticleChannels.YOffset] -cy, 
+											positionChannel.data[positionOffset +ParticleChannels.ZOffset] -cz)
+								.nor().scl(strength);
+				accelerationChannel.data[forceOffset +ParticleChannels.XOffset] += TMP_V3.x;
+				accelerationChannel.data[forceOffset +ParticleChannels.YOffset] += TMP_V3.y;
+				accelerationChannel.data[forceOffset +ParticleChannels.ZOffset] += TMP_V3.z;
+			}
+		}
+
+		@Override
+		public CentripetalAcceleration copy () {
+			return new CentripetalAcceleration(this);
+		}
+	}
+	
+	public static class PolarAcceleration extends Angular {
+		FloatChannel directionalVelocityChannel;
+		public PolarAcceleration(){}
+		
+		public PolarAcceleration (PolarAcceleration rotation) {
+			super(rotation);
+		}
+
+		@Override
+		public void allocateChannels() {
+			super.allocateChannels();
+			directionalVelocityChannel = controller.particles.addChannel(ParticleChannels.Acceleration);
+		}
+		
+		@Override
+		public void update () {
+			for(int 	i=0, l = ParticleChannels.LifePercentOffset, s =0, a = 0,
+				c = i +controller.particles.size*directionalVelocityChannel.strideSize; 
+				i < c; 
+				s += strengthChannel.strideSize, i +=directionalVelocityChannel.strideSize, 
+				a += angularChannel.strideSize, l += lifeChannel.strideSize){
+				
+				float 	lifePercent = lifeChannel.data[l],
+							strength = 	strengthChannel.data[s + ParticleChannels.VelocityStrengthStartOffset] + 
+													strengthChannel.data[s + ParticleChannels.VelocityStrengthDiffOffset]* strengthValue.getScale(lifePercent),
+							phi = 	angularChannel.data[a + ParticleChannels.VelocityPhiStartOffset] + 
+											angularChannel.data[a + ParticleChannels.VelocityPhiDiffOffset]* phiValue.getScale(lifePercent),
+							theta = 	angularChannel.data[a + ParticleChannels.VelocityThetaStartOffset] + 
+												angularChannel.data[a + ParticleChannels.VelocityThetaDiffOffset]* thetaValue.getScale(lifePercent);
+				
+				float cosTheta = MathUtils.cosDeg(theta), sinTheta = MathUtils.sinDeg(theta),
+					cosPhi = MathUtils.cosDeg(phi), sinPhi = MathUtils.sinDeg(phi);
+				TMP_V3.set(cosTheta *sinPhi, cosPhi, sinTheta*sinPhi).nor().scl(strength);	
+				directionalVelocityChannel.data[i +ParticleChannels.XOffset] += TMP_V3.x;
+				directionalVelocityChannel.data[i +ParticleChannels.YOffset] += TMP_V3.y;
+				directionalVelocityChannel.data[i +ParticleChannels.ZOffset] += TMP_V3.z;
+			}
+		}
+
+		@Override
+		public PolarAcceleration copy () {
+			return new PolarAcceleration(this);
+		}
+	}
+	
+	public static class TangentialAcceleration extends Angular {
+		FloatChannel directionalVelocityChannel, positionChannel;
+		
+		public TangentialAcceleration(){}
+		
+		public TangentialAcceleration (TangentialAcceleration rotation) {
+			super(rotation);
+		}
+
+		@Override
+		public void allocateChannels() {
+			super.allocateChannels();
+			directionalVelocityChannel = controller.particles.addChannel(ParticleChannels.Acceleration);
+			positionChannel = controller.particles.addChannel(ParticleChannels.Position);
+		}
+		
+		@Override
+		public void update () {
+			for(int 	i=0, l = ParticleChannels.LifePercentOffset, s =0, a = 0, positionOffset = 0,
+				c = i +controller.particles.size*directionalVelocityChannel.strideSize; 
+				i < c; 
+				s += strengthChannel.strideSize, i +=directionalVelocityChannel.strideSize, 
+				a += angularChannel.strideSize, l += lifeChannel.strideSize, positionOffset += positionChannel.strideSize ){
+				
+				float 	lifePercent = lifeChannel.data[l],
+							strength = 	strengthChannel.data[s + ParticleChannels.VelocityStrengthStartOffset] + 
+													strengthChannel.data[s + ParticleChannels.VelocityStrengthDiffOffset]* strengthValue.getScale(lifePercent),
+							phi = 	angularChannel.data[a + ParticleChannels.VelocityPhiStartOffset] + 
+											angularChannel.data[a + ParticleChannels.VelocityPhiDiffOffset]* phiValue.getScale(lifePercent),
+							theta = 	angularChannel.data[a + ParticleChannels.VelocityThetaStartOffset] + 
+												angularChannel.data[a + ParticleChannels.VelocityThetaDiffOffset]* thetaValue.getScale(lifePercent);
+				
+				float cosTheta = MathUtils.cosDeg(theta), sinTheta = MathUtils.sinDeg(theta),
+					cosPhi = MathUtils.cosDeg(phi), sinPhi = MathUtils.sinDeg(phi);
+				TMP_V3.set(cosTheta *sinPhi, cosPhi, sinTheta*sinPhi)
+								.crs(	positionChannel.data[positionOffset +ParticleChannels.XOffset], 
+											positionChannel.data[positionOffset +ParticleChannels.YOffset], 
+											positionChannel.data[positionOffset +ParticleChannels.ZOffset])
+								.nor().scl(strength);	
+				directionalVelocityChannel.data[i +ParticleChannels.XOffset] += TMP_V3.x;
+				directionalVelocityChannel.data[i +ParticleChannels.YOffset] += TMP_V3.y;
+				directionalVelocityChannel.data[i +ParticleChannels.ZOffset] += TMP_V3.z;
+			}
+		}
+
+		@Override
+		public TangentialAcceleration copy () {
+			return new TangentialAcceleration(this);
+		}
+	}
+
+	public static class BrownianAcceleration extends Strength {
+		FloatChannel accelerationChannel;
+		public BrownianAcceleration(){}
+		
+		public BrownianAcceleration (BrownianAcceleration rotation) {
+			super(rotation);
+		}
+
+		@Override
+		public void allocateChannels() {
+			super.allocateChannels();
+			accelerationChannel = controller.particles.addChannel(ParticleChannels.Acceleration);
+		}
+		
+		@Override
+		public void update () {
+			int lifeOffset=ParticleChannels.LifePercentOffset, strengthOffset = 0, forceOffset = 0;
+			for(int 	i=0,  c= controller.particles.size; i < c; ++i,  
+				strengthOffset += strengthChannel.strideSize, 
+				forceOffset +=accelerationChannel.strideSize, 
+				lifeOffset += lifeChannel.strideSize){
+			
+				float 	strength = 	strengthChannel.data[strengthOffset + ParticleChannels.VelocityStrengthStartOffset] + 
+													strengthChannel.data[strengthOffset + ParticleChannels.VelocityStrengthDiffOffset]* strengthValue.getScale(lifeChannel.data[lifeOffset]);
+				TMP_V3.set(MathUtils.random(-1, 1f), MathUtils.random(-1, 1f), MathUtils.random(-1, 1f)).nor().scl(strength);
+				accelerationChannel.data[forceOffset +ParticleChannels.XOffset] += TMP_V3.x;
+				accelerationChannel.data[forceOffset +ParticleChannels.YOffset] += TMP_V3.y;
+				accelerationChannel.data[forceOffset +ParticleChannels.ZOffset] += TMP_V3.z;
+			}
+		}
+
+		@Override
+		public BrownianAcceleration copy () {
+			return new BrownianAcceleration(this);
+		}
+	}
+
+	
+	public boolean isGlobal = false;
+	protected FloatChannel lifeChannel;
+	
+	public DynamicsModifier(){}
+	
+	public DynamicsModifier (DynamicsModifier modifier) {
+		this.isGlobal = modifier.isGlobal;
+	}
+
+	@Override
+	public void allocateChannels() {
+		lifeChannel = controller.particles.addChannel(ParticleChannels.Life);
+	}
+	
+	@Override
+	public void write (Json json) {
+		super.write(json);
+		json.writeValue("isGlobal", isGlobal);
+	}
+
+	@Override
+	public void read (Json json, JsonValue jsonData) {
+		super.read(json, jsonData);
+		isGlobal = json.readValue("isGlobal", boolean.class, jsonData);
+	}
+	
+}
+
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/Influencer.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/Influencer.java
new file mode 100644
index 0000000..696cba4
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/Influencer.java
@@ -0,0 +1,10 @@
+package com.badlogic.gdx.graphics.g3d.particles.influencers;
+
+import com.badlogic.gdx.graphics.g3d.particles.ParticleControllerComponent;
+
+/** It's a {@link ParticleControllerComponent} which usually modifies one or more properties
+ * of the particles(i.e color, scale, graphical representation, velocity, etc...).
+ * @author Inferno */
+public abstract class Influencer extends ParticleControllerComponent {
+	
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/ModelInfluencer.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/ModelInfluencer.java
new file mode 100644
index 0000000..9892b69
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/ModelInfluencer.java
@@ -0,0 +1,138 @@
+package com.badlogic.gdx.graphics.g3d.particles.influencers;
+
+import com.badlogic.gdx.assets.AssetDescriptor;
+import com.badlogic.gdx.assets.AssetManager;
+import com.badlogic.gdx.graphics.g3d.Model;
+import com.badlogic.gdx.graphics.g3d.ModelInstance;
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.ObjectChannel;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels;
+import com.badlogic.gdx.graphics.g3d.particles.ResourceData;
+import com.badlogic.gdx.graphics.g3d.particles.ResourceData.SaveData;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.Pool;
+
+/** It's an {@link Influencer} which controls which {@link Model} will be assigned
+ * to the particles as {@link ModelInstance}. 
+ * @author Inferno */
+public abstract class ModelInfluencer extends Influencer{
+
+	/** Assigns the first model of {@link ModelInfluencer#models} to the particles.*/
+	public static class Single extends ModelInfluencer{
+
+		public Single(){
+			super();
+		}
+		
+		public Single(Single influencer){
+			super(influencer);
+		}
+		
+		public Single (Model...models) {
+			super(models);
+		}
+
+		@Override
+		public void init () {
+			Model first = models.first();
+			for(int i=0, c = controller.emitter.maxParticleCount; i < c; ++i){
+				modelChannel.data[i] = new ModelInstance(first);
+			}
+		}
+		
+		@Override
+		public Single copy () {
+			return new Single(this);
+		}
+	}
+	
+	/** Assigns a random model of {@link ModelInfluencer#models} to the particles.*/
+	public static class Random extends ModelInfluencer{
+		private class ModelInstancePool extends Pool<ModelInstance>{
+			public ModelInstancePool () {}
+
+			@Override
+			public ModelInstance newObject () {
+				return new ModelInstance(models.random());
+			}
+		}
+		
+		ModelInstancePool pool;
+		public Random(){
+			super();
+			pool = new ModelInstancePool();
+		}
+		
+		public Random(Random influencer){
+			super(influencer);
+			pool = new ModelInstancePool();
+		}
+		
+		public Random (Model...models) {
+			super(models);
+			pool = new ModelInstancePool();
+		}
+		
+		@Override
+		public void init () {
+			pool.clear();
+		}
+		
+		@Override
+		public void activateParticles (int startIndex, int count) {
+			for(int i=startIndex, c = startIndex +count; i < c; ++i){
+				modelChannel.data[i] = pool.obtain();
+			}
+		}
+		@Override
+		public void killParticles (int startIndex, int count) {
+			for(int i=startIndex, c = startIndex +count; i < c; ++i){
+				pool.free(modelChannel.data[i]);
+				modelChannel.data[i]= null;
+			}
+		}
+		
+		@Override
+		public Random copy () {
+			return new Random(this);
+		}
+	}
+
+	public Array<Model> models;
+	ObjectChannel<ModelInstance> modelChannel;
+	
+	public ModelInfluencer(){
+		this.models = new Array<Model>(true, 1, Model.class);
+	}
+	
+	public ModelInfluencer(Model...models){
+		this.models = new Array<Model>(models);
+	}
+	
+	public ModelInfluencer (ModelInfluencer influencer) {
+		this((Model[])influencer.models.toArray(Model.class));
+	}
+	
+	@Override
+	public void allocateChannels() {
+		modelChannel = controller.particles.addChannel(ParticleChannels.ModelInstance);
+	}
+
+	@Override
+	public void save (AssetManager manager, ResourceData resources) {
+		SaveData data = resources.createSaveData();
+		for(Model model : models)
+			data.saveAsset(manager.getAssetFileName(model), Model.class);
+	}
+	
+	@Override
+	public void load (AssetManager manager, ResourceData resources) {
+		SaveData data = resources.getSaveData();
+		AssetDescriptor descriptor;
+		while((descriptor = data.loadAsset()) != null){
+			Model model = (Model)manager.get(descriptor);
+			if(model == null)
+				throw new RuntimeException("Model is null");
+			models.add(model);
+		}
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/ParticleControllerFinalizerInfluencer.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/ParticleControllerFinalizerInfluencer.java
new file mode 100644
index 0000000..9a7d7f8
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/ParticleControllerFinalizerInfluencer.java
@@ -0,0 +1,62 @@
+package com.badlogic.gdx.graphics.g3d.particles.influencers;
+
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.FloatChannel;
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.ObjectChannel;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleController;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+/** It's an {@link Influencer} which updates the simulation of particles containing a {@link ParticleController}.
+ * Must be the last influencer to be updated, so it has to be placed at the end 
+ * of the influencers list when creating a {@link ParticleController}.
+ * @author Inferno */
+public class ParticleControllerFinalizerInfluencer extends Influencer {
+	FloatChannel positionChannel, scaleChannel, rotationChannel;
+	ObjectChannel<ParticleController> controllerChannel;
+	boolean hasScale, hasRotation;
+	
+	public ParticleControllerFinalizerInfluencer()	{}
+	
+	@Override
+	public void init () {
+		controllerChannel = controller.particles.getChannel(ParticleChannels.ParticleController);
+		if(controllerChannel == null)
+			throw new GdxRuntimeException("ParticleController channel not found, specify an influencer which will allocate it please.");
+		scaleChannel = controller.particles.getChannel(ParticleChannels.Scale);
+		rotationChannel = controller.particles.getChannel(ParticleChannels.Rotation3D);
+		hasScale = scaleChannel != null;
+		hasRotation = rotationChannel != null;
+	}
+
+	@Override
+	public void allocateChannels () {
+		positionChannel = controller.particles.addChannel(ParticleChannels.Position);
+	}
+
+	@Override
+	public void update () {
+		for(int i=0, positionOffset = 0, c = controller.particles.size;
+			i< c; 
+			++i, positionOffset += positionChannel.strideSize){
+			ParticleController particleController = controllerChannel.data[i];
+			float scale = hasScale ? scaleChannel.data[i] : 1;
+			float qx=0, qy=0, qz=0, qw=1;
+			if(hasRotation){
+				int rotationOffset = i* rotationChannel.strideSize;
+				qx = rotationChannel.data[rotationOffset + ParticleChannels.XOffset];
+				qy = rotationChannel.data[rotationOffset + ParticleChannels.YOffset]; 
+				qz = rotationChannel.data[rotationOffset + ParticleChannels.ZOffset];
+				qw = rotationChannel.data[rotationOffset + ParticleChannels.WOffset];
+			}
+			particleController.setTransform(	positionChannel.data[positionOffset + ParticleChannels.XOffset],
+				positionChannel.data[positionOffset + ParticleChannels.YOffset],
+				positionChannel.data[positionOffset + ParticleChannels.ZOffset],
+				qx,qy,qz,qw, scale);
+			particleController.update();
+		}
+	}
+	@Override
+	public ParticleControllerFinalizerInfluencer copy () {
+		return new ParticleControllerFinalizerInfluencer();
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/ParticleControllerInfluencer.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/ParticleControllerInfluencer.java
new file mode 100644
index 0000000..bcc2672
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/ParticleControllerInfluencer.java
@@ -0,0 +1,235 @@
+package com.badlogic.gdx.graphics.g3d.particles.influencers;
+
+import java.util.Iterator;
+
+import com.badlogic.gdx.assets.AssetDescriptor;
+import com.badlogic.gdx.assets.AssetManager;
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.ObjectChannel;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleController;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleEffect;
+import com.badlogic.gdx.graphics.g3d.particles.ResourceData;
+import com.badlogic.gdx.graphics.g3d.particles.ResourceData.SaveData;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.Pool;
+
+/** It's an {@link Influencer} which controls which {@link ParticleController} will be assigned to a particle.
+ * @author Inferno */
+public abstract class ParticleControllerInfluencer extends Influencer{
+
+	/** Assigns the first controller of {@link ParticleControllerInfluencer#templates} to the particles.*/
+	public static class Single extends ParticleControllerInfluencer{
+
+		public Single (ParticleController... templates) {
+			super(templates);
+		}
+		
+		public Single (){
+			super();
+		}
+			
+		public Single (Single particleControllerSingle) {
+			super(particleControllerSingle);
+		}
+
+		@Override
+		public void init () {
+			ParticleController first = templates.first();
+			for(int i=0, c = controller.particles.capacity; i < c; ++i){
+				ParticleController copy = first.copy();
+				copy.init();
+				particleControllerChannel.data[i] = copy;
+			}
+		}
+		
+		@Override
+		public void activateParticles (int startIndex, int count) {
+			for(int i=startIndex, c = startIndex +count; i < c; ++i){
+				particleControllerChannel.data[i].start();
+			}
+		}
+		
+		@Override
+		public void killParticles (int startIndex, int count) {
+			for(int i=startIndex, c = startIndex +count; i < c; ++i){
+				particleControllerChannel.data[i].end();
+			}
+		}
+
+		@Override
+		public Single copy () {
+			return new Single(this);
+		}
+	}
+	
+	
+	/** Assigns a random controller of {@link ParticleControllerInfluencer#templates} to the particles.*/
+	public static class Random extends ParticleControllerInfluencer{
+		private class ParticleControllerPool extends Pool<ParticleController>{
+			public ParticleControllerPool () {}
+
+			@Override
+			public ParticleController newObject () {
+				ParticleController controller = templates.random().copy();
+				controller.init();
+				return controller;
+			}
+			
+			@Override
+			public void clear () {
+				//Dispose every allocated instance because the templates may be changed 
+				for(int i=0, free = pool.getFree(); i < free; ++i){
+					pool.obtain().dispose();
+				}
+				super.clear();
+			}
+		}
+		
+		ParticleControllerPool pool;
+		
+		public Random (){
+			super();
+			pool = new ParticleControllerPool();
+		}
+		public Random (ParticleController... templates) {
+			super(templates);
+			pool = new ParticleControllerPool();
+		}
+
+		public Random (Random particleControllerRandom) {
+			super(particleControllerRandom);
+			pool = new ParticleControllerPool();
+		}
+		
+		@Override
+		public void init () {
+			pool.clear();
+			//Allocate the new instances
+			for(int i=0; i < controller.emitter.maxParticleCount; ++i){
+				pool.free(pool.newObject());
+			}
+		}
+		
+		@Override
+		public void dispose(){
+			pool.clear();
+			super.dispose();
+		}
+
+		@Override
+		public void activateParticles (int startIndex, int count) {
+			for(int i=startIndex, c = startIndex +count; i < c; ++i){
+				ParticleController controller = pool.obtain();
+				controller.start();
+				particleControllerChannel.data[i] = controller;
+			}
+		}
+		
+		@Override
+		public void killParticles (int startIndex, int count) {
+			for(int i=startIndex, c = startIndex +count; i < c; ++i){
+				ParticleController controller = particleControllerChannel.data[i];
+				controller.end();
+				pool.free(controller);
+				particleControllerChannel.data[i] = null;
+			}
+		}
+
+		@Override
+		public Random copy () {
+			return new Random(this);
+		}
+	}
+	
+	public Array<ParticleController> templates;
+	ObjectChannel<ParticleController> particleControllerChannel;
+	
+	public ParticleControllerInfluencer(){
+		this.templates = new Array<ParticleController>(true, 1, ParticleController.class);
+	}
+	
+	public ParticleControllerInfluencer(ParticleController... templates){
+		this.templates = new Array<ParticleController>(templates);
+	}
+	
+	public ParticleControllerInfluencer(ParticleControllerInfluencer influencer){
+		this(influencer.templates.items);
+	}
+	
+	@Override
+	public void allocateChannels () {
+		particleControllerChannel = controller.particles.addChannel(ParticleChannels.ParticleController);
+	}
+	
+	@Override
+	public void end(){
+		for(int i=0; i < controller.particles.size; ++i){
+			particleControllerChannel.data[i].end();
+		}
+	}
+	
+	@Override
+	public void dispose () {
+		if(controller != null){
+			for(int i=0; i < controller.particles.size; ++i){
+				ParticleController controller = particleControllerChannel.data[i];
+				if(controller != null){
+					controller.dispose();
+					particleControllerChannel.data[i]= null;
+				}
+			}
+		}
+	}
+
+	@Override
+	public void save (AssetManager manager, ResourceData resources) {
+		SaveData data = resources.createSaveData();
+		Array<ParticleEffect> effects = manager.getAll(ParticleEffect.class, new Array<ParticleEffect>());
+		
+		Array<ParticleController> controllers = new Array<ParticleController>(templates);
+		Array<Array<Integer>>effectsIndices = new Array<Array<Integer>>();
+		
+		for(int i=0; i < effects.size && controllers.size >0; ++i){
+			ParticleEffect effect = effects.get(i);
+			Array<ParticleController> effectControllers = effect.getControllers();
+			Iterator<ParticleController> iterator = controllers.iterator();
+			Array<Integer> indices = null;
+			while(iterator.hasNext()){
+				ParticleController controller = iterator.next();
+				int index = -1;
+				if( (index = effectControllers.indexOf(controller, true)) >-1){
+					if(indices == null){
+						indices = new Array<Integer>();
+					}
+					iterator.remove();
+					indices.add(index);
+				}
+			}
+			
+			if(indices != null){
+				data.saveAsset(manager.getAssetFileName(effect), ParticleEffect.class);
+				effectsIndices.add(indices);
+			}
+		}
+		data.save("indices", effectsIndices);
+	}
+	
+	@Override
+	public void load (AssetManager manager, ResourceData resources) {
+		SaveData data = resources.getSaveData();
+		Array<Array<Integer>>effectsIndices = data.load("indices");
+		AssetDescriptor descriptor;
+		Iterator<Array<Integer>> iterator = effectsIndices.iterator();
+		while((descriptor = data.loadAsset()) != null){
+			ParticleEffect effect = (ParticleEffect)manager.get(descriptor);
+			if(effect == null)
+				throw new RuntimeException("Template is null");
+			Array<ParticleController> effectControllers = effect.getControllers();
+			Array<Integer> effectIndices = iterator.next();
+			
+			for(Integer index : effectIndices){
+					templates.add(effectControllers.get(index));
+			}
+		}
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/RegionInfluencer.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/RegionInfluencer.java
new file mode 100644
index 0000000..418cffc
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/RegionInfluencer.java
@@ -0,0 +1,225 @@
+package com.badlogic.gdx.graphics.g3d.particles.influencers;
+
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.g2d.TextureRegion;
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.FloatChannel;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.Json;
+import com.badlogic.gdx.utils.JsonValue;
+
+/** It's an {@link Influencer} which assigns a region of a {@link Texture} to the particles.
+ * @author Inferno */
+public abstract class RegionInfluencer extends Influencer {
+	
+	/** Assigns the first region of {@link RegionInfluencer#regions} to the particles.*/
+	public static class Single extends RegionInfluencer{
+		public Single(){}
+
+		public Single (Single regionInfluencer) {
+			super(regionInfluencer);
+		}
+
+		public Single (TextureRegion textureRegion) {
+			super(textureRegion);
+		}
+		
+		public Single (Texture texture) {
+			super(texture);
+		}
+
+		@Override
+		public void init () {
+			AspectTextureRegion region = regions.items[0];
+			for(int 	i=0, c = controller.emitter.maxParticleCount*regionChannel.strideSize; 
+				i < c; 
+				i +=regionChannel.strideSize){
+				regionChannel.data[i +ParticleChannels.UOffset] = region.u; 
+				regionChannel.data[i +ParticleChannels.VOffset] = region.v;
+				regionChannel.data[i +ParticleChannels.U2Offset] = region.u2;
+				regionChannel.data[i +ParticleChannels.V2Offset] = region.v2; 
+				regionChannel.data[i +ParticleChannels.HalfWidthOffset] = 0.5f; 
+				regionChannel.data[i +ParticleChannels.HalfHeightOffset] = region.halfInvAspectRatio;
+			}	
+		}
+		
+		@Override
+		public Single copy () {
+			return new Single(this);
+		}
+	}
+
+	/** Assigns a random region of {@link RegionInfluencer#regions} to the particles.*/
+	public static class Random extends RegionInfluencer{
+		public Random(){}
+		public Random (Random regionInfluencer) {
+			super(regionInfluencer);
+		}
+		public Random (TextureRegion textureRegion) {
+			super(textureRegion);
+		}
+		
+		public Random (Texture texture) {
+			super(texture);
+		}
+
+		@Override
+		public void activateParticles (int startIndex, int count) {
+			for(int 	i=startIndex*regionChannel.strideSize, c = i +count*regionChannel.strideSize; 
+				i < c; 
+				i +=regionChannel.strideSize){
+				AspectTextureRegion region = regions.random();
+				regionChannel.data[i +ParticleChannels.UOffset] = region.u; 
+				regionChannel.data[i +ParticleChannels.VOffset] = region.v;
+				regionChannel.data[i +ParticleChannels.U2Offset] = region.u2;
+				regionChannel.data[i +ParticleChannels.V2Offset] = region.v2; 
+				regionChannel.data[i +ParticleChannels.HalfWidthOffset] = 0.5f; 
+				regionChannel.data[i +ParticleChannels.HalfHeightOffset] = region.halfInvAspectRatio;
+			}	
+		}
+		
+		@Override
+		public Random copy () {
+			return new Random(this);
+		}
+	}
+	
+	/** Assigns a region to the particles using the particle life percent
+	 * to calculate the current index in the {@link RegionInfluencer#regions} array.*/
+	public static class Animated extends RegionInfluencer{
+		FloatChannel lifeChannel;
+		public Animated(){}
+		public Animated (Animated regionInfluencer) {
+			super(regionInfluencer);
+		}
+
+		public Animated (TextureRegion textureRegion) {
+			super(textureRegion);
+		}
+		
+		public Animated (Texture texture) {
+			super(texture);
+		}
+
+		@Override
+		public void allocateChannels () {
+			super.allocateChannels();
+			lifeChannel = controller.particles.addChannel(ParticleChannels.Life);
+		}
+		
+		@Override
+		public void update () {
+			for(int 	i=0, l = ParticleChannels.LifePercentOffset,
+				c = controller.particles.size*regionChannel.strideSize; 
+				i < c; 
+				i +=regionChannel.strideSize, l +=lifeChannel.strideSize){
+				AspectTextureRegion region = regions.get( (int)(lifeChannel.data[l]*(regions.size-1)));
+				regionChannel.data[i +ParticleChannels.UOffset] = region.u; 
+				regionChannel.data[i +ParticleChannels.VOffset] = region.v;
+				regionChannel.data[i +ParticleChannels.U2Offset] = region.u2;
+				regionChannel.data[i +ParticleChannels.V2Offset] = region.v2; 
+				regionChannel.data[i +ParticleChannels.HalfWidthOffset] = 0.5f; 
+				regionChannel.data[i +ParticleChannels.HalfHeightOffset] = region.halfInvAspectRatio;
+			}
+		}
+		
+		@Override
+		public Animated copy () {
+			return new Animated(this);
+		}
+	}
+	
+	/** It's a class used internally by the {@link RegionInfluencer} to represent a texture region.
+	 * It contains the uv coordinates of the region and the region inverse aspect ratio.*/
+	public static class AspectTextureRegion{
+		public float u, v, u2, v2;
+		public float halfInvAspectRatio;
+		
+		public AspectTextureRegion(){}
+		
+		public AspectTextureRegion( AspectTextureRegion aspectTextureRegion){
+			set(aspectTextureRegion);
+		}
+		
+		public AspectTextureRegion(TextureRegion region){
+			set(region);
+		}
+		
+		public void set(TextureRegion region){
+			this.u = region.getU();
+			this.v = region.getV();
+			this.u2 = region.getU2();
+			this.v2 = region.getV2();
+			this.halfInvAspectRatio = 0.5f*((float)region.getRegionHeight()/region.getRegionWidth());
+		}
+		
+		public void set(AspectTextureRegion aspectTextureRegion){
+			u = aspectTextureRegion.u;
+			v = aspectTextureRegion.v;
+			u2 = aspectTextureRegion.u2;
+			v2 = aspectTextureRegion.v2;
+			halfInvAspectRatio = aspectTextureRegion.halfInvAspectRatio;
+		}
+	}
+	
+	public Array<AspectTextureRegion> regions;
+	FloatChannel regionChannel;
+	
+	public RegionInfluencer(int regionsCount){
+		this.regions = new Array<AspectTextureRegion>(false, regionsCount, AspectTextureRegion.class);
+	}
+	
+	public RegionInfluencer(){
+		this(1);
+		AspectTextureRegion aspectRegion = new AspectTextureRegion();
+		aspectRegion.u = aspectRegion.v = 0;
+		aspectRegion.u2 = aspectRegion.v2 = 1;
+		aspectRegion.halfInvAspectRatio = 0.5f;
+		regions.add(aspectRegion);
+	}
+	
+	/** All the regions must be defined on the same Texture */
+	public RegionInfluencer(TextureRegion...regions){
+		this.regions = new Array<AspectTextureRegion>( false, regions.length, AspectTextureRegion.class);
+		add(regions);
+	}
+	
+	public RegionInfluencer(Texture texture){
+		this(new TextureRegion(texture));
+	}
+	
+	public RegionInfluencer(RegionInfluencer regionInfluencer){
+		this(regionInfluencer.regions.size);
+		regions.ensureCapacity(regionInfluencer.regions.size);
+		for(int i=0; i < regionInfluencer.regions.size; ++i){
+			regions.add(new AspectTextureRegion((AspectTextureRegion)regionInfluencer.regions.get(i)));
+		}
+	}
+	
+	public void add (TextureRegion...regions) {
+		this.regions.ensureCapacity(regions.length);
+		for(TextureRegion region : regions){
+			this.regions.add(new AspectTextureRegion(region));
+		}
+	}
+	
+	public void clear(){
+		regions.clear();
+	}
+	
+	@Override
+	public void allocateChannels () {
+		regionChannel = controller.particles.addChannel(ParticleChannels.TextureRegion);
+	}
+
+	@Override
+	public void write (Json json) {
+		json.writeValue("regions", regions, Array.class, AspectTextureRegion.class);
+	}
+
+	@Override
+	public void read (Json json, JsonValue jsonData) {
+		regions.clear();
+		regions.addAll(json.readValue("regions", Array.class, AspectTextureRegion.class, jsonData));
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/ScaleInfluencer.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/ScaleInfluencer.java
new file mode 100644
index 0000000..876577c
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/ScaleInfluencer.java
@@ -0,0 +1,48 @@
+package com.badlogic.gdx.graphics.g3d.particles.influencers;
+
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleControllerComponent;
+
+/** It's an {@link Influencer} which controls the scale of the particles.
+ * @author Inferno */
+public class ScaleInfluencer extends SimpleInfluencer{
+	
+	public ScaleInfluencer(){
+		super();
+		valueChannelDescriptor = ParticleChannels.Scale;
+	}
+	
+	@Override
+	public void activateParticles (int startIndex, int count) {		
+		if(value.isRelative()){
+			for(int 	i=startIndex*valueChannel.strideSize, a = startIndex*interpolationChannel.strideSize, c = i +count*valueChannel.strideSize; 
+				i < c;  i +=valueChannel.strideSize, a+=interpolationChannel.strideSize){
+				float start = value.newLowValue()* controller.scale.x;
+				float diff = value.newHighValue()* controller.scale.x;
+				interpolationChannel.data[a +ParticleChannels.InterpolationStartOffset] = start;
+				interpolationChannel.data[a +ParticleChannels.InterpolationDiffOffset] = diff;
+				valueChannel.data[i] = start + diff* value.getScale(0);
+			}
+		}
+		else {
+			for(int 	i=startIndex*valueChannel.strideSize, a = startIndex*interpolationChannel.strideSize, c = i +count*valueChannel.strideSize; 
+				i < c;  i +=valueChannel.strideSize, a+=interpolationChannel.strideSize){
+				float start = value.newLowValue()* controller.scale.x;
+				float diff = value.newHighValue()* controller.scale.x - start;
+				interpolationChannel.data[a +ParticleChannels.InterpolationStartOffset] = start;
+				interpolationChannel.data[a +ParticleChannels.InterpolationDiffOffset] = diff;
+				valueChannel.data[i] = start + diff* value.getScale(0);
+			}
+		}
+	}
+	
+	public ScaleInfluencer (ScaleInfluencer scaleInfluencer) {
+		super(scaleInfluencer);
+	}
+
+	@Override
+	public ParticleControllerComponent copy () {
+		return new ScaleInfluencer(this);
+	}
+
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/SimpleInfluencer.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/SimpleInfluencer.java
new file mode 100644
index 0000000..c6f1426
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/SimpleInfluencer.java
@@ -0,0 +1,88 @@
+package com.badlogic.gdx.graphics.g3d.particles.influencers;
+
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.ChannelDescriptor;
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.FloatChannel;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels;
+import com.badlogic.gdx.graphics.g3d.particles.values.ScaledNumericValue;
+import com.badlogic.gdx.utils.Json;
+import com.badlogic.gdx.utils.JsonValue;
+
+/** It's an {@link Influencer} which controls a generic channel of the particles.
+ *  It handles the interpolation through time using {@link ScaledNumericValue}. 
+ *  @author Inferno */
+public abstract class SimpleInfluencer extends Influencer{
+
+	public ScaledNumericValue value;
+	FloatChannel valueChannel, interpolationChannel, lifeChannel;
+	ChannelDescriptor valueChannelDescriptor;
+	
+	public SimpleInfluencer(){
+		value = new ScaledNumericValue();
+		value.setHigh(1);
+	}
+	
+	public SimpleInfluencer (SimpleInfluencer billboardScaleinfluencer) {
+		this();
+		set(billboardScaleinfluencer);
+	}
+
+	private void set (SimpleInfluencer scaleInfluencer) {
+		value.load(scaleInfluencer.value);
+		valueChannelDescriptor = scaleInfluencer.valueChannelDescriptor;
+	}
+	
+	@Override
+	public void allocateChannels() {
+		valueChannel = controller.particles.addChannel(valueChannelDescriptor);
+		ParticleChannels.Interpolation.id = controller.particleChannels.newId();
+		interpolationChannel = controller.particles.addChannel(ParticleChannels.Interpolation);
+		lifeChannel = controller.particles.addChannel(ParticleChannels.Life);
+	}
+
+	@Override
+	public void activateParticles (int startIndex, int count) {
+		if(!value.isRelative()){
+			for(int 	i=startIndex*valueChannel.strideSize, a = startIndex*interpolationChannel.strideSize, c = i +count*valueChannel.strideSize; 
+				i < c;  i +=valueChannel.strideSize, a+=interpolationChannel.strideSize){
+				float start = value.newLowValue();
+				float diff = value.newHighValue() - start;
+				interpolationChannel.data[a +ParticleChannels.InterpolationStartOffset] = start;
+				interpolationChannel.data[a +ParticleChannels.InterpolationDiffOffset] = diff;
+				valueChannel.data[i] = start + diff* value.getScale(0);
+			}
+		}
+		else {
+			for(int 	i=startIndex*valueChannel.strideSize, a = startIndex*interpolationChannel.strideSize, c = i +count*valueChannel.strideSize; 
+				i < c;  i +=valueChannel.strideSize, a+=interpolationChannel.strideSize){
+				float start = value.newLowValue();
+				float diff = value.newHighValue();
+				interpolationChannel.data[a +ParticleChannels.InterpolationStartOffset] = start;
+				interpolationChannel.data[a +ParticleChannels.InterpolationDiffOffset] = diff;
+				valueChannel.data[i] = start + diff* value.getScale(0);
+			}
+		}
+	}
+
+	@Override
+	public void update () {
+		for(int 	i=0, a = 0, l = ParticleChannels.LifePercentOffset,
+			c = i +controller.particles.size*valueChannel.strideSize; 
+			i < c; 
+			i +=valueChannel.strideSize, a +=interpolationChannel.strideSize, l +=lifeChannel.strideSize){
+			
+			valueChannel.data[i] = interpolationChannel.data[a +ParticleChannels.InterpolationStartOffset] + 
+															interpolationChannel.data[a +ParticleChannels.InterpolationDiffOffset] * value.getScale(lifeChannel.data[l]);
+		}
+	}
+	
+	@Override
+	public void write (Json json) {
+		json.writeValue("value", value);
+	}
+	
+	@Override
+	public void read (Json json, JsonValue jsonData) {
+		value = json.readValue("value", ScaledNumericValue.class, jsonData);
+	}
+	
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/SpawnInfluencer.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/SpawnInfluencer.java
new file mode 100644
index 0000000..eb0ba83
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/SpawnInfluencer.java
@@ -0,0 +1,81 @@
+package com.badlogic.gdx.graphics.g3d.particles.influencers;
+
+import com.badlogic.gdx.assets.AssetManager;
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.FloatChannel;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels;
+import com.badlogic.gdx.graphics.g3d.particles.ResourceData;
+import com.badlogic.gdx.graphics.g3d.particles.values.PointSpawnShapeValue;
+import com.badlogic.gdx.graphics.g3d.particles.values.SpawnShapeValue;
+import com.badlogic.gdx.utils.Json;
+import com.badlogic.gdx.utils.JsonValue;
+
+/** It's an {@link Influencer} which controls where the particles will be spawned.
+ * @author Inferno */
+public class SpawnInfluencer extends Influencer {
+
+	public SpawnShapeValue spawnShapeValue;
+	FloatChannel positionChannel;
+	
+	public SpawnInfluencer(){
+		spawnShapeValue = new PointSpawnShapeValue();
+	}
+	
+	public SpawnInfluencer(SpawnShapeValue spawnShapeValue){
+		this.spawnShapeValue = spawnShapeValue;
+	}
+	
+	public SpawnInfluencer(SpawnInfluencer source){
+		spawnShapeValue = source.spawnShapeValue.copy();
+	}
+	
+	@Override
+	public void init () {
+		spawnShapeValue.init();
+	}
+	
+	@Override
+	public void allocateChannels () {
+		positionChannel = controller.particles.addChannel(ParticleChannels.Position);
+	}
+	
+	@Override
+	public void start () {
+		spawnShapeValue.start();
+	}
+
+	@Override
+	public void activateParticles (int startIndex, int count) {
+		for(int 	i=startIndex*positionChannel.strideSize, c = i +count*positionChannel.strideSize; i < c; i +=positionChannel.strideSize){
+			spawnShapeValue.spawn(TMP_V1, controller.emitter.percent);
+			TMP_V1.mul(controller.transform);
+			positionChannel.data[i+ParticleChannels.XOffset] = TMP_V1.x;
+			positionChannel.data[i+ParticleChannels.YOffset] = TMP_V1.y;
+			positionChannel.data[i+ParticleChannels.ZOffset] = TMP_V1.z;
+		}
+	}
+
+	@Override
+	public SpawnInfluencer copy () {
+		return new SpawnInfluencer(this);
+	}
+
+	@Override
+	public void write (Json json) {
+		json.writeValue("spawnShape", spawnShapeValue, SpawnShapeValue.class);
+	}
+	
+	@Override
+	public void read (Json json, JsonValue jsonData) {
+		spawnShapeValue = json.readValue("spawnShape", SpawnShapeValue.class, jsonData);
+	}
+	
+	@Override
+	public void save (AssetManager manager, ResourceData data) {
+		spawnShapeValue.save(manager, data);
+	}
+	
+	@Override
+	public void load (AssetManager manager, ResourceData data) {
+		spawnShapeValue.load(manager, data);
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/particles.fragment.glsl b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/particles.fragment.glsl
new file mode 100644
index 0000000..6cfdc71
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/particles.fragment.glsl
@@ -0,0 +1,38 @@
+#ifdef GL_ES 
+#define LOWP lowp
+#define MED mediump
+#define HIGH highp
+precision mediump float;
+#else
+#define MED
+#define LOWP
+#define HIGH
+#endif
+
+
+#ifdef billboard
+//Billboard particles
+varying vec4 v_color;
+varying MED vec2 v_texCoords0;
+uniform sampler2D u_diffuseTexture;
+
+void main() {
+	gl_FragColor = texture2D(u_diffuseTexture, v_texCoords0) * v_color;
+}
+#else
+//Point particles
+varying vec4 v_color;
+varying mat2 v_rotation;
+varying MED vec4 v_region;
+varying vec2 v_uvRegionCenter;
+
+uniform sampler2D u_diffuseTexture;
+uniform vec2 u_regionSize;
+
+void main() {
+	vec2 uv = v_region.xy + gl_PointCoord*v_region.zw - v_uvRegionCenter;
+	vec2 texCoord = v_rotation * uv  +v_uvRegionCenter;
+	gl_FragColor = texture2D(u_diffuseTexture, texCoord)* v_color;
+}
+
+#endif
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/particles.vertex.glsl b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/particles.vertex.glsl
new file mode 100644
index 0000000..c0ce005
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/particles.vertex.glsl
@@ -0,0 +1,101 @@
+#ifdef billboard
+//Billboard particles
+//In
+attribute vec3 a_position;
+attribute vec2 a_texCoord0;
+attribute vec4 a_sizeAndRotation;
+attribute vec4 a_color;
+
+//out
+varying vec2 v_texCoords0;
+varying vec4 v_color;
+
+//Camera
+uniform mat4 u_projViewTrans;
+
+//Billboard to screen
+#ifdef screenFacing
+uniform vec3 u_cameraInvDirection;
+uniform vec3 u_cameraRight;
+uniform vec3 u_cameraUp;
+#endif
+#ifdef viewPointFacing
+uniform vec3 u_cameraPosition;
+uniform vec3 u_cameraUp;
+#endif
+#ifdef paticleDirectionFacing
+uniform vec3 u_cameraPosition;
+attribute vec3 a_direction;
+#endif
+
+void main() {
+
+#ifdef screenFacing
+	vec3 right = u_cameraRight;
+	vec3 up = u_cameraUp;
+	vec3 look = u_cameraInvDirection;
+#endif
+#ifdef viewPointFacing
+	vec3 look = normalize(u_cameraPosition - a_position);
+	vec3 right = normalize(cross(u_cameraUp, look));
+	vec3 up = normalize(cross(look, right));
+#endif
+#ifdef paticleDirectionFacing
+	vec3 up = a_direction;
+	vec3 look = normalize(u_cameraPosition - a_position);
+	vec3 right = normalize(cross(up, look));
+	look = normalize(cross(right, up));
+#endif
+
+	//Rotate around look
+	vec3 axis = look;
+	float c = a_sizeAndRotation.z;
+    float s = a_sizeAndRotation.w;
+    float oc = 1.0 - c;
+    
+    mat3 rot = mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,
+                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,
+                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);	
+	vec3 offset = rot*(right*a_sizeAndRotation.x + up*a_sizeAndRotation.y );
+
+	gl_Position = u_projViewTrans * vec4(a_position + offset, 1.0);
+	v_texCoords0 = a_texCoord0;
+	v_color = a_color;
+}
+#else
+//Point particles
+attribute vec3 a_position;
+attribute vec3 a_sizeAndRotation;
+attribute vec4 a_color;
+attribute vec4 a_region;
+
+//out
+varying vec4 v_color;
+varying mat2 v_rotation;
+varying vec4 v_region;
+varying vec2 v_uvRegionCenter;
+
+//Camera
+uniform mat4 u_projTrans;
+//should be modelView but particles are already in world coordinates
+uniform mat4 u_viewTrans;
+uniform float u_screenWidth;
+uniform vec2 u_regionSize;
+
+void main(){
+
+	float halfSize = 0.5*a_sizeAndRotation.x;
+	vec4 eyePos = u_viewTrans * vec4(a_position, 1); 
+	vec4 projCorner = u_projTrans * vec4(halfSize, halfSize, eyePos.z, eyePos.w);
+	gl_PointSize = u_screenWidth * projCorner.x / projCorner.w;
+	gl_Position = u_projTrans * eyePos;
+	v_rotation = mat2(a_sizeAndRotation.y, a_sizeAndRotation.z, -a_sizeAndRotation.z, a_sizeAndRotation.y);
+	v_color = a_color;
+	v_region.xy = a_region.xy;
+	v_region.zw = a_region.zw -a_region.xy;	
+	v_uvRegionCenter = a_region.xy +v_region.zw*0.5;
+}
+
+#endif
+
+
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/BillboardControllerRenderData.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/BillboardControllerRenderData.java
new file mode 100644
index 0000000..b4efce3
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/BillboardControllerRenderData.java
@@ -0,0 +1,12 @@
+package com.badlogic.gdx.graphics.g3d.particles.renderers;
+
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.FloatChannel;
+
+/** Render data used by billboard particle batches 
+ * @author Inferno */
+public class BillboardControllerRenderData extends ParticleControllerRenderData{
+	public FloatChannel 	regionChannel, 
+												colorChannel, 
+												scaleChannel,
+												rotationChannel;
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/BillboardRenderer.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/BillboardRenderer.java
new file mode 100644
index 0000000..4a4fdf9
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/BillboardRenderer.java
@@ -0,0 +1,44 @@
+package com.badlogic.gdx.graphics.g3d.particles.renderers;
+
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels.ColorInitializer;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels.Rotation2dInitializer;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels.ScaleInitializer;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels.TextureRegionInitializer;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleControllerComponent;
+import com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch;
+import com.badlogic.gdx.graphics.g3d.particles.batches.ParticleBatch;
+
+/** A {@link ParticleControllerRenderer} which will render particles as billboards to a {@link BillboardParticleBatch} .
+ * @author Inferno */
+public class BillboardRenderer extends ParticleControllerRenderer< BillboardControllerRenderData, BillboardParticleBatch> {
+	
+	public BillboardRenderer(){
+		super(new BillboardControllerRenderData());
+	}
+	
+	public BillboardRenderer(BillboardParticleBatch batch){
+		this();
+		setBatch(batch);
+	}
+	
+	@Override
+	public void allocateChannels () {
+		renderData.positionChannel = controller.particles.addChannel(ParticleChannels.Position);
+		renderData.regionChannel = controller.particles.addChannel(ParticleChannels.TextureRegion, TextureRegionInitializer.get());
+		renderData.colorChannel = controller.particles.addChannel(ParticleChannels.Color, ColorInitializer.get());
+		renderData.scaleChannel = controller.particles.addChannel(ParticleChannels.Scale, ScaleInitializer.get());
+		renderData.rotationChannel = controller.particles.addChannel(ParticleChannels.Rotation2D, Rotation2dInitializer.get());
+	}
+
+	@Override
+	public ParticleControllerComponent copy () {
+		return new BillboardRenderer(batch);
+	}
+
+	@Override
+	public boolean isCompatible (ParticleBatch<?> batch) {
+		return batch instanceof BillboardParticleBatch;
+	}
+
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/ModelInstanceControllerRenderData.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/ModelInstanceControllerRenderData.java
new file mode 100644
index 0000000..4f8a408
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/ModelInstanceControllerRenderData.java
@@ -0,0 +1,15 @@
+package com.badlogic.gdx.graphics.g3d.particles.renderers;
+
+import com.badlogic.gdx.graphics.g3d.ModelInstance;
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.FloatChannel;
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.ObjectChannel;
+
+/** Render data used by model instance particle batches 
+ * @author Inferno */
+public class ModelInstanceControllerRenderData extends ParticleControllerRenderData{
+	public ObjectChannel<ModelInstance> 	modelInstanceChannel;
+	public FloatChannel	colorChannel,
+												scaleChannel,
+												rotationChannel;
+												
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/ModelInstanceRenderer.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/ModelInstanceRenderer.java
new file mode 100644
index 0000000..2eac46a
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/ModelInstanceRenderer.java
@@ -0,0 +1,87 @@
+package com.badlogic.gdx.graphics.g3d.particles.renderers;
+
+import com.badlogic.gdx.graphics.g3d.ModelInstance;
+import com.badlogic.gdx.graphics.g3d.attributes.BlendingAttribute;
+import com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleControllerComponent;
+import com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch;
+import com.badlogic.gdx.graphics.g3d.particles.batches.ModelInstanceParticleBatch;
+import com.badlogic.gdx.graphics.g3d.particles.batches.ParticleBatch;
+
+/** A {@link ParticleControllerRenderer} which will render particles 
+ * as {@link ModelInstance} to a {@link ModelInstanceParticleBatch}.
+ * @author Inferno */
+public class ModelInstanceRenderer extends ParticleControllerRenderer<ModelInstanceControllerRenderData, ModelInstanceParticleBatch> {
+	private boolean hasColor, hasScale, hasRotation;
+	public ModelInstanceRenderer(){
+		super(new ModelInstanceControllerRenderData());
+	}
+	
+	public ModelInstanceRenderer(ModelInstanceParticleBatch batch){
+		this();
+		setBatch(batch);
+	}
+	
+	@Override
+	public void allocateChannels () {
+		renderData.positionChannel = controller.particles.addChannel(ParticleChannels.Position);
+	}
+	
+	@Override
+	public void init () {
+		renderData.modelInstanceChannel = controller.particles.getChannel(ParticleChannels.ModelInstance);
+		renderData.colorChannel = controller.particles.getChannel(ParticleChannels.Color);
+		renderData.scaleChannel = controller.particles.getChannel(ParticleChannels.Scale);
+		renderData.rotationChannel = controller.particles.getChannel(ParticleChannels.Rotation3D);
+		hasColor = renderData.colorChannel != null;
+		hasScale = renderData.scaleChannel != null;
+		hasRotation = renderData.rotationChannel != null;
+	}
+
+	@Override
+	public void update () {
+		for(int i=0, positionOffset = 0, c = controller.particles.size;
+			i< c; 
+			++i, positionOffset += renderData.positionChannel.strideSize){
+			ModelInstance instance = renderData.modelInstanceChannel.data[i];
+			float scale = hasScale ? renderData.scaleChannel.data[i] : 1;
+			float qx=0, qy=0, qz=0, qw=1;
+			if(hasRotation){
+				int rotationOffset = i* renderData.rotationChannel.strideSize;
+				qx = renderData.rotationChannel.data[rotationOffset + ParticleChannels.XOffset];
+				qy = renderData.rotationChannel.data[rotationOffset + ParticleChannels.YOffset]; 
+				qz = renderData.rotationChannel.data[rotationOffset + ParticleChannels.ZOffset];
+				qw = renderData.rotationChannel.data[rotationOffset + ParticleChannels.WOffset];
+			}
+			
+			instance.transform.set(	renderData.positionChannel.data[positionOffset + ParticleChannels.XOffset],
+				renderData.positionChannel.data[positionOffset + ParticleChannels.YOffset],
+				renderData.positionChannel.data[positionOffset + ParticleChannels.ZOffset],
+				qx, qy, qz, qw,
+				scale, scale, scale);
+			if(hasColor){
+				int colorOffset = i*renderData.colorChannel.strideSize;
+				ColorAttribute colorAttribute = (ColorAttribute)instance.materials.get(0).get(ColorAttribute.Diffuse);
+				BlendingAttribute blendingAttribute = (BlendingAttribute)instance.materials.get(0).get(BlendingAttribute.Type);
+				colorAttribute.color.r = renderData.colorChannel.data[colorOffset +ParticleChannels.RedOffset];
+				colorAttribute.color.g = renderData.colorChannel.data[colorOffset +ParticleChannels.GreenOffset];
+				colorAttribute.color.b = renderData.colorChannel.data[colorOffset +ParticleChannels.BlueOffset];
+				if(blendingAttribute != null)
+					blendingAttribute.opacity  = renderData.colorChannel.data[colorOffset +ParticleChannels.AlphaOffset];
+			}
+		}
+		super.update();
+	}
+	
+	@Override
+	public ParticleControllerComponent copy () {
+		return new ModelInstanceRenderer(batch);
+	}
+
+	@Override
+	public boolean isCompatible (ParticleBatch<?> batch) {
+		return batch instanceof ModelInstanceParticleBatch;
+	}
+
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/ParticleControllerControllerRenderer.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/ParticleControllerControllerRenderer.java
new file mode 100644
index 0000000..ca986f7
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/ParticleControllerControllerRenderer.java
@@ -0,0 +1,42 @@
+package com.badlogic.gdx.graphics.g3d.particles.renderers;
+
+import com.badlogic.gdx.graphics.g3d.ModelInstance;
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.ObjectChannel;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleController;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleControllerComponent;
+import com.badlogic.gdx.graphics.g3d.particles.batches.ModelInstanceParticleBatch;
+import com.badlogic.gdx.graphics.g3d.particles.batches.ParticleBatch;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+/** A {@link ParticleControllerRenderer} which will render the {@link ParticleController} of each particle. 
+ * @author Inferno */
+@SuppressWarnings("rawtypes")
+public class ParticleControllerControllerRenderer extends ParticleControllerRenderer{
+	ObjectChannel<ParticleController> controllerChannel;
+	
+	@Override
+	public void init () {
+		controllerChannel = controller.particles.getChannel(ParticleChannels.ParticleController);
+		if(controllerChannel == null)
+			throw new GdxRuntimeException("ParticleController channel not found, specify an influencer which will allocate it please.");
+	}
+
+	@Override
+	public void update () {
+		for(int i=0, c = controller.particles.size; i< c; ++i){
+			controllerChannel.data[i].draw();
+		}
+	}
+	
+	@Override
+	public ParticleControllerComponent copy () {
+		return new ParticleControllerControllerRenderer();
+	}
+
+	@Override
+	public boolean isCompatible (ParticleBatch batch) {
+		return false;
+	}
+
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/ParticleControllerRenderData.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/ParticleControllerRenderData.java
new file mode 100644
index 0000000..a02d775
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/ParticleControllerRenderData.java
@@ -0,0 +1,11 @@
+package com.badlogic.gdx.graphics.g3d.particles.renderers;
+
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.FloatChannel;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleController;
+
+/** Render data used by particle controller renderer
+ * @author Inferno */
+public abstract class ParticleControllerRenderData {
+	public ParticleController controller;
+	public FloatChannel positionChannel;
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/ParticleControllerRenderer.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/ParticleControllerRenderer.java
new file mode 100644
index 0000000..a83c009
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/ParticleControllerRenderer.java
@@ -0,0 +1,42 @@
+package com.badlogic.gdx.graphics.g3d.particles.renderers;
+
+import com.badlogic.gdx.graphics.g3d.particles.ParticleController;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleControllerComponent;
+import com.badlogic.gdx.graphics.g3d.particles.batches.ParticleBatch;
+
+/** It's a {@link ParticleControllerComponent} which determines how the particles are rendered.
+ * It's the base class of every particle renderer.
+ * @author Inferno */
+public abstract class ParticleControllerRenderer< D extends ParticleControllerRenderData, T extends ParticleBatch<D>> extends ParticleControllerComponent{
+	protected T batch;
+	protected D renderData;
+	
+	protected ParticleControllerRenderer(){}
+	
+	protected ParticleControllerRenderer(D renderData){
+		this.renderData = renderData;
+	}
+	
+	@Override
+	public void update () {
+		batch.draw(renderData);
+	}
+	
+	@SuppressWarnings("unchecked")
+	public boolean setBatch (ParticleBatch<?> batch){
+		if(isCompatible(batch)){
+			this.batch = (T)batch;
+			return true;
+		}
+		return false;
+	}
+	
+	public abstract boolean isCompatible (ParticleBatch<?> batch);
+
+	@Override
+	public void set (ParticleController particleController) {
+		super.set(particleController);
+		if(renderData != null)
+			renderData.controller = controller;
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/PointSpriteControllerRenderData.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/PointSpriteControllerRenderData.java
new file mode 100644
index 0000000..3f3009d
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/PointSpriteControllerRenderData.java
@@ -0,0 +1,13 @@
+package com.badlogic.gdx.graphics.g3d.particles.renderers;
+
+import com.badlogic.gdx.graphics.g3d.particles.ParallelArray.FloatChannel;
+
+/** Render data used by point sprites batches
+ * @author Inferno */
+public class PointSpriteControllerRenderData extends ParticleControllerRenderData{
+	public FloatChannel 	regionChannel, 
+												colorChannel, 
+												scaleChannel,
+												rotationChannel;
+												
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/PointSpriteRenderer.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/PointSpriteRenderer.java
new file mode 100644
index 0000000..1ffc570
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/renderers/PointSpriteRenderer.java
@@ -0,0 +1,44 @@
+package com.badlogic.gdx.graphics.g3d.particles.renderers;
+
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels.ColorInitializer;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels.Rotation2dInitializer;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels.ScaleInitializer;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleChannels.TextureRegionInitializer;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleControllerComponent;
+import com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch;
+import com.badlogic.gdx.graphics.g3d.particles.batches.ParticleBatch;
+import com.badlogic.gdx.graphics.g3d.particles.batches.PointSpriteParticleBatch;
+
+/** A {@link ParticleControllerRenderer} which will render particles as point sprites to a {@link PointSpriteParticleBatch} .
+ * @author Inferno */
+public class PointSpriteRenderer extends ParticleControllerRenderer<PointSpriteControllerRenderData, PointSpriteParticleBatch> {
+	public PointSpriteRenderer(){
+		super(new PointSpriteControllerRenderData());
+	}
+	
+	public PointSpriteRenderer(PointSpriteParticleBatch batch){
+		this();
+		setBatch(batch);
+	}
+	
+	@Override
+	public void allocateChannels () {
+		renderData.positionChannel = controller.particles.addChannel(ParticleChannels.Position);
+		renderData.regionChannel = controller.particles.addChannel(ParticleChannels.TextureRegion, TextureRegionInitializer.get());
+		renderData.colorChannel = controller.particles.addChannel(ParticleChannels.Color, ColorInitializer.get());
+		renderData.scaleChannel = controller.particles.addChannel(ParticleChannels.Scale, ScaleInitializer.get());
+		renderData.rotationChannel = controller.particles.addChannel(ParticleChannels.Rotation2D, Rotation2dInitializer.get());
+	}
+	
+	@Override
+	public boolean isCompatible (ParticleBatch<?> batch) {
+		return batch instanceof PointSpriteParticleBatch;
+	}
+	
+	@Override
+	public ParticleControllerComponent copy () {
+		return new PointSpriteRenderer(batch);
+	}
+
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/CylinderSpawnShapeValue.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/CylinderSpawnShapeValue.java
new file mode 100644
index 0000000..53939f8
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/CylinderSpawnShapeValue.java
@@ -0,0 +1,57 @@
+package com.badlogic.gdx.graphics.g3d.particles.values;
+
+import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.math.Vector3;
+
+/** Encapsulate the formulas to spawn a particle on a cylinder shape. 
+ * @author Inferno */
+public final class CylinderSpawnShapeValue extends PrimitiveSpawnShapeValue{
+
+	public CylinderSpawnShapeValue (CylinderSpawnShapeValue cylinderSpawnShapeValue) {
+		super(cylinderSpawnShapeValue);
+		load(cylinderSpawnShapeValue);
+	}
+
+	public CylinderSpawnShapeValue () {}
+
+	@Override
+	public void spawnAux (Vector3 vector, float percent) {
+		//Generate the point on the surface of the sphere
+		float width = spawnWidth + (spawnWidthDiff * spawnWidthValue.getScale(percent));
+		float height = spawnHeight + (spawnHeightDiff * spawnHeightValue.getScale(percent));
+		float depth = spawnDepth + (spawnDepthDiff * spawnDepthValue.getScale(percent));
+		
+		float radiusX, radiusZ;
+		float hf = height / 2;
+		float ty = MathUtils.random(height) - hf;
+		
+		//Where generate the point, on edges or inside ?
+		if(edges ){
+			radiusX = width / 2;
+			radiusZ = depth/2;
+		}
+		else {
+			radiusX = MathUtils.random(width)/2;
+			radiusZ = MathUtils.random(depth)/2;
+		}
+
+		float 	spawnTheta = 0;
+		
+		//Generate theta
+		boolean isRadiusXZero = radiusX == 0, isRadiusZZero = radiusZ == 0;
+		if(!isRadiusXZero && !isRadiusZZero)
+			spawnTheta = MathUtils.random(360f);
+		else {
+			if(isRadiusXZero) spawnTheta = MathUtils.random(1) == 0 ? -90 : 90;
+			else if(isRadiusZZero) spawnTheta = MathUtils.random(1)==0 ? 0 : 180;
+		}
+		
+		vector.set(radiusX*MathUtils.cosDeg(spawnTheta), ty, radiusZ*MathUtils.sinDeg(spawnTheta));
+	}
+
+	@Override
+	public SpawnShapeValue copy () {
+		return new CylinderSpawnShapeValue(this);
+	}
+
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/EllipseSpawnShapeValue.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/EllipseSpawnShapeValue.java
new file mode 100644
index 0000000..23b4fd4
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/EllipseSpawnShapeValue.java
@@ -0,0 +1,99 @@
+package com.badlogic.gdx.graphics.g3d.particles.values;
+
+import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.utils.Json;
+import com.badlogic.gdx.utils.JsonValue;
+
+/** Encapsulate the formulas to spawn a particle on a ellipse shape.
+ * @author Inferno */
+public final class EllipseSpawnShapeValue extends PrimitiveSpawnShapeValue {
+	SpawnSide side = SpawnSide.both;
+	
+	public EllipseSpawnShapeValue (EllipseSpawnShapeValue value) {
+		super(value);
+		load(value);
+	}
+
+	public EllipseSpawnShapeValue () {}
+
+	@Override
+	public void spawnAux (Vector3 vector, float percent) {
+		//Generate the point on the surface of the sphere
+		float width = spawnWidth + spawnWidthDiff * spawnWidthValue.getScale(percent);
+		float height = spawnHeight + spawnHeightDiff * spawnHeightValue.getScale(percent);
+		float depth = spawnDepth + spawnDepthDiff * spawnDepthValue.getScale(percent);
+		
+		float radiusX, radiusY, radiusZ;
+		//Where generate the point, on edges or inside ?
+		float minT =0, maxT = MathUtils.PI2;
+		if(side == SpawnSide.top){
+			maxT = MathUtils.PI;
+		}
+		else if(side == SpawnSide.bottom){
+			maxT = -MathUtils.PI;
+		}
+		float t = MathUtils.random(minT, maxT);
+		
+		//Where generate the point, on edges or inside ?
+		if(edges){
+			if(width == 0){
+				vector.set(0, height / 2 * MathUtils.sin(t), depth/2 * MathUtils.cos(t)); 
+				return;
+			}
+			if(height == 0){
+				vector.set(width / 2 * MathUtils.cos(t), 0, depth/2 * MathUtils.sin(t)); 
+				return;
+			}
+			if(depth == 0){
+				vector.set(width / 2 * MathUtils.cos(t), height / 2 * MathUtils.sin(t), 0);
+				return;
+			}
+			
+			radiusX = width / 2;
+			radiusY = height / 2;
+			radiusZ = depth/2;
+		}
+		else {
+			radiusX = MathUtils.random(width/2);
+			radiusY = MathUtils.random(height /2);
+			radiusZ = MathUtils.random(depth/2);
+		}
+		
+		float z = MathUtils.random(-1, 1f);
+		float r = (float)Math.sqrt(1f - z*z);
+		vector.set(radiusX * r * MathUtils.cos(t), radiusY * r * MathUtils.sin(t), radiusZ * z);
+	}
+	
+	public SpawnSide getSide () {
+		return side;
+	}
+
+	public void setSide (SpawnSide side) {
+		this.side = side;
+	}
+
+	@Override
+	public void load (ParticleValue value) {
+		super.load(value);
+		EllipseSpawnShapeValue shape = (EllipseSpawnShapeValue) value;
+		side = shape.side;
+	}
+
+	@Override
+	public SpawnShapeValue copy () {
+		return new EllipseSpawnShapeValue(this);
+	}
+
+	@Override
+	public void write (Json json) {
+		super.write(json);
+		json.writeValue("side", side);
+	}
+
+	@Override
+	public void read (Json json, JsonValue jsonData) {
+		super.read(json, jsonData);
+		side = json.readValue("side", SpawnSide.class, jsonData);
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/GradientColorValue.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/GradientColorValue.java
new file mode 100644
index 0000000..bf6ff47
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/GradientColorValue.java
@@ -0,0 +1,86 @@
+package com.badlogic.gdx.graphics.g3d.particles.values;
+
+import com.badlogic.gdx.utils.Json;
+import com.badlogic.gdx.utils.JsonValue;
+
+/** Defines a variation of red, green and blue on a given time line.
+ * @author Inferno */
+public class GradientColorValue extends ParticleValue {
+		static private float[] temp = new float[3];
+
+		private float[] colors = {1, 1, 1};
+		public float[] timeline = {0};
+
+		public float[] getTimeline () {
+			return timeline;
+		}
+
+		public void setTimeline (float[] timeline) {
+			this.timeline = timeline;
+		}
+
+		public float[] getColors () {
+			return colors;
+		}
+
+		public void setColors (float[] colors) {
+			this.colors = colors;
+		}
+
+		public float[] getColor (float percent) {
+			getColor(percent, temp, 0);
+			return temp;
+		}
+		
+		public void getColor (float percent, float[] out, int index) {
+			int startIndex = 0, endIndex = -1;
+			float[] timeline = this.timeline;
+			int n = timeline.length;
+			for (int i = 1; i < n; i++) {
+				float t = timeline[i];
+				if (t > percent) {
+					endIndex = i;
+					break;
+				}
+				startIndex = i;
+			}
+			float startTime = timeline[startIndex];
+			startIndex *= 3;
+			float r1 = colors[startIndex];
+			float g1 = colors[startIndex + 1];
+			float b1 = colors[startIndex + 2];
+			if (endIndex == -1) {
+				out[index] = r1;
+				out[index+1] = g1;
+				out[index+2] = b1;
+				return;
+			}
+			float factor = (percent - startTime) / (timeline[endIndex] - startTime);
+			endIndex *= 3;
+			out[index] = r1 + (colors[endIndex] - r1) * factor;
+			out[index+1] = g1 + (colors[endIndex + 1] - g1) * factor;
+			out[index+2] = b1 + (colors[endIndex + 2] - b1) * factor;
+		}
+		
+		@Override
+		public void write (Json json) {
+			super.write(json);
+			json.writeValue("colors", colors);
+			json.writeValue("timeline", timeline);
+		}
+
+		@Override
+		public void read (Json json, JsonValue jsonData) {
+			super.read(json, jsonData);
+			colors = json.readValue("colors", float[].class, jsonData);
+			timeline = json.readValue("timeline", float[].class, jsonData);
+		}
+		
+		public void load (GradientColorValue value) {
+			super.load(value);
+			colors = new float[value.colors.length];
+			System.arraycopy(value.colors, 0, colors, 0, colors.length);
+			timeline = new float[value.timeline.length];
+			System.arraycopy(value.timeline, 0, timeline, 0, timeline.length);
+		}
+	}
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/LineSpawnShapeValue.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/LineSpawnShapeValue.java
new file mode 100644
index 0000000..a136020
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/LineSpawnShapeValue.java
@@ -0,0 +1,33 @@
+package com.badlogic.gdx.graphics.g3d.particles.values;
+
+import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.math.Vector3;
+
+/** Encapsulate the formulas to spawn a particle on a line shape. 
+ * @author Inferno */
+public final class LineSpawnShapeValue extends PrimitiveSpawnShapeValue {
+
+	public LineSpawnShapeValue (LineSpawnShapeValue value) {
+		super(value);
+		load(value);
+	}
+
+	public LineSpawnShapeValue () {}
+
+	@Override
+	public void spawnAux (Vector3 vector, float percent) {
+		float width = spawnWidth + (spawnWidthDiff * spawnWidthValue.getScale(percent));
+		float height = spawnHeight + (spawnHeightDiff * spawnHeightValue.getScale(percent));
+		float depth = spawnDepth + (spawnDepthDiff * spawnDepthValue.getScale(percent));
+
+		float a = MathUtils.random();
+		vector.x = a * width;
+		vector.y = a * height;
+		vector.z = a * depth;
+	}
+
+	@Override
+	public SpawnShapeValue copy () {
+		return new LineSpawnShapeValue(this);
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/MeshSpawnShapeValue.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/MeshSpawnShapeValue.java
new file mode 100644
index 0000000..3151762
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/MeshSpawnShapeValue.java
@@ -0,0 +1,95 @@
+package com.badlogic.gdx.graphics.g3d.particles.values;
+
+import com.badlogic.gdx.assets.AssetDescriptor;
+import com.badlogic.gdx.assets.AssetManager;
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.VertexAttributes.Usage;
+import com.badlogic.gdx.graphics.g3d.Model;
+import com.badlogic.gdx.graphics.g3d.particles.ResourceData;
+import com.badlogic.gdx.graphics.g3d.particles.ResourceData.SaveData;
+import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+/** The base class of all the {@link ParticleValue} values which spawn a particle on a mesh shape.
+* @author Inferno */
+public abstract class MeshSpawnShapeValue extends SpawnShapeValue {
+	protected static class Triangle{
+		float x1, y1, z1,
+				x2, y2, z2,
+				x3, y3, z3;
+		public Triangle(	float x1, float y1, float z1, 
+								float x2, float y2, float z2, 
+								float x3, float y3, float z3){
+			this.x1 = x1; this.y1 = y1; this.z1 = z1;
+			this.x2 = x2; this.y2 = y2; this.z2 = z2;
+			this.x3 = x3; this.y3 = y3; this.z3 = z3;
+		}
+		
+		public static Vector3 pick(float x1, float y1, float z1, 
+			float x2, float y2, float z2, 
+			float x3, float y3, float z3, Vector3 vector){
+			float a = MathUtils.random(), b = MathUtils.random();
+			return vector.set( 	x1 + a*(x2 - x1) + b*(x3 - x1),
+										y1 + a*(y2 - y1) + b*(y3 - y1),
+										z1 + a*(z2 - z1) + b*(z3 - z1));
+		}
+		
+		public Vector3 pick(Vector3 vector){
+			float a = MathUtils.random(), b = MathUtils.random();
+			return vector.set( 	x1 + a*(x2 - x1) + b*(x3 - x1),
+										y1 + a*(y2 - y1) + b*(y3 - y1),
+										z1 + a*(z2 - z1) + b*(z3 - z1));
+		}
+	}
+	
+	protected Mesh mesh;
+	/** the model this mesh belongs to.
+	 * It can be null, but this means the mesh 
+	 * will not be able to be serialized correctly.*/
+	protected Model model;
+	
+	public MeshSpawnShapeValue (MeshSpawnShapeValue value) {
+		super(value);
+	}
+
+	public MeshSpawnShapeValue () {}
+
+	@Override
+	public void load (ParticleValue value) {
+		super.load(value);
+		MeshSpawnShapeValue spawnShapeValue = (MeshSpawnShapeValue) value;
+		setMesh(spawnShapeValue.mesh, spawnShapeValue.model);
+	}
+	
+	public void setMesh(Mesh mesh, Model model){
+		if(mesh.getVertexAttribute(Usage.Position) == null) 
+			throw new GdxRuntimeException("Mesh vertices must have Usage.Position");
+		this.model =  model;
+		this.mesh = mesh;
+	}
+	
+	public void setMesh(Mesh mesh){
+		this.setMesh(mesh, null);
+	}
+
+	@Override
+	public void save (AssetManager manager, ResourceData data) {
+		if(model != null){
+			SaveData saveData = data.createSaveData();
+			saveData.saveAsset(manager.getAssetFileName(model), Model.class);
+			saveData.save("index", model.meshes.indexOf(mesh, true));
+		}
+	}
+	
+	@Override
+	public void load (AssetManager manager, ResourceData data) {
+		SaveData saveData = data.getSaveData();
+		AssetDescriptor descriptor = saveData.loadAsset();
+		if(descriptor!=null){
+			Model model = (Model) manager.get(descriptor);
+			setMesh(model.meshes.get((Integer)saveData.load("index")), model);
+		}
+	}
+
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/NumericValue.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/NumericValue.java
new file mode 100644
index 0000000..14a9ab8
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/NumericValue.java
@@ -0,0 +1,36 @@
+package com.badlogic.gdx.graphics.g3d.particles.values;
+
+import com.badlogic.gdx.utils.Json;
+import com.badlogic.gdx.utils.JsonValue;
+
+/** A value which contains a single float variable. 
+ * @author Inferno */
+public class NumericValue extends ParticleValue {
+	private float value;
+
+	public float getValue () {
+		return value;
+	}
+
+	public void setValue (float value) {
+		this.value = value;
+	}
+
+	public void load (NumericValue value) {
+		super.load(value);
+		this.value = value.value;
+	}
+	
+	@Override
+	public void write (Json json) {
+		super.write(json);
+		json.writeValue("value", value);
+	}
+
+	@Override
+	public void read (Json json, JsonValue jsonData) {
+		super.read(json, jsonData);
+		value = json.readValue("value", float.class, jsonData);
+	}
+	
+}
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/ParticleValue.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/ParticleValue.java
new file mode 100644
index 0000000..b29e3b8
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/ParticleValue.java
@@ -0,0 +1,40 @@
+package com.badlogic.gdx.graphics.g3d.particles.values;
+
+import com.badlogic.gdx.utils.Json;
+import com.badlogic.gdx.utils.JsonValue;
+
+/** It's a class which represents a value bound to the particles.
+ * Generally used by a particle controller component to find 
+ * the current value of a particle property during the simulation. 
+ * @author Inferno */
+public class ParticleValue implements Json.Serializable {
+	public boolean active;
+
+	public ParticleValue(){	}
+	
+	public ParticleValue (ParticleValue value) {
+		this.active =value.active;
+	}
+	
+	public boolean isActive () {
+		return active;
+	}
+
+	public void setActive (boolean active) {
+		this.active = active;
+	}
+
+	public void load (ParticleValue value) {
+		active = value.active;
+	}
+	
+	@Override
+	public void write (Json json) {
+		json.writeValue("active", active);
+	}
+
+	@Override
+	public void read (Json json, JsonValue jsonData) {
+		active = json.readValue("active", Boolean.class, jsonData);
+	}
+}
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/PointSpawnShapeValue.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/PointSpawnShapeValue.java
new file mode 100644
index 0000000..7d879b9
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/PointSpawnShapeValue.java
@@ -0,0 +1,27 @@
+package com.badlogic.gdx.graphics.g3d.particles.values;
+
+import com.badlogic.gdx.math.Vector3;
+
+/** Encapsulate the formulas to spawn a particle on a point shape. 
+ * @author Inferno */
+public final class PointSpawnShapeValue extends PrimitiveSpawnShapeValue {
+
+	public PointSpawnShapeValue (PointSpawnShapeValue value) {
+		super(value);
+		load(value);
+	}
+
+	public PointSpawnShapeValue () {}
+
+	@Override
+	public void spawnAux (Vector3 vector, float percent) {
+		vector.x = spawnWidth + (spawnWidthDiff * spawnWidthValue.getScale(percent));
+		vector.y = spawnHeight + (spawnHeightDiff * spawnHeightValue.getScale(percent));
+		vector.z = spawnDepth + (spawnDepthDiff * spawnDepthValue.getScale(percent));
+	}
+
+	@Override
+	public SpawnShapeValue copy () {
+		return new PointSpawnShapeValue(this);
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/PrimitiveSpawnShapeValue.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/PrimitiveSpawnShapeValue.java
new file mode 100644
index 0000000..ecf8ca2
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/PrimitiveSpawnShapeValue.java
@@ -0,0 +1,113 @@
+package com.badlogic.gdx.graphics.g3d.particles.values;
+
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.utils.Json;
+import com.badlogic.gdx.utils.JsonValue;
+
+/** The base class of all the {@link SpawnShapeValue} values which spawn the
+ * particles on a geometric primitive. 
+ * @author Inferno */
+public abstract class PrimitiveSpawnShapeValue extends SpawnShapeValue {
+	protected static final Vector3 TMP_V1 = new Vector3();
+	static public enum SpawnSide {
+		both, top, bottom
+	}
+	public ScaledNumericValue spawnWidthValue,
+							 spawnHeightValue,
+							 spawnDepthValue;
+	protected float spawnWidth, spawnWidthDiff;
+	protected float spawnHeight, spawnHeightDiff;
+	protected float spawnDepth, spawnDepthDiff;
+	boolean edges = false;
+	
+	public PrimitiveSpawnShapeValue(){
+		spawnWidthValue = new ScaledNumericValue();
+		spawnHeightValue = new ScaledNumericValue();
+		spawnDepthValue = new ScaledNumericValue();
+	}
+	
+	public PrimitiveSpawnShapeValue(PrimitiveSpawnShapeValue value){
+		super(value);
+		spawnWidthValue = new ScaledNumericValue();
+		spawnHeightValue = new ScaledNumericValue();
+		spawnDepthValue = new ScaledNumericValue();
+	}
+	
+	@Override
+	public void setActive (boolean active) {
+		super.setActive(active);
+		spawnWidthValue.setActive(true);
+		spawnHeightValue.setActive(true);
+		spawnDepthValue.setActive(true);
+	}
+	
+	public boolean isEdges () {
+		return edges;
+	}
+
+	public void setEdges (boolean edges) {
+		this.edges = edges;
+	}
+	
+	public ScaledNumericValue getSpawnWidth () {
+		return spawnWidthValue;
+	}
+
+	public ScaledNumericValue getSpawnHeight () {
+		return spawnHeightValue;
+	}
+	
+	public ScaledNumericValue getSpawnDepth () 	{
+		return spawnDepthValue;
+	}
+	
+	public void setDimensions(float width, float height, float depth){
+		spawnWidthValue.setHigh(width);
+		spawnHeightValue.setHigh(height);
+		spawnDepthValue.setHigh(depth);
+	}
+	
+	@Override
+	public void start () {
+		spawnWidth = spawnWidthValue.newLowValue();
+		spawnWidthDiff = spawnWidthValue.newHighValue();
+		if (!spawnWidthValue.isRelative()) spawnWidthDiff -= spawnWidth;
+
+		spawnHeight = spawnHeightValue.newLowValue();
+		spawnHeightDiff = spawnHeightValue.newHighValue();
+		if (!spawnHeightValue.isRelative()) spawnHeightDiff -= spawnHeight;
+		
+		spawnDepth = spawnDepthValue.newLowValue();
+		spawnDepthDiff = spawnDepthValue.newHighValue();
+		if (!spawnDepthValue.isRelative()) spawnDepthDiff -= spawnDepth;
+	}
+	
+	@Override
+	public void load (ParticleValue value) {
+		super.load(value);
+		PrimitiveSpawnShapeValue shape = (PrimitiveSpawnShapeValue) value;
+		edges = shape.edges;
+		spawnWidthValue.load(shape.spawnWidthValue);
+		spawnHeightValue.load(shape.spawnHeightValue);
+		spawnDepthValue.load(shape.spawnDepthValue);
+	}
+	
+	@Override
+	public void write (Json json) {
+		super.write(json);
+		json.writeValue("spawnWidthValue", spawnWidthValue);
+		json.writeValue("spawnHeightValue", spawnHeightValue);
+		json.writeValue("spawnDepthValue", spawnDepthValue);
+		json.writeValue("edges", edges);
+	}
+
+	@Override
+	public void read (Json json, JsonValue jsonData) {
+		super.read(json, jsonData);
+		spawnWidthValue = json.readValue("spawnWidthValue", ScaledNumericValue.class, jsonData);
+		spawnHeightValue = json.readValue("spawnHeightValue", ScaledNumericValue.class, jsonData);
+		spawnDepthValue = json.readValue("spawnDepthValue", ScaledNumericValue.class, jsonData);
+		edges = json.readValue("edges", boolean.class, jsonData);
+	}
+	
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/RangedNumericValue.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/RangedNumericValue.java
new file mode 100644
index 0000000..c42a16b
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/RangedNumericValue.java
@@ -0,0 +1,62 @@
+package com.badlogic.gdx.graphics.g3d.particles.values;
+
+import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.utils.Json;
+import com.badlogic.gdx.utils.JsonValue;
+
+/** A value which has a defined minimum and maximum bounds.
+* @author Inferno */
+public class RangedNumericValue extends ParticleValue {
+	private float lowMin, lowMax;
+
+	public float newLowValue () {
+		return lowMin + (lowMax - lowMin) * MathUtils.random();
+	}
+
+	public void setLow (float value) {
+		lowMin = value;
+		lowMax = value;
+	}
+
+	public void setLow (float min, float max) {
+		lowMin = min;
+		lowMax = max;
+	}
+
+	public float getLowMin () {
+		return lowMin;
+	}
+
+	public void setLowMin (float lowMin) {
+		this.lowMin = lowMin;
+	}
+
+	public float getLowMax () {
+		return lowMax;
+	}
+
+	public void setLowMax (float lowMax) {
+		this.lowMax = lowMax;
+	}
+
+	public void load (RangedNumericValue value) {
+		super.load(value);
+		lowMax = value.lowMax;
+		lowMin = value.lowMin;
+	}
+	
+	@Override
+	public void write (Json json) {
+		super.write(json);
+		json.writeValue("lowMin", lowMin);
+		json.writeValue("lowMax", lowMax);
+	}
+
+	@Override
+	public void read (Json json, JsonValue jsonData) {
+		super.read(json, jsonData);
+		lowMin = json.readValue("lowMin", float.class, jsonData);
+		lowMax = json.readValue("lowMax", float.class, jsonData);
+	}
+	
+}
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/RectangleSpawnShapeValue.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/RectangleSpawnShapeValue.java
new file mode 100644
index 0000000..9ac49bd
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/RectangleSpawnShapeValue.java
@@ -0,0 +1,74 @@
+package com.badlogic.gdx.graphics.g3d.particles.values;
+
+import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.math.Vector3;
+
+/** Encapsulate the formulas to spawn a particle on a rectangle shape. 
+* @author Inferno */
+public final class RectangleSpawnShapeValue extends PrimitiveSpawnShapeValue {
+	public RectangleSpawnShapeValue (RectangleSpawnShapeValue value) {
+		super(value);
+		load(value);
+	}
+
+	public RectangleSpawnShapeValue () {}
+
+	@Override
+	public void spawnAux (Vector3 vector, float percent) {
+		float width = spawnWidth + (spawnWidthDiff * spawnWidthValue.getScale(percent));
+		float height = spawnHeight + (spawnHeightDiff * spawnHeightValue.getScale(percent));
+		float depth = spawnDepth + (spawnDepthDiff * spawnDepthValue.getScale(percent));
+		//Where generate the point, on edges or inside ?
+		if(edges)
+		{
+			int a = MathUtils.random(-1,1);
+			float tx=0, ty=0, tz=0;
+			if(a == -1){
+				tx = MathUtils.random(1)==0 ? -width/ 2 : width/ 2; 
+				if(tx == 0){
+					ty = MathUtils.random(1)==0 ? -height / 2 : height/ 2;	
+					tz = MathUtils.random(1)==0 ? -depth/2 : depth/2;
+				}
+				else {
+					ty = MathUtils.random(height) - height / 2;	
+					tz = MathUtils.random(depth) - depth / 2;
+				}
+			}
+			else if(a == 0){
+				//Z
+				tz = MathUtils.random(1)==0 ? -depth/ 2 : depth/ 2; 
+				if(tz == 0){
+					ty = MathUtils.random(1)==0 ? -height / 2 : height/ 2;	
+					tx = MathUtils.random(1)==0 ? -width/2 : width/2;
+				}
+				else {
+					ty = MathUtils.random(height) - height / 2;	
+					tx = MathUtils.random(width) - width / 2;
+				}
+			}
+			else {
+				//Y
+				ty = MathUtils.random(1)==0 ? -height/ 2 : height / 2; 
+				if(ty == 0){
+					tx = MathUtils.random(1)==0 ? -width / 2 : width / 2;	
+					tz = MathUtils.random(1)==0 ? -depth/2 : depth/2;
+				}
+				else {
+					tx = MathUtils.random(width) - width / 2;	
+					tz = MathUtils.random(depth) - depth / 2;
+				}
+			}			
+			vector.x = tx; vector.y = ty; vector.z = tz;
+		}
+		else {
+			vector.x = MathUtils.random(width) - width / 2;
+			vector.y = MathUtils.random(height) - height / 2;
+			vector.z = MathUtils.random(depth) - depth/2;	
+		}
+	}
+
+	@Override
+	public SpawnShapeValue copy () {
+		return new RectangleSpawnShapeValue(this);
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/ScaledNumericValue.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/ScaledNumericValue.java
new file mode 100644
index 0000000..612d42f
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/ScaledNumericValue.java
@@ -0,0 +1,121 @@
+package com.badlogic.gdx.graphics.g3d.particles.values;
+
+import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.utils.Json;
+import com.badlogic.gdx.utils.JsonValue;
+
+/** A value which has a defined minimum and maximum upper and lower bounds.
+ * Defines the variations of the value on a time line. 
+ * @author Inferno */
+public class ScaledNumericValue extends RangedNumericValue {
+	private float[] scaling = {1};
+	public float[] timeline = {0};
+	private float highMin, highMax;
+	private boolean relative = false;
+
+	public float newHighValue () {
+		return highMin + (highMax - highMin) * MathUtils.random();
+	}
+
+	public void setHigh (float value) {
+		highMin = value;
+		highMax = value;
+	}
+
+	public void setHigh (float min, float max) {
+		highMin = min;
+		highMax = max;
+	}
+
+	public float getHighMin () {
+		return highMin;
+	}
+
+	public void setHighMin (float highMin) {
+		this.highMin = highMin;
+	}
+
+	public float getHighMax () {
+		return highMax;
+	}
+
+	public void setHighMax (float highMax) {
+		this.highMax = highMax;
+	}
+
+	public float[] getScaling () {
+		return scaling;
+	}
+
+	public void setScaling (float[] values) {
+		this.scaling = values;
+	}
+
+	public float[] getTimeline () {
+		return timeline;
+	}
+
+	public void setTimeline (float[] timeline) {
+		this.timeline = timeline;
+	}
+
+	public boolean isRelative () {
+		return relative;
+	}
+
+	public void setRelative (boolean relative) {
+		this.relative = relative;
+	}
+
+	public float getScale (float percent) {
+		int endIndex = -1;
+		int n = timeline.length;
+		//if (percent >= timeline[n-1]) 
+		//	return scaling[n - 1];
+		for (int i = 1; i < n; i++) {
+			float t = timeline[i];
+			if (t > percent) {
+				endIndex = i;
+				break;
+			}
+		}
+		if (endIndex == -1) return scaling[n - 1];
+		int startIndex = endIndex - 1;
+		float startValue = scaling[startIndex];
+		float startTime = timeline[startIndex];
+		return startValue + (scaling[endIndex] - startValue) * ((percent - startTime) / (timeline[endIndex] - startTime));
+	}
+
+	public void load (ScaledNumericValue value) {
+		super.load(value);
+		highMax = value.highMax;
+		highMin = value.highMin;
+		scaling = new float[value.scaling.length];
+		System.arraycopy(value.scaling, 0, scaling, 0, scaling.length);
+		timeline = new float[value.timeline.length];
+		System.arraycopy(value.timeline, 0, timeline, 0, timeline.length);
+		relative = value.relative;
+	}
+	
+	@Override
+	public void write (Json json) {
+		super.write(json);
+		json.writeValue("highMin", highMin);
+		json.writeValue("highMax", highMax);
+		json.writeValue("relative", relative);
+		json.writeValue("scaling", scaling);
+		json.writeValue("timeline", timeline);
+	}
+
+	@Override
+	public void read (Json json, JsonValue jsonData) {
+		super.read(json, jsonData);
+		highMin = json.readValue("highMin", float.class, jsonData);
+		highMax = json.readValue("highMax", float.class, jsonData);
+		relative = json.readValue("relative", boolean.class, jsonData);
+		scaling = json.readValue("scaling", float[].class, jsonData);
+		timeline = json.readValue("timeline", float[].class, jsonData);
+	}
+	
+	
+}
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/SpawnShapeValue.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/SpawnShapeValue.java
new file mode 100644
index 0000000..df765a1
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/SpawnShapeValue.java
@@ -0,0 +1,71 @@
+package com.badlogic.gdx.graphics.g3d.particles.values;
+
+import com.badlogic.gdx.assets.AssetManager;
+import com.badlogic.gdx.graphics.g3d.particles.ResourceData;
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.utils.Json;
+import com.badlogic.gdx.utils.JsonValue;
+
+/** Encapsulate the formulas to spawn a particle on a shape.
+* @author Inferno */
+public abstract class SpawnShapeValue extends ParticleValue implements  ResourceData.Configurable, Json.Serializable{
+	
+	public RangedNumericValue xOffsetValue, yOffsetValue, zOffsetValue;
+	
+	public SpawnShapeValue(){
+		xOffsetValue = new RangedNumericValue();
+		yOffsetValue = new RangedNumericValue();
+		zOffsetValue = new RangedNumericValue();
+	}
+	
+	public SpawnShapeValue(SpawnShapeValue spawnShapeValue){
+		this();
+	}
+	
+	public abstract void spawnAux(Vector3 vector, float percent);
+	
+	public final Vector3 spawn(Vector3 vector, float percent){
+		spawnAux(vector, percent);
+		if (xOffsetValue.active) vector.x += xOffsetValue.newLowValue();
+		if (yOffsetValue.active) vector.y += yOffsetValue.newLowValue();
+		if (zOffsetValue.active) vector.z += zOffsetValue.newLowValue();
+		return vector;
+	}
+
+	public void init (){}
+	public void start(){}
+	
+	@Override
+	public void load (ParticleValue value) {
+		super.load(value);
+		SpawnShapeValue shape = (SpawnShapeValue) value;
+		xOffsetValue.load(shape.xOffsetValue);
+		yOffsetValue.load(shape.yOffsetValue);
+		zOffsetValue.load(shape.zOffsetValue);
+	}
+	
+	public abstract SpawnShapeValue copy ();
+	
+	@Override
+	public void write (Json json) {
+		super.write(json);
+		json.writeValue("xOffsetValue", xOffsetValue);
+		json.writeValue("yOffsetValue", yOffsetValue);
+		json.writeValue("zOffsetValue", zOffsetValue);
+	}
+
+	@Override
+	public void read (Json json, JsonValue jsonData) {
+		super.read(json, jsonData);
+		xOffsetValue = json.readValue("xOffsetValue", RangedNumericValue.class, jsonData);
+		yOffsetValue = json.readValue("yOffsetValue", RangedNumericValue.class, jsonData);
+		zOffsetValue = json.readValue("zOffsetValue", RangedNumericValue.class, jsonData);
+	}
+	
+	@Override
+	public void save (AssetManager manager, ResourceData data) {}
+	@Override
+	public void load (AssetManager manager, ResourceData data) {}
+
+	
+}
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/UnweightedMeshSpawnShapeValue.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/UnweightedMeshSpawnShapeValue.java
new file mode 100644
index 0000000..4bda958
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/UnweightedMeshSpawnShapeValue.java
@@ -0,0 +1,71 @@
+package com.badlogic.gdx.graphics.g3d.particles.values;
+
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.VertexAttributes.Usage;
+import com.badlogic.gdx.graphics.g3d.Model;
+import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.math.Vector3;
+
+/** Encapsulate the formulas to spawn a particle on a mesh shape. 
+* @author Inferno */
+public final class UnweightedMeshSpawnShapeValue extends MeshSpawnShapeValue {
+	private float[] vertices;
+	private short[] indices;
+	private int positionOffset, vertexSize, vertexCount, triangleCount;
+	
+	public UnweightedMeshSpawnShapeValue (UnweightedMeshSpawnShapeValue value) {
+		super(value);
+		load(value);
+	}
+
+	public UnweightedMeshSpawnShapeValue () {}
+	
+	@Override
+	public void setMesh(Mesh mesh, Model model){
+		super.setMesh(mesh, model);
+		vertexSize = mesh.getVertexSize()/4;
+		positionOffset = mesh.getVertexAttribute(Usage.Position).offset/4;
+		int indicesCount = mesh.getNumIndices();
+		if(indicesCount >0){
+			indices = new short[indicesCount];
+			mesh.getIndices(indices);
+			triangleCount = indices.length/3;
+		}
+		else indices = null;
+		vertexCount = mesh.getNumVertices();
+		vertices = new float[ vertexCount* vertexSize];
+		mesh.getVertices(vertices);
+	}
+
+	@Override
+	public void spawnAux (Vector3 vector, float percent) {
+		if(indices == null){
+			//Triangles 
+			int triangleIndex = MathUtils.random(vertexCount -3)*vertexSize;
+			int 	p1Offset = triangleIndex+positionOffset, 
+					p2Offset = p1Offset + vertexSize, 
+					p3Offset = p2Offset + vertexSize;
+			float x1 = vertices[p1Offset], y1 = vertices[p1Offset+1], z1 = vertices[p1Offset+2],
+					x2 = vertices[p2Offset], y2 = vertices[p2Offset+1], z2 = vertices[p2Offset+2],
+					x3 = vertices[p3Offset], y3 = vertices[p3Offset+1], z3 = vertices[p3Offset+2];
+			Triangle.pick(x1, y1, z1, x2, y2, z2, x3, y3, z3, vector);
+		}
+		else {
+			//Indices
+			int triangleIndex = MathUtils.random(triangleCount-1)*3;
+			int p1Offset = indices[triangleIndex]*vertexSize + positionOffset,
+				 p2Offset = indices[triangleIndex+1]*vertexSize + positionOffset,
+				 p3Offset = indices[triangleIndex+2]*vertexSize + positionOffset;
+			float x1 = vertices[p1Offset], y1 = vertices[p1Offset+1], z1 = vertices[p1Offset+2],
+				x2 = vertices[p2Offset], y2 = vertices[p2Offset+1], z2 = vertices[p2Offset+2],
+				x3 = vertices[p3Offset], y3 = vertices[p3Offset+1], z3 = vertices[p3Offset+2];
+			Triangle.pick(x1, y1, z1, x2, y2, z2, x3, y3, z3, vector);
+		}
+	}
+
+	@Override
+	public SpawnShapeValue copy () {
+		return new UnweightedMeshSpawnShapeValue(this);
+	}
+
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/WeightMeshSpawnShapeValue.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/WeightMeshSpawnShapeValue.java
new file mode 100644
index 0000000..0582e53
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/WeightMeshSpawnShapeValue.java
@@ -0,0 +1,92 @@
+package com.badlogic.gdx.graphics.g3d.particles.values;
+
+import com.badlogic.gdx.graphics.VertexAttributes;
+import com.badlogic.gdx.graphics.VertexAttributes.Usage;
+import com.badlogic.gdx.math.CumulativeDistribution;
+import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.math.Vector3;
+
+/** Encapsulate the formulas to spawn a particle on a mesh shape dealing
+ * with not uniform area triangles.
+ * @author Inferno */
+public final class WeightMeshSpawnShapeValue extends MeshSpawnShapeValue {
+	
+	private CumulativeDistribution<Triangle> distribution;
+	
+	public WeightMeshSpawnShapeValue(WeightMeshSpawnShapeValue value){
+		super(value);
+		distribution = new CumulativeDistribution<Triangle>();
+		load(value);
+	}
+	
+	public WeightMeshSpawnShapeValue () {
+		super();
+		distribution = new CumulativeDistribution<Triangle>();
+	}
+	
+	@Override
+	public void init () {
+		calculateWeights();
+	}
+
+	/** Calculate the weights of each triangle of the wrapped mesh.
+	 * If the mesh has indices: the function will calculate the weight of those triangles.
+	 * If the mesh has not indices: the function will consider the vertices as a triangle strip.*/
+	public void calculateWeights(){
+		distribution.clear();
+		VertexAttributes attributes = mesh.getVertexAttributes();
+		int indicesCount = mesh.getNumIndices();
+		int vertexCount = mesh.getNumVertices();
+		int vertexSize = (short)(attributes.vertexSize / 4),
+			 positionOffset = (short)(attributes.findByUsage(Usage.Position).offset/4);
+		float[] vertices = new float[vertexCount*vertexSize];
+		mesh.getVertices(vertices);
+		if(indicesCount > 0){
+			short[] indices = new short[indicesCount];
+			mesh.getIndices(indices);
+
+			//Calculate the Area
+			for(int i=0; i < indicesCount; i+=3){
+				int p1Offset = indices[i]*vertexSize + positionOffset,
+					 p2Offset = indices[i+1]*vertexSize + positionOffset,
+					 p3Offset = indices[i+2]*vertexSize + positionOffset;
+				float x1 = vertices[p1Offset], y1 = vertices[p1Offset+1], z1 = vertices[p1Offset+2],
+						x2 = vertices[p2Offset], y2 = vertices[p2Offset+1], z2 = vertices[p2Offset+2],
+						x3 = vertices[p3Offset], y3 = vertices[p3Offset+1], z3 = vertices[p3Offset+2];
+				float area = Math.abs((x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1-y2))/2f);
+				distribution.add(new Triangle(x1, y1, z1,    x2, y2, z2,   x3, y3, z3), area);
+			}
+		}
+		else {
+			//Calculate the Area
+			for(int i=0; i < vertexCount; i+=vertexSize){
+				int p1Offset = i + positionOffset,
+					 p2Offset = p1Offset + vertexSize,
+					 p3Offset = p2Offset + vertexSize;
+				float x1 = vertices[p1Offset], y1 = vertices[p1Offset+1], z1 = vertices[p1Offset+2],
+						x2 = vertices[p2Offset], y2 = vertices[p2Offset+1], z2 = vertices[p2Offset+2],
+						x3 = vertices[p3Offset], y3 = vertices[p3Offset+1], z3 = vertices[p3Offset+2];
+				float area = Math.abs((x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1-y2))/2f);
+				distribution.add(new Triangle(x1, y1, z1,    x2, y2, z2,   x3, y3, z3), area);
+			}
+		}
+
+		//Generate cumulative distribution
+		distribution.generateNormalized();
+	}
+	
+	@Override
+	public void spawnAux (Vector3 vector, float percent) {
+		Triangle t = distribution.value();
+		float a = MathUtils.random(), b = MathUtils.random();
+		vector.set( 	t.x1 + a*(t.x2 - t.x1) + b*(t.x3 - t.x1),
+							t.y1 + a*(t.y2 - t.y1) + b*(t.y3 - t.y1),
+							t.z1 + a*(t.z2 - t.z1) + b*(t.z3 - t.z1));
+	}
+	
+	@Override
+	public SpawnShapeValue copy () {
+		return new WeightMeshSpawnShapeValue(this);
+	}
+
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java b/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java
index c4e9e6c..31a2ad9 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java
@@ -542,18 +542,18 @@ public class ShapeRenderer implements Disposable {
 			renderer.color(col1.r, col1.g, col1.b, col1.a);
 			renderer.vertex(x1, y1, 0);
 		} else {
-			renderer.color(color);
+			renderer.color(col1.r, col1.g, col1.b, col1.a);
 			renderer.vertex(x1, y1, 0);
-			renderer.color(color);
+			renderer.color(col2.r, col2.g, col2.b, col2.a);
 			renderer.vertex(x2, y2, 0);
-			renderer.color(color);
+			renderer.color(col3.r, col3.g, col3.b, col3.a);
 			renderer.vertex(x3, y3, 0);
 
-			renderer.color(color);
+			renderer.color(col3.r, col3.g, col3.b, col3.a);
 			renderer.vertex(x3, y3, 0);
-			renderer.color(color);
+			renderer.color(col4.r, col4.g, col4.b, col4.a);
 			renderer.vertex(x4, y4, 0);
-			renderer.color(color);
+			renderer.color(col1.r, col1.g, col1.b, col1.a);
 			renderer.vertex(x1, y1, 0);
 		}
 
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexArray.java b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexArray.java
index 7e28c9d..c770f05 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexArray.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexArray.java
@@ -114,12 +114,8 @@ public class VertexArray implements VertexData {
 				shader.enableVertexAttribute(location);
 
 				byteBuffer.position(attribute.offset);
-				if (attribute.usage == Usage.ColorPacked)
-					shader.setVertexAttribute(location, attribute.numComponents, GL20.GL_UNSIGNED_BYTE, true, attributes.vertexSize,
-						byteBuffer);
-				else
-					shader.setVertexAttribute(location, attribute.numComponents, GL20.GL_FLOAT, false, attributes.vertexSize,
-						byteBuffer);
+				shader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,
+					byteBuffer);
 			}
 		} else {
 			for (int i = 0; i < numAttributes; i++) {
@@ -129,12 +125,8 @@ public class VertexArray implements VertexData {
 				shader.enableVertexAttribute(location);
 
 				byteBuffer.position(attribute.offset);
-				if (attribute.usage == Usage.ColorPacked)
-					shader.setVertexAttribute(location, attribute.numComponents, GL20.GL_UNSIGNED_BYTE, true, attributes.vertexSize,
-						byteBuffer);
-				else
-					shader.setVertexAttribute(location, attribute.numComponents, GL20.GL_FLOAT, false, attributes.vertexSize,
-						byteBuffer);
+				shader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,
+					byteBuffer);
 			}
 		}
 		isBound = true;
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java
index 6fe22d5..8753db4 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java
@@ -168,13 +168,10 @@ public class VertexBufferObject implements VertexData {
 				if (location < 0) continue;
 				shader.enableVertexAttribute(location);
 
-				if (attribute.usage == Usage.ColorPacked)
-					shader.setVertexAttribute(location, attribute.numComponents, GL20.GL_UNSIGNED_BYTE, true, attributes.vertexSize,
-						attribute.offset);
-				else
-					shader.setVertexAttribute(location, attribute.numComponents, GL20.GL_FLOAT, false, attributes.vertexSize,
+				shader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,
 						attribute.offset);
 			}
+			
 		} else {
 			for (int i = 0; i < numAttributes; i++) {
 				final VertexAttribute attribute = attributes.get(i);
@@ -182,12 +179,8 @@ public class VertexBufferObject implements VertexData {
 				if (location < 0) continue;
 				shader.enableVertexAttribute(location);
 
-				if (attribute.usage == Usage.ColorPacked)
-					shader.setVertexAttribute(location, attribute.numComponents, GL20.GL_UNSIGNED_BYTE, true, attributes.vertexSize,
-						attribute.offset);
-				else
-					shader.setVertexAttribute(location, attribute.numComponents, GL20.GL_FLOAT, false, attributes.vertexSize,
-						attribute.offset);
+				shader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,
+					attribute.offset);
 			}
 		}
 		isBound = true;
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObjectSubData.java b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObjectSubData.java
index 6a9f6c6..be275f2 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObjectSubData.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObjectSubData.java
@@ -177,11 +177,7 @@ public class VertexBufferObjectSubData implements VertexData {
 				if (location < 0) continue;
 				shader.enableVertexAttribute(location);
 
-				if (attribute.usage == Usage.ColorPacked)
-					shader.setVertexAttribute(location, attribute.numComponents, GL20.GL_UNSIGNED_BYTE, true, attributes.vertexSize,
-						attribute.offset);
-				else
-					shader.setVertexAttribute(location, attribute.numComponents, GL20.GL_FLOAT, false, attributes.vertexSize,
+				shader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,
 						attribute.offset);
 			}
 		} else {
@@ -191,11 +187,7 @@ public class VertexBufferObjectSubData implements VertexData {
 				if (location < 0) continue;
 				shader.enableVertexAttribute(location);
 
-				if (attribute.usage == Usage.ColorPacked)
-					shader.setVertexAttribute(location, attribute.numComponents, GL20.GL_UNSIGNED_BYTE, true, attributes.vertexSize,
-						attribute.offset);
-				else
-					shader.setVertexAttribute(location, attribute.numComponents, GL20.GL_FLOAT, false, attributes.vertexSize,
+				shader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,
 						attribute.offset);
 			}
 		}
diff --git a/gdx/src/com/badlogic/gdx/math/Circle.java b/gdx/src/com/badlogic/gdx/math/Circle.java
index 63bd6ff..fa0e007 100644
--- a/gdx/src/com/badlogic/gdx/math/Circle.java
+++ b/gdx/src/com/badlogic/gdx/math/Circle.java
@@ -15,6 +15,8 @@ package com.badlogic.gdx.math;
 
 import java.io.Serializable;
 
+import com.badlogic.gdx.utils.NumberUtils;
+
 /** A convenient 2D circle class.
  * @author mzechner */
 public class Circle implements Serializable {
@@ -56,6 +58,16 @@ public class Circle implements Serializable {
 		this.radius = circle.radius;
 	}
 
+	/** Creates a new {@link Circle} in terms of its center and a point on its edge.
+	 * 
+	 * @param center The center of the new circle
+	 * @param edge Any point on the edge of the given circle */
+	public Circle (Vector2 center, Vector2 edge) {
+		this.x = center.x;
+		this.y = center.y;
+		this.radius = Vector2.len(center.x - edge.x, center.y - edge.y);
+	}
+
 	/** Sets a new location and radius for this circle.
 	 * 
 	 * @param x X coordinate
@@ -81,9 +93,19 @@ public class Circle implements Serializable {
 	 * 
 	 * @param circle The circle to copy the position and radius of. */
 	public void set (Circle circle) {
-		x = circle.x;
-		y = circle.y;
-		radius = circle.radius;
+		this.x = circle.x;
+		this.y = circle.y;
+		this.radius = circle.radius;
+	}
+
+	/** Sets this {@link Circle}'s values in terms of its center and a point on its edge.
+	 * 
+	 * @param center The new center of the circle
+	 * @param edge Any point on the edge of the given circle */
+	public void set (Vector2 center, Vector2 edge) {
+		this.x = center.x;
+		this.y = center.y;
+		this.radius = Vector2.len(center.x - edge.x, center.y - edge.y);
 	}
 
 	/** Sets the x and y-coordinates of circle center from vector
@@ -164,7 +186,37 @@ public class Circle implements Serializable {
 		return distance < radiusSum * radiusSum;
 	}
 
+	/** Returns a {@link String} representation of this {@link Circle} of the form {@code x,y,radius}. */
+	@Override
 	public String toString () {
 		return x + "," + y + "," + radius;
 	}
+
+	/** @return The circumference of this circle (as 2 * {@link MathUtils#PI2}) * {@code radius} */
+	public float circumference () {
+		return this.radius * MathUtils.PI2;
+	}
+
+	/** @return The area of this circle (as {@link MathUtils#PI} * radius * radius). */
+	public float area () {
+		return this.radius * this.radius * MathUtils.PI;
+	}
+
+	@Override
+	public boolean equals (Object o) {
+		if (o == this) return true;
+		if (o == null || o.getClass() != this.getClass()) return false;
+		Circle c = (Circle)o;
+		return this.x == c.x && this.y == c.y && this.radius == c.radius;
+	}
+
+	@Override
+	public int hashCode () {
+		final int prime = 41;
+		int result = 1;
+		result = prime * result + NumberUtils.floatToRawIntBits(radius);
+		result = prime * result + NumberUtils.floatToRawIntBits(x);
+		result = prime * result + NumberUtils.floatToRawIntBits(y);
+		return result;
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/math/Ellipse.java b/gdx/src/com/badlogic/gdx/math/Ellipse.java
index 216800d..c33a10a 100644
--- a/gdx/src/com/badlogic/gdx/math/Ellipse.java
+++ b/gdx/src/com/badlogic/gdx/math/Ellipse.java
@@ -19,6 +19,7 @@ package com.badlogic.gdx.math;
 import java.io.Serializable;
 
 import com.badlogic.gdx.math.Vector2;
+import com.badlogic.gdx.utils.NumberUtils;
 
 /** A convenient 2D ellipse class, based on the circle class
  * @author tonyp7 */
@@ -69,6 +70,23 @@ public class Ellipse implements Serializable {
 		this.height = height;
 	}
 
+	public Ellipse (Vector2 position, Vector2 size) {
+		this.x = position.x;
+		this.y = position.y;
+		this.width = size.x;
+		this.height = size.y;
+	}
+
+	/** Constructs a new {@link Ellipse} from the position and radius of a {@link Circle} (since circles are special cases of
+	 * ellipses).
+	 * @param circle The circle to take the values of */
+	public Ellipse (Circle circle) {
+		this.x = circle.x;
+		this.y = circle.y;
+		this.width = circle.radius;
+		this.height = circle.radius;
+	}
+
 	/** Checks whether or not this ellipse contains the given point.
 	 * 
 	 * @param x X coordinate
@@ -114,6 +132,20 @@ public class Ellipse implements Serializable {
 		height = ellipse.height;
 	}
 
+	public void set (Circle circle) {
+		this.x = circle.x;
+		this.y = circle.y;
+		this.width = circle.radius;
+		this.height = circle.radius;
+	}
+
+	public void set (Vector2 position, Vector2 size) {
+		this.x = position.x;
+		this.y = position.y;
+		this.width = size.x;
+		this.height = size.y;
+	}
+
 	/** Sets the x and y-coordinates of ellipse center from a {@link Vector2}.
 	 * @param position The position vector
 	 * @return this ellipse for chaining */
@@ -145,4 +177,44 @@ public class Ellipse implements Serializable {
 
 		return this;
 	}
+
+	/** @return The area of this {@link Ellipse} as {@link MathUtils#PI} * {@link rx Ellipse#width} * {@link ry Ellipse#height} */
+	public float area () {
+		return MathUtils.PI * (this.width * this.height) / 4;
+	}
+
+	/** Approximates the circumference of this {@link Ellipse}. Oddly enough, the circumference of an ellipse is actually difficult
+	 * to compute exactly.
+	 * @return The Ramanujan approximation to the circumference of an ellipse if one dimension is at least three times longer than
+	 *         the other, else the simpler approximation */
+	public float circumference () {
+		float a = this.width / 2;
+		float b = this.height / 2;
+		if (a * 3 > b || b * 3 > a) {
+			// If one dimension is three times as long as the other...
+			return (float)(MathUtils.PI * ((3 * (a + b)) - Math.sqrt((3 * a + b) * (a + 3 * b))));
+		} else {
+			// We can use the simpler approximation, then
+			return (float)(MathUtils.PI2 * Math.sqrt((a * a + b * b) / 2));
+		}
+	}
+
+	@Override
+	public boolean equals (Object o) {
+		if (o == this) return true;
+		if (o == null || o.getClass() != this.getClass()) return false;
+		Ellipse e = (Ellipse)o;
+		return this.x == e.x && this.y == e.y && this.width == e.width && this.height == e.height;
+	}
+
+	@Override
+	public int hashCode () {
+		final int prime = 53;
+		int result = 1;
+		result = prime * result + NumberUtils.floatToRawIntBits(this.height);
+		result = prime * result + NumberUtils.floatToRawIntBits(this.width);
+		result = prime * result + NumberUtils.floatToRawIntBits(this.x);
+		result = prime * result + NumberUtils.floatToRawIntBits(this.y);
+		return result;
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/math/GridPoint2.java b/gdx/src/com/badlogic/gdx/math/GridPoint2.java
index a78fcf0..d3f50e7 100644
--- a/gdx/src/com/badlogic/gdx/math/GridPoint2.java
+++ b/gdx/src/com/badlogic/gdx/math/GridPoint2.java
@@ -16,6 +16,8 @@
 
 package com.badlogic.gdx.math;
 
+import com.badlogic.gdx.utils.NumberUtils;
+
 /** A point in a 2D grid, with integer x and y coordinates
  * 
  * @author badlogic */
@@ -66,4 +68,21 @@ public class GridPoint2 {
 		this.y = y;
 		return this;
 	}
+
+	@Override
+	public boolean equals (Object o) {
+		if (this == o) return true;
+		if (o == null || o.getClass() != this.getClass()) return false;
+		GridPoint2 g = (GridPoint2)o;
+		return this.x == g.x && this.y == g.y;
+	}
+
+	@Override
+	public int hashCode () {
+		final int prime = 53;
+		int result = 1;
+		result = prime * result + this.x;
+		result = prime * result + this.y;
+		return result;
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/math/GridPoint3.java b/gdx/src/com/badlogic/gdx/math/GridPoint3.java
index 3235bc2..aabdbd9 100644
--- a/gdx/src/com/badlogic/gdx/math/GridPoint3.java
+++ b/gdx/src/com/badlogic/gdx/math/GridPoint3.java
@@ -16,6 +16,8 @@
 
 package com.badlogic.gdx.math;
 
+import com.badlogic.gdx.utils.NumberUtils;
+
 /** A point in a 3D grid, with integer x and y coordinates
  * 
  * @author badlogic */
@@ -73,4 +75,22 @@ public class GridPoint3 {
 		this.z = z;
 		return this;
 	}
+
+	@Override
+	public boolean equals (Object o) {
+		if (this == o) return true;
+		if (o == null || o.getClass() != this.getClass()) return false;
+		GridPoint3 g = (GridPoint3)o;
+		return this.x == g.x && this.y == g.y && this.z == g.z;
+	}
+
+	@Override
+	public int hashCode () {
+		final int prime = 17;
+		int result = 1;
+		result = prime * result + this.x;
+		result = prime * result + this.y;
+		result = prime * result + this.z;
+		return result;
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/math/MathUtils.java b/gdx/src/com/badlogic/gdx/math/MathUtils.java
index 86dc431..a6a6cad 100644
--- a/gdx/src/com/badlogic/gdx/math/MathUtils.java
+++ b/gdx/src/com/badlogic/gdx/math/MathUtils.java
@@ -280,4 +280,15 @@ public final class MathUtils {
 	static public boolean isEqual (float a, float b, float tolerance) {
 		return Math.abs(a - b) <= tolerance;
 	}
+
+	/**@return the logarithm of x with base a */
+	static public float log( float a, float x ){
+		return (float)(Math.log(x) / Math.log(a));
+	}
+
+	/**@return the logarithm of x with base 2*/
+	static public float log2( float x ){
+		return log(2, x);
+	}
+
 }
diff --git a/gdx/src/com/badlogic/gdx/math/Rectangle.java b/gdx/src/com/badlogic/gdx/math/Rectangle.java
index 22e5063..6ca08b0 100644
--- a/gdx/src/com/badlogic/gdx/math/Rectangle.java
+++ b/gdx/src/com/badlogic/gdx/math/Rectangle.java
@@ -15,6 +15,8 @@ package com.badlogic.gdx.math;
 
 import java.io.Serializable;
 
+import com.badlogic.gdx.utils.NumberUtils;
+
 /** Encapsulates a 2D rectangle defined by it's bottom corner point and its extends in x (width) and y (height).
  * @author badlogicgames@gmail.com */
 public class Rectangle implements Serializable {
@@ -222,8 +224,7 @@ public class Rectangle implements Serializable {
 		return this;
 	}
 
-	/** Merges this rectangle with the other rectangle.
-	 * The rectangle should not have negative width or negative height.
+	/** Merges this rectangle with the other rectangle. The rectangle should not have negative width or negative height.
 	 * @param rect the other rectangle
 	 * @return this rectangle for chaining */
 	public Rectangle merge (Rectangle rect) {
@@ -239,8 +240,8 @@ public class Rectangle implements Serializable {
 
 		return this;
 	}
-	/** Merges this rectangle with a point
-	 * The rectangle should not have negative width or negative height.
+
+	/** Merges this rectangle with a point. The rectangle should not have negative width or negative height.
 	 * @param x the x coordinate of the point
 	 * @param y the y coordinate of the point
 	 * @return this rectangle for chaining */
@@ -257,23 +258,23 @@ public class Rectangle implements Serializable {
 
 		return this;
 	}
-	/** Merges this rectangle with a point
-	 * The rectangle should not have negative width or negative height.
+
+	/** Merges this rectangle with a point. The rectangle should not have negative width or negative height.
 	 * @param vec the vector describing the point
 	 * @return this rectangle for chaining */
 	public Rectangle merge (Vector2 vec) {
 		return merge(vec.x, vec.y);
 	}
-	/** Merges this rectangle with a list of points
-	 * The rectangle should not have negative width or negative height.
+
+	/** Merges this rectangle with a list of points. The rectangle should not have negative width or negative height.
 	 * @param vecs the vectors describing the points
 	 * @return this rectangle for chaining */
 	public Rectangle merge (Vector2[] vecs) {
 		float minX = x;
-		float maxX = x+width;
+		float maxX = x + width;
 		float minY = y;
-		float maxY = y+height;
-		for(int i = 0; i < vecs.length; ++i) {
+		float maxY = y + height;
+		for (int i = 0; i < vecs.length; ++i) {
 			Vector2 v = vecs[i];
 			minX = Math.min(minX, v.x);
 			maxX = Math.max(maxX, v.x);
@@ -286,6 +287,7 @@ public class Rectangle implements Serializable {
 		height = maxY - minY;
 		return this;
 	}
+
 	/** Calculates the aspect ratio ( width / height ) of this rectangle
 	 * @return the aspect ratio of this rectangle. Returns Float.NaN if height is 0 to avoid ArithmeticException */
 	public float getAspectRatio () {
@@ -318,7 +320,7 @@ public class Rectangle implements Serializable {
 		return this;
 	}
 
-	/** Fits this rectangle around another rectangle while maintaining aspect ratio This scales and centers the rectangle to the
+	/** Fits this rectangle around another rectangle while maintaining aspect ratio. This scales and centers the rectangle to the
 	 * other rectangle (e.g. Having a camera translate and scale to show a given area)
 	 * @param rect the other rectangle to fit this rectangle around
 	 * @return this rectangle for chaining */
@@ -360,13 +362,21 @@ public class Rectangle implements Serializable {
 		return x + "," + y + "," + width + "," + height;
 	}
 
+	public float area () {
+		return this.width * this.height;
+	}
+
+	public float perimeter () {
+		return 2 * (this.width + this.height);
+	}
+
 	public int hashCode () {
 		final int prime = 31;
 		int result = 1;
-		result = prime * result + Float.floatToIntBits(height);
-		result = prime * result + Float.floatToIntBits(width);
-		result = prime * result + Float.floatToIntBits(x);
-		result = prime * result + Float.floatToIntBits(y);
+		result = prime * result + NumberUtils.floatToRawIntBits(height);
+		result = prime * result + NumberUtils.floatToRawIntBits(width);
+		result = prime * result + NumberUtils.floatToRawIntBits(x);
+		result = prime * result + NumberUtils.floatToRawIntBits(y);
 		return result;
 	}
 
@@ -375,12 +385,11 @@ public class Rectangle implements Serializable {
 		if (obj == null) return false;
 		if (getClass() != obj.getClass()) return false;
 		Rectangle other = (Rectangle)obj;
-		if (Float.floatToIntBits(height) != Float.floatToIntBits(other.height)) return false;
-		if (Float.floatToIntBits(width) != Float.floatToIntBits(other.width)) return false;
-		if (Float.floatToIntBits(x) != Float.floatToIntBits(other.x)) return false;
-		if (Float.floatToIntBits(y) != Float.floatToIntBits(other.y)) return false;
+		if (NumberUtils.floatToRawIntBits(height) != NumberUtils.floatToRawIntBits(other.height)) return false;
+		if (NumberUtils.floatToRawIntBits(width) != NumberUtils.floatToRawIntBits(other.width)) return false;
+		if (NumberUtils.floatToRawIntBits(x) != NumberUtils.floatToRawIntBits(other.x)) return false;
+		if (NumberUtils.floatToRawIntBits(y) != NumberUtils.floatToRawIntBits(other.y)) return false;
 		return true;
 	}
-	
-	
+
 }
diff --git a/gdx/src/com/badlogic/gdx/math/collision/Ray.java b/gdx/src/com/badlogic/gdx/math/collision/Ray.java
index 2e57b0e..673641d 100644
--- a/gdx/src/com/badlogic/gdx/math/collision/Ray.java
+++ b/gdx/src/com/badlogic/gdx/math/collision/Ray.java
@@ -114,4 +114,21 @@ public class Ray implements Serializable {
 		this.direction.set(ray.direction);
 		return this;
 	}
+
+	@Override
+	public boolean equals (Object o) {
+		if (o == this) return true;
+		if (o == null || o.getClass() != this.getClass()) return false;
+		Ray r = (Ray)o;
+		return this.direction.equals(r.direction) && this.origin.equals(r.origin);
+	}
+
+	@Override
+	public int hashCode () {
+		final int prime = 73;
+		int result = 1;
+		result = prime * result + this.direction.hashCode();
+		result = prime * result + this.origin.hashCode();
+		return result;
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/math/collision/Segment.java b/gdx/src/com/badlogic/gdx/math/collision/Segment.java
index 8928e17..7593787 100644
--- a/gdx/src/com/badlogic/gdx/math/collision/Segment.java
+++ b/gdx/src/com/badlogic/gdx/math/collision/Segment.java
@@ -19,6 +19,7 @@ package com.badlogic.gdx.math.collision;
 import java.io.Serializable;
 
 import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.utils.NumberUtils;
 
 /** A Segment is a line in 3-space having a staring and an ending position.
  * 
@@ -52,4 +53,29 @@ public class Segment implements Serializable {
 		this.a.set(aX, aY, aZ);
 		this.b.set(bX, bY, bZ);
 	}
+
+	public float len () {
+		return a.dst(b);
+	}
+
+	public float len2 () {
+		return a.dst2(b);
+	}
+
+	@Override
+	public boolean equals (Object o) {
+		if (o == this) return true;
+		if (o == null || o.getClass() != this.getClass()) return false;
+		Segment s = (Segment)o;
+		return this.a.equals(s.a) && this.b.equals(s.b);
+	}
+
+	@Override
+	public int hashCode () {
+		final int prime = 71;
+		int result = 1;
+		result = prime * result + this.a.hashCode();
+		result = prime * result + this.b.hashCode();
+		return result;
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/math/collision/Sphere.java b/gdx/src/com/badlogic/gdx/math/collision/Sphere.java
index 1a74615..cf531ff 100644
--- a/gdx/src/com/badlogic/gdx/math/collision/Sphere.java
+++ b/gdx/src/com/badlogic/gdx/math/collision/Sphere.java
@@ -18,7 +18,9 @@ package com.badlogic.gdx.math.collision;
 
 import java.io.Serializable;
 
+import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.utils.NumberUtils;
 
 /** Encapsulates a 3D sphere with a center and a radius
  * 
@@ -30,6 +32,8 @@ public class Sphere implements Serializable {
 	/** the center of the sphere **/
 	public final Vector3 center;
 
+	private static final float PI_4_3 = MathUtils.PI * 4f / 3f;
+
 	/** Constructs a sphere with the given center and radius
 	 * @param center The center
 	 * @param radius The radius */
@@ -43,4 +47,29 @@ public class Sphere implements Serializable {
 	public boolean overlaps (Sphere sphere) {
 		return center.dst2(sphere.center) < (radius + sphere.radius) * (radius + sphere.radius);
 	}
+
+	@Override
+	public int hashCode () {
+		final int prime = 71;
+		int result = 1;
+		result = prime * result + this.center.hashCode();
+		result = prime * result + NumberUtils.floatToRawIntBits(this.radius);
+		return result;
+	}
+
+	@Override
+	public boolean equals (Object o) {
+		if (this == o) return true;
+		if (o == null || o.getClass() != this.getClass()) return false;
+		Sphere s = (Sphere)o;
+		return this.radius == s.radius && this.center.equals(s.center);
+	}
+
+	public float volume () {
+		return PI_4_3 * this.radius * this.radius * this.radius;
+	}
+
+	public float surfaceArea () {
+		return 4 * MathUtils.PI * this.radius * this.radius;
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/Actor.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/Actor.java
index 7a5966d..b657d55 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/Actor.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/Actor.java
@@ -24,8 +24,6 @@ import com.badlogic.gdx.math.Vector2;
 import com.badlogic.gdx.scenes.scene2d.InputEvent.Type;
 import com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener;
 import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
-import com.badlogic.gdx.scenes.scene2d.utils.Scene2DDebugRenderer;
-import com.badlogic.gdx.scenes.scene2d.utils.Scene2DDebugRenderer.DebugRect;
 import com.badlogic.gdx.scenes.scene2d.utils.ScissorStack;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.DelayedRemovalArray;
@@ -67,9 +65,6 @@ public class Actor {
 	final Color color = new Color(1, 1, 1, 1);
 	private Object userObject;
 
-	private boolean debuggingEnabled = true;
-	public static final Color debugColor = new Color(0, 1, 0, 1);
-
 	/** Draws the actor. The Batch is configured to draw in the parent's coordinate system.
 	 * {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)
 	 * This draw method} is convenient to draw a rotated and scaled TextureRegion. {@link Batch#begin()} has already been called on
@@ -345,6 +340,7 @@ public class Actor {
 		this.visible = visible;
 	}
 
+	/** Retrieves application specific object for convenience. */
 	public Object getUserObject () {
 		return userObject;
 	}
@@ -354,6 +350,7 @@ public class Actor {
 		this.userObject = userObject;
 	}
 
+	/** Get the X position of the actor (left edge of actor) */
 	public float getX () {
 		return x;
 	}
@@ -362,6 +359,7 @@ public class Actor {
 		this.x = x;
 	}
 
+	/** Get the Y position of the actor (bottom edge of actor) */
 	public float getY () {
 		return y;
 	}
@@ -370,12 +368,27 @@ public class Actor {
 		this.y = y;
 	}
 
-	/** Sets the x and y. */
+	/** Set position of Actor to x, y (using bottom left corner of Actor) */
 	public void setPosition (float x, float y) {
 		this.x = x;
 		this.y = y;
 	}
 
+	/** Set position of Actor centered on x, y */
+	public void setCenterPosition(float x, float y) {
+		this.x = x - width / 2;
+		this.y = y - height / 2;
+	}
+
+	public float getCenterX() {
+		return this.x + width / 2;
+	}
+
+	public float getCenterY() {
+		return this.y + height / 2;
+	}
+
+	/** Add x and y to current position */
 	public void moveBy (float x, float y) {
 		this.x += x;
 		this.y += y;
@@ -465,7 +478,7 @@ public class Actor {
 		this.originY = originY;
 	}
 
-	/** Sets the originx and originy. */
+	/** Sets the origin X and origin Y. */
 	public void setOrigin (float originX, float originY) {
 		this.originX = originX;
 		this.originY = originY;
@@ -487,13 +500,13 @@ public class Actor {
 		this.scaleY = scaleY;
 	}
 
-	/** Sets the scalex and scaley. */
+	/** Sets the scale X and scale X. */
 	public void setScale (float scaleXY) {
 		this.scaleX = scaleXY;
 		this.scaleY = scaleXY;
 	}
 
-	/** Sets the scalex and scaley. */
+	/** Sets the scale X and scale Y. */
 	public void setScale (float scaleX, float scaleY) {
 		this.scaleX = scaleX;
 		this.scaleY = scaleY;
@@ -537,6 +550,8 @@ public class Actor {
 		return color;
 	}
 
+	/** Retrieve custom actor name set with {@link Actor#setName(String)},
+	 * used for easier identification */
 	public String getName () {
 		return name;
 	}
@@ -547,26 +562,6 @@ public class Actor {
 		this.name = name;
 	}
 
-	/** The {@link Scene2DDebugRenderer} will ask every actor of a stage for their debugging rectangles. To fill the given array you
-	 * can obtain fresh {@link DebugRect}s via the {@link Scene2DDebugRenderer#debugRectPool}. To avoid the garbage collection you
-	 * should make sure to free them later, but it's not a strict requirement. */
-	public void getDebugRects (Array<DebugRect> debugRects) {
-		DebugRect debugRect = Scene2DDebugRenderer.debugRectPool.obtain();
-		debugRect.bottomLeft.set(0, 0);
-		debugRect.topRight.set(width, height);
-		debugRect.color.set(Actor.debugColor);
-		debugRects.add(debugRect);
-	}
-
-	/** Used only in combination with a {@link Scene2DDebugRenderer}. */
-	public void setDebuggingEnabled (boolean enabled) {
-		debuggingEnabled = enabled;
-	}
-
-	public boolean isDebuggingEnabled () {
-		return debuggingEnabled;
-	}
-
 	/** Changes the z-order for this actor so it is in front of all siblings. */
 	public void toFront () {
 		setZIndex(Integer.MAX_VALUE);
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/Group.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/Group.java
index 1b8b493..bda642c 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/Group.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/Group.java
@@ -22,7 +22,6 @@ import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.math.Rectangle;
 import com.badlogic.gdx.math.Vector2;
 import com.badlogic.gdx.scenes.scene2d.utils.Cullable;
-import com.badlogic.gdx.scenes.scene2d.utils.Scene2DDebugRenderer;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.SnapshotArray;
 
@@ -290,12 +289,12 @@ public class Group extends Actor implements Cullable {
 	public <T extends Actor> T findActor (String name) {
 		Array<Actor> children = this.children;
 		for (int i = 0, n = children.size; i < n; i++)
-			if (name.equals(children.get(i).getName())) return (T)children.get(i);
+			if (name.equals(children.get(i).getName())) return (T) children.get(i);
 		for (int i = 0, n = children.size; i < n; i++) {
 			Actor child = children.get(i);
 			if (child instanceof Group) {
 				Actor actor = ((Group)child).findActor(name);
-				if (actor != null) return (T)actor;
+				if (actor != null) return (T) actor;
 			}
 		}
 		return null;
@@ -365,21 +364,6 @@ public class Group extends Actor implements Cullable {
 		print("");
 	}
 
-	/** Used only in combination with a {@link Scene2DDebugRenderer}.
-	 * @param recursively If {@code true} it will also recursively disable all children of this group. */
-	public void setDebuggingEnabled (boolean enabled, boolean recursively) {
-		setDebuggingEnabled(enabled);
-		if (recursively) {
-			for (Actor child : children) {
-				if (child instanceof Group) {
-					((Group)child).setDebuggingEnabled(enabled, recursively);
-				} else {
-					child.setDebuggingEnabled(enabled);
-				}
-			}
-		}
-	}
-
 	private void print (String indent) {
 		Actor[] actors = children.begin();
 		for (int i = 0, n = children.size; i < n; i++) {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Container.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Container.java
index eb02c1b..40146f3 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Container.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Container.java
@@ -38,7 +38,6 @@ public class Container<T extends Actor> extends WidgetGroup {
 
 	public void draw (Batch batch, float parentAlpha) {
 		validate();
-		if (actor == null) return;
 		if (isTransform()) {
 			applyTransform(batch, computeTransform());
 			drawBackground(batch, parentAlpha, 0, 0);
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SelectBox.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SelectBox.java
index 41467f1..146982a 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SelectBox.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SelectBox.java
@@ -112,28 +112,26 @@ public class SelectBox<T> extends Widget implements Disableable {
 		return style;
 	}
 
+	/** Set the backing Array that makes up the choices available in the SelectBox */
 	public void setItems (T... newItems) {
 		if (newItems == null) throw new IllegalArgumentException("newItems cannot be null.");
-
 		items.clear();
 		items.addAll(newItems);
-
 		scroll.list.setItems(items);
-
 		invalidateHierarchy();
 	}
 
+	/** Set the backing Array that makes up the choices available in the SelectBox */
 	public void setItems (Array<T> newItems) {
 		if (newItems == null) throw new IllegalArgumentException("newItems cannot be null.");
-
 		items.clear();
 		items.addAll(newItems);
-
 		scroll.list.setItems(items);
-
 		invalidateHierarchy();
 	}
 
+	/** Retrieve the backing Array that makes up the chocies available in the SelectBox
+	 * @see SelectBox#setItems(Array)  */
 	public Array<T> getItems () {
 		return items;
 	}
@@ -201,16 +199,19 @@ public class SelectBox<T> extends Widget implements Disableable {
 		}
 	}
 
+	/** Get the set of selected items, useful when multiple items are selected
+	 * @return a Selection object containing the selected elements
+	 * */
 	public Selection<T> getSelection () {
 		return selection;
 	}
 
-	/** Returns the first selected item, or null. */
+	/** Returns the first selected item, or null. For multiple selections use {@link SelectBox#getSelection()}*/
 	public T getSelected () {
 		return selection.first();
 	}
 
-	/** Sets the selection to only the item if found, else selects the first item. */
+	/** Sets the selection to only the passed item, if it is a possible choice, else selects the first item. */
 	public void setSelected (T item) {
 		if (items.contains(item, false))
 			selection.set(item);
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Table.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Table.java
index da18138..792d449 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Table.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Table.java
@@ -16,17 +16,23 @@
 
 package com.badlogic.gdx.scenes.scene2d.ui;
 
+import com.badlogic.gdx.Application;
+import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.Color;
+import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.g2d.Batch;
+import com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer;
+import com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20;
+import com.badlogic.gdx.math.Rectangle;
 import com.badlogic.gdx.scenes.scene2d.Actor;
+import com.badlogic.gdx.scenes.scene2d.Group;
+import com.badlogic.gdx.scenes.scene2d.Stage;
 import com.badlogic.gdx.scenes.scene2d.Touchable;
 import com.badlogic.gdx.scenes.scene2d.ui.Label.LabelStyle;
 import com.badlogic.gdx.scenes.scene2d.ui.Value.Fixed;
 import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
 import com.badlogic.gdx.scenes.scene2d.utils.Layout;
-import com.badlogic.gdx.scenes.scene2d.utils.Scene2DDebugRenderer;
-import com.badlogic.gdx.scenes.scene2d.utils.Scene2DDebugRenderer.DebugRect;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.Pool;
 
@@ -36,12 +42,7 @@ import com.badlogic.gdx.utils.Pool;
  * The preferred and minimum sizes are that of the children when laid out in columns and rows.
  * @author Nathan Sweet */
 public class Table extends WidgetGroup {
-
-	public static final Color tableColor = new Color(0, 0, 1, 1);
-
-	public static final Color cellColor = new Color(1, 0, 0, 1);
-
-	static Pool<Cell> cellPool = new Pool() {
+	static Pool<Cell> cellPool = new Pool<Cell>() {
 		protected Cell newObject () {
 			return new Cell();
 		}
@@ -67,7 +68,7 @@ public class Table extends WidgetGroup {
 	int align = Align.center;
 
 	Debug debug = Debug.none;
-	Array<DebugRect> debugRects = new Array<DebugRect>();
+	Array<DebugRect> debugRects;
 
 	private Drawable background;
 	private boolean clip;
@@ -202,8 +203,8 @@ public class Table extends WidgetGroup {
 	}
 
 	/** Adds a new cell to the table with the specified actor. */
-	public Cell add (Actor actor) {
-		Cell cell = obtainCell();
+	public <T extends Actor> Cell<T> add (T actor) {
+		Cell<T> cell = obtainCell();
 		cell.actor = actor;
 
 		Array<Cell> cells = this.cells;
@@ -280,7 +281,7 @@ public class Table extends WidgetGroup {
 
 	/** Adds a cell without an actor. */
 	public Cell add () {
-		return add((Actor)null);
+		return add((Actor) null);
 	}
 
 	/** Adds a new cell to the table with the specified actors in a {@link Stack}.
@@ -328,10 +329,7 @@ public class Table extends WidgetGroup {
 		padBottom = Value.zero;
 		padRight = Value.zero;
 		align = Align.center;
-		if (debug != Debug.none) {
-			Scene2DDebugRenderer.debugRectPool.freeAll(debugRects);
-			debugRects.clear();
-		}
+		if (debug != Debug.none) debugRects.clear();
 		debug = Debug.none;
 		cellDefaults.defaults();
 		for (int i = 0, n = columnDefaults.size; i < n; i++) {
@@ -591,10 +589,7 @@ public class Table extends WidgetGroup {
 	public Table debug (Debug debug) {
 		this.debug = debug;
 		if (debug == Debug.none) {
-			if (debugRects != null) {
-				Scene2DDebugRenderer.debugRectPool.freeAll(debugRects);
-				debugRects.clear();
-			}
+			if (debugRects != null) debugRects.clear();
 		} else
 			invalidate();
 		return this;
@@ -1086,22 +1081,19 @@ public class Table extends WidgetGroup {
 
 		// Store debug rectangles.
 		if (debug == Debug.none) return;
-		if (debugRects != null) {
-			Scene2DDebugRenderer.debugRectPool.freeAll(debugRects);
-			debugRects.clear();
-		}
+		if (debugRects != null) debugRects.clear();
 		currentX = x;
 		currentY = y;
 		if (debug == Debug.table || debug == Debug.all) {
-			addDebugRect(layoutX, layoutY, layoutWidth, layoutHeight, tableColor);
-			addDebugRect(x, y, tableWidth - hpadding, tableHeight - vpadding, tableColor);
+			TableDebug.addRectangle(this, Debug.table, layoutX, layoutY, layoutWidth, layoutHeight);
+			TableDebug.addRectangle(this, Debug.table, x, y, tableWidth - hpadding, tableHeight - vpadding);
 		}
 		for (int i = 0; i < cellCount; i++) {
 			Cell c = cells.get(i);
 
 			// Actor bounds.
 			if (debug == Debug.actor || debug == Debug.all)
-				addDebugRect(c.actorX, c.actorY, c.actorWidth, c.actorHeight, Actor.debugColor);
+				TableDebug.addRectangle(this, Debug.actor, c.actorX, c.actorY, c.actorWidth, c.actorHeight);
 
 			// Cell bounds.
 			float spannedCellWidth = 0;
@@ -1110,8 +1102,8 @@ public class Table extends WidgetGroup {
 			spannedCellWidth -= c.computedPadLeft + c.computedPadRight;
 			currentX += c.computedPadLeft;
 			if (debug == Debug.cell || debug == Debug.all) {
-				addDebugRect(currentX, currentY + c.computedPadTop, spannedCellWidth, rowHeight[c.row] - c.computedPadTop
-					- c.computedPadBottom, cellColor);
+				TableDebug.addRectangle(this, Debug.cell, currentX, currentY + c.computedPadTop, spannedCellWidth, rowHeight[c.row]
+					- c.computedPadTop - c.computedPadBottom);
 			}
 
 			if (c.endRow) {
@@ -1122,18 +1114,11 @@ public class Table extends WidgetGroup {
 		}
 	}
 
-	@Override
-	public void getDebugRects (Array<DebugRect> debugRects) {
-		debugRects.addAll(this.debugRects);
-	}
-
-	private void addDebugRect (float x, float y, float width, float height, Color color) {
-		DebugRect debugRect = Scene2DDebugRenderer.debugRectPool.obtain();
-		float yCorrected = getHeight() - y - height;
-		debugRect.bottomLeft.set(x, yCorrected);
-		debugRect.topRight.set(x + width, yCorrected + height);
-		debugRect.color.set(color);
-		debugRects.add(debugRect);
+	/** Draws the debug lines for all tables in the stage. If this method is not called each frame, no debug lines will be drawn. If
+	 * debug is never turned on for any table in the application, calling this method will have no effect. If a table has ever had
+	 * debug set, calling this method causes an expensive traversal of all actors in the stage. */
+	static public void drawDebug (Stage stage) {
+		if (TableDebug.draw) TableDebug.draw(stage);
 	}
 
 	/** @author Nathan Sweet */
@@ -1141,4 +1126,93 @@ public class Table extends WidgetGroup {
 		none, all, table, cell, actor
 	}
 
+	/** @author Nathan Sweet */
+	static class DebugRect extends Rectangle {
+		final Debug type;
+
+		public DebugRect (Debug type, float x, float y, float width, float height) {
+			super(x, y, width, height);
+			this.type = type;
+		}
+	}
+
+	/** @author Nathan Sweet */
+	static class TableDebug {
+		static boolean draw;
+
+		static private Application app;
+		static private ImmediateModeRenderer debugRenderer;
+
+		static public void addRectangle (Table table, Debug type, float x, float y, float w, float h) {
+			draw = true;
+			if (table.debugRects == null) table.debugRects = new Array();
+			table.debugRects.add(new DebugRect(type, x, table.getHeight() - y, w, h));
+		}
+
+		static void draw (Stage stage) {
+			if (app != Gdx.app) debugRenderer = new ImmediateModeRenderer20(128, false, true, 0);
+
+			debugRenderer.begin(stage.getBatch().getProjectionMatrix(), GL20.GL_LINES);
+			draw(stage.getActors());
+			debugRenderer.end();
+		}
+
+		static void draw (Array<Actor> actors) {
+			for (int i = 0, n = actors.size; i < n; i++) {
+				Actor actor = actors.get(i);
+				if (!actor.isVisible()) continue;
+				if (actor instanceof Table) draw((Table)actor);
+				if (actor instanceof Group) draw(((Group)actor).getChildren());
+			}
+		}
+
+		static public void draw (Table table) {
+			if (table.debug == Debug.none) return;
+			Array<DebugRect> debugRects = table.debugRects;
+			if (debugRects == null) return;
+
+			float x = 0, y = 0;
+			Actor parent = table;
+			while (parent != null) {
+				if (parent instanceof Group) {
+					x += parent.getX();
+					y += parent.getY();
+				}
+				parent = parent.getParent();
+			}
+
+			for (int i = 0, n = debugRects.size; i < n; i++) {
+				DebugRect rect = debugRects.get(i);
+				float x1 = x + rect.x;
+				float y1 = y + rect.y - rect.height;
+				float x2 = x1 + rect.width;
+				float y2 = y1 + rect.height;
+				float r = rect.type == Debug.cell ? 1 : 0;
+				float g = rect.type == Debug.actor ? 1 : 0;
+				float b = rect.type == Debug.table ? 1 : 0;
+
+				debugRenderer.color(r, g, b, 1);
+				debugRenderer.vertex(x1, y1, 0);
+				debugRenderer.color(r, g, b, 1);
+				debugRenderer.vertex(x1, y2, 0);
+
+				debugRenderer.color(r, g, b, 1);
+				debugRenderer.vertex(x1, y2, 0);
+				debugRenderer.color(r, g, b, 1);
+				debugRenderer.vertex(x2, y2, 0);
+
+				debugRenderer.color(r, g, b, 1);
+				debugRenderer.vertex(x2, y2, 0);
+				debugRenderer.color(r, g, b, 1);
+				debugRenderer.vertex(x2, y1, 0);
+
+				debugRenderer.color(r, g, b, 1);
+				debugRenderer.vertex(x2, y1, 0);
+				debugRenderer.color(r, g, b, 1);
+				debugRenderer.vertex(x1, y1, 0);
+
+				if (debugRenderer.getNumVertices() == 128) debugRenderer.flush();
+			}
+		}
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/Scene2DDebugRenderer.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/Scene2DDebugRenderer.java
deleted file mode 100644
index 66214ef..0000000
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/Scene2DDebugRenderer.java
+++ /dev/null
@@ -1,143 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.scenes.scene2d.utils;
-
-import com.badlogic.gdx.graphics.Color;
-import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
-import com.badlogic.gdx.graphics.glutils.ShapeRenderer.ShapeType;
-import com.badlogic.gdx.math.Vector2;
-import com.badlogic.gdx.scenes.scene2d.Actor;
-import com.badlogic.gdx.scenes.scene2d.Group;
-import com.badlogic.gdx.scenes.scene2d.Stage;
-import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.Pool;
-import com.badlogic.gdx.utils.Pool.Poolable;
-import com.badlogic.gdx.utils.ReflectionPool;
-
-/** This debugging utility takes a {@link Stage} and renders all {@link Actor}s bounding boxes via a {@link ShapeRenderer}. The
- * bounding boxes are not axis-aligned but rotated and scaled just like the actor. All you need to do is calling the
- * {@link #render()} method each frame.
- * 
- * @author Daniel Holderbaum */
-public class Scene2DDebugRenderer {
-
-	public static class DebugRect implements Poolable {
-		public Vector2 bottomLeft;
-		public Vector2 topRight;
-		public Color color;
-
-		public DebugRect () {
-			bottomLeft = new Vector2();
-			topRight = new Vector2();
-			color = new Color(1, 1, 1, 1);
-		}
-
-		@Override
-		public void reset () {
-			bottomLeft.setZero();
-			topRight.setZero();
-			color.set(1, 1, 1, 1);
-		}
-	}
-
-	public static Pool<DebugRect> debugRectPool = new ReflectionPool(DebugRect.class);
-
-	private Array<DebugRect> debugRects = new Array<DebugRect>();
-
-	/** Set to {@code true} if you want to render the actors that are not visible ({@code visible=false} of the actor or any parent)
-	 * as well. */
-	public boolean renderInvisibleActors = false;
-
-	private Stage stage;
-
-	private ShapeRenderer shapeRenderer;
-
-	public Scene2DDebugRenderer (Stage stage) {
-		this.stage = stage;
-		this.shapeRenderer = new ShapeRenderer();
-	}
-
-	/** Renders the bounding boxes of all actors of the stage. */
-	public void render () {
-		shapeRenderer.setProjectionMatrix(stage.getCamera().projection);
-		shapeRenderer.setTransformMatrix(stage.getCamera().view);
-		shapeRenderer.begin(ShapeType.Line);
-		for (Actor actor : stage.getActors()) {
-			renderRecursive(actor);
-		}
-		shapeRenderer.end();
-	}
-
-	private Vector2 topLeft = new Vector2();
-	private Vector2 topRight = new Vector2();
-	private Vector2 bottomRight = new Vector2();
-	private Vector2 bottomLeft = new Vector2();
-
-	private void renderRecursive (Actor actor) {
-		if (actor.isDebuggingEnabled() && (renderInvisibleActors || isActorVisible(actor))) {
-
-			actor.getDebugRects(debugRects);
-			for (DebugRect debugRect : debugRects) {
-				topLeft.set(debugRect.bottomLeft.x, debugRect.topRight.y);
-				topRight.set(debugRect.topRight.x, debugRect.topRight.y);
-				bottomRight.set(debugRect.topRight.x, debugRect.bottomLeft.y);
-				bottomLeft.set(debugRect.bottomLeft.x, debugRect.bottomLeft.y);
-
-				renderBoundingBox(actor, topLeft, topRight, bottomRight, bottomLeft, debugRect.color);
-			}
-			debugRects.clear();
-
-			if (actor instanceof Group) {
-				Group group = (Group)actor;
-				for (Actor child : group.getChildren()) {
-					renderRecursive(child);
-				}
-			}
-		}
-
-	}
-
-	private void renderBoundingBox (Actor actor, Vector2 topLeft, Vector2 topRight, Vector2 bottomRight, Vector2 bottomLeft,
-		Color color) {
-		// transform to stage coordinates using offsets, scales,
-		// rotations etc of the whole ancestor hierarchy until the root
-		actor.localToStageCoordinates(topLeft);
-		actor.localToStageCoordinates(topRight);
-		actor.localToStageCoordinates(bottomRight);
-		actor.localToStageCoordinates(bottomLeft);
-
-		shapeRenderer.setColor(color);
-		shapeRenderer.line(topLeft, topRight);
-		shapeRenderer.line(topRight, bottomRight);
-		shapeRenderer.line(bottomRight, bottomLeft);
-		shapeRenderer.line(bottomLeft, topLeft);
-	}
-
-	/** Returns {@code true} in case the given actor and all of its ancestors are visible. {@code False} otherwise. */
-	private boolean isActorVisible (Actor actor) {
-		Actor currentActor = actor;
-		while (currentActor != null) {
-			if (currentActor.isVisible() == false) {
-				return false;
-			} else {
-				currentActor = currentActor.getParent();
-			}
-		}
-
-		return true;
-	}
-}
diff --git a/pom.xml b/pom.xml
index 13d8212..9632405 100644
--- a/pom.xml
+++ b/pom.xml
@@ -10,7 +10,7 @@
   <groupId>com.badlogicgames.gdx</groupId>
   <artifactId>gdx-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.1.1-SNAPSHOT</version>
+  <version>1.2.1-SNAPSHOT</version>
 
   <name>libGDX Parent</name>
   <description>Android/Desktop/iOS/HTML5 game development framework.</description>
@@ -46,7 +46,7 @@
     <gwt.version>2.6.0</gwt.version>
     <lwjgl.version>2.9.1</lwjgl.version>
     <jglfw.version>1.1</jglfw.version>
-    <robovm.version>0.0.12</robovm.version>
+    <robovm.version>0.0.13</robovm.version>
   </properties>
 
   <modules>
diff --git a/tests/gdx-tests-android/assets/data/g3d/monkey.g3db b/tests/gdx-tests-android/assets/data/g3d/monkey.g3db
new file mode 100644
index 0000000..ff7b52f
Binary files /dev/null and b/tests/gdx-tests-android/assets/data/g3d/monkey.g3db differ
diff --git a/tests/gdx-tests-android/assets/data/pre_particle.png b/tests/gdx-tests-android/assets/data/pre_particle.png
new file mode 100644
index 0000000..3ce4d1a
Binary files /dev/null and b/tests/gdx-tests-android/assets/data/pre_particle.png differ
diff --git a/tests/gdx-tests-iosrobovm/src/com/badlogic/gdx/tests/IOSRobovmTests.java b/tests/gdx-tests-iosrobovm/src/com/badlogic/gdx/tests/IOSRobovmTests.java
index 6a9d573..a3e53e0 100644
--- a/tests/gdx-tests-iosrobovm/src/com/badlogic/gdx/tests/IOSRobovmTests.java
+++ b/tests/gdx-tests-iosrobovm/src/com/badlogic/gdx/tests/IOSRobovmTests.java
@@ -21,6 +21,7 @@ import org.robovm.apple.uikit.UIApplication;
 
 import com.badlogic.gdx.backends.iosrobovm.IOSApplication;
 import com.badlogic.gdx.backends.iosrobovm.IOSApplicationConfiguration;
+import com.badlogic.gdx.tests.g3d.Benchmark3DTest;
 
 public class IOSRobovmTests extends IOSApplication.Delegate {
 	
@@ -28,7 +29,7 @@ public class IOSRobovmTests extends IOSApplication.Delegate {
 	protected IOSApplication createApplication() {
 		IOSApplicationConfiguration config = new IOSApplicationConfiguration();
 		config.useAccelerometer = false;
-		return new IOSApplication(new InputTest(), config);
+		return new IOSApplication(new Benchmark3DTest(), config);
 	}
 
 	public static void main(String[] argv) {
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/ContainerTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/ContainerTest.java
index ac55466..09f09c0 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/ContainerTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/ContainerTest.java
@@ -10,20 +10,17 @@ import com.badlogic.gdx.scenes.scene2d.ui.Container;
 import com.badlogic.gdx.scenes.scene2d.ui.Label;
 import com.badlogic.gdx.scenes.scene2d.ui.Skin;
 import com.badlogic.gdx.scenes.scene2d.ui.Table;
-import com.badlogic.gdx.scenes.scene2d.utils.Scene2DDebugRenderer;
 import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
 public class ContainerTest extends GdxTest {
 	Skin skin;
 	Stage stage;
-	Scene2DDebugRenderer debugRenderer;
 
 	@Override
 	public void create () {
 		skin = new Skin(Gdx.files.internal("data/uiskin.json"));
 		stage = new Stage();
-		debugRenderer = new Scene2DDebugRenderer(stage);
 		Gdx.input.setInputProcessor(stage);
 
 		TextureRegionDrawable logo = new TextureRegionDrawable(new TextureRegion(new Texture(
@@ -84,7 +81,7 @@ public class ContainerTest extends GdxTest {
 		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
 		stage.act();
 		stage.draw();
-		debugRenderer.render();
+		Table.drawDebug(stage);
 	}
 
 	@Override
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/DragAndDropTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/DragAndDropTest.java
index a4951eb..cb2ae5e 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/DragAndDropTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/DragAndDropTest.java
@@ -109,6 +109,7 @@ public class DragAndDropTest extends GdxTest {
 		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
 		stage.act(Gdx.graphics.getDeltaTime());
 		stage.draw();
+		Table.drawDebug(stage);
 	}
 
 	public void resize (int width, int height) {
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/ImageTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/ImageTest.java
index cf6ceb8..0cb6499 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/ImageTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/ImageTest.java
@@ -24,7 +24,6 @@ import com.badlogic.gdx.scenes.scene2d.Stage;
 import com.badlogic.gdx.scenes.scene2d.ui.Image;
 import com.badlogic.gdx.scenes.scene2d.ui.Skin;
 import com.badlogic.gdx.scenes.scene2d.ui.Table;
-import com.badlogic.gdx.scenes.scene2d.utils.Scene2DDebugRenderer;
 import com.badlogic.gdx.tests.utils.GdxTest;
 import com.badlogic.gdx.utils.Scaling;
 
@@ -33,24 +32,21 @@ public class ImageTest extends GdxTest {
 	Stage ui;
 	Table root;
 	TextureRegion image2;
-	Scene2DDebugRenderer debugRenderer;
 
 	@Override
 	public void create () {
 		skin = new Skin(Gdx.files.internal("data/uiskin.json"));
 		image2 = new TextureRegion(new Texture(Gdx.files.internal("data/badlogic.jpg")));
 		ui = new Stage();
-		debugRenderer = new Scene2DDebugRenderer(ui);
 		Gdx.input.setInputProcessor(ui);
 
 		root = new Table();
-		root.setSize(Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
 		ui.addActor(root);
 		root.debug();
 
 		Image image = new Image(image2);
 		image.setScaling(Scaling.fill);
-		root.add(image).width(image2.getRegionWidth()).height(image2.getRegionHeight());
+		root.add(image).width(160).height(100);
 	}
 
 	@Override
@@ -66,11 +62,12 @@ public class ImageTest extends GdxTest {
 		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
 		ui.act(Math.min(Gdx.graphics.getDeltaTime(), 1 / 30f));
 		ui.draw();
-		debugRenderer.render();
+		Table.drawDebug(ui);
 	}
 
 	@Override
 	public void resize (int width, int height) {
 		ui.getViewport().update(width, height, true);
+		root.setSize(width, height);
 	}
 }
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/LabelScaleTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/LabelScaleTest.java
index a08cb4f..bafb24d 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/LabelScaleTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/LabelScaleTest.java
@@ -24,7 +24,6 @@ import com.badlogic.gdx.scenes.scene2d.Stage;
 import com.badlogic.gdx.scenes.scene2d.ui.Label;
 import com.badlogic.gdx.scenes.scene2d.ui.Skin;
 import com.badlogic.gdx.scenes.scene2d.ui.Table;
-import com.badlogic.gdx.scenes.scene2d.utils.Scene2DDebugRenderer;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
 public class LabelScaleTest extends GdxTest {
@@ -32,14 +31,12 @@ public class LabelScaleTest extends GdxTest {
 	Stage stage;
 	SpriteBatch batch;
 	Actor root;
-	Scene2DDebugRenderer debugRenderer;
 
 	@Override
 	public void create () {
 		batch = new SpriteBatch();
 		skin = new Skin(Gdx.files.internal("data/uiskin.json"));
 		stage = new Stage();
-		debugRenderer = new Scene2DDebugRenderer(stage);
 		Gdx.input.setInputProcessor(stage);
 
 		Table table = new Table();
@@ -73,7 +70,7 @@ public class LabelScaleTest extends GdxTest {
 
 		stage.act(Math.min(Gdx.graphics.getDeltaTime(), 1 / 30f));
 		stage.draw();
-		debugRenderer.render();
+		Table.drawDebug(stage);
 	}
 
 	@Override
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/LabelTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/LabelTest.java
index 98b6a1f..834cf80 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/LabelTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/LabelTest.java
@@ -30,7 +30,6 @@ import com.badlogic.gdx.scenes.scene2d.ui.Label;
 import com.badlogic.gdx.scenes.scene2d.ui.Skin;
 import com.badlogic.gdx.scenes.scene2d.ui.Table;
 import com.badlogic.gdx.scenes.scene2d.utils.Align;
-import com.badlogic.gdx.scenes.scene2d.utils.Scene2DDebugRenderer;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
 public class LabelTest extends GdxTest {
@@ -39,7 +38,6 @@ public class LabelTest extends GdxTest {
 	SpriteBatch batch;
 	Actor root;
 	ShapeRenderer renderer;
-	Scene2DDebugRenderer debugRenderer;
 
 	@Override
 	public void create () {
@@ -49,7 +47,6 @@ public class LabelTest extends GdxTest {
 		skin.getAtlas().getTextures().iterator().next().setFilter(TextureFilter.Nearest, TextureFilter.Nearest);
 		skin.getFont("default-font").setMarkupEnabled(true);
 		stage = new Stage();
-		debugRenderer = new Scene2DDebugRenderer(stage);
 		Gdx.input.setInputProcessor(stage);
 
 		Table table = new Table();
@@ -92,7 +89,7 @@ public class LabelTest extends GdxTest {
 
 		stage.act(Math.min(Gdx.graphics.getDeltaTime(), 1 / 30f));
 		stage.draw();
-		debugRenderer.render();
+		Table.drawDebug(stage);
 
 		float x = 40, y = 40;
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/ProjectiveTextureTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/ProjectiveTextureTest.java
index 5ba9d09..287206d 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/ProjectiveTextureTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/ProjectiveTextureTest.java
@@ -102,7 +102,7 @@ public class ProjectiveTextureTest extends GdxTest {
 	}
 
 	public void setupUI () {
-		ui = new Stage();
+		ui = new Stage();;
 		skin = new Skin(Gdx.files.internal("data/uiskin.json"));
 		TextButton reload = new TextButton("Reload Shaders", skin.get(TextButtonStyle.class));
 		camera = new SelectBox(skin.get(SelectBoxStyle.class));
@@ -170,6 +170,7 @@ public class ProjectiveTextureTest extends GdxTest {
 		fps.setText("fps: " + Gdx.graphics.getFramesPerSecond());
 		ui.act();
 		ui.draw();
+		Table.drawDebug(ui);
 	}
 
 	Vector3 position = new Vector3();
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/Scene2DDebugRendererTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/Scene2DDebugRendererTest.java
deleted file mode 100644
index 4e3c6e7..0000000
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/Scene2DDebugRendererTest.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/* ######################################
- * Copyright 2014 (c) Pixel Scientists
- * All rights reserved.
- * Unauthorized copying of this file, via
- * any medium is strictly prohibited.
- * Proprietary and confidential.
- * ###################################### */
-
-package com.badlogic.gdx.tests;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.Pixmap;
-import com.badlogic.gdx.graphics.Texture;
-import com.badlogic.gdx.graphics.Pixmap.Format;
-import com.badlogic.gdx.graphics.g2d.Batch;
-import com.badlogic.gdx.graphics.g2d.TextureRegion;
-import com.badlogic.gdx.scenes.scene2d.Actor;
-import com.badlogic.gdx.scenes.scene2d.Group;
-import com.badlogic.gdx.scenes.scene2d.Stage;
-import com.badlogic.gdx.scenes.scene2d.ui.Label;
-import com.badlogic.gdx.scenes.scene2d.ui.Skin;
-import com.badlogic.gdx.scenes.scene2d.ui.Table;
-import com.badlogic.gdx.scenes.scene2d.ui.TextButton;
-import com.badlogic.gdx.scenes.scene2d.utils.Scene2DDebugRenderer;
-import com.badlogic.gdx.tests.utils.GdxTest;
-
-/** @author Daniel Holderbaum */
-public class Scene2DDebugRendererTest extends GdxTest {
-
-	static TextureRegion textureRegion;
-
-	private Stage stage;
-	private Stage stage1;
-	private Stage stage2;
-
-	private Scene2DDebugRenderer debugRenderer;
-
-	class DebugActor extends Actor {
-
-		@Override
-		public void draw (Batch batch, float parentAlpha) {
-			batch.draw(textureRegion, getX(), getY(), getOriginX(), getOriginY(), getWidth(), getHeight(), getScaleX(), getScaleY(),
-				getRotation());
-		}
-	}
-
-	@Override
-	public void create () {
-		textureRegion = new TextureRegion(new Texture("data/badlogic.jpg"));
-
-		Gdx.input.setInputProcessor(this);
-
-		stage1 = new Stage();
-		stage1.getCamera().position.set(100, 100, 0);
-
-		Group group = new Group();
-//		 group.setBounds(0, 0, 10, 10);
-		// group.setOrigin(25, 50);
-		group.setRotation(10);
-		group.setScale(1.2f);
-		stage1.addActor(group);
-
-		DebugActor actor = new DebugActor();
-		actor.setBounds(400, 240, 50, 100);
-		actor.setOrigin(25, 50);
-		actor.setRotation(-45);
-		actor.setScale(2f);
-		group.addActor(actor);
-
-		stage2 = new Stage();
-		Skin skin = new Skin(Gdx.files.internal("data/uiskin.json"));
-
-		Table root = new Table(skin);
-		root.setFillParent(true);
-		root.setBackground(skin.getDrawable("default-pane"));
-		root.defaults().space(6);
-		root.debug();
-		TextButton shortButton = new TextButton("Button short", skin);
-		root.add(shortButton).pad(5);
-		shortButton.debug();
-		TextButton longButton = new TextButton("Button loooooooooong", skin);
-		longButton.debug();
-		root.add(longButton).row();
-		root.add("Colspan").colspan(2).row();
-		root.setTransform(true);
-		root.rotateBy(10);
-		stage2.addActor(root);
-
-		switchStage();
-	}
-
-	@Override
-	public void render () {
-		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT | GL20.GL_DEPTH_BUFFER_BIT);
-
-		stage.draw();
-		debugRenderer.render();
-	}
-
-	@Override
-	public boolean touchDown (int screenX, int screenY, int pointer, int button) {
-		switchStage();
-		return false;
-	}
-
-	@Override
-	public void resize (int width, int height) {
-		stage1.getViewport().update(width, height, true);
-		stage2.getViewport().update(width, height, true);
-	}
-
-	private void switchStage () {
-		if (stage != stage1) {
-			stage = stage1;
-		} else {
-			stage = stage2;
-		}
-		debugRenderer = new Scene2DDebugRenderer(stage);
-	}
-
-	/** A workaround for the limitations of UI elements when it comes to rotation and scaling. For most groups this is disabled by
-	 * default. */
-	private Table createWrapper (Actor actor) {
-		Table wrapper = new Table();
-		wrapper.setTransform(true);
-		wrapper.add(actor);
-		wrapper.setOrigin(wrapper.getPrefWidth() / 2f, wrapper.getPrefHeight() / 2f);
-		return wrapper;
-	}
-
-}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/Scene2dTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/Scene2dTest.java
index efa16aa..1b0ade2 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/Scene2dTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/Scene2dTest.java
@@ -40,19 +40,16 @@ import com.badlogic.gdx.scenes.scene2d.ui.TextButton;
 import com.badlogic.gdx.scenes.scene2d.ui.VerticalGroup;
 import com.badlogic.gdx.scenes.scene2d.ui.Window;
 import com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener;
-import com.badlogic.gdx.scenes.scene2d.utils.Scene2DDebugRenderer;
 import com.badlogic.gdx.scenes.scene2d.utils.TiledDrawable;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
 public class Scene2dTest extends GdxTest {
 	Stage stage;
-	Scene2DDebugRenderer debugRenderer;
 	private FloatAction meow = new FloatAction(10, 5);
 	private TiledDrawable patch;
 
 	public void create () {
 		stage = new Stage();
-		debugRenderer = new Scene2DDebugRenderer(stage);
 		Gdx.input.setInputProcessor(stage);
 
 		final TextureRegion region = new TextureRegion(new Texture("data/badlogic.jpg"));
@@ -177,7 +174,7 @@ public class Scene2dTest extends GdxTest {
 		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
 		stage.act(Gdx.graphics.getDeltaTime());
 		stage.draw();
-		debugRenderer.render();
+		Table.drawDebug(stage);
 
 		stage.getBatch().begin();
 		patch.draw(stage.getBatch(), 300, 100, 126, 126);
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/ScrollPane2Test.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/ScrollPane2Test.java
index 2fc53be..3d6f4e7 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/ScrollPane2Test.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/ScrollPane2Test.java
@@ -26,17 +26,14 @@ import com.badlogic.gdx.scenes.scene2d.ui.Image;
 import com.badlogic.gdx.scenes.scene2d.ui.ScrollPane;
 import com.badlogic.gdx.scenes.scene2d.ui.Skin;
 import com.badlogic.gdx.scenes.scene2d.ui.Table;
-import com.badlogic.gdx.scenes.scene2d.utils.Scene2DDebugRenderer;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
 public class ScrollPane2Test extends GdxTest {
 	Stage stage;
 	Skin skin;
-	Scene2DDebugRenderer debugRenderer;
 
 	public void create () {
 		stage = new Stage();
-		debugRenderer = new Scene2DDebugRenderer(stage);
 		Gdx.input.setInputProcessor(stage);
 
 		skin = new Skin(Gdx.files.internal("data/uiskin.json"));
@@ -85,7 +82,7 @@ public class ScrollPane2Test extends GdxTest {
 		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
 		stage.act(Gdx.graphics.getDeltaTime());
 		stage.draw();
-		debugRenderer.render();
+		Table.drawDebug(stage);
 	}
 
 	public void resize (int width, int height) {
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/ScrollPaneScrollBarsTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/ScrollPaneScrollBarsTest.java
index 445757a..7cfd449 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/ScrollPaneScrollBarsTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/ScrollPaneScrollBarsTest.java
@@ -224,6 +224,7 @@ public class ScrollPaneScrollBarsTest extends GdxTest {
 		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
 		stage.act(Gdx.graphics.getDeltaTime());
 		stage.draw();
+		Table.drawDebug(stage);
 	}
 
 	public void resize (int width, int height) {
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/ScrollPaneTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/ScrollPaneTest.java
index ceb9cd2..08004fc 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/ScrollPaneTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/ScrollPaneTest.java
@@ -123,6 +123,7 @@ public class ScrollPaneTest extends GdxTest {
 		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
 		stage.act(Gdx.graphics.getDeltaTime());
 		stage.draw();
+		Table.drawDebug(stage);
 	}
 
 	public void resize (int width, int height) {
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/TableLayoutTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/TableLayoutTest.java
index 71a36e9..3ae1f7f 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/TableLayoutTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/TableLayoutTest.java
@@ -30,16 +30,13 @@ import com.badlogic.gdx.scenes.scene2d.ui.Table;
 import com.badlogic.gdx.scenes.scene2d.ui.TextButton;
 import com.badlogic.gdx.scenes.scene2d.ui.TextField;
 import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
-import com.badlogic.gdx.scenes.scene2d.utils.Scene2DDebugRenderer;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
 public class TableLayoutTest extends GdxTest {
 	Stage stage;
-	Scene2DDebugRenderer debugRenderer;
 
 	public void create () {
 		stage = new Stage();
-		debugRenderer = new Scene2DDebugRenderer(stage);
 		Gdx.input.setInputProcessor(stage);
 		Skin skin = new Skin(Gdx.files.internal("data/uiskin.json"));
 
@@ -94,7 +91,7 @@ public class TableLayoutTest extends GdxTest {
 		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
 		stage.act(Gdx.graphics.getDeltaTime());
 		stage.draw();
-		debugRenderer.render();
+		Table.drawDebug(stage);
 	}
 
 	public void resize (int width, int height) {
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/TableTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/TableTest.java
index 5b11fcf..0635517 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/TableTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/TableTest.java
@@ -31,7 +31,6 @@ import com.badlogic.gdx.scenes.scene2d.ui.Table;
 import com.badlogic.gdx.scenes.scene2d.ui.TextButton;
 import com.badlogic.gdx.scenes.scene2d.ui.TextButton.TextButtonStyle;
 import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
-import com.badlogic.gdx.scenes.scene2d.utils.Scene2DDebugRenderer;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
 public class TableTest extends GdxTest {
@@ -39,12 +38,10 @@ public class TableTest extends GdxTest {
 	Stage stage;
 	Texture texture;
 	Table root;
-	Scene2DDebugRenderer debugRenderer;
 
 	@Override
 	public void create () {
 		stage = new Stage();
-		debugRenderer = new Scene2DDebugRenderer(stage);
 		Gdx.input.setInputProcessor(stage);
 
 		skin = new Skin(Gdx.files.internal("data/uiskin.json"));
@@ -108,7 +105,7 @@ public class TableTest extends GdxTest {
 
 		stage.act(Math.min(Gdx.graphics.getDeltaTime(), 1 / 30f));
 		stage.draw();
-		debugRenderer.render();
+		Table.drawDebug(stage);
 	}
 
 	@Override
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/TreeTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/TreeTest.java
index 2a65472..4fc0785 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/TreeTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/TreeTest.java
@@ -68,6 +68,7 @@ public class TreeTest extends GdxTest {
 		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
 		stage.act(Gdx.graphics.getDeltaTime());
 		stage.draw();
+		Table.drawDebug(stage);
 	}
 
 	public void resize (int width, int height) {
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/UISimpleTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/UISimpleTest.java
index aeb5327..95363b9 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/UISimpleTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/UISimpleTest.java
@@ -97,6 +97,7 @@ public class UISimpleTest extends GdxTest {
 		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
 		stage.act(Math.min(Gdx.graphics.getDeltaTime(), 1 / 30f));
 		stage.draw();
+		Table.drawDebug(stage);
 	}
 
 	@Override
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/UITest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/UITest.java
index fca61ca..c4678d3 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/UITest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/UITest.java
@@ -182,6 +182,7 @@ public class UITest extends GdxTest {
 
 		stage.act(Math.min(Gdx.graphics.getDeltaTime(), 1 / 30f));
 		stage.draw();
+		Table.drawDebug(stage);
 	}
 
 	@Override
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/ViewportTest1.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/ViewportTest1.java
index 82a0e9c..a9b7195 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/ViewportTest1.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/ViewportTest1.java
@@ -27,7 +27,6 @@ import com.badlogic.gdx.scenes.scene2d.ui.Label;
 import com.badlogic.gdx.scenes.scene2d.ui.Skin;
 import com.badlogic.gdx.scenes.scene2d.ui.Table;
 import com.badlogic.gdx.scenes.scene2d.ui.TextButton;
-import com.badlogic.gdx.scenes.scene2d.utils.Scene2DDebugRenderer;
 import com.badlogic.gdx.tests.utils.GdxTest;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.Scaling;
@@ -45,12 +44,10 @@ public class ViewportTest1 extends GdxTest {
 	Array<String> names;
 	Stage stage;
 	Label label;
-	Scene2DDebugRenderer debugRenderer;
 
 	public void create () {
 		stage = new Stage();
 		Skin skin = new Skin(Gdx.files.internal("data/uiskin.json"));
-		debugRenderer = new Scene2DDebugRenderer(stage);
 
 		label = new Label("", skin);
 
@@ -89,8 +86,7 @@ public class ViewportTest1 extends GdxTest {
 
 		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
 		stage.draw();
-		debugRenderer.render();
-//		Table.drawDebug(stage);
+		Table.drawDebug(stage);
 	}
 
 	public void resize (int width, int height) {
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/BaseG3dHudTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/BaseG3dHudTest.java
index cf5f3f8..4903642 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/BaseG3dHudTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/BaseG3dHudTest.java
@@ -53,7 +53,7 @@ public abstract class BaseG3dHudTest extends BaseG3dTest {
 	protected float moveRadius = 2f;
 
 	protected String models[] = new String[] {"car.obj", "cube.obj", "scene.obj", "scene2.obj", "wheel.obj", "g3d/invaders.g3dj",
-		"g3d/head.g3db", "g3d/knight.g3dj", "g3d/knight.g3db", "g3d/ship.obj", "g3d/shapes/cube_1.0x1.0.g3dj",
+		"g3d/head.g3db", "g3d/knight.g3dj", "g3d/knight.g3db", "g3d/monkey.g3db", "g3d/ship.obj", "g3d/shapes/cube_1.0x1.0.g3dj",
 		"g3d/shapes/cube_1.5x1.5.g3dj", "g3d/shapes/sphere.g3dj", "g3d/shapes/teapot.g3dj", "g3d/shapes/torus.g3dj"};
 
 	@Override
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/Benchmark3DTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/Benchmark3DTest.java
index 9591d4a..543840d 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/Benchmark3DTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/Benchmark3DTest.java
@@ -17,6 +17,7 @@
 package com.badlogic.gdx.tests.g3d;
 
 import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.Input.Buttons;
 import com.badlogic.gdx.Input.Keys;
 import com.badlogic.gdx.graphics.Camera;
 import com.badlogic.gdx.graphics.Color;
@@ -71,7 +72,7 @@ public class Benchmark3DTest extends BaseG3dHudTest {
 
 		randomizeLights();
 
-		cam.position.set(1, 1, 1);
+		cam.position.set(10, 10, 10);
 		cam.lookAt(0, 0, 0);
 		cam.update();
 		showAxes = true;
@@ -237,7 +238,7 @@ public class Benchmark3DTest extends BaseG3dHudTest {
 		instance.transform.rotate(Vector3.Z, MathUtils.random(-180, 180));
 		instances.add(instance);
 	}
-
+	
 	@Override
 	public boolean keyUp (int keycode) {
 		if (keycode == Keys.SPACE || keycode == Keys.MENU) {
@@ -245,11 +246,17 @@ public class Benchmark3DTest extends BaseG3dHudTest {
 		}
 		return super.keyUp(keycode);
 	}
-
+	
+	@Override
+	public boolean touchUp (int screenX, int screenY, int pointer, int button) {
+		onModelClicked(models[MathUtils.random(models.length-1)]);
+		return false;
+	}
+	
 	@Override
 	public void dispose () {
 		super.dispose();
 		GLProfiler.disable();
 	}
 
-}
+}
\ No newline at end of file
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ParticleControllerTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ParticleControllerTest.java
new file mode 100644
index 0000000..20ac12b
--- /dev/null
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ParticleControllerTest.java
@@ -0,0 +1,221 @@
+package com.badlogic.gdx.tests.g3d;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.assets.AssetDescriptor;
+import com.badlogic.gdx.assets.AssetErrorListener;
+import com.badlogic.gdx.assets.loaders.TextureLoader.TextureParameter;
+import com.badlogic.gdx.graphics.Color;
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.g2d.ParticleEmitter.SpawnEllipseSide;
+import com.badlogic.gdx.graphics.g2d.TextureRegion;
+import com.badlogic.gdx.graphics.g3d.Attribute;
+import com.badlogic.gdx.graphics.g3d.Environment;
+import com.badlogic.gdx.graphics.g3d.Material;
+import com.badlogic.gdx.graphics.g3d.Model;
+import com.badlogic.gdx.graphics.g3d.ModelBatch;
+import com.badlogic.gdx.graphics.g3d.ModelInstance;
+import com.badlogic.gdx.graphics.g3d.attributes.BlendingAttribute;
+import com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute;
+import com.badlogic.gdx.graphics.g3d.environment.DirectionalLight;
+import com.badlogic.gdx.graphics.g3d.particles.ParticleController;
+import com.badlogic.gdx.graphics.g3d.particles.batches.BillboardParticleBatch;
+import com.badlogic.gdx.graphics.g3d.particles.emitters.RegularEmitter;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.ColorInfluencer;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.DynamicsInfluencer;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.DynamicsModifier;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.DynamicsModifier.BrownianAcceleration;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.RegionInfluencer;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.ScaleInfluencer;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.SpawnInfluencer;
+import com.badlogic.gdx.graphics.g3d.particles.influencers.ColorInfluencer.Single;
+import com.badlogic.gdx.graphics.g3d.particles.renderers.BillboardRenderer;
+import com.badlogic.gdx.graphics.g3d.particles.values.PointSpawnShapeValue;
+import com.badlogic.gdx.math.Matrix4;
+import com.badlogic.gdx.math.Quaternion;
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.scenes.scene2d.Action;
+import com.badlogic.gdx.scenes.scene2d.Stage;
+import com.badlogic.gdx.scenes.scene2d.actions.Actions;
+import com.badlogic.gdx.scenes.scene2d.ui.Label;
+import com.badlogic.gdx.scenes.scene2d.ui.Skin;
+import com.badlogic.gdx.scenes.scene2d.ui.Table;
+import com.badlogic.gdx.utils.Array;
+
+/** @author Inferno */
+public class ParticleControllerTest extends BaseG3dTest{
+	public static final String DEFAULT_PARTICLE = "data/pre_particle.png",
+										DEFAULT_SKIN ="data/uiskin.json";
+	Quaternion tmpQuaternion = new Quaternion();
+	Matrix4 tmpMatrix = new Matrix4(), tmpMatrix4 = new Matrix4();
+	Vector3 tmpVector = new Vector3();
+	
+	private class RotationAction extends Action{
+		private ParticleController emitter;
+		Vector3 axis;
+		float angle;
+		
+		public RotationAction (ParticleController emitter, Vector3 axis, float angle) {
+			this.emitter = emitter;
+			this.axis = axis;
+			this.angle = angle;
+		}
+
+		@Override
+		public boolean act (float delta) {
+			emitter.getTransform(tmpMatrix);
+			tmpQuaternion.set(axis, angle*delta).toMatrix(tmpMatrix4.val);
+			tmpMatrix4.mul(tmpMatrix);
+			emitter.setTransform(tmpMatrix4);
+			return false;
+		}
+	}
+	
+	//Simulation
+	Array<ParticleController> emitters;
+	
+	//Rendering
+	Environment environment;
+	BillboardParticleBatch billboardParticleBatch;
+	
+	//UI
+	Stage ui;
+	Label fpsLabel;
+	StringBuilder builder;
+	
+	@Override
+	public void create () {
+		super.create();
+		emitters = new Array<ParticleController>();
+		assets.load(DEFAULT_PARTICLE, Texture.class);
+		assets.load(DEFAULT_SKIN, Skin.class);
+		loading = true;
+		environment = new Environment();
+		environment.set(new ColorAttribute(ColorAttribute.AmbientLight, 0f, 0f, 0.1f, 1f));
+		environment.add(new DirectionalLight().set(1f, 1f, 1f,  0, -0.5f, -1 ));
+		billboardParticleBatch = new BillboardParticleBatch();
+		billboardParticleBatch.setCamera(cam);
+		ui = new Stage();
+		builder = new StringBuilder();
+	}
+	
+	@Override
+	public void resize (int width, int height) {
+		super.resize(width, height);
+		ui.getViewport().setWorldSize(width, height);
+		ui.getViewport().update(width, height, true);
+	}
+	
+	@Override
+	protected void onLoaded () {
+		Texture particleTexture = assets.get(DEFAULT_PARTICLE);
+		billboardParticleBatch.setTexture(assets.get(DEFAULT_PARTICLE, Texture.class));
+		
+		//X
+		addEmitter(new float[] {1, 0.12156863f, 0.047058824f}, particleTexture, 
+								tmpVector.set(5,5,0), Vector3.X, 360);
+
+		//Y
+		addEmitter(new float[] {0.12156863f, 1, 0.047058824f}, particleTexture, 
+								tmpVector.set(0,5,-5), Vector3.Y, -360);
+		
+		//Z
+		addEmitter(new float[] {0.12156863f, 0.047058824f, 1}, particleTexture, 
+			tmpVector.set(0,5,5), Vector3.Z, -360);
+
+		setupUI();
+	}
+	
+	private void addEmitter(	float[] colors, Texture particleTexture, 
+														Vector3 translation, 
+														Vector3 actionAxis, float actionRotation){
+		ParticleController controller = createBillboardController(colors, particleTexture);
+		controller.init();
+		controller.start();
+		emitters.add(controller);
+		controller.translate(translation);
+		ui.addAction(new RotationAction(controller, actionAxis, actionRotation));
+	}
+
+	private void setupUI () {
+		Skin skin = assets.get(DEFAULT_SKIN);
+		Table table = new Table();
+		table.setFillParent(true);
+		table.top().left().add(new Label("FPS ", skin)).left();
+		table.add(fpsLabel = new Label("", skin)).left().expandX().row();
+		ui.addActor(table);
+	}
+
+	private ParticleController createBillboardController (float[] colors, Texture particleTexture) {
+		//Emission
+		RegularEmitter emitter = new RegularEmitter();
+		emitter.getDuration().setLow(3000);
+		emitter.getEmission().setHigh(2900);
+		emitter.getLife().setHigh(1000);
+		emitter.setMaxParticleCount(3000);
+
+		//Spawn
+		PointSpawnShapeValue pointSpawnShapeValue = new PointSpawnShapeValue();		
+		pointSpawnShapeValue.xOffsetValue.setLow(0, 1f);
+		pointSpawnShapeValue.xOffsetValue.setActive(true);
+		pointSpawnShapeValue.yOffsetValue.setLow(0, 1f);
+		pointSpawnShapeValue.yOffsetValue.setActive(true);
+		pointSpawnShapeValue.zOffsetValue.setLow(0, 1f);
+		pointSpawnShapeValue.zOffsetValue.setActive(true);
+		SpawnInfluencer spawnSource = new SpawnInfluencer(pointSpawnShapeValue);
+
+		//Scale
+		ScaleInfluencer scaleInfluencer = new ScaleInfluencer();
+		scaleInfluencer.value.setTimeline(new float[]{0, 1});
+		scaleInfluencer.value.setScaling(new float[]{1, 0});
+		scaleInfluencer.value.setLow(0);
+		scaleInfluencer.value.setHigh(1);
+
+		//Color
+		ColorInfluencer.Single colorInfluencer = new ColorInfluencer.Single();
+		colorInfluencer.colorValue.setColors(new float[] {colors[0], colors[1], colors[2], 0,0,0});
+		colorInfluencer.colorValue.setTimeline(new float[] {0, 1});
+		colorInfluencer.alphaValue.setHigh(1);
+		colorInfluencer.alphaValue.setTimeline(new float[] {0, 0.5f, 0.8f, 1});
+		colorInfluencer.alphaValue.setScaling(new float[] {0, 0.15f, 0.5f, 0});
+		
+		//Dynamics
+		DynamicsInfluencer dynamicsInfluencer = new DynamicsInfluencer();
+		BrownianAcceleration modifier = new BrownianAcceleration();
+		modifier.strengthValue.setTimeline(new float[]{0,1});
+		modifier.strengthValue.setScaling(new float[]{0,1});
+		modifier.strengthValue.setHigh(80);
+		modifier.strengthValue.setLow(1, 5);
+		dynamicsInfluencer.velocities.add(modifier);
+		
+		return new ParticleController("Billboard Controller", emitter, new BillboardRenderer(billboardParticleBatch),
+			new RegionInfluencer.Single(particleTexture),
+			spawnSource,
+			scaleInfluencer,
+			colorInfluencer,
+			dynamicsInfluencer
+			);
+	}
+
+	@Override
+	protected void render (ModelBatch batch, Array<ModelInstance> instances) {
+		if(emitters.size > 0){
+			//Update
+			float delta = Gdx.graphics.getDeltaTime();
+			builder.delete(0, builder.length());
+			builder.append(Gdx.graphics.getFramesPerSecond());
+			fpsLabel.setText(builder);
+			ui.act(delta);
+
+			billboardParticleBatch.begin();
+			for (ParticleController controller : emitters){
+				controller.update();
+				controller.draw();
+			}
+			billboardParticleBatch.end();
+			batch.render(billboardParticleBatch, environment);
+		}
+		batch.render(instances, environment);
+		ui.draw();
+	}
+}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
index c4b26b2..a6134fd 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
@@ -39,6 +39,7 @@ import com.badlogic.gdx.tests.g3d.FogTest;
 import com.badlogic.gdx.tests.g3d.LightsTest;
 import com.badlogic.gdx.tests.g3d.MaterialTest;
 import com.badlogic.gdx.tests.g3d.ModelTest;
+import com.badlogic.gdx.tests.g3d.ParticleControllerTest;
 import com.badlogic.gdx.tests.g3d.ShaderCollectionTest;
 import com.badlogic.gdx.tests.g3d.ShaderTest;
 import com.badlogic.gdx.tests.g3d.ShadowMappingTest;
@@ -144,6 +145,7 @@ public class GdxTests {
 		OnscreenKeyboardTest.class,
 		PathTest.class,
 		ParallaxTest.class,
+		ParticleControllerTest.class,
 		ParticleEmitterTest.class,
 		PixelsPerInchTest.class,
 		PixmapBlendingTest.class,
@@ -157,7 +159,6 @@ public class GdxTests {
 		ReflectionTest.class,
 		RotationTest.class,
 		RunnablePostTest.class,
-		Scene2DDebugRendererTest.class,
 		Scene2dTest.class,
 		ScrollPane2Test.class,
 		ScrollPaneScrollBarsTest.class,
