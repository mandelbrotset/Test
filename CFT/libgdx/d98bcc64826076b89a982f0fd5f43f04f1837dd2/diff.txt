diff --git a/CHANGES b/CHANGES
index 4b70848..467d655 100644
--- a/CHANGES
+++ b/CHANGES
@@ -1,4 +1,6 @@
 [1.4.2]
+- API Addition: IOSInput now uses CMCoreMotion for accelerometer and magnetometer
+- API Addition: Added getter for UITextField on IOS for keyboard customization 
 - API Addition: Added ability to save PixmapPackers to atlas files. See PixmapPackerIO.
 - API Addition: Added HttpRequestHeader and HttpResponseHeader with constants for HTTP headers.
 - API Addition: HttpRequest is now poolable.
@@ -8,6 +10,8 @@
 - API Change: ScrollPane#scrollToCenter -> ScrollPane#scrollTo; see optional boolean arguments centerHorizontal and centerVertical (scrollToCenter centered vertically only).
 - API Change: Changed Input#getTextInput to accept both text and hint, removed Input#getPlaceholderTextInput.
 - Bug Fix: Fixed potential NPE with immersive mode in the Android fragment backend. 
+- iOS backend now supports sound ids, thanks Tomski!
+
 
 [1.4.1]
 - Update to the Gradle Integration plugin nightly build if you are on Eclipse 4.4.x!
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGL20.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGL20.java
index 4729e01..2fbf6a4 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGL20.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGL20.java
@@ -89,16 +89,24 @@ public class AndroidGL20 implements GL20 {
 	public native void glCullFace (int mode);
 
 	public native void glDeleteBuffers (int n, IntBuffer buffers);
+	
+	public native void glDeleteBuffer (int buffer);
 
 	public native void glDeleteFramebuffers (int n, IntBuffer framebuffers);
+	
+	public native void glDeleteFramebuffer (int framebuffer);
 
 	public native void glDeleteProgram (int program);
 
 	public native void glDeleteRenderbuffers (int n, IntBuffer renderbuffers);
+	
+	public native void glDeleteRenderbuffer (int renderbuffer);
 
 	public native void glDeleteShader (int shader);
 
 	public native void glDeleteTextures (int n, IntBuffer textures);
+	
+	public native void glDeleteTexture (int texture);
 
 	public native void glDepthFunc (int func);
 
@@ -133,14 +141,22 @@ public class AndroidGL20 implements GL20 {
 	public native void glFrontFace (int mode);
 
 	public native void glGenBuffers (int n, IntBuffer buffers);
+	
+	public native int glGenBuffer ();
 
 	public native void glGenerateMipmap (int target);
 
 	public native void glGenFramebuffers (int n, IntBuffer framebuffers);
+	
+	public native int glGenFramebuffer ();
 
 	public native void glGenRenderbuffers (int n, IntBuffer renderbuffers);
+	
+	public native int glGenRenderbuffer ();
 
 	public native void glGenTextures (int n, IntBuffer textures);
+	
+	public native int glGenTexture ();
 
 	public native String glGetActiveAttrib (int program, int index, IntBuffer size, Buffer type);
 
@@ -261,40 +277,62 @@ public class AndroidGL20 implements GL20 {
 	public native void glUniform1f (int location, float x);
 
 	public native void glUniform1fv (int location, int count, FloatBuffer v);
+	
+	public native void glUniform1fv (int location, int count, float[] v, int offset);
 
 	public native void glUniform1i (int location, int x);
 
 	public native void glUniform1iv (int location, int count, IntBuffer v);
+	
+	public native void glUniform1iv (int location, int count, int[] v, int offset);
 
 	public native void glUniform2f (int location, float x, float y);
 
 	public native void glUniform2fv (int location, int count, FloatBuffer v);
+	
+	public native void glUniform2fv (int location, int count, float[] v, int offset);
 
 	public native void glUniform2i (int location, int x, int y);
 
 	public native void glUniform2iv (int location, int count, IntBuffer v);
 
+	public native void glUniform2iv (int location, int count, int[] v, int offset);
+
 	public native void glUniform3f (int location, float x, float y, float z);
 
 	public native void glUniform3fv (int location, int count, FloatBuffer v);
+	
+	public native void glUniform3fv (int location, int count, float[] v, int offset);
 
 	public native void glUniform3i (int location, int x, int y, int z);
 
 	public native void glUniform3iv (int location, int count, IntBuffer v);
+	
+	public native void glUniform3iv (int location, int count, int[] v, int offset);
 
 	public native void glUniform4f (int location, float x, float y, float z, float w);
 
 	public native void glUniform4fv (int location, int count, FloatBuffer v);
 
+	public native void glUniform4fv (int location, int count, float[] v, int offset);
+
 	public native void glUniform4i (int location, int x, int y, int z, int w);
 
 	public native void glUniform4iv (int location, int count, IntBuffer v);
 
+	public native void glUniform4iv (int location, int count, int[] v, int offset);
+	
 	public native void glUniformMatrix2fv (int location, int count, boolean transpose, FloatBuffer value);
+	
+	public native void glUniformMatrix2fv (int location, int count, boolean transpose, float[] value, int offset);
 
 	public native void glUniformMatrix3fv (int location, int count, boolean transpose, FloatBuffer value);
+	
+	public native void glUniformMatrix3fv (int location, int count, boolean transpose, float[] value, int offset);
 
 	public native void glUniformMatrix4fv (int location, int count, boolean transpose, FloatBuffer value);
+	
+	public native void glUniformMatrix4fv (int location, int count, boolean transpose, float[] value, int offset);
 
 	public native void glUseProgram (int program);
 
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphics.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphics.java
index ffb369a..a7bc00a 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphics.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphics.java
@@ -16,12 +16,7 @@
 
 package com.badlogic.gdx.backends.android;
 
-import javax.microedition.khronos.egl.EGL10;
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.egl.EGLContext;
-import javax.microedition.khronos.egl.EGLDisplay;
-import javax.microedition.khronos.opengles.GL10;
-
+import android.content.Context;
 import android.opengl.GLSurfaceView;
 import android.opengl.GLSurfaceView.EGLConfigChooser;
 import android.opengl.GLSurfaceView.Renderer;
@@ -37,7 +32,6 @@ import com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20API18;
 import com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18;
 import com.badlogic.gdx.backends.android.surfaceview.GdxEglConfigChooser;
 import com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy;
-import com.badlogic.gdx.graphics.Cubemap;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.GL30;
 import com.badlogic.gdx.graphics.Mesh;
@@ -48,6 +42,14 @@ import com.badlogic.gdx.math.WindowedMean;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 
+import java.lang.reflect.Method;
+
+import javax.microedition.khronos.egl.EGL10;
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.egl.EGLContext;
+import javax.microedition.khronos.egl.EGLDisplay;
+import javax.microedition.khronos.opengles.GL10;
+
 /** An implementation of {@link Graphics} for Android.
  * 
  * @author mzechner */
@@ -250,7 +252,6 @@ public class AndroidGraphics implements Graphics, Renderer {
 
 		Mesh.invalidateAllMeshes(app);
 		Texture.invalidateAllTextures(app);
-		Cubemap.invalidateAllCubemaps(app);
 		ShaderProgram.invalidateAllShaderPrograms(app);
 		FrameBuffer.invalidateAllFrameBuffers(app);
 
@@ -476,7 +477,6 @@ public class AndroidGraphics implements Graphics, Renderer {
 	public void clearManagedCaches () {
 		Mesh.clearAllMeshes(app);
 		Texture.clearAllTextures(app);
-		Cubemap.clearAllCubemaps(app);
 		ShaderProgram.clearAllShaderPrograms(app);
 		FrameBuffer.clearAllFrameBuffers(app);
 
@@ -486,7 +486,6 @@ public class AndroidGraphics implements Graphics, Renderer {
 	protected void logManagedCachesStatus() {
 		Gdx.app.log(LOG_TAG, Mesh.getManagedStatus());
 		Gdx.app.log(LOG_TAG, Texture.getManagedStatus());
-		Gdx.app.log(LOG_TAG, Cubemap.getManagedStatus());
 		Gdx.app.log(LOG_TAG, ShaderProgram.getManagedStatus());
 		Gdx.app.log(LOG_TAG, FrameBuffer.getManagedStatus());
 	}
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidInput.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidInput.java
index 3f6d46d..c512555 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidInput.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidInput.java
@@ -95,7 +95,7 @@ public class AndroidInput implements Input, OnKeyListener, OnTouchListener {
 		}
 	};
 
-	public static final int NUM_TOUCHES = 40;
+	public static final int NUM_TOUCHES = 20;
 
 	ArrayList<OnKeyListener> keyListeners = new ArrayList();
 	ArrayList<KeyEvent> keyEvents = new ArrayList();
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidSound.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidSound.java
index e3256f3..122296b 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidSound.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidSound.java
@@ -50,7 +50,7 @@ final class AndroidSound implements Sound {
 		int streamId = soundPool.play(soundId, volume, volume, 1, 0, 1);
 		// standardise error code with other backends
 		if (streamId == 0) return -1;
-		streamIds.add(streamId);
+		streamIds.insert(0, streamId);
 		return streamId;
 	}
 
@@ -105,7 +105,7 @@ final class AndroidSound implements Sound {
 		int streamId = soundPool.play(soundId, volume, volume, 1, -1, 1);
 		// standardise error code with other backends
 		if (streamId == 0) return -1;
-		streamIds.add(streamId);
+		streamIds.insert(0, streamId);
 		return streamId;
 	}
 
@@ -141,7 +141,7 @@ final class AndroidSound implements Sound {
 		int streamId = soundPool.play(soundId, leftVolume, rightVolume, 1, 0, pitch);
 		// standardise error code with other backends
 		if (streamId == 0) return -1;
-		streamIds.add(streamId);
+		streamIds.insert(0, streamId);
 		return streamId;
 	}
 
@@ -158,7 +158,7 @@ final class AndroidSound implements Sound {
 		int streamId = soundPool.play(soundId, leftVolume, rightVolume, 1, -1, pitch);
 		// standardise error code with other backends
 		if (streamId == 0) return -1;
-		streamIds.add(streamId);
+		streamIds.insert(0, streamId);
 		return streamId;
 	}
 
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwGL20.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwGL20.java
index 0ec45a4..d34d0a7 100644
--- a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwGL20.java
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwGL20.java
@@ -16,16 +16,51 @@
 
 package com.badlogic.gdx.backends.jglfw;
 
-import static com.badlogic.jglfw.utils.Memory.*;
-
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.jglfw.gl.GL;
+import static com.badlogic.jglfw.utils.Memory.getPosition;
 
 import java.nio.Buffer;
+import java.nio.ByteBuffer;
 import java.nio.FloatBuffer;
 import java.nio.IntBuffer;
 
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.jglfw.gl.GL;
+
 public class JglfwGL20 implements GL20 {
+	private ByteBuffer buffer = null;
+	private FloatBuffer floatBuffer = null;
+	private IntBuffer intBuffer = null;
+
+	private void ensureBufferCapacity (int numBytes) {
+		if (buffer == null || buffer.capacity() < numBytes) {
+			buffer = com.badlogic.gdx.utils.BufferUtils.newByteBuffer(numBytes);
+			floatBuffer = buffer.asFloatBuffer();
+			intBuffer = buffer.asIntBuffer();
+		}
+	}
+
+	private FloatBuffer toFloatBuffer (float v[], int offset, int count) {
+		ensureBufferCapacity(count << 2);
+		floatBuffer.clear();
+		com.badlogic.gdx.utils.BufferUtils.copy(v, floatBuffer, count, offset);
+		return floatBuffer;
+	}
+
+	private IntBuffer toIntBuffer (int v[], int offset, int count) {
+		ensureBufferCapacity(count << 2);
+		intBuffer.clear();
+		com.badlogic.gdx.utils.BufferUtils.copy(v, count, offset, intBuffer);
+		return intBuffer;
+	}
+	
+	private IntBuffer toIntBuffer (int v) {
+		ensureBufferCapacity(4);
+		intBuffer.put(0, v);
+		intBuffer.position(0);
+		intBuffer.limit(1);
+		return intBuffer;
+	}
+	
 	public void glActiveTexture (int texture) {
 		GL.glActiveTexture(texture);
 	}
@@ -83,6 +118,10 @@ public class JglfwGL20 implements GL20 {
 	public void glDeleteTextures (int n, IntBuffer textures) {
 		GL.glDeleteTextures(n, textures, getPosition(textures));
 	}
+	
+	public void glDeleteTexture (int texture) {
+		glDeleteTextures(1, toIntBuffer(texture));
+	}
 
 	public void glDepthFunc (int func) {
 		GL.glDepthFunc(func);
@@ -127,6 +166,14 @@ public class JglfwGL20 implements GL20 {
 	public void glGenTextures (int n, IntBuffer textures) {
 		GL.glGenTextures(n, textures, getPosition(textures));
 	}
+	
+	public int glGenTexture () {
+		ensureBufferCapacity(4);
+		intBuffer.position(0);
+		intBuffer.limit(1);
+		glGenTextures(1, intBuffer);
+		return intBuffer.get(0);
+	}
 
 	public int glGetError () {
 		return GL.glGetError();
@@ -221,6 +268,10 @@ public class JglfwGL20 implements GL20 {
 	public void glDeleteBuffers (int n, IntBuffer buffers) {
 		GL.glDeleteBuffers(n, buffers, getPosition(buffers));
 	}
+	
+	public void glDeleteBuffer (int buffer) {
+		glDeleteBuffers(1, toIntBuffer(buffer));
+	}
 
 	public void glGetBufferParameteriv (int target, int pname, IntBuffer params) {
 		GL.glGetBufferParameteriv(target, pname, params, getPosition(params));
@@ -229,6 +280,14 @@ public class JglfwGL20 implements GL20 {
 	public void glGenBuffers (int n, IntBuffer buffers) {
 		GL.glGenBuffers(n, buffers, getPosition(buffers));
 	}
+	
+	public int glGenBuffer () {
+		ensureBufferCapacity(4);
+		intBuffer.position(0);
+		intBuffer.limit(1);
+		glGenBuffers(1, intBuffer);
+		return intBuffer.get(0);
+	}
 
 	public void glGetTexParameteriv (int target, int pname, IntBuffer params) {
 		GL.glGetTexParameteriv(target, pname, params, getPosition(params));
@@ -309,6 +368,10 @@ public class JglfwGL20 implements GL20 {
 	public void glDeleteFramebuffers (int n, IntBuffer framebuffers) {
 		GL.glDeleteFramebuffersEXT(n, framebuffers, getPosition(framebuffers));
 	}
+	
+	public void glDeleteFramebuffer (int framebuffer) {
+		glDeleteFramebuffers(1, toIntBuffer(framebuffer));
+	}
 
 	public void glDeleteProgram (int program) {
 		GL.glDeleteProgram(program);
@@ -317,6 +380,10 @@ public class JglfwGL20 implements GL20 {
 	public void glDeleteRenderbuffers (int n, IntBuffer renderbuffers) {
 		GL.glDeleteRenderbuffersEXT(n, renderbuffers, getPosition(renderbuffers));
 	}
+	
+	public void glDeleteRenderbuffer (int renderbuffer) {
+		glDeleteRenderbuffers(1, toIntBuffer(renderbuffer));
+	}
 
 	public void glDeleteShader (int shader) {
 		GL.glDeleteShader(shader);
@@ -349,10 +416,26 @@ public class JglfwGL20 implements GL20 {
 	public void glGenFramebuffers (int n, IntBuffer framebuffers) {
 		GL.glGenFramebuffersEXT(n, framebuffers, getPosition(framebuffers));
 	}
+	
+	public int glGenFramebuffer () {
+		ensureBufferCapacity(4);
+		intBuffer.position(0);
+		intBuffer.limit(1);
+		glGenFramebuffers(1, intBuffer);
+		return intBuffer.get(0);
+	}
 
 	public void glGenRenderbuffers (int n, IntBuffer renderbuffers) {
 		GL.glGenRenderbuffersEXT(n, renderbuffers, getPosition(renderbuffers));
 	}
+	
+	public int glGenRenderbuffer () {
+		ensureBufferCapacity(4);
+		intBuffer.position(0);
+		intBuffer.limit(1);
+		glGenRenderbuffers(1, intBuffer);
+		return intBuffer.get(0);
+	}
 
 	public String glGetActiveAttrib (int program, int index, IntBuffer size, Buffer type) {
 		return GL.glGetActiveAttrib(program, index, size, getPosition(size), type, getPosition(type));
@@ -490,6 +573,10 @@ public class JglfwGL20 implements GL20 {
 		GL.glUniform1fv(location, count, v, getPosition(v));
 	}
 
+	public void glUniform1fv (int location, int count, float[] v, int offset) {
+		glUniform1fv(location, count, toFloatBuffer(v, offset, count));
+	}
+	
 	public void glUniform1i (int location, int x) {
 		GL.glUniform1i(location, x);
 	}
@@ -497,6 +584,10 @@ public class JglfwGL20 implements GL20 {
 	public void glUniform1iv (int location, int count, IntBuffer v) {
 		GL.glUniform1iv(location, count, v, getPosition(v));
 	}
+	
+	public void glUniform1iv (int location, int count, int[] v, int offset) {
+		glUniform1iv(location, count, toIntBuffer(v, offset, count));
+	}
 
 	public void glUniform2f (int location, float x, float y) {
 		GL.glUniform2f(location, x, y);
@@ -505,6 +596,10 @@ public class JglfwGL20 implements GL20 {
 	public void glUniform2fv (int location, int count, FloatBuffer v) {
 		GL.glUniform2fv(location, count, v, getPosition(v));
 	}
+	
+	public void glUniform2fv (int location, int count, float[] v, int offset) {
+		glUniform2fv(location, count, toFloatBuffer(v, offset, count << 1));
+	}
 
 	public void glUniform2i (int location, int x, int y) {
 		GL.glUniform2i(location, x, y);
@@ -513,6 +608,10 @@ public class JglfwGL20 implements GL20 {
 	public void glUniform2iv (int location, int count, IntBuffer v) {
 		GL.glUniform2iv(location, count, v, getPosition(v));
 	}
+	
+	public void glUniform2iv (int location, int count, int[] v, int offset) {
+		glUniform2iv(location, count, toIntBuffer(v, offset, count<<1));
+	}
 
 	public void glUniform3f (int location, float x, float y, float z) {
 		GL.glUniform3f(location, x, y, z);
@@ -521,6 +620,10 @@ public class JglfwGL20 implements GL20 {
 	public void glUniform3fv (int location, int count, FloatBuffer v) {
 		GL.glUniform3fv(location, count, v, getPosition(v));
 	}
+	
+	public void glUniform3fv (int location, int count, float[] v, int offset) {
+		glUniform3fv(location, count, toFloatBuffer(v, offset, count*3));
+	}
 
 	public void glUniform3i (int location, int x, int y, int z) {
 		GL.glUniform3i(location, x, y, z);
@@ -529,6 +632,10 @@ public class JglfwGL20 implements GL20 {
 	public void glUniform3iv (int location, int count, IntBuffer v) {
 		GL.glUniform3iv(location, count, v, getPosition(v));
 	}
+	
+	public void glUniform3iv (int location, int count, int[] v, int offset) {
+		glUniform3iv(location, count, toIntBuffer(v, offset, count*3));
+	}
 
 	public void glUniform4f (int location, float x, float y, float z, float w) {
 		GL.glUniform4f(location, x, y, z, w);
@@ -537,6 +644,10 @@ public class JglfwGL20 implements GL20 {
 	public void glUniform4fv (int location, int count, FloatBuffer v) {
 		GL.glUniform4fv(location, count, v, getPosition(v));
 	}
+	
+	public void glUniform4fv (int location, int count, float[] v, int offset) {
+		glUniform4fv(location, count, toFloatBuffer(v, offset, count << 2));
+	}
 
 	public void glUniform4i (int location, int x, int y, int z, int w) {
 		GL.glUniform4i(location, x, y, z, w);
@@ -545,18 +656,34 @@ public class JglfwGL20 implements GL20 {
 	public void glUniform4iv (int location, int count, IntBuffer v) {
 		GL.glUniform4iv(location, count, v, getPosition(v));
 	}
+	
+	public void glUniform4iv (int location, int count, int[] v, int offset) {
+		glUniform4iv(location, count, toIntBuffer(v, offset, count << 2));
+	}
 
 	public void glUniformMatrix2fv (int location, int count, boolean transpose, FloatBuffer value) {
 		GL.glUniformMatrix2fv(location, count, transpose, value, getPosition(value));
 	}
+	
+	public void glUniformMatrix2fv (int location, int count, boolean transpose, float[] value, int offset) {
+		glUniformMatrix2fv(location, count, transpose, toFloatBuffer(value, offset, count << 2));
+	}
 
 	public void glUniformMatrix3fv (int location, int count, boolean transpose, FloatBuffer value) {
 		GL.glUniformMatrix3fv(location, count, transpose, value, getPosition(value));
 	}
+	
+	public void glUniformMatrix3fv (int location, int count, boolean transpose, float[] value, int offset) {
+		glUniformMatrix3fv(location, count, transpose, toFloatBuffer(value, offset, count * 9));
+	}
 
 	public void glUniformMatrix4fv (int location, int count, boolean transpose, FloatBuffer value) {
 		GL.glUniformMatrix4fv(location, count, transpose, value, getPosition(value));
 	}
+	
+	public void glUniformMatrix4fv (int location, int count, boolean transpose, float[] value, int offset) {
+		glUniformMatrix4fv(location, count, transpose, toFloatBuffer(value, offset, count << 4));
+	}
 
 	public void glUseProgram (int program) {
 		GL.glUseProgram(program);
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGL20.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGL20.java
index 57ceceb..3341469 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGL20.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGL20.java
@@ -39,6 +39,32 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
  * 
  * @author mzechner */
 class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
+	private ByteBuffer buffer = null;
+	private FloatBuffer floatBuffer = null;
+	private IntBuffer intBuffer = null;
+
+	private void ensureBufferCapacity (int numBytes) {
+		if (buffer == null || buffer.capacity() < numBytes) {
+			buffer = com.badlogic.gdx.utils.BufferUtils.newByteBuffer(numBytes);
+			floatBuffer = buffer.asFloatBuffer();
+			intBuffer = buffer.asIntBuffer();
+		}
+	}
+
+	private FloatBuffer toFloatBuffer (float v[], int offset, int count) {
+		ensureBufferCapacity(count << 2);
+		floatBuffer.clear();
+		com.badlogic.gdx.utils.BufferUtils.copy(v, floatBuffer, count, offset);
+		return floatBuffer;
+	}
+
+	private IntBuffer toIntBuffer (int v[], int offset, int count) {
+		ensureBufferCapacity(count << 2);
+		floatBuffer.clear();
+		com.badlogic.gdx.utils.BufferUtils.copy(v, count, offset, intBuffer);
+		return intBuffer;
+	}
+
 	public void glActiveTexture (int texture) {
 		GL13.glActiveTexture(texture);
 	}
@@ -88,7 +114,7 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 	}
 
 	public void glBufferData (int target, int size, Buffer data, int usage) {
-		if(data == null)
+		if (data == null)
 			GL15.glBufferData(target, size, usage);
 		else if (data instanceof ByteBuffer)
 			GL15.glBufferData(target, (ByteBuffer)data, usage);
@@ -103,7 +129,7 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 	}
 
 	public void glBufferSubData (int target, int offset, int size, Buffer data) {
-		if(data == null)
+		if (data == null)
 			throw new GdxRuntimeException("Using null for the data not possible, blame LWJGL");
 		else if (data instanceof ByteBuffer)
 			GL15.glBufferSubData(target, offset, (ByteBuffer)data);
@@ -148,11 +174,10 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 	public void glCompressedTexImage2D (int target, int level, int internalformat, int width, int height, int border,
 		int imageSize, Buffer data) {
 		if (data instanceof ByteBuffer) {
-	       GL13.glCompressedTexImage2D(target, level, internalformat, width, height, border, (ByteBuffer)data);
-	    } else {
-	        throw new GdxRuntimeException("Can't use " + data.getClass().getName()
-	           + " with this method. Use ByteBuffer instead.");
-	    }
+			GL13.glCompressedTexImage2D(target, level, internalformat, width, height, border, (ByteBuffer)data);
+		} else {
+			throw new GdxRuntimeException("Can't use " + data.getClass().getName() + " with this method. Use ByteBuffer instead.");
+		}
 	}
 
 	public void glCompressedTexSubImage2D (int target, int level, int xoffset, int yoffset, int width, int height, int format,
@@ -184,10 +209,20 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		GL15.glDeleteBuffers(buffers);
 	}
 
+	@Override
+	public void glDeleteBuffer (int buffer) {
+		GL15.glDeleteBuffers(buffer);
+	}
+
 	public void glDeleteFramebuffers (int n, IntBuffer framebuffers) {
 		EXTFramebufferObject.glDeleteFramebuffersEXT(framebuffers);
 	}
 
+	@Override
+	public void glDeleteFramebuffer (int framebuffer) {
+		EXTFramebufferObject.glDeleteFramebuffersEXT(framebuffer);
+	}
+
 	public void glDeleteProgram (int program) {
 		GL20.glDeleteProgram(program);
 	}
@@ -196,6 +231,10 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		EXTFramebufferObject.glDeleteRenderbuffersEXT(renderbuffers);
 	}
 
+	public void glDeleteRenderbuffer (int renderbuffer) {
+		EXTFramebufferObject.glDeleteRenderbuffersEXT(renderbuffer);
+	}
+
 	public void glDeleteShader (int shader) {
 		GL20.glDeleteShader(shader);
 	}
@@ -204,6 +243,11 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		GL11.glDeleteTextures(textures);
 	}
 
+	@Override
+	public void glDeleteTexture (int texture) {
+		GL11.glDeleteTextures(texture);
+	}
+
 	public void glDepthFunc (int func) {
 		GL11.glDepthFunc(func);
 	}
@@ -276,18 +320,34 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		GL15.glGenBuffers(buffers);
 	}
 
+	public int glGenBuffer () {
+		return GL15.glGenBuffers();
+	}
+
 	public void glGenFramebuffers (int n, IntBuffer framebuffers) {
 		EXTFramebufferObject.glGenFramebuffersEXT(framebuffers);
 	}
 
+	public int glGenFramebuffer () {
+		return EXTFramebufferObject.glGenFramebuffersEXT();
+	}
+
 	public void glGenRenderbuffers (int n, IntBuffer renderbuffers) {
 		EXTFramebufferObject.glGenRenderbuffersEXT(renderbuffers);
 	}
 
+	public int glGenRenderbuffer () {
+		return EXTFramebufferObject.glGenRenderbuffersEXT();
+	}
+
 	public void glGenTextures (int n, IntBuffer textures) {
 		GL11.glGenTextures(textures);
 	}
 
+	public int glGenTexture () {
+		return GL11.glGenTextures();
+	}
+
 	public void glGenerateMipmap (int target) {
 		EXTFramebufferObject.glGenerateMipmapEXT(target);
 	}
@@ -592,6 +652,10 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		GL20.glUniform1(location, v);
 	}
 
+	public void glUniform1fv (int location, int count, float[] v, int offset) {
+		GL20.glUniform1(location, toFloatBuffer(v, offset, count));
+	}
+
 	public void glUniform1i (int location, int x) {
 		GL20.glUniform1i(location, x);
 	}
@@ -600,6 +664,11 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		GL20.glUniform1(location, v);
 	}
 
+	@Override
+	public void glUniform1iv (int location, int count, int[] v, int offset) {
+		GL20.glUniform1(location, toIntBuffer(v, offset, count));
+	}
+
 	public void glUniform2f (int location, float x, float y) {
 		GL20.glUniform2f(location, x, y);
 	}
@@ -608,6 +677,10 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		GL20.glUniform2(location, v);
 	}
 
+	public void glUniform2fv (int location, int count, float[] v, int offset) {
+		GL20.glUniform2(location, toFloatBuffer(v, offset, count << 1));
+	}
+
 	public void glUniform2i (int location, int x, int y) {
 		GL20.glUniform2i(location, x, y);
 	}
@@ -616,6 +689,10 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		GL20.glUniform2(location, v);
 	}
 
+	public void glUniform2iv (int location, int count, int[] v, int offset) {
+		GL20.glUniform2(location, toIntBuffer(v, offset, count << 1));
+	}
+
 	public void glUniform3f (int location, float x, float y, float z) {
 		GL20.glUniform3f(location, x, y, z);
 	}
@@ -624,6 +701,10 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		GL20.glUniform3(location, v);
 	}
 
+	public void glUniform3fv (int location, int count, float[] v, int offset) {
+		GL20.glUniform3(location, toFloatBuffer(v, offset, count * 3));
+	}
+
 	public void glUniform3i (int location, int x, int y, int z) {
 		GL20.glUniform3i(location, x, y, z);
 	}
@@ -632,6 +713,10 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		GL20.glUniform3(location, v);
 	}
 
+	public void glUniform3iv (int location, int count, int[] v, int offset) {
+		GL20.glUniform3(location, toIntBuffer(v, offset, count * 3));
+	}
+
 	public void glUniform4f (int location, float x, float y, float z, float w) {
 		GL20.glUniform4f(location, x, y, z, w);
 	}
@@ -640,6 +725,10 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		GL20.glUniform4(location, v);
 	}
 
+	public void glUniform4fv (int location, int count, float[] v, int offset) {
+		GL20.glUniform4(location, toFloatBuffer(v, offset, count << 2));
+	}
+
 	public void glUniform4i (int location, int x, int y, int z, int w) {
 		GL20.glUniform4i(location, x, y, z, w);
 	}
@@ -648,18 +737,34 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		GL20.glUniform4(location, v);
 	}
 
+	public void glUniform4iv (int location, int count, int[] v, int offset) {
+		GL20.glUniform4(location, toIntBuffer(v, offset, count << 2));
+	}
+
 	public void glUniformMatrix2fv (int location, int count, boolean transpose, FloatBuffer value) {
 		GL20.glUniformMatrix2(location, transpose, value);
 	}
 
+	public void glUniformMatrix2fv (int location, int count, boolean transpose, float[] value, int offset) {
+		GL20.glUniformMatrix2(location, transpose, toFloatBuffer(value, offset, count << 2));
+	}
+
 	public void glUniformMatrix3fv (int location, int count, boolean transpose, FloatBuffer value) {
 		GL20.glUniformMatrix3(location, transpose, value);
 	}
 
+	public void glUniformMatrix3fv (int location, int count, boolean transpose, float[] value, int offset) {
+		GL20.glUniformMatrix3(location, transpose, toFloatBuffer(value, offset, count * 9));
+	}
+
 	public void glUniformMatrix4fv (int location, int count, boolean transpose, FloatBuffer value) {
 		GL20.glUniformMatrix4(location, transpose, value);
 	}
 
+	public void glUniformMatrix4fv (int location, int count, boolean transpose, float[] value, int offset) {
+		GL20.glUniformMatrix4(location, transpose, toFloatBuffer(value, offset, count << 4));
+	}
+
 	public void glUseProgram (int program) {
 		GL20.glUseProgram(program);
 	}
@@ -723,12 +828,8 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 			if (type == GL_FLOAT)
 				GL20.glVertexAttribPointer(indx, size, normalized, stride, (FloatBuffer)buffer);
 			else
-				throw new GdxRuntimeException(
-					"Can't use "
-						+ buffer.getClass().getName()
-						+ " with type "
-						+ type
-						+ " with this method.");
+				throw new GdxRuntimeException("Can't use " + buffer.getClass().getName() + " with type " + type
+					+ " with this method.");
 		} else
 			throw new GdxRuntimeException("Can't use " + buffer.getClass().getName()
 				+ " with this method. Use ByteBuffer instead. Blame LWJGL");
@@ -745,5 +846,4 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 	public void glVertexAttribPointer (int indx, int size, int type, boolean normalized, int stride, int ptr) {
 		GL20.glVertexAttribPointer(indx, size, type, normalized, stride, ptr);
 	}
-
 }
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplication.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplication.java
index 9012832..9a2954b 100644
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplication.java
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplication.java
@@ -43,6 +43,7 @@ import com.badlogic.gdx.Input;
 import com.badlogic.gdx.LifecycleListener;
 import com.badlogic.gdx.Net;
 import com.badlogic.gdx.Preferences;
+import com.badlogic.gdx.backends.iosrobovm.custom.UIScreen;
 import com.badlogic.gdx.backends.iosrobovm.objectal.OALAudioSession;
 import com.badlogic.gdx.backends.iosrobovm.objectal.OALSimpleAudio;
 import com.badlogic.gdx.graphics.GL20;
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplicationConfiguration.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplicationConfiguration.java
index bfe4fae..fb3a5f7 100644
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplicationConfiguration.java
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplicationConfiguration.java
@@ -81,10 +81,15 @@ public class IOSApplicationConfiguration {
 	public boolean useAccelerometer = true;
 	/** the update interval to poll the accelerometer with, in seconds **/
 	public float accelerometerUpdate = 0.05f;
+	/** the update interval to poll the magnetometer with, in seconds **/
+	public float magnetometerUpdate = 0.05f;
 
 	/** whether to use the compass, default true **/
 	public boolean useCompass = true;
 
 	/** whether or not to allow background music from iPod **/
 	public boolean allowIpod = false;
+	
+	/** whether or not the onScreenKeyboard should be closed on return key **/
+	public boolean keyboardCloseOnReturn = true;
 }
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSGLES20.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSGLES20.java
index 56e6691..027529c 100644
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSGLES20.java
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSGLES20.java
@@ -16,11 +16,11 @@
 
 package com.badlogic.gdx.backends.iosrobovm;
 
-import java.nio.Buffer;
-import java.nio.FloatBuffer;
-import java.nio.IntBuffer;
-
-import com.badlogic.gdx.graphics.GL20;
+import java.nio.Buffer;
+import java.nio.FloatBuffer;
+import java.nio.IntBuffer;
+
+import com.badlogic.gdx.graphics.GL20;
 
 public class IOSGLES20 implements GL20
 {	
@@ -89,17 +89,25 @@ public class IOSGLES20 implements GL20
 
 	public native void glCullFace ( int mode );
 
-	public native void glDeleteBuffers ( int n, IntBuffer buffers );
+	public native void glDeleteBuffers ( int n, IntBuffer buffers );
+	
+	public native void glDeleteBuffer(int buffer);
 
-	public native void glDeleteFramebuffers ( int n, IntBuffer framebuffers );
+	public native void glDeleteFramebuffers ( int n, IntBuffer framebuffers );
+	
+	public native void glDeleteFramebuffer(int framebuffer);
 
 	public native void glDeleteProgram ( int program );
 
-	public native void glDeleteRenderbuffers ( int n, IntBuffer renderbuffers );
+	public native void glDeleteRenderbuffers ( int n, IntBuffer renderbuffers );
+	
+	public native void glDeleteRenderbuffer(int renderbuffer);
 
 	public native void glDeleteShader ( int shader );
 
-	public native void glDeleteTextures ( int n, IntBuffer textures );
+	public native void glDeleteTextures ( int n, IntBuffer textures );
+	
+	public native void glDeleteTexture(int texture);
 
 	public native void glDepthFunc ( int func );
 
@@ -133,15 +141,23 @@ public class IOSGLES20 implements GL20
 
 	public native void glFrontFace ( int mode );
 
-	public native void glGenBuffers ( int n, IntBuffer buffers );
+	public native void glGenBuffers ( int n, IntBuffer buffers );
+	
+	public native int glGenBuffer();
 
 	public native void glGenerateMipmap ( int target );
 
-	public native void glGenFramebuffers ( int n, IntBuffer framebuffers );
-
-	public native void glGenRenderbuffers ( int n, IntBuffer renderbuffers );
+	public native void glGenFramebuffers ( int n, IntBuffer framebuffers );
+	
+	public native int glGenFramebuffer();
 
-	public native void glGenTextures ( int n, IntBuffer textures );
+	public native void glGenRenderbuffers ( int n, IntBuffer renderbuffers );
+	
+	public native int glGenRenderbuffer();
+	
+	public native void glGenTextures ( int n, IntBuffer textures );
+	
+	public native int glGenTexture();
 
 	public native String glGetActiveAttrib ( int program, int index, IntBuffer size, Buffer type );
 
@@ -260,40 +276,62 @@ public class IOSGLES20 implements GL20
 	public native void glUniform1f ( int location, float x );
 
 	public native void glUniform1fv ( int location, int count, FloatBuffer v );
-
+
+	public native void glUniform1fv(int location, int count, float[] v, int offset);
+	
 	public native void glUniform1i ( int location, int x );
 
-	public native void glUniform1iv ( int location, int count, IntBuffer v );
+	public native void glUniform1iv ( int location, int count, IntBuffer v );
+	
+	public native void glUniform1iv(int location, int count, int[] v, int offset);
 
 	public native void glUniform2f ( int location, float x, float y );
 
-	public native void glUniform2fv ( int location, int count, FloatBuffer v );
+	public native void glUniform2fv ( int location, int count, FloatBuffer v );
+	
+	public native void glUniform2fv(int location, int count, float[] v, int offset);
 
 	public native void glUniform2i ( int location, int x, int y );
 
-	public native void glUniform2iv ( int location, int count, IntBuffer v );
+	public native void glUniform2iv ( int location, int count, IntBuffer v );
+	
+	public native void glUniform2iv(int location, int count, int[] v, int offset);
 
 	public native void glUniform3f ( int location, float x, float y, float z );
 
-	public native void glUniform3fv ( int location, int count, FloatBuffer v );
+	public native void glUniform3fv ( int location, int count, FloatBuffer v );
+	
+	public native void glUniform3fv(int location, int count, float[] v, int offset);
 
 	public native void glUniform3i ( int location, int x, int y, int z );
 
-	public native void glUniform3iv ( int location, int count, IntBuffer v );
-
+	public native void glUniform3iv ( int location, int count, IntBuffer v );
+	
+	public native void glUniform3iv(int location, int count, int[] v, int offset);
+	
 	public native void glUniform4f ( int location, float x, float y, float z, float w );
 
-	public native void glUniform4fv ( int location, int count, FloatBuffer v );
+	public native void glUniform4fv ( int location, int count, FloatBuffer v );
+	
+	public native void glUniform4fv(int location, int count, float[] v, int offset);
 
 	public native void glUniform4i ( int location, int x, int y, int z, int w );
 
-	public native void glUniform4iv ( int location, int count, IntBuffer v );
+	public native void glUniform4iv ( int location, int count, IntBuffer v );
+	
+	public native void glUniform4iv(int location, int count, int[] v, int offset);
 
-	public native void glUniformMatrix2fv ( int location, int count, boolean transpose, FloatBuffer value );
+	public native void glUniformMatrix2fv ( int location, int count, boolean transpose, FloatBuffer value );
+	
+	public native void glUniformMatrix2fv(int location, int count, boolean transpose, float[] value, int offset);
 
-	public native void glUniformMatrix3fv ( int location, int count, boolean transpose, FloatBuffer value );
+	public native void glUniformMatrix3fv ( int location, int count, boolean transpose, FloatBuffer value );
+	
+	public native void glUniformMatrix3fv(int location, int count, boolean transpose, float[] value, int offset);
 
-	public native void glUniformMatrix4fv ( int location, int count, boolean transpose, FloatBuffer value );
+	public native void glUniformMatrix4fv ( int location, int count, boolean transpose, FloatBuffer value );
+	
+	public native void glUniformMatrix4fv(int location, int count, boolean transpose, float[] value, int offset);
 
 	public native void glUseProgram ( int program );
 
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSInput.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSInput.java
index 9980ce8..ae19368 100644
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSInput.java
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSInput.java
@@ -19,13 +19,14 @@ package com.badlogic.gdx.backends.iosrobovm;
 import org.robovm.apple.audiotoolbox.AudioServices;
 import org.robovm.apple.coregraphics.CGPoint;
 import org.robovm.apple.coregraphics.CGRect;
+import org.robovm.apple.coremotion.CMAccelerometerData;
+import org.robovm.apple.coremotion.CMMagnetometerData;
+import org.robovm.apple.coremotion.CMMotionManager;
+import org.robovm.apple.foundation.NSError;
 import org.robovm.apple.foundation.NSExtensions;
 import org.robovm.apple.foundation.NSObject;
+import org.robovm.apple.foundation.NSOperationQueue;
 import org.robovm.apple.foundation.NSRange;
-import org.robovm.apple.uikit.UIAcceleration;
-import org.robovm.apple.uikit.UIAccelerometer;
-import org.robovm.apple.uikit.UIAccelerometerDelegate;
-import org.robovm.apple.uikit.UIAccelerometerDelegateAdapter;
 import org.robovm.apple.uikit.UIAlertView;
 import org.robovm.apple.uikit.UIAlertViewDelegate;
 import org.robovm.apple.uikit.UIAlertViewDelegateAdapter;
@@ -45,6 +46,7 @@ import org.robovm.apple.uikit.UITextSpellCheckingType;
 import org.robovm.apple.uikit.UITouch;
 import org.robovm.apple.uikit.UITouchPhase;
 import org.robovm.objc.annotation.Method;
+import org.robovm.objc.block.VoidBlock2;
 import org.robovm.rt.VM;
 import org.robovm.rt.bro.NativeObject;
 import org.robovm.rt.bro.annotation.MachineSizedUInt;
@@ -52,9 +54,9 @@ import org.robovm.rt.bro.annotation.Pointer;
 
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.Input;
-import com.badlogic.gdx.Input.TextInputListener;
 import com.badlogic.gdx.InputProcessor;
 import com.badlogic.gdx.graphics.Pixmap;
+import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 import com.badlogic.gdx.utils.Pool;
@@ -85,8 +87,6 @@ public class IOSInput implements Input {
 	}
 
 	private static final NSObjectWrapper<UITouch> UI_TOUCH_WRAPPER = new NSObjectWrapper<UITouch>(UITouch.class);
-	static final NSObjectWrapper<UIAcceleration> UI_ACCELERATION_WRAPPER = new NSObjectWrapper<UIAcceleration>(
-		UIAcceleration.class);
 
 	IOSApplication app;
 	IOSApplicationConfiguration config;
@@ -107,18 +107,23 @@ public class IOSInput implements Input {
 	Array<TouchEvent> touchEvents = new Array<TouchEvent>();
 	TouchEvent currentEvent = null;
 	float[] acceleration = new float[3];
+	float[] rotation = new float[3];
+	float[] R = new float[9];
 	InputProcessor inputProcessor = null;
-	// We need to hold on to the reference to this delegate or else its
-	// ObjC peer will get released when the Java peer is GCed.
-	UIAccelerometerDelegate accelerometerDelegate;
+
 	boolean hasVibrator;
+	CMMotionManager motionManager;
+	boolean compassSupported;
+	boolean keyboardCloseOnReturn;
 
 	public IOSInput (IOSApplication app) {
 		this.app = app;
 		this.config = app.config;
+		this.keyboardCloseOnReturn = app.config.keyboardCloseOnReturn;
 	}
 
 	void setupPeripherals () {
+		motionManager = new CMMotionManager();
 		setupAccelerometer();
 		setupCompass();
 		UIDevice device = UIDevice.getCurrentDevice();
@@ -127,30 +132,79 @@ public class IOSInput implements Input {
 
 	private void setupCompass () {
 		if (config.useCompass) {
-			// FIXME implement compass
+			setupMagnetometer();
 		}
 	}
 
 	private void setupAccelerometer () {
 		if (config.useAccelerometer) {
-			accelerometerDelegate = new UIAccelerometerDelegateAdapter() {
-
-				@Method(selector = "accelerometer:didAccelerate:")
-				public void didAccelerate (UIAccelerometer accelerometer, @Pointer long valuesPtr) {
-					UIAcceleration values = UI_ACCELERATION_WRAPPER.wrap(valuesPtr);
-					float x = (float)values.getX() * 10;
-					float y = (float)values.getY() * 10;
-					float z = (float)values.getZ() * 10;
-
-					acceleration[0] = -x;
-					acceleration[1] = -y;
-					acceleration[2] = -z;
+			motionManager.setAccelerometerUpdateInterval(config.accelerometerUpdate);			
+			VoidBlock2<CMAccelerometerData, NSError> accelVoid = new VoidBlock2<CMAccelerometerData, NSError>() {
+				@Override
+				public void invoke(CMAccelerometerData accelData, NSError error) {
+					updateAccelerometer(accelData);					
 				}
 			};
-			UIAccelerometer.getSharedAccelerometer().setDelegate(accelerometerDelegate);
-			UIAccelerometer.getSharedAccelerometer().setUpdateInterval(config.accelerometerUpdate);
+			motionManager.startAccelerometerUpdates(new NSOperationQueue(), accelVoid);
 		}
 	}
+	
+	private void setupMagnetometer () {
+		if (motionManager.isMagnetometerAvailable() && config.useCompass) compassSupported = true;
+		else return;
+		motionManager.setMagnetometerUpdateInterval(config.magnetometerUpdate);
+		VoidBlock2<CMMagnetometerData, NSError> magnetVoid = new VoidBlock2<CMMagnetometerData, NSError>() {
+			@Override
+			public void invoke(CMMagnetometerData magnetData, NSError error) {
+				updateRotation(magnetData);
+			}
+		};
+		motionManager.startMagnetometerUpdates(new NSOperationQueue(), magnetVoid);
+	}
+	
+	private void updateAccelerometer (CMAccelerometerData data) {
+		float x = (float) data.getAcceleration().x() * 10f;
+		float y = (float) data.getAcceleration().y() * 10f;
+		float z = (float) data.getAcceleration().z() * 10f;
+		acceleration[0] = -x;
+		acceleration[1] = -y;
+		acceleration[2] = -z;
+	}
+	
+	private void updateRotation (CMMagnetometerData data) {
+		final float eX = (float) data.getMagneticField().x();
+		final float eY = (float) data.getMagneticField().y();
+		final float eZ = (float) data.getMagneticField().z();
+				
+		float gX = acceleration[0];
+		float gY = acceleration[1];
+		float gZ = acceleration[2];
+		
+		float cX = eY * gZ - eZ * gY;
+		float cY = eZ * gX - eX * gZ;
+		float cZ = eX * gY - eY * gX;
+		
+		final float normal = (float) Math.sqrt(cX * cX + cY * cY + cZ * cZ);
+		final float invertC = 1.0f / normal;
+		cX *= invertC;
+		cY *= invertC;
+		cZ *= invertC;
+		final float invertG = 1.0f / (float) Math.sqrt(gX * gX + gY * gY + gZ * gZ);
+		gX *= invertG;
+		gY *= invertG;
+		gZ *= invertG;
+		final float mX = gY * cZ - gZ * cY;
+		final float mY = gZ * cX - gX * cZ;
+		final float mZ = gX * cY - gY * cX;
+		
+		R[0] = cX;	R[1] = cY;	R[2] = cZ;
+		R[3] = mX;	R[4] = mY;	R[5] = mZ;
+		R[6] = gX;	R[7] = gY;	R[8] = gZ;
+		
+		rotation[0] = (float) Math.atan2(R[1], R[4]) * MathUtils.radDeg;
+		rotation[1] = (float) Math.asin(-R[7]) * MathUtils.radDeg;
+		rotation[2] = (float) Math.atan2(-R[6], R[8]) * MathUtils.radDeg;
+	}
 
 	@Override
 	public float getAccelerometerX () {
@@ -169,25 +223,26 @@ public class IOSInput implements Input {
 
 	@Override
 	public float getAzimuth () {
-		// FIXME implement this
-		return 0;
+		if (!compassSupported) return 0;
+		return rotation[0];
 	}
 
 	@Override
 	public float getPitch () {
-		// FIXME implement this
-		return 0;
+		if (!compassSupported) return 0;
+		return rotation[1];
 	}
 
 	@Override
 	public float getRoll () {
-		// FIXME implement this
-		return 0;
+		if (!compassSupported) return 0;
+		return rotation[2];
 	}
 
 	@Override
 	public void getRotationMatrix (float[] matrix) {
-		// FIXME implement this
+		if (matrix.length != 9) return;
+		//TODO implement when azimuth is fixed
 	}
 
 	@Override
@@ -329,7 +384,9 @@ public class IOSInput implements Input {
 
 		@Override
 		public boolean shouldReturn (UITextField textField) {
-			textField.resignFirstResponder();
+			if (keyboardCloseOnReturn) setOnscreenKeyboardVisible(false);
+			app.input.inputProcessor.keyDown(Keys.ENTER);
+			app.input.inputProcessor.keyTyped((char)13);
 			Gdx.graphics.requestRendering();
 			return false;
 		}
@@ -337,20 +394,7 @@ public class IOSInput implements Input {
 
 	@Override
 	public void setOnscreenKeyboardVisible (boolean visible) {
-		if (textfield == null) {
-			// Making simple textField
-			textfield = new UITextField(new CGRect(10, 10, 100, 50));
-			// Setting parameters
-			textfield.setKeyboardType(UIKeyboardType.Default);
-			textfield.setReturnKeyType(UIReturnKeyType.Done);
-			textfield.setAutocapitalizationType(UITextAutocapitalizationType.None);
-			textfield.setAutocorrectionType(UITextAutocorrectionType.No);
-			textfield.setSpellCheckingType(UITextSpellCheckingType.No);
-			textfield.setHidden(true);
-			// Text field needs to have at least one symbol - so we can use backspace
-			textfield.setText("x");
-			app.getUIViewController().getView().addSubview(textfield);
-		}
+		if (textfield == null) createDefaultTextField();
 		if (visible) {
 			textfield.becomeFirstResponder();
 			textfield.setDelegate(textDelegate);
@@ -358,7 +402,35 @@ public class IOSInput implements Input {
 			textfield.resignFirstResponder();
 		}
 	}
-
+	
+	/**
+	 * Set the keyboard to close when the UITextField return key is pressed
+	 * @param shouldClose Whether or not the keyboard should clsoe on return key press
+	 */
+	public void setKeyboardCloseOnReturnKey (boolean shouldClose) {
+		keyboardCloseOnReturn = shouldClose;
+	}
+	
+	public UITextField getKeyboardTextField () {
+		if (textfield == null) createDefaultTextField();
+		return textfield;
+	}
+	
+	private void createDefaultTextField () {
+		textfield = new UITextField(new CGRect(10, 10, 100, 50));
+		//Parameters
+		// Setting parameters
+		textfield.setKeyboardType(UIKeyboardType.Default);
+		textfield.setReturnKeyType(UIReturnKeyType.Done);
+		textfield.setAutocapitalizationType(UITextAutocapitalizationType.None);
+		textfield.setAutocorrectionType(UITextAutocorrectionType.No);
+		textfield.setSpellCheckingType(UITextSpellCheckingType.No);
+		textfield.setHidden(true);
+		// Text field needs to have at least one symbol - so we can use backspace
+		textfield.setText("x");
+		app.getUIViewController().getView().addSubview(textfield);
+	}
+	
 	// Issue 773 indicates this may solve a premature GC issue
 	UIAlertViewDelegate delegate;
 
@@ -452,11 +524,8 @@ public class IOSInput implements Input {
 		if (peripheral == Peripheral.Accelerometer && config.useAccelerometer) return true;
 		if (peripheral == Peripheral.MultitouchScreen) return true;
 		if (peripheral == Peripheral.Vibrator) return hasVibrator;
-		// FIXME implement this (not sure if possible)
+		if (peripheral == Peripheral.Compass) return compassSupported;
 		// if(peripheral == Peripheral.OnscreenKeyboard) return true;
-		// FIXME implement this
-		// if(peripheral == Peripheral.Compass) return true;
-
 		return false;
 	}
 
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSSound.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSSound.java
index f54f848..19b3336 100644
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSSound.java
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSSound.java
@@ -16,24 +16,34 @@
 
 package com.badlogic.gdx.backends.iosrobovm;
 
+import org.robovm.apple.foundation.NSArray;
+
 import com.badlogic.gdx.audio.Sound;
 import com.badlogic.gdx.backends.iosrobovm.objectal.ALBuffer;
+import com.badlogic.gdx.backends.iosrobovm.objectal.ALChannelSource;
 import com.badlogic.gdx.backends.iosrobovm.objectal.ALSource;
 import com.badlogic.gdx.backends.iosrobovm.objectal.OALSimpleAudio;
 import com.badlogic.gdx.files.FileHandle;
+import com.badlogic.gdx.utils.IntArray;
 
 /** @author tescott
+ *  @author Tomski
  * 
  *         First pass at implementing OALSimpleAudio support. */
 public class IOSSound implements Sound {
 
-	private ALSource soundSource;
 	private ALBuffer soundBuffer;
 	private String soundPath;
-
+	
+	private ALChannelSource channel;
+	private NSArray<ALSource> sourcePool;
+	private IntArray streamIds = new IntArray(8);
+	
 	public IOSSound (FileHandle filePath) {
 		soundPath = filePath.file().getPath().replace('\\', '/');
 		soundBuffer = OALSimpleAudio.sharedInstance().preloadEffect(soundPath);
+		channel = OALSimpleAudio.sharedInstance().getChannelSource();
+		sourcePool = channel.getSourcePool().getSources();
 	}
 
 	@Override
@@ -52,8 +62,11 @@ public class IOSSound implements Sound {
 	}
 
 	public long play (float volume, float pitch, float pan, boolean loop) {
-		soundSource = OALSimpleAudio.sharedInstance().playEffect(soundPath, volume, pitch, pan, loop);
-		return 0;
+		if (streamIds.size == 8) streamIds.pop();
+		ALSource soundSource = OALSimpleAudio.sharedInstance().playEffect(soundPath, volume, pitch, pan, loop);
+		if (soundSource.getSourceId() == -1) return -1;
+		streamIds.insert(0, soundSource.getSourceId());
+		return soundSource.getSourceId();
 	}
 
 	@Override
@@ -73,7 +86,10 @@ public class IOSSound implements Sound {
 
 	@Override
 	public void stop () {
-		if (soundSource != null) soundSource.stop();
+		ALSource source;
+		for (int i = 0; i < streamIds.size; i++) {
+			if ((source = getSoundSource(streamIds.get(i))) != null) source.stop();
+		}
 	}
 
 	@Override
@@ -83,58 +99,74 @@ public class IOSSound implements Sound {
 
 	@Override
 	public void stop (long soundId) {
-		// we should do something to give an id for each sound.
-		stop();
+		ALSource source;
+		if ((source = getSoundSource(soundId)) != null) source.stop();
 	}
 
 	@Override
 	public void setLooping (long soundId, boolean looping) {
-		if (soundSource != null) soundSource.setLooping(looping);
+		ALSource source;
+		if ((source = getSoundSource(soundId)) != null) source.setLooping(looping);
 	}
 
 	@Override
 	public void setPitch (long soundId, float pitch) {
-		if (soundSource != null) soundSource.setPitch(pitch);
+		ALSource source;
+		if ((source = getSoundSource(soundId)) != null) source.setPitch(pitch);
 	}
 
 	@Override
 	public void setVolume (long soundId, float volume) {
-		if (soundSource != null) soundSource.setVolume(volume);
+		ALSource source;
+		if ((source = getSoundSource(soundId)) != null) source.setVolume(volume);
 	}
 
 	@Override
 	public void setPan (long soundId, float pan, float volume) {
-		if (soundSource != null) {
-			soundSource.setPan(pan);
-			soundSource.setVolume(volume);
+		ALSource source;
+		if ((source = getSoundSource(soundId)) != null) {
+			source.setPan(pan);
+			source.setVolume(volume);
 		}
 	}
 
 	@Override
 	public void setPriority (long soundId, int priority) {
 		// TODO Auto-generated method stub
-
 	}
 
 	@Override
 	public void pause () {
-		if (soundSource != null) soundSource.setPaused(true);
+		ALSource source;
+		for (int i = 0; i < streamIds.size; i++) {
+			if ((source = getSoundSource(streamIds.get(i))) != null) source.setPaused(true);
+		}
 	}
 
 	@Override
 	public void resume () {
-		if (soundSource != null) soundSource.setPaused(false);
+		ALSource source;
+		for (int i = 0; i < streamIds.size; i++) {
+			if ((source = getSoundSource(streamIds.get(i))) != null) source.setPaused(false);
+		}
 	}
 
 	@Override
 	public void pause (long soundId) {
-		// we should do something to give an id for each sound.
-		pause();
+		ALSource source;
+		if ((source = getSoundSource(soundId)) != null) source.setPaused(true);
 	}
 
 	@Override
 	public void resume (long soundId) {
-		// we should do something to give an id for each sound.
-		resume();
+		ALSource source;
+		if ((source = getSoundSource(soundId)) != null) source.setPaused(false);
+	}
+	
+	private ALSource getSoundSource (long soundId) {	
+		for (ALSource source : sourcePool) {
+			if (source.getSourceId() == soundId) return source;			
+		}
+		return null;
 	}
 }
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/UIScreen.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/UIScreen.java
deleted file mode 100644
index 8ba5886..0000000
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/UIScreen.java
+++ /dev/null
@@ -1,216 +0,0 @@
-/*
- * Copyright (C) 2014 Trillian Mobile AB
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.badlogic.gdx.backends.iosrobovm;
-
-/*<imports>*/
-import java.io.*;
-import java.nio.*;
-import java.util.*;
-
-import org.robovm.objc.*;
-import org.robovm.objc.annotation.*;
-import org.robovm.objc.block.*;
-import org.robovm.rt.*;
-import org.robovm.rt.bro.*;
-import org.robovm.rt.bro.annotation.*;
-import org.robovm.rt.bro.ptr.*;
-import org.robovm.apple.foundation.*;
-import org.robovm.apple.uikit.UIScreenMode;
-import org.robovm.apple.uikit.UIScreenOverscanCompensation;
-import org.robovm.apple.uikit.UIView;
-import org.robovm.apple.coreanimation.*;
-import org.robovm.apple.coregraphics.*;
-import org.robovm.apple.coredata.*;
-import org.robovm.apple.coreimage.*;
-import org.robovm.apple.coretext.*;
-/*</imports>*/
-
-/*<javadoc>*/
-/**
- * @since Available in iOS 2.0 and later.
- */
-/*</javadoc>*/
-/*<annotations>*/@Library("UIKit") @NativeClass/*</annotations>*/
-/*<visibility>*/public/*</visibility>*/ class /*<name>*/UIScreen/*</name>*/ 
-    extends /*<extends>*/NSObject/*</extends>*/ 
-    /*<implements>*//*</implements>*/ {
-
-    public static class Notifications {
-        /**
-         * @since Available in iOS 3.2 and later.
-         */
-        public static NSObject observeDidConnect(final VoidBlock1<UIScreen> block) {
-            return NSNotificationCenter.getDefaultCenter().addObserver(DidConnectNotification(), null, NSOperationQueue.getMainQueue(), new VoidBlock1<NSNotification>() {
-                @Override
-                public void invoke(NSNotification a) {
-                    block.invoke((UIScreen) a.getObject());
-                }
-            });
-        }
-        /**
-         * @since Available in iOS 3.2 and later.
-         */
-        public static NSObject observeDidDisconnect(final VoidBlock1<UIScreen> block) {
-            return NSNotificationCenter.getDefaultCenter().addObserver(DidDisconnectNotification(), null, NSOperationQueue.getMainQueue(), new VoidBlock1<NSNotification>() {
-                @Override
-                public void invoke(NSNotification a) {
-                    block.invoke((UIScreen) a.getObject());
-                }
-            });
-        }
-        /**
-         * @since Available in iOS 3.2 and later.
-         */
-        public static NSObject observeModeDidChange(final VoidBlock1<UIScreen> block) {
-            return NSNotificationCenter.getDefaultCenter().addObserver(ModeDidChangeNotification(), null, NSOperationQueue.getMainQueue(), new VoidBlock1<NSNotification>() {
-                @Override
-                public void invoke(NSNotification a) {
-                    block.invoke((UIScreen) a.getObject());
-                }
-            });
-        }
-        /**
-         * @since Available in iOS 5.0 and later.
-         */
-        public static NSObject observeBrightnessDidChange(final VoidBlock1<UIScreen> block) {
-            return NSNotificationCenter.getDefaultCenter().addObserver(BrightnessDidChangeNotification(), null, NSOperationQueue.getMainQueue(), new VoidBlock1<NSNotification>() {
-                @Override
-                public void invoke(NSNotification a) {
-                    block.invoke((UIScreen) a.getObject());
-                }
-            });
-        }
-    }
-    /*<ptr>*/public static class UIScreenPtr extends Ptr<UIScreen, UIScreenPtr> {}/*</ptr>*/
-    /*<bind>*/static { ObjCRuntime.bind(UIScreen.class); }/*</bind>*/
-    /*<constants>*//*</constants>*/
-    /*<constructors>*/
-    public UIScreen() {}
-    protected UIScreen(SkipInit skipInit) { super(skipInit); }
-    /*</constructors>*/
-    /*<properties>*/
-    @Property(selector = "bounds")
-    public native @ByVal CGRect getBounds();
-    @Property(selector = "applicationFrame")
-    public native @ByVal CGRect getApplicationFrame();
-    /**
-     * @since Available in iOS 4.0 and later.
-     */
-    @Property(selector = "scale")
-    public native @MachineSizedFloat double getScale();
-    /**
-     * @since Available in iOS 4.0 and later.
-     */
-    @Property(selector = "nativeScale")
-    public native @MachineSizedFloat double getNativeScale();
-    /**
-     * @since Available in iOS 3.2 and later.
-     */
-    @Property(selector = "availableModes")
-    public native NSArray<UIScreenMode> getAvailableModes();
-    /**
-     * @since Available in iOS 4.3 and later.
-     */
-    @Property(selector = "preferredMode")
-    public native UIScreenMode getPreferredMode();
-    /**
-     * @since Available in iOS 3.2 and later.
-     */
-    @Property(selector = "currentMode")
-    public native UIScreenMode getCurrentMode();
-    /**
-     * @since Available in iOS 3.2 and later.
-     */
-    @Property(selector = "setCurrentMode:")
-    public native void setCurrentMode(UIScreenMode v);
-    /**
-     * @since Available in iOS 5.0 and later.
-     */
-    @Property(selector = "overscanCompensation")
-    public native UIScreenOverscanCompensation getOverscanCompensation();
-    /**
-     * @since Available in iOS 5.0 and later.
-     */
-    @Property(selector = "setOverscanCompensation:")
-    public native void setOverscanCompensation(UIScreenOverscanCompensation v);
-    /**
-     * @since Available in iOS 4.3 and later.
-     */
-    @Property(selector = "mirroredScreen")
-    public native UIScreen getMirroredScreen();
-    /**
-     * @since Available in iOS 5.0 and later.
-     */
-    @Property(selector = "brightness")
-    public native @MachineSizedFloat double getBrightness();
-    /**
-     * @since Available in iOS 5.0 and later.
-     */
-    @Property(selector = "setBrightness:")
-    public native void setBrightness(@MachineSizedFloat double v);
-    /**
-     * @since Available in iOS 5.0 and later.
-     */
-    @Property(selector = "wantsSoftwareDimming")
-    public native boolean isWantsSoftwareDimming();
-    /**
-     * @since Available in iOS 5.0 and later.
-     */
-    @Property(selector = "setWantsSoftwareDimming:")
-    public native void setWantsSoftwareDimming(boolean v);
-    /*</properties>*/
-    /*<members>*//*</members>*/
-    /*<methods>*/
-    /**
-     * @since Available in iOS 3.2 and later.
-     */
-    @GlobalValue(symbol="UIScreenDidConnectNotification", optional=true)
-    public static native NSString DidConnectNotification();
-    /**
-     * @since Available in iOS 3.2 and later.
-     */
-    @GlobalValue(symbol="UIScreenDidDisconnectNotification", optional=true)
-    public static native NSString DidDisconnectNotification();
-    /**
-     * @since Available in iOS 3.2 and later.
-     */
-    @GlobalValue(symbol="UIScreenModeDidChangeNotification", optional=true)
-    public static native NSString ModeDidChangeNotification();
-    /**
-     * @since Available in iOS 5.0 and later.
-     */
-    @GlobalValue(symbol="UIScreenBrightnessDidChangeNotification", optional=true)
-    public static native NSString BrightnessDidChangeNotification();
-    
-    /**
-     * @since Available in iOS 4.0 and later.
-     */
-    @Method(selector = "displayLinkWithTarget:selector:")
-    public native CADisplayLink createDisplayLink(NSObject target, Selector sel);
-    /**
-     * @since Available in iOS 3.2 and later.
-     */
-    @Method(selector = "screens")
-    public static native NSArray<UIScreen> getScreens();
-    @Method(selector = "mainScreen")
-    public static native UIScreen getMainScreen();
-    /**
-     * @since Available in iOS 7.0 and later.
-     */
-    @Method(selector = "snapshotViewAfterScreenUpdates:")
-    public native UIView snapshotView(boolean afterUpdates);
-    /*</methods>*/
-}
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAcceleration.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAcceleration.java
new file mode 100644
index 0000000..101b337
--- /dev/null
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAcceleration.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2014 Trillian Mobile AB
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.badlogic.gdx.backends.iosrobovm.custom;
+
+/*<imports>*/
+import java.io.*;
+import java.nio.*;
+import java.util.*;
+import org.robovm.objc.*;
+import org.robovm.objc.annotation.*;
+import org.robovm.objc.block.*;
+import org.robovm.rt.*;
+import org.robovm.rt.bro.*;
+import org.robovm.rt.bro.annotation.*;
+import org.robovm.rt.bro.ptr.*;
+import org.robovm.apple.foundation.*;
+import org.robovm.apple.coreanimation.*;
+import org.robovm.apple.coregraphics.*;
+import org.robovm.apple.coredata.*;
+import org.robovm.apple.coreimage.*;
+import org.robovm.apple.coretext.*;
+import org.robovm.apple.corelocation.*;
+/*</imports>*/
+
+/*<javadoc>*/
+/**
+ * @since Available in iOS 2.0 and later.
+ * @deprecated Deprecated in iOS 5.0.
+ */
+@Deprecated
+/*</javadoc>*/
+/*<annotations>*/@Library("UIKit") @NativeClass/*</annotations>*/
+/*<visibility>*/public/*</visibility>*/ class /*<name>*/UIAcceleration/*</name>*/ 
+    extends /*<extends>*/NSObject/*</extends>*/ 
+    /*<implements>*//*</implements>*/ {
+
+    /*<ptr>*/public static class UIAccelerationPtr extends Ptr<UIAcceleration, UIAccelerationPtr> {}/*</ptr>*/
+    /*<bind>*/static { ObjCRuntime.bind(UIAcceleration.class); }/*</bind>*/
+    /*<constants>*//*</constants>*/
+    /*<constructors>*/
+    public UIAcceleration() {}
+    protected UIAcceleration(SkipInit skipInit) { super(skipInit); }
+    /*</constructors>*/
+    /*<properties>*/
+    @Property(selector = "timestamp")
+    public native double getTimestamp();
+    @Property(selector = "x")
+    public native double getX();
+    @Property(selector = "y")
+    public native double getY();
+    @Property(selector = "z")
+    public native double getZ();
+    /*</properties>*/
+    /*<members>*//*</members>*/
+    /*<methods>*/
+    
+    /*</methods>*/
+}
\ No newline at end of file
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAccelerometer.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAccelerometer.java
new file mode 100644
index 0000000..a848f21
--- /dev/null
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAccelerometer.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2014 Trillian Mobile AB
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.badlogic.gdx.backends.iosrobovm.custom;
+
+/*<imports>*/
+import java.io.*;
+import java.nio.*;
+import java.util.*;
+import org.robovm.objc.*;
+import org.robovm.objc.annotation.*;
+import org.robovm.objc.block.*;
+import org.robovm.rt.*;
+import org.robovm.rt.bro.*;
+import org.robovm.rt.bro.annotation.*;
+import org.robovm.rt.bro.ptr.*;
+import org.robovm.apple.foundation.*;
+import org.robovm.apple.coreanimation.*;
+import org.robovm.apple.coregraphics.*;
+import org.robovm.apple.coredata.*;
+import org.robovm.apple.coreimage.*;
+import org.robovm.apple.coretext.*;
+import org.robovm.apple.corelocation.*;
+/*</imports>*/
+
+/*<javadoc>*/
+/**
+ * @since Available in iOS 2.0 and later.
+ * @deprecated Deprecated in iOS 5.0.
+ */
+@Deprecated
+/*</javadoc>*/
+/*<annotations>*/@Library("UIKit") @NativeClass/*</annotations>*/
+/*<visibility>*/public/*</visibility>*/ class /*<name>*/UIAccelerometer/*</name>*/ 
+    extends /*<extends>*/NSObject/*</extends>*/ 
+    /*<implements>*//*</implements>*/ {
+
+    /*<ptr>*/public static class UIAccelerometerPtr extends Ptr<UIAccelerometer, UIAccelerometerPtr> {}/*</ptr>*/
+    /*<bind>*/static { ObjCRuntime.bind(UIAccelerometer.class); }/*</bind>*/
+    /*<constants>*//*</constants>*/
+    /*<constructors>*/
+    public UIAccelerometer() {}
+    protected UIAccelerometer(SkipInit skipInit) { super(skipInit); }
+    /*</constructors>*/
+    /*<properties>*/
+    @Property(selector = "updateInterval")
+    public native double getUpdateInterval();
+    @Property(selector = "setUpdateInterval:")
+    public native void setUpdateInterval(double v);
+    @Property(selector = "delegate")
+    public native UIAccelerometerDelegate getDelegate();
+    @Property(selector = "setDelegate:", strongRef = true)
+    public native void setDelegate(UIAccelerometerDelegate v);
+    /*</properties>*/
+    /*<members>*//*</members>*/
+    /*<methods>*/
+    @Method(selector = "sharedAccelerometer")
+    public static native UIAccelerometer getSharedAccelerometer();
+    /*</methods>*/
+}
\ No newline at end of file
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAccelerometerDelegate.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAccelerometerDelegate.java
new file mode 100644
index 0000000..72c2628
--- /dev/null
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAccelerometerDelegate.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2014 Trillian Mobile AB
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.badlogic.gdx.backends.iosrobovm.custom;
+
+/*<imports>*/
+import java.io.*;
+import java.nio.*;
+import java.util.*;
+import org.robovm.objc.*;
+import org.robovm.objc.annotation.*;
+import org.robovm.objc.block.*;
+import org.robovm.rt.*;
+import org.robovm.rt.bro.*;
+import org.robovm.rt.bro.annotation.*;
+import org.robovm.rt.bro.ptr.*;
+import org.robovm.apple.foundation.*;
+import org.robovm.apple.coreanimation.*;
+import org.robovm.apple.coregraphics.*;
+import org.robovm.apple.coredata.*;
+import org.robovm.apple.coreimage.*;
+import org.robovm.apple.coretext.*;
+import org.robovm.apple.corelocation.*;
+/*</imports>*/
+
+/*<javadoc>*/
+
+/*</javadoc>*/
+/*<annotations>*//*</annotations>*/
+/*<visibility>*/public/*</visibility>*/ interface /*<name>*/UIAccelerometerDelegate/*</name>*/ 
+    /*<implements>*/extends NSObjectProtocol/*</implements>*/ {
+
+    /*<ptr>*/
+    /*</ptr>*/
+    /*<bind>*/
+    /*</bind>*/
+    /*<constants>*//*</constants>*/
+    /*<properties>*/
+    
+    /*</properties>*/
+    /*<methods>*/
+    /**
+     * @since Available in iOS 2.0 and later.
+     * @deprecated Deprecated in iOS 5.0.
+     */
+    @Deprecated
+    @Method(selector = "accelerometer:didAccelerate:")
+    void didAccelerate(UIAccelerometer accelerometer, UIAcceleration acceleration);
+    /*</methods>*/
+    /*<adapter>*/
+    /*</adapter>*/
+}
\ No newline at end of file
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAccelerometerDelegateAdapter.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAccelerometerDelegateAdapter.java
new file mode 100644
index 0000000..5808172
--- /dev/null
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAccelerometerDelegateAdapter.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2014 Trillian Mobile AB
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.badlogic.gdx.backends.iosrobovm.custom;
+
+/*<imports>*/
+import java.io.*;
+import java.nio.*;
+import java.util.*;
+import org.robovm.objc.*;
+import org.robovm.objc.annotation.*;
+import org.robovm.objc.block.*;
+import org.robovm.rt.*;
+import org.robovm.rt.bro.*;
+import org.robovm.rt.bro.annotation.*;
+import org.robovm.rt.bro.ptr.*;
+import org.robovm.apple.foundation.*;
+import org.robovm.apple.coreanimation.*;
+import org.robovm.apple.coregraphics.*;
+import org.robovm.apple.coredata.*;
+import org.robovm.apple.coreimage.*;
+import org.robovm.apple.coretext.*;
+import org.robovm.apple.corelocation.*;
+/*</imports>*/
+
+/*<javadoc>*/
+/*</javadoc>*/
+/*<annotations>*//*</annotations>*/
+/*<visibility>*/public/*</visibility>*/ class /*<name>*/UIAccelerometerDelegateAdapter/*</name>*/ 
+    extends /*<extends>*/NSObject/*</extends>*/ 
+    /*<implements>*/implements UIAccelerometerDelegate/*</implements>*/ {
+
+    /*<ptr>*/
+    /*</ptr>*/
+    /*<bind>*/
+    /*</bind>*/
+    /*<constants>*//*</constants>*/
+    /*<constructors>*//*</constructors>*/
+    /*<properties>*/
+    
+    /*</properties>*/
+    /*<members>*//*</members>*/
+    /*<methods>*/
+    /**
+     * @since Available in iOS 2.0 and later.
+     * @deprecated Deprecated in iOS 5.0.
+     */
+    @Deprecated
+    @NotImplemented("accelerometer:didAccelerate:")
+    public void didAccelerate(UIAccelerometer accelerometer, UIAcceleration acceleration) { throw new UnsupportedOperationException(); }
+    /*</methods>*/
+}
\ No newline at end of file
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIScreen.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIScreen.java
new file mode 100644
index 0000000..287bdd6
--- /dev/null
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIScreen.java
@@ -0,0 +1,216 @@
+/*
+ * Copyright (C) 2014 Trillian Mobile AB
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.badlogic.gdx.backends.iosrobovm.custom;
+
+/*<imports>*/
+import java.io.*;
+import java.nio.*;
+import java.util.*;
+
+import org.robovm.objc.*;
+import org.robovm.objc.annotation.*;
+import org.robovm.objc.block.*;
+import org.robovm.rt.*;
+import org.robovm.rt.bro.*;
+import org.robovm.rt.bro.annotation.*;
+import org.robovm.rt.bro.ptr.*;
+import org.robovm.apple.foundation.*;
+import org.robovm.apple.uikit.UIScreenMode;
+import org.robovm.apple.uikit.UIScreenOverscanCompensation;
+import org.robovm.apple.uikit.UIView;
+import org.robovm.apple.coreanimation.*;
+import org.robovm.apple.coregraphics.*;
+import org.robovm.apple.coredata.*;
+import org.robovm.apple.coreimage.*;
+import org.robovm.apple.coretext.*;
+/*</imports>*/
+
+/*<javadoc>*/
+/**
+ * @since Available in iOS 2.0 and later.
+ */
+/*</javadoc>*/
+/*<annotations>*/@Library("UIKit") @NativeClass/*</annotations>*/
+/*<visibility>*/public/*</visibility>*/ class /*<name>*/UIScreen/*</name>*/ 
+    extends /*<extends>*/NSObject/*</extends>*/ 
+    /*<implements>*//*</implements>*/ {
+
+    public static class Notifications {
+        /**
+         * @since Available in iOS 3.2 and later.
+         */
+        public static NSObject observeDidConnect(final VoidBlock1<UIScreen> block) {
+            return NSNotificationCenter.getDefaultCenter().addObserver(DidConnectNotification(), null, NSOperationQueue.getMainQueue(), new VoidBlock1<NSNotification>() {
+                @Override
+                public void invoke(NSNotification a) {
+                    block.invoke((UIScreen) a.getObject());
+                }
+            });
+        }
+        /**
+         * @since Available in iOS 3.2 and later.
+         */
+        public static NSObject observeDidDisconnect(final VoidBlock1<UIScreen> block) {
+            return NSNotificationCenter.getDefaultCenter().addObserver(DidDisconnectNotification(), null, NSOperationQueue.getMainQueue(), new VoidBlock1<NSNotification>() {
+                @Override
+                public void invoke(NSNotification a) {
+                    block.invoke((UIScreen) a.getObject());
+                }
+            });
+        }
+        /**
+         * @since Available in iOS 3.2 and later.
+         */
+        public static NSObject observeModeDidChange(final VoidBlock1<UIScreen> block) {
+            return NSNotificationCenter.getDefaultCenter().addObserver(ModeDidChangeNotification(), null, NSOperationQueue.getMainQueue(), new VoidBlock1<NSNotification>() {
+                @Override
+                public void invoke(NSNotification a) {
+                    block.invoke((UIScreen) a.getObject());
+                }
+            });
+        }
+        /**
+         * @since Available in iOS 5.0 and later.
+         */
+        public static NSObject observeBrightnessDidChange(final VoidBlock1<UIScreen> block) {
+            return NSNotificationCenter.getDefaultCenter().addObserver(BrightnessDidChangeNotification(), null, NSOperationQueue.getMainQueue(), new VoidBlock1<NSNotification>() {
+                @Override
+                public void invoke(NSNotification a) {
+                    block.invoke((UIScreen) a.getObject());
+                }
+            });
+        }
+    }
+    /*<ptr>*/public static class UIScreenPtr extends Ptr<UIScreen, UIScreenPtr> {}/*</ptr>*/
+    /*<bind>*/static { ObjCRuntime.bind(UIScreen.class); }/*</bind>*/
+    /*<constants>*//*</constants>*/
+    /*<constructors>*/
+    public UIScreen() {}
+    protected UIScreen(SkipInit skipInit) { super(skipInit); }
+    /*</constructors>*/
+    /*<properties>*/
+    @Property(selector = "bounds")
+    public native @ByVal CGRect getBounds();
+    @Property(selector = "applicationFrame")
+    public native @ByVal CGRect getApplicationFrame();
+    /**
+     * @since Available in iOS 4.0 and later.
+     */
+    @Property(selector = "scale")
+    public native @MachineSizedFloat double getScale();
+    /**
+     * @since Available in iOS 4.0 and later.
+     */
+    @Property(selector = "nativeScale")
+    public native @MachineSizedFloat double getNativeScale();
+    /**
+     * @since Available in iOS 3.2 and later.
+     */
+    @Property(selector = "availableModes")
+    public native NSArray<UIScreenMode> getAvailableModes();
+    /**
+     * @since Available in iOS 4.3 and later.
+     */
+    @Property(selector = "preferredMode")
+    public native UIScreenMode getPreferredMode();
+    /**
+     * @since Available in iOS 3.2 and later.
+     */
+    @Property(selector = "currentMode")
+    public native UIScreenMode getCurrentMode();
+    /**
+     * @since Available in iOS 3.2 and later.
+     */
+    @Property(selector = "setCurrentMode:")
+    public native void setCurrentMode(UIScreenMode v);
+    /**
+     * @since Available in iOS 5.0 and later.
+     */
+    @Property(selector = "overscanCompensation")
+    public native UIScreenOverscanCompensation getOverscanCompensation();
+    /**
+     * @since Available in iOS 5.0 and later.
+     */
+    @Property(selector = "setOverscanCompensation:")
+    public native void setOverscanCompensation(UIScreenOverscanCompensation v);
+    /**
+     * @since Available in iOS 4.3 and later.
+     */
+    @Property(selector = "mirroredScreen")
+    public native UIScreen getMirroredScreen();
+    /**
+     * @since Available in iOS 5.0 and later.
+     */
+    @Property(selector = "brightness")
+    public native @MachineSizedFloat double getBrightness();
+    /**
+     * @since Available in iOS 5.0 and later.
+     */
+    @Property(selector = "setBrightness:")
+    public native void setBrightness(@MachineSizedFloat double v);
+    /**
+     * @since Available in iOS 5.0 and later.
+     */
+    @Property(selector = "wantsSoftwareDimming")
+    public native boolean isWantsSoftwareDimming();
+    /**
+     * @since Available in iOS 5.0 and later.
+     */
+    @Property(selector = "setWantsSoftwareDimming:")
+    public native void setWantsSoftwareDimming(boolean v);
+    /*</properties>*/
+    /*<members>*//*</members>*/
+    /*<methods>*/
+    /**
+     * @since Available in iOS 3.2 and later.
+     */
+    @GlobalValue(symbol="UIScreenDidConnectNotification", optional=true)
+    public static native NSString DidConnectNotification();
+    /**
+     * @since Available in iOS 3.2 and later.
+     */
+    @GlobalValue(symbol="UIScreenDidDisconnectNotification", optional=true)
+    public static native NSString DidDisconnectNotification();
+    /**
+     * @since Available in iOS 3.2 and later.
+     */
+    @GlobalValue(symbol="UIScreenModeDidChangeNotification", optional=true)
+    public static native NSString ModeDidChangeNotification();
+    /**
+     * @since Available in iOS 5.0 and later.
+     */
+    @GlobalValue(symbol="UIScreenBrightnessDidChangeNotification", optional=true)
+    public static native NSString BrightnessDidChangeNotification();
+    
+    /**
+     * @since Available in iOS 4.0 and later.
+     */
+    @Method(selector = "displayLinkWithTarget:selector:")
+    public native CADisplayLink createDisplayLink(NSObject target, Selector sel);
+    /**
+     * @since Available in iOS 3.2 and later.
+     */
+    @Method(selector = "screens")
+    public static native NSArray<UIScreen> getScreens();
+    @Method(selector = "mainScreen")
+    public static native UIScreen getMainScreen();
+    /**
+     * @since Available in iOS 7.0 and later.
+     */
+    @Method(selector = "snapshotViewAfterScreenUpdates:")
+    public native UIView snapshotView(boolean afterUpdates);
+    /*</methods>*/
+}
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/ALChannelSource.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/ALChannelSource.java
new file mode 100644
index 0000000..2e62a60
--- /dev/null
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/ALChannelSource.java
@@ -0,0 +1,20 @@
+package com.badlogic.gdx.backends.iosrobovm.objectal;
+
+import org.robovm.apple.foundation.NSObject;
+import org.robovm.objc.ObjCRuntime;
+import org.robovm.objc.annotation.NativeClass;
+import org.robovm.objc.annotation.Property;
+import org.robovm.rt.bro.annotation.Library;
+
+@Library(Library.INTERNAL)
+@NativeClass
+public final class ALChannelSource extends NSObject {
+
+	static {
+		ObjCRuntime.bind(ALChannelSource.class);
+	}
+	
+	@Property(selector = "sourcePool")
+	public native ALSoundSourcePool getSourcePool ();
+	
+}
\ No newline at end of file
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/ALSoundSourcePool.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/ALSoundSourcePool.java
new file mode 100644
index 0000000..1ccc5cb
--- /dev/null
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/ALSoundSourcePool.java
@@ -0,0 +1,21 @@
+package com.badlogic.gdx.backends.iosrobovm.objectal;
+
+import org.robovm.apple.foundation.NSArray;
+import org.robovm.apple.foundation.NSObject;
+import org.robovm.objc.ObjCRuntime;
+import org.robovm.objc.annotation.NativeClass;
+import org.robovm.objc.annotation.Property;
+import org.robovm.rt.bro.annotation.Library;
+
+@Library(Library.INTERNAL)
+@NativeClass
+public class ALSoundSourcePool extends NSObject {
+
+	static {
+		ObjCRuntime.bind(ALSoundSourcePool.class);
+	}
+	
+	@Property(selector = "sources")
+	public native NSArray<ALSource> getSources ();
+	
+}
\ No newline at end of file
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/ALSource.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/ALSource.java
index 8311f19..42e976a 100644
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/ALSource.java
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/ALSource.java
@@ -21,6 +21,7 @@ import org.robovm.objc.ObjCRuntime;
 import org.robovm.objc.annotation.Method;
 import org.robovm.objc.annotation.NativeClass;
 import org.robovm.objc.annotation.Property;
+import org.robovm.rt.bro.NativeObject;
 import org.robovm.rt.bro.annotation.Library;
 
 /**
@@ -33,6 +34,9 @@ public class ALSource extends NSObject {
 	static {
 		ObjCRuntime.bind(ALSource.class);
 	}
+	
+	@Property(selector = "sourceId")
+	public native int getSourceId ();
 
 	@Method(selector = "stop")
 	public native void stop ();
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/OALSimpleAudio.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/OALSimpleAudio.java
index fe2de1d..ec1c8f3 100644
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/OALSimpleAudio.java
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/OALSimpleAudio.java
@@ -63,4 +63,8 @@ public final class OALSimpleAudio extends NSObject {
 
 	@Property
 	public native void setUseHardwareIfAvailable (boolean useHardwareIfAvailable);
+	
+	@Property(selector = "channel")
+	public native ALChannelSource getChannelSource ();
+	
 }
diff --git a/backends/gdx-backends-gwt/issues.txt b/backends/gdx-backends-gwt/issues.txt
index cd93a8d..061aebc 100644
--- a/backends/gdx-backends-gwt/issues.txt
+++ b/backends/gdx-backends-gwt/issues.txt
@@ -54,7 +54,6 @@ Gdx2DPixmap.java
 PixmapIO.java
 ETC1.java
 ETC1TextureData.java
-KTXTextureData.java
 ScreenUtils.java
 RemoteInput.java
 RemoteSender.java
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGL20.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGL20.java
index 3485edf..45dd288 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGL20.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGL20.java
@@ -283,6 +283,13 @@ public class GwtGL20 implements GL20 {
 			gl.deleteTexture(texture);
 		}
 	}
+	
+	@Override
+	public void glDeleteTexture (int id) {
+		WebGLTexture texture = this.textures.get(id);
+		deallocateTextureId(id);
+		gl.deleteTexture(texture);
+	}
 
 	@Override
 	public void glDepthFunc (int func) {
@@ -340,6 +347,12 @@ public class GwtGL20 implements GL20 {
 		int id = allocateTextureId(texture);
 		textures.put(id);
 	}
+	
+	@Override
+	public int glGenTexture () {
+		WebGLTexture texture = gl.createTexture();
+		return allocateTextureId(texture);
+	}
 
 	@Override
 	public int glGetError () {
@@ -593,6 +606,13 @@ public class GwtGL20 implements GL20 {
 			gl.deleteBuffer(buffer);
 		}
 	}
+	
+	@Override
+	public void glDeleteBuffer (int id) {
+		WebGLBuffer buffer = this.buffers.get(id);
+		deallocateBufferId(id);
+		gl.deleteBuffer(buffer);
+	}
 
 	@Override
 	public void glDeleteFramebuffers (int n, IntBuffer framebuffers) {
@@ -605,6 +625,13 @@ public class GwtGL20 implements GL20 {
 	}
 
 	@Override
+	public void glDeleteFramebuffer (int id) {
+		WebGLFramebuffer fb = this.frameBuffers.get(id);
+		deallocateFrameBufferId(id);
+		gl.deleteFramebuffer(fb);
+	}
+	
+	@Override
 	public void glDeleteProgram (int program) {
 		WebGLProgram prog = programs.get(program);
 		deallocateProgramId(program);
@@ -620,6 +647,13 @@ public class GwtGL20 implements GL20 {
 			gl.deleteRenderbuffer(rb);
 		}
 	}
+	
+	@Override
+	public void glDeleteRenderbuffer (int id) {
+		WebGLRenderbuffer rb = this.renderBuffers.get(id);
+		deallocateRenderBufferId(id);
+		gl.deleteRenderbuffer(rb);
+	}
 
 	@Override
 	public void glDeleteShader (int shader) {
@@ -666,6 +700,12 @@ public class GwtGL20 implements GL20 {
 			buffers.put(id);
 		}
 	}
+	
+	@Override
+	public int glGenBuffer () {
+		WebGLBuffer buffer = gl.createBuffer();
+		return allocateBufferId(buffer);
+	}
 
 	@Override
 	public void glGenerateMipmap (int target) {
@@ -680,6 +720,12 @@ public class GwtGL20 implements GL20 {
 			framebuffers.put(id);
 		}
 	}
+	
+	@Override
+	public int glGenFramebuffer () {
+		WebGLFramebuffer fb = gl.createFramebuffer();
+		return allocateFrameBufferId(fb);
+	}
 
 	@Override
 	public void glGenRenderbuffers (int n, IntBuffer renderbuffers) {
@@ -689,6 +735,12 @@ public class GwtGL20 implements GL20 {
 			renderbuffers.put(id);
 		}
 	}
+	
+	@Override
+	public int glGenRenderbuffer () {
+		WebGLRenderbuffer rb = gl.createRenderbuffer();
+		return allocateRenderBufferId(rb);
+	}
 
 	@Override
 	public String glGetActiveAttrib (int program, int index, IntBuffer size, Buffer type) {
@@ -937,6 +989,12 @@ public class GwtGL20 implements GL20 {
 		WebGLUniformLocation loc = getUniformLocation(location);
 		gl.uniform1fv(loc, copy(v));
 	}
+	
+	@Override
+	public void glUniform1fv (int location, int count, float[] v, int offset) {
+		WebGLUniformLocation loc = getUniformLocation(location);
+		gl.uniform1fv(loc, v);
+	}
 
 	@Override
 	public void glUniform1i (int location, int x) {
@@ -949,6 +1007,12 @@ public class GwtGL20 implements GL20 {
 		WebGLUniformLocation loc = getUniformLocation(location);
 		gl.uniform1iv(loc, copy(v));
 	}
+	
+	@Override
+	public void glUniform1iv (int location, int count, int[] v, int offset) {
+		WebGLUniformLocation loc = getUniformLocation(location);
+		gl.uniform1iv(loc, v);
+	}
 
 	@Override
 	public void glUniform2f (int location, float x, float y) {
@@ -961,6 +1025,12 @@ public class GwtGL20 implements GL20 {
 		WebGLUniformLocation loc = getUniformLocation(location);
 		gl.uniform2fv(loc, copy(v));
 	}
+	
+	@Override
+	public void glUniform2fv (int location, int count, float[] v, int offset) {
+		WebGLUniformLocation loc = getUniformLocation(location);
+		gl.uniform2fv(loc, v);
+	}
 
 	@Override
 	public void glUniform2i (int location, int x, int y) {
@@ -973,6 +1043,12 @@ public class GwtGL20 implements GL20 {
 		WebGLUniformLocation loc = getUniformLocation(location);
 		gl.uniform2iv(loc, copy(v));
 	}
+	
+	@Override
+	public void glUniform2iv (int location, int count, int[] v, int offset) {
+		WebGLUniformLocation loc = getUniformLocation(location);
+		gl.uniform2iv(loc, v);
+	}
 
 	@Override
 	public void glUniform3f (int location, float x, float y, float z) {
@@ -985,6 +1061,12 @@ public class GwtGL20 implements GL20 {
 		WebGLUniformLocation loc = getUniformLocation(location);
 		gl.uniform3fv(loc, copy(v));
 	}
+	
+	@Override
+	public void glUniform3fv (int location, int count, float[] v, int offset) {
+		WebGLUniformLocation loc = getUniformLocation(location);
+		gl.uniform3fv(loc, v);
+	}
 
 	@Override
 	public void glUniform3i (int location, int x, int y, int z) {
@@ -997,6 +1079,12 @@ public class GwtGL20 implements GL20 {
 		WebGLUniformLocation loc = getUniformLocation(location);
 		gl.uniform3iv(loc, copy(v));
 	}
+	
+	@Override
+	public void glUniform3iv (int location, int count, int[] v, int offset) {
+		WebGLUniformLocation loc = getUniformLocation(location);
+		gl.uniform3iv(loc, v);
+	}
 
 	@Override
 	public void glUniform4f (int location, float x, float y, float z, float w) {
@@ -1011,6 +1099,12 @@ public class GwtGL20 implements GL20 {
 	}
 
 	@Override
+	public void glUniform4fv (int location, int count, float[] v, int offset) {
+		WebGLUniformLocation loc = getUniformLocation(location);
+		gl.uniform4fv(loc, v);
+	}
+	
+	@Override
 	public void glUniform4i (int location, int x, int y, int z, int w) {
 		WebGLUniformLocation loc = getUniformLocation(location);
 		gl.uniform4i(loc, x, y, z, w);
@@ -1023,22 +1117,46 @@ public class GwtGL20 implements GL20 {
 	}
 
 	@Override
+	public void glUniform4iv (int location, int count, int[] v, int offset) {
+		WebGLUniformLocation loc = getUniformLocation(location);
+		gl.uniform4iv(loc, v);
+	}
+	
+	@Override
 	public void glUniformMatrix2fv (int location, int count, boolean transpose, FloatBuffer value) {
 		WebGLUniformLocation loc = getUniformLocation(location);
 		gl.uniformMatrix2fv(loc, transpose, copy(value));
 	}
+	
+	@Override
+	public void glUniformMatrix2fv (int location, int count, boolean transpose, float[] value, int offset) {
+		WebGLUniformLocation loc = getUniformLocation(location);
+		gl.uniformMatrix2fv(loc, transpose, value);
+	}
 
 	@Override
 	public void glUniformMatrix3fv (int location, int count, boolean transpose, FloatBuffer value) {
 		WebGLUniformLocation loc = getUniformLocation(location);
 		gl.uniformMatrix3fv(loc, transpose, copy(value));
 	}
+	
+	@Override
+	public void glUniformMatrix3fv (int location, int count, boolean transpose, float[] value, int offset) {
+		WebGLUniformLocation loc = getUniformLocation(location);
+		gl.uniformMatrix3fv(loc, transpose, value);
+	}
 
 	@Override
 	public void glUniformMatrix4fv (int location, int count, boolean transpose, FloatBuffer value) {
 		WebGLUniformLocation loc = getUniformLocation(location);
 		gl.uniformMatrix4fv(loc, transpose, copy(value));
 	}
+	
+	@Override
+	public void glUniformMatrix4fv (int location, int count, boolean transpose, float[] value, int offset) {
+		WebGLUniformLocation loc = getUniformLocation(location);
+		gl.uniformMatrix4fv(loc, transpose, value);
+	}
 
 	@Override
 	public void glUseProgram (int program) {
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gitignore b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gitignore
index 2668f00..47454ee 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gitignore
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gitignore
@@ -57,6 +57,7 @@ nb-configuration.xml
 ## Gradle
 
 .gradle
+gradle-app.setting
 build/
 
 ## OS Specific
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/ktx/KTXProcessor.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/ktx/KTXProcessor.java
deleted file mode 100644
index 20ec228..0000000
--- a/extensions/gdx-tools/src/com/badlogic/gdx/tools/ktx/KTXProcessor.java
+++ /dev/null
@@ -1,340 +0,0 @@
-
-package com.badlogic.gdx.tools.ktx;
-
-import java.io.DataOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.nio.ByteBuffer;
-import java.util.zip.GZIPOutputStream;
-
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.Pixmap;
-import com.badlogic.gdx.graphics.Pixmap.Blending;
-import com.badlogic.gdx.graphics.Pixmap.Filter;
-import com.badlogic.gdx.graphics.Pixmap.Format;
-import com.badlogic.gdx.graphics.PixmapIO;
-import com.badlogic.gdx.graphics.glutils.ETC1;
-import com.badlogic.gdx.graphics.glutils.ETC1.ETC1Data;
-import com.badlogic.gdx.graphics.glutils.KTXTextureData;
-import com.badlogic.gdx.math.MathUtils;
-import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-
-public class KTXProcessor {
-
-	private final static byte[] HEADER_MAGIC = {(byte)0x0AB, (byte)0x04B, (byte)0x054, (byte)0x058, (byte)0x020, (byte)0x031,
-		(byte)0x031, (byte)0x0BB, (byte)0x00D, (byte)0x00A, (byte)0x01A, (byte)0x00A};
-
-	public static void convert (String input, String output, boolean genMipmaps, boolean packETC1, boolean genAlphaAtlas)
-		throws Exception {
-		Array<String> opts = new Array<String>(String.class);
-		opts.add(input);
-		opts.add(output);
-		if (genMipmaps) opts.add("-mipmaps");
-		if (packETC1 && !genAlphaAtlas) opts.add("-etc1");
-		if (packETC1 && genAlphaAtlas) opts.add("-etc1a");
-		main(opts.toArray());
-	}
-
-	public static void convert (String inPx, String inNx, String inPy, String inNy, String inPz, String inNz, String output,
-		boolean genMipmaps, boolean packETC1, boolean genAlphaAtlas) throws Exception {
-		Array<String> opts = new Array<String>(String.class);
-		opts.add(inPx);
-		opts.add(inNx);
-		opts.add(inPy);
-		opts.add(inNy);
-		opts.add(inPz);
-		opts.add(inNz);
-		opts.add(output);
-		if (genMipmaps) opts.add("-mipmaps");
-		if (packETC1 && !genAlphaAtlas) opts.add("-etc1");
-		if (packETC1 && genAlphaAtlas) opts.add("-etc1a");
-		main(opts.toArray());
-	}
-
-	private final static int DISPOSE_DONT = 0;
-	private final static int DISPOSE_PACK = 1;
-	private final static int DISPOSE_FACE = 2;
-	private final static int DISPOSE_LEVEL = 4;
-
-	public static void main (String[] args) throws Exception {
-		boolean isCubemap = args.length == 7 || args.length == 8 || args.length == 9;
-		boolean isTexture = args.length == 2 || args.length == 3 || args.length == 4;
-		boolean isPackETC1 = false, isAlphaAtlas = false, isGenMipMaps = false;
-		if (!isCubemap && !isTexture) {
-			System.out.println("usage : KTXProcessor input_file output_file [-etc1|-etc1a] [-mipmaps]");
-			System.out.println("  input_file  is the texture file to include in the output KTX or ZKTX file.");
-			System.out
-				.println("              for cube map, just provide 6 input files corresponding to the faces in the following order : X+, X-, Y+, Y-, Z+, Z-");
-			System.out
-				.println("  output_file is the path to the output file, its type is based on the extension which must be either KTX or ZKTX");
-			System.out.println();
-			System.out.println("  options:");
-			System.out.println("    -etc1    input file will be packed using ETC1 compression, dropping the alpha channel");
-			System.out
-				.println("    -etc1a   input file will be packed using ETC1 compression, doubling the height and placing the alpha channel in the bottom half");
-			System.out.println("    -mipmaps input file will be processed to generate mipmaps");
-			System.out.println();
-			System.out.println("  examples:");
-			System.out
-				.println("    KTXProcessor in.png out.ktx                                        Create a KTX file with the provided 2D texture");
-			System.out
-				.println("    KTXProcessor in.png out.zktx                                       Create a Zipped KTX file with the provided 2D texture");
-			System.out
-				.println("    KTXProcessor in.png out.zktx -mipmaps                              Create a Zipped KTX file with the provided 2D texture, generating all mipmap levels");
-			System.out
-				.println("    KTXProcessor px.ktx nx.ktx py.ktx ny.ktx pz.ktx nz.ktx out.zktx    Create a Zipped KTX file with the provided cubemap textures");
-			System.out
-				.println("    KTXProcessor in.ktx out.zktx                                       Convert a KTX file to a Zipped KTX file");
-			System.exit(-1);
-		}
-
-		// Loads other options
-		for (int i = 0; i < args.length; i++) {
-			if (isTexture && i < 2) continue;
-			if (isCubemap && i < 7) continue;
-			if ("-etc1".equals(args[i])) isPackETC1 = true;
-			if ("-etc1a".equals(args[i])) isAlphaAtlas = isPackETC1 = true;
-			if ("-mipmaps".equals(args[i])) isGenMipMaps = true;
-		}
-		File output = new File(args[isCubemap ? 6 : 1]);
-
-		// Check if we have a cubemapped ktx file as input
-		int ktxDispose = DISPOSE_DONT;
-		KTXTextureData ktx = null;
-		FileHandle file = new FileHandle(args[0]);
-		if (file.name().toLowerCase().endsWith(".ktx") || file.name().toLowerCase().endsWith(".zktx")) {
-			ktx = new KTXTextureData(file, false);
-			if (ktx.getNumberOfFaces() == 6) isCubemap = true;
-			ktxDispose = DISPOSE_PACK;
-		}
-
-		// Process all faces
-		int nFaces = isCubemap ? 6 : 1;
-		Image[][] images = new Image[nFaces][];
-		Pixmap.setBlending(Blending.None);
-		Pixmap.setFilter(Filter.BiLinear);
-		int texWidth = -1, texHeight = -1, texFormat = -1, nLevels = 0;
-		for (int face = 0; face < nFaces; face++) {
-			ETC1Data etc1 = null;
-			Pixmap facePixmap = null;
-			int ktxFace = 0;
-
-			// Load source image (ends up with either ktx, etc1 or facePixmap initialized)
-			if (ktx != null && ktx.getNumberOfFaces() == 6) {
-				// No loading since we have a ktx file with cubemap as input
-				nLevels = ktx.getNumberOfMipMapLevels();
-				ktxFace = face;
-			} else {
-				file = new FileHandle(args[face]);
-				System.out.println("Processing : " + file + " for face #" + face);
-				if (file.name().toLowerCase().endsWith(".ktx") || file.name().toLowerCase().endsWith(".zktx")) {
-					if (ktx == null || ktx.getNumberOfFaces() != 6) {
-						ktxDispose = DISPOSE_FACE;
-						ktx = new KTXTextureData(file, false);
-						ktx.prepare();
-					}
-					nLevels = ktx.getNumberOfMipMapLevels();
-					texWidth = ktx.getWidth();
-					texHeight = ktx.getHeight();
-				} else if (file.name().toLowerCase().endsWith(".etc1")) {
-					etc1 = new ETC1Data(file);
-					nLevels = 1;
-					texWidth = etc1.width;
-					texHeight = etc1.height;
-				} else {
-					facePixmap = new Pixmap(file);
-					nLevels = 1;
-					texWidth = facePixmap.getWidth();
-					texHeight = facePixmap.getHeight();
-				}
-				if (isGenMipMaps) {
-					if (!MathUtils.isPowerOfTwo(texWidth) || !MathUtils.isPowerOfTwo(texHeight))
-						throw new GdxRuntimeException(
-							"Invalid input : mipmap generation is only available for power of two textures : " + file);
-					nLevels = Math.max(Integer.SIZE - Integer.numberOfLeadingZeros(texWidth),
-						Integer.SIZE - Integer.numberOfLeadingZeros(texHeight));
-				}
-			}
-
-			// Process each mipmap level
-			images[face] = new Image[nLevels];
-			for (int level = 0; level < nLevels; level++) {
-				int levelWidth = Math.max(1, texWidth >> level);
-				int levelHeight = Math.max(1, texHeight >> level);
-
-				// Get pixmap for this level (ends with either levelETCData or levelPixmap being non null)
-				Pixmap levelPixmap = null;
-				ETC1Data levelETCData = null;
-				if (ktx != null) {
-					ByteBuffer ktxData = ktx.getData(level, ktxFace);
-					if (ktxData != null && ktx.getGlInternalFormat() == ETC1.ETC1_RGB8_OES)
-						levelETCData = new ETC1Data(levelWidth, levelHeight, ktxData, 0);
-				}
-				if (ktx != null && levelETCData == null && facePixmap == null) {
-					ByteBuffer ktxData = ktx.getData(0, ktxFace);
-					if (ktxData != null && ktx.getGlInternalFormat() == ETC1.ETC1_RGB8_OES)
-						facePixmap = ETC1.decodeImage(new ETC1Data(levelWidth, levelHeight, ktxData, 0), Format.RGB888);
-				}
-				if (level == 0 && etc1 != null) {
-					levelETCData = etc1;
-				}
-				if (levelETCData == null && etc1 != null && facePixmap == null) {
-					facePixmap = ETC1.decodeImage(etc1, Format.RGB888);
-				}
-				if (levelETCData == null) {
-					levelPixmap = new Pixmap(levelWidth, levelHeight, facePixmap.getFormat());
-					levelPixmap.drawPixmap(facePixmap, 0, 0, facePixmap.getWidth(), facePixmap.getHeight(), 0, 0,
-						levelPixmap.getWidth(), levelPixmap.getHeight());
-				}
-				if (levelETCData == null && levelPixmap == null)
-					throw new GdxRuntimeException("Failed to load data for face " + face + " / mipmap level " + level);
-
-				// Create alpha atlas
-				if (isAlphaAtlas) {
-					if (levelPixmap == null) levelPixmap = ETC1.decodeImage(levelETCData, Format.RGB888);
-					int w = levelPixmap.getWidth(), h = levelPixmap.getHeight();
-					Pixmap pm = new Pixmap(w, h * 2, levelPixmap.getFormat());
-					pm.drawPixmap(levelPixmap, 0, 0);
-					for (int y = 0; y < h; y++) {
-						for (int x = 0; x < w; x++) {
-							int alpha = (levelPixmap.getPixel(x, y)) & 0x0FF;
-							pm.drawPixel(x, y + h, (alpha << 24) | (alpha << 16) | (alpha << 8) | 0x0FF);
-						}
-					}
-					levelPixmap.dispose();
-					levelPixmap = pm;
-					levelETCData = null;
-				}
-
-				// Perform ETC1 compression
-				if (levelETCData == null && isPackETC1) {
-					if (levelPixmap.getFormat() != Format.RGB888 && levelPixmap.getFormat() != Format.RGB565) {
-						if (!isAlphaAtlas)
-							System.out.println("Converting from " + levelPixmap.getFormat() + " to RGB888 for ETC1 compression");
-						Pixmap tmp = new Pixmap(levelPixmap.getWidth(), levelPixmap.getHeight(), Format.RGB888);
-						tmp.drawPixmap(levelPixmap, 0, 0, 0, 0, levelPixmap.getWidth(), levelPixmap.getHeight());
-						levelPixmap.dispose();
-						levelPixmap = tmp;
-					}
-					// System.out.println("Compress : " + levelWidth + " x " + levelHeight);
-					levelETCData = ETC1.encodeImagePKM(levelPixmap);
-					levelPixmap.dispose();
-					levelPixmap = null;
-				}
-
-				// Save result to ouput ktx
-				images[face][level] = new Image();
-				images[face][level].etcData = levelETCData;
-				images[face][level].pixmap = levelPixmap;
-				if (levelPixmap != null) {
-					levelPixmap.dispose();
-					facePixmap = null;
-				}
-			}
-
-			// Dispose resources
-			if (facePixmap != null) {
-				facePixmap.dispose();
-				facePixmap = null;
-			}
-			if (etc1 != null) {
-				etc1.dispose();
-				etc1 = null;
-			}
-			if (ktx != null && ktxDispose == DISPOSE_FACE) {
-				ktx.disposePreparedData();
-				ktx = null;
-			}
-		}
-		if (ktx != null) {
-			ktx.disposePreparedData();
-			ktx = null;
-		}
-
-		int glType, glTypeSize, glFormat, glInternalFormat, glBaseInternalFormat;
-		if (isPackETC1) {
-			glType = glFormat = 0;
-			glTypeSize = 1;
-			glInternalFormat = ETC1.ETC1_RGB8_OES;
-			glBaseInternalFormat = GL20.GL_RGB;
-		} else if (images[0][0].pixmap != null) {
-			glType = images[0][0].pixmap.getGLType();
-			glTypeSize = 1;
-			glFormat = images[0][0].pixmap.getGLFormat();
-			glInternalFormat = images[0][0].pixmap.getGLInternalFormat();
-			glBaseInternalFormat = glFormat;
-		} else
-			throw new GdxRuntimeException("Unsupported output format");
-
-		int totalSize = 12 + 13 * 4;
-		for (int level = 0; level < nLevels; level++) {
-			int faceLodSize = images[0][level].getSize();
-			int faceLodSizeRounded = (faceLodSize + 3) & ~3;
-			totalSize += 4;
-			totalSize += nFaces * faceLodSizeRounded;
-		}
-
-		DataOutputStream out;
-		if (output.getName().toLowerCase().endsWith(".zktx")) {
-			out = new DataOutputStream(new GZIPOutputStream(new FileOutputStream(output)));
-			out.writeInt(totalSize);
-		} else
-			out = new DataOutputStream(new FileOutputStream(output));
-
-		out.write(HEADER_MAGIC);
-		out.writeInt(0x04030201);
-		out.writeInt(glType);
-		out.writeInt(glTypeSize);
-		out.writeInt(glFormat);
-		out.writeInt(glInternalFormat);
-		out.writeInt(glBaseInternalFormat);
-		out.writeInt(texWidth);
-		out.writeInt(isAlphaAtlas ? (2 * texHeight) : texHeight);
-		out.writeInt(0); // depth (not supported)
-		out.writeInt(0); // n array elements (not supported)
-		out.writeInt(nFaces);
-		out.writeInt(nLevels);
-		out.writeInt(0); // No additional info (key/value pairs)
-		for (int level = 0; level < nLevels; level++) {
-			int faceLodSize = images[0][level].getSize();
-			int faceLodSizeRounded = (faceLodSize + 3) & ~3;
-			out.writeInt(faceLodSize);
-			for (int face = 0; face < nFaces; face++) {
-				byte[] bytes = images[face][level].getBytes();
-				out.write(bytes);
-				for (int j = bytes.length; j < faceLodSizeRounded; j++)
-					out.write((byte)0x00);
-			}
-		}
-
-		out.close();
-	}
-
-	private static class Image {
-
-		public ETC1Data etcData;
-		public Pixmap pixmap;
-
-		public Image () {
-		}
-
-		public int getSize () {
-			if (etcData != null) return etcData.compressedData.limit() - etcData.dataOffset;
-			throw new GdxRuntimeException("Unsupported output format");
-		}
-
-		public byte[] getBytes () {
-			if (etcData != null) {
-				byte[] result = new byte[getSize()];
-				etcData.compressedData.position(etcData.dataOffset);
-				etcData.compressedData.get(result);
-				return result;
-			}
-			throw new GdxRuntimeException("Unsupported output format");
-		}
-
-	}
-
-}
diff --git a/gdx/jni/android/AndroidGL20.cpp b/gdx/jni/android/AndroidGL20.cpp
index eaf4c5c..1d0dc9a 100644
--- a/gdx/jni/android/AndroidGL20.cpp
+++ b/gdx/jni/android/AndroidGL20.cpp
@@ -498,6 +498,18 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glDeleteBuffer
+ * Signature: (I)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDeleteBuffer
+  (JNIEnv *, jobject, jint buffer)
+{
+	GLuint buf =  buffer;
+	glDeleteBuffers(1, &buf);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glDeleteFramebuffers
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -510,6 +522,18 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glDeleteFramebuffer
+ * Signature: (I)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDeleteFramebuffer
+  (JNIEnv *, jobject, jint buffer)
+{
+	GLuint buf = buffer;
+	glDeleteFramebuffers(1, &buf);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glDeleteProgram
  * Signature: (I)V
  */
@@ -533,6 +557,18 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glDeleteRenderbuffer
+ * Signature: (I)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDeleteRenderbuffer
+  (JNIEnv *, jobject, jint buffer)
+{
+	GLuint buf = buffer;
+	glDeleteRenderbuffers(1, &buf);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glDeleteShader
  * Signature: (I)V
  */
@@ -556,6 +592,18 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glDeleteTexture
+ * Signature: (I)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDeleteTexture
+  (JNIEnv *, jobject, jint buffer)
+{
+	GLuint buf = buffer;
+	glDeleteTextures( 1, &buf);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glDepthFunc
  * Signature: (I)V
  */
@@ -741,6 +789,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenB
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glGenBuffer
+ * Signature: ()I
+ */
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenBuffer
+  (JNIEnv *, jobject)
+{
+	GLuint result;
+	glGenBuffers( 1, &result);
+	return result;
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glGenerateMipmap
  * Signature: (I)V
  */
@@ -764,6 +825,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenF
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glGenFramebuffer
+ * Signature: ()I
+ */
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenFramebuffer
+  (JNIEnv *, jobject)
+{
+	GLuint result;
+	glGenFramebuffers(1, &result);
+	return result;
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glGenRenderbuffers
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -776,6 +850,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenR
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glGenRenderbuffer
+ * Signature: ()I
+ */
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenRenderbuffer
+  (JNIEnv *, jobject)
+{
+	GLuint result;
+	glGenRenderbuffers( 1, &result);
+	return result;
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glGenTextures
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -788,6 +875,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenT
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glGenTexture
+ * Signature: ()I
+ */
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenTexture
+  (JNIEnv *, jobject)
+{
+	GLuint result;
+	glGenTextures(1, &result);
+	return result;
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glGetActiveAttrib
  * Signature: (IIILjava/nio/Buffer;Ljava/nio/IntBuffer;Ljava/nio/Buffer;Ljava/lang/String;)V
  */
@@ -1482,7 +1582,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform1fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1fv__IILjava_nio_FloatBuffer_2
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1491,6 +1591,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glUniform1fv
+ * Signature: (II[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1fv__II_3FI
+  (JNIEnv *env, jobject, jint location, jint count, jfloatArray value, jint offset)
+{
+	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
+	glUniform1fv( location, count, (GLfloat*)&v[offset] );
+	env->ReleasePrimitiveArrayCritical(value, v, 0);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform1i
  * Signature: (II)V
  */
@@ -1505,7 +1618,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform1iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1iv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1iv__IILjava_nio_IntBuffer_2
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1514,6 +1627,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glUniform1iv
+ * Signature: (II[II)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1iv__II_3II
+  (JNIEnv *env, jobject, jint location, jint count, jintArray value, jint offset)
+{
+	int* v = (int*)env->GetPrimitiveArrayCritical(value, 0);
+	glUniform1iv( location, count, (GLint*)&v[offset] );
+	env->ReleasePrimitiveArrayCritical(value, v, 0);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform2f
  * Signature: (IFF)V
  */
@@ -1528,7 +1654,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform2fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2fv__IILjava_nio_FloatBuffer_2
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1537,6 +1663,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glUniform2fv
+ * Signature: (II[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2fv__II_3FI
+  (JNIEnv *env, jobject, jint location, jint count, jfloatArray value, jint offset)
+{
+	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
+	glUniform2fv( location, count, (GLfloat*)&v[offset] );
+	env->ReleasePrimitiveArrayCritical(value, v, 0);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform2i
  * Signature: (III)V
  */
@@ -1551,7 +1690,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform2iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2iv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2iv__IILjava_nio_IntBuffer_2
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1560,6 +1699,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glUniform2iv
+ * Signature: (II[II)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2iv__II_3II
+  (JNIEnv *env, jobject, jint location, jint count, jintArray value, jint offset)
+{
+	int* v = (int*)env->GetPrimitiveArrayCritical(value, 0);
+	glUniform2iv( location, count, (GLint*)&v[offset] );
+	env->ReleasePrimitiveArrayCritical(value, v, 0);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform3f
  * Signature: (IFFF)V
  */
@@ -1574,7 +1726,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform3fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3fv__IILjava_nio_FloatBuffer_2
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1583,6 +1735,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glUniform3fv
+ * Signature: (II[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3fv__II_3FI
+  (JNIEnv *env, jobject, jint location, jint count, jfloatArray value, jint offset)
+{
+	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
+	glUniform3fv( location, count, (GLfloat*)&v[offset] );
+	env->ReleasePrimitiveArrayCritical(value, v, 0);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform3i
  * Signature: (IIII)V
  */
@@ -1597,7 +1762,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform3iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3iv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3iv__IILjava_nio_IntBuffer_2
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1606,6 +1771,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glUniform3iv
+ * Signature: (II[II)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3iv__II_3II
+  (JNIEnv *env, jobject, jint location, jint count, jintArray value, jint offset)
+{
+	int* v = (int*)env->GetPrimitiveArrayCritical(value, 0);
+	glUniform3iv( location, count, (GLint*)&v[offset] );
+	env->ReleasePrimitiveArrayCritical(value, v, 0);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform4f
  * Signature: (IFFFF)V
  */
@@ -1620,7 +1798,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform4fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4fv__IILjava_nio_FloatBuffer_2
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1629,6 +1807,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glUniform4fv
+ * Signature: (II[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4fv__II_3FI
+  (JNIEnv *env, jobject, jint location, jint count, jfloatArray value, jint offset)
+{
+	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
+	glUniform4fv( location, count, (GLfloat*)&v[offset] );
+	env->ReleasePrimitiveArrayCritical(value, v, 0);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform4i
  * Signature: (IIIII)V
  */
@@ -1643,7 +1834,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform4iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4iv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4iv__IILjava_nio_IntBuffer_2
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1652,10 +1843,23 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glUniform4iv
+ * Signature: (II[II)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4iv__II_3II
+  (JNIEnv *env, jobject, jint location, jint count, jintArray value, jint offset)
+{
+	int* v = (int*)env->GetPrimitiveArrayCritical(value, 0);
+	glUniform4iv( location, count, (GLint*)&v[offset] );
+	env->ReleasePrimitiveArrayCritical(value, v, 0);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniformMatrix2fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix2fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix2fv__IIZLjava_nio_FloatBuffer_2
   (JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jobject value)
 {
 	void* dataPtr = getDirectBufferPointer( env, value );
@@ -1664,10 +1868,23 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glUniformMatrix2fv
+ * Signature: (IIZ[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix2fv__IIZ_3FI
+  (JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jfloatArray value, jint offset)
+{
+	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
+	glUniformMatrix2fv( location, count, transpose, (GLfloat*)&v[offset] );
+	env->ReleasePrimitiveArrayCritical(value, v, 0);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniformMatrix3fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix3fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix3fv__IIZLjava_nio_FloatBuffer_2
   (JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jobject value)
 {
 	void* dataPtr = getDirectBufferPointer( env, value );
@@ -1676,10 +1893,23 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glUniformMatrix3fv
+ * Signature: (IIZ[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix3fv__IIZ_3FI
+  (JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jfloatArray value, jint offset)
+{
+	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
+	glUniformMatrix3fv( location, count, transpose, (GLfloat*)&v[offset] );
+	env->ReleasePrimitiveArrayCritical(value, v, 0);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniformMatrix4fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix4fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix4fv__IIZLjava_nio_FloatBuffer_2
   (JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jobject value)
 {
 	void* dataPtr = getDirectBufferPointer( env, value );
@@ -1688,6 +1918,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glUniformMatrix4fv
+ * Signature: (IIZ[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix4fv__IIZ_3FI
+  (JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jfloatArray value, jint offset)
+{
+	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
+	glUniformMatrix4fv( location, count, transpose, (GLfloat*)&v[offset] );
+	env->ReleasePrimitiveArrayCritical(value, v, 0);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUseProgram
  * Signature: (I)V
  */
diff --git a/gdx/jni/android/AndroidGL20.h b/gdx/jni/android/AndroidGL20.h
index 2a5b3d6..787d7bb 100644
--- a/gdx/jni/android/AndroidGL20.h
+++ b/gdx/jni/android/AndroidGL20.h
@@ -249,6 +249,14 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glDeleteBuffer
+ * Signature: (I)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDeleteBuffer
+  (JNIEnv *, jobject, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glDeleteFramebuffers
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -257,6 +265,14 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glDeleteFramebuffer
+ * Signature: (I)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDeleteFramebuffer
+  (JNIEnv *, jobject, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glDeleteProgram
  * Signature: (I)V
  */
@@ -273,6 +289,14 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glDeleteRenderbuffer
+ * Signature: (I)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDeleteRenderbuffer
+  (JNIEnv *, jobject, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glDeleteShader
  * Signature: (I)V
  */
@@ -289,6 +313,14 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glDeleteTexture
+ * Signature: (I)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDeleteTexture
+  (JNIEnv *, jobject, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glDepthFunc
  * Signature: (I)V
  */
@@ -425,6 +457,14 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenB
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glGenBuffer
+ * Signature: ()I
+ */
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenBuffer
+  (JNIEnv *, jobject);
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glGenerateMipmap
  * Signature: (I)V
  */
@@ -441,6 +481,14 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenF
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glGenFramebuffer
+ * Signature: ()I
+ */
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenFramebuffer
+  (JNIEnv *, jobject);
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glGenRenderbuffers
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -449,6 +497,14 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenR
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glGenRenderbuffer
+ * Signature: ()I
+ */
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenRenderbuffer
+  (JNIEnv *, jobject);
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glGenTextures
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -457,6 +513,14 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenT
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glGenTexture
+ * Signature: ()I
+ */
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenTexture
+  (JNIEnv *, jobject);
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glGetActiveAttrib
  * Signature: (IILjava/nio/IntBuffer;Ljava/nio/Buffer;)Ljava/lang/String;
  */
@@ -924,11 +988,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform1fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1fv__IILjava_nio_FloatBuffer_2
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glUniform1fv
+ * Signature: (II[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1fv__II_3FI
+  (JNIEnv *, jobject, jint, jint, jfloatArray, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform1i
  * Signature: (II)V
  */
@@ -940,11 +1012,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform1iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1iv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1iv__IILjava_nio_IntBuffer_2
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glUniform1iv
+ * Signature: (II[II)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1iv__II_3II
+  (JNIEnv *, jobject, jint, jint, jintArray, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform2f
  * Signature: (IFF)V
  */
@@ -956,11 +1036,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform2fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2fv__IILjava_nio_FloatBuffer_2
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glUniform2fv
+ * Signature: (II[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2fv__II_3FI
+  (JNIEnv *, jobject, jint, jint, jfloatArray, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform2i
  * Signature: (III)V
  */
@@ -972,11 +1060,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform2iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2iv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2iv__IILjava_nio_IntBuffer_2
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glUniform2iv
+ * Signature: (II[II)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2iv__II_3II
+  (JNIEnv *, jobject, jint, jint, jintArray, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform3f
  * Signature: (IFFF)V
  */
@@ -988,11 +1084,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform3fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3fv__IILjava_nio_FloatBuffer_2
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glUniform3fv
+ * Signature: (II[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3fv__II_3FI
+  (JNIEnv *, jobject, jint, jint, jfloatArray, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform3i
  * Signature: (IIII)V
  */
@@ -1004,11 +1108,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform3iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3iv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3iv__IILjava_nio_IntBuffer_2
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glUniform3iv
+ * Signature: (II[II)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3iv__II_3II
+  (JNIEnv *, jobject, jint, jint, jintArray, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform4f
  * Signature: (IFFFF)V
  */
@@ -1020,11 +1132,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform4fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4fv__IILjava_nio_FloatBuffer_2
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glUniform4fv
+ * Signature: (II[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4fv__II_3FI
+  (JNIEnv *, jobject, jint, jint, jfloatArray, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform4i
  * Signature: (IIIII)V
  */
@@ -1036,35 +1156,67 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform4iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4iv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4iv__IILjava_nio_IntBuffer_2
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glUniform4iv
+ * Signature: (II[II)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4iv__II_3II
+  (JNIEnv *, jobject, jint, jint, jintArray, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniformMatrix2fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix2fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix2fv__IIZLjava_nio_FloatBuffer_2
   (JNIEnv *, jobject, jint, jint, jboolean, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glUniformMatrix2fv
+ * Signature: (IIZ[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix2fv__IIZ_3FI
+  (JNIEnv *, jobject, jint, jint, jboolean, jfloatArray, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniformMatrix3fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix3fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix3fv__IIZLjava_nio_FloatBuffer_2
   (JNIEnv *, jobject, jint, jint, jboolean, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glUniformMatrix3fv
+ * Signature: (IIZ[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix3fv__IIZ_3FI
+  (JNIEnv *, jobject, jint, jint, jboolean, jfloatArray, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniformMatrix4fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix4fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix4fv__IIZLjava_nio_FloatBuffer_2
   (JNIEnv *, jobject, jint, jint, jboolean, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
+ * Method:    glUniformMatrix4fv
+ * Signature: (IIZ[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix4fv__IIZ_3FI
+  (JNIEnv *, jobject, jint, jint, jboolean, jfloatArray, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUseProgram
  * Signature: (I)V
  */
diff --git a/gdx/jni/iosgl/iosgl20.cpp b/gdx/jni/iosgl/iosgl20.cpp
index 8acba63..849078a 100644
--- a/gdx/jni/iosgl/iosgl20.cpp
+++ b/gdx/jni/iosgl/iosgl20.cpp
@@ -437,6 +437,18 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glDeleteBuffer
+ * Signature: (I)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDeleteBuffer
+  (JNIEnv *, jobject, jint buffer)
+{
+	GLuint b = buffer;
+	glDeleteBuffers (1, &b);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glDeleteFramebuffers
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -449,6 +461,18 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glDeleteFramebuffer
+ * Signature: (I)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDeleteFramebuffer
+  (JNIEnv *, jobject, jint buffer)
+{
+	GLuint b = buffer;
+	glDeleteFramebuffers(1, &b);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glDeleteProgram
  * Signature: (I)V
  */
@@ -472,6 +496,18 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glDeleteRenderbuffer
+ * Signature: (I)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDeleteRenderbuffer
+  (JNIEnv *, jobject, jint buffer)
+{
+	GLuint b = buffer;
+	glDeleteRenderbuffers( 1, &b );
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glDeleteShader
  * Signature: (I)V
  */
@@ -495,6 +531,18 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glDeleteTexture
+ * Signature: (I)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDeleteTexture
+  (JNIEnv *, jobject, jint buffer)
+{
+	GLuint b = buffer;
+	glDeleteTextures(1, &b);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glDepthFunc
  * Signature: (I)V
  */
@@ -680,6 +728,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenB
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glGenBuffer
+ * Signature: ()I
+ */
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenBuffer
+  (JNIEnv *, jobject)
+{
+	GLuint result;
+	glGenBuffers( 1, &result );
+	return result;
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glGenerateMipmap
  * Signature: (I)V
  */
@@ -703,6 +764,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenF
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glGenFramebuffer
+ * Signature: ()I
+ */
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenFramebuffer
+  (JNIEnv *, jobject)
+{
+	GLuint result;
+	glGenFramebuffers( 1, &result );
+	return result;
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glGenRenderbuffers
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -715,6 +789,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenR
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glGenRenderbuffer
+ * Signature: ()I
+ */
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenRenderbuffer
+  (JNIEnv *, jobject)
+{
+	GLuint result;
+	glGenRenderbuffers( 1, &result );
+	return result;
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glGenTextures
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -727,6 +814,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenT
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glGenTexture
+ * Signature: ()I
+ */
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenTexture
+  (JNIEnv *, jobject)
+{
+	GLuint result;
+	glGenTextures(1, &result);
+	return result;
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glGetActiveAttrib
  * Signature: (IIILjava/nio/Buffer;Ljava/nio/IntBuffer;Ljava/nio/Buffer;Ljava/lang/String;)V
  */
@@ -1421,7 +1521,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform1fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1fv__IILjava_nio_FloatBuffer_2
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1430,6 +1530,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glUniform1fv
+ * Signature: (II[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1fv__II_3FI
+  (JNIEnv *env, jobject, jint location, jint count, jfloatArray value, jint offset)
+{
+	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
+	glUniform1fv( location, count, (GLfloat*)&v[offset] );
+	env->ReleasePrimitiveArrayCritical(value, v, 0);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform1i
  * Signature: (II)V
  */
@@ -1444,7 +1557,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform1iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1iv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1iv__IILjava_nio_IntBuffer_2
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1453,6 +1566,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glUniform1iv
+ * Signature: (II[II)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1iv__II_3II
+	(JNIEnv *env, jobject, jint location, jint count, jintArray value, jint offset)
+{
+	int* v = (int*)env->GetPrimitiveArrayCritical(value, 0);
+	glUniform1iv( location, count, (GLint*)&v[offset] );
+	env->ReleasePrimitiveArrayCritical(value, v, 0);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform2f
  * Signature: (IFF)V
  */
@@ -1467,7 +1593,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform2fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2fv__IILjava_nio_FloatBuffer_2
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1476,6 +1602,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glUniform2fv
+ * Signature: (II[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2fv__II_3FI
+	(JNIEnv *env, jobject, jint location, jint count, jfloatArray value, jint offset)
+{
+	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
+	glUniform2fv( location, count, (GLfloat*)&v[offset] );
+	env->ReleasePrimitiveArrayCritical(value, v, 0);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform2i
  * Signature: (III)V
  */
@@ -1490,7 +1629,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform2iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2iv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2iv__IILjava_nio_IntBuffer_2
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1499,6 +1638,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glUniform2iv
+ * Signature: (II[II)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2iv__II_3II
+	(JNIEnv *env, jobject, jint location, jint count, jintArray value, jint offset)
+{
+	int* v = (int*)env->GetPrimitiveArrayCritical(value, 0);
+	glUniform2iv( location, count, (GLint*)&v[offset] );
+	env->ReleasePrimitiveArrayCritical(value, v, 0);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform3f
  * Signature: (IFFF)V
  */
@@ -1513,7 +1665,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform3fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3fv__IILjava_nio_FloatBuffer_2
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1522,6 +1674,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glUniform3fv
+ * Signature: (II[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3fv__II_3FI
+	(JNIEnv *env, jobject, jint location, jint count, jfloatArray value, jint offset)
+{
+	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
+	glUniform3fv( location, count, (GLfloat*)&v[offset] );
+	env->ReleasePrimitiveArrayCritical(value, v, 0);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform3i
  * Signature: (IIII)V
  */
@@ -1536,7 +1701,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform3iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3iv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3iv__IILjava_nio_IntBuffer_2
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1545,6 +1710,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glUniform3iv
+ * Signature: (II[II)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3iv__II_3II
+	(JNIEnv *env, jobject, jint location, jint count, jintArray value, jint offset)
+{
+	int* v = (int*)env->GetPrimitiveArrayCritical(value, 0);
+	glUniform3iv( location, count, (GLint*)&v[offset] );
+	env->ReleasePrimitiveArrayCritical(value, v, 0);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform4f
  * Signature: (IFFFF)V
  */
@@ -1559,7 +1737,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform4fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4fv__IILjava_nio_FloatBuffer_2
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1568,6 +1746,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glUniform4fv
+ * Signature: (II[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4fv__II_3FI
+	(JNIEnv *env, jobject, jint location, jint count, jfloatArray value, jint offset)
+{
+	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
+	glUniform4fv( location, count, (GLfloat*)&v[offset] );
+	env->ReleasePrimitiveArrayCritical(value, v, 0);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform4i
  * Signature: (IIIII)V
  */
@@ -1582,7 +1773,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform4iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4iv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4iv__IILjava_nio_IntBuffer_2
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1591,10 +1782,23 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glUniform4iv
+ * Signature: (II[II)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4iv__II_3II
+	(JNIEnv *env, jobject, jint location, jint count, jintArray value, jint offset)
+{
+	int* v = (int*)env->GetPrimitiveArrayCritical(value, 0);
+	glUniform4iv( location, count, (GLint*)&v[offset] );
+	env->ReleasePrimitiveArrayCritical(value, v, 0);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniformMatrix2fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix2fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix2fv__IIZLjava_nio_FloatBuffer_2
   (JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jobject value)
 {
 	void* dataPtr = getDirectBufferPointer( env, value );
@@ -1603,10 +1807,23 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glUniformMatrix2fv
+ * Signature: (IIZ[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix2fv__IIZ_3FI
+  (JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jfloatArray value, jint offset)
+{
+	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
+	glUniformMatrix2fv( location, count, transpose, (GLfloat*)&v[offset] );
+	env->ReleasePrimitiveArrayCritical(value, v, 0);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniformMatrix3fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix3fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix3fv__IIZLjava_nio_FloatBuffer_2
   (JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jobject value)
 {
 	void* dataPtr = getDirectBufferPointer( env, value );
@@ -1615,10 +1832,23 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glUniformMatrix3fv
+ * Signature: (IIZ[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix3fv__IIZ_3FI
+	(JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jfloatArray value, jint offset)
+{
+	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
+	glUniformMatrix3fv( location, count, transpose, (GLfloat*)&v[offset] );
+	env->ReleasePrimitiveArrayCritical(value, v, 0);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniformMatrix4fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix4fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix4fv__IIZLjava_nio_FloatBuffer_2
   (JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jobject value)
 {
 	void* dataPtr = getDirectBufferPointer( env, value );
@@ -1627,6 +1857,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glUniformMatrix4fv
+ * Signature: (IIZ[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix4fv__IIZ_3FI
+	(JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jfloatArray value, jint offset)
+{
+	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
+	glUniformMatrix4fv( location, count, transpose, (GLfloat*)&v[offset] );
+	env->ReleasePrimitiveArrayCritical(value, v, 0);
+}
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUseProgram
  * Signature: (I)V
  */
@@ -1759,7 +2002,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glVert
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glViewport
+ * Method:    glViewportJni
  * Signature: (IIII)V
  */
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glViewportJni
diff --git a/gdx/jni/iosgl/iosgl20.h b/gdx/jni/iosgl/iosgl20.h
index 68e7a51..3d56ba9 100644
--- a/gdx/jni/iosgl/iosgl20.h
+++ b/gdx/jni/iosgl/iosgl20.h
@@ -249,6 +249,14 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glDeleteBuffer
+ * Signature: (I)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDeleteBuffer
+  (JNIEnv *, jobject, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glDeleteFramebuffers
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -257,6 +265,14 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glDeleteFramebuffer
+ * Signature: (I)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDeleteFramebuffer
+  (JNIEnv *, jobject, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glDeleteProgram
  * Signature: (I)V
  */
@@ -273,6 +289,14 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glDeleteRenderbuffer
+ * Signature: (I)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDeleteRenderbuffer
+  (JNIEnv *, jobject, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glDeleteShader
  * Signature: (I)V
  */
@@ -289,6 +313,14 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glDeleteTexture
+ * Signature: (I)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDeleteTexture
+  (JNIEnv *, jobject, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glDepthFunc
  * Signature: (I)V
  */
@@ -425,6 +457,14 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenB
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glGenBuffer
+ * Signature: ()I
+ */
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenBuffer
+  (JNIEnv *, jobject);
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glGenerateMipmap
  * Signature: (I)V
  */
@@ -441,6 +481,14 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenF
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glGenFramebuffer
+ * Signature: ()I
+ */
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenFramebuffer
+  (JNIEnv *, jobject);
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glGenRenderbuffers
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -449,6 +497,14 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenR
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glGenRenderbuffer
+ * Signature: ()I
+ */
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenRenderbuffer
+  (JNIEnv *, jobject);
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glGenTextures
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -457,6 +513,14 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenT
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glGenTexture
+ * Signature: ()I
+ */
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenTexture
+  (JNIEnv *, jobject);
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glGetActiveAttrib
  * Signature: (IILjava/nio/IntBuffer;Ljava/nio/Buffer;)Ljava/lang/String;
  */
@@ -924,11 +988,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform1fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1fv__IILjava_nio_FloatBuffer_2
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glUniform1fv
+ * Signature: (II[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1fv__II_3FI
+  (JNIEnv *, jobject, jint, jint, jfloatArray, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform1i
  * Signature: (II)V
  */
@@ -940,11 +1012,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform1iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1iv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1iv__IILjava_nio_IntBuffer_2
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glUniform1iv
+ * Signature: (II[II)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1iv__II_3II
+  (JNIEnv *, jobject, jint, jint, jintArray, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform2f
  * Signature: (IFF)V
  */
@@ -956,11 +1036,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform2fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2fv__IILjava_nio_FloatBuffer_2
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glUniform2fv
+ * Signature: (II[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2fv__II_3FI
+  (JNIEnv *, jobject, jint, jint, jfloatArray, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform2i
  * Signature: (III)V
  */
@@ -972,11 +1060,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform2iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2iv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2iv__IILjava_nio_IntBuffer_2
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glUniform2iv
+ * Signature: (II[II)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2iv__II_3II
+  (JNIEnv *, jobject, jint, jint, jintArray, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform3f
  * Signature: (IFFF)V
  */
@@ -988,11 +1084,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform3fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3fv__IILjava_nio_FloatBuffer_2
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glUniform3fv
+ * Signature: (II[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3fv__II_3FI
+  (JNIEnv *, jobject, jint, jint, jfloatArray, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform3i
  * Signature: (IIII)V
  */
@@ -1004,11 +1108,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform3iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3iv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3iv__IILjava_nio_IntBuffer_2
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glUniform3iv
+ * Signature: (II[II)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3iv__II_3II
+  (JNIEnv *, jobject, jint, jint, jintArray, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform4f
  * Signature: (IFFFF)V
  */
@@ -1020,11 +1132,19 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform4fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4fv__IILjava_nio_FloatBuffer_2
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glUniform4fv
+ * Signature: (II[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4fv__II_3FI
+  (JNIEnv *, jobject, jint, jint, jfloatArray, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform4i
  * Signature: (IIIII)V
  */
@@ -1036,35 +1156,67 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform4iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4iv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4iv__IILjava_nio_IntBuffer_2
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glUniform4iv
+ * Signature: (II[II)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4iv__II_3II
+  (JNIEnv *, jobject, jint, jint, jintArray, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniformMatrix2fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix2fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix2fv__IIZLjava_nio_FloatBuffer_2
   (JNIEnv *, jobject, jint, jint, jboolean, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glUniformMatrix2fv
+ * Signature: (IIZ[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix2fv__IIZ_3FI
+  (JNIEnv *, jobject, jint, jint, jboolean, jfloatArray, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniformMatrix3fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix3fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix3fv__IIZLjava_nio_FloatBuffer_2
   (JNIEnv *, jobject, jint, jint, jboolean, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glUniformMatrix3fv
+ * Signature: (IIZ[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix3fv__IIZ_3FI
+  (JNIEnv *, jobject, jint, jint, jboolean, jfloatArray, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniformMatrix4fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix4fv
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix4fv__IIZLjava_nio_FloatBuffer_2
   (JNIEnv *, jobject, jint, jint, jboolean, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
+ * Method:    glUniformMatrix4fv
+ * Signature: (IIZ[FI)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix4fv__IIZ_3FI
+  (JNIEnv *, jobject, jint, jint, jboolean, jfloatArray, jint);
+
+/*
+ * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUseProgram
  * Signature: (I)V
  */
@@ -1161,7 +1313,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glVert
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glViewport
+ * Method:    glViewportJni
  * Signature: (IIII)V
  */
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glViewportJni
diff --git a/gdx/src/com/badlogic/gdx.gwt.xml b/gdx/src/com/badlogic/gdx.gwt.xml
index 650cb44..160dc5a 100644
--- a/gdx/src/com/badlogic/gdx.gwt.xml
+++ b/gdx/src/com/badlogic/gdx.gwt.xml
@@ -204,7 +204,6 @@
 	<!-- graphics/glutils -->
 		<exclude name="graphics/glutils/ETC1.java"/> <!-- Reason: No ETC1 Support -->
 		<include name="graphics/glutils/ETC1TextureData.java"/>  <!-- Emulated: explodes on construction -->
-		<exclude name="graphics/glutils/KTXTextureData.java"/>  <!-- Rely on ETC1 -->
 		<include name="graphics/glutils/FileTextureData.java"/> <!-- Emulated: No PixmapIO -->
 		<include name="graphics/glutils/FloatFrameBuffer.java"/>
 		<include name="graphics/glutils/FloatTextureData.java"/>
diff --git a/gdx/src/com/badlogic/gdx/assets/loaders/CubemapLoader.java b/gdx/src/com/badlogic/gdx/assets/loaders/CubemapLoader.java
deleted file mode 100644
index 01dab39..0000000
--- a/gdx/src/com/badlogic/gdx/assets/loaders/CubemapLoader.java
+++ /dev/null
@@ -1,112 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.assets.loaders;
-
-import com.badlogic.gdx.assets.AssetDescriptor;
-import com.badlogic.gdx.assets.AssetLoaderParameters;
-import com.badlogic.gdx.assets.AssetManager;
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.Cubemap;
-import com.badlogic.gdx.graphics.CubemapData;
-import com.badlogic.gdx.graphics.Pixmap;
-import com.badlogic.gdx.graphics.Pixmap.Format;
-import com.badlogic.gdx.graphics.PixmapIO;
-import com.badlogic.gdx.graphics.Texture;
-import com.badlogic.gdx.graphics.Texture.TextureFilter;
-import com.badlogic.gdx.graphics.Texture.TextureWrap;
-import com.badlogic.gdx.graphics.TextureData;
-import com.badlogic.gdx.graphics.glutils.ETC1TextureData;
-import com.badlogic.gdx.graphics.glutils.FileTextureData;
-import com.badlogic.gdx.graphics.glutils.KTXTextureData;
-import com.badlogic.gdx.utils.Array;
-
-/** {@link AssetLoader} for {@link Cubemap} instances. The pixel data is loaded asynchronously. The texture is then created on the
- * rendering thread, synchronously. Passing a {@link CubemapParameter} to
- * {@link AssetManager#load(String, Class, AssetLoaderParameters)} allows one to specify parameters as can be passed to the
- * various Cubemap constructors, e.g. filtering and so on.
- * @author mzechner, Vincent Bousquet */
-public class CubemapLoader extends AsynchronousAssetLoader<Cubemap, CubemapLoader.CubemapParameter> {
-	static public class CubemapLoaderInfo {
-		String filename;
-		CubemapData data;
-		Cubemap cubemap;
-	};
-
-	CubemapLoaderInfo info = new CubemapLoaderInfo();
-
-	public CubemapLoader (FileHandleResolver resolver) {
-		super(resolver);
-	}
-
-	@Override
-	public void loadAsync (AssetManager manager, String fileName, FileHandle file, CubemapParameter parameter) {
-		info.filename = fileName;
-		if (parameter == null || parameter.cubemapData == null) {
-			Pixmap pixmap = null;
-			Format format = null;
-			boolean genMipMaps = false;
-			info.cubemap = null;
-
-			if (parameter != null) {
-				format = parameter.format;
-				info.cubemap = parameter.cubemap;
-			}
-
-			if (fileName.contains(".ktx") || fileName.contains(".zktx")) {
-				info.data = new KTXTextureData(file, genMipMaps);
-			}
-		} else {
-			info.data = parameter.cubemapData;
-			info.cubemap = parameter.cubemap;
-		}
-		if (!info.data.isPrepared()) info.data.prepare();
-	}
-
-	@Override
-	public Cubemap loadSync (AssetManager manager, String fileName, FileHandle file, CubemapParameter parameter) {
-		if (info == null) return null;
-		Cubemap cubemap = info.cubemap;
-		if (cubemap != null) {
-			cubemap.load(info.data);
-		} else {
-			cubemap = new Cubemap(info.data);
-		}
-		if (parameter != null) {
-			cubemap.setFilter(parameter.minFilter, parameter.magFilter);
-			cubemap.setWrap(parameter.wrapU, parameter.wrapV);
-		}
-		return cubemap;
-	}
-
-	@Override
-	public Array<AssetDescriptor> getDependencies (String fileName, FileHandle file, CubemapParameter parameter) {
-		return null;
-	}
-
-	static public class CubemapParameter extends AssetLoaderParameters<Cubemap> {
-		/** the format of the final Texture. Uses the source images format if null **/
-		public Format format = null;
-		/** The texture to put the {@link TextureData} in, optional. **/
-		public Cubemap cubemap = null;
-		/** CubemapData for textures created on the fly, optional. When set, all format and genMipMaps are ignored */
-		public CubemapData cubemapData = null;
-		public TextureFilter minFilter = TextureFilter.Nearest;
-		public TextureFilter magFilter = TextureFilter.Nearest;
-		public TextureWrap wrapU = TextureWrap.ClampToEdge;
-		public TextureWrap wrapV = TextureWrap.ClampToEdge;
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/assets/loaders/TextureLoader.java b/gdx/src/com/badlogic/gdx/assets/loaders/TextureLoader.java
index 8118cf1..608dbc7 100644
--- a/gdx/src/com/badlogic/gdx/assets/loaders/TextureLoader.java
+++ b/gdx/src/com/badlogic/gdx/assets/loaders/TextureLoader.java
@@ -16,11 +16,11 @@
 
 package com.badlogic.gdx.assets.loaders;
 
+import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.assets.AssetDescriptor;
 import com.badlogic.gdx.assets.AssetLoaderParameters;
 import com.badlogic.gdx.assets.AssetManager;
 import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.GLTexture;
 import com.badlogic.gdx.graphics.Pixmap;
 import com.badlogic.gdx.graphics.Pixmap.Format;
 import com.badlogic.gdx.graphics.PixmapIO;
@@ -30,8 +30,8 @@ import com.badlogic.gdx.graphics.Texture.TextureWrap;
 import com.badlogic.gdx.graphics.TextureData;
 import com.badlogic.gdx.graphics.glutils.ETC1TextureData;
 import com.badlogic.gdx.graphics.glutils.FileTextureData;
-import com.badlogic.gdx.graphics.glutils.KTXTextureData;
 import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.ObjectMap;
 
 /** {@link AssetLoader} for {@link Texture} instances. The pixel data is loaded asynchronously. The texture is then created on the
  * rendering thread, synchronously. Passing a {@link TextureParameter} to
@@ -66,7 +66,15 @@ public class TextureLoader extends AsynchronousAssetLoader<Texture, TextureLoade
 				info.texture = parameter.texture;
 			}
 
-			info.data = TextureData.Factory.loadFromFile(file, format, genMipMaps);
+			if (!fileName.contains(".etc1")) {
+				if (fileName.contains(".cim"))
+					pixmap = PixmapIO.readCIM(file);
+				else
+					pixmap = new Pixmap(file);
+				info.data = new FileTextureData(file, pixmap, format, genMipMaps);
+			} else {
+				info.data = new ETC1TextureData(file, genMipMaps);
+			}
 		} else {
 			info.data = parameter.textureData;
 			info.texture = parameter.texture;
diff --git a/gdx/src/com/badlogic/gdx/graphics/Cubemap.java b/gdx/src/com/badlogic/gdx/graphics/Cubemap.java
index e11ebad..65c41a0 100644
--- a/gdx/src/com/badlogic/gdx/graphics/Cubemap.java
+++ b/gdx/src/com/badlogic/gdx/graphics/Cubemap.java
@@ -16,30 +16,21 @@
 
 package com.badlogic.gdx.graphics;
 
-import java.util.HashMap;
-import java.util.Map;
-
-import com.badlogic.gdx.Application;
 import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.assets.AssetLoaderParameters.LoadedCallback;
-import com.badlogic.gdx.assets.AssetManager;
-import com.badlogic.gdx.assets.loaders.AssetLoader;
-import com.badlogic.gdx.assets.loaders.CubemapLoader.CubemapParameter;
 import com.badlogic.gdx.files.FileHandle;
 import com.badlogic.gdx.graphics.Pixmap.Format;
 import com.badlogic.gdx.graphics.Texture.TextureFilter;
 import com.badlogic.gdx.graphics.Texture.TextureWrap;
-import com.badlogic.gdx.graphics.glutils.FacedCubemapData;
+import com.badlogic.gdx.graphics.glutils.ETC1TextureData;
+import com.badlogic.gdx.graphics.glutils.FileTextureData;
+import com.badlogic.gdx.graphics.glutils.MipMapGenerator;
 import com.badlogic.gdx.graphics.glutils.PixmapTextureData;
-import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 
 /** Wraps a standard OpenGL ES Cubemap. Must be disposed when it is no longer used.
  * @author Xoppa */
 public class Cubemap extends GLTexture {
-	private static AssetManager assetManager;
-	final static Map<Application, Array<Cubemap>> managedCubemaps = new HashMap<Application, Array<Cubemap>>();
-
 	/** Enum to identify each side of a Cubemap */
 	public enum CubemapSide {
 		/** The positive X and first side of the cubemap */
@@ -71,13 +62,12 @@ public class Cubemap extends GLTexture {
 		}
 	}
 
-	protected CubemapData data;
+	protected final TextureData[] data = new TextureData[6];
 
-	/** Construct an Cubemap based on the given CubemapData. */
-	public Cubemap (CubemapData data) {
-		super(GL20.GL_TEXTURE_CUBE_MAP);
-		this.data = data;
-		load(data);
+	/** Construct an empty Cubemap. Use the load(...) methods to set the texture of each side. Every side of the cubemap must be set
+	 * before it can be used. */
+	public Cubemap () {
+		this((TextureData)null, (TextureData)null, (TextureData)null, (TextureData)null, (TextureData)null, (TextureData)null);
 	}
 
 	/** Construct a Cubemap with the specified texture files for the sides, does not generate mipmaps. */
@@ -125,155 +115,142 @@ public class Cubemap extends GLTexture {
 		magFilter = TextureFilter.Nearest;
 		uWrap = TextureWrap.ClampToEdge;
 		vWrap = TextureWrap.ClampToEdge;
-		data = new FacedCubemapData(positiveX, negativeX, positiveY, negativeY, positiveZ, negativeZ);
-		load(data);
+		load(positiveX, negativeX, positiveY, negativeY, positiveZ, negativeZ);
 	}
 
-	/** Sets the sides of this cubemap to the specified {@link CubemapData}. */
-	public void load (CubemapData data) {
-		if (!data.isPrepared()) data.prepare();
+	/** Sets the sides of this cubemap to the specified {@link TextureData}. */
+	public void load (TextureData positiveX, TextureData negativeX, TextureData positiveY, TextureData negativeY,
+		TextureData positiveZ, TextureData negativeZ) {
 		bind();
 		unsafeSetFilter(minFilter, magFilter, true);
 		unsafeSetWrap(uWrap, vWrap, true);
-		data.consumeCubemapData();
+		unsafeLoad(CubemapSide.PositiveX, positiveX);
+		unsafeLoad(CubemapSide.NegativeX, negativeX);
+		unsafeLoad(CubemapSide.PositiveY, positiveY);
+		unsafeLoad(CubemapSide.NegativeY, negativeY);
+		unsafeLoad(CubemapSide.PositiveZ, positiveZ);
+		unsafeLoad(CubemapSide.NegativeZ, negativeZ);
 		Gdx.gl.glBindTexture(glTarget, 0);
 	}
 
-	public CubemapData getCubemapData () {
-		return data;
-	}
-
 	@Override
 	public boolean isManaged () {
-		return data.isManaged();
+		for (TextureData data : this.data)
+			if (!data.isManaged()) return false;
+		return true;
 	}
 
 	@Override
 	protected void reload () {
 		if (!isManaged()) throw new GdxRuntimeException("Tried to reload an unmanaged Cubemap");
 		glHandle = createGLHandle();
-		load(data);
-	}
-
-	@Override
-	public int getWidth () {
-		return data.getWidth();
+		load(data[CubemapSide.PositiveX.index], data[CubemapSide.NegativeX.index], data[CubemapSide.PositiveY.index],
+			data[CubemapSide.NegativeY.index], data[CubemapSide.PositiveZ.index], data[CubemapSide.NegativeZ.index]);
 	}
 
-	@Override
-	public int getHeight () {
-		return data.getHeight();
+	/** Loads the texture specified using the {@link FileHandle} and sets it to specified side, overwriting any previous data set to
+	 * that side. Does not generate mipmaps. This method binds the Cubemap to the active unit!
+	 * @param side The {@link CubemapSide}
+	 * @param file The texture {@link FileHandle} */
+	public void load (CubemapSide side, FileHandle file) {
+		load(side, file, false);
 	}
 
-	@Override
-	public int getDepth () {
-		return 0;
+	/** Loads the texture specified using the {@link FileHandle} and sets it to specified side, overwriting any previous data set to
+	 * that side. This method binds the Cubemap to the active unit!
+	 * @param side The {@link CubemapSide}
+	 * @param file The texture {@link FileHandle}
+	 * @param useMipMaps True to generate mipmaps. */
+	public void load (CubemapSide side, FileHandle file, boolean useMipMaps) {
+		load(side, createTextureData(file, useMipMaps));
 	}
 
-	/** Disposes all resources associated with the cubemap */
-	public void dispose () {
-		// this is a hack. reason: we have to set the glHandle to 0 for textures that are
-		// reloaded through the asset manager as we first remove (and thus dispose) the texture
-		// and then reload it. the glHandle is set to 0 in invalidateAllTextures prior to
-		// removal from the asset manager.
-		if (glHandle == 0) return;
-		delete();
-		if (data.isManaged()) if (managedCubemaps.get(Gdx.app) != null) managedCubemaps.get(Gdx.app).removeValue(this, true);
+	/** Sets the specified side of this cubemap to the specified {@link Pixmap}, overwriting any previous data set to that side.
+	 * Does not generate mipmaps. This method binds the Cubemap to the active unit!
+	 * @param side The {@link CubemapSide}
+	 * @param pixmap The {@link Pixmap} */
+	public void load (CubemapSide side, Pixmap pixmap) {
+		load(side, pixmap == null ? null : new PixmapTextureData(pixmap, null, false, false));
 	}
 
-	private static void addManagedCubemap (Application app, Cubemap cubemap) {
-		Array<Cubemap> managedCubemapArray = managedCubemaps.get(app);
-		if (managedCubemapArray == null) managedCubemapArray = new Array<Cubemap>();
-		managedCubemapArray.add(cubemap);
-		managedCubemaps.put(app, managedCubemapArray);
+	/** Sets the specified side of this cubemap to the specified {@link Pixmap}, overwriting any previous data set to that side.
+	 * This method binds the Cubemap to the active unit!
+	 * @param side The {@link CubemapSide}
+	 * @param pixmap The {@link Pixmap}
+	 * @param useMipMaps True to generate mipmaps. */
+	public void load (CubemapSide side, Pixmap pixmap, boolean useMipMaps) {
+		load(side, pixmap == null ? null : new PixmapTextureData(pixmap, null, useMipMaps, false));
 	}
 
-	/** Clears all managed cubemaps. This is an internal method. Do not use it! */
-	public static void clearAllCubemaps (Application app) {
-		managedCubemaps.remove(app);
+	/** Sets the specified side of this cubemap to the specified {@link TextureData}, overwriting any previous data set to that
+	 * side. This method binds the Cubemap to the active unit!
+	 * @param side The {@link CubemapSide}
+	 * @param data The {@link TextureData} */
+	public void load (CubemapSide side, TextureData data) {
+		bind();
+		unsafeLoad(side, data);
+		Gdx.gl.glBindTexture(glTarget, 0);
 	}
 
-	/** Invalidate all managed cubemaps. This is an internal method. Do not use it! */
-	public static void invalidateAllCubemaps (Application app) {
-		Array<Cubemap> managedCubemapArray = managedCubemaps.get(app);
-		if (managedCubemapArray == null) return;
+	/** Sets the specified side of this cubemap to the specified {@link TextureData}, overwriting any previous data set to that
+	 * side. Assumes that the cubemap is bound and active! See also: {@link #load(CubemapSide, TextureData)}
+	 * @param side The {@link CubemapSide}
+	 * @param data The {@link TextureData} */
+	protected void unsafeLoad (CubemapSide side, TextureData data) {
+		final int idx = side.index;
+		if (this.data[idx] != null && data != null && data.isManaged() != this.data[idx].isManaged())
+			throw new GdxRuntimeException("New data must have the same managed status as the old data");
 
-		if (assetManager == null) {
-			for (int i = 0; i < managedCubemapArray.size; i++) {
-				Cubemap cubemap = managedCubemapArray.get(i);
-				cubemap.reload();
-			}
-		} else {
-			// first we have to make sure the AssetManager isn't loading anything anymore,
-			// otherwise the ref counting trick below wouldn't work (when a cubemap is
-			// currently on the task stack of the manager.)
-			assetManager.finishLoading();
+		uploadImageData(side.glEnum, data);
 
-			// next we go through each cubemap and reload either directly or via the
-			// asset manager.
-			Array<Cubemap> cubemaps = new Array<Cubemap>(managedCubemapArray);
-			for (Cubemap cubemap : cubemaps) {
-				String fileName = assetManager.getAssetFileName(cubemap);
-				if (fileName == null) {
-					cubemap.reload();
-				} else {
-					// get the ref count of the cubemap, then set it to 0 so we
-					// can actually remove it from the assetmanager. Also set the
-					// handle to zero, otherwise we might accidentially dispose
-					// already reloaded cubemaps.
-					final int refCount = assetManager.getReferenceCount(fileName);
-					assetManager.setReferenceCount(fileName, 0);
-					cubemap.glHandle = 0;
-
-					// create the parameters, passing the reference to the cubemap as
-					// well as a callback that sets the ref count.
-					CubemapParameter params = new CubemapParameter();
-					params.cubemapData = cubemap.getCubemapData();
-					params.minFilter = cubemap.getMinFilter();
-					params.magFilter = cubemap.getMagFilter();
-					params.wrapU = cubemap.getUWrap();
-					params.wrapV = cubemap.getVWrap();
-					params.cubemap = cubemap; // special parameter which will ensure that the references stay the same.
-					params.loadedCallback = new LoadedCallback() {
-						@Override
-						public void finishedLoading (AssetManager assetManager, String fileName, Class type) {
-							assetManager.setReferenceCount(fileName, refCount);
-						}
-					};
+		this.data[idx] = data;
+	}
 
-					// unload the c, create a new gl handle then reload it.
-					assetManager.unload(fileName);
-					cubemap.glHandle = GLTexture.createGLHandle();
-					assetManager.load(fileName, Cubemap.class, params);
-				}
-			}
-			managedCubemapArray.clear();
-			managedCubemapArray.addAll(cubemaps);
-		}
+	/** @return True if all sides of this cubemap are set, false otherwise. */
+	public boolean isComplete () {
+		for (int i = 0; i < data.length; i++)
+			if (data[i] == null) return false;
+		return true;
 	}
 
-	/** Sets the {@link AssetManager}. When the context is lost, cubemaps managed by the asset manager are reloaded by the manager
-	 * on a separate thread (provided that a suitable {@link AssetLoader} is registered with the manager). Cubemaps not managed by
-	 * the AssetManager are reloaded via the usual means on the rendering thread.
-	 * @param manager the asset manager. */
-	public static void setAssetManager (AssetManager manager) {
-		Cubemap.assetManager = manager;
+	/** @return The {@link TextureData} for the specified side, can be null if the cubemap is incomplete. */
+	public TextureData getTextureData (CubemapSide side) {
+		return data[side.index];
 	}
 
-	public static String getManagedStatus () {
-		StringBuilder builder = new StringBuilder();
-		builder.append("Managed cubemap/app: { ");
-		for (Application app : managedCubemaps.keySet()) {
-			builder.append(managedCubemaps.get(app).size);
-			builder.append(" ");
-		}
-		builder.append("}");
-		return builder.toString();
+	@Override
+	public int getWidth () {
+		int tmp, width = 0;
+		if (data[CubemapSide.PositiveZ.index] != null && (tmp = data[CubemapSide.PositiveZ.index].getWidth()) > width) width = tmp;
+		if (data[CubemapSide.NegativeZ.index] != null && (tmp = data[CubemapSide.NegativeZ.index].getWidth()) > width) width = tmp;
+		if (data[CubemapSide.PositiveY.index] != null && (tmp = data[CubemapSide.PositiveY.index].getWidth()) > width) width = tmp;
+		if (data[CubemapSide.NegativeY.index] != null && (tmp = data[CubemapSide.NegativeY.index].getWidth()) > width) width = tmp;
+		return width;
 	}
 
-	/** @return the number of managed cubemaps currently loaded */
-	public static int getNumManagedCubemaps () {
-		return managedCubemaps.get(Gdx.app).size;
+	@Override
+	public int getHeight () {
+		int tmp, height = 0;
+		if (data[CubemapSide.PositiveZ.index] != null && (tmp = data[CubemapSide.PositiveZ.index].getHeight()) > height)
+			height = tmp;
+		if (data[CubemapSide.NegativeZ.index] != null && (tmp = data[CubemapSide.NegativeZ.index].getHeight()) > height)
+			height = tmp;
+		if (data[CubemapSide.PositiveX.index] != null && (tmp = data[CubemapSide.PositiveX.index].getHeight()) > height)
+			height = tmp;
+		if (data[CubemapSide.NegativeX.index] != null && (tmp = data[CubemapSide.NegativeX.index].getHeight()) > height)
+			height = tmp;
+		return height;
 	}
 
+	@Override
+	public int getDepth () {
+		int tmp, depth = 0;
+		if (data[CubemapSide.PositiveX.index] != null && (tmp = data[CubemapSide.PositiveX.index].getWidth()) > depth) depth = tmp;
+		if (data[CubemapSide.NegativeX.index] != null && (tmp = data[CubemapSide.NegativeX.index].getWidth()) > depth) depth = tmp;
+		if (data[CubemapSide.PositiveY.index] != null && (tmp = data[CubemapSide.PositiveY.index].getHeight()) > depth)
+			depth = tmp;
+		if (data[CubemapSide.NegativeY.index] != null && (tmp = data[CubemapSide.NegativeY.index].getHeight()) > depth)
+			depth = tmp;
+		return depth;
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/CubemapData.java b/gdx/src/com/badlogic/gdx/graphics/CubemapData.java
deleted file mode 100644
index dfc86cc..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/CubemapData.java
+++ /dev/null
@@ -1,39 +0,0 @@
-
-package com.badlogic.gdx.graphics;
-
-import com.badlogic.gdx.graphics.Pixmap.Format;
-import com.badlogic.gdx.graphics.glutils.KTXTextureData;
-
-/** Used by a {@link Cubemap} to load the pixel data. The Cubemap will request the CubemapData to prepare itself through
- * {@link #prepare()} and upload its data using {@link #consumeCubemapData()}. These are the first methods to be called by Cubemap.
- * After that the Cubemap will invoke the other methods to find out about the size of the image data, the format, whether the
- * CubemapData is able to manage the pixel data if the OpenGL ES context is lost.</p>
- * 
- * Before a call to either {@link #consumeCubemapData()}, Cubemap will bind the OpenGL ES texture.</p>
- * 
- * Look at {@link KTXTextureData} for example implementation of this interface.
- * @author Vincent Bousquet */
-public interface CubemapData {
-
-	/** @return whether the TextureData is prepared or not. */
-	public boolean isPrepared ();
-
-	/** Prepares the TextureData for a call to {@link #consumeCubemapData()}. This method can be called from a non OpenGL thread and
-	 * should thus not interact with OpenGL. */
-	public void prepare ();
-
-	/** Uploads the pixel data for the 6 faces of the cube to the OpenGL ES texture. The caller must bind an OpenGL ES texture. A
-	 * call to {@link #prepare()} must preceed a call to this method. Any internal data structures created in {@link #prepare()}
-	 * should be disposed of here. */
-	public void consumeCubemapData ();
-
-	/** @return the width of the pixel data */
-	public int getWidth ();
-
-	/** @return the height of the pixel data */
-	public int getHeight ();
-
-	/** @return whether this implementation can cope with a EGL context loss. */
-	public boolean isManaged ();
-
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/GL20.java b/gdx/src/com/badlogic/gdx/graphics/GL20.java
index a8d5989..17eb49e 100644
--- a/gdx/src/com/badlogic/gdx/graphics/GL20.java
+++ b/gdx/src/com/badlogic/gdx/graphics/GL20.java
@@ -364,6 +364,8 @@ public interface GL20 {
 	public void glCullFace (int mode);
 
 	public void glDeleteTextures (int n, IntBuffer textures);
+	
+	public void glDeleteTexture (int texture);
 
 	public void glDepthFunc (int func);
 
@@ -386,6 +388,8 @@ public interface GL20 {
 	public void glFrontFace (int mode);
 
 	public void glGenTextures (int n, IntBuffer textures);
+	
+	public int glGenTexture ();
 
 	public int glGetError ();
 
@@ -450,13 +454,19 @@ public interface GL20 {
 	public int glCreateProgram ();
 
 	public int glCreateShader (int type);
+	
+	public void glDeleteBuffer (int buffer);
 
 	public void glDeleteBuffers (int n, IntBuffer buffers);
 
+	public void glDeleteFramebuffer (int framebuffer);
+	
 	public void glDeleteFramebuffers (int n, IntBuffer framebuffers);
 
 	public void glDeleteProgram (int program);
 
+	public void glDeleteRenderbuffer (int renderbuffer);
+	
 	public void glDeleteRenderbuffers (int n, IntBuffer renderbuffers);
 
 	public void glDeleteShader (int shader);
@@ -473,12 +483,18 @@ public interface GL20 {
 
 	public void glFramebufferTexture2D (int target, int attachment, int textarget, int texture, int level);
 
+	public int glGenBuffer ();
+	
 	public void glGenBuffers (int n, IntBuffer buffers);
 
 	public void glGenerateMipmap (int target);
 
+	public int glGenFramebuffer ();
+	
 	public void glGenFramebuffers (int n, IntBuffer framebuffers);
 
+	public int glGenRenderbuffer ();
+	
 	public void glGenRenderbuffers (int n, IntBuffer renderbuffers);
 
 	// deviates
@@ -571,40 +587,62 @@ public interface GL20 {
 	public void glUniform1f (int location, float x);
 
 	public void glUniform1fv (int location, int count, FloatBuffer v);
+	
+	public void glUniform1fv (int location, int count, float v[], int offset);
 
 	public void glUniform1i (int location, int x);
 
 	public void glUniform1iv (int location, int count, IntBuffer v);
+	
+	public void glUniform1iv (int location, int count, int v[], int offset);
 
 	public void glUniform2f (int location, float x, float y);
 
 	public void glUniform2fv (int location, int count, FloatBuffer v);
+	
+	public void glUniform2fv (int location, int count, float v[], int offset);
 
 	public void glUniform2i (int location, int x, int y);
 
 	public void glUniform2iv (int location, int count, IntBuffer v);
+	
+	public void glUniform2iv (int location, int count, int[] v, int offset);
 
 	public void glUniform3f (int location, float x, float y, float z);
 
 	public void glUniform3fv (int location, int count, FloatBuffer v);
+	
+	public void glUniform3fv (int location, int count, float[] v, int offset);
 
 	public void glUniform3i (int location, int x, int y, int z);
 
 	public void glUniform3iv (int location, int count, IntBuffer v);
+	
+	public void glUniform3iv (int location, int count, int v[], int offset);
 
 	public void glUniform4f (int location, float x, float y, float z, float w);
 
 	public void glUniform4fv (int location, int count, FloatBuffer v);
+	
+	public void glUniform4fv (int location, int count, float v[], int offset);
 
 	public void glUniform4i (int location, int x, int y, int z, int w);
 
 	public void glUniform4iv (int location, int count, IntBuffer v);
+	
+	public void glUniform4iv (int location, int count, int v[], int offset);
 
 	public void glUniformMatrix2fv (int location, int count, boolean transpose, FloatBuffer value);
+	
+	public void glUniformMatrix2fv (int location, int count, boolean transpose, float value[], int offset);
 
 	public void glUniformMatrix3fv (int location, int count, boolean transpose, FloatBuffer value);
+	
+	public void glUniformMatrix3fv (int location, int count, boolean transpose, float value[], int offset);
 
 	public void glUniformMatrix4fv (int location, int count, boolean transpose, FloatBuffer value);
+	
+	public void glUniformMatrix4fv (int location, int count, boolean transpose, float value[], int offset);
 
 	public void glUseProgram (int program);
 
diff --git a/gdx/src/com/badlogic/gdx/graphics/GLTexture.java b/gdx/src/com/badlogic/gdx/graphics/GLTexture.java
index 5eea2fa..33cf410 100644
--- a/gdx/src/com/badlogic/gdx/graphics/GLTexture.java
+++ b/gdx/src/com/badlogic/gdx/graphics/GLTexture.java
@@ -16,8 +16,6 @@
 
 package com.badlogic.gdx.graphics;
 
-import java.nio.IntBuffer;
-
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.files.FileHandle;
 import com.badlogic.gdx.graphics.Pixmap.Blending;
@@ -27,17 +25,13 @@ import com.badlogic.gdx.graphics.Texture.TextureWrap;
 import com.badlogic.gdx.graphics.TextureData.TextureDataType;
 import com.badlogic.gdx.graphics.glutils.ETC1TextureData;
 import com.badlogic.gdx.graphics.glutils.FileTextureData;
-import com.badlogic.gdx.graphics.glutils.KTXTextureData;
 import com.badlogic.gdx.graphics.glutils.MipMapGenerator;
-import com.badlogic.gdx.utils.BufferUtils;
 import com.badlogic.gdx.utils.Disposable;
 
 /** Class representing an OpenGL texture by its target and handle. Keeps track of its state like the TextureFilter and TextureWrap.
  * Also provides some (protected) static methods to create TextureData and upload image data.
  * @author badlogic, Xoppa */
 public abstract class GLTexture implements Disposable {
-	private static final IntBuffer buffer = BufferUtils.newIntBuffer(1);
-
 	/** The target of this texture, used when binding the texture, e.g. GL_TEXTURE_2D */
 	public final int glTarget;
 	protected int glHandle;
@@ -177,10 +171,7 @@ public abstract class GLTexture implements Disposable {
 	/** Destroys the OpenGL Texture as specified by the glHandle. */
 	protected void delete () {
 		if (glHandle != 0) {
-			buffer.put(0, glHandle);
-			buffer.position(0);
-			buffer.limit(1);
-			Gdx.gl.glDeleteTextures(1, buffer);
+			Gdx.gl.glDeleteTexture (glHandle);
 			glHandle = 0;
 		}
 	}
@@ -190,21 +181,18 @@ public abstract class GLTexture implements Disposable {
 		delete();
 	}
 
-	@Deprecated
 	protected static TextureData createTextureData (FileHandle file, Format format, boolean useMipMaps) {
-		return TextureData.Factory.loadFromFile(file, format, useMipMaps);
+		if (file == null) return null;
+		if (file.name().endsWith(".etc1")) return new ETC1TextureData(file, useMipMaps);
+		return new FileTextureData(file, null, format, useMipMaps);
 	}
 
-	@Deprecated
 	protected static TextureData createTextureData (FileHandle file, boolean useMipMaps) {
 		return createTextureData(file, null, useMipMaps);
 	}
 
 	protected static int createGLHandle () {
-		buffer.position(0);
-		buffer.limit(buffer.capacity());
-		Gdx.gl.glGenTextures(1, buffer);
-		return buffer.get(0);
+		return Gdx.gl.glGenTexture ();
 	}
 	
 	protected static void uploadImageData (int target, TextureData data) {
diff --git a/gdx/src/com/badlogic/gdx/graphics/Mesh.java b/gdx/src/com/badlogic/gdx/graphics/Mesh.java
index 0d80f6d..d6a8a84 100644
--- a/gdx/src/com/badlogic/gdx/graphics/Mesh.java
+++ b/gdx/src/com/badlogic/gdx/graphics/Mesh.java
@@ -44,8 +44,8 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
 
 /** <p>
  * A Mesh holds vertices composed of attributes specified by a {@link VertexAttributes} instance. The vertices are held either in
- * VRAM in form of vertex buffer objects or in RAM in form of vertex arrays. The former variant is more performant and is preferred
- * over vertex arrays if hardware supports it.
+ * VRAM in form of vertex buffer objects or in RAM in form of vertex arrays. The former variant is more performant and is
+ * preferred over vertex arrays if hardware supports it.
  * </p>
  * 
  * <p>
@@ -62,7 +62,7 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
  * exactly for this to work.
  * </p>
  * 
- * @author mzechner, Dave Clayton <contact@redskyforge.com> */
+ * @author mzechner, Dave Clayton <contact@redskyforge.com>, Xoppa */
 public class Mesh implements Disposable {
 	public enum VertexDataType {
 		VertexArray, VertexBufferObject, VertexBufferObjectSubData,
@@ -76,6 +76,14 @@ public class Mesh implements Disposable {
 	boolean autoBind = true;
 	final boolean isVertexArray;
 
+	protected Mesh (VertexData vertices, IndexData indices, boolean isVertexArray) {
+		this.vertices = vertices;
+		this.indices = indices;
+		this.isVertexArray = isVertexArray;
+
+		addManagedMesh(Gdx.app, this);
+	}
+
 	/** Creates a new Mesh with the given attributes.
 	 * 
 	 * @param isStatic whether this mesh is static or not. Allows for internal optimizations.
@@ -220,8 +228,7 @@ public class Mesh implements Disposable {
 		meshes[0].getVertices(vertices);
 		meshes[0].getIndices(indices);
 		int vcount = meshes[0].getNumVertices();
-		if (transformations != null)
-			transform(transformations[0], vertices, vertexSize, offset, numComponents, 0, vcount);
+		if (transformations != null) transform(transformations[0], vertices, vertexSize, offset, numComponents, 0, vcount);
 		int voffset = vcount;
 		int ioffset = meshes[0].getNumIndices();
 		for (int i = 1; i < meshes.length; i++) {
@@ -658,7 +665,9 @@ public class Mesh implements Disposable {
 	 * @return the value specified by out. */
 	public BoundingBox extendBoundingBox (final BoundingBox out, int offset, int count, final Matrix4 transform) {
 		int numIndices = getNumIndices();
-		if (offset < 0 || count < 1 || offset + count > numIndices) throw new GdxRuntimeException("Not enough indices ( offset="+offset+", count="+count+", max="+numIndices+" )");
+		if (offset < 0 || count < 1 || offset + count > numIndices)
+			throw new GdxRuntimeException("Not enough indices ( offset=" + offset + ", count=" + count + ", max=" + numIndices
+				+ " )");
 
 		final FloatBuffer verts = vertices.getBuffer();
 		final ShortBuffer index = indices.getBuffer();
@@ -824,9 +833,7 @@ public class Mesh implements Disposable {
 		Array<Mesh> meshesArray = meshes.get(app);
 		if (meshesArray == null) return;
 		for (int i = 0; i < meshesArray.size; i++) {
-			if (meshesArray.get(i).vertices instanceof VertexBufferObject) {
-				((VertexBufferObject)meshesArray.get(i).vertices).invalidate();
-			}
+			meshesArray.get(i).vertices.invalidate();
 			meshesArray.get(i).indices.invalidate();
 		}
 	}
diff --git a/gdx/src/com/badlogic/gdx/graphics/Texture.java b/gdx/src/com/badlogic/gdx/graphics/Texture.java
index aa75aad..8316d98 100644
--- a/gdx/src/com/badlogic/gdx/graphics/Texture.java
+++ b/gdx/src/com/badlogic/gdx/graphics/Texture.java
@@ -24,9 +24,6 @@ import com.badlogic.gdx.assets.loaders.AssetLoader;
 import com.badlogic.gdx.assets.loaders.TextureLoader.TextureParameter;
 import com.badlogic.gdx.files.FileHandle;
 import com.badlogic.gdx.graphics.Pixmap.Format;
-import com.badlogic.gdx.graphics.glutils.ETC1TextureData;
-import com.badlogic.gdx.graphics.glutils.FileTextureData;
-import com.badlogic.gdx.graphics.glutils.KTXTextureData;
 import com.badlogic.gdx.graphics.glutils.PixmapTextureData;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.GdxRuntimeException;
@@ -124,7 +121,7 @@ public class Texture extends GLTexture {
 		load(data);
 		if (data.isManaged()) addManagedTexture(Gdx.app, this);
 	}
-	
+
 	public void load (TextureData data) {
 		if (this.data != null && data.isManaged() != this.data.isManaged())
 			throw new GdxRuntimeException("New data must have the same managed status as the old data");
diff --git a/gdx/src/com/badlogic/gdx/graphics/TextureData.java b/gdx/src/com/badlogic/gdx/graphics/TextureData.java
index 47e04db..8f3c319 100644
--- a/gdx/src/com/badlogic/gdx/graphics/TextureData.java
+++ b/gdx/src/com/badlogic/gdx/graphics/TextureData.java
@@ -16,18 +16,16 @@
 
 package com.badlogic.gdx.graphics;
 
-import com.badlogic.gdx.files.FileHandle;
 import com.badlogic.gdx.graphics.Pixmap.Format;
 import com.badlogic.gdx.graphics.glutils.ETC1TextureData;
 import com.badlogic.gdx.graphics.glutils.FileTextureData;
-import com.badlogic.gdx.graphics.glutils.KTXTextureData;
 import com.badlogic.gdx.graphics.glutils.MipMapGenerator;
 
 /** Used by a {@link Texture} to load the pixel data. A TextureData can either return a {@link Pixmap} or upload the pixel data
  * itself. It signals it's type via {@link #getType()} to the Texture that's using it. The Texture will then either invoke
- * {@link #consumePixmap()} or {@link #consumeCustomData(int)}. These are the first methods to be called by Texture. After that
- * the Texture will invoke the other methods to find out about the size of the image data, the format, whether mipmaps should be
- * generated and whether the TextureData is able to manage the pixel data if the OpenGL ES context is lost.</p>
+ * {@link #consumePixmap()} or {@link #consumeCustomData(int)}. These are the first methods to be called by Texture. After
+ * that the Texture will invoke the other methods to find out about the size of the image data, the format, whether mipmaps should
+ * be generated and whether the TextureData is able to manage the pixel data if the OpenGL ES context is lost.</p>
  * 
  * In case the TextureData implementation has the type {@link TextureDataType#Custom}, the implementation has to generate the
  * mipmaps itself if necessary. See {@link MipMapGenerator}.</p>
@@ -64,7 +62,7 @@ public interface TextureData {
 	public boolean disposePixmap ();
 
 	/** Uploads the pixel data to the OpenGL ES texture. The caller must bind an OpenGL ES texture. A call to {@link #prepare()}
-	 * must preceed a call to this method. Any internal data structures created in {@link #prepare()} should be disposed of here. */
+	 * must preceed a call to this method. Any internal data structures created in {@link #prepare()}. */
 	public void consumeCustomData (int target);
 
 	/** @return the width of the pixel data */
@@ -81,23 +79,4 @@ public interface TextureData {
 
 	/** @return whether this implementation can cope with a EGL context loss. */
 	public boolean isManaged ();
-
-	/** Provides static method to instantiate the right implementation (Pixmap, ETC1, KTX).
-	 * @author Vincent Bousquet */
-	public static class Factory {
-
-		public static TextureData loadFromFile (FileHandle file, boolean useMipMaps) {
-			return loadFromFile(file, null, useMipMaps);
-		}
-
-		public static TextureData loadFromFile (FileHandle file, Format format, boolean useMipMaps) {
-			if (file == null) return null;
-			if (file.name().endsWith(".cim")) return new FileTextureData(file, PixmapIO.readCIM(file), format, useMipMaps);
-			if (file.name().endsWith(".etc1")) return new ETC1TextureData(file, useMipMaps);
-			if (file.name().endsWith(".ktx") || file.name().endsWith(".zktx")) return new KTXTextureData(file, useMipMaps);
-			return new FileTextureData(file, new Pixmap(file), format, useMipMaps);
-		}
-
-	}
-
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/PolygonRegionLoader.java b/gdx/src/com/badlogic/gdx/graphics/g2d/PolygonRegionLoader.java
index 4ca8d29..ec720f0 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/PolygonRegionLoader.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/PolygonRegionLoader.java
@@ -48,8 +48,7 @@ public class PolygonRegionLoader extends SynchronousAssetLoader<PolygonRegion, P
 		public int readerBuffer = 1024;
 
 		/** the possible file name extensions of the texture file */
-		public String[] textureExtensions = new String[] {"png", "PNG", "jpeg", "JPEG", "jpg", "JPG", "cim", "CIM", "etc1", "ETC1",
-			"ktx", "KTX", "zktx", "ZKTX"};
+		public String[] textureExtensions = new String[] {"png", "PNG", "jpeg", "JPEG", "jpg", "JPG", "cim", "CIM", "etc1", "ETC1"};
 
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/CubemapAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/CubemapAttribute.java
index 8033bf4..ab8eb09 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/CubemapAttribute.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/CubemapAttribute.java
@@ -17,7 +17,7 @@
 package com.badlogic.gdx.graphics.g3d.attributes;
 
 import com.badlogic.gdx.graphics.Cubemap;
-import com.badlogic.gdx.graphics.GLTexture;
+import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.graphics.g3d.Attribute;
 import com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor;
 import com.badlogic.gdx.utils.GdxRuntimeException;
@@ -67,6 +67,6 @@ public class CubemapAttribute extends Attribute {
 	public int hashCode () {
 		int result = super.hashCode();
 		result = 967 * result + textureDescription.hashCode();
-		return result;
+		return result; 
 	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/FacedCubemapData.java b/gdx/src/com/badlogic/gdx/graphics/glutils/FacedCubemapData.java
deleted file mode 100644
index 0e68816..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/FacedCubemapData.java
+++ /dev/null
@@ -1,182 +0,0 @@
-
-package com.badlogic.gdx.graphics.glutils;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.Cubemap;
-import com.badlogic.gdx.graphics.Cubemap.CubemapSide;
-import com.badlogic.gdx.graphics.CubemapData;
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.GLTexture;
-import com.badlogic.gdx.graphics.Pixmap;
-import com.badlogic.gdx.graphics.Pixmap.Blending;
-import com.badlogic.gdx.graphics.Pixmap.Format;
-import com.badlogic.gdx.graphics.Texture;
-import com.badlogic.gdx.graphics.TextureData;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-
-/** A FacedCubemapData holds a cubemap data definition based on a {@link TextureData} per face.
- * 
- * @author Vincent Nousquet */
-public class FacedCubemapData implements CubemapData {
-
-	protected final TextureData[] data = new TextureData[6];
-
-	/** Construct an empty Cubemap. Use the load(...) methods to set the texture of each side. Every side of the cubemap must be set
-	 * before it can be used. */
-	public FacedCubemapData () {
-		this((TextureData)null, (TextureData)null, (TextureData)null, (TextureData)null, (TextureData)null, (TextureData)null);
-	}
-
-	/** Construct a Cubemap with the specified texture files for the sides, optionally generating mipmaps. */
-	public FacedCubemapData (FileHandle positiveX, FileHandle negativeX, FileHandle positiveY, FileHandle negativeY,
-		FileHandle positiveZ, FileHandle negativeZ) {
-		this(TextureData.Factory.loadFromFile(positiveX, false), TextureData.Factory.loadFromFile(negativeX,
-			false), TextureData.Factory.loadFromFile(positiveY, false), TextureData.Factory.loadFromFile(
-			negativeY, false), TextureData.Factory.loadFromFile(positiveZ, false), TextureData.Factory
-			.loadFromFile(negativeZ, false));
-	}
-
-	/** Construct a Cubemap with the specified texture files for the sides, optionally generating mipmaps. */
-	public FacedCubemapData (FileHandle positiveX, FileHandle negativeX, FileHandle positiveY, FileHandle negativeY,
-		FileHandle positiveZ, FileHandle negativeZ, boolean useMipMaps) {
-		this(TextureData.Factory.loadFromFile(positiveX, useMipMaps), TextureData.Factory.loadFromFile(
-			negativeX, useMipMaps), TextureData.Factory.loadFromFile(positiveY, useMipMaps), TextureData.Factory
-			.loadFromFile(negativeY, useMipMaps), TextureData.Factory.loadFromFile(positiveZ, useMipMaps),
-			TextureData.Factory.loadFromFile(negativeZ, useMipMaps));
-	}
-
-	/** Construct a Cubemap with the specified {@link Pixmap}s for the sides, does not generate mipmaps. */
-	public FacedCubemapData (Pixmap positiveX, Pixmap negativeX, Pixmap positiveY, Pixmap negativeY, Pixmap positiveZ,
-		Pixmap negativeZ) {
-		this(positiveX, negativeX, positiveY, negativeY, positiveZ, negativeZ, false);
-	}
-
-	/** Construct a Cubemap with the specified {@link Pixmap}s for the sides, optionally generating mipmaps. */
-	public FacedCubemapData (Pixmap positiveX, Pixmap negativeX, Pixmap positiveY, Pixmap negativeY, Pixmap positiveZ,
-		Pixmap negativeZ, boolean useMipMaps) {
-		this(positiveX == null ? null : new PixmapTextureData(positiveX, null, useMipMaps, false), negativeX == null ? null
-			: new PixmapTextureData(negativeX, null, useMipMaps, false), positiveY == null ? null : new PixmapTextureData(positiveY,
-			null, useMipMaps, false), negativeY == null ? null : new PixmapTextureData(negativeY, null, useMipMaps, false),
-			positiveZ == null ? null : new PixmapTextureData(positiveZ, null, useMipMaps, false), negativeZ == null ? null
-				: new PixmapTextureData(negativeZ, null, useMipMaps, false));
-	}
-
-	/** Construct a Cubemap with {@link Pixmap}s for each side of the specified size. */
-	public FacedCubemapData (int width, int height, int depth, Format format) {
-		this(new PixmapTextureData(new Pixmap(depth, height, format), null, false, true), new PixmapTextureData(new Pixmap(depth,
-			height, format), null, false, true), new PixmapTextureData(new Pixmap(width, depth, format), null, false, true),
-			new PixmapTextureData(new Pixmap(width, depth, format), null, false, true), new PixmapTextureData(new Pixmap(width,
-				height, format), null, false, true), new PixmapTextureData(new Pixmap(width, height, format), null, false, true));
-	}
-
-	/** Construct a Cubemap with the specified {@link TextureData}'s for the sides */
-	public FacedCubemapData (TextureData positiveX, TextureData negativeX, TextureData positiveY, TextureData negativeY,
-		TextureData positiveZ, TextureData negativeZ) {
-		data[0] = positiveX;
-		data[1] = negativeX;
-		data[2] = positiveY;
-		data[3] = negativeY;
-		data[4] = positiveZ;
-		data[5] = negativeZ;
-	}
-
-	@Override
-	public boolean isManaged () {
-		for (TextureData data : this.data)
-			if (!data.isManaged()) return false;
-		return true;
-	}
-
-	/** Loads the texture specified using the {@link FileHandle} and sets it to specified side, overwriting any previous data set to
-	 * that side. Note that you need to reload through {@link Cubemap#load(CubemapData)} any cubemap using this data for the change
-	 * to be taken in account.
-	 * @param side The {@link CubemapSide}
-	 * @param file The texture {@link FileHandle} */
-	public void load (CubemapSide side, FileHandle file) {
-		data[side.index] = TextureData.Factory.loadFromFile(file, false);
-	}
-
-	/** Sets the specified side of this cubemap to the specified {@link Pixmap}, overwriting any previous data set to that side.
-	 * Note that you need to reload through {@link Cubemap#load(CubemapData)} any cubemap using this data for the change to be
-	 * taken in account.
-	 * @param side The {@link CubemapSide}
-	 * @param pixmap The {@link Pixmap} */
-	public void load (CubemapSide side, Pixmap pixmap) {
-		data[side.index] = pixmap == null ? null : new PixmapTextureData(pixmap, null, false, false);
-	}
-
-	/** @return True if all sides of this cubemap are set, false otherwise. */
-	public boolean isComplete () {
-		for (int i = 0; i < data.length; i++)
-			if (data[i] == null) return false;
-		return true;
-	}
-
-	/** @return The {@link TextureData} for the specified side, can be null if the cubemap is incomplete. */
-	public TextureData getTextureData (CubemapSide side) {
-		return data[side.index];
-	}
-
-	@Override
-	public int getWidth () {
-		int tmp, width = 0;
-		if (data[CubemapSide.PositiveZ.index] != null && (tmp = data[CubemapSide.PositiveZ.index].getWidth()) > width) width = tmp;
-		if (data[CubemapSide.NegativeZ.index] != null && (tmp = data[CubemapSide.NegativeZ.index].getWidth()) > width) width = tmp;
-		if (data[CubemapSide.PositiveY.index] != null && (tmp = data[CubemapSide.PositiveY.index].getWidth()) > width) width = tmp;
-		if (data[CubemapSide.NegativeY.index] != null && (tmp = data[CubemapSide.NegativeY.index].getWidth()) > width) width = tmp;
-		return width;
-	}
-
-	@Override
-	public int getHeight () {
-		int tmp, height = 0;
-		if (data[CubemapSide.PositiveZ.index] != null && (tmp = data[CubemapSide.PositiveZ.index].getHeight()) > height)
-			height = tmp;
-		if (data[CubemapSide.NegativeZ.index] != null && (tmp = data[CubemapSide.NegativeZ.index].getHeight()) > height)
-			height = tmp;
-		if (data[CubemapSide.PositiveX.index] != null && (tmp = data[CubemapSide.PositiveX.index].getHeight()) > height)
-			height = tmp;
-		if (data[CubemapSide.NegativeX.index] != null && (tmp = data[CubemapSide.NegativeX.index].getHeight()) > height)
-			height = tmp;
-		return height;
-	}
-
-	@Override
-	public boolean isPrepared () {
-		return false;
-	}
-
-	@Override
-	public void prepare () {
-		if (!isComplete()) throw new GdxRuntimeException("You need to complete your cubemap data before using it");
-		for (int i = 0; i < data.length; i++)
-			if (!data[i].isPrepared()) data[i].prepare();
-	}
-
-	@Override
-	public void consumeCubemapData () {
-		for (int i = 0; i < data.length; i++) {
-			if (data[i].getType() == TextureData.TextureDataType.Custom) {
-				data[i].consumeCustomData(GL20.GL_TEXTURE_CUBE_MAP_POSITIVE_X + i);
-			} else {
-				Pixmap pixmap = data[i].consumePixmap();
-				boolean disposePixmap = data[i].disposePixmap();
-				if (data[i].getFormat() != pixmap.getFormat()) {
-					Pixmap tmp = new Pixmap(pixmap.getWidth(), pixmap.getHeight(), data[i].getFormat());
-					Blending blend = Pixmap.getBlending();
-					Pixmap.setBlending(Blending.None);
-					tmp.drawPixmap(pixmap, 0, 0, 0, 0, pixmap.getWidth(), pixmap.getHeight());
-					Pixmap.setBlending(blend);
-					if (data[i].disposePixmap()) pixmap.dispose();
-					pixmap = tmp;
-					disposePixmap = true;
-				}
-				Gdx.gl.glPixelStorei(GL20.GL_UNPACK_ALIGNMENT, 1);
-				Gdx.gl.glTexImage2D(GL20.GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, pixmap.getGLInternalFormat(), pixmap.getWidth(),
-					pixmap.getHeight(), 0, pixmap.getGLFormat(), pixmap.getGLType(), pixmap.getPixels());
-			}
-		}
-	}
-
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/KTXTextureData.java b/gdx/src/com/badlogic/gdx/graphics/glutils/KTXTextureData.java
deleted file mode 100644
index 63d501d..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/KTXTextureData.java
+++ /dev/null
@@ -1,355 +0,0 @@
-
-package com.badlogic.gdx.graphics.glutils;
-
-import java.io.BufferedInputStream;
-import java.io.DataInputStream;
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.nio.IntBuffer;
-import java.util.zip.GZIPInputStream;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.Cubemap;
-import com.badlogic.gdx.graphics.CubemapData;
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.Pixmap;
-import com.badlogic.gdx.graphics.Pixmap.Format;
-import com.badlogic.gdx.graphics.Texture;
-import com.badlogic.gdx.graphics.TextureData;
-import com.badlogic.gdx.graphics.glutils.ETC1.ETC1Data;
-import com.badlogic.gdx.utils.BufferUtils;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-import com.badlogic.gdx.utils.StreamUtils;
-
-/** A KTXTextureData holds the data from a KTX (or zipped KTX file, aka ZKTX). That is to say an OpenGL ready texture data. The KTX
- * file format is just a thin wrapper around OpenGL textures and therefore is compatible with most OpenGL texture capabilities
- * like texture compression, cubemapping, mipmapping, etc.
- * 
- * For example, KTXTextureData can be used for {@link Texture} or {@link Cubemap}.
- * 
- * @author Vincent Bousquet */
-public class KTXTextureData implements TextureData, CubemapData {
-
-	// The file we are loading
-	private FileHandle file;
-
-	// KTX header (only available after preparing)
-	private int glType;
-	private int glTypeSize;
-	private int glFormat;
-	private int glInternalFormat;
-	private int glBaseInternalFormat;
-	private int pixelWidth = -1;
-	private int pixelHeight = -1;
-	private int pixelDepth = -1;
-	private int numberOfArrayElements;
-	private int numberOfFaces;
-	private int numberOfMipmapLevels;
-	private int imagePos;
-
-	// KTX image data (only available after preparing and before consuming)
-	private ByteBuffer compressedData;
-
-	// Whether to generate mipmaps if they are not included in the file
-	private boolean useMipMaps;
-
-	public KTXTextureData (FileHandle file, boolean genMipMaps) {
-		this.file = file;
-		this.useMipMaps = genMipMaps;
-	}
-
-	@Override
-	public TextureDataType getType () {
-		return TextureDataType.Custom;
-	}
-
-	@Override
-	public boolean isPrepared () {
-		return compressedData != null;
-	}
-
-	@Override
-	public void prepare () {
-		if (compressedData != null) throw new GdxRuntimeException("Already prepared");
-		if (file == null) throw new GdxRuntimeException("Need a file to load from");
-		// We support normal ktx files as well as 'zktx' which are gzip ktx file with an int length at the beginning (like ETC1).
-		if (file.name().endsWith(".zktx")) {
-			byte[] buffer = new byte[1024 * 10];
-			DataInputStream in = null;
-			try {
-				in = new DataInputStream(new BufferedInputStream(new GZIPInputStream(file.read())));
-				int fileSize = in.readInt();
-				compressedData = BufferUtils.newUnsafeByteBuffer(fileSize);
-				int readBytes = 0;
-				while ((readBytes = in.read(buffer)) != -1)
-					compressedData.put(buffer, 0, readBytes);
-				compressedData.position(0);
-				compressedData.limit(compressedData.capacity());
-			} catch (Exception e) {
-				throw new GdxRuntimeException("Couldn't load zktx file '" + file + "'", e);
-			} finally {
-				StreamUtils.closeQuietly(in);
-			}
-		} else {
-			compressedData = ByteBuffer.wrap(file.readBytes());
-		}
-		if (compressedData.get() != (byte)0x0AB) throw new GdxRuntimeException("Invalid KTX Header");
-		if (compressedData.get() != (byte)0x04B) throw new GdxRuntimeException("Invalid KTX Header");
-		if (compressedData.get() != (byte)0x054) throw new GdxRuntimeException("Invalid KTX Header");
-		if (compressedData.get() != (byte)0x058) throw new GdxRuntimeException("Invalid KTX Header");
-		if (compressedData.get() != (byte)0x020) throw new GdxRuntimeException("Invalid KTX Header");
-		if (compressedData.get() != (byte)0x031) throw new GdxRuntimeException("Invalid KTX Header");
-		if (compressedData.get() != (byte)0x031) throw new GdxRuntimeException("Invalid KTX Header");
-		if (compressedData.get() != (byte)0x0BB) throw new GdxRuntimeException("Invalid KTX Header");
-		if (compressedData.get() != (byte)0x00D) throw new GdxRuntimeException("Invalid KTX Header");
-		if (compressedData.get() != (byte)0x00A) throw new GdxRuntimeException("Invalid KTX Header");
-		if (compressedData.get() != (byte)0x01A) throw new GdxRuntimeException("Invalid KTX Header");
-		if (compressedData.get() != (byte)0x00A) throw new GdxRuntimeException("Invalid KTX Header");
-		int endianTag = compressedData.getInt();
-		if (endianTag != 0x04030201 && endianTag != 0x01020304) throw new GdxRuntimeException("Invalid KTX Header");
-		if (endianTag != 0x04030201)
-			compressedData.order(compressedData.order() == ByteOrder.BIG_ENDIAN ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);
-		glType = compressedData.getInt();
-		glTypeSize = compressedData.getInt();
-		glFormat = compressedData.getInt();
-		glInternalFormat = compressedData.getInt();
-		glBaseInternalFormat = compressedData.getInt();
-		pixelWidth = compressedData.getInt();
-		pixelHeight = compressedData.getInt();
-		pixelDepth = compressedData.getInt();
-		numberOfArrayElements = compressedData.getInt();
-		numberOfFaces = compressedData.getInt();
-		numberOfMipmapLevels = compressedData.getInt();
-		int bytesOfKeyValueData = compressedData.getInt();
-		imagePos = compressedData.position() + bytesOfKeyValueData;
-		if (!compressedData.isDirect()) {
-			int pos = imagePos;
-			for (int level = 0; level < numberOfMipmapLevels; level++) {
-				int faceLodSize = compressedData.getInt(pos);
-				int faceLodSizeRounded = (faceLodSize + 3) & ~3;
-				pos += faceLodSizeRounded * numberOfFaces + 4;
-			}
-			compressedData.limit(pos);
-			compressedData.position(0);
-			ByteBuffer directBuffer = BufferUtils.newUnsafeByteBuffer(pos);
-			directBuffer.order(compressedData.order());
-			directBuffer.put(compressedData);
-			compressedData = directBuffer;
-		}
-	}
-
-	private static final int GL_TEXTURE_1D = 0x1234;
-	private static final int GL_TEXTURE_3D = 0x1234;
-	private static final int GL_TEXTURE_1D_ARRAY_EXT = 0x1234;
-	private static final int GL_TEXTURE_2D_ARRAY_EXT = 0x1234;
-
-	@Override
-	public void consumeCubemapData () {
-		consumeCustomData(GL20.GL_TEXTURE_CUBE_MAP);
-	}
-
-	@Override
-	public void consumeCustomData (int target) {
-		if (compressedData == null) throw new GdxRuntimeException("Call prepare() before calling consumeCompressedData()");
-		IntBuffer buffer = BufferUtils.newIntBuffer(16);
-
-		// Check OpenGL type and format, detect compressed data format (no type & format)
-		boolean compressed = false;
-		if (glType == 0 || glFormat == 0) {
-			if (glType + glFormat != 0) throw new GdxRuntimeException("either both or none of glType, glFormat must be zero");
-			compressed = true;
-		}
-
-		// find OpenGL texture target and dimensions
-		int textureDimensions = 1;
-		int glTarget = GL_TEXTURE_1D;
-		if (pixelHeight > 0) {
-			textureDimensions = 2;
-			glTarget = GL20.GL_TEXTURE_2D;
-		}
-		if (pixelDepth > 0) {
-			textureDimensions = 3;
-			glTarget = GL_TEXTURE_3D;
-		}
-		if (numberOfFaces == 6) {
-			if (textureDimensions == 2)
-				glTarget = GL20.GL_TEXTURE_CUBE_MAP;
-			else
-				throw new GdxRuntimeException("cube map needs 2D faces");
-		} else if (numberOfFaces != 1) {
-			throw new GdxRuntimeException("numberOfFaces must be either 1 or 6");
-		}
-		if (numberOfArrayElements > 0) {
-			if (glTarget == GL_TEXTURE_1D)
-				glTarget = GL_TEXTURE_1D_ARRAY_EXT;
-			else if (glTarget == GL20.GL_TEXTURE_2D)
-				glTarget = GL_TEXTURE_2D_ARRAY_EXT;
-			else
-				throw new GdxRuntimeException("No API for 3D and cube arrays yet");
-			textureDimensions++;
-		}
-		if (glTarget == 0x1234)
-			throw new GdxRuntimeException("Unsupported texture format (only 2D texture are supported in LibGdx for the time being)");
-
-		int singleFace = -1;
-		if (numberOfFaces == 6 && target != GL20.GL_TEXTURE_CUBE_MAP) {
-			// Load a single face of the cube (should be avoided since the data is unloaded afterwards)
-			if (!(GL20.GL_TEXTURE_CUBE_MAP_POSITIVE_X <= target && target <= GL20.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z))
-				throw new GdxRuntimeException(
-					"You must specify either GL_TEXTURE_CUBE_MAP to bind all 6 faces of the cube or the requested face GL_TEXTURE_CUBE_MAP_POSITIVE_X and followings.");
-			singleFace = target - GL20.GL_TEXTURE_CUBE_MAP_POSITIVE_X;
-			target = GL20.GL_TEXTURE_CUBE_MAP_POSITIVE_X;
-		} else if (numberOfFaces == 6 && target == GL20.GL_TEXTURE_CUBE_MAP) {
-			// Load the 6 faces
-			target = GL20.GL_TEXTURE_CUBE_MAP_POSITIVE_X;
-		} else {
-			// Load normal texture
-			if (target != glTarget
-				&& !(GL20.GL_TEXTURE_CUBE_MAP_POSITIVE_X <= target && target <= GL20.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z && target == GL20.GL_TEXTURE_2D))
-				throw new GdxRuntimeException("Invalid target requested : 0x" + Integer.toHexString(target) + ", expecting : 0x"
-					+ Integer.toHexString(glTarget));
-		}
-
-		// KTX files require an unpack alignment of 4
-		Gdx.gl.glGetIntegerv(GL20.GL_UNPACK_ALIGNMENT, buffer);
-		int previousUnpackAlignment = buffer.get(0);
-		if (previousUnpackAlignment != 4) Gdx.gl.glPixelStorei(GL20.GL_UNPACK_ALIGNMENT, 4);
-		int glInternalFormat = this.glInternalFormat;
-		int glFormat = this.glFormat;
-		int pos = imagePos;
-		for (int level = 0; level < numberOfMipmapLevels; level++) {
-			int pixelWidth = Math.max(1, this.pixelWidth >> level);
-			int pixelHeight = Math.max(1, this.pixelHeight >> level);
-			int pixelDepth = Math.max(1, this.pixelDepth >> level);
-			compressedData.position(pos);
-			int faceLodSize = compressedData.getInt();
-			int faceLodSizeRounded = (faceLodSize + 3) & ~3;
-			pos += 4;
-			for (int face = 0; face < numberOfFaces; face++) {
-				compressedData.position(pos);
-				pos += faceLodSizeRounded;
-				if (singleFace != -1 && singleFace != face) continue;
-				ByteBuffer data = compressedData.slice();
-				data.limit(faceLodSizeRounded);
-				if (textureDimensions == 1) {
-					// if (compressed)
-					// Gdx.gl.glCompressedTexImage1D(target + face, level, glInternalFormat, pixelWidth, 0, faceLodSize,
-					// data);
-					// else
-					// Gdx.gl.glTexImage1D(target + face, level, glInternalFormat, pixelWidth, 0, glFormat, glType, data);
-				} else if (textureDimensions == 2) {
-					if (numberOfArrayElements > 0) pixelHeight = numberOfArrayElements;
-					if (compressed) {
-						if (glInternalFormat == ETC1.ETC1_RGB8_OES) {
-							if (!Gdx.graphics.supportsExtension("GL_OES_compressed_ETC1_RGB8_texture")) {
-								ETC1Data etcData = new ETC1Data(pixelWidth, pixelHeight, data, 0);
-								Pixmap pixmap = ETC1.decodeImage(etcData, Format.RGB888);
-								Gdx.gl.glTexImage2D(target + face, level, pixmap.getGLInternalFormat(), pixmap.getWidth(),
-									pixmap.getHeight(), 0, pixmap.getGLFormat(), pixmap.getGLType(), pixmap.getPixels());
-								pixmap.dispose();
-							} else {
-								Gdx.gl.glCompressedTexImage2D(target + face, level, glInternalFormat, pixelWidth, pixelHeight, 0,
-									faceLodSize, data);
-							}
-						} else {
-							// Try to load (no software unpacking fallback)
-							Gdx.gl.glCompressedTexImage2D(target + face, level, glInternalFormat, pixelWidth, pixelHeight, 0,
-								faceLodSize, data);
-						}
-					} else
-						Gdx.gl.glTexImage2D(target + face, level, glInternalFormat, pixelWidth, pixelHeight, 0, glFormat, glType, data);
-				} else if (textureDimensions == 3) {
-					if (numberOfArrayElements > 0) pixelDepth = numberOfArrayElements;
-					// if (compressed)
-					// Gdx.gl.glCompressedTexImage3D(target + face, level, glInternalFormat, pixelWidth, pixelHeight, pixelDepth, 0,
-					// faceLodSize, data);
-					// else
-					// Gdx.gl.glTexImage3D(target + face, level, glInternalFormat, pixelWidth, pixelHeight, pixelDepth, 0, glFormat,
-					// glType, data);
-				}
-			}
-		}
-		if (previousUnpackAlignment != 4) Gdx.gl.glPixelStorei(GL20.GL_UNPACK_ALIGNMENT, previousUnpackAlignment);
-		if (useMipMaps && numberOfMipmapLevels == 1) Gdx.gl.glGenerateMipmap(target);
-
-		// dispose data once transfered to GPU
-		disposePreparedData();
-	}
-
-	public void disposePreparedData () {
-		if (compressedData != null) BufferUtils.disposeUnsafeByteBuffer(compressedData);
-		compressedData = null;
-	}
-
-	@Override
-	public Pixmap consumePixmap () {
-		throw new GdxRuntimeException("This TextureData implementation does not return a Pixmap");
-	}
-
-	@Override
-	public boolean disposePixmap () {
-		throw new GdxRuntimeException("This TextureData implementation does not return a Pixmap");
-	}
-
-	@Override
-	public int getWidth () {
-		return pixelWidth;
-	}
-
-	@Override
-	public int getHeight () {
-		return pixelHeight;
-	}
-
-	public int getNumberOfMipMapLevels () {
-		return numberOfMipmapLevels;
-	}
-
-	public int getNumberOfFaces () {
-		return numberOfFaces;
-	}
-
-	public int getGlInternalFormat () {
-		return glInternalFormat;
-	}
-
-	public ByteBuffer getData (int requestedLevel, int requestedFace) {
-		int pos = imagePos;
-		for (int level = 0; level < numberOfMipmapLevels; level++) {
-			int faceLodSize = compressedData.getInt(pos);
-			int faceLodSizeRounded = (faceLodSize + 3) & ~3;
-			pos += 4;
-			if (level == requestedLevel) {
-				for (int face = 0; face < numberOfFaces; face++) {
-					if (face == requestedFace) {
-						compressedData.position(pos);
-						ByteBuffer data = compressedData.slice();
-						data.limit(faceLodSizeRounded);
-						return data;
-					}
-					pos += faceLodSizeRounded;
-				}
-			} else {
-				pos += faceLodSizeRounded * numberOfFaces;
-			}
-		}
-		return null;
-	}
-
-	@Override
-	public Format getFormat () {
-		throw new GdxRuntimeException("This TextureData implementation directly handles texture formats.");
-	}
-
-	@Override
-	public boolean useMipMaps () {
-		return useMipMaps;
-	}
-
-	@Override
-	public boolean isManaged () {
-		return true;
-	}
-
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/ShaderProgram.java b/gdx/src/com/badlogic/gdx/graphics/glutils/ShaderProgram.java
index 3e5211a..40a794d 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/ShaderProgram.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/ShaderProgram.java
@@ -137,11 +137,6 @@ public class ShaderProgram implements Disposable {
 	/** whether this shader was invalidated **/
 	private boolean invalidated;
 
-	/** direct buffer for passing float and int uniform arrays **/
-	private ByteBuffer buffer = null;
-	private FloatBuffer floatBuffer = null;
-	private IntBuffer intBuffer = null;
-
 	/** reference count **/
 	private int refCount = 0;
 
@@ -455,76 +450,52 @@ public class ShaderProgram implements Disposable {
 		GL20 gl = Gdx.gl20;
 		checkManaged();
 		int location = fetchUniformLocation(name);
-		ensureBufferCapacity(length << 2);
-		floatBuffer.clear();
-		BufferUtils.copy(values, floatBuffer, length, offset);
-		gl.glUniform1fv(location, length, floatBuffer);
+		gl.glUniform1fv(location, length, values, offset);
 	}
 
 	public void setUniform1fv (int location, float[] values, int offset, int length) {
 		GL20 gl = Gdx.gl20;
 		checkManaged();
-		ensureBufferCapacity(length << 2);
-		floatBuffer.clear();
-		BufferUtils.copy(values, floatBuffer, length, offset);
-		gl.glUniform1fv(location, length, floatBuffer);
+		gl.glUniform1fv(location, length, values, offset);
 	}
 
 	public void setUniform2fv (String name, float[] values, int offset, int length) {
 		GL20 gl = Gdx.gl20;
 		checkManaged();
 		int location = fetchUniformLocation(name);
-		ensureBufferCapacity(length << 2);
-		floatBuffer.clear();
-		BufferUtils.copy(values, floatBuffer, length, offset);
-		gl.glUniform2fv(location, length / 2, floatBuffer);
+		gl.glUniform2fv(location, length / 2, values, offset);
 	}
 
 	public void setUniform2fv (int location, float[] values, int offset, int length) {
 		GL20 gl = Gdx.gl20;
 		checkManaged();
-		ensureBufferCapacity(length << 2);
-		floatBuffer.clear();
-		BufferUtils.copy(values, floatBuffer, length, offset);
-		gl.glUniform2fv(location, length / 2, floatBuffer);
+		gl.glUniform2fv(location, length / 2, values, offset);
 	}
 
 	public void setUniform3fv (String name, float[] values, int offset, int length) {
 		GL20 gl = Gdx.gl20;
 		checkManaged();
 		int location = fetchUniformLocation(name);
-		ensureBufferCapacity(length << 2);
-		floatBuffer.clear();
-		BufferUtils.copy(values, floatBuffer, length, offset);
-		gl.glUniform3fv(location, length / 3, floatBuffer);
+		gl.glUniform3fv(location, length / 3, values, offset);
 	}
 
 	public void setUniform3fv (int location, float[] values, int offset, int length) {
 		GL20 gl = Gdx.gl20;
 		checkManaged();
-		ensureBufferCapacity(length << 2);
-		floatBuffer.clear();
-		BufferUtils.copy(values, floatBuffer, length, offset);
-		gl.glUniform3fv(location, length / 3, floatBuffer);
+		gl.glUniform3fv(location, length / 3, values, offset);
 	}
 
 	public void setUniform4fv (String name, float[] values, int offset, int length) {
 		GL20 gl = Gdx.gl20;
 		checkManaged();
 		int location = fetchUniformLocation(name);
-		ensureBufferCapacity(length << 2);
-		floatBuffer.clear();
-		BufferUtils.copy(values, floatBuffer, length, offset);
-		gl.glUniform4fv(location, length / 4, floatBuffer);
+		gl.glUniform4fv(location, length / 4, values, offset);
 	}
 
 	public void setUniform4fv (int location, float[] values, int offset, int length) {
 		GL20 gl = Gdx.gl20;
 		checkManaged();
-		ensureBufferCapacity(length << 2);
-		floatBuffer.clear();
-		BufferUtils.copy(values, floatBuffer, length, offset);
-		gl.glUniform4fv(location, length / 4, floatBuffer);
+		gl.glUniform4fv(location, length / 4, values, offset);
 	}
 
 	/** Sets the uniform matrix with the given name. Throws an IllegalArgumentException in case it is not called in between a
@@ -543,12 +514,7 @@ public class ShaderProgram implements Disposable {
 	 * @param matrix the matrix
 	 * @param transpose whether the matrix should be transposed */
 	public void setUniformMatrix (String name, Matrix4 matrix, boolean transpose) {
-		GL20 gl = Gdx.gl20;
-		checkManaged();
-		int location = fetchUniformLocation(name);
-		this.matrix.clear();
-		BufferUtils.copy(matrix.val, this.matrix, matrix.val.length, 0);
-		gl.glUniformMatrix4fv(location, 1, transpose, this.matrix);
+		setUniformMatrix(fetchUniformLocation(name), matrix, transpose); 
 	}
 
 	public void setUniformMatrix (int location, Matrix4 matrix) {
@@ -558,9 +524,7 @@ public class ShaderProgram implements Disposable {
 	public void setUniformMatrix (int location, Matrix4 matrix, boolean transpose) {
 		GL20 gl = Gdx.gl20;
 		checkManaged();
-		this.matrix.clear();
-		BufferUtils.copy(matrix.val, this.matrix, matrix.val.length, 0);
-		gl.glUniformMatrix4fv(location, 1, transpose, this.matrix);
+		gl.glUniformMatrix4fv(location, 1, transpose, matrix.val, 0);
 	}
 
 	/** Sets the uniform matrix with the given name. Throws an IllegalArgumentException in case it is not called in between a
@@ -579,13 +543,7 @@ public class ShaderProgram implements Disposable {
 	 * @param matrix the matrix
 	 * @param transpose whether the uniform matrix should be transposed */
 	public void setUniformMatrix (String name, Matrix3 matrix, boolean transpose) {
-		GL20 gl = Gdx.gl20;
-		checkManaged();
-		int location = fetchUniformLocation(name);
-		float[] vals = matrix.getValues();
-		this.matrix.clear();
-		BufferUtils.copy(vals, this.matrix, vals.length, 0);
-		gl.glUniformMatrix3fv(location, 1, transpose, this.matrix);
+		setUniformMatrix(fetchUniformLocation(name), matrix, transpose);
 	}
 
 	public void setUniformMatrix (int location, Matrix3 matrix) {
@@ -595,10 +553,7 @@ public class ShaderProgram implements Disposable {
 	public void setUniformMatrix (int location, Matrix3 matrix, boolean transpose) {
 		GL20 gl = Gdx.gl20;
 		checkManaged();
-		float[] vals = matrix.getValues();
-		this.matrix.clear();
-		BufferUtils.copy(vals, this.matrix, vals.length, 0);
-		gl.glUniformMatrix3fv(location, 1, transpose, this.matrix);
+		gl.glUniformMatrix3fv(location, 1, transpose, matrix.val, 0);
 	}
 
 	/** Sets an array of uniform matrices with the given name. Throws an IllegalArgumentException in case it is not called in
@@ -632,20 +587,11 @@ public class ShaderProgram implements Disposable {
 	public void setUniformMatrix4fv (int location, float[] values, int offset, int length) {
 		GL20 gl = Gdx.gl20;
 		checkManaged();
-		ensureBufferCapacity(length << 2);
-		floatBuffer.clear();
-		BufferUtils.copy(values, floatBuffer, length, offset);
-		gl.glUniformMatrix4fv(location, length / 16, false, floatBuffer);
+		gl.glUniformMatrix4fv(location, length / 16, false, values, offset);
 	}
 
 	public void setUniformMatrix4fv (String name, float[] values, int offset, int length) {
-		GL20 gl = Gdx.gl20;
-		checkManaged();
-		ensureBufferCapacity(length << 2);
-		floatBuffer.clear();
-		BufferUtils.copy(values, floatBuffer, length, offset);
-		int location = fetchUniformLocation(name);
-		gl.glUniformMatrix4fv(location, length / 16, false, floatBuffer);
+		setUniformMatrix4fv(fetchUniformLocation(name), values, offset, length);
 	}
 
 	/** Sets the uniform with the given name. Throws an IllegalArgumentException in case it is not called in between a
@@ -851,14 +797,6 @@ public class ShaderProgram implements Disposable {
 		gl.glVertexAttrib4f(location, value1, value2, value3, value4);
 	}
 
-	private void ensureBufferCapacity (int numBytes) {
-		if (buffer == null || buffer.capacity() < numBytes) {
-			buffer = BufferUtils.newByteBuffer(numBytes);
-			floatBuffer = buffer.asFloatBuffer();
-			intBuffer = buffer.asIntBuffer();
-		}
-	}
-
 	IntBuffer params = BufferUtils.newIntBuffer(1);
 	IntBuffer type = BufferUtils.newIntBuffer(1);
 
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexArray.java b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexArray.java
index 5914ddf..1e1bdcd 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexArray.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexArray.java
@@ -173,4 +173,8 @@ public class VertexArray implements VertexData {
 	public VertexAttributes getAttributes () {
 		return attributes;
 	}
+	
+	@Override
+	public void invalidate () {
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexData.java b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexData.java
index d547b22..34f0f0a 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexData.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexData.java
@@ -70,6 +70,9 @@ public interface VertexData extends Disposable {
 	/** Unbinds this VertexData.
 	 * @param locations array containing the attribute locations. */
 	public void unbind (ShaderProgram shader, int[] locations);
+	
+	/** Invalidates the VertexData if applicable. Use this in case of a context loss. */
+	public void invalidate ();
 
 	/** Disposes this VertexData and all its associated OpenGL resources. */
 	public void dispose ();
diff --git a/gdx/src/com/badlogic/gdx/graphics/profiling/GL20Profiler.java b/gdx/src/com/badlogic/gdx/graphics/profiling/GL20Profiler.java
index 2d6a842..99c9d3a 100644
--- a/gdx/src/com/badlogic/gdx/graphics/profiling/GL20Profiler.java
+++ b/gdx/src/com/badlogic/gdx/graphics/profiling/GL20Profiler.java
@@ -901,4 +901,117 @@ public class GL20Profiler extends GLProfiler implements GL20 {
 		gl20.glVertexAttribPointer(indx, size, type, normalized, stride, ptr);
 	}
 
+	@Override
+	public void glDeleteTexture (int texture) {
+		calls++;
+		gl20.glDeleteTexture(texture);
+	}
+
+	@Override
+	public int glGenTexture () {
+		calls++;
+		return gl20.glGenTexture();
+	}
+
+	@Override
+	public void glDeleteBuffer (int buffer) {
+		calls++;
+		gl20.glDeleteBuffer(buffer);
+	}
+
+	@Override
+	public void glDeleteFramebuffer (int framebuffer) {
+		calls++;
+		gl20.glDeleteFramebuffer(framebuffer);
+	}
+
+	@Override
+	public void glDeleteRenderbuffer (int renderbuffer) {
+		calls++;
+		gl20.glDeleteRenderbuffer(renderbuffer);
+	}
+
+	@Override
+	public int glGenBuffer () {
+		calls++;
+		return gl20.glGenBuffer();
+	}
+
+	@Override
+	public int glGenFramebuffer () {
+		calls++;
+		return gl20.glGenFramebuffer();
+	}
+
+	@Override
+	public int glGenRenderbuffer () {
+		calls++;
+		return gl20.glGenRenderbuffer();
+	}
+
+	@Override
+	public void glUniform1fv (int location, int count, float[] v, int offset) {
+		calls++;
+		gl20.glUniform1fv(location, count, v, offset);
+	}
+
+	@Override
+	public void glUniform1iv (int location, int count, int[] v, int offset) {
+		calls++;
+		gl20.glUniform1iv(location, count, v, offset);
+	}
+
+	@Override
+	public void glUniform2fv (int location, int count, float[] v, int offset) {
+		calls++;
+		gl20.glUniform2fv(location, count, v, offset);	
+	}
+
+	@Override
+	public void glUniform2iv (int location, int count, int[] v, int offset) {
+		calls++;
+		gl20.glUniform2iv(location, count, v, offset);
+	}
+
+	@Override
+	public void glUniform3fv (int location, int count, float[] v, int offset) {
+		calls++;
+		gl20.glUniform3fv(location, count, v, offset);
+	}
+
+	@Override
+	public void glUniform3iv (int location, int count, int[] v, int offset) {
+		calls++;
+		gl20.glUniform3iv(location, count, v, offset);
+	}
+
+	@Override
+	public void glUniform4fv (int location, int count, float[] v, int offset) {
+		calls++;
+		gl20.glUniform4fv(location, count, v, offset);
+	}
+
+	@Override
+	public void glUniform4iv (int location, int count, int[] v, int offset) {
+		calls++;
+		gl20.glUniform4iv(location, count, v, offset);
+	}
+
+	@Override
+	public void glUniformMatrix2fv (int location, int count, boolean transpose, float[] value, int offset) {
+		calls++;
+		gl20.glUniformMatrix2fv(location, count, transpose, value, offset);
+	}
+
+	@Override
+	public void glUniformMatrix3fv (int location, int count, boolean transpose, float[] value, int offset) {
+		calls++;
+		gl20.glUniformMatrix3fv(location, count, transpose, value, offset);
+	}
+
+	@Override
+	public void glUniformMatrix4fv (int location, int count, boolean transpose, float[] value, int offset) {
+		calls++;
+		gl20.glUniformMatrix4fv(location, count, transpose, value, offset);
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/profiling/GL30Profiler.java b/gdx/src/com/badlogic/gdx/graphics/profiling/GL30Profiler.java
index dcaf62b..fc040db 100644
--- a/gdx/src/com/badlogic/gdx/graphics/profiling/GL30Profiler.java
+++ b/gdx/src/com/badlogic/gdx/graphics/profiling/GL30Profiler.java
@@ -1469,4 +1469,118 @@ public class GL30Profiler extends GLProfiler implements GL30 {
 		calls++;
 		gl30.glInvalidateSubFramebuffer(target, numAttachments, attachments, x, y, width, height);
 	}
+	
+	@Override
+	public void glDeleteTexture (int texture) {
+		calls++;
+		gl30.glDeleteTexture(texture);
+	}
+
+	@Override
+	public int glGenTexture () {
+		calls++;
+		return gl30.glGenTexture();
+	}
+
+	@Override
+	public void glDeleteBuffer (int buffer) {
+		calls++;
+		gl30.glDeleteBuffer(buffer);
+	}
+
+	@Override
+	public void glDeleteFramebuffer (int framebuffer) {
+		calls++;
+		gl30.glDeleteFramebuffer(framebuffer);
+	}
+
+	@Override
+	public void glDeleteRenderbuffer (int renderbuffer) {
+		calls++;
+		gl30.glDeleteRenderbuffer(renderbuffer);
+	}
+
+	@Override
+	public int glGenBuffer () {
+		calls++;
+		return gl30.glGenBuffer();
+	}
+
+	@Override
+	public int glGenFramebuffer () {
+		calls++;
+		return gl30.glGenFramebuffer();
+	}
+
+	@Override
+	public int glGenRenderbuffer () {
+		calls++;
+		return gl30.glGenRenderbuffer();
+	}
+
+	@Override
+	public void glUniform1fv (int location, int count, float[] v, int offset) {
+		calls++;
+		gl30.glUniform1fv(location, count, v, offset);
+	}
+
+	@Override
+	public void glUniform1iv (int location, int count, int[] v, int offset) {
+		calls++;
+		gl30.glUniform1iv(location, count, v, offset);
+	}
+
+	@Override
+	public void glUniform2fv (int location, int count, float[] v, int offset) {
+		calls++;
+		gl30.glUniform2fv(location, count, v, offset);	
+	}
+
+	@Override
+	public void glUniform2iv (int location, int count, int[] v, int offset) {
+		calls++;
+		gl30.glUniform2iv(location, count, v, offset);
+	}
+
+	@Override
+	public void glUniform3fv (int location, int count, float[] v, int offset) {
+		calls++;
+		gl30.glUniform3fv(location, count, v, offset);
+	}
+
+	@Override
+	public void glUniform3iv (int location, int count, int[] v, int offset) {
+		calls++;
+		gl30.glUniform3iv(location, count, v, offset);
+	}
+
+	@Override
+	public void glUniform4fv (int location, int count, float[] v, int offset) {
+		calls++;
+		gl30.glUniform4fv(location, count, v, offset);
+	}
+
+	@Override
+	public void glUniform4iv (int location, int count, int[] v, int offset) {
+		calls++;
+		gl30.glUniform4iv(location, count, v, offset);
+	}
+
+	@Override
+	public void glUniformMatrix2fv (int location, int count, boolean transpose, float[] value, int offset) {
+		calls++;
+		gl30.glUniformMatrix2fv(location, count, transpose, value, offset);
+	}
+
+	@Override
+	public void glUniformMatrix3fv (int location, int count, boolean transpose, float[] value, int offset) {
+		calls++;
+		gl30.glUniformMatrix3fv(location, count, transpose, value, offset);
+	}
+
+	@Override
+	public void glUniformMatrix4fv (int location, int count, boolean transpose, float[] value, int offset) {
+		calls++;
+		gl30.glUniformMatrix4fv(location, count, transpose, value, offset);
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/math/Shape2D.java b/gdx/src/com/badlogic/gdx/math/Shape2D.java
index 2f02476..4bbe571 100644
--- a/gdx/src/com/badlogic/gdx/math/Shape2D.java
+++ b/gdx/src/com/badlogic/gdx/math/Shape2D.java
@@ -1,6 +1,4 @@
 package com.badlogic.gdx.math;
 
-import com.badlogic.gdx.math.collision.*;
-
 public interface Shape2D {
 }
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextField.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextField.java
index 52416a2..d0a8a58 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextField.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextField.java
@@ -760,7 +760,7 @@ public class TextField extends Widget implements Disableable {
 			if (ctrl) {
 				if (keycode == Keys.V) {
 					paste();
-					return true;
+					repeat = true;
 				}
 				if (keycode == Keys.C || keycode == Keys.INSERT) {
 					copy();
diff --git a/tests/gdx-tests-android/assets/data/cubemap.zktx b/tests/gdx-tests-android/assets/data/cubemap.zktx
deleted file mode 100644
index 534146f..0000000
Binary files a/tests/gdx-tests-android/assets/data/cubemap.zktx and /dev/null differ
diff --git a/tests/gdx-tests-android/assets/data/egg.zktx b/tests/gdx-tests-android/assets/data/egg.zktx
deleted file mode 100644
index be57ea9..0000000
Binary files a/tests/gdx-tests-android/assets/data/egg.zktx and /dev/null differ
diff --git a/tests/gdx-tests-iosrobovm/src/com/badlogic/gdx/tests/IOSRobovmTests.java b/tests/gdx-tests-iosrobovm/src/com/badlogic/gdx/tests/IOSRobovmTests.java
index c253d36..0491cbd 100644
--- a/tests/gdx-tests-iosrobovm/src/com/badlogic/gdx/tests/IOSRobovmTests.java
+++ b/tests/gdx-tests-iosrobovm/src/com/badlogic/gdx/tests/IOSRobovmTests.java
@@ -28,7 +28,7 @@ public class IOSRobovmTests extends IOSApplication.Delegate {
 	protected IOSApplication createApplication() {
 		IOSApplicationConfiguration config = new IOSApplicationConfiguration();
 		config.useAccelerometer = false;
-		return new IOSApplication(new BulletTestCollection(), config);
+		return new IOSApplication(new AccelerometerTest(), config);
 	}
 
 	public static void main(String[] argv) {
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/GdxTests.gwt.xml b/tests/gdx-tests/src/com/badlogic/gdx/GdxTests.gwt.xml
index 716ddc5..c6def1f 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/GdxTests.gwt.xml
+++ b/tests/gdx-tests/src/com/badlogic/gdx/GdxTests.gwt.xml
@@ -9,7 +9,6 @@
 		<exclude name="**/ContactListenerTest.java"/> <!-- String.format, Reflection -->
 		<exclude name="**/CullTest.java"/> <!-- GL ES 1.0 -->
 		<exclude name="**/DownloadTest.java"/> <!-- Incompatible Pixmap ctor -->
-		<exclude name="**/KTXTest.java"/> <!-- use ECT1 which is native -->
 		<exclude name="**/ETC1Test.java"/> <!-- native -->
 		<exclude name="**/FFTTest.java"/> <!-- native -->
 		<exclude name="**/FramebufferToTextureTest.java"/> <!-- ScreenUtils missing -->
@@ -44,4 +43,4 @@
 		<exclude name="**/voxel/*.java"/> <!-- PerlinNoiseGenerator uses a method not in the emulated version of Buffer -->
 	</source>
 	<extend-configuration-property name="gdx.reflect.include" value="com.badlogic.gdx.tests.AnnotationTest" />
-</module>
+</module>
\ No newline at end of file
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/KTXTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/KTXTest.java
deleted file mode 100644
index 7b7d997..0000000
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/KTXTest.java
+++ /dev/null
@@ -1,212 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.tests;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.InputMultiplexer;
-import com.badlogic.gdx.graphics.Color;
-import com.badlogic.gdx.graphics.Cubemap;
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.OrthographicCamera;
-import com.badlogic.gdx.graphics.PerspectiveCamera;
-import com.badlogic.gdx.graphics.Texture;
-import com.badlogic.gdx.graphics.Texture.TextureFilter;
-import com.badlogic.gdx.graphics.VertexAttributes.Usage;
-import com.badlogic.gdx.graphics.g2d.SpriteBatch;
-import com.badlogic.gdx.graphics.g3d.Environment;
-import com.badlogic.gdx.graphics.g3d.Material;
-import com.badlogic.gdx.graphics.g3d.Model;
-import com.badlogic.gdx.graphics.g3d.ModelBatch;
-import com.badlogic.gdx.graphics.g3d.ModelInstance;
-import com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute;
-import com.badlogic.gdx.graphics.g3d.attributes.CubemapAttribute;
-import com.badlogic.gdx.graphics.g3d.environment.DirectionalLight;
-import com.badlogic.gdx.graphics.g3d.shaders.DefaultShader.Config;
-import com.badlogic.gdx.graphics.g3d.utils.CameraInputController;
-import com.badlogic.gdx.graphics.g3d.utils.DefaultShaderProvider;
-import com.badlogic.gdx.graphics.g3d.utils.ModelBuilder;
-import com.badlogic.gdx.graphics.glutils.KTXTextureData;
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-import com.badlogic.gdx.math.MathUtils;
-import com.badlogic.gdx.tests.utils.GdxTest;
-
-/** Simple test and example for the KTX/ZKTX file format
- * @author Vincent Bousquet */
-public class KTXTest extends GdxTest {
-
-	// 3D texture cubemap example
-	private PerspectiveCamera perspectiveCamera;
-	private CameraInputController inputController;
-	private ModelBatch modelBatch;
-	private Model model;
-	private ModelInstance instance;
-	private Environment environment;
-	private Cubemap cubemap;
-
-	// 2D texture alpha ETC1 example
-	private OrthographicCamera orthoCamera;
-	private Texture image;
-	private SpriteBatch batch;
-	private ShaderProgram etc1aShader;
-
-	// animation
-	private float time;
-
-	@Override
-	public void create () {
-
-		// Cubemap test
-
-		String cubemapVS = "" //
-			+ "attribute vec3 a_position;\n"//
-			+ "uniform mat4 u_projViewTrans;\n"//
-			+ "uniform mat4 u_worldTrans;\n"//
-			+ "\n"//
-			+ "varying vec3 v_cubeMapUV;\n"//
-			+ "\n"//
-			+ "void main() {\n"//
-			+ "   vec4 g_position = vec4(a_position, 1.0);\n"//
-			+ "   g_position = u_worldTrans * g_position;\n"//
-			+ "   v_cubeMapUV = normalize(g_position.xyz);\n"//
-			+ "   gl_Position = u_projViewTrans * g_position;\n"//
-			+ "}";
-		String cubemapFS = ""//
-			+ "uniform samplerCube u_environmentCubemap;\n"//
-			+ "varying vec3 v_cubeMapUV;\n"//
-			+ "void main() {\n" //
-			+ "	gl_FragColor = vec4(textureCube(u_environmentCubemap, v_cubeMapUV).rgb, 1.0);\n" //
-			+ "}\n";
-		modelBatch = new ModelBatch(new DefaultShaderProvider(new Config(cubemapVS, cubemapFS)));
-
-		cubemap = new Cubemap(new KTXTextureData(Gdx.files.internal("data/cubemap.zktx"), true));
-		cubemap.setFilter(TextureFilter.MipMapLinearLinear, TextureFilter.Linear);
-
-		environment = new Environment();
-		environment.set(new ColorAttribute(ColorAttribute.AmbientLight, 0.1f, 0.1f, 0.1f, 1.f));
-		environment.add(new DirectionalLight().set(0.8f, 0.8f, 0.8f, -0.5f, -1.0f, -0.8f));
-		environment.set(new CubemapAttribute(CubemapAttribute.EnvironmentMap, cubemap));
-
-		perspectiveCamera = new PerspectiveCamera(67, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
-		perspectiveCamera.position.set(10f, 10f, 10f);
-		perspectiveCamera.lookAt(0, 0, 0);
-		perspectiveCamera.near = 0.1f;
-		perspectiveCamera.far = 300f;
-		perspectiveCamera.update();
-
-		ModelBuilder modelBuilder = new ModelBuilder();
-		model = modelBuilder.createBox(5f, 5f, 5f, new Material(ColorAttribute.createDiffuse(Color.GREEN)), Usage.Position
-			| Usage.Normal);
-		instance = new ModelInstance(model);
-
-		Gdx.input.setInputProcessor(new InputMultiplexer(this, inputController = new CameraInputController(perspectiveCamera)));
-
-		// 2D texture test
-
-		String etc1aVS = "" //
-			+ "uniform mat4 u_projTrans;\n"//
-			+ "\n"//
-			+ "attribute vec4 a_position;\n"//
-			+ "attribute vec2 a_texCoord0;\n"//
-			+ "attribute vec4 a_color;\n"//
-			+ "\n"//
-			+ "varying vec4 v_color;\n"//
-			+ "varying vec2 v_texCoord;\n"//
-			+ "\n"//
-			+ "void main() {\n"//
-			+ "   gl_Position = u_projTrans * a_position;\n"//
-			+ "   v_texCoord = a_texCoord0;\n"//
-			+ "   v_color = a_color;\n"//
-			+ "}\n";//
-		String etc1aFS = ""//
-			+ "uniform sampler2D u_texture;\n"//
-			+ "\n"//
-			+ "varying vec4 v_color;\n"//
-			+ "varying vec2 v_texCoord;\n"//
-			+ "\n"//
-			+ "void main() {\n"//
-			+ "   vec3 col = texture2D(u_texture, v_texCoord.st).rgb;\n"//
-			+ "   float alpha = texture2D(u_texture, v_texCoord.st + vec2(0.0, 0.5)).r;\n"//
-			+ "   gl_FragColor = vec4(col, alpha) * v_color;\n"//
-			+ "}\n";//
-		etc1aShader = new ShaderProgram(etc1aVS, etc1aFS);
-		orthoCamera = new OrthographicCamera(Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
-		image = new Texture("data/egg.zktx");
-		batch = new SpriteBatch(100, etc1aShader);
-
-	}
-
-	@Override
-	public void render () {
-		time += Gdx.graphics.getDeltaTime();
-		inputController.update();
-		int gw = Gdx.graphics.getWidth(), gh = Gdx.graphics.getHeight();
-		int pw = gw > gh ? gw / 2 : gw, ph = gw > gh ? gh : gh / 2;
-
-		Gdx.gl.glClearColor(0, 0, 0, 1);
-		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT | GL20.GL_DEPTH_BUFFER_BIT);
-
-		// cubemap
-		Gdx.gl.glViewport(gw - pw, gh - ph, pw, ph);
-		perspectiveCamera.viewportWidth = pw;
-		perspectiveCamera.viewportHeight = ph;
-		perspectiveCamera.update();
-		modelBatch.begin(perspectiveCamera);
-		modelBatch.render(instance, environment);
-		modelBatch.end();
-
-		// 2D texture with alpha & ETC1
-		Gdx.gl.glViewport(0, 0, pw, ph);
-		orthoCamera.viewportWidth = pw;
-		orthoCamera.viewportHeight = ph;
-		orthoCamera.update();
-		batch.setProjectionMatrix(orthoCamera.combined);
-		batch.begin();
-		float s = 0.1f + 0.5f * (1 + MathUtils.sinDeg(time * 90.0f));
-		float w = s * image.getWidth(), h = s * image.getHeight() / 2, x = -w / 2, y = -h / 2;
-		batch.setShader(null);
-		batch.disableBlending();
-		batch.draw(image, -pw / 2, -ph / 2, pw, ph, 0, 1, 1, 0);
-		batch.setShader(etc1aShader);
-		batch.enableBlending();
-		batch.draw(image, x, y, w, h, 0, 0.5f, 1, 0);
-		batch.end();
-	}
-
-	@Override
-	public void dispose () {
-		modelBatch.dispose();
-		model.dispose();
-		cubemap.dispose();
-		image.dispose();
-		batch.dispose();
-		etc1aShader.dispose();
-	}
-
-	public boolean needsGL20 () {
-		return true;
-	}
-
-	public void resume () {
-	}
-
-	public void resize (int width, int height) {
-	}
-
-	public void pause () {
-	}
-
-}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ShaderCollectionTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ShaderCollectionTest.java
index f9309b1..7a75279 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ShaderCollectionTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ShaderCollectionTest.java
@@ -36,7 +36,6 @@ import com.badlogic.gdx.graphics.g3d.shaders.BaseShader;
 import com.badlogic.gdx.graphics.g3d.shaders.DefaultShader;
 import com.badlogic.gdx.graphics.g3d.utils.AnimationController;
 import com.badlogic.gdx.graphics.g3d.utils.DefaultShaderProvider;
-import com.badlogic.gdx.graphics.glutils.FacedCubemapData;
 import com.badlogic.gdx.math.Quaternion;
 import com.badlogic.gdx.math.Vector3;
 import com.badlogic.gdx.math.collision.BoundingBox;
@@ -169,12 +168,10 @@ public class ShaderCollectionTest extends BaseG3dHudTest {
 			}
 		} else {
 			FileHandle root = Gdx.files.internal("data/g3d/environment");
-			FacedCubemapData faces = new FacedCubemapData(root.child(name + "_PX.png"), root.child(name+"_NX.png"),
+			cubemap = new Cubemap(root.child(name + "_PX.png"), root.child(name+"_NX.png"),
 				root.child(name + "_PY.png"), root.child(name + "_NY.png"), root.child(name + "_PZ.png"),
 				root.child(name + "_NZ.png"), false); // FIXME mipmapping on desktop
-			cubemap = new Cubemap(faces);
-			faces.load(CubemapSide.NegativeX, root.child(name + "_NX.png"));
-			cubemap.load(faces);
+			cubemap.load(CubemapSide.NegativeX, root.child(name + "_NX.png"));
 			if (!lights.has(CubemapAttribute.EnvironmentMap)) shaderProvider.clear();
 			lights.set(new CubemapAttribute(CubemapAttribute.EnvironmentMap, cubemap));
 		}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
index 8f8fd88..fd47da6 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
@@ -136,7 +136,6 @@ public class GdxTests {
 		InverseKinematicsTest.class,
 		IsometricTileTest.class,
 		KinematicBodyTest.class,
-		KTXTest.class,
 		LabelScaleTest.class,
 		LabelTest.class,
 		LifeCycleTest.class,
