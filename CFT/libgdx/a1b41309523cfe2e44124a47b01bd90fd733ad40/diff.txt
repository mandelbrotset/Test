diff --git a/.gitignore b/.gitignore
index ce575c2..c96ead9 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,18 +3,13 @@
 .*.swp
 .DS_STORE
 
-.gradle/
-build/
 bin/
 target/
 obj/
-out/
-classes/
 .gwt/
 gwt-unitCache/
 war/
 gen/
-gen-external-apklibs/
 armeabi/
 armeabi-v7a/
 linux32/
diff --git a/CHANGES b/CHANGES
index 50f69d0..0da175c 100644
--- a/CHANGES
+++ b/CHANGES
@@ -1,54 +1,7 @@
-[1.5.4]
-- Added support for image layers in Tiled maps (TiledMapImageLayer)
-- Added support for loading texture objects from TMX Maps (TextureMapObject)
-- Added support for border and shadow with FreeTypeFontGenerator - see https://github.com/libgdx/libgdx/pull/2774
-- Now unknown markup colors are silently ignored and considered as normal text.
-
-[1.5.3]
-- API Change: TextField#setRightAlign -> TextField#setAlignment
-- I18NBundle is now compatible with Android 2.2
-- Fixed GWT reflection includes for 3D particles
-- 3D ParticleEffectLoader registered by default
-- Added HttpRequestBuilder, see https://github.com/libgdx/libgdx/pull/2698
-- Added LwjglApplicationConfiguration.useHDPI for Mac OS X with retina displays. Allows you to get "real" pixel coordinates for mouse and display coordinates.
-- Updated RoboVM to 1.0.0-beta-03
-
-[1.5.2]
-- Fixed issue #2433 with color markup and alpha animation. 
-- Fixed natives loading for LWJGL on Mac OS X
-
-[1.5.1]
-- Gradle updated to 2.2
-- Android Gradle tooling updated to 1.0.0
-- API Change: Switched from Timer to AnimationScheduler for driving main loop on GWT. Removed fps field from GwtApplicationConfiguration to instead let the browser choose the most optimal rate.
-- API Change: Added pause and resume handling on GWT backend. When the browser supports the page visibility api, pause and resume will be called when the tab or window loses and gains visibility.
-- API Change: Added concept of target actor, separate from the actor the action is added to. This allows an action to be added to one actor but affect another. This is useful to create a sequence of actions that affect many different actors. Previously this would require adding actions to each actor and using delays to get them to play in the correct order.
-- Added 64-bit support for iOS sim and device
-- Deprecated Node#children and Node#parent, added inheritTransform flag and methods to add/get/remove children
-- API Change: By default keyframes are no longer copied from Model to ModelInstance but shared instead, can be changed using the `ModelInstance.defaultShareKeyframes` flag or `shareKeyframes` constructor argument.
-- JSON minimal format now makes commas optional: newline can be used in place of any comma.
-- JSON minimal format is now more lenient with unquoted strings: spaces and more are allowed.
-- API Change: Added support for KTX/ZKTX file format, https://github.com/libgdx/libgdx/pull/2431
-- Update stb_image from v1.33 to v1.48, see https://github.com/libgdx/libgdx/pull/2668
-- Bullet Wrapper: added Gimpact, see https://github.com/libgdx/libgdx/issues/2619
-- API Addition: Added MeshPartBuilder#addMesh(...), can be used to more easily combine meshes/models
-- Update to LWJGL 2.9.2, fixes fullscreen mode on "retina" displays
-- Fixes to RoboVM backend which would crash if accelerometer is used.
-
-[1.5.0]
-- API Addition: IOSInput now uses CMCoreMotion for accelerometer and magnetometer
-- API Addition: Added getter for UITextField on IOS for keyboard customization 
-- API Addition: Added ability to save PixmapPackers to atlas files. See PixmapPackerIO.
+[1.4.2]
 - API Addition: Added HttpRequestHeader and HttpResponseHeader with constants for HTTP headers.
 - API Addition: HttpRequest is now poolable.
 - New PNG encoder that supports compression, more efficient vertical flipping, and minimal allocation when encoding multiple PNGs.
-- API Change: Label#setEllipse -> Label#setEllipsis.
-- API Change: BatchTiledMapRenderer *SpriteBatch fields and methods renamed to *Batch
-- API Change: ScrollPane#scrollToCenter -> ScrollPane#scrollTo; see optional boolean arguments centerHorizontal and centerVertical (scrollToCenter centered vertically only).
-- API Change: Changed Input#getTextInput to accept both text and hint, removed Input#getPlaceholderTextInput.
-- Bug Fix: Fixed potential NPE with immersive mode in the Android fragment backend. 
-- iOS backend now supports sound ids, thanks Tomski!
-
 
 [1.4.1]
 - Update to the Gradle Integration plugin nightly build if you are on Eclipse 4.4.x!
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 3dc5b40..02b3751 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -26,7 +26,7 @@ see: [this article](http://blog.jetbrains.com/idea/2014/01/intellij-idea-13-impo
 
 ### Code Style
 
-Libgdx does not have an official coding standard. We mostly follow the usual [Java style](http://www.oracle.com/technetwork/java/codeconvtoc-136057.html), and so should you.
+Libgdx does not have an official coding standard. We mostly follow the usual [Java style](http://www.oracle.com/technetwork/java/codeconv-138413.html), and so should you.
 
 A few things we'd rather not like to see:
 
diff --git a/backends/gdx-backend-android/pom.xml b/backends/gdx-backend-android/pom.xml
index fce800d..93e74db 100644
--- a/backends/gdx-backend-android/pom.xml
+++ b/backends/gdx-backend-android/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.5.4-SNAPSHOT</version>
+    <version>1.4.2-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidApplication.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidApplication.java
index 418295c..dbcfd4f 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidApplication.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidApplication.java
@@ -149,12 +149,12 @@ public class AndroidApplication extends Activity implements AndroidApplicationBa
 			public void resume () {
 				// No need to resume audio here
 			}
-
+			
 			@Override
 			public void pause () {
 				audio.pause();
 			}
-
+			
 			@Override
 			public void dispose () {
 				audio.dispose();
@@ -214,7 +214,8 @@ public class AndroidApplication extends Activity implements AndroidApplicationBa
 
 		try {
 			Method m = View.class.getMethod("setSystemUiVisibility", int.class);
-			if (getVersion() <= 13) m.invoke(rootView, 0x0);
+			if (getVersion() <= 13)
+				m.invoke(rootView, 0x0);
 			m.invoke(rootView, 0x1);
 		} catch (Exception e) {
 			log("AndroidApplication", "Can't hide status bar", e);
@@ -245,9 +246,12 @@ public class AndroidApplication extends Activity implements AndroidApplicationBa
 		View view = getWindow().getDecorView();
 		try {
 			Method m = View.class.getMethod("setSystemUiVisibility", int.class);
-			int code = View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
-				| View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_FULLSCREEN
-				| View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;
+			int code = View.SYSTEM_UI_FLAG_LAYOUT_STABLE
+						| View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
+						| View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
+						| View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
+						| View.SYSTEM_UI_FLAG_FULLSCREEN
+						| View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;
 			m.invoke(view, code);
 		} catch (Exception e) {
 			log("AndroidApplication", "Can't set immersive mode", e);
@@ -257,13 +261,7 @@ public class AndroidApplication extends Activity implements AndroidApplicationBa
 	@Override
 	protected void onPause () {
 		boolean isContinuous = graphics.isContinuousRendering();
-		boolean isContinuousEnforced = AndroidGraphics.enforceContinuousRendering;
-
-		// from here we don't want non continuous rendering
-		AndroidGraphics.enforceContinuousRendering = true;
 		graphics.setContinuousRendering(true);
-		// calls to setContinuousRendering(false) from other thread (ex: GLThread)
-		// will be ignored at this point...
 		graphics.pause();
 
 		input.onPause();
@@ -272,8 +270,6 @@ public class AndroidApplication extends Activity implements AndroidApplicationBa
 			graphics.clearManagedCaches();
 			graphics.destroy();
 		}
-
-		AndroidGraphics.enforceContinuousRendering = isContinuousEnforced;
 		graphics.setContinuousRendering(isContinuous);
 
 		graphics.onPauseGLSurfaceView();
@@ -466,7 +462,7 @@ public class AndroidApplication extends Activity implements AndroidApplicationBa
 	@Override
 	protected void onActivityResult (int requestCode, int resultCode, Intent data) {
 		super.onActivityResult(requestCode, resultCode, data);
-
+		
 		// forward events to our listeners if there are any installed
 		synchronized (androidEventListeners) {
 			for (int i = 0; i < androidEventListeners.size; i++) {
@@ -491,7 +487,7 @@ public class AndroidApplication extends Activity implements AndroidApplicationBa
 
 	@Override
 	public Context getContext () {
-		return this;
+		return this;  
 	}
 
 	@Override
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidFragmentApplication.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidFragmentApplication.java
index 2ef4ade..1789494 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidFragmentApplication.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidFragmentApplication.java
@@ -106,17 +106,20 @@ public class AndroidFragmentApplication extends Fragment implements AndroidAppli
 	@Override
 	public void useImmersiveMode (boolean use) {
 		if (!use || getVersion() < Build.VERSION_CODES.KITKAT) return;
-		
-		try {
-			View view = this.graphics.getView();
 
+		View view = getApplicationWindow().getDecorView();
+
+		try {
 			Method m = View.class.getMethod("setSystemUiVisibility", int.class);
-			int code = View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
-				| View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_FULLSCREEN
-				| View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;
+			int code = View.SYSTEM_UI_FLAG_LAYOUT_STABLE
+						| View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
+						| View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
+						| View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
+						| View.SYSTEM_UI_FLAG_FULLSCREEN
+						| View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;
 			m.invoke(view, code);
 		} catch (Exception e) {
-			log("AndroidApplication", "Failed to setup immersive mode, a throwable has occurred.", e);
+			log("AndroidApplication", "Can't set immersive mode", e);
 		}
 	}
 
@@ -166,12 +169,12 @@ public class AndroidFragmentApplication extends Fragment implements AndroidAppli
 			public void resume () {
 				audio.resume();
 			}
-
+			
 			@Override
 			public void pause () {
 				audio.pause();
 			}
-
+			
 			@Override
 			public void dispose () {
 				audio.dispose();
@@ -202,13 +205,7 @@ public class AndroidFragmentApplication extends Fragment implements AndroidAppli
 	@Override
 	public void onPause () {
 		boolean isContinuous = graphics.isContinuousRendering();
-		boolean isContinuousEnforced = AndroidGraphics.enforceContinuousRendering;
-
-		// from here we don't want non continuous rendering
-		AndroidGraphics.enforceContinuousRendering = true;
 		graphics.setContinuousRendering(true);
-		// calls to setContinuousRendering(false) from other thread (ex: GLThread)
-		// will be ignored at this point...
 		graphics.pause();
 
 		input.onPause();
@@ -220,7 +217,6 @@ public class AndroidFragmentApplication extends Fragment implements AndroidAppli
 			graphics.destroy();
 		}
 
-		AndroidGraphics.enforceContinuousRendering = isContinuousEnforced;
 		graphics.setContinuousRendering(isContinuous);
 
 		graphics.onPauseGLSurfaceView();
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGL20.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGL20.java
index 2fbf6a4..4729e01 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGL20.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGL20.java
@@ -89,24 +89,16 @@ public class AndroidGL20 implements GL20 {
 	public native void glCullFace (int mode);
 
 	public native void glDeleteBuffers (int n, IntBuffer buffers);
-	
-	public native void glDeleteBuffer (int buffer);
 
 	public native void glDeleteFramebuffers (int n, IntBuffer framebuffers);
-	
-	public native void glDeleteFramebuffer (int framebuffer);
 
 	public native void glDeleteProgram (int program);
 
 	public native void glDeleteRenderbuffers (int n, IntBuffer renderbuffers);
-	
-	public native void glDeleteRenderbuffer (int renderbuffer);
 
 	public native void glDeleteShader (int shader);
 
 	public native void glDeleteTextures (int n, IntBuffer textures);
-	
-	public native void glDeleteTexture (int texture);
 
 	public native void glDepthFunc (int func);
 
@@ -141,22 +133,14 @@ public class AndroidGL20 implements GL20 {
 	public native void glFrontFace (int mode);
 
 	public native void glGenBuffers (int n, IntBuffer buffers);
-	
-	public native int glGenBuffer ();
 
 	public native void glGenerateMipmap (int target);
 
 	public native void glGenFramebuffers (int n, IntBuffer framebuffers);
-	
-	public native int glGenFramebuffer ();
 
 	public native void glGenRenderbuffers (int n, IntBuffer renderbuffers);
-	
-	public native int glGenRenderbuffer ();
 
 	public native void glGenTextures (int n, IntBuffer textures);
-	
-	public native int glGenTexture ();
 
 	public native String glGetActiveAttrib (int program, int index, IntBuffer size, Buffer type);
 
@@ -277,62 +261,40 @@ public class AndroidGL20 implements GL20 {
 	public native void glUniform1f (int location, float x);
 
 	public native void glUniform1fv (int location, int count, FloatBuffer v);
-	
-	public native void glUniform1fv (int location, int count, float[] v, int offset);
 
 	public native void glUniform1i (int location, int x);
 
 	public native void glUniform1iv (int location, int count, IntBuffer v);
-	
-	public native void glUniform1iv (int location, int count, int[] v, int offset);
 
 	public native void glUniform2f (int location, float x, float y);
 
 	public native void glUniform2fv (int location, int count, FloatBuffer v);
-	
-	public native void glUniform2fv (int location, int count, float[] v, int offset);
 
 	public native void glUniform2i (int location, int x, int y);
 
 	public native void glUniform2iv (int location, int count, IntBuffer v);
 
-	public native void glUniform2iv (int location, int count, int[] v, int offset);
-
 	public native void glUniform3f (int location, float x, float y, float z);
 
 	public native void glUniform3fv (int location, int count, FloatBuffer v);
-	
-	public native void glUniform3fv (int location, int count, float[] v, int offset);
 
 	public native void glUniform3i (int location, int x, int y, int z);
 
 	public native void glUniform3iv (int location, int count, IntBuffer v);
-	
-	public native void glUniform3iv (int location, int count, int[] v, int offset);
 
 	public native void glUniform4f (int location, float x, float y, float z, float w);
 
 	public native void glUniform4fv (int location, int count, FloatBuffer v);
 
-	public native void glUniform4fv (int location, int count, float[] v, int offset);
-
 	public native void glUniform4i (int location, int x, int y, int z, int w);
 
 	public native void glUniform4iv (int location, int count, IntBuffer v);
 
-	public native void glUniform4iv (int location, int count, int[] v, int offset);
-	
 	public native void glUniformMatrix2fv (int location, int count, boolean transpose, FloatBuffer value);
-	
-	public native void glUniformMatrix2fv (int location, int count, boolean transpose, float[] value, int offset);
 
 	public native void glUniformMatrix3fv (int location, int count, boolean transpose, FloatBuffer value);
-	
-	public native void glUniformMatrix3fv (int location, int count, boolean transpose, float[] value, int offset);
 
 	public native void glUniformMatrix4fv (int location, int count, boolean transpose, FloatBuffer value);
-	
-	public native void glUniformMatrix4fv (int location, int count, boolean transpose, float[] value, int offset);
 
 	public native void glUseProgram (int program);
 
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphics.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphics.java
index f61e3e5..a7bc00a 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphics.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphics.java
@@ -16,12 +16,7 @@
 
 package com.badlogic.gdx.backends.android;
 
-import javax.microedition.khronos.egl.EGL10;
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.egl.EGLContext;
-import javax.microedition.khronos.egl.EGLDisplay;
-import javax.microedition.khronos.opengles.GL10;
-
+import android.content.Context;
 import android.opengl.GLSurfaceView;
 import android.opengl.GLSurfaceView.EGLConfigChooser;
 import android.opengl.GLSurfaceView.Renderer;
@@ -37,7 +32,6 @@ import com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20API18;
 import com.badlogic.gdx.backends.android.surfaceview.GLSurfaceViewAPI18;
 import com.badlogic.gdx.backends.android.surfaceview.GdxEglConfigChooser;
 import com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy;
-import com.badlogic.gdx.graphics.Cubemap;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.GL30;
 import com.badlogic.gdx.graphics.Mesh;
@@ -48,6 +42,14 @@ import com.badlogic.gdx.math.WindowedMean;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 
+import java.lang.reflect.Method;
+
+import javax.microedition.khronos.egl.EGL10;
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.egl.EGLContext;
+import javax.microedition.khronos.egl.EGLDisplay;
+import javax.microedition.khronos.opengles.GL10;
+
 /** An implementation of {@link Graphics} for Android.
  * 
  * @author mzechner */
@@ -55,13 +57,6 @@ public class AndroidGraphics implements Graphics, Renderer {
 
 	private static final String LOG_TAG = "AndroidGraphics";
 
-	/** When {@link AndroidFragmentApplication#onPause()} or {@link AndroidApplication#onPause()} call
-	 * {@link AndroidGraphics#pause()} they <b>MUST</b> enforce continuous rendering. If not, {@link #onDrawFrame(GL10)} will not
-	 * be called in the GLThread while {@link #pause()} is sleeping in the Android UI Thread which will cause the
-	 * {@link AndroidGraphics#pause} variable never be set to false. As a result, the {@link AndroidGraphics#pause()} method will
-	 * kill the current process to avoid ANR */
-	static volatile boolean enforceContinuousRendering = false;
-
 	final View view;
 	int width;
 	int height;
@@ -136,7 +131,8 @@ public class AndroidGraphics implements Graphics, Renderer {
 				view.setEGLConfigChooser(config.r, config.g, config.b, config.a, config.depth, config.stencil);
 			view.setRenderer(this);
 			return view;
-		} else {
+		}
+		else {
 			GLSurfaceView20 view = new GLSurfaceView20(application.getContext(), resolutionStrategy);
 			if (configChooser != null)
 				view.setEGLConfigChooser(configChooser);
@@ -256,7 +252,6 @@ public class AndroidGraphics implements Graphics, Renderer {
 
 		Mesh.invalidateAllMeshes(app);
 		Texture.invalidateAllTextures(app);
-		Cubemap.invalidateAllCubemaps(app);
 		ShaderProgram.invalidateAllShaderPrograms(app);
 		FrameBuffer.invalidateAllFrameBuffers(app);
 
@@ -326,9 +321,8 @@ public class AndroidGraphics implements Graphics, Renderer {
 					// ~500ms between taps.
 					synch.wait(4000);
 					if (pause) {
-						// pause will never go false if onDrawFrame is never called by the GLThread
-						// when entering this method, we MUST enforce continuous rendering
-						Gdx.app.error(LOG_TAG, "waiting for pause synchronization took too long; assuming deadlock and killing");
+						Gdx.app.error(LOG_TAG, "waiting for pause synchronization took too "
+							+ "long; assuming deadlock and killing");
 						android.os.Process.killProcess(android.os.Process.myPid());
 					}
 				} catch (InterruptedException ignored) {
@@ -483,17 +477,15 @@ public class AndroidGraphics implements Graphics, Renderer {
 	public void clearManagedCaches () {
 		Mesh.clearAllMeshes(app);
 		Texture.clearAllTextures(app);
-		Cubemap.clearAllCubemaps(app);
 		ShaderProgram.clearAllShaderPrograms(app);
 		FrameBuffer.clearAllFrameBuffers(app);
 
 		logManagedCachesStatus();
 	}
-
-	protected void logManagedCachesStatus () {
+	
+	protected void logManagedCachesStatus() {
 		Gdx.app.log(LOG_TAG, Mesh.getManagedStatus());
 		Gdx.app.log(LOG_TAG, Texture.getManagedStatus());
-		Gdx.app.log(LOG_TAG, Cubemap.getManagedStatus());
 		Gdx.app.log(LOG_TAG, ShaderProgram.getManagedStatus());
 		Gdx.app.log(LOG_TAG, FrameBuffer.getManagedStatus());
 	}
@@ -583,9 +575,8 @@ public class AndroidGraphics implements Graphics, Renderer {
 	@Override
 	public void setContinuousRendering (boolean isContinuous) {
 		if (view != null) {
-			// ignore setContinuousRendering(false) while pausing
-			this.isContinuous = enforceContinuousRendering || isContinuous;
-			int renderMode = this.isContinuous ? GLSurfaceView.RENDERMODE_CONTINUOUSLY : GLSurfaceView.RENDERMODE_WHEN_DIRTY;
+			this.isContinuous = isContinuous;
+			int renderMode = isContinuous ? GLSurfaceView.RENDERMODE_CONTINUOUSLY : GLSurfaceView.RENDERMODE_WHEN_DIRTY;
 			if (view instanceof GLSurfaceViewAPI18) ((GLSurfaceViewAPI18)view).setRenderMode(renderMode);
 			if (view instanceof GLSurfaceView) ((GLSurfaceView)view).setRenderMode(renderMode);
 			mean.clear();
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidInput.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidInput.java
index c512555..a2f3d03 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidInput.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidInput.java
@@ -44,7 +44,6 @@ import com.badlogic.gdx.Application;
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.Graphics.DisplayMode;
 import com.badlogic.gdx.Input;
-import com.badlogic.gdx.Input.TextInputListener;
 import com.badlogic.gdx.InputProcessor;
 import com.badlogic.gdx.backends.android.AndroidLiveWallpaperService.AndroidWallpaperEngine;
 import com.badlogic.gdx.graphics.Pixmap;
@@ -95,7 +94,7 @@ public class AndroidInput implements Input, OnKeyListener, OnTouchListener {
 		}
 	};
 
-	public static final int NUM_TOUCHES = 20;
+	public static final int NUM_TOUCHES = 40;
 
 	ArrayList<OnKeyListener> keyListeners = new ArrayList();
 	ArrayList<KeyEvent> keyEvents = new ArrayList();
@@ -193,14 +192,13 @@ public class AndroidInput implements Input, OnKeyListener, OnTouchListener {
 	}
 
 	@Override
-	public void getTextInput (final TextInputListener listener, final String title, final String text, final String hint) {
+	public void getTextInput (final TextInputListener listener, final String title, final String text) {
 		handle.post(new Runnable() {
 			public void run () {
 				AlertDialog.Builder alert = new AlertDialog.Builder(context);
 				alert.setTitle(title);
 				final EditText input = new EditText(context);
-				input.setHint(hint);
-				input.setText(text);				
+				input.setText(text);
 				input.setSingleLine();
 				alert.setView(input);
 				alert.setPositiveButton(context.getString(android.R.string.ok), new DialogInterface.OnClickListener() {
@@ -239,6 +237,41 @@ public class AndroidInput implements Input, OnKeyListener, OnTouchListener {
 		});
 	}
 
+	public void getPlaceholderTextInput (final TextInputListener listener, final String title, final String placeholder) {
+		handle.post(new Runnable() {
+			public void run () {
+				AlertDialog.Builder alert = new AlertDialog.Builder(context);
+				alert.setTitle(title);
+				final EditText input = new EditText(context);
+				input.setHint(placeholder);
+				input.setSingleLine();
+				alert.setView(input);
+				alert.setPositiveButton(context.getString(android.R.string.ok), new DialogInterface.OnClickListener() {
+					public void onClick (DialogInterface dialog, int whichButton) {
+						Gdx.app.postRunnable(new Runnable() {
+							@Override
+							public void run () {
+								listener.input(input.getText().toString());
+							}
+						});
+					}
+				});
+				alert.setOnCancelListener(new OnCancelListener() {
+					@Override
+					public void onCancel (DialogInterface arg0) {
+						Gdx.app.postRunnable(new Runnable() {
+							@Override
+							public void run () {
+								listener.canceled();
+							}
+						});
+					}
+				});
+				alert.show();
+			}
+		});
+	}
+
 	@Override
 	public int getX () {
 		synchronized (this) {
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidMusic.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidMusic.java
index 24a974b..eb7f9d7 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidMusic.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidMusic.java
@@ -42,6 +42,7 @@ public class AndroidMusic implements Music, MediaPlayer.OnCompletionListener {
 	public void dispose () {
 		if (player == null) return;
 		try {
+			if (player.isPlaying()) player.stop();
 			player.release();
 		} catch (Throwable t) {
 			Gdx.app.log("AndroidMusic", "error while disposing AndroidMusic instance, non-fatal");
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidSound.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidSound.java
index 122296b..e3256f3 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidSound.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidSound.java
@@ -50,7 +50,7 @@ final class AndroidSound implements Sound {
 		int streamId = soundPool.play(soundId, volume, volume, 1, 0, 1);
 		// standardise error code with other backends
 		if (streamId == 0) return -1;
-		streamIds.insert(0, streamId);
+		streamIds.add(streamId);
 		return streamId;
 	}
 
@@ -105,7 +105,7 @@ final class AndroidSound implements Sound {
 		int streamId = soundPool.play(soundId, volume, volume, 1, -1, 1);
 		// standardise error code with other backends
 		if (streamId == 0) return -1;
-		streamIds.insert(0, streamId);
+		streamIds.add(streamId);
 		return streamId;
 	}
 
@@ -141,7 +141,7 @@ final class AndroidSound implements Sound {
 		int streamId = soundPool.play(soundId, leftVolume, rightVolume, 1, 0, pitch);
 		// standardise error code with other backends
 		if (streamId == 0) return -1;
-		streamIds.insert(0, streamId);
+		streamIds.add(streamId);
 		return streamId;
 	}
 
@@ -158,7 +158,7 @@ final class AndroidSound implements Sound {
 		int streamId = soundPool.play(soundId, leftVolume, rightVolume, 1, -1, pitch);
 		// standardise error code with other backends
 		if (streamId == 0) return -1;
-		streamIds.insert(0, streamId);
+		streamIds.add(streamId);
 		return streamId;
 	}
 
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidVisibilityListener.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidVisibilityListener.java
index 42a6f21..1c4179a 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidVisibilityListener.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidVisibilityListener.java
@@ -37,7 +37,7 @@ public class AndroidVisibilityListener {
 				}
 			});
 		} catch (Throwable t) {
-			application.log("AndroidApplication", "Can't create OnSystemUiVisibilityChangeListener, unable to use immersive mode.", t);
+			application.log("AndroidApplication", "Can't create OnSystemUiVisibilityChangeListener", t);
 		}
 	}
 }
diff --git a/backends/gdx-backend-headless/pom.xml b/backends/gdx-backend-headless/pom.xml
index c6b3522..709d4bb 100644
--- a/backends/gdx-backend-headless/pom.xml
+++ b/backends/gdx-backend-headless/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.5.4-SNAPSHOT</version>
+    <version>1.4.2-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/HeadlessApplication.java b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/HeadlessApplication.java
index 57e4276..223f80d 100644
--- a/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/HeadlessApplication.java
+++ b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/HeadlessApplication.java
@@ -142,13 +142,13 @@ public class HeadlessApplication implements Application {
 
 	public boolean executeRunnables () {
 		synchronized (runnables) {
-			for (int i = runnables.size - 1; i >= 0; i--)
-				executedRunnables.addAll(runnables.get(i));
+			executedRunnables.addAll(runnables);
 			runnables.clear();
 		}
 		if (executedRunnables.size == 0) return false;
-		for (int i = executedRunnables.size - 1; i >= 0; i--)
-			executedRunnables.removeIndex(i).run();
+		for (int i = 0; i < executedRunnables.size; i++)
+			executedRunnables.get(i).run();
+		executedRunnables.clear();
 		return true;
 	}
 
diff --git a/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/input/MockInput.java b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/input/MockInput.java
index 4340927..6081492 100644
--- a/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/input/MockInput.java
+++ b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/mock/input/MockInput.java
@@ -17,7 +17,6 @@
 package com.badlogic.gdx.backends.headless.mock.input;
 
 import com.badlogic.gdx.Input;
-import com.badlogic.gdx.Input.TextInputListener;
 import com.badlogic.gdx.InputAdapter;
 import com.badlogic.gdx.InputProcessor;
 import com.badlogic.gdx.graphics.Pixmap;
@@ -113,8 +112,13 @@ public class MockInput implements Input {
 	}
 
 	@Override
-	public void getTextInput(TextInputListener listener, String title, String text, String hint) {
-		
+	public void getTextInput(TextInputListener listener, String title, String text) {
+
+	}
+
+	@Override
+	public void getPlaceholderTextInput(TextInputListener listener, String title, String placeholder) {
+
 	}
 
 	@Override
diff --git a/backends/gdx-backend-jglfw/pom.xml b/backends/gdx-backend-jglfw/pom.xml
index afd7392..d260feb 100644
--- a/backends/gdx-backend-jglfw/pom.xml
+++ b/backends/gdx-backend-jglfw/pom.xml
@@ -4,7 +4,7 @@
 	<parent>
 		<groupId>com.badlogicgames.gdx</groupId>
 		<artifactId>gdx-parent</artifactId>
-		<version>1.5.4-SNAPSHOT</version>
+		<version>1.4.2-SNAPSHOT</version>
 		<relativePath>../../pom.xml</relativePath>
 	</parent>
 
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwApplication.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwApplication.java
index 76248be..77744e1 100644
--- a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwApplication.java
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwApplication.java
@@ -203,14 +203,11 @@ public class JglfwApplication implements Application {
 	protected void frame () {
 		if (!running) return;
 
-		boolean shouldRender = false;
-
-		if (executeRunnables()) shouldRender = true;
+		if (executeRunnables()) graphics.requestRendering();
 
 		if (!running) return;
 
 		input.update();
-		shouldRender |= graphics.shouldRender();
 
 		long frameStartTime = System.nanoTime();
 		int targetFPS = (graphics.isHidden() || graphics.isMinimized()) ? hiddenFPS : //
@@ -222,10 +219,7 @@ public class JglfwApplication implements Application {
 		} else {
 			if (isPaused) listener.resume();
 			isPaused = false;
-			if (shouldRender)
-				render(frameStartTime);
-			else
-				targetFPS = backgroundFPS;
+			if (graphics.shouldRender()) render(frameStartTime);
 		}
 
 		if (targetFPS != 0) {
@@ -238,13 +232,13 @@ public class JglfwApplication implements Application {
 
 	public boolean executeRunnables () {
 		synchronized (runnables) {
-			for (int i = runnables.size - 1; i >= 0; i--)
-				executedRunnables.addAll(runnables.get(i));
+			executedRunnables.addAll(runnables);
 			runnables.clear();
 		}
 		if (executedRunnables.size == 0) return false;
-		for (int i = executedRunnables.size - 1; i >= 0; i--)
-			executedRunnables.removeIndex(i).run();
+		for (int i = 0; i < executedRunnables.size; i++)
+			executedRunnables.get(i).run();
+		executedRunnables.clear();
 		return true;
 	}
 
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwGL20.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwGL20.java
index d34d0a7..0ec45a4 100644
--- a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwGL20.java
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwGL20.java
@@ -16,51 +16,16 @@
 
 package com.badlogic.gdx.backends.jglfw;
 
-import static com.badlogic.jglfw.utils.Memory.getPosition;
+import static com.badlogic.jglfw.utils.Memory.*;
+
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.jglfw.gl.GL;
 
 import java.nio.Buffer;
-import java.nio.ByteBuffer;
 import java.nio.FloatBuffer;
 import java.nio.IntBuffer;
 
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.jglfw.gl.GL;
-
 public class JglfwGL20 implements GL20 {
-	private ByteBuffer buffer = null;
-	private FloatBuffer floatBuffer = null;
-	private IntBuffer intBuffer = null;
-
-	private void ensureBufferCapacity (int numBytes) {
-		if (buffer == null || buffer.capacity() < numBytes) {
-			buffer = com.badlogic.gdx.utils.BufferUtils.newByteBuffer(numBytes);
-			floatBuffer = buffer.asFloatBuffer();
-			intBuffer = buffer.asIntBuffer();
-		}
-	}
-
-	private FloatBuffer toFloatBuffer (float v[], int offset, int count) {
-		ensureBufferCapacity(count << 2);
-		floatBuffer.clear();
-		com.badlogic.gdx.utils.BufferUtils.copy(v, floatBuffer, count, offset);
-		return floatBuffer;
-	}
-
-	private IntBuffer toIntBuffer (int v[], int offset, int count) {
-		ensureBufferCapacity(count << 2);
-		intBuffer.clear();
-		com.badlogic.gdx.utils.BufferUtils.copy(v, count, offset, intBuffer);
-		return intBuffer;
-	}
-	
-	private IntBuffer toIntBuffer (int v) {
-		ensureBufferCapacity(4);
-		intBuffer.put(0, v);
-		intBuffer.position(0);
-		intBuffer.limit(1);
-		return intBuffer;
-	}
-	
 	public void glActiveTexture (int texture) {
 		GL.glActiveTexture(texture);
 	}
@@ -118,10 +83,6 @@ public class JglfwGL20 implements GL20 {
 	public void glDeleteTextures (int n, IntBuffer textures) {
 		GL.glDeleteTextures(n, textures, getPosition(textures));
 	}
-	
-	public void glDeleteTexture (int texture) {
-		glDeleteTextures(1, toIntBuffer(texture));
-	}
 
 	public void glDepthFunc (int func) {
 		GL.glDepthFunc(func);
@@ -166,14 +127,6 @@ public class JglfwGL20 implements GL20 {
 	public void glGenTextures (int n, IntBuffer textures) {
 		GL.glGenTextures(n, textures, getPosition(textures));
 	}
-	
-	public int glGenTexture () {
-		ensureBufferCapacity(4);
-		intBuffer.position(0);
-		intBuffer.limit(1);
-		glGenTextures(1, intBuffer);
-		return intBuffer.get(0);
-	}
 
 	public int glGetError () {
 		return GL.glGetError();
@@ -268,10 +221,6 @@ public class JglfwGL20 implements GL20 {
 	public void glDeleteBuffers (int n, IntBuffer buffers) {
 		GL.glDeleteBuffers(n, buffers, getPosition(buffers));
 	}
-	
-	public void glDeleteBuffer (int buffer) {
-		glDeleteBuffers(1, toIntBuffer(buffer));
-	}
 
 	public void glGetBufferParameteriv (int target, int pname, IntBuffer params) {
 		GL.glGetBufferParameteriv(target, pname, params, getPosition(params));
@@ -280,14 +229,6 @@ public class JglfwGL20 implements GL20 {
 	public void glGenBuffers (int n, IntBuffer buffers) {
 		GL.glGenBuffers(n, buffers, getPosition(buffers));
 	}
-	
-	public int glGenBuffer () {
-		ensureBufferCapacity(4);
-		intBuffer.position(0);
-		intBuffer.limit(1);
-		glGenBuffers(1, intBuffer);
-		return intBuffer.get(0);
-	}
 
 	public void glGetTexParameteriv (int target, int pname, IntBuffer params) {
 		GL.glGetTexParameteriv(target, pname, params, getPosition(params));
@@ -368,10 +309,6 @@ public class JglfwGL20 implements GL20 {
 	public void glDeleteFramebuffers (int n, IntBuffer framebuffers) {
 		GL.glDeleteFramebuffersEXT(n, framebuffers, getPosition(framebuffers));
 	}
-	
-	public void glDeleteFramebuffer (int framebuffer) {
-		glDeleteFramebuffers(1, toIntBuffer(framebuffer));
-	}
 
 	public void glDeleteProgram (int program) {
 		GL.glDeleteProgram(program);
@@ -380,10 +317,6 @@ public class JglfwGL20 implements GL20 {
 	public void glDeleteRenderbuffers (int n, IntBuffer renderbuffers) {
 		GL.glDeleteRenderbuffersEXT(n, renderbuffers, getPosition(renderbuffers));
 	}
-	
-	public void glDeleteRenderbuffer (int renderbuffer) {
-		glDeleteRenderbuffers(1, toIntBuffer(renderbuffer));
-	}
 
 	public void glDeleteShader (int shader) {
 		GL.glDeleteShader(shader);
@@ -416,26 +349,10 @@ public class JglfwGL20 implements GL20 {
 	public void glGenFramebuffers (int n, IntBuffer framebuffers) {
 		GL.glGenFramebuffersEXT(n, framebuffers, getPosition(framebuffers));
 	}
-	
-	public int glGenFramebuffer () {
-		ensureBufferCapacity(4);
-		intBuffer.position(0);
-		intBuffer.limit(1);
-		glGenFramebuffers(1, intBuffer);
-		return intBuffer.get(0);
-	}
 
 	public void glGenRenderbuffers (int n, IntBuffer renderbuffers) {
 		GL.glGenRenderbuffersEXT(n, renderbuffers, getPosition(renderbuffers));
 	}
-	
-	public int glGenRenderbuffer () {
-		ensureBufferCapacity(4);
-		intBuffer.position(0);
-		intBuffer.limit(1);
-		glGenRenderbuffers(1, intBuffer);
-		return intBuffer.get(0);
-	}
 
 	public String glGetActiveAttrib (int program, int index, IntBuffer size, Buffer type) {
 		return GL.glGetActiveAttrib(program, index, size, getPosition(size), type, getPosition(type));
@@ -573,10 +490,6 @@ public class JglfwGL20 implements GL20 {
 		GL.glUniform1fv(location, count, v, getPosition(v));
 	}
 
-	public void glUniform1fv (int location, int count, float[] v, int offset) {
-		glUniform1fv(location, count, toFloatBuffer(v, offset, count));
-	}
-	
 	public void glUniform1i (int location, int x) {
 		GL.glUniform1i(location, x);
 	}
@@ -584,10 +497,6 @@ public class JglfwGL20 implements GL20 {
 	public void glUniform1iv (int location, int count, IntBuffer v) {
 		GL.glUniform1iv(location, count, v, getPosition(v));
 	}
-	
-	public void glUniform1iv (int location, int count, int[] v, int offset) {
-		glUniform1iv(location, count, toIntBuffer(v, offset, count));
-	}
 
 	public void glUniform2f (int location, float x, float y) {
 		GL.glUniform2f(location, x, y);
@@ -596,10 +505,6 @@ public class JglfwGL20 implements GL20 {
 	public void glUniform2fv (int location, int count, FloatBuffer v) {
 		GL.glUniform2fv(location, count, v, getPosition(v));
 	}
-	
-	public void glUniform2fv (int location, int count, float[] v, int offset) {
-		glUniform2fv(location, count, toFloatBuffer(v, offset, count << 1));
-	}
 
 	public void glUniform2i (int location, int x, int y) {
 		GL.glUniform2i(location, x, y);
@@ -608,10 +513,6 @@ public class JglfwGL20 implements GL20 {
 	public void glUniform2iv (int location, int count, IntBuffer v) {
 		GL.glUniform2iv(location, count, v, getPosition(v));
 	}
-	
-	public void glUniform2iv (int location, int count, int[] v, int offset) {
-		glUniform2iv(location, count, toIntBuffer(v, offset, count<<1));
-	}
 
 	public void glUniform3f (int location, float x, float y, float z) {
 		GL.glUniform3f(location, x, y, z);
@@ -620,10 +521,6 @@ public class JglfwGL20 implements GL20 {
 	public void glUniform3fv (int location, int count, FloatBuffer v) {
 		GL.glUniform3fv(location, count, v, getPosition(v));
 	}
-	
-	public void glUniform3fv (int location, int count, float[] v, int offset) {
-		glUniform3fv(location, count, toFloatBuffer(v, offset, count*3));
-	}
 
 	public void glUniform3i (int location, int x, int y, int z) {
 		GL.glUniform3i(location, x, y, z);
@@ -632,10 +529,6 @@ public class JglfwGL20 implements GL20 {
 	public void glUniform3iv (int location, int count, IntBuffer v) {
 		GL.glUniform3iv(location, count, v, getPosition(v));
 	}
-	
-	public void glUniform3iv (int location, int count, int[] v, int offset) {
-		glUniform3iv(location, count, toIntBuffer(v, offset, count*3));
-	}
 
 	public void glUniform4f (int location, float x, float y, float z, float w) {
 		GL.glUniform4f(location, x, y, z, w);
@@ -644,10 +537,6 @@ public class JglfwGL20 implements GL20 {
 	public void glUniform4fv (int location, int count, FloatBuffer v) {
 		GL.glUniform4fv(location, count, v, getPosition(v));
 	}
-	
-	public void glUniform4fv (int location, int count, float[] v, int offset) {
-		glUniform4fv(location, count, toFloatBuffer(v, offset, count << 2));
-	}
 
 	public void glUniform4i (int location, int x, int y, int z, int w) {
 		GL.glUniform4i(location, x, y, z, w);
@@ -656,34 +545,18 @@ public class JglfwGL20 implements GL20 {
 	public void glUniform4iv (int location, int count, IntBuffer v) {
 		GL.glUniform4iv(location, count, v, getPosition(v));
 	}
-	
-	public void glUniform4iv (int location, int count, int[] v, int offset) {
-		glUniform4iv(location, count, toIntBuffer(v, offset, count << 2));
-	}
 
 	public void glUniformMatrix2fv (int location, int count, boolean transpose, FloatBuffer value) {
 		GL.glUniformMatrix2fv(location, count, transpose, value, getPosition(value));
 	}
-	
-	public void glUniformMatrix2fv (int location, int count, boolean transpose, float[] value, int offset) {
-		glUniformMatrix2fv(location, count, transpose, toFloatBuffer(value, offset, count << 2));
-	}
 
 	public void glUniformMatrix3fv (int location, int count, boolean transpose, FloatBuffer value) {
 		GL.glUniformMatrix3fv(location, count, transpose, value, getPosition(value));
 	}
-	
-	public void glUniformMatrix3fv (int location, int count, boolean transpose, float[] value, int offset) {
-		glUniformMatrix3fv(location, count, transpose, toFloatBuffer(value, offset, count * 9));
-	}
 
 	public void glUniformMatrix4fv (int location, int count, boolean transpose, FloatBuffer value) {
 		GL.glUniformMatrix4fv(location, count, transpose, value, getPosition(value));
 	}
-	
-	public void glUniformMatrix4fv (int location, int count, boolean transpose, float[] value, int offset) {
-		glUniformMatrix4fv(location, count, transpose, toFloatBuffer(value, offset, count << 4));
-	}
 
 	public void glUseProgram (int program) {
 		GL.glUseProgram(program);
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwInput.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwInput.java
index c0e7857..1ed7bda 100644
--- a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwInput.java
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwInput.java
@@ -103,7 +103,7 @@ public class JglfwInput implements Input {
 
 			public boolean mouseMoved (int screenX, int screenY) {
 				deltaX = screenX - mouseX;
-				deltaY = screenY - mouseY;
+				deltaY = screenY - mouseX;
 				mouseX = screenX;
 				mouseY = screenY;
 				app.graphics.requestRendering();
@@ -125,8 +125,6 @@ public class JglfwInput implements Input {
 	}
 
 	public void update () {
-		deltaX = 0;
-		deltaY = 0;
 		justTouched = false;
 		if (keyJustPressed) {
 			keyJustPressed = false;
@@ -298,7 +296,23 @@ public class JglfwInput implements Input {
 	public void setCursorImage (Pixmap pixmap, int xHotspot, int yHotspot) {
 	}
 
-	public void getTextInput (final TextInputListener listener, final String title, final String text, final String hint) {
+	public void getTextInput (final TextInputListener listener, final String title, final String text) {
+		SwingUtilities.invokeLater(new Runnable() {
+			public void run () {
+				final String output = JOptionPane.showInputDialog(null, title, text);
+				app.postRunnable(new Runnable() {
+					public void run () {
+						if (output != null)
+							listener.input(output);
+						else
+							listener.canceled();
+					}
+				});
+			}
+		});
+	}
+
+	public void getPlaceholderTextInput (final TextInputListener listener, final String title, final String placeholder) {
 		SwingUtilities.invokeLater(new Runnable() {
 			public void run () {
 				JPanel panel = new JPanel(new FlowLayout());
@@ -312,11 +326,10 @@ public class JglfwInput implements Input {
 				panel.add(textPanel);
 
 				final JTextField textField = new JTextField(20);
-				textField.setText(text);
 				textField.setAlignmentX(0.0f);
 				textPanel.add(textField);
 
-				final JLabel placeholderLabel = new JLabel(hint);
+				final JLabel placeholderLabel = new JLabel(placeholder);
 				placeholderLabel.setForeground(Color.GRAY);
 				placeholderLabel.setAlignmentX(0.0f);
 				textPanel.add(placeholderLabel, 0);
@@ -366,7 +379,7 @@ public class JglfwInput implements Input {
 			}
 		});
 	}
-	
+
 	static char characterForKeyCode (int key) {
 		// Map certain key codes to character codes.
 		switch (key) {
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/Sync.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/Sync.java
index a2da9ac..899a55a 100644
--- a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/Sync.java
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/Sync.java
@@ -107,7 +107,7 @@ class Sync {
 				}
 			});
 
-			timerAccuracyThread.setName("JGLFW Sync");
+			timerAccuracyThread.setName("LWJGL Sync");
 			timerAccuracyThread.setDaemon(true);
 			timerAccuracyThread.start();
 		}
diff --git a/backends/gdx-backend-lwjgl/libs/gdx-backend-lwjgl-natives.jar b/backends/gdx-backend-lwjgl/libs/gdx-backend-lwjgl-natives.jar
index 0a965e6..4253dff 100644
Binary files a/backends/gdx-backend-lwjgl/libs/gdx-backend-lwjgl-natives.jar and b/backends/gdx-backend-lwjgl/libs/gdx-backend-lwjgl-natives.jar differ
diff --git a/backends/gdx-backend-lwjgl/libs/lwjgl.jar b/backends/gdx-backend-lwjgl/libs/lwjgl.jar
index 5da88d3..8c663d6 100644
Binary files a/backends/gdx-backend-lwjgl/libs/lwjgl.jar and b/backends/gdx-backend-lwjgl/libs/lwjgl.jar differ
diff --git a/backends/gdx-backend-lwjgl/pom.xml b/backends/gdx-backend-lwjgl/pom.xml
index 482c8ce..3b6be65 100644
--- a/backends/gdx-backend-lwjgl/pom.xml
+++ b/backends/gdx-backend-lwjgl/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.5.4-SNAPSHOT</version>
+    <version>1.4.2-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglAWTInput.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglAWTInput.java
index 39ac0a0..1327a8b 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglAWTInput.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglAWTInput.java
@@ -57,7 +57,6 @@ import javax.swing.event.DocumentListener;
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.Input;
 import com.badlogic.gdx.InputProcessor;
-import com.badlogic.gdx.Input.TextInputListener;
 import com.badlogic.gdx.graphics.Pixmap;
 import com.badlogic.gdx.utils.IntSet;
 import com.badlogic.gdx.utils.Pool;
@@ -160,7 +159,22 @@ public class LwjglAWTInput implements Input, MouseMotionListener, MouseListener,
 		return 0;
 	}
 
-	public void getTextInput (final TextInputListener listener, final String title, final String text, final String hint) {
+	@Override
+	public void getTextInput (final TextInputListener listener, final String title, final String text) {
+		SwingUtilities.invokeLater(new Runnable() {
+			@Override
+			public void run () {
+				String output = JOptionPane.showInputDialog(null, title, text);
+				if (output != null)
+					listener.input(output);
+				else
+					listener.canceled();
+
+			}
+		});
+	}
+
+	public void getPlaceholderTextInput (final TextInputListener listener, final String title, final String placeholder) {
 		SwingUtilities.invokeLater(new Runnable() {
 			@Override
 			public void run () {
@@ -176,11 +190,10 @@ public class LwjglAWTInput implements Input, MouseMotionListener, MouseListener,
 				panel.add(textPanel);
 
 				final JTextField textField = new JTextField(20);
-				textField.setText(text);
 				textField.setAlignmentX(0.0f);
 				textPanel.add(textField);
 
-				final JLabel placeholderLabel = new JLabel(hint);
+				final JLabel placeholderLabel = new JLabel(placeholder);
 				placeholderLabel.setForeground(Color.GRAY);
 				placeholderLabel.setAlignmentX(0.0f);
 				textPanel.add(placeholderLabel, 0);
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplication.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplication.java
index d21ecbb..b4c5baa 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplication.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplication.java
@@ -78,15 +78,9 @@ public class LwjglApplication implements Application {
 		if (config.title == null) config.title = listener.getClass().getSimpleName();
 
 		this.graphics = graphics;
-		if (!LwjglApplicationConfiguration.disableAudio) {
-			try {
-				audio = new OpenALAudio(config.audioDeviceSimultaneousSources, config.audioDeviceBufferCount,
-					config.audioDeviceBufferSize);
-			} catch(Throwable t) {
-				log("LwjglApplication", "Couldn't initialize audio, disabling audio", t);
-				LwjglApplicationConfiguration.disableAudio = true;
-			}
-		}
+		if (!LwjglApplicationConfiguration.disableAudio)
+			audio = new OpenALAudio(config.audioDeviceSimultaneousSources, config.audioDeviceBufferCount,
+				config.audioDeviceBufferSize);
 		files = new LwjglFiles();
 		input = new LwjglInput();
 		net = new LwjglNet();
@@ -120,7 +114,6 @@ public class LwjglApplication implements Application {
 					LwjglApplication.this.mainLoop();
 				} catch (Throwable t) {
 					if (audio != null) audio.dispose();
-					Gdx.input.setCursorCatched(false);
 					if (t instanceof RuntimeException)
 						throw (RuntimeException)t;
 					else
@@ -163,11 +156,11 @@ public class LwjglApplication implements Application {
 			}
 			if (!wasActive && isActive) { // if it's just recently focused from minimized state
 				wasActive = true;
+				listener.resume();
 				synchronized (lifecycleListeners) {
 					for (LifecycleListener listener : lifecycleListeners)
 						listener.resume();
 				}
-				listener.resume();				
 			}
 
 			boolean shouldRender = false;
@@ -185,13 +178,13 @@ public class LwjglApplication implements Application {
 			} else {
 				graphics.config.x = Display.getX();
 				graphics.config.y = Display.getY();
-				if (graphics.resize || Display.wasResized() || (int)(Display.getWidth() * Display.getPixelScaleFactor()) != graphics.config.width
-					|| (int)(Display.getHeight() * Display.getPixelScaleFactor()) != graphics.config.height) {
-					graphics.resize = false;					
-					graphics.config.width = (int)(Display.getWidth() * Display.getPixelScaleFactor());
-					graphics.config.height = (int)(Display.getHeight() * Display.getPixelScaleFactor());
-					Gdx.gl.glViewport(0, 0, graphics.config.width, graphics.config.height);
-					if (listener != null) listener.resize(graphics.config.width, graphics.config.height);
+				if (graphics.resize || Display.wasResized() || Display.getWidth() != graphics.config.width
+					|| Display.getHeight() != graphics.config.height) {
+					graphics.resize = false;
+					Gdx.gl.glViewport(0, 0, Display.getWidth(), Display.getHeight());
+					graphics.config.width = Display.getWidth();
+					graphics.config.height = Display.getHeight();
+					if (listener != null) listener.resize(Display.getWidth(), Display.getHeight());
 					graphics.requestRendering();
 				}
 			}
@@ -237,13 +230,13 @@ public class LwjglApplication implements Application {
 
 	public boolean executeRunnables () {
 		synchronized (runnables) {
-			for (int i = runnables.size - 1; i >= 0; i--)
-				executedRunnables.addAll(runnables.get(i));
+			executedRunnables.addAll(runnables);
 			runnables.clear();
 		}
 		if (executedRunnables.size == 0) return false;
-		for (int i = executedRunnables.size - 1; i >= 0; i--)
-			executedRunnables.removeIndex(i).run();
+		for (int i = 0; i < executedRunnables.size; i++)
+			executedRunnables.get(i).run();
+		executedRunnables.clear();
 		return true;
 	}
 
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplicationConfiguration.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplicationConfiguration.java
index 23c5bda..785c138 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplicationConfiguration.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplicationConfiguration.java
@@ -75,8 +75,6 @@ public class LwjglApplicationConfiguration {
 	public String preferencesDirectory = ".prefs/";
 	/** Callback used when trying to create a display, can handle failures, default value is null (disabled) */
 	public LwjglGraphics.SetDisplayModeCallback setDisplayModeCallback;
-	/** enable HDPI mode on Mac OS X **/
-	public boolean useHDPI = false;
 
 	Array<String> iconPaths = new Array();
 	Array<FileType> iconFileTypes = new Array();	
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglCanvas.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglCanvas.java
index 3d6472d..e541972 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglCanvas.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglCanvas.java
@@ -206,9 +206,7 @@ public class LwjglCanvas implements Application {
 					return;
 				}
 				try {
-					Display.processMessages();
-
-					boolean shouldRender = false;
+					graphics.updateTime();
 
 					int width = Math.max(1, graphics.getWidth());
 					int height = Math.max(1, graphics.getHeight());
@@ -218,28 +216,17 @@ public class LwjglCanvas implements Application {
 						Gdx.gl.glViewport(0, 0, lastWidth, lastHeight);
 						resize(width, height);
 						listener.resize(width, height);
-						shouldRender = true;
 					}
 
-					if (executeRunnables()) shouldRender = true;
-
-					// If one of the runnables set running to false, for example after an exit().
-					if (!running) return;
+					executeRunnables();
 
 					input.update();
-					shouldRender |= graphics.shouldRender();
 					input.processEvents();
+					graphics.frameId++;
+					listener.render();
 					if (audio != null) audio.update();
-
-					if (shouldRender) {
-						graphics.updateTime();
-						graphics.frameId++;
-						listener.render();
-						Display.update(false);
-					}
-
+					Display.update();
 					canvas.setCursor(cursor);
-
 					Display.sync(getFrameRate());
 				} catch (Throwable ex) {
 					exception(ex);
@@ -251,13 +238,13 @@ public class LwjglCanvas implements Application {
 
 	public boolean executeRunnables () {
 		synchronized (runnables) {
-			for (int i = runnables.size - 1; i >= 0; i--)
-				executedRunnables.addAll(runnables.get(i));
+			executedRunnables.addAll(runnables);
 			runnables.clear();
 		}
 		if (executedRunnables.size == 0) return false;
-		for (int i = executedRunnables.size - 1; i >= 0; i--)
-			executedRunnables.removeIndex(i).run();
+		for (int i = 0; i < executedRunnables.size; i++)
+			executedRunnables.get(i).run();
+		executedRunnables.clear();
 		return true;
 	}
 
@@ -341,7 +328,6 @@ public class LwjglCanvas implements Application {
 	public void postRunnable (Runnable runnable) {
 		synchronized (runnables) {
 			runnables.add(runnable);
-			Gdx.graphics.requestRendering();
 		}
 	}
 
@@ -395,7 +381,7 @@ public class LwjglCanvas implements Application {
 	}
 
 	@Override
-	public int getLogLevel () {
+	public int getLogLevel() {
 		return logLevel;
 	}
 
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGL20.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGL20.java
index 3341469..57ceceb 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGL20.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGL20.java
@@ -39,32 +39,6 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
  * 
  * @author mzechner */
 class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
-	private ByteBuffer buffer = null;
-	private FloatBuffer floatBuffer = null;
-	private IntBuffer intBuffer = null;
-
-	private void ensureBufferCapacity (int numBytes) {
-		if (buffer == null || buffer.capacity() < numBytes) {
-			buffer = com.badlogic.gdx.utils.BufferUtils.newByteBuffer(numBytes);
-			floatBuffer = buffer.asFloatBuffer();
-			intBuffer = buffer.asIntBuffer();
-		}
-	}
-
-	private FloatBuffer toFloatBuffer (float v[], int offset, int count) {
-		ensureBufferCapacity(count << 2);
-		floatBuffer.clear();
-		com.badlogic.gdx.utils.BufferUtils.copy(v, floatBuffer, count, offset);
-		return floatBuffer;
-	}
-
-	private IntBuffer toIntBuffer (int v[], int offset, int count) {
-		ensureBufferCapacity(count << 2);
-		floatBuffer.clear();
-		com.badlogic.gdx.utils.BufferUtils.copy(v, count, offset, intBuffer);
-		return intBuffer;
-	}
-
 	public void glActiveTexture (int texture) {
 		GL13.glActiveTexture(texture);
 	}
@@ -114,7 +88,7 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 	}
 
 	public void glBufferData (int target, int size, Buffer data, int usage) {
-		if (data == null)
+		if(data == null)
 			GL15.glBufferData(target, size, usage);
 		else if (data instanceof ByteBuffer)
 			GL15.glBufferData(target, (ByteBuffer)data, usage);
@@ -129,7 +103,7 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 	}
 
 	public void glBufferSubData (int target, int offset, int size, Buffer data) {
-		if (data == null)
+		if(data == null)
 			throw new GdxRuntimeException("Using null for the data not possible, blame LWJGL");
 		else if (data instanceof ByteBuffer)
 			GL15.glBufferSubData(target, offset, (ByteBuffer)data);
@@ -174,10 +148,11 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 	public void glCompressedTexImage2D (int target, int level, int internalformat, int width, int height, int border,
 		int imageSize, Buffer data) {
 		if (data instanceof ByteBuffer) {
-			GL13.glCompressedTexImage2D(target, level, internalformat, width, height, border, (ByteBuffer)data);
-		} else {
-			throw new GdxRuntimeException("Can't use " + data.getClass().getName() + " with this method. Use ByteBuffer instead.");
-		}
+	       GL13.glCompressedTexImage2D(target, level, internalformat, width, height, border, (ByteBuffer)data);
+	    } else {
+	        throw new GdxRuntimeException("Can't use " + data.getClass().getName()
+	           + " with this method. Use ByteBuffer instead.");
+	    }
 	}
 
 	public void glCompressedTexSubImage2D (int target, int level, int xoffset, int yoffset, int width, int height, int format,
@@ -209,20 +184,10 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		GL15.glDeleteBuffers(buffers);
 	}
 
-	@Override
-	public void glDeleteBuffer (int buffer) {
-		GL15.glDeleteBuffers(buffer);
-	}
-
 	public void glDeleteFramebuffers (int n, IntBuffer framebuffers) {
 		EXTFramebufferObject.glDeleteFramebuffersEXT(framebuffers);
 	}
 
-	@Override
-	public void glDeleteFramebuffer (int framebuffer) {
-		EXTFramebufferObject.glDeleteFramebuffersEXT(framebuffer);
-	}
-
 	public void glDeleteProgram (int program) {
 		GL20.glDeleteProgram(program);
 	}
@@ -231,10 +196,6 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		EXTFramebufferObject.glDeleteRenderbuffersEXT(renderbuffers);
 	}
 
-	public void glDeleteRenderbuffer (int renderbuffer) {
-		EXTFramebufferObject.glDeleteRenderbuffersEXT(renderbuffer);
-	}
-
 	public void glDeleteShader (int shader) {
 		GL20.glDeleteShader(shader);
 	}
@@ -243,11 +204,6 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		GL11.glDeleteTextures(textures);
 	}
 
-	@Override
-	public void glDeleteTexture (int texture) {
-		GL11.glDeleteTextures(texture);
-	}
-
 	public void glDepthFunc (int func) {
 		GL11.glDepthFunc(func);
 	}
@@ -320,34 +276,18 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		GL15.glGenBuffers(buffers);
 	}
 
-	public int glGenBuffer () {
-		return GL15.glGenBuffers();
-	}
-
 	public void glGenFramebuffers (int n, IntBuffer framebuffers) {
 		EXTFramebufferObject.glGenFramebuffersEXT(framebuffers);
 	}
 
-	public int glGenFramebuffer () {
-		return EXTFramebufferObject.glGenFramebuffersEXT();
-	}
-
 	public void glGenRenderbuffers (int n, IntBuffer renderbuffers) {
 		EXTFramebufferObject.glGenRenderbuffersEXT(renderbuffers);
 	}
 
-	public int glGenRenderbuffer () {
-		return EXTFramebufferObject.glGenRenderbuffersEXT();
-	}
-
 	public void glGenTextures (int n, IntBuffer textures) {
 		GL11.glGenTextures(textures);
 	}
 
-	public int glGenTexture () {
-		return GL11.glGenTextures();
-	}
-
 	public void glGenerateMipmap (int target) {
 		EXTFramebufferObject.glGenerateMipmapEXT(target);
 	}
@@ -652,10 +592,6 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		GL20.glUniform1(location, v);
 	}
 
-	public void glUniform1fv (int location, int count, float[] v, int offset) {
-		GL20.glUniform1(location, toFloatBuffer(v, offset, count));
-	}
-
 	public void glUniform1i (int location, int x) {
 		GL20.glUniform1i(location, x);
 	}
@@ -664,11 +600,6 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		GL20.glUniform1(location, v);
 	}
 
-	@Override
-	public void glUniform1iv (int location, int count, int[] v, int offset) {
-		GL20.glUniform1(location, toIntBuffer(v, offset, count));
-	}
-
 	public void glUniform2f (int location, float x, float y) {
 		GL20.glUniform2f(location, x, y);
 	}
@@ -677,10 +608,6 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		GL20.glUniform2(location, v);
 	}
 
-	public void glUniform2fv (int location, int count, float[] v, int offset) {
-		GL20.glUniform2(location, toFloatBuffer(v, offset, count << 1));
-	}
-
 	public void glUniform2i (int location, int x, int y) {
 		GL20.glUniform2i(location, x, y);
 	}
@@ -689,10 +616,6 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		GL20.glUniform2(location, v);
 	}
 
-	public void glUniform2iv (int location, int count, int[] v, int offset) {
-		GL20.glUniform2(location, toIntBuffer(v, offset, count << 1));
-	}
-
 	public void glUniform3f (int location, float x, float y, float z) {
 		GL20.glUniform3f(location, x, y, z);
 	}
@@ -701,10 +624,6 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		GL20.glUniform3(location, v);
 	}
 
-	public void glUniform3fv (int location, int count, float[] v, int offset) {
-		GL20.glUniform3(location, toFloatBuffer(v, offset, count * 3));
-	}
-
 	public void glUniform3i (int location, int x, int y, int z) {
 		GL20.glUniform3i(location, x, y, z);
 	}
@@ -713,10 +632,6 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		GL20.glUniform3(location, v);
 	}
 
-	public void glUniform3iv (int location, int count, int[] v, int offset) {
-		GL20.glUniform3(location, toIntBuffer(v, offset, count * 3));
-	}
-
 	public void glUniform4f (int location, float x, float y, float z, float w) {
 		GL20.glUniform4f(location, x, y, z, w);
 	}
@@ -725,10 +640,6 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		GL20.glUniform4(location, v);
 	}
 
-	public void glUniform4fv (int location, int count, float[] v, int offset) {
-		GL20.glUniform4(location, toFloatBuffer(v, offset, count << 2));
-	}
-
 	public void glUniform4i (int location, int x, int y, int z, int w) {
 		GL20.glUniform4i(location, x, y, z, w);
 	}
@@ -737,34 +648,18 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 		GL20.glUniform4(location, v);
 	}
 
-	public void glUniform4iv (int location, int count, int[] v, int offset) {
-		GL20.glUniform4(location, toIntBuffer(v, offset, count << 2));
-	}
-
 	public void glUniformMatrix2fv (int location, int count, boolean transpose, FloatBuffer value) {
 		GL20.glUniformMatrix2(location, transpose, value);
 	}
 
-	public void glUniformMatrix2fv (int location, int count, boolean transpose, float[] value, int offset) {
-		GL20.glUniformMatrix2(location, transpose, toFloatBuffer(value, offset, count << 2));
-	}
-
 	public void glUniformMatrix3fv (int location, int count, boolean transpose, FloatBuffer value) {
 		GL20.glUniformMatrix3(location, transpose, value);
 	}
 
-	public void glUniformMatrix3fv (int location, int count, boolean transpose, float[] value, int offset) {
-		GL20.glUniformMatrix3(location, transpose, toFloatBuffer(value, offset, count * 9));
-	}
-
 	public void glUniformMatrix4fv (int location, int count, boolean transpose, FloatBuffer value) {
 		GL20.glUniformMatrix4(location, transpose, value);
 	}
 
-	public void glUniformMatrix4fv (int location, int count, boolean transpose, float[] value, int offset) {
-		GL20.glUniformMatrix4(location, transpose, toFloatBuffer(value, offset, count << 4));
-	}
-
 	public void glUseProgram (int program) {
 		GL20.glUseProgram(program);
 	}
@@ -828,8 +723,12 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 			if (type == GL_FLOAT)
 				GL20.glVertexAttribPointer(indx, size, normalized, stride, (FloatBuffer)buffer);
 			else
-				throw new GdxRuntimeException("Can't use " + buffer.getClass().getName() + " with type " + type
-					+ " with this method.");
+				throw new GdxRuntimeException(
+					"Can't use "
+						+ buffer.getClass().getName()
+						+ " with type "
+						+ type
+						+ " with this method.");
 		} else
 			throw new GdxRuntimeException("Can't use " + buffer.getClass().getName()
 				+ " with this method. Use ByteBuffer instead. Blame LWJGL");
@@ -846,4 +745,5 @@ class LwjglGL20 implements com.badlogic.gdx.graphics.GL20 {
 	public void glVertexAttribPointer (int indx, int size, int type, boolean normalized, int stride, int ptr) {
 		GL20.glVertexAttribPointer(indx, size, type, normalized, stride, ptr);
 	}
+
 }
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGraphics.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGraphics.java
index 9eb97bb..333631c 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGraphics.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGraphics.java
@@ -81,14 +81,14 @@ public class LwjglGraphics implements Graphics {
 		if (canvas != null)
 			return Math.max(1, canvas.getHeight());
 		else
-			return (int)(Display.getHeight() * Display.getPixelScaleFactor());
+			return Display.getHeight();
 	}
 
 	public int getWidth () {
 		if (canvas != null)
 			return Math.max(1, canvas.getWidth());
 		else
-			return (int)(Display.getWidth() * Display.getPixelScaleFactor());
+			return Display.getWidth();
 	}
 
 	public boolean isGL20Available () {
@@ -129,14 +129,10 @@ public class LwjglGraphics implements Graphics {
 	}
 
 	void setupDisplay () throws LWJGLException {
-		if(config.useHDPI) {
-			System.setProperty("org.lwjgl.opengl.Display.enableHighDPI", "true");
-		}
-		
 		if (canvas != null) {
 			Display.setParent(canvas);
 		} else {
-			boolean displayCreated = setDisplayMode(config.width, config.height, config.fullscreen);			
+			boolean displayCreated = setDisplayMode(config.width, config.height, config.fullscreen);
 			if (!displayCreated) {
 				if (config.setDisplayModeCallback != null) {
 					config = config.setDisplayModeCallback.onFailure(config);
@@ -183,8 +179,9 @@ public class LwjglGraphics implements Graphics {
 					Display.create(new PixelFormat(config.r + config.g + config.b, config.a, config.depth, config.stencil,
 						config.samples), context);
 				} catch (Exception e) {
+					Display.create(new PixelFormat(config.r + config.g + config.b, config.a, config.depth, config.stencil,
+						config.samples), context);
 					System.out.println("LwjglGraphics: couldn't create OpenGL 3.2+ core profile context");
-					throw e;
 				}
 				System.out.println("LwjglGraphics: created OpenGL 3.2+ core profile context. This is experimental!");
 			} else {
@@ -322,17 +319,16 @@ public class LwjglGraphics implements Graphics {
 
 	@Override
 	public boolean setDisplayMode (DisplayMode displayMode) {
-		org.lwjgl.opengl.DisplayMode mode = ((LwjglDisplayMode)displayMode).mode;		
+		org.lwjgl.opengl.DisplayMode mode = ((LwjglDisplayMode)displayMode).mode;
 		try {
 			if (!mode.isFullscreenCapable()) {
 				Display.setDisplayMode(mode);
 			} else {
 				Display.setDisplayModeAndFullscreen(mode);
-			}			
-			float scaleFactor = Display.getPixelScaleFactor();
-			config.width = (int)(mode.getWidth() * scaleFactor);
-			config.height = (int)(mode.getHeight() * scaleFactor);
-			if (Gdx.gl != null) Gdx.gl.glViewport(0, 0, config.width, config.height);
+			}
+			if (Gdx.gl != null) Gdx.gl.glViewport(0, 0, displayMode.width, displayMode.height);
+			config.width = displayMode.width;
+			config.height = displayMode.height;
 			resize = true;
 			return true;
 		} catch (LWJGLException e) {
@@ -383,20 +379,11 @@ public class LwjglGraphics implements Graphics {
 				return false;
 			}
 
-			boolean resizable = !fullscreen && config.resizable;
-			
 			Display.setDisplayMode(targetDisplayMode);
 			Display.setFullscreen(fullscreen);
-			// Workaround for bug in LWJGL whereby resizable state is lost on DisplayMode change
-			if (resizable == Display.isResizable()) {
-				Display.setResizable(!resizable);
-			}
-			Display.setResizable(resizable);
-			
-			float scaleFactor = Display.getPixelScaleFactor();
-			config.width = (int)(targetDisplayMode.getWidth() * scaleFactor);
-			config.height = (int)(targetDisplayMode.getHeight() * scaleFactor);
-			if (Gdx.gl != null) Gdx.gl.glViewport(0, 0, config.width, config.height);
+			if (Gdx.gl != null) Gdx.gl.glViewport(0, 0, targetDisplayMode.getWidth(), targetDisplayMode.getHeight());
+			config.width = targetDisplayMode.getWidth();
+			config.height = targetDisplayMode.getHeight();
 			resize = true;
 			return true;
 		} catch (LWJGLException e) {
@@ -447,8 +434,23 @@ public class LwjglGraphics implements Graphics {
 	}
 
 	@Override
-	public boolean supportsExtension (String extension) {
-		if (extensions == null) extensions = gl20.glGetString(GL20.GL_EXTENSIONS);
+	public boolean supportsExtension(String extension) {
+		if (extensions == null) {
+			if(gl30 != null) {
+				//old style glGetString(GL_EXTENSIONS) is not valid in 3.2 core:
+				StringBuilder extensionsBuilder = new StringBuilder();
+
+				int numExtensions = GL11.glGetInteger(GL30.GL_NUM_EXTENSIONS);
+				for (int i = 0; i < numExtensions; ++i) {
+					extensionsBuilder.append(gl30.glGetStringi(GL20.GL_EXTENSIONS, i));
+					extensionsBuilder.append(" ");
+				}
+				extensions = extensionsBuilder.toString();
+			} else {
+				extensions = gl20.glGetString(GL20.GL_EXTENSIONS);
+			}
+		}
+
 		return extensions.contains(extension);
 	}
 
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglInput.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglInput.java
index 97e4e4e..a5fb916 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglInput.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglInput.java
@@ -46,7 +46,6 @@ import org.lwjgl.LWJGLException;
 import org.lwjgl.input.Cursor;
 import org.lwjgl.input.Keyboard;
 import org.lwjgl.input.Mouse;
-import org.lwjgl.opengl.Display;
 
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.Input;
@@ -106,7 +105,29 @@ final public class LwjglInput implements Input {
 		return 0;
 	}
 
-	public void getTextInput (final TextInputListener listener, final String title, final String text, final String hint) {
+	public void getTextInput (final TextInputListener listener, final String title, final String text) {
+		SwingUtilities.invokeLater(new Runnable() {
+			public void run () {
+				final String output = JOptionPane.showInputDialog(null, title, text);
+				if (output != null)
+					Gdx.app.postRunnable(new Runnable() {
+						@Override
+						public void run () {
+							listener.input(output);
+						}
+					});
+				else
+					Gdx.app.postRunnable(new Runnable() {
+						@Override
+						public void run () {
+							listener.canceled();
+						}
+					});
+			}
+		});
+	}
+
+	public void getPlaceholderTextInput (final TextInputListener listener, final String title, final String placeholder) {
 		SwingUtilities.invokeLater(new Runnable() {
 			@Override
 			public void run () {
@@ -122,11 +143,10 @@ final public class LwjglInput implements Input {
 				panel.add(textPanel);
 
 				final JTextField textField = new JTextField(20);
-				textField.setText(text);
 				textField.setAlignmentX(0.0f);
 				textPanel.add(textField);
 
-				final JLabel placeholderLabel = new JLabel(hint);
+				final JLabel placeholderLabel = new JLabel(placeholder);
 				placeholderLabel.setForeground(Color.GRAY);
 				placeholderLabel.setAlignmentX(0.0f);
 				textPanel.add(placeholderLabel, 0);
@@ -197,11 +217,11 @@ final public class LwjglInput implements Input {
 	}
 
 	public int getX () {
-		return (int)(Mouse.getX() * Display.getPixelScaleFactor());
+		return Mouse.getX();
 	}
 
 	public int getY () {
-		return Gdx.graphics.getHeight() - 1 - (int)(Mouse.getY() * Display.getPixelScaleFactor());
+		return Gdx.graphics.getHeight() - 1 - Mouse.getY();
 	}
 
 	public boolean isAccelerometerAvailable () {
@@ -772,8 +792,8 @@ final public class LwjglInput implements Input {
 			int events = 0;
 			while (Mouse.next()) {
 				events++;
-				int x = (int)(Mouse.getEventX() * Display.getPixelScaleFactor());
-				int y = Gdx.graphics.getHeight() - (int)(Mouse.getEventY() * Display.getPixelScaleFactor()) - 1;
+				int x = Mouse.getEventX();
+				int y = Gdx.graphics.getHeight() - Mouse.getEventY() - 1;
 				int button = Mouse.getEventButton();
 				int gdxButton = toGdxButton(button);
 				if (button != -1 && gdxButton == -1) continue; // Ignore unknown button.
@@ -810,8 +830,8 @@ final public class LwjglInput implements Input {
 				touchEvents.add(event);
 				mouseX = event.x;
 				mouseY = event.y;
-				deltaX = (int)(Mouse.getEventDX() * Display.getPixelScaleFactor());
-				deltaY = (int)(Mouse.getEventDY() * Display.getPixelScaleFactor());
+				deltaX = Mouse.getEventDX();
+				deltaY = Mouse.getEventDY();
 			}
 
 			if (events == 0) {
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglNativesLoader.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglNativesLoader.java
index f76d91d..2bf0d24 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglNativesLoader.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglNativesLoader.java
@@ -30,7 +30,7 @@ public final class LwjglNativesLoader {
 	static public boolean load = true;
 
 	static {
-		System.setProperty("org.lwjgl.input.Mouse.allowNegativeMouseCoords", "true");		
+		System.setProperty("org.lwjgl.input.Mouse.allowNegativeMouseCoords", "true");
 
 		// Don't extract natives if using JWS.
 		try {
@@ -56,7 +56,9 @@ public final class LwjglNativesLoader {
 				if (!LwjglApplicationConfiguration.disableAudio)
 					loader.extractFile(is64Bit ? "OpenAL64.dll" : "OpenAL32.dll", nativesDir.getName());
 			} else if (isMac) {
-				nativesDir = loader.extractFile("liblwjgl.dylib", null).getParentFile();
+				File extractedFile = loader.extractFile("liblwjgl.jnilib", null);
+				nativesDir = extractedFile.getParentFile();
+				new FileHandle(extractedFile).copyTo(new FileHandle(new File(nativesDir, "liblwjgl.dylib")));
 				if (!LwjglApplicationConfiguration.disableAudio) loader.extractFile("openal.dylib", nativesDir.getName());
 			} else if (isLinux) {
 				nativesDir = loader.extractFile(is64Bit ? "liblwjgl64.so" : "liblwjgl.so", null).getParentFile();
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/audio/Mp3.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/audio/Mp3.java
index 486bd90..3e1a0e0 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/audio/Mp3.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/audio/Mp3.java
@@ -41,10 +41,9 @@ public class Mp3 {
 			if (audio.noDevice) return;
 			bitstream = new Bitstream(file.read());
 			decoder = new MP3Decoder();
-			bufferOverhead = 4096;
 			try {
 				Header header = bitstream.readFrame();
-				if (header == null) throw new GdxRuntimeException("Empty MP3");
+				if (header == null) throw new GdxRuntimeException("empty ogg");
 				int channels = header.mode() == Header.SINGLE_CHANNEL ? 1 : 2;
 				outputBuffer = new OutputBuffer(channels, false);
 				decoder.setOutputBuffer(outputBuffer);
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/audio/OpenALMusic.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/audio/OpenALMusic.java
index 4eabd2d..611bc14 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/audio/OpenALMusic.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/audio/OpenALMusic.java
@@ -47,7 +47,6 @@ public abstract class OpenALMusic implements Music {
 	private float renderedSeconds, secondsPerBuffer;
 
 	protected final FileHandle file;
-	protected int bufferOverhead = 0;
 
 	private OnCompletionListener onCompletionListener;
 
@@ -60,7 +59,7 @@ public abstract class OpenALMusic implements Music {
 	protected void setup (int channels, int sampleRate) {
 		this.format = channels > 1 ? AL_FORMAT_STEREO16 : AL_FORMAT_MONO16;
 		this.sampleRate = sampleRate;
-		secondsPerBuffer = (float)(bufferSize - bufferOverhead)  / (bytesPerSample * channels * sampleRate);
+		secondsPerBuffer = (float)bufferSize / bytesPerSample / channels / sampleRate;
 	}
 
 	public void play () {
@@ -156,8 +155,7 @@ public abstract class OpenALMusic implements Music {
 		boolean wasPlaying = isPlaying;
 		isPlaying = false;
 		alSourceStop(sourceID);
-		alSourceUnqueueBuffers(sourceID, buffers);
-		renderedSeconds += (secondsPerBuffer * bufferCount);
+		renderedSeconds += secondsPerBuffer;
 		if (position <= renderedSeconds) {
 			reset();
 			renderedSeconds = 0;
@@ -166,17 +164,7 @@ public abstract class OpenALMusic implements Music {
 			if (read(tempBytes) <= 0) break;
 			renderedSeconds += secondsPerBuffer;
 		}
-		boolean filled = false;
-		for (int i = 0; i < bufferCount; i++) {
-			int bufferID = buffers.get(i);
-			if (!fill(bufferID)) break;
-			filled = true;
-			alSourceQueueBuffers(sourceID, bufferID);
-		}
-		if (!filled) {
-			stop();
-			if (onCompletionListener != null) onCompletionListener.onCompletion(this);
-		}
+		update();
 		alSourcef(sourceID, AL11.AL_SEC_OFFSET, position - renderedSeconds);
 		if (wasPlaying) {
 			alSourcePlay(sourceID);
diff --git a/backends/gdx-backend-robovm/build-objectal.sh b/backends/gdx-backend-robovm/build-objectal.sh
index d6fa45e..ff476bc 100755
--- a/backends/gdx-backend-robovm/build-objectal.sh
+++ b/backends/gdx-backend-robovm/build-objectal.sh
@@ -1,17 +1,11 @@
 #!/bin/bash
 curl https://codeload.github.com/kstenerud/ObjectAL-for-iPhone/legacy.tar.gz/master -o objectal.tar.gz
 tar xvfz objectal.tar.gz
-cd kstenerud-ObjectAL-for-iPhone-a2252f3/ObjectAL
+cd kstenerud-ObjectAL-for-iPhone-71e903e/ObjectAL
 xcodebuild -arch armv7 -sdk iphoneos
-cp build/Release-iphoneos/libObjectAl.a build/libObjectAl.a.armv7
-xcodebuild -arch arm64 -sdk iphoneos
-cp build/Release-iphoneos/libObjectAl.a build/libObjectAl.a.arm64
 xcodebuild -arch i386 -sdk iphonesimulator
-cp build/Release-iphonesimulator/libObjectAl.a build/libObjectAl.a.i386
-xcodebuild -arch x86_64 -sdk iphonesimulator
-cp build/Release-iphonesimulator/libObjectAl.a build/libObjectAl.a.x86_64
-lipo build/libObjectAL.a.armv7 build/libObjectAL.a.arm64 build/libObjectAL.a.i386 build/libObjectAL.a.x86_64 -create -output build/libObjectAL.a
+lipo build/Release-iphoneos/libObjectAL.a build/Release-iphonesimulator/libObjectAL.a -create -output build/libObjectAL.a
 cp build/libObjectAL.a ../../../../gdx/libs/ios32/
 cd ../..
 rm objectal.tar.gz
-rm -r kstenerud-ObjectAL-for-iPhone-a2252f3/
+rm -r kstenerud-ObjectAL-for-iPhone-71e903e/
diff --git a/backends/gdx-backend-robovm/pom.xml b/backends/gdx-backend-robovm/pom.xml
index a5b059a..63a8bfd 100644
--- a/backends/gdx-backend-robovm/pom.xml
+++ b/backends/gdx-backend-robovm/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.5.4-SNAPSHOT</version>
+    <version>1.4.2-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplication.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplication.java
index cb53078..5495aee 100644
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplication.java
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplication.java
@@ -29,11 +29,9 @@ import org.robovm.apple.uikit.UIApplicationLaunchOptions;
 import org.robovm.apple.uikit.UIDevice;
 import org.robovm.apple.uikit.UIInterfaceOrientation;
 import org.robovm.apple.uikit.UIPasteboard;
-import org.robovm.apple.uikit.UIScreen;
 import org.robovm.apple.uikit.UIUserInterfaceIdiom;
 import org.robovm.apple.uikit.UIViewController;
 import org.robovm.apple.uikit.UIWindow;
-import org.robovm.rt.bro.Bro;
 
 import com.badlogic.gdx.Application;
 import com.badlogic.gdx.ApplicationListener;
@@ -120,8 +118,6 @@ public class IOSApplication implements Application {
 		Gdx.app.debug("IOSApplication", "iOS version: " + UIDevice.getCurrentDevice().getSystemVersion());
 		// fix the scale factor if we have a retina device (NOTE: iOS screen sizes are in "points" not pixels by default!)
 
-		Gdx.app.debug("IOSApplication", "Running in " + (Bro.IS_64BIT ? "64-bit" : "32-bit") + " mode");
-
 		float scale = (float)(getIosVersion() >= 8 ? UIScreen.getMainScreen().getNativeScale() : UIScreen.getMainScreen()
 			.getScale());
 		if (scale >= 2.0f) {
@@ -195,7 +191,7 @@ public class IOSApplication implements Application {
 	 * @return Or real display dimension. */
 	CGSize getBounds (UIViewController viewController) {
 		// or screen size (always portrait)
-		CGSize bounds = UIScreen.getMainScreen().getApplicationFrame().getSize();
+		CGSize bounds = UIScreen.getMainScreen().getApplicationFrame().size();
 
 		// determine orientation and resulting width + height
 		UIInterfaceOrientation orientation;
@@ -216,17 +212,17 @@ public class IOSApplication implements Application {
 		switch (orientation) {
 		case LandscapeLeft:
 		case LandscapeRight:
-			height = (int)bounds.getWidth();
-			width = (int)bounds.getHeight();
+			height = (int)bounds.width();
+			width = (int)bounds.height();
 			if (width < height) {
-				width = (int)bounds.getWidth();
-				height = (int)bounds.getHeight();
+				width = (int)bounds.width();
+				height = (int)bounds.height();
 			}
 			break;
 		default:
 			// assume portrait
-			width = (int)bounds.getWidth();
-			height = (int)bounds.getHeight();
+			width = (int)bounds.width();
+			height = (int)bounds.height();
 		}
 
 		Gdx.app.debug("IOSApplication", "Unscaled View: " + orientation.toString() + " " + width + "x" + height);
@@ -313,14 +309,14 @@ public class IOSApplication implements Application {
 	@Override
 	public void log (String tag, String message) {
 		if (logLevel > LOG_NONE) {
-			Foundation.log("%@", new NSString("[info] " + tag + ": " + message));
+			Foundation.log("[info] " + tag + ": " + message);
 		}
 	}
 
 	@Override
 	public void log (String tag, String message, Throwable exception) {
 		if (logLevel > LOG_NONE) {
-			Foundation.log("%@", new NSString("[info] " + tag + ": " + message));
+			Foundation.log("[info] " + tag + ": " + message);
 			exception.printStackTrace();
 		}
 	}
@@ -328,14 +324,14 @@ public class IOSApplication implements Application {
 	@Override
 	public void error (String tag, String message) {
 		if (logLevel >= LOG_ERROR) {
-			Foundation.log("%@", new NSString("[error] " + tag + ": " + message));
+			Foundation.log("[error] " + tag + ": " + message);
 		}
 	}
 
 	@Override
 	public void error (String tag, String message, Throwable exception) {
 		if (logLevel >= LOG_ERROR) {
-			Foundation.log("%@", new NSString("[error] " + tag + ": " + message));
+			Foundation.log("[error] " + tag + ": " + message);
 			exception.printStackTrace();
 		}
 	}
@@ -343,14 +339,14 @@ public class IOSApplication implements Application {
 	@Override
 	public void debug (String tag, String message) {
 		if (logLevel >= LOG_DEBUG) {
-			Foundation.log("%@", new NSString("[debug] " + tag + ": " + message));
+			Foundation.log("[debug] " + tag + ": " + message);
 		}
 	}
 
 	@Override
 	public void debug (String tag, String message, Throwable exception) {
 		if (logLevel >= LOG_DEBUG) {
-			Foundation.log("%@", new NSString("[error] " + tag + ": " + message));
+			Foundation.log("[error] " + tag + ": " + message);
 			exception.printStackTrace();
 		}
 	}
@@ -435,12 +431,12 @@ public class IOSApplication implements Application {
 		return new Clipboard() {
 			@Override
 			public void setContents (String content) {
-				UIPasteboard.getGeneralPasteboard().setString(content);
+				UIPasteboard.getGeneral().setString(content);
 			}
 
 			@Override
 			public String getContents () {
-				return UIPasteboard.getGeneralPasteboard().getString();
+				return UIPasteboard.getGeneral().getString();
 			}
 		};
 	}
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplicationConfiguration.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplicationConfiguration.java
index fb3a5f7..bfe4fae 100644
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplicationConfiguration.java
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplicationConfiguration.java
@@ -81,15 +81,10 @@ public class IOSApplicationConfiguration {
 	public boolean useAccelerometer = true;
 	/** the update interval to poll the accelerometer with, in seconds **/
 	public float accelerometerUpdate = 0.05f;
-	/** the update interval to poll the magnetometer with, in seconds **/
-	public float magnetometerUpdate = 0.05f;
 
 	/** whether to use the compass, default true **/
 	public boolean useCompass = true;
 
 	/** whether or not to allow background music from iPod **/
 	public boolean allowIpod = false;
-	
-	/** whether or not the onScreenKeyboard should be closed on return key **/
-	public boolean keyboardCloseOnReturn = true;
 }
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSDevice.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSDevice.java
deleted file mode 100644
index a7a8d7d..0000000
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSDevice.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package com.badlogic.gdx.backends.iosrobovm;
-
-public enum IOSDevice {
-	
-	IPHONE_2G("iPhone1,1", 163),
-	IPHONE_3G("iPhone1,2", 163),
-	IPHONE_3GS("iPhone2,1", 163),
-	IPHONE_4("iPhone3,1", 326),
-	IPHONE_4V("iPhone3,2", 326),
-	IPHONE_4_CDMA("iPhone3,3", 326),
-	IPHONE_4S("iPhone4,1", 326),
-	IPHONE_5("iPhone5,1", 326),
-	IPHONE_5_CDMA_GSM("iPhone5,2", 326),
-	IPHONE_5C("iPhone5,3", 326),
-	IPHONE_5C_CDMA_GSM("iPhone5,4", 326),
-	IPHONE_5S("iPhone6,1", 326),
-	IPHONE_5S_CDMA_GSM("iPhone6,2", 326),
-	IPHONE_6_PLUS("iPhone7,1", 326),
-	IPHONE_6("iPhone7,2", 401),
-	
-	IPOD_TOUCH_1G("iPod1,1", 163),
-	IPOD_TOUCH_2G("iPod2,1", 163),
-	IPOD_TOUCH_3G("iPod3,1", 163),
-	IPOD_TOUCH_4G("iPod4,1", 326),
-	IPOD_TOUCH_5G("iPod5,1", 326),
-	
-	IPAD("iPad1,1", 132),
-	IPAD_3G("iPad1,2", 132),
-	IPAD_2_WIFI("iPad2,1", 132),
-	IPAD_2("iPad2,2", 132),
-	IPAD_2_CDMA("iPad2,3", 132),
-	IPAD_2V("iPad2,4", 132),
-	IPAD_MINI_WIFI("iPad2,5", 164),
-	IPAD_MINI("iPad2,6", 164),
-	IPAD_MINI_WIFI_CDMA("iPad2,7", 164),
-	IPAD_3_WIFI("iPad3,1", 264),
-	IPAD_3_WIFI_CDMA("iPad3,2", 264),
-	IPAD_3("iPad3,3", 264),
-	IPAD_4_WIFI("iPad3,4", 264),
-	IPAD_4("iPad3,5", 264),
-	IPAD_4_GSM_CDMA("iPad3,6", 264),
-	IPAD_AIR_WIFI("iPad4,1", 264),
-	IPAD_AIR_WIFI_GSM("iPad4,2", 264),
-	IPAD_AIR_WIFI_CDMA("iPad4,3", 264),
-	IPAD_MINI_RETINA_WIFI("iPad4,4", 326),
-	IPAD_MINI_RETINA_WIFI_CDMA("iPad4,5", 326),
-	IPAD_MINI_RETINA_WIFI_CELLULAR_CN("iPad4,6", 326),
-	IPAD_MINI_3_WIFI("iPad4,7", 326),
-	IPAD_MINI_3_WIFI_CELLULAR("iPad4,8", 326),
-	IPAD_MINI_AIR_2_WIFI("iPad5,3", 264),
-	IPAD_MINI_AIR_2_WIFI_CELLULAR("iPad5,4", 264),
-	SIMULATOR_32("i386", 264),
-	SIMULATOR_64("x86_64", 264);
-	
-	final String machineString;
-	final int ppi;
-	
-	IOSDevice(String machineString, int ppi) {
-		this.machineString = machineString;
-		this.ppi = ppi;
-	}
-	
-	public static IOSDevice getDevice (String machineString) {
-		for (IOSDevice device : values()) {
-			if (device.machineString.equalsIgnoreCase(machineString)) return device;
-		}
-		return null;
-	}
-
-	
-}
\ No newline at end of file
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSFiles.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSFiles.java
index a186003..e038118 100644
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSFiles.java
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSFiles.java
@@ -25,8 +25,8 @@ public class IOSFiles implements Files {
 	// TODO: Use NSSearchPathForDirectoriesInDomains instead?
 	// $HOME should point to the app root dir.
 	static final String appDir = System.getenv("HOME");
-	static final String externalPath = appDir + "/Documents/";
-	static final String localPath = appDir + "/Library/local/";
+	static final String externalPath = appDir + "/Documents";
+	static final String localPath = appDir + "/Library/local";
 	static final String internalPath = NSBundle.getMainBundle().getBundlePath();
 
 	public IOSFiles () {
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSGLES20.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSGLES20.java
index 027529c..56e6691 100644
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSGLES20.java
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSGLES20.java
@@ -16,11 +16,11 @@
 
 package com.badlogic.gdx.backends.iosrobovm;
 
-import java.nio.Buffer;
-import java.nio.FloatBuffer;
-import java.nio.IntBuffer;
-
-import com.badlogic.gdx.graphics.GL20;
+import java.nio.Buffer;
+import java.nio.FloatBuffer;
+import java.nio.IntBuffer;
+
+import com.badlogic.gdx.graphics.GL20;
 
 public class IOSGLES20 implements GL20
 {	
@@ -89,25 +89,17 @@ public class IOSGLES20 implements GL20
 
 	public native void glCullFace ( int mode );
 
-	public native void glDeleteBuffers ( int n, IntBuffer buffers );
-	
-	public native void glDeleteBuffer(int buffer);
+	public native void glDeleteBuffers ( int n, IntBuffer buffers );
 
-	public native void glDeleteFramebuffers ( int n, IntBuffer framebuffers );
-	
-	public native void glDeleteFramebuffer(int framebuffer);
+	public native void glDeleteFramebuffers ( int n, IntBuffer framebuffers );
 
 	public native void glDeleteProgram ( int program );
 
-	public native void glDeleteRenderbuffers ( int n, IntBuffer renderbuffers );
-	
-	public native void glDeleteRenderbuffer(int renderbuffer);
+	public native void glDeleteRenderbuffers ( int n, IntBuffer renderbuffers );
 
 	public native void glDeleteShader ( int shader );
 
-	public native void glDeleteTextures ( int n, IntBuffer textures );
-	
-	public native void glDeleteTexture(int texture);
+	public native void glDeleteTextures ( int n, IntBuffer textures );
 
 	public native void glDepthFunc ( int func );
 
@@ -141,23 +133,15 @@ public class IOSGLES20 implements GL20
 
 	public native void glFrontFace ( int mode );
 
-	public native void glGenBuffers ( int n, IntBuffer buffers );
-	
-	public native int glGenBuffer();
+	public native void glGenBuffers ( int n, IntBuffer buffers );
 
 	public native void glGenerateMipmap ( int target );
 
-	public native void glGenFramebuffers ( int n, IntBuffer framebuffers );
-	
-	public native int glGenFramebuffer();
+	public native void glGenFramebuffers ( int n, IntBuffer framebuffers );
 
-	public native void glGenRenderbuffers ( int n, IntBuffer renderbuffers );
-	
-	public native int glGenRenderbuffer();
-	
-	public native void glGenTextures ( int n, IntBuffer textures );
-	
-	public native int glGenTexture();
+	public native void glGenRenderbuffers ( int n, IntBuffer renderbuffers );
+
+	public native void glGenTextures ( int n, IntBuffer textures );
 
 	public native String glGetActiveAttrib ( int program, int index, IntBuffer size, Buffer type );
 
@@ -276,62 +260,40 @@ public class IOSGLES20 implements GL20
 	public native void glUniform1f ( int location, float x );
 
 	public native void glUniform1fv ( int location, int count, FloatBuffer v );
-
-	public native void glUniform1fv(int location, int count, float[] v, int offset);
-	
+
 	public native void glUniform1i ( int location, int x );
 
-	public native void glUniform1iv ( int location, int count, IntBuffer v );
-	
-	public native void glUniform1iv(int location, int count, int[] v, int offset);
+	public native void glUniform1iv ( int location, int count, IntBuffer v );
 
 	public native void glUniform2f ( int location, float x, float y );
 
-	public native void glUniform2fv ( int location, int count, FloatBuffer v );
-	
-	public native void glUniform2fv(int location, int count, float[] v, int offset);
+	public native void glUniform2fv ( int location, int count, FloatBuffer v );
 
 	public native void glUniform2i ( int location, int x, int y );
 
-	public native void glUniform2iv ( int location, int count, IntBuffer v );
-	
-	public native void glUniform2iv(int location, int count, int[] v, int offset);
+	public native void glUniform2iv ( int location, int count, IntBuffer v );
 
 	public native void glUniform3f ( int location, float x, float y, float z );
 
-	public native void glUniform3fv ( int location, int count, FloatBuffer v );
-	
-	public native void glUniform3fv(int location, int count, float[] v, int offset);
+	public native void glUniform3fv ( int location, int count, FloatBuffer v );
 
 	public native void glUniform3i ( int location, int x, int y, int z );
 
-	public native void glUniform3iv ( int location, int count, IntBuffer v );
-	
-	public native void glUniform3iv(int location, int count, int[] v, int offset);
-	
+	public native void glUniform3iv ( int location, int count, IntBuffer v );
+
 	public native void glUniform4f ( int location, float x, float y, float z, float w );
 
-	public native void glUniform4fv ( int location, int count, FloatBuffer v );
-	
-	public native void glUniform4fv(int location, int count, float[] v, int offset);
+	public native void glUniform4fv ( int location, int count, FloatBuffer v );
 
 	public native void glUniform4i ( int location, int x, int y, int z, int w );
 
-	public native void glUniform4iv ( int location, int count, IntBuffer v );
-	
-	public native void glUniform4iv(int location, int count, int[] v, int offset);
+	public native void glUniform4iv ( int location, int count, IntBuffer v );
 
-	public native void glUniformMatrix2fv ( int location, int count, boolean transpose, FloatBuffer value );
-	
-	public native void glUniformMatrix2fv(int location, int count, boolean transpose, float[] value, int offset);
+	public native void glUniformMatrix2fv ( int location, int count, boolean transpose, FloatBuffer value );
 
-	public native void glUniformMatrix3fv ( int location, int count, boolean transpose, FloatBuffer value );
-	
-	public native void glUniformMatrix3fv(int location, int count, boolean transpose, float[] value, int offset);
+	public native void glUniformMatrix3fv ( int location, int count, boolean transpose, FloatBuffer value );
 
-	public native void glUniformMatrix4fv ( int location, int count, boolean transpose, FloatBuffer value );
-	
-	public native void glUniformMatrix4fv(int location, int count, boolean transpose, float[] value, int offset);
+	public native void glUniformMatrix4fv ( int location, int count, boolean transpose, FloatBuffer value );
 
 	public native void glUseProgram ( int program );
 
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSGraphics.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSGraphics.java
index 422e6a0..ec55702 100644
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSGraphics.java
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSGraphics.java
@@ -30,9 +30,11 @@ import org.robovm.apple.glkit.GLKViewDrawableMultisample;
 import org.robovm.apple.glkit.GLKViewDrawableStencilFormat;
 import org.robovm.apple.opengles.EAGLContext;
 import org.robovm.apple.opengles.EAGLRenderingAPI;
+import org.robovm.apple.uikit.UIDevice;
 import org.robovm.apple.uikit.UIEvent;
 import org.robovm.apple.uikit.UIInterfaceOrientation;
 import org.robovm.apple.uikit.UIInterfaceOrientationMask;
+import org.robovm.apple.uikit.UIUserInterfaceIdiom;
 import org.robovm.objc.Selector;
 import org.robovm.objc.annotation.BindSelector;
 import org.robovm.objc.annotation.Method;
@@ -42,7 +44,6 @@ import org.robovm.rt.bro.annotation.Pointer;
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.Graphics;
 import com.badlogic.gdx.LifecycleListener;
-import com.badlogic.gdx.backends.iosrobovm.custom.HWMachine;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.GL30;
 import com.badlogic.gdx.utils.Array;
@@ -83,8 +84,8 @@ public class IOSGraphics extends NSObject implements Graphics, GLKViewDelegate,
 			// FIXME screen orientation needs to be stored for
 			// Input#getNativeOrientation
 			CGSize bounds = app.getBounds(this);
-			graphics.width = (int)bounds.getWidth();
-			graphics.height = (int)bounds.getHeight();
+			graphics.width = (int)bounds.width();
+			graphics.height = (int)bounds.height();
 			graphics.makeCurrent();
 			app.listener.resize(graphics.width, graphics.height);
 		}
@@ -132,7 +133,7 @@ public class IOSGraphics extends NSObject implements Graphics, GLKViewDelegate,
 			super(frame, context);
 		}
 	}
-	
+
 	IOSApplication app;
 	IOSInput input;
 	GL20 gl20;
@@ -166,9 +167,9 @@ public class IOSGraphics extends NSObject implements Graphics, GLKViewDelegate,
 		GL20 gl20) {
 		this.config = config;
 		// setup view and OpenGL
-		width = (int)bounds.getWidth();
-		height = (int)bounds.getHeight();
-		app.debug(tag, bounds.getWidth() + "x" + bounds.getHeight() + ", " + scale);
+		width = (int)bounds.width();
+		height = (int)bounds.height();
+		app.debug(tag, bounds.width() + "x" + bounds.height() + ", " + scale);
 		this.gl20 = gl20;
 
 		context = new EAGLContext(EAGLRenderingAPI.OpenGLES2);
@@ -240,11 +241,21 @@ public class IOSGraphics extends NSObject implements Graphics, GLKViewDelegate,
 		bufferFormat = new BufferFormat(r, g, b, a, depth, stencil, samples, false);
 		this.gl20 = gl20;
 
-		String machineString = HWMachine.getMachineString();
-		IOSDevice device = IOSDevice.getDevice(machineString);
-		if (device == null) app.error(tag, "Machine ID: " + machineString + " not found, please report to LibGDX");
-		int ppi = device != null ? device.ppi : 163;
-		density = device != null ? device.ppi/160f : scale;
+		// determine display density and PPI (PPI values via Wikipedia!)
+		density = 1f;
+
+		app.debug(tag, "Calculating density, UIScreen.mainScreen.scale: " + scale);
+		if (scale == 2) density = 2f;
+		if (scale == 3) density = 3f;
+
+		int ppi;
+		if (UIDevice.getCurrentDevice().getUserInterfaceIdiom() == UIUserInterfaceIdiom.Pad) {
+			// iPad
+			ppi = Math.round(density * 132);
+		} else {
+			// iPhone or iPodTouch
+			ppi = Math.round(density * 163);
+		}
 		ppiX = ppi;
 		ppiY = ppi;
 		ppcX = ppiX / 2.54f;
@@ -394,6 +405,9 @@ public class IOSGraphics extends NSObject implements Graphics, GLKViewDelegate,
 		return ppcY;
 	}
 
+	/** Returns the display density.
+	 * 
+	 * @return 1.0f for non-retina devices, 2.0f for retina devices. */
 	@Override
 	public float getDensity () {
 		return density;
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSInput.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSInput.java
index 31ccd08..ea77fdb 100644
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSInput.java
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSInput.java
@@ -22,6 +22,10 @@ import org.robovm.apple.coregraphics.CGRect;
 import org.robovm.apple.foundation.NSExtensions;
 import org.robovm.apple.foundation.NSObject;
 import org.robovm.apple.foundation.NSRange;
+import org.robovm.apple.uikit.UIAcceleration;
+import org.robovm.apple.uikit.UIAccelerometer;
+import org.robovm.apple.uikit.UIAccelerometerDelegate;
+import org.robovm.apple.uikit.UIAccelerometerDelegateAdapter;
 import org.robovm.apple.uikit.UIAlertView;
 import org.robovm.apple.uikit.UIAlertViewDelegate;
 import org.robovm.apple.uikit.UIAlertViewDelegateAdapter;
@@ -49,12 +53,7 @@ import org.robovm.rt.bro.annotation.Pointer;
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.Input;
 import com.badlogic.gdx.InputProcessor;
-import com.badlogic.gdx.backends.iosrobovm.custom.UIAcceleration;
-import com.badlogic.gdx.backends.iosrobovm.custom.UIAccelerometer;
-import com.badlogic.gdx.backends.iosrobovm.custom.UIAccelerometerDelegate;
-import com.badlogic.gdx.backends.iosrobovm.custom.UIAccelerometerDelegateAdapter;
 import com.badlogic.gdx.graphics.Pixmap;
-import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 import com.badlogic.gdx.utils.Pool;
@@ -85,8 +84,9 @@ public class IOSInput implements Input {
 	}
 
 	private static final NSObjectWrapper<UITouch> UI_TOUCH_WRAPPER = new NSObjectWrapper<UITouch>(UITouch.class);
-	private static final NSObjectWrapper<UIAcceleration> UI_ACCELERATION_WRAPPER = new NSObjectWrapper<UIAcceleration>(UIAcceleration.class);
-	
+	static final NSObjectWrapper<UIAcceleration> UI_ACCELERATION_WRAPPER = new NSObjectWrapper<UIAcceleration>(
+		UIAcceleration.class);
+
 	IOSApplication app;
 	IOSApplicationConfiguration config;
 	int[] deltaX = new int[MAX_TOUCHES];
@@ -106,24 +106,18 @@ public class IOSInput implements Input {
 	Array<TouchEvent> touchEvents = new Array<TouchEvent>();
 	TouchEvent currentEvent = null;
 	float[] acceleration = new float[3];
-	float[] rotation = new float[3];
-	float[] R = new float[9];
 	InputProcessor inputProcessor = null;
-
-	boolean hasVibrator;
-	//CMMotionManager motionManager;
+	// We need to hold on to the reference to this delegate or else its
+	// ObjC peer will get released when the Java peer is GCed.
 	UIAccelerometerDelegate accelerometerDelegate;
-	boolean compassSupported;
-	boolean keyboardCloseOnReturn;
+	boolean hasVibrator;
 
 	public IOSInput (IOSApplication app) {
 		this.app = app;
 		this.config = app.config;
-		this.keyboardCloseOnReturn = app.config.keyboardCloseOnReturn;
 	}
 
 	void setupPeripherals () {
-		//motionManager = new CMMotionManager();
 		setupAccelerometer();
 		setupCompass();
 		UIDevice device = UIDevice.getCurrentDevice();
@@ -132,10 +126,10 @@ public class IOSInput implements Input {
 
 	private void setupCompass () {
 		if (config.useCompass) {
-			//setupMagnetometer();
+			// FIXME implement compass
 		}
 	}
-	
+
 	private void setupAccelerometer () {
 		if (config.useAccelerometer) {
 			accelerometerDelegate = new UIAccelerometerDelegateAdapter() {
@@ -157,82 +151,6 @@ public class IOSInput implements Input {
 		}
 	}
 
-	// need to retain a reference so GC doesn't get right of the
-	// object passed to the native thread
-//	VoidBlock2<CMAccelerometerData, NSError> accelVoid = null;	
-//	private void setupAccelerometer () {
-//		if (config.useAccelerometer) {
-//			motionManager.setAccelerometerUpdateInterval(config.accelerometerUpdate);			
-//			accelVoid = new VoidBlock2<CMAccelerometerData, NSError>() {
-//				@Override
-//				public void invoke(CMAccelerometerData accelData, NSError error) {
-//					updateAccelerometer(accelData);					
-//				}
-//			};
-//			motionManager.startAccelerometerUpdates(new NSOperationQueue(), accelVoid);
-//		}
-//	}
-	
-	// need to retain a reference so GC doesn't get right of the
-	// object passed to the native thread
-//	VoidBlock2<CMMagnetometerData, NSError> magnetVoid = null;
-//	private void setupMagnetometer () {
-//		if (motionManager.isMagnetometerAvailable() && config.useCompass) compassSupported = true;
-//		else return;
-//		motionManager.setMagnetometerUpdateInterval(config.magnetometerUpdate);
-//		magnetVoid = new VoidBlock2<CMMagnetometerData, NSError>() {
-//			@Override
-//			public void invoke(CMMagnetometerData magnetData, NSError error) {
-//				updateRotation(magnetData);
-//			}
-//		};
-//		motionManager.startMagnetometerUpdates(new NSOperationQueue(), magnetVoid);
-//	}
-	
-//	private void updateAccelerometer (CMAccelerometerData data) {
-//		float x = (float) data.getAcceleration().x() * 10f;
-//		float y = (float) data.getAcceleration().y() * 10f;
-//		float z = (float) data.getAcceleration().z() * 10f;
-//		acceleration[0] = -x;
-//		acceleration[1] = -y;
-//		acceleration[2] = -z;
-//	}
-//	
-//	private void updateRotation (CMMagnetometerData data) {
-//		final float eX = (float) data.getMagneticField().x();
-//		final float eY = (float) data.getMagneticField().y();
-//		final float eZ = (float) data.getMagneticField().z();
-//				
-//		float gX = acceleration[0];
-//		float gY = acceleration[1];
-//		float gZ = acceleration[2];
-//		
-//		float cX = eY * gZ - eZ * gY;
-//		float cY = eZ * gX - eX * gZ;
-//		float cZ = eX * gY - eY * gX;
-//		
-//		final float normal = (float) Math.sqrt(cX * cX + cY * cY + cZ * cZ);
-//		final float invertC = 1.0f / normal;
-//		cX *= invertC;
-//		cY *= invertC;
-//		cZ *= invertC;
-//		final float invertG = 1.0f / (float) Math.sqrt(gX * gX + gY * gY + gZ * gZ);
-//		gX *= invertG;
-//		gY *= invertG;
-//		gZ *= invertG;
-//		final float mX = gY * cZ - gZ * cY;
-//		final float mY = gZ * cX - gX * cZ;
-//		final float mZ = gX * cY - gY * cX;
-//		
-//		R[0] = cX;	R[1] = cY;	R[2] = cZ;
-//		R[3] = mX;	R[4] = mY;	R[5] = mZ;
-//		R[6] = gX;	R[7] = gY;	R[8] = gZ;
-//		
-//		rotation[0] = (float) Math.atan2(R[1], R[4]) * MathUtils.radDeg;
-//		rotation[1] = (float) Math.asin(-R[7]) * MathUtils.radDeg;
-//		rotation[2] = (float) Math.atan2(-R[6], R[8]) * MathUtils.radDeg;
-//	}
-
 	@Override
 	public float getAccelerometerX () {
 		return acceleration[0];
@@ -250,26 +168,25 @@ public class IOSInput implements Input {
 
 	@Override
 	public float getAzimuth () {
-		if (!compassSupported) return 0;
-		return rotation[0];
+		// FIXME implement this
+		return 0;
 	}
 
 	@Override
 	public float getPitch () {
-		if (!compassSupported) return 0;
-		return rotation[1];
+		// FIXME implement this
+		return 0;
 	}
 
 	@Override
 	public float getRoll () {
-		if (!compassSupported) return 0;
-		return rotation[2];
+		// FIXME implement this
+		return 0;
 	}
 
 	@Override
 	public void getRotationMatrix (float[] matrix) {
-		if (matrix.length != 9) return;
-		//TODO implement when azimuth is fixed
+		// FIXME implement this
 	}
 
 	@Override
@@ -348,9 +265,10 @@ public class IOSInput implements Input {
 	}
 
 	@Override
-	public void getTextInput(TextInputListener listener, String title, String text, String hint) {
-		buildUIAlertView(listener, title, text, hint).show();
-	}	
+	public void getTextInput (TextInputListener listener, String title, String text) {
+		final UIAlertView uiAlertView = buildUIAlertView(listener, title, text, null);
+		uiAlertView.show();
+	}
 
 	// hack for software keyboard support
 	// uses a hidden textfield to capture input
@@ -380,12 +298,12 @@ public class IOSInput implements Input {
 	private final UITextFieldDelegate textDelegate = new UITextFieldDelegateAdapter() {
 		@Override
 		public boolean shouldChangeCharacters (UITextField textField, NSRange range, String string) {
-			for (int i = 0; i < range.getLength(); i++) {
+			for (int i = 0; i < range.length(); i++) {
 				app.input.inputProcessor.keyTyped((char)8);
 			}
 
 			if (string.isEmpty()) {
-				if (range.getLength() > 0) Gdx.graphics.requestRendering();
+				if (range.length() > 0) Gdx.graphics.requestRendering();
 				return false;
 			}
 
@@ -411,9 +329,7 @@ public class IOSInput implements Input {
 
 		@Override
 		public boolean shouldReturn (UITextField textField) {
-			if (keyboardCloseOnReturn) setOnscreenKeyboardVisible(false);
-			app.input.inputProcessor.keyDown(Keys.ENTER);
-			app.input.inputProcessor.keyTyped((char)13);
+			textField.resignFirstResponder();
 			Gdx.graphics.requestRendering();
 			return false;
 		}
@@ -421,7 +337,20 @@ public class IOSInput implements Input {
 
 	@Override
 	public void setOnscreenKeyboardVisible (boolean visible) {
-		if (textfield == null) createDefaultTextField();
+		if (textfield == null) {
+			// Making simple textField
+			textfield = new UITextField(new CGRect(10, 10, 100, 50));
+			// Setting parameters
+			textfield.setKeyboardType(UIKeyboardType.Default);
+			textfield.setReturnKeyType(UIReturnKeyType.Done);
+			textfield.setAutocapitalizationType(UITextAutocapitalizationType.None);
+			textfield.setAutocorrectionType(UITextAutocorrectionType.No);
+			textfield.setSpellCheckingType(UITextSpellCheckingType.No);
+			textfield.setHidden(true);
+			// Text field needs to have at least one symbol - so we can use backspace
+			textfield.setText("x");
+			app.getUIViewController().getView().addSubview(textfield);
+		}
 		if (visible) {
 			textfield.becomeFirstResponder();
 			textfield.setDelegate(textDelegate);
@@ -429,35 +358,7 @@ public class IOSInput implements Input {
 			textfield.resignFirstResponder();
 		}
 	}
-	
-	/**
-	 * Set the keyboard to close when the UITextField return key is pressed
-	 * @param shouldClose Whether or not the keyboard should clsoe on return key press
-	 */
-	public void setKeyboardCloseOnReturnKey (boolean shouldClose) {
-		keyboardCloseOnReturn = shouldClose;
-	}
-	
-	public UITextField getKeyboardTextField () {
-		if (textfield == null) createDefaultTextField();
-		return textfield;
-	}
-	
-	private void createDefaultTextField () {
-		textfield = new UITextField(new CGRect(10, 10, 100, 50));
-		//Parameters
-		// Setting parameters
-		textfield.setKeyboardType(UIKeyboardType.Default);
-		textfield.setReturnKeyType(UIReturnKeyType.Done);
-		textfield.setAutocapitalizationType(UITextAutocapitalizationType.None);
-		textfield.setAutocorrectionType(UITextAutocorrectionType.No);
-		textfield.setSpellCheckingType(UITextSpellCheckingType.No);
-		textfield.setHidden(true);
-		// Text field needs to have at least one symbol - so we can use backspace
-		textfield.setText("x");
-		app.getUIViewController().getView().addSubview(textfield);
-	}
-	
+
 	// Issue 773 indicates this may solve a premature GC issue
 	UIAlertViewDelegate delegate;
 
@@ -504,6 +405,12 @@ public class IOSInput implements Input {
 	}
 
 	@Override
+	public void getPlaceholderTextInput (TextInputListener listener, String title, String placeholder) {
+		final UIAlertView uiAlertView = buildUIAlertView(listener, title, null, placeholder);
+		uiAlertView.show();
+	}
+
+	@Override
 	public void vibrate (int milliseconds) {
 		AudioServices.playSystemSound(4095);
 	}
@@ -551,8 +458,11 @@ public class IOSInput implements Input {
 		if (peripheral == Peripheral.Accelerometer && config.useAccelerometer) return true;
 		if (peripheral == Peripheral.MultitouchScreen) return true;
 		if (peripheral == Peripheral.Vibrator) return hasVibrator;
-		if (peripheral == Peripheral.Compass) return compassSupported;
+		// FIXME implement this (not sure if possible)
 		// if(peripheral == Peripheral.OnscreenKeyboard) return true;
+		// FIXME implement this
+		// if(peripheral == Peripheral.Compass) return true;
+
 		return false;
 	}
 
@@ -668,15 +578,15 @@ public class IOSInput implements Input {
 			synchronized (touchEvents) {
 				UITouchPhase phase = touch.getPhase();
 				TouchEvent event = touchEventPool.obtain();
-				event.x = (int)(loc.getX() * app.displayScaleFactor);
-				event.y = (int)(loc.getY() * app.displayScaleFactor);
+				event.x = (int)(loc.x() * app.displayScaleFactor);
+				event.y = (int)(loc.y() * app.displayScaleFactor);
 				event.phase = phase;
 				event.timestamp = (long)(touch.getTimestamp() * 1000000000);
 				touchEvents.add(event);
 
 				if (phase == UITouchPhase.Began) {
 					event.pointer = getFreePointer();
-					touchDown[event.pointer] = touch.getHandle();
+					touchDown[event.pointer] = (int)touch.getHandle();
 					touchX[event.pointer] = event.x;
 					touchY[event.pointer] = event.y;
 					deltaX[event.pointer] = 0;
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSSound.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSSound.java
index 539b269..1beb039 100644
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSSound.java
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSSound.java
@@ -16,34 +16,24 @@
 
 package com.badlogic.gdx.backends.iosrobovm;
 
-import org.robovm.apple.foundation.NSArray;
-
 import com.badlogic.gdx.audio.Sound;
 import com.badlogic.gdx.backends.iosrobovm.objectal.ALBuffer;
-import com.badlogic.gdx.backends.iosrobovm.objectal.ALChannelSource;
 import com.badlogic.gdx.backends.iosrobovm.objectal.ALSource;
 import com.badlogic.gdx.backends.iosrobovm.objectal.OALSimpleAudio;
 import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.utils.IntArray;
 
 /** @author tescott
- *  @author Tomski
  * 
  *         First pass at implementing OALSimpleAudio support. */
 public class IOSSound implements Sound {
 
+	private ALSource soundSource;
 	private ALBuffer soundBuffer;
 	private String soundPath;
-	
-	private ALChannelSource channel;
-	private NSArray<ALSource> sourcePool;
-	private IntArray streamIds = new IntArray(8);
-	
+
 	public IOSSound (FileHandle filePath) {
 		soundPath = filePath.file().getPath().replace('\\', '/');
 		soundBuffer = OALSimpleAudio.sharedInstance().preloadEffect(soundPath);
-		channel = OALSimpleAudio.sharedInstance().getChannelSource();
-		sourcePool = channel.getSourcePool().getSources();
 	}
 
 	@Override
@@ -62,12 +52,8 @@ public class IOSSound implements Sound {
 	}
 
 	public long play (float volume, float pitch, float pan, boolean loop) {
-		if (streamIds.size == 8) streamIds.pop();
-		ALSource soundSource = OALSimpleAudio.sharedInstance().playEffect(soundPath, volume, pitch, pan, loop);
-		if (soundSource == null) return -1;
-		if (soundSource.getSourceId() == -1) return -1;
-		streamIds.insert(0, soundSource.getSourceId());
-		return soundSource.getSourceId();
+		soundSource = OALSimpleAudio.sharedInstance().playEffect(soundPath, volume, pitch, pan, loop);
+		return 0;
 	}
 
 	@Override
@@ -87,10 +73,7 @@ public class IOSSound implements Sound {
 
 	@Override
 	public void stop () {
-		ALSource source;
-		for (int i = 0; i < streamIds.size; i++) {
-			if ((source = getSoundSource(streamIds.get(i))) != null) source.stop();
-		}
+		if (soundSource != null) soundSource.stop();
 	}
 
 	@Override
@@ -100,74 +83,58 @@ public class IOSSound implements Sound {
 
 	@Override
 	public void stop (long soundId) {
-		ALSource source;
-		if ((source = getSoundSource(soundId)) != null) source.stop();
+		// we should do something to give an id for each sound.
+		stop();
 	}
 
 	@Override
 	public void setLooping (long soundId, boolean looping) {
-		ALSource source;
-		if ((source = getSoundSource(soundId)) != null) source.setLooping(looping);
+		// TODO Auto-generated method stub
 	}
 
 	@Override
 	public void setPitch (long soundId, float pitch) {
-		ALSource source;
-		if ((source = getSoundSource(soundId)) != null) source.setPitch(pitch);
+		// TODO Auto-generated method stub
+
 	}
 
 	@Override
 	public void setVolume (long soundId, float volume) {
-		ALSource source;
-		if ((source = getSoundSource(soundId)) != null) source.setVolume(volume);
+		// TODO Auto-generated method stub
+
 	}
 
 	@Override
 	public void setPan (long soundId, float pan, float volume) {
-		ALSource source;
-		if ((source = getSoundSource(soundId)) != null) {
-			source.setPan(pan);
-			source.setVolume(volume);
-		}
+		// TODO Auto-generated method stub
+
 	}
 
 	@Override
 	public void setPriority (long soundId, int priority) {
 		// TODO Auto-generated method stub
+
 	}
 
 	@Override
 	public void pause () {
-		ALSource source;
-		for (int i = 0; i < streamIds.size; i++) {
-			if ((source = getSoundSource(streamIds.get(i))) != null) source.setPaused(true);
-		}
+		if (soundSource != null) soundSource.setPaused(true);
 	}
 
 	@Override
 	public void resume () {
-		ALSource source;
-		for (int i = 0; i < streamIds.size; i++) {
-			if ((source = getSoundSource(streamIds.get(i))) != null) source.setPaused(false);
-		}
+		if (soundSource != null) soundSource.setPaused(false);
 	}
 
 	@Override
 	public void pause (long soundId) {
-		ALSource source;
-		if ((source = getSoundSource(soundId)) != null) source.setPaused(true);
+		// we should do something to give an id for each sound.
+		pause();
 	}
 
 	@Override
 	public void resume (long soundId) {
-		ALSource source;
-		if ((source = getSoundSource(soundId)) != null) source.setPaused(false);
-	}
-	
-	private ALSource getSoundSource (long soundId) {	
-		for (ALSource source : sourcePool) {
-			if (source.getSourceId() == soundId) return source;			
-		}
-		return null;
+		// we should do something to give an id for each sound.
+		resume();
 	}
 }
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/UIScreen.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/UIScreen.java
new file mode 100644
index 0000000..8ba5886
--- /dev/null
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/UIScreen.java
@@ -0,0 +1,216 @@
+/*
+ * Copyright (C) 2014 Trillian Mobile AB
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.badlogic.gdx.backends.iosrobovm;
+
+/*<imports>*/
+import java.io.*;
+import java.nio.*;
+import java.util.*;
+
+import org.robovm.objc.*;
+import org.robovm.objc.annotation.*;
+import org.robovm.objc.block.*;
+import org.robovm.rt.*;
+import org.robovm.rt.bro.*;
+import org.robovm.rt.bro.annotation.*;
+import org.robovm.rt.bro.ptr.*;
+import org.robovm.apple.foundation.*;
+import org.robovm.apple.uikit.UIScreenMode;
+import org.robovm.apple.uikit.UIScreenOverscanCompensation;
+import org.robovm.apple.uikit.UIView;
+import org.robovm.apple.coreanimation.*;
+import org.robovm.apple.coregraphics.*;
+import org.robovm.apple.coredata.*;
+import org.robovm.apple.coreimage.*;
+import org.robovm.apple.coretext.*;
+/*</imports>*/
+
+/*<javadoc>*/
+/**
+ * @since Available in iOS 2.0 and later.
+ */
+/*</javadoc>*/
+/*<annotations>*/@Library("UIKit") @NativeClass/*</annotations>*/
+/*<visibility>*/public/*</visibility>*/ class /*<name>*/UIScreen/*</name>*/ 
+    extends /*<extends>*/NSObject/*</extends>*/ 
+    /*<implements>*//*</implements>*/ {
+
+    public static class Notifications {
+        /**
+         * @since Available in iOS 3.2 and later.
+         */
+        public static NSObject observeDidConnect(final VoidBlock1<UIScreen> block) {
+            return NSNotificationCenter.getDefaultCenter().addObserver(DidConnectNotification(), null, NSOperationQueue.getMainQueue(), new VoidBlock1<NSNotification>() {
+                @Override
+                public void invoke(NSNotification a) {
+                    block.invoke((UIScreen) a.getObject());
+                }
+            });
+        }
+        /**
+         * @since Available in iOS 3.2 and later.
+         */
+        public static NSObject observeDidDisconnect(final VoidBlock1<UIScreen> block) {
+            return NSNotificationCenter.getDefaultCenter().addObserver(DidDisconnectNotification(), null, NSOperationQueue.getMainQueue(), new VoidBlock1<NSNotification>() {
+                @Override
+                public void invoke(NSNotification a) {
+                    block.invoke((UIScreen) a.getObject());
+                }
+            });
+        }
+        /**
+         * @since Available in iOS 3.2 and later.
+         */
+        public static NSObject observeModeDidChange(final VoidBlock1<UIScreen> block) {
+            return NSNotificationCenter.getDefaultCenter().addObserver(ModeDidChangeNotification(), null, NSOperationQueue.getMainQueue(), new VoidBlock1<NSNotification>() {
+                @Override
+                public void invoke(NSNotification a) {
+                    block.invoke((UIScreen) a.getObject());
+                }
+            });
+        }
+        /**
+         * @since Available in iOS 5.0 and later.
+         */
+        public static NSObject observeBrightnessDidChange(final VoidBlock1<UIScreen> block) {
+            return NSNotificationCenter.getDefaultCenter().addObserver(BrightnessDidChangeNotification(), null, NSOperationQueue.getMainQueue(), new VoidBlock1<NSNotification>() {
+                @Override
+                public void invoke(NSNotification a) {
+                    block.invoke((UIScreen) a.getObject());
+                }
+            });
+        }
+    }
+    /*<ptr>*/public static class UIScreenPtr extends Ptr<UIScreen, UIScreenPtr> {}/*</ptr>*/
+    /*<bind>*/static { ObjCRuntime.bind(UIScreen.class); }/*</bind>*/
+    /*<constants>*//*</constants>*/
+    /*<constructors>*/
+    public UIScreen() {}
+    protected UIScreen(SkipInit skipInit) { super(skipInit); }
+    /*</constructors>*/
+    /*<properties>*/
+    @Property(selector = "bounds")
+    public native @ByVal CGRect getBounds();
+    @Property(selector = "applicationFrame")
+    public native @ByVal CGRect getApplicationFrame();
+    /**
+     * @since Available in iOS 4.0 and later.
+     */
+    @Property(selector = "scale")
+    public native @MachineSizedFloat double getScale();
+    /**
+     * @since Available in iOS 4.0 and later.
+     */
+    @Property(selector = "nativeScale")
+    public native @MachineSizedFloat double getNativeScale();
+    /**
+     * @since Available in iOS 3.2 and later.
+     */
+    @Property(selector = "availableModes")
+    public native NSArray<UIScreenMode> getAvailableModes();
+    /**
+     * @since Available in iOS 4.3 and later.
+     */
+    @Property(selector = "preferredMode")
+    public native UIScreenMode getPreferredMode();
+    /**
+     * @since Available in iOS 3.2 and later.
+     */
+    @Property(selector = "currentMode")
+    public native UIScreenMode getCurrentMode();
+    /**
+     * @since Available in iOS 3.2 and later.
+     */
+    @Property(selector = "setCurrentMode:")
+    public native void setCurrentMode(UIScreenMode v);
+    /**
+     * @since Available in iOS 5.0 and later.
+     */
+    @Property(selector = "overscanCompensation")
+    public native UIScreenOverscanCompensation getOverscanCompensation();
+    /**
+     * @since Available in iOS 5.0 and later.
+     */
+    @Property(selector = "setOverscanCompensation:")
+    public native void setOverscanCompensation(UIScreenOverscanCompensation v);
+    /**
+     * @since Available in iOS 4.3 and later.
+     */
+    @Property(selector = "mirroredScreen")
+    public native UIScreen getMirroredScreen();
+    /**
+     * @since Available in iOS 5.0 and later.
+     */
+    @Property(selector = "brightness")
+    public native @MachineSizedFloat double getBrightness();
+    /**
+     * @since Available in iOS 5.0 and later.
+     */
+    @Property(selector = "setBrightness:")
+    public native void setBrightness(@MachineSizedFloat double v);
+    /**
+     * @since Available in iOS 5.0 and later.
+     */
+    @Property(selector = "wantsSoftwareDimming")
+    public native boolean isWantsSoftwareDimming();
+    /**
+     * @since Available in iOS 5.0 and later.
+     */
+    @Property(selector = "setWantsSoftwareDimming:")
+    public native void setWantsSoftwareDimming(boolean v);
+    /*</properties>*/
+    /*<members>*//*</members>*/
+    /*<methods>*/
+    /**
+     * @since Available in iOS 3.2 and later.
+     */
+    @GlobalValue(symbol="UIScreenDidConnectNotification", optional=true)
+    public static native NSString DidConnectNotification();
+    /**
+     * @since Available in iOS 3.2 and later.
+     */
+    @GlobalValue(symbol="UIScreenDidDisconnectNotification", optional=true)
+    public static native NSString DidDisconnectNotification();
+    /**
+     * @since Available in iOS 3.2 and later.
+     */
+    @GlobalValue(symbol="UIScreenModeDidChangeNotification", optional=true)
+    public static native NSString ModeDidChangeNotification();
+    /**
+     * @since Available in iOS 5.0 and later.
+     */
+    @GlobalValue(symbol="UIScreenBrightnessDidChangeNotification", optional=true)
+    public static native NSString BrightnessDidChangeNotification();
+    
+    /**
+     * @since Available in iOS 4.0 and later.
+     */
+    @Method(selector = "displayLinkWithTarget:selector:")
+    public native CADisplayLink createDisplayLink(NSObject target, Selector sel);
+    /**
+     * @since Available in iOS 3.2 and later.
+     */
+    @Method(selector = "screens")
+    public static native NSArray<UIScreen> getScreens();
+    @Method(selector = "mainScreen")
+    public static native UIScreen getMainScreen();
+    /**
+     * @since Available in iOS 7.0 and later.
+     */
+    @Method(selector = "snapshotViewAfterScreenUpdates:")
+    public native UIView snapshotView(boolean afterUpdates);
+    /*</methods>*/
+}
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/HWMachine.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/HWMachine.java
deleted file mode 100644
index 94aac7f..0000000
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/HWMachine.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.backends.iosrobovm.custom;
-
-import org.robovm.rt.bro.Bro;
-import org.robovm.rt.bro.Struct;
-import org.robovm.rt.bro.annotation.Bridge;
-import org.robovm.rt.bro.annotation.Library;
-import org.robovm.rt.bro.annotation.MachineSizedSInt;
-import org.robovm.rt.bro.ptr.BytePtr;
-import org.robovm.rt.bro.ptr.MachineSizedUIntPtr;
-import org.robovm.rt.bro.ptr.VoidPtr;
-
-@Library("c")
-public class HWMachine {
-	static {
-		Bro.bind();
-	}
-
-	@Bridge
-	public static native int sysctlbyname (BytePtr name, VoidPtr oldp,
-			MachineSizedUIntPtr oldlenp, VoidPtr newp,
-			@MachineSizedSInt long newlen);
-	
-	public static String getMachineString () {
-		BytePtr name = BytePtr.toBytePtrAsciiZ("hw.machine");
-		MachineSizedUIntPtr size = new MachineSizedUIntPtr();
-		sysctlbyname(name, null, size, null, 0);
-		BytePtr machine = Struct.allocate(BytePtr.class, (int) size.get());
-		sysctlbyname(name, machine.as(VoidPtr.class), size, null, 0);
-		return machine.toStringAsciiZ();
-	}
-
-}
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAcceleration.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAcceleration.java
deleted file mode 100644
index 101b337..0000000
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAcceleration.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (C) 2014 Trillian Mobile AB
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.badlogic.gdx.backends.iosrobovm.custom;
-
-/*<imports>*/
-import java.io.*;
-import java.nio.*;
-import java.util.*;
-import org.robovm.objc.*;
-import org.robovm.objc.annotation.*;
-import org.robovm.objc.block.*;
-import org.robovm.rt.*;
-import org.robovm.rt.bro.*;
-import org.robovm.rt.bro.annotation.*;
-import org.robovm.rt.bro.ptr.*;
-import org.robovm.apple.foundation.*;
-import org.robovm.apple.coreanimation.*;
-import org.robovm.apple.coregraphics.*;
-import org.robovm.apple.coredata.*;
-import org.robovm.apple.coreimage.*;
-import org.robovm.apple.coretext.*;
-import org.robovm.apple.corelocation.*;
-/*</imports>*/
-
-/*<javadoc>*/
-/**
- * @since Available in iOS 2.0 and later.
- * @deprecated Deprecated in iOS 5.0.
- */
-@Deprecated
-/*</javadoc>*/
-/*<annotations>*/@Library("UIKit") @NativeClass/*</annotations>*/
-/*<visibility>*/public/*</visibility>*/ class /*<name>*/UIAcceleration/*</name>*/ 
-    extends /*<extends>*/NSObject/*</extends>*/ 
-    /*<implements>*//*</implements>*/ {
-
-    /*<ptr>*/public static class UIAccelerationPtr extends Ptr<UIAcceleration, UIAccelerationPtr> {}/*</ptr>*/
-    /*<bind>*/static { ObjCRuntime.bind(UIAcceleration.class); }/*</bind>*/
-    /*<constants>*//*</constants>*/
-    /*<constructors>*/
-    public UIAcceleration() {}
-    protected UIAcceleration(SkipInit skipInit) { super(skipInit); }
-    /*</constructors>*/
-    /*<properties>*/
-    @Property(selector = "timestamp")
-    public native double getTimestamp();
-    @Property(selector = "x")
-    public native double getX();
-    @Property(selector = "y")
-    public native double getY();
-    @Property(selector = "z")
-    public native double getZ();
-    /*</properties>*/
-    /*<members>*//*</members>*/
-    /*<methods>*/
-    
-    /*</methods>*/
-}
\ No newline at end of file
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAccelerometer.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAccelerometer.java
deleted file mode 100644
index a848f21..0000000
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAccelerometer.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (C) 2014 Trillian Mobile AB
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.badlogic.gdx.backends.iosrobovm.custom;
-
-/*<imports>*/
-import java.io.*;
-import java.nio.*;
-import java.util.*;
-import org.robovm.objc.*;
-import org.robovm.objc.annotation.*;
-import org.robovm.objc.block.*;
-import org.robovm.rt.*;
-import org.robovm.rt.bro.*;
-import org.robovm.rt.bro.annotation.*;
-import org.robovm.rt.bro.ptr.*;
-import org.robovm.apple.foundation.*;
-import org.robovm.apple.coreanimation.*;
-import org.robovm.apple.coregraphics.*;
-import org.robovm.apple.coredata.*;
-import org.robovm.apple.coreimage.*;
-import org.robovm.apple.coretext.*;
-import org.robovm.apple.corelocation.*;
-/*</imports>*/
-
-/*<javadoc>*/
-/**
- * @since Available in iOS 2.0 and later.
- * @deprecated Deprecated in iOS 5.0.
- */
-@Deprecated
-/*</javadoc>*/
-/*<annotations>*/@Library("UIKit") @NativeClass/*</annotations>*/
-/*<visibility>*/public/*</visibility>*/ class /*<name>*/UIAccelerometer/*</name>*/ 
-    extends /*<extends>*/NSObject/*</extends>*/ 
-    /*<implements>*//*</implements>*/ {
-
-    /*<ptr>*/public static class UIAccelerometerPtr extends Ptr<UIAccelerometer, UIAccelerometerPtr> {}/*</ptr>*/
-    /*<bind>*/static { ObjCRuntime.bind(UIAccelerometer.class); }/*</bind>*/
-    /*<constants>*//*</constants>*/
-    /*<constructors>*/
-    public UIAccelerometer() {}
-    protected UIAccelerometer(SkipInit skipInit) { super(skipInit); }
-    /*</constructors>*/
-    /*<properties>*/
-    @Property(selector = "updateInterval")
-    public native double getUpdateInterval();
-    @Property(selector = "setUpdateInterval:")
-    public native void setUpdateInterval(double v);
-    @Property(selector = "delegate")
-    public native UIAccelerometerDelegate getDelegate();
-    @Property(selector = "setDelegate:", strongRef = true)
-    public native void setDelegate(UIAccelerometerDelegate v);
-    /*</properties>*/
-    /*<members>*//*</members>*/
-    /*<methods>*/
-    @Method(selector = "sharedAccelerometer")
-    public static native UIAccelerometer getSharedAccelerometer();
-    /*</methods>*/
-}
\ No newline at end of file
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAccelerometerDelegate.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAccelerometerDelegate.java
deleted file mode 100644
index 72c2628..0000000
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAccelerometerDelegate.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2014 Trillian Mobile AB
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.badlogic.gdx.backends.iosrobovm.custom;
-
-/*<imports>*/
-import java.io.*;
-import java.nio.*;
-import java.util.*;
-import org.robovm.objc.*;
-import org.robovm.objc.annotation.*;
-import org.robovm.objc.block.*;
-import org.robovm.rt.*;
-import org.robovm.rt.bro.*;
-import org.robovm.rt.bro.annotation.*;
-import org.robovm.rt.bro.ptr.*;
-import org.robovm.apple.foundation.*;
-import org.robovm.apple.coreanimation.*;
-import org.robovm.apple.coregraphics.*;
-import org.robovm.apple.coredata.*;
-import org.robovm.apple.coreimage.*;
-import org.robovm.apple.coretext.*;
-import org.robovm.apple.corelocation.*;
-/*</imports>*/
-
-/*<javadoc>*/
-
-/*</javadoc>*/
-/*<annotations>*//*</annotations>*/
-/*<visibility>*/public/*</visibility>*/ interface /*<name>*/UIAccelerometerDelegate/*</name>*/ 
-    /*<implements>*/extends NSObjectProtocol/*</implements>*/ {
-
-    /*<ptr>*/
-    /*</ptr>*/
-    /*<bind>*/
-    /*</bind>*/
-    /*<constants>*//*</constants>*/
-    /*<properties>*/
-    
-    /*</properties>*/
-    /*<methods>*/
-    /**
-     * @since Available in iOS 2.0 and later.
-     * @deprecated Deprecated in iOS 5.0.
-     */
-    @Deprecated
-    @Method(selector = "accelerometer:didAccelerate:")
-    void didAccelerate(UIAccelerometer accelerometer, UIAcceleration acceleration);
-    /*</methods>*/
-    /*<adapter>*/
-    /*</adapter>*/
-}
\ No newline at end of file
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAccelerometerDelegateAdapter.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAccelerometerDelegateAdapter.java
deleted file mode 100644
index 5808172..0000000
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/custom/UIAccelerometerDelegateAdapter.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2014 Trillian Mobile AB
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.badlogic.gdx.backends.iosrobovm.custom;
-
-/*<imports>*/
-import java.io.*;
-import java.nio.*;
-import java.util.*;
-import org.robovm.objc.*;
-import org.robovm.objc.annotation.*;
-import org.robovm.objc.block.*;
-import org.robovm.rt.*;
-import org.robovm.rt.bro.*;
-import org.robovm.rt.bro.annotation.*;
-import org.robovm.rt.bro.ptr.*;
-import org.robovm.apple.foundation.*;
-import org.robovm.apple.coreanimation.*;
-import org.robovm.apple.coregraphics.*;
-import org.robovm.apple.coredata.*;
-import org.robovm.apple.coreimage.*;
-import org.robovm.apple.coretext.*;
-import org.robovm.apple.corelocation.*;
-/*</imports>*/
-
-/*<javadoc>*/
-/*</javadoc>*/
-/*<annotations>*//*</annotations>*/
-/*<visibility>*/public/*</visibility>*/ class /*<name>*/UIAccelerometerDelegateAdapter/*</name>*/ 
-    extends /*<extends>*/NSObject/*</extends>*/ 
-    /*<implements>*/implements UIAccelerometerDelegate/*</implements>*/ {
-
-    /*<ptr>*/
-    /*</ptr>*/
-    /*<bind>*/
-    /*</bind>*/
-    /*<constants>*//*</constants>*/
-    /*<constructors>*//*</constructors>*/
-    /*<properties>*/
-    
-    /*</properties>*/
-    /*<members>*//*</members>*/
-    /*<methods>*/
-    /**
-     * @since Available in iOS 2.0 and later.
-     * @deprecated Deprecated in iOS 5.0.
-     */
-    @Deprecated
-    @NotImplemented("accelerometer:didAccelerate:")
-    public void didAccelerate(UIAccelerometer accelerometer, UIAcceleration acceleration) { throw new UnsupportedOperationException(); }
-    /*</methods>*/
-}
\ No newline at end of file
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/ALChannelSource.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/ALChannelSource.java
deleted file mode 100644
index 2e62a60..0000000
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/ALChannelSource.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package com.badlogic.gdx.backends.iosrobovm.objectal;
-
-import org.robovm.apple.foundation.NSObject;
-import org.robovm.objc.ObjCRuntime;
-import org.robovm.objc.annotation.NativeClass;
-import org.robovm.objc.annotation.Property;
-import org.robovm.rt.bro.annotation.Library;
-
-@Library(Library.INTERNAL)
-@NativeClass
-public final class ALChannelSource extends NSObject {
-
-	static {
-		ObjCRuntime.bind(ALChannelSource.class);
-	}
-	
-	@Property(selector = "sourcePool")
-	public native ALSoundSourcePool getSourcePool ();
-	
-}
\ No newline at end of file
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/ALSoundSourcePool.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/ALSoundSourcePool.java
deleted file mode 100644
index 1ccc5cb..0000000
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/ALSoundSourcePool.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package com.badlogic.gdx.backends.iosrobovm.objectal;
-
-import org.robovm.apple.foundation.NSArray;
-import org.robovm.apple.foundation.NSObject;
-import org.robovm.objc.ObjCRuntime;
-import org.robovm.objc.annotation.NativeClass;
-import org.robovm.objc.annotation.Property;
-import org.robovm.rt.bro.annotation.Library;
-
-@Library(Library.INTERNAL)
-@NativeClass
-public class ALSoundSourcePool extends NSObject {
-
-	static {
-		ObjCRuntime.bind(ALSoundSourcePool.class);
-	}
-	
-	@Property(selector = "sources")
-	public native NSArray<ALSource> getSources ();
-	
-}
\ No newline at end of file
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/ALSource.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/ALSource.java
index 42e976a..05a51d0 100644
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/ALSource.java
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/ALSource.java
@@ -21,7 +21,6 @@ import org.robovm.objc.ObjCRuntime;
 import org.robovm.objc.annotation.Method;
 import org.robovm.objc.annotation.NativeClass;
 import org.robovm.objc.annotation.Property;
-import org.robovm.rt.bro.NativeObject;
 import org.robovm.rt.bro.annotation.Library;
 
 /**
@@ -34,9 +33,6 @@ public class ALSource extends NSObject {
 	static {
 		ObjCRuntime.bind(ALSource.class);
 	}
-	
-	@Property(selector = "sourceId")
-	public native int getSourceId ();
 
 	@Method(selector = "stop")
 	public native void stop ();
@@ -46,17 +42,4 @@ public class ALSource extends NSObject {
 
 	@Property(selector = "setPaused:")
 	public native void setPaused (boolean paused);
-	
-	@Method(selector = "setVolume:")
-	public native void setVolume (float volume);
-
-	@Method(selector = "setPitch:")
-	public native void setPitch (float pitch);
-	
-	@Method(selector = "setPan:")
-	public native void setPan (float pan);
-	
-	@Method(selector = "setLooping:")
-	public native void setLooping (boolean shouldLoop);
-	
 }
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/OALSimpleAudio.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/OALSimpleAudio.java
index ec1c8f3..fe2de1d 100644
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/OALSimpleAudio.java
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/objectal/OALSimpleAudio.java
@@ -63,8 +63,4 @@ public final class OALSimpleAudio extends NSObject {
 
 	@Property
 	public native void setUseHardwareIfAvailable (boolean useHardwareIfAvailable);
-	
-	@Property(selector = "channel")
-	public native ALChannelSource getChannelSource ();
-	
 }
diff --git a/backends/gdx-backends-gwt/issues.txt b/backends/gdx-backends-gwt/issues.txt
index cd93a8d..061aebc 100644
--- a/backends/gdx-backends-gwt/issues.txt
+++ b/backends/gdx-backends-gwt/issues.txt
@@ -54,7 +54,6 @@ Gdx2DPixmap.java
 PixmapIO.java
 ETC1.java
 ETC1TextureData.java
-KTXTextureData.java
 ScreenUtils.java
 RemoteInput.java
 RemoteSender.java
diff --git a/backends/gdx-backends-gwt/pom.xml b/backends/gdx-backends-gwt/pom.xml
index 03e3425..796a5ac 100644
--- a/backends/gdx-backends-gwt/pom.xml
+++ b/backends/gdx-backends-gwt/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.5.4-SNAPSHOT</version>
+    <version>1.4.2-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtApplication.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtApplication.java
index 4830794..77d1b81 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtApplication.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtApplication.java
@@ -34,8 +34,6 @@ import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.Clipboard;
 import com.badlogic.gdx.utils.ObjectMap;
 import com.badlogic.gdx.utils.TimeUtils;
-import com.google.gwt.animation.client.AnimationScheduler;
-import com.google.gwt.animation.client.AnimationScheduler.AnimationCallback;
 import com.google.gwt.core.client.EntryPoint;
 import com.google.gwt.core.client.GWT;
 import com.google.gwt.core.client.JavaScriptObject;
@@ -44,6 +42,7 @@ import com.google.gwt.dom.client.Document;
 import com.google.gwt.dom.client.Element;
 import com.google.gwt.dom.client.Style;
 import com.google.gwt.dom.client.Style.Unit;
+import com.google.gwt.user.client.Timer;
 import com.google.gwt.user.client.ui.HasHorizontalAlignment;
 import com.google.gwt.user.client.ui.HasVerticalAlignment;
 import com.google.gwt.user.client.ui.Image;
@@ -61,8 +60,8 @@ import com.google.gwt.user.client.ui.VerticalPanel;
  * @author mzechner */
 public abstract class GwtApplication implements EntryPoint, Application {
 	private ApplicationListener listener;
-	GwtApplicationConfiguration config;
-	GwtGraphics graphics;
+	private GwtApplicationConfiguration config;
+	private GwtGraphics graphics;
 	private GwtInput input;
 	private GwtNet net;
 	private Panel root = null;
@@ -95,8 +94,6 @@ public abstract class GwtApplication implements EntryPoint, Application {
 		this.config = getConfig();
 		this.log = config.log;
 
-		addEventListeners();
-
 		if (config.rootPanel != null) {
 			this.root = config.rootPanel;
 		} else {
@@ -191,18 +188,18 @@ public abstract class GwtApplication implements EntryPoint, Application {
 			throw new RuntimeException(t);
 		}
 
-		AnimationScheduler.get().requestAnimationFrame(new AnimationCallback() {
+		// setup rendering timer
+		new Timer() {
 			@Override
-			public void execute (double timestamp) {
+			public void run () {
 				try {
 					mainLoop();
 				} catch (Throwable t) {
 					error("GwtApplication", "exception: " + t.getMessage(), t);
 					throw new RuntimeException(t);
 				}
-				AnimationScheduler.get().requestAnimationFrame(this, graphics.canvas);
 			}
-		}, graphics.canvas);
+		}.scheduleRepeating((int)((1f / config.fps) * 1000));
 	}
 
 	void mainLoop() {
@@ -522,27 +519,6 @@ public abstract class GwtApplication implements EntryPoint, Application {
 		console.log( "GWT: " + message );
 	}-*/;
 	
-	private native void addEventListeners () /*-{
-		var self = this;
-		$doc.addEventListener('visibilitychange', function (e) {
-			self.@com.badlogic.gdx.backends.gwt.GwtApplication::onVisibilityChange(Z)($doc['hidden'] !== true);
-		});
-	}-*/;
-
-	private void onVisibilityChange (boolean visible) {
-		if (visible) {
-			for (LifecycleListener listener : lifecycleListeners) {
-				listener.resume();
-			}
-			listener.resume();
-		} else {
-			for (LifecycleListener listener : lifecycleListeners) {
-				listener.pause();
-			}
-			listener.pause();
-		}
-	}
-	
 	/**
 	 * LoadingListener interface main purpose is to do some things before or after {@link GwtApplication#setupLoop()}
 	 */
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtApplicationConfiguration.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtApplicationConfiguration.java
index 0a4ee7b..d9516ae 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtApplicationConfiguration.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtApplicationConfiguration.java
@@ -28,6 +28,8 @@ public class GwtApplicationConfiguration {
 	public boolean stencil = false;
 	/** whether to enable antialiasing **/
 	public boolean antialiasing = false;
+	/** the framerate to run the game at **/
+	public int fps = 60;
 	/** the Panel to add the WebGL canvas to, can be null in which case a Panel is added automatically to the body element of the
 	 * DOM **/
 	public Panel rootPanel;
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGL20.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGL20.java
index c1e4a52..3485edf 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGL20.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGL20.java
@@ -283,13 +283,6 @@ public class GwtGL20 implements GL20 {
 			gl.deleteTexture(texture);
 		}
 	}
-	
-	@Override
-	public void glDeleteTexture (int id) {
-		WebGLTexture texture = this.textures.get(id);
-		deallocateTextureId(id);
-		gl.deleteTexture(texture);
-	}
 
 	@Override
 	public void glDepthFunc (int func) {
@@ -347,12 +340,6 @@ public class GwtGL20 implements GL20 {
 		int id = allocateTextureId(texture);
 		textures.put(id);
 	}
-	
-	@Override
-	public int glGenTexture () {
-		WebGLTexture texture = gl.createTexture();
-		return allocateTextureId(texture);
-	}
 
 	@Override
 	public int glGetError () {
@@ -495,7 +482,7 @@ public class GwtGL20 implements GL20 {
             gl.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, buffer);
         } else {
             Pixmap pixmap = Pixmap.pixmaps.get(((IntBuffer) pixels).get(0));
-            gl.texSubImage2D(target, level, xoffset, yoffset, format, type, pixmap.getCanvasElement());
+            gl.texSubImage2D(target, level, xoffset, yoffset, width, height, pixmap.getCanvasElement());
         }
 	}
 
@@ -606,13 +593,6 @@ public class GwtGL20 implements GL20 {
 			gl.deleteBuffer(buffer);
 		}
 	}
-	
-	@Override
-	public void glDeleteBuffer (int id) {
-		WebGLBuffer buffer = this.buffers.get(id);
-		deallocateBufferId(id);
-		gl.deleteBuffer(buffer);
-	}
 
 	@Override
 	public void glDeleteFramebuffers (int n, IntBuffer framebuffers) {
@@ -625,13 +605,6 @@ public class GwtGL20 implements GL20 {
 	}
 
 	@Override
-	public void glDeleteFramebuffer (int id) {
-		WebGLFramebuffer fb = this.frameBuffers.get(id);
-		deallocateFrameBufferId(id);
-		gl.deleteFramebuffer(fb);
-	}
-	
-	@Override
 	public void glDeleteProgram (int program) {
 		WebGLProgram prog = programs.get(program);
 		deallocateProgramId(program);
@@ -647,13 +620,6 @@ public class GwtGL20 implements GL20 {
 			gl.deleteRenderbuffer(rb);
 		}
 	}
-	
-	@Override
-	public void glDeleteRenderbuffer (int id) {
-		WebGLRenderbuffer rb = this.renderBuffers.get(id);
-		deallocateRenderBufferId(id);
-		gl.deleteRenderbuffer(rb);
-	}
 
 	@Override
 	public void glDeleteShader (int shader) {
@@ -700,12 +666,6 @@ public class GwtGL20 implements GL20 {
 			buffers.put(id);
 		}
 	}
-	
-	@Override
-	public int glGenBuffer () {
-		WebGLBuffer buffer = gl.createBuffer();
-		return allocateBufferId(buffer);
-	}
 
 	@Override
 	public void glGenerateMipmap (int target) {
@@ -720,12 +680,6 @@ public class GwtGL20 implements GL20 {
 			framebuffers.put(id);
 		}
 	}
-	
-	@Override
-	public int glGenFramebuffer () {
-		WebGLFramebuffer fb = gl.createFramebuffer();
-		return allocateFrameBufferId(fb);
-	}
 
 	@Override
 	public void glGenRenderbuffers (int n, IntBuffer renderbuffers) {
@@ -735,12 +689,6 @@ public class GwtGL20 implements GL20 {
 			renderbuffers.put(id);
 		}
 	}
-	
-	@Override
-	public int glGenRenderbuffer () {
-		WebGLRenderbuffer rb = gl.createRenderbuffer();
-		return allocateRenderBufferId(rb);
-	}
 
 	@Override
 	public String glGetActiveAttrib (int program, int index, IntBuffer size, Buffer type) {
@@ -989,12 +937,6 @@ public class GwtGL20 implements GL20 {
 		WebGLUniformLocation loc = getUniformLocation(location);
 		gl.uniform1fv(loc, copy(v));
 	}
-	
-	@Override
-	public void glUniform1fv (int location, int count, float[] v, int offset) {
-		WebGLUniformLocation loc = getUniformLocation(location);
-		gl.uniform1fv(loc, v);
-	}
 
 	@Override
 	public void glUniform1i (int location, int x) {
@@ -1007,12 +949,6 @@ public class GwtGL20 implements GL20 {
 		WebGLUniformLocation loc = getUniformLocation(location);
 		gl.uniform1iv(loc, copy(v));
 	}
-	
-	@Override
-	public void glUniform1iv (int location, int count, int[] v, int offset) {
-		WebGLUniformLocation loc = getUniformLocation(location);
-		gl.uniform1iv(loc, v);
-	}
 
 	@Override
 	public void glUniform2f (int location, float x, float y) {
@@ -1025,12 +961,6 @@ public class GwtGL20 implements GL20 {
 		WebGLUniformLocation loc = getUniformLocation(location);
 		gl.uniform2fv(loc, copy(v));
 	}
-	
-	@Override
-	public void glUniform2fv (int location, int count, float[] v, int offset) {
-		WebGLUniformLocation loc = getUniformLocation(location);
-		gl.uniform2fv(loc, v);
-	}
 
 	@Override
 	public void glUniform2i (int location, int x, int y) {
@@ -1043,12 +973,6 @@ public class GwtGL20 implements GL20 {
 		WebGLUniformLocation loc = getUniformLocation(location);
 		gl.uniform2iv(loc, copy(v));
 	}
-	
-	@Override
-	public void glUniform2iv (int location, int count, int[] v, int offset) {
-		WebGLUniformLocation loc = getUniformLocation(location);
-		gl.uniform2iv(loc, v);
-	}
 
 	@Override
 	public void glUniform3f (int location, float x, float y, float z) {
@@ -1061,12 +985,6 @@ public class GwtGL20 implements GL20 {
 		WebGLUniformLocation loc = getUniformLocation(location);
 		gl.uniform3fv(loc, copy(v));
 	}
-	
-	@Override
-	public void glUniform3fv (int location, int count, float[] v, int offset) {
-		WebGLUniformLocation loc = getUniformLocation(location);
-		gl.uniform3fv(loc, v);
-	}
 
 	@Override
 	public void glUniform3i (int location, int x, int y, int z) {
@@ -1079,12 +997,6 @@ public class GwtGL20 implements GL20 {
 		WebGLUniformLocation loc = getUniformLocation(location);
 		gl.uniform3iv(loc, copy(v));
 	}
-	
-	@Override
-	public void glUniform3iv (int location, int count, int[] v, int offset) {
-		WebGLUniformLocation loc = getUniformLocation(location);
-		gl.uniform3iv(loc, v);
-	}
 
 	@Override
 	public void glUniform4f (int location, float x, float y, float z, float w) {
@@ -1099,12 +1011,6 @@ public class GwtGL20 implements GL20 {
 	}
 
 	@Override
-	public void glUniform4fv (int location, int count, float[] v, int offset) {
-		WebGLUniformLocation loc = getUniformLocation(location);
-		gl.uniform4fv(loc, v);
-	}
-	
-	@Override
 	public void glUniform4i (int location, int x, int y, int z, int w) {
 		WebGLUniformLocation loc = getUniformLocation(location);
 		gl.uniform4i(loc, x, y, z, w);
@@ -1117,46 +1023,22 @@ public class GwtGL20 implements GL20 {
 	}
 
 	@Override
-	public void glUniform4iv (int location, int count, int[] v, int offset) {
-		WebGLUniformLocation loc = getUniformLocation(location);
-		gl.uniform4iv(loc, v);
-	}
-	
-	@Override
 	public void glUniformMatrix2fv (int location, int count, boolean transpose, FloatBuffer value) {
 		WebGLUniformLocation loc = getUniformLocation(location);
 		gl.uniformMatrix2fv(loc, transpose, copy(value));
 	}
-	
-	@Override
-	public void glUniformMatrix2fv (int location, int count, boolean transpose, float[] value, int offset) {
-		WebGLUniformLocation loc = getUniformLocation(location);
-		gl.uniformMatrix2fv(loc, transpose, value);
-	}
 
 	@Override
 	public void glUniformMatrix3fv (int location, int count, boolean transpose, FloatBuffer value) {
 		WebGLUniformLocation loc = getUniformLocation(location);
 		gl.uniformMatrix3fv(loc, transpose, copy(value));
 	}
-	
-	@Override
-	public void glUniformMatrix3fv (int location, int count, boolean transpose, float[] value, int offset) {
-		WebGLUniformLocation loc = getUniformLocation(location);
-		gl.uniformMatrix3fv(loc, transpose, value);
-	}
 
 	@Override
 	public void glUniformMatrix4fv (int location, int count, boolean transpose, FloatBuffer value) {
 		WebGLUniformLocation loc = getUniformLocation(location);
 		gl.uniformMatrix4fv(loc, transpose, copy(value));
 	}
-	
-	@Override
-	public void glUniformMatrix4fv (int location, int count, boolean transpose, float[] value, int offset) {
-		WebGLUniformLocation loc = getUniformLocation(location);
-		gl.uniformMatrix4fv(loc, transpose, value);
-	}
 
 	@Override
 	public void glUseProgram (int program) {
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtInput.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtInput.java
index 4f70a01..c0e7d0c 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtInput.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtInput.java
@@ -23,7 +23,6 @@ import com.badlogic.gdx.Input.Buttons;
 import com.badlogic.gdx.backends.gwt.widgets.TextInputDialogBox;
 import com.badlogic.gdx.backends.gwt.widgets.TextInputDialogBox.TextInputDialogListener;
 import com.badlogic.gdx.graphics.Pixmap;
-import com.badlogic.gdx.utils.IntMap;
 import com.badlogic.gdx.utils.IntSet;
 import com.badlogic.gdx.utils.TimeUtils;
 import com.gargoylesoftware.htmlunit.javascript.host.Navigator;
@@ -40,7 +39,6 @@ import com.google.gwt.logging.client.ConsoleLogHandler;
 public class GwtInput implements Input {
 	static final int MAX_TOUCHES = 20;
 	boolean justTouched = false;
-	private IntMap<Integer> touchMap = new IntMap<Integer>(20);
 	private boolean[] touched = new boolean[MAX_TOUCHES];
 	private int[] touchX = new int[MAX_TOUCHES];
 	private int[] touchY = new int[MAX_TOUCHES];
@@ -175,8 +173,9 @@ public class GwtInput implements Input {
 		return justPressedKeys[key];
 	}
 
-	public void getTextInput (TextInputListener listener, String title, String text, String hint) {
-		TextInputDialogBox dialog = new TextInputDialogBox(title, text, hint);
+	@Override
+	public void getTextInput (TextInputListener listener, String title, String text) {
+		TextInputDialogBox dialog = new TextInputDialogBox(title, text, null);
 		final TextInputListener capturedListener = listener;
 		dialog.setListener(new TextInputDialogListener() {
 			@Override
@@ -194,7 +193,28 @@ public class GwtInput implements Input {
 			}
 		});
 	}
-	
+
+	@Override
+	public void getPlaceholderTextInput (TextInputListener listener, String title, String placeholder) {
+		TextInputDialogBox dialog = new TextInputDialogBox(title, null, placeholder);
+		final TextInputListener capturedListener = listener;
+		dialog.setListener(new TextInputDialogListener() {
+			@Override
+			public void onPositive (String text) {
+				if (capturedListener != null) {
+					capturedListener.input(text);
+				}
+			}
+
+			@Override
+			public void onNegative () {
+				if (capturedListener != null) {
+					capturedListener.canceled();
+				}
+			}
+		});
+	}
+
 	@Override
 	public void setOnscreenKeyboardVisible (boolean visible) {
 	}
@@ -598,9 +618,7 @@ public class GwtInput implements Input {
 			JsArray<Touch> touches = e.getChangedTouches();
 			for (int i = 0, j = touches.length(); i < j; i++) {
 				Touch touch = touches.get(i);
-				int real = touch.getIdentifier();
-				int touchId;
-				touchMap.put(real, touchId = getAvailablePointer());
+				int touchId = touch.getIdentifier();
 				touched[touchId] = true;
 				touchX[touchId] = getRelativeX(touch, canvas);
 				touchY[touchId] = getRelativeY(touch, canvas);
@@ -617,8 +635,7 @@ public class GwtInput implements Input {
 			JsArray<Touch> touches = e.getChangedTouches();
 			for (int i = 0, j = touches.length(); i < j; i++) {
 				Touch touch = touches.get(i);
-				int real = touch.getIdentifier();
-				int touchId = touchMap.get(real);
+				int touchId = touch.getIdentifier();
 				deltaX[touchId] = getRelativeX(touch, canvas) - touchX[touchId];
 				deltaY[touchId] = getRelativeY(touch, canvas) - touchY[touchId];
 				touchX[touchId] = getRelativeX(touch, canvas);
@@ -634,9 +651,7 @@ public class GwtInput implements Input {
 			JsArray<Touch> touches = e.getChangedTouches();
 			for (int i = 0, j = touches.length(); i < j; i++) {
 				Touch touch = touches.get(i);
-				int real = touch.getIdentifier();
-				int touchId = touchMap.get(real);
-				touchMap.remove(real);
+				int touchId = touch.getIdentifier();
 				touched[touchId] = false;
 				deltaX[touchId] = getRelativeX(touch, canvas) - touchX[touchId];
 				deltaY[touchId] = getRelativeY(touch, canvas) - touchY[touchId];
@@ -653,9 +668,7 @@ public class GwtInput implements Input {
 			JsArray<Touch> touches = e.getChangedTouches();
 			for (int i = 0, j = touches.length(); i < j; i++) {
 				Touch touch = touches.get(i);
-				int real = touch.getIdentifier();
-				int touchId = touchMap.get(real);
-				touchMap.remove(real);
+				int touchId = touch.getIdentifier();
 				touched[touchId] = false;
 				deltaX[touchId] = getRelativeX(touch, canvas) - touchX[touchId];
 				deltaY[touchId] = getRelativeY(touch, canvas) - touchY[touchId];
@@ -670,13 +683,6 @@ public class GwtInput implements Input {
 		}
 // if(hasFocus) e.preventDefault();
 	}
-	
-	private int getAvailablePointer () {
-		for (int i = 0; i < MAX_TOUCHES; i++) {
-			if (!touchMap.containsValue(i, false)) return i;
-		}
-		return -1;
-	}
 
 	/** borrowed from PlayN, thanks guys **/
 	private static int keyForCode (int keyCode) {
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtNet.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtNet.java
index a9d40c1..72be7f6 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtNet.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtNet.java
@@ -161,7 +161,7 @@ public class GwtNet implements Net {
 			requests.put(httpRequest, request);
 			listeners.put(httpRequest, httpResultListener);
 
-		} catch (Throwable e) {
+		} catch (RequestException e) {
 			httpResultListener.failed(e);
 		}
 
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/assets/loaders/CubemapLoader.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/assets/loaders/CubemapLoader.java
deleted file mode 100644
index 062c8b0..0000000
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/assets/loaders/CubemapLoader.java
+++ /dev/null
@@ -1,87 +0,0 @@
-package com.badlogic.gdx.assets.loaders;
-
-import com.badlogic.gdx.assets.AssetDescriptor;
-import com.badlogic.gdx.assets.AssetLoaderParameters;
-import com.badlogic.gdx.assets.AssetManager;
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.Cubemap;
-import com.badlogic.gdx.graphics.CubemapData;
-import com.badlogic.gdx.graphics.Pixmap;
-import com.badlogic.gdx.graphics.Pixmap.Format;
-import com.badlogic.gdx.graphics.Texture.TextureFilter;
-import com.badlogic.gdx.graphics.Texture.TextureWrap;
-import com.badlogic.gdx.graphics.TextureData;
-import com.badlogic.gdx.utils.Array;
-
-/** {@link AssetLoader} for {@link Cubemap} instances. The pixel data is loaded asynchronously. The texture is then created on the
- * rendering thread, synchronously. Passing a {@link CubemapParameter} to
- * {@link AssetManager#load(String, Class, AssetLoaderParameters)} allows one to specify parameters as can be passed to the
- * various Cubemap constructors, e.g. filtering and so on.
- * @author mzechner, Vincent Bousquet */
-public class CubemapLoader extends AsynchronousAssetLoader<Cubemap, CubemapLoader.CubemapParameter> {
-	static public class CubemapLoaderInfo {
-		String filename;
-		CubemapData data;
-		Cubemap cubemap;
-	};
-
-	CubemapLoaderInfo info = new CubemapLoaderInfo();
-
-	public CubemapLoader (FileHandleResolver resolver) {
-		super(resolver);
-	}
-
-	@Override
-	public void loadAsync (AssetManager manager, String fileName, FileHandle file, CubemapParameter parameter) {
-		info.filename = fileName;
-		if (parameter == null || parameter.cubemapData == null) {
-			Pixmap pixmap = null;
-			Format format = null;
-			boolean genMipMaps = false;
-			info.cubemap = null;
-
-			if (parameter != null) {
-				format = parameter.format;
-				info.cubemap = parameter.cubemap;
-			}
-		} else {
-			info.data = parameter.cubemapData;
-			info.cubemap = parameter.cubemap;
-		}
-		if (!info.data.isPrepared()) info.data.prepare();
-	}
-
-	@Override
-	public Cubemap loadSync (AssetManager manager, String fileName, FileHandle file, CubemapParameter parameter) {
-		if (info == null) return null;
-		Cubemap cubemap = info.cubemap;
-		if (cubemap != null) {
-			cubemap.load(info.data);
-		} else {
-			cubemap = new Cubemap(info.data);
-		}
-		if (parameter != null) {
-			cubemap.setFilter(parameter.minFilter, parameter.magFilter);
-			cubemap.setWrap(parameter.wrapU, parameter.wrapV);
-		}
-		return cubemap;
-	}
-
-	@Override
-	public Array<AssetDescriptor> getDependencies (String fileName, FileHandle file, CubemapParameter parameter) {
-		return null;
-	}
-
-	static public class CubemapParameter extends AssetLoaderParameters<Cubemap> {
-		/** the format of the final Texture. Uses the source images format if null **/
-		public Format format = null;
-		/** The texture to put the {@link TextureData} in, optional. **/
-		public Cubemap cubemap = null;
-		/** CubemapData for textures created on the fly, optional. When set, all format and genMipMaps are ignored */
-		public CubemapData cubemapData = null;
-		public TextureFilter minFilter = TextureFilter.Nearest;
-		public TextureFilter magFilter = TextureFilter.Nearest;
-		public TextureWrap wrapU = TextureWrap.ClampToEdge;
-		public TextureWrap wrapV = TextureWrap.ClampToEdge;
-	}
-}
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/assets/loaders/resolvers/ResolutionFileResolver.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/assets/loaders/resolvers/ResolutionFileResolver.java
index 2450e0d..f20e75b 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/assets/loaders/resolvers/ResolutionFileResolver.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/assets/loaders/resolvers/ResolutionFileResolver.java
@@ -25,12 +25,12 @@ public class ResolutionFileResolver implements FileHandleResolver {
 	public static class Resolution {
 		public final int portraitWidth;
 		public final int portraitHeight;
-		public final String folder;
+		public final String suffix;
 
-		public Resolution (int portraitWidth, int portraitHeight, String folder) {
+		public Resolution (int portraitWidth, int portraitHeight, String suffix) {
 			this.portraitWidth = portraitWidth;
 			this.portraitHeight = portraitHeight;
-			this.folder = folder;
+			this.suffix = suffix;
 		}
 	}
 
@@ -46,7 +46,7 @@ public class ResolutionFileResolver implements FileHandleResolver {
 	public FileHandle resolve (String fileName) {
 		Resolution bestDesc = choose(descriptors);
 		FileHandle originalHandle = new GwtFileHandle(fileName);
-		FileHandle handle = baseResolver.resolve(resolve(originalHandle, bestDesc.folder));
+		FileHandle handle = baseResolver.resolve(resolve(originalHandle, bestDesc.suffix));
 		if (!handle.exists()) handle = baseResolver.resolve(fileName);
 		return handle;
 	}
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/Pixmap.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/Pixmap.java
index fcf8250..bdde321 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/Pixmap.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/Pixmap.java
@@ -67,7 +67,6 @@ public class Pixmap implements Disposable {
 	int r = 255, g = 255, b = 255;
 	float a;
 	String color = make(r, g, b, a);
-	static String clearColor = make(255, 255, 255, 1.0f);
 	static Blending blending;
 	CanvasPixelArray pixels;
 
@@ -82,7 +81,7 @@ public class Pixmap implements Disposable {
 	}
 
 	private static Composite getComposite () {
-		return Composite.SOURCE_OVER;
+		return blending == Blending.None ? Composite.COPY : Composite.SOURCE_OVER;
 	}
 
 	public Pixmap (ImageElement img) {
@@ -207,7 +206,7 @@ public class Pixmap implements Disposable {
 
 	/** Fills the complete bitmap with the currently set color. */
 	public void fill () {
-		rectangle(0, 0, getWidth(), getHeight(), DrawType.FILL);
+		context.fillRect(0, 0, getWidth(), getHeight());
 	}
 
 // /**
@@ -224,7 +223,11 @@ public class Pixmap implements Disposable {
 	 * @param x2 The x-coordinate of the first point
 	 * @param y2 The y-coordinate of the first point */
 	public void drawLine (int x, int y, int x2, int y2) {
-		line(x, y, x2, y2, DrawType.STROKE);
+		context.beginPath();
+		context.moveTo(x, y);
+		context.lineTo(x2, y2);
+		context.stroke();
+		context.closePath();
 	}
 
 	/** Draws a rectangle outline starting at x, y extending by width to the right and by height downwards (y-axis points downwards)
@@ -235,7 +238,10 @@ public class Pixmap implements Disposable {
 	 * @param width The width in pixels
 	 * @param height The height in pixels */
 	public void drawRectangle (int x, int y, int width, int height) {
-		rectangle(x, y, width, height, DrawType.STROKE);
+		context.beginPath();
+		context.rect(x, y, width, height);
+		context.stroke();
+		context.closePath();
 	}
 
 	/** Draws an area form another Pixmap to this Pixmap.
@@ -244,8 +250,7 @@ public class Pixmap implements Disposable {
 	 * @param x The target x-coordinate (top left corner)
 	 * @param y The target y-coordinate (top left corner) */
 	public void drawPixmap (Pixmap pixmap, int x, int y) {
-		CanvasElement image = pixmap.getCanvasElement();		
-		image(image, 0, 0, image.getWidth(), image.getHeight(), x, y, image.getWidth(), image.getHeight());
+		context.drawImage(pixmap.getCanvasElement(), x, y);
 	}
 
 	/** Draws an area form another Pixmap to this Pixmap.
@@ -257,9 +262,8 @@ public class Pixmap implements Disposable {
 	 * @param srcy The source y-coordinate (top left corner);
 	 * @param srcWidth The width of the area form the other Pixmap in pixels
 	 * @param srcHeight The height of the area form the other Pixmap in pixles */
-	public void drawPixmap (Pixmap pixmap, int x, int y, int srcx, int srcy, int srcWidth, int srcHeight) {		
-		CanvasElement image = pixmap.getCanvasElement();		
-		image(image, srcx, srcy, srcWidth, srcHeight, x, y, srcWidth, srcHeight);		
+	public void drawPixmap (Pixmap pixmap, int x, int y, int srcx, int srcy, int srcWidth, int srcHeight) {
+		context.drawImage(pixmap.getCanvasElement(), srcx, srcy, srcWidth, srcHeight, x, y, srcWidth, srcHeight);
 	}
 
 	/** Draws an area form another Pixmap to this Pixmap. This will automatically scale and stretch the source image to the
@@ -277,7 +281,7 @@ public class Pixmap implements Disposable {
 	 * @param dstHeight the target height */
 	public void drawPixmap (Pixmap pixmap, int srcx, int srcy, int srcWidth, int srcHeight, int dstx, int dsty, int dstWidth,
 		int dstHeight) {
-		image(pixmap.getCanvasElement(), srcx, srcy, srcWidth, srcHeight, dstx, dsty, dstWidth, dstHeight);
+		context.drawImage(pixmap.getCanvasElement(), srcx, srcy, srcWidth, srcHeight, dstx, dsty, dstWidth, dstHeight);
 	}
 
 	/** Fills a rectangle starting at x, y extending by width to the right and by height downwards (y-axis points downwards) using
@@ -288,7 +292,7 @@ public class Pixmap implements Disposable {
 	 * @param width The width in pixels
 	 * @param height The height in pixels */
 	public void fillRectangle (int x, int y, int width, int height) {
-		rectangle(x, y, width, height, DrawType.FILL);
+		context.fillRect(x, y, width, height);
 	}
 
 	/** Draws a circle outline with the center at x,y and a radius using the current color and stroke width.
@@ -297,7 +301,10 @@ public class Pixmap implements Disposable {
 	 * @param y The y-coordinate of the center
 	 * @param radius The radius in pixels */
 	public void drawCircle (int x, int y, int radius) {
-		circle(x, y, radius, DrawType.STROKE);
+		context.beginPath();
+		context.arc(x, y, radius, 0, 2 * Math.PI, false);
+		context.stroke();
+		context.closePath();
 	}
 
 	/** Fills a circle with the center at x,y and a radius using the current color.
@@ -306,7 +313,10 @@ public class Pixmap implements Disposable {
 	 * @param y The y-coordinate of the center
 	 * @param radius The radius in pixels */
 	public void fillCircle (int x, int y, int radius) {
-		circle(x, y, radius, DrawType.FILL);
+		context.beginPath();
+		context.arc(x, y, radius, 0, 2 * Math.PI, false);
+		context.fill();
+		context.closePath();
 	}
 
 	/** Fills a triangle with vertices at x1,y1 and x2,y2 and x3,y3 using the current color.
@@ -318,7 +328,13 @@ public class Pixmap implements Disposable {
 	 * @param x3 The x-coordinate of vertex 3
 	 * @param y3 The y-coordinate of vertex 3 */
 	public void fillTriangle (int x1, int y1, int x2, int y2, int x3, int y3) {
-		triangle(x1, y1, x2, y2, x3, y3, DrawType.FILL);
+		context.beginPath();
+		context.moveTo(x1,y1);
+		context.lineTo(x2,y2);
+		context.lineTo(x3,y3);
+		context.lineTo(x1,y1);
+		context.fill();
+		context.closePath();
 	}
 
 	/** Returns the 32-bit RGBA8888 value of the pixel at x, y. For Alpha formats the RGB components will be one.
@@ -341,7 +357,7 @@ public class Pixmap implements Disposable {
 	 * @param x the x-coordinate
 	 * @param y the y-coordinate */
 	public void drawPixel (int x, int y) {
-		rectangle(x, y, 1, 1, DrawType.FILL);
+		context.fillRect(x, y, 1, 1);
 	}
 
 	/** Draws a pixel at the given location with the given color.
@@ -354,123 +370,4 @@ public class Pixmap implements Disposable {
 		drawPixel(x, y);
 	}
 
-	private void circle (int x, int y, int radius, DrawType drawType) {
-		if (blending == Blending.None) {
-			context.setFillStyle(clearColor);
-			context.setStrokeStyle(clearColor);
-			context.setGlobalCompositeOperation("clear");
-			context.beginPath();
-			context.arc(x, y, radius, 0, 2 * Math.PI, false);
-			fillOrStrokePath(drawType);
-			context.closePath();
-			context.setFillStyle(color);
-			context.setStrokeStyle(color);
-			context.setGlobalCompositeOperation(Composite.SOURCE_OVER);
-		}
-		context.beginPath();
-		context.arc(x, y, radius, 0, 2 * Math.PI, false);
-		fillOrStrokePath(drawType);
-		context.closePath();
-		pixels = null;		
-	}
-	
-	private void line(int x, int y, int x2, int y2, DrawType drawType) {
-		if (blending == Blending.None) {
-			context.setFillStyle(clearColor);
-			context.setStrokeStyle(clearColor);
-			context.setGlobalCompositeOperation("clear");
-			context.beginPath();
-			context.moveTo(x, y);
-			context.lineTo(x2, y2);
-			fillOrStrokePath(drawType);
-			context.closePath();
-			context.setFillStyle(color);
-			context.setStrokeStyle(color);
-			context.setGlobalCompositeOperation(Composite.SOURCE_OVER);
-		}		
-		context.beginPath();
-		context.moveTo(x, y);
-		context.lineTo(x2, y2);
-		fillOrStrokePath(drawType);
-		context.closePath();
-	}
-	
-	private void rectangle(int x, int y, int width, int height, DrawType drawType) {
-		if (blending == Blending.None) {
-			context.setFillStyle(clearColor);
-			context.setStrokeStyle(clearColor);
-			context.setGlobalCompositeOperation("clear");
-			context.beginPath();
-			context.rect(x, y, width, height);
-			fillOrStrokePath(drawType);
-			context.closePath();
-			context.setFillStyle(color);
-			context.setStrokeStyle(color);
-			context.setGlobalCompositeOperation(Composite.SOURCE_OVER);
-		}
-		context.beginPath();
-		context.rect(x, y, width, height);
-		fillOrStrokePath(drawType);
-		context.closePath();
-		pixels = null;
-	}
-	
-	private void triangle(int x1, int y1, int x2, int y2, int x3, int y3, DrawType drawType) {
-		if (blending == Blending.None) {
-			context.setFillStyle(clearColor);
-			context.setStrokeStyle(clearColor);
-			context.setGlobalCompositeOperation("clear");
-			context.beginPath();
-			context.moveTo(x1,y1);
-			context.lineTo(x2,y2);
-			context.lineTo(x3,y3);
-			context.lineTo(x1,y1);
-			fillOrStrokePath(drawType);
-			context.closePath();
-			context.setFillStyle(color);
-			context.setStrokeStyle(color);
-			context.setGlobalCompositeOperation(Composite.SOURCE_OVER);
-		}		
-		context.beginPath();
-		context.moveTo(x1,y1);
-		context.lineTo(x2,y2);
-		context.lineTo(x3,y3);
-		context.lineTo(x1,y1);
-		fillOrStrokePath(drawType);
-		context.closePath();
-		pixels = null;
-	}
-	
-	private void image (CanvasElement image, int srcX, int srcY, int srcWidth, int srcHeight, int dstX, int dstY, int dstWidth, int dstHeight) {
-		if (blending == Blending.None) {
-			context.setFillStyle(clearColor);
-			context.setStrokeStyle(clearColor);
-			context.setGlobalCompositeOperation("clear");
-			context.beginPath();
-			context.rect(dstX, dstY, dstWidth, dstHeight);
-			fillOrStrokePath(DrawType.FILL);
-			context.closePath();
-			context.setFillStyle(color);
-			context.setStrokeStyle(color);
-			context.setGlobalCompositeOperation(Composite.SOURCE_OVER);
-		}
-		context.drawImage(image, srcX, srcY, srcWidth, srcHeight, dstX, dstY, dstWidth, dstHeight);
-		pixels = null;
-	}
-	
-	private void fillOrStrokePath(DrawType drawType) {
-		switch (drawType) {
-			case FILL:
-				context.fill();
-				break;
-			case STROKE:
-				context.stroke();
-				break;
-		}		
-	}
-	
-	private enum DrawType {
-		FILL, STROKE
-	}
-	
 }
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/TextureData.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/TextureData.java
deleted file mode 100644
index 290c3ee..0000000
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/TextureData.java
+++ /dev/null
@@ -1,81 +0,0 @@
-package com.badlogic.gdx.graphics;
-
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.Pixmap.Format;
-import com.badlogic.gdx.graphics.glutils.FileTextureData;
-import com.badlogic.gdx.graphics.glutils.MipMapGenerator;
-
-/** Used by a {@link Texture} to load the pixel data. A TextureData can either return a {@link Pixmap} or upload the pixel data
- * itself. It signals it's type via {@link #getType()} to the Texture that's using it. The Texture will then either invoke
- * {@link #consumePixmap()} or {@link #consumeCustomData(int)}. These are the first methods to be called by Texture. After that
- * the Texture will invoke the other methods to find out about the size of the image data, the format, whether mipmaps should be
- * generated and whether the TextureData is able to manage the pixel data if the OpenGL ES context is lost.</p>
- * 
- * In case the TextureData implementation has the type {@link TextureDataType#Custom}, the implementation has to generate the
- * mipmaps itself if necessary. See {@link MipMapGenerator}.</p>
- * 
- * Before a call to either {@link #consumePixmap()} or {@link #consumeCustomData(int)}, Texture will bind the OpenGL ES
- * texture.</p>
- * 
- * Look at {@link FileTextureData} for example implementations of this interface.
- * @author mzechner */
-public interface TextureData {
-	/** The type of this {@link TextureData}.
-	 * @author mzechner */
-	public enum TextureDataType {
-		Pixmap, Custom
-	}
-
-	/** @return the {@link TextureDataType} */
-	public TextureDataType getType ();
-
-	/** @return whether the TextureData is prepared or not. */
-	public boolean isPrepared ();
-
-	/** Prepares the TextureData for a call to {@link #consumePixmap()} or {@link #consumeCustomData(int)}. This method can be
-	 * called from a non OpenGL thread and should thus not interact with OpenGL. */
-	public void prepare ();
-
-	/** Returns the {@link Pixmap} for upload by Texture. A call to {@link #prepare()} must precede a call to this method. Any
-	 * internal data structures created in {@link #prepare()} should be disposed of here.
-	 * 
-	 * @return the pixmap. */
-	public Pixmap consumePixmap ();
-
-	/** @return whether the caller of {@link #consumePixmap()} should dispose the Pixmap returned by {@link #consumePixmap()} */
-	public boolean disposePixmap ();
-
-	/** Uploads the pixel data to the OpenGL ES texture. The caller must bind an OpenGL ES texture. A call to {@link #prepare()}
-	 * must preceed a call to this method. Any internal data structures created in {@link #prepare()} should be disposed of here. */
-	public void consumeCustomData (int target);
-
-	/** @return the width of the pixel data */
-	public int getWidth ();
-
-	/** @return the height of the pixel data */
-	public int getHeight ();
-
-	/** @return the {@link Format} of the pixel data */
-	public Format getFormat ();
-
-	/** @return whether to generate mipmaps or not. */
-	public boolean useMipMaps ();
-
-	/** @return whether this implementation can cope with a EGL context loss. */
-	public boolean isManaged ();
-
-	/** Provides static method to instantiate the right implementation (Pixmap, ETC1, KTX).
-	 * @author Vincent Bousquet */
-	public static class Factory {
-
-		public static TextureData loadFromFile (FileHandle file, boolean useMipMaps) {
-			return loadFromFile(file, null, useMipMaps);
-		}
-
-		public static TextureData loadFromFile (FileHandle file, Format format, boolean useMipMaps) {
-			if (file == null) return null;
-			return new FileTextureData(file, new Pixmap(file), format, useMipMaps);
-		}
-
-	}
-}
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/glutils/IndexBufferObject.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/glutils/IndexBufferObject.java
index 61f7ab5..465db27 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/glutils/IndexBufferObject.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/glutils/IndexBufferObject.java
@@ -16,6 +16,7 @@
 
 package com.badlogic.gdx.graphics.glutils;
 
+import java.nio.IntBuffer;
 import java.nio.ShortBuffer;
 
 import com.badlogic.gdx.Gdx;
@@ -44,6 +45,8 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
  * 
  * @author mzechner */
 public class IndexBufferObject implements IndexData {
+	final static IntBuffer tmpHandle = BufferUtils.newIntBuffer(1);
+
 	ShortBuffer buffer;
 	int bufferHandle;
 	final boolean isDirect;
@@ -59,7 +62,7 @@ public class IndexBufferObject implements IndexData {
 		isDirect = true;
 		buffer = BufferUtils.newShortBuffer(maxIndices);
 		buffer.flip();
-		bufferHandle = Gdx.gl20.glGenBuffer();
+		bufferHandle = createBufferObject();
 		usage = isStatic ? GL20.GL_STATIC_DRAW : GL20.GL_DYNAMIC_DRAW;
 	}
 
@@ -70,10 +73,16 @@ public class IndexBufferObject implements IndexData {
 		this.isDirect = true;
 		buffer = BufferUtils.newShortBuffer(maxIndices);
 		buffer.flip();
-		bufferHandle = Gdx.gl20.glGenBuffer();
+		bufferHandle = createBufferObject();
 		usage = GL20.GL_STATIC_DRAW;
 	}
 
+	private int createBufferObject () {
+		tmpHandle.clear();
+		Gdx.gl20.glGenBuffers(1, tmpHandle);
+		return tmpHandle.get(0);
+	}
+
 	/** @return the number of indices currently stored in this buffer */
 	public int getNumIndices () {
 		return buffer.limit();
@@ -107,19 +116,6 @@ public class IndexBufferObject implements IndexData {
 			isDirty = false;
 		}
 	}
-	
-	public void setIndices (ShortBuffer indices) {
-		isDirty = true;
-		buffer.clear();
-		buffer.put(indices);
-		buffer.flip();
-		
-		if (isBound) {
-			Gdx.gl20.glBufferData(GL20.GL_ELEMENT_ARRAY_BUFFER, buffer.limit(), buffer, usage);
-			isDirty = false;
-		}
-	}
-
 
 	/** <p>
 	 * Returns the underlying ShortBuffer. If you modify the buffer contents they wil be uploaded on the call to {@link #bind()}.
@@ -152,15 +148,18 @@ public class IndexBufferObject implements IndexData {
 
 	/** Invalidates the IndexBufferObject so a new OpenGL buffer handle is created. Use this in case of a context loss. */
 	public void invalidate () {
-		bufferHandle = Gdx.gl20.glGenBuffer();
+		bufferHandle = createBufferObject();
 		isDirty = true;
 	}
 
 	/** Disposes this IndexBufferObject and all its associated OpenGL resources. */
 	public void dispose () {
+		tmpHandle.clear();
+		tmpHandle.put(bufferHandle);
+		tmpHandle.flip();
 		GL20 gl = Gdx.gl20;
 		gl.glBindBuffer(GL20.GL_ELEMENT_ARRAY_BUFFER, 0);
-		gl.glDeleteBuffer(bufferHandle);
+		gl.glDeleteBuffers(1, tmpHandle);
 		bufferHandle = 0;		
 	}
 }
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java
index b119d45..d68bf4b 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java
@@ -17,6 +17,7 @@
 package com.badlogic.gdx.graphics.glutils;
 
 import java.nio.FloatBuffer;
+import java.nio.IntBuffer;
 
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.GL20;
@@ -49,6 +50,8 @@ import com.badlogic.gdx.utils.BufferUtils;
  * 
  * @author mzechner, Dave Clayton <contact@redskyforge.com> */
 public class VertexBufferObject implements VertexData {
+	final static IntBuffer tmpHandle = BufferUtils.newIntBuffer(1);
+
 	final VertexAttributes attributes;
 	final FloatBuffer buffer;
 	int bufferHandle;
@@ -77,10 +80,16 @@ public class VertexBufferObject implements VertexData {
 
 		buffer = BufferUtils.newFloatBuffer(this.attributes.vertexSize / 4 * numVertices);
 		buffer.flip();
-		bufferHandle = Gdx.gl20.glGenBuffer();
+		bufferHandle = createBufferObject();
 		usage = isStatic ? GL20.GL_STATIC_DRAW : GL20.GL_DYNAMIC_DRAW;
 	}
 
+	private int createBufferObject () {
+		tmpHandle.clear();
+		Gdx.gl20.glGenBuffers(1, tmpHandle);
+		return tmpHandle.get(0);
+	}
+
 	@Override
 	public VertexAttributes getAttributes () {
 		return attributes;
@@ -213,16 +222,19 @@ public class VertexBufferObject implements VertexData {
 
 	/** Invalidates the VertexBufferObject so a new OpenGL buffer handle is created. Use this in case of a context loss. */
 	public void invalidate () {
-		bufferHandle = Gdx.gl20.glGenBuffer();
+		bufferHandle = createBufferObject();
 		isDirty = true;
 	}
 
 	/** Disposes of all resources this VertexBufferObject uses. */
 	@Override
 	public void dispose () {
+		tmpHandle.clear();
+		tmpHandle.put(bufferHandle);
+		tmpHandle.flip();
 		GL20 gl = Gdx.gl20;
 		gl.glBindBuffer(GL20.GL_ARRAY_BUFFER, 0);
-		gl.glDeleteBuffer(bufferHandle);
+		gl.glDeleteBuffers(1, tmpHandle);
 		bufferHandle = 0;		
 	}
 }
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/math/Matrix4.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/math/Matrix4.java
index 09741d2..d1a5586 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/math/Matrix4.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/math/Matrix4.java
@@ -578,44 +578,6 @@ public class Matrix4 implements Serializable {
 		return this;
 	}
 
-	/** Sets the matrix to a projection matrix with a near/far plane, and left, bottom, right and top specifying the points on the
-	 * near plane that are mapped to the lower left and upper right corners of the viewport. This allows to create projection
-	 * matrix with off-center vanishing point.
-	 * 
-	 * @param left
-	 * @param right
-	 * @param bottom
-	 * @param top
-	 * @param near The near plane
-	 * @param far The far plane
-	 * @return This matrix for the purpose of chaining methods together. */
-	public Matrix4 setToProjection (float left, float right, float bottom, float top, float near, float far) {
-		float x = 2.0f * near / (right - left);
-		float y = 2.0f * near / (top - bottom);
-		float a = (right + left) / (right - left);
-		float b = (top + bottom) / (top - bottom);
-		float l_a1 = (far + near) / (near - far);
-		float l_a2 = (2 * far * near) / (near - far);
-		val[M00] = x;
-		val[M10] = 0;
-		val[M20] = 0;
-		val[M30] = 0;
-		val[M01] = 0;
-		val[M11] = y;
-		val[M21] = 0;
-		val[M31] = 0;
-		val[M02] = a;
-		val[M12] = b;
-		val[M22] = l_a1;
-		val[M32] = -1;
-		val[M03] = 0;
-		val[M13] = 0;
-		val[M23] = l_a2;
-		val[M33] = 0;
-
-		return this;
-	}
-
 	/** Sets this matrix to an orthographic projection matrix with the origin at (x,y) extending by width and height. The near plane
 	 * is set to 0, the far plane is set to 1.
 	 * 
@@ -973,17 +935,26 @@ public class Matrix4 implements Serializable {
 	 * @param w Weight of this transform; weight of the other transform is (1 - w)
 	 * @return This matrix for chaining */
 	public Matrix4 avg (Matrix4 other, float w) {
+
+		//Get this and other matrix's scale component
 		getScale(tmpVec);
 		other.getScale(tmpForward);
 		
+		//Get this and other matrix's rotation component
 		getRotation(quat);
 		other.getRotation(quat2);
 		
+		//Get this and other matrix's translation component
 		getTranslation(tmpUp);
 		other.getTranslation(right);
 		
+		//Calculate scale components
 		setToScaling(tmpVec.scl(w).add(tmpForward.scl(1 - w)));
+
+		//Calculate rotation components
 		rotate(quat.slerp(quat2, 1 - w));
+
+		//Calculate translation components
 		setTranslation(tmpUp.scl(w).add(right.scl(1 - w)));
 		
 		return this;
@@ -998,17 +969,30 @@ public class Matrix4 implements Serializable {
 	public Matrix4 avg (Matrix4[] t) {
 		final float w = 1.0f/t.length;
 
+		//Initialize scale components
 		tmpVec.set(t[0].getScale(tmpUp).scl(w));
+		
+		//Initialize rotation components
 		quat.set(t[0].getRotation(quat2).exp(w));
+		
+		//Initialize translation components
 		tmpForward.set(t[0].getTranslation(tmpUp).scl(w));
 		
+		//Continue calculating
 		for(int i=1;i<t.length;i++){
+			
+			//Calculate scale components
 			tmpVec.add(t[i].getScale(tmpUp).scl(w));
+			
+			//Calculate rotation components
 			quat.mul(t[i].getRotation(quat2).exp(w));
+			
+			//Calculate translation components
 			tmpForward.add(t[i].getTranslation(tmpUp).scl(w));
 		}
 		quat.nor();
 		
+		//Set calculated components to this matrix
 		setToScaling(tmpVec);
 		rotate(quat);
 		setTranslation(tmpForward);
@@ -1025,17 +1009,31 @@ public class Matrix4 implements Serializable {
 	 * @param w List of weights
 	 * @return This matrix for chaining */
 	public Matrix4 avg (Matrix4[] t, float[] w) {
+
+		//Initialize scale components
 		tmpVec.set(t[0].getScale(tmpUp).scl(w[0]));
+		
+		//Initialize rotation components
 		quat.set(t[0].getRotation(quat2).exp(w[0]));
+		
+		//Initialize translation components
 		tmpForward.set(t[0].getTranslation(tmpUp).scl(w[0]));
 		
+		//Continue calculating
 		for(int i=1;i<t.length;i++){
+			
+			//Calculate scale components
 			tmpVec.add(t[i].getScale(tmpUp).scl(w[i]));
+			
+			//Calculate rotation components
 			quat.mul(t[i].getRotation(quat2).exp(w[i]));
+			
+			//Calculate translation components
 			tmpForward.add(t[i].getTranslation(tmpUp).scl(w[i]));
 		}
 		quat.nor();
 		
+		//Set calculated components to this matrix
 		setToScaling(tmpVec);
 		rotate(quat);
 		setTranslation(tmpForward);
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/Timer.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/Timer.java
index 7e1dd4e..6cb8373 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/Timer.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/Timer.java
@@ -45,22 +45,22 @@ public class Timer {
 	}
 
 	/** Schedules a task to occur once as soon as possible, but not sooner than the start of the next frame. */
-	public Task postTask (Task task) {
-		return scheduleTask(task, 0, 0, 0);
+	public void postTask (Task task) {
+		scheduleTask(task, 0, 0, 0);
 	}
 
 	/** Schedules a task to occur once after the specified delay. */
-	public Task scheduleTask (Task task, float delaySeconds) {
-		return scheduleTask(task, delaySeconds, 0, 0);
+	public void scheduleTask (Task task, float delaySeconds) {
+		scheduleTask(task, delaySeconds, 0, 0);
 	}
 
 	/** Schedules a task to occur once after the specified delay and then repeatedly at the specified interval until cancelled. */
-	public Task scheduleTask (Task task, float delaySeconds, float intervalSeconds) {
-		return scheduleTask(task, delaySeconds, intervalSeconds, FOREVER);
+	public void scheduleTask (Task task, float delaySeconds, float intervalSeconds) {
+		scheduleTask(task, delaySeconds, intervalSeconds, FOREVER);
 	}
 
 	/** Schedules a task to occur once after the specified delay and then a number of additional times at the specified interval. */
-	public Task scheduleTask (Task task, float delaySeconds, float intervalSeconds, int repeatCount) {
+	public void scheduleTask (Task task, float delaySeconds, float intervalSeconds, int repeatCount) {
 		if (task.repeatCount != CANCELLED) throw new IllegalArgumentException("The same task may not be scheduled twice.");
 		task.executeTimeMillis = TimeUtils.nanoTime() / 1000000 + (long)(delaySeconds * 1000);
 		task.intervalMillis = (long)(intervalSeconds * 1000);
@@ -69,7 +69,6 @@ public class Timer {
 			tasks.add(task);
 		}
 		wake();
-		return task;
 	}
 
 	/** Stops the timer, tasks will not be executed and time that passes will not be applied to the task delays. */
@@ -145,26 +144,26 @@ public class Timer {
 
 	/** Schedules a task on {@link #instance}.
 	 * @see #postTask(Task) */
-	static public Task post (Task task) {
-		return instance().postTask(task);
+	static public void post (Task task) {
+		instance().postTask(task);
 	}
 
 	/** Schedules a task on {@link #instance}.
 	 * @see #scheduleTask(Task, float) */
-	static public Task schedule (Task task, float delaySeconds) {
-		return instance().scheduleTask(task, delaySeconds);
+	static public void schedule (Task task, float delaySeconds) {
+		instance().scheduleTask(task, delaySeconds);
 	}
 
 	/** Schedules a task on {@link #instance}.
 	 * @see #scheduleTask(Task, float, float) */
-	static public Task schedule (Task task, float delaySeconds, float intervalSeconds) {
-		return instance().scheduleTask(task, delaySeconds, intervalSeconds);
+	static public void schedule (Task task, float delaySeconds, float intervalSeconds) {
+		instance().scheduleTask(task, delaySeconds, intervalSeconds);
 	}
 
 	/** Schedules a task on {@link #instance}.
 	 * @see #scheduleTask(Task, float, float, int) */
-	static public Task schedule (Task task, float delaySeconds, float intervalSeconds, int repeatCount) {
-		return instance().scheduleTask(task, delaySeconds, intervalSeconds, repeatCount);
+	static public void schedule (Task task, float delaySeconds, float intervalSeconds, int repeatCount) {
+		instance().scheduleTask(task, delaySeconds, intervalSeconds, repeatCount);
 	}
 
 	/** Runnable with a cancel method.
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/preloader/PreloaderBundleGenerator.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/preloader/PreloaderBundleGenerator.java
index 48465ca..ddf304f 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/preloader/PreloaderBundleGenerator.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/preloader/PreloaderBundleGenerator.java
@@ -118,7 +118,7 @@ public class PreloaderBundleGenerator extends Generator {
 		for (Entry<String, ArrayList<Asset>> bundle : bundles.entrySet()) {
 			StringBuffer buffer = new StringBuffer();
 			for (Asset asset : bundle.getValue()) {
-				String path = asset.file.path().replace('\\', '/').replace(assetOutputPath, "").replaceFirst("assets/", "");
+				String path = asset.file.path().replace('\\', '/').replace(assetOutputPath + "assets/", "").replaceFirst("assets", "");
 				if (path.startsWith("/")) path = path.substring(1);
 				buffer.append(asset.type.code);
 				buffer.append(":");
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/GwtReflect.gwt.xml b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/GwtReflect.gwt.xml
index 3fa7c56..b6942db 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/GwtReflect.gwt.xml
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/GwtReflect.gwt.xml
@@ -36,9 +36,6 @@
 		value="com.badlogic.gdx.graphics.g3d.model" />
 
 	<extend-configuration-property name="gdx.reflect.include"
-		value="com.badlogic.gdx.Net" />
-	
-	<extend-configuration-property name="gdx.reflect.include"
 		value="com.badlogic.gdx.graphics.g3d.particles.ParallelArray" />
 		
 	<extend-configuration-property name="gdx.reflect.include"
@@ -47,11 +44,11 @@
 	<extend-configuration-property name="gdx.reflect.include"
 		value="com.badlogic.gdx.graphics.g3d.particles.renderers.BillboardControllerRenderData" />
 	<extend-configuration-property name="gdx.reflect.include"
-		value="com.badlogic.gdx.graphics.g3d.particles.renderers.ModelInstanceControllerRenderData" />
+		value="com.badlogic.gdx.graphics.g3d.particle.renderers.ModelInstanceControllerRenderData" />
 	<extend-configuration-property name="gdx.reflect.include"
-		value="com.badlogic.gdx.graphics.g3d.particles.renderers.ParticleControllerRenderData" />
+		value="com.badlogic.gdx.graphics.g3d.particle.renderers.ParticleControllerRenderData" />
 	<extend-configuration-property name="gdx.reflect.include"
-		value="com.badlogic.gdx.graphics.g3d.particles.renderers.PointSpriteControllerRenderData" />
+		value="com.badlogic.gdx.graphics.g3d.particle.renderers.PointSpriteControllerRenderData" />
     <extend-configuration-property name="gdx.reflect.include"
         value="java.util.Collection" />
 	<extend-configuration-property name="gdx.reflect.include"
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/gen/ReflectionCacheSourceCreator.java b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/gen/ReflectionCacheSourceCreator.java
index 9f2cc80..6e1be51 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/gen/ReflectionCacheSourceCreator.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/gen/ReflectionCacheSourceCreator.java
@@ -322,7 +322,7 @@ public class ReflectionCacheSourceCreator {
 			return "";
 		}
 
-		if ((stub.enclosingType.startsWith("java") && !stub.enclosingType.startsWith("java.util")) || stub.enclosingType.contains("google")) {
+		if (stub.enclosingType.startsWith("java") || stub.enclosingType.contains("google")) {
 			logger.log(Type.INFO, "not emitting code for accessing method " + stub.name + " in class '" + stub.enclosingType
 				+ ", either in java.* or GWT related class");
 			return "";
diff --git a/build-template.xml b/build-template.xml
index ad3b941..1408339 100644
--- a/build-template.xml
+++ b/build-template.xml
@@ -76,11 +76,10 @@ zipfileset id="jarfiles" -> the jar files to be merged with the project's classe
 		<mkdir dir="${libs}/android32" />
 		<mkdir dir="${libs}/armeabi" />
 		<mkdir dir="${libs}/armeabi-v7a" />
-		<mkdir dir="${libs}/x86" />
+        <mkdir dir="${libs}/x86" />
 		<mkdir dir="${libs}/linux32" />
 		<mkdir dir="${libs}/linux64" />
 		<mkdir dir="${libs}/macosx32" />
-		<mkdir dir="${libs}/macosx64" />
 		<mkdir dir="${libs}/windows32" />
 		<mkdir dir="${libs}/windows64" />
 		<mkdir dir="${libs}/ios32"/>
@@ -116,12 +115,12 @@ zipfileset id="jarfiles" -> the jar files to be merged with the project's classe
 				<include name="**/*.so"/>
 			</fileset>
 		</copy>
-		<copy failonerror="false" todir="${distDir}/x86">
+        <copy failonerror="false" todir="${distDir}/x86">
 			<fileset dir="${libs}/x86">
 				<include name="**/*.so"/>
 			</fileset>
 		</copy>
-		<copy failonerror="false" todir="${distDir}/ios">
+        <copy failonerror="false" todir="${distDir}/ios">
 			<fileset dir="${libs}/ios32">
 				<include name="**/*.a"/>
 			</fileset>
@@ -137,7 +136,7 @@ zipfileset id="jarfiles" -> the jar files to be merged with the project's classe
 				<exclude name="*-debug.jar"/>
 				<exclude name="android-*.jar"/>
 				<exclude name="support-*.jar"/>
-				<exclude name="robovm-*.jar"/>
+                <exclude name="robovm-*.jar"/>
 				<exclude name="gwt*.jar"/>
 			</zipgroupfileset>
 			<!-- merge dependencies specified in parent build.xml -->
diff --git a/build.xml b/build.xml
index 7c279b3..61eedb9 100644
--- a/build.xml
+++ b/build.xml
@@ -131,11 +131,10 @@
 
 	<!-- build the extensions -->
 	<!-- gdx tools -->
-	<target name="gdx-tools" depends="gdx-core,gdx-backend-lwjgl,gdx-backend-lwjgl,gdx-backend-headless">
+	<target name="gdx-tools" depends="gdx-core,gdx-backend-lwjgl,gdx-backend-lwjgl">
 		<path id="classpath">
 			<pathelement location="${distDir}/gdx.jar"/>
 			<pathelement location="${distDir}/gdx-backend-lwjgl.jar"/>
-			<pathelement location="${distDir}/gdx-backend-headless.jar"/>
 		</path>
 		<fileset id="resourcefiles" dir="extensions/gdx-tools/assets"/>
 		<ant antfile="../../build-template.xml" dir="extensions/gdx-tools">
diff --git a/extensions/gdx-box2d/gdx-box2d-gwt/pom.xml b/extensions/gdx-box2d/gdx-box2d-gwt/pom.xml
index 0475024..9caf47b 100644
--- a/extensions/gdx-box2d/gdx-box2d-gwt/pom.xml
+++ b/extensions/gdx-box2d/gdx-box2d-gwt/pom.xml
@@ -4,7 +4,7 @@
 	<parent>
 		<groupId>com.badlogicgames.gdx</groupId>
 		<artifactId>gdx-box2d-parent</artifactId>
-		<version>1.5.4-SNAPSHOT</version>
+		<version>1.4.2-SNAPSHOT</version>
 		<relativePath>../pom.xml</relativePath>
 	</parent>
 
diff --git a/extensions/gdx-box2d/gdx-box2d-gwt/src/com/badlogic/gdx/physics/box2d/gwt/emu/com/badlogic/gdx/physics/box2d/joints/RopeJoint.java b/extensions/gdx-box2d/gdx-box2d-gwt/src/com/badlogic/gdx/physics/box2d/gwt/emu/com/badlogic/gdx/physics/box2d/joints/RopeJoint.java
index cdb82a7..c488c49 100644
--- a/extensions/gdx-box2d/gdx-box2d-gwt/src/com/badlogic/gdx/physics/box2d/gwt/emu/com/badlogic/gdx/physics/box2d/joints/RopeJoint.java
+++ b/extensions/gdx-box2d/gdx-box2d-gwt/src/com/badlogic/gdx/physics/box2d/gwt/emu/com/badlogic/gdx/physics/box2d/joints/RopeJoint.java
@@ -53,9 +53,4 @@ public class RopeJoint extends Joint {
 	public float getMaxLength () {
 		return joint.getMaxLength();
 	}
-	
-	public void setMaxLength (float maxLength) {
-		joint.setMaxLength(maxLength);
-	}
-	
 }
diff --git a/extensions/gdx-box2d/gdx-box2d-gwt/src/com/badlogic/gdx/physics/box2d/gwt/emu/com/badlogic/gdx/physics/box2d/joints/WeldJoint.java b/extensions/gdx-box2d/gdx-box2d-gwt/src/com/badlogic/gdx/physics/box2d/gwt/emu/com/badlogic/gdx/physics/box2d/joints/WeldJoint.java
index 137c14e..3096a18 100644
--- a/extensions/gdx-box2d/gdx-box2d-gwt/src/com/badlogic/gdx/physics/box2d/gwt/emu/com/badlogic/gdx/physics/box2d/joints/WeldJoint.java
+++ b/extensions/gdx-box2d/gdx-box2d-gwt/src/com/badlogic/gdx/physics/box2d/gwt/emu/com/badlogic/gdx/physics/box2d/joints/WeldJoint.java
@@ -47,23 +47,6 @@ public class WeldJoint extends Joint {
 	}
 
 	public float getReferenceAngle () {
-		return joint.getReferenceAngle();
+		return 0;
 	}
-	
-	public float getFrequency () {
-		return joint.getFrequency();
-	}
-	
-	public void setFrequency (float frequencyHz) {
-		joint.setFrequency(frequencyHz);
-	}
-	
-	public float getDampingRatio () {
-		return joint.getDampingRatio();
-	}
-	
-	public void setDampingRatio (float dampingRatio) {
-		joint.setDampingRatio(dampingRatio);
-	}
-	
 }
diff --git a/extensions/gdx-box2d/gdx-box2d/jni/build-ios32.xml b/extensions/gdx-box2d/gdx-box2d/jni/build-ios32.xml
index 712691c..72c455a 100644
--- a/extensions/gdx-box2d/gdx-box2d/jni/build-ios32.xml
+++ b/extensions/gdx-box2d/gdx-box2d/jni/build-ios32.xml
@@ -70,7 +70,7 @@
 				<exclude name="*.o"/>
 			</fileset>
 		</delete>
-	</target>		
+	</target>
 
 	<!-- compiles all C and C++ files to object files in the build directory, for 386 builds-->
 	<target name="compile-386" depends="clean,create-build-dir">
@@ -124,61 +124,8 @@
 	</target>
 	
 	<!-- compiles all C and C++ files to object files in the build directory, for 386 builds-->
-	<target name="compile-x86_64" depends="create-build-dir">
-		<mkdir dir="${buildDir}"/>
-		<antcall target="clean-objfiles"/>
-		<apply failonerror="true" executable="${g++}" dest="${buildDir}" verbose="true">
-			<arg line="-isysroot ${iphonesimulator-sdk} -arch x86_64 ${g++-opts}"/>
-			<arg value="-Ijni-headers"/>
-			<arg value="-Ijni-headers/${jniPlatform}"/>
-			<arg value="-I."/>
-			
-			<srcfile/>
-			<arg value="-o"/>
-			<targetfile/>
-			<fileset refid="g++-files"/>
-			<compositemapper>
-				<mapper type="glob" from="*.cpp" to="*.o"/>
-				<mapper type="glob" from="*.mm" to="*.o"/>
-			</compositemapper>
-		</apply>
-		<apply failonerror="true" executable="${gcc}" dest="${buildDir}" verbose="true">
-			<arg line="-isysroot ${iphonesimulator-sdk} -arch x86_64 ${gcc-opts}"/>
-			<arg value="-Ijni-headers"/>
-			<arg value="-Ijni-headers/${jniPlatform}"/>
-			<arg value="-I."/>
-			
-			<srcfile/>
-			<arg value="-o"/>
-			<targetfile/>
-			<fileset refid="gcc-files"/>
-			<compositemapper>
-				<mapper type="glob" from="*.c" to="*.o"/>
-			</compositemapper>
-		</apply>
-	</target>	
-
-	<!-- links the shared library based on the previously compiled object files -->
-	<target name="link-x86_64" depends="compile-x86_64">
-		<fileset dir="${buildDir}" id="objFileSet">
-			<patternset>
-				<include name="**/*.o" />
-			</patternset>
-		</fileset>
-		<pathconvert pathsep=" " property="objFiles" refid="objFileSet" />
-		<mkdir dir="${libsDir}" />
-		<exec executable="${linker}" failonerror="true" dir="${buildDir}">
-			<arg line="${linker-opts}" />
-			<arg path="${libsDir}/${libName}.x86_64" />
-			<arg line="${objFiles}"/>
-			<arg line="${libraries}" />
-		</exec>
-	</target>
-	
-	<!-- compiles all C and C++ files to object files in the build directory, for 386 builds-->
-	<target name="compile-arm" depends="create-build-dir">
+	<target name="compile-arm" depends="create-build-dir,clean-objfiles">
 		<mkdir dir="${buildDir}"/>
-		<antcall target="clean-objfiles"/>
 		<apply failonerror="true" executable="${g++}" dest="${buildDir}" verbose="true">
 			<arg line="-isysroot ${iphoneos-sdk} -arch armv7 ${g++-opts}"/>
 			<arg value="-Ijni-headers"/>
@@ -226,66 +173,14 @@
 			<arg line="${libraries}" />
 		</exec>
 	</target>
-	
-		<!-- compiles all C and C++ files to object files in the build directory, for 386 builds-->
-	<target name="compile-arm64" depends="create-build-dir,clean-objfiles">
-		<mkdir dir="${buildDir}"/>
-		<antcall target="clean-objfiles"/>
-		<apply failonerror="true" executable="${g++}" dest="${buildDir}" verbose="true">
-			<arg line="-isysroot ${iphoneos-sdk} -arch arm64 ${g++-opts}"/>
-			<arg value="-Ijni-headers"/>
-			<arg value="-Ijni-headers/${jniPlatform}"/>
-			<arg value="-I."/>
-			
-			<srcfile/>
-			<arg value="-o"/>
-			<targetfile/>
-			<fileset refid="g++-files"/>
-			<compositemapper>
-				<mapper type="glob" from="*.cpp" to="*.o"/>
-				<mapper type="glob" from="*.mm" to="*.o"/>
-			</compositemapper>
-		</apply>
-		<apply failonerror="true" executable="${gcc}" dest="${buildDir}" verbose="true">
-			<arg line="-isysroot ${iphoneos-sdk} -arch arm64 ${gcc-opts}"/>
-			<arg value="-Ijni-headers"/>
-			<arg value="-Ijni-headers/${jniPlatform}"/>
-			<arg value="-I."/>
-			
-			<srcfile/>
-			<arg value="-o"/>
-			<targetfile/>
-			<fileset refid="gcc-files"/>
-			<compositemapper>
-				<mapper type="glob" from="*.c" to="*.o"/>
-			</compositemapper>
-		</apply>
-	</target>	
-
-	<!-- links the shared library based on the previously compiled object files -->
-	<target name="link-arm64" depends="compile-arm64">
-		<fileset dir="${buildDir}" id="objFileSet">
-			<patternset>
-				<include name="**/*.o" />
-			</patternset>
-		</fileset>
-		<pathconvert pathsep=" " property="objFiles" refid="objFileSet" />
-		<mkdir dir="${libsDir}" />
-		<exec executable="${linker}" failonerror="true" dir="${buildDir}">
-			<arg line="${linker-opts}" />
-			<arg path="${libsDir}/${libName}.arm64" />
-			<arg line="${objFiles}"/>
-			<arg line="${libraries}" />
-		</exec>
-	</target>
 
 	<target name="link-fat">
 		<exec executable="lipo" failonerror="true" dir="${libsDir}">
-			<arg line="-create -output ${libName} ${libName}.386 ${libName}.x86_64 ${libName}.armv7 ${libName}.arm64"/>
+			<arg line="-create -output ${libName} ${libName}.386 ${libName}.armv7"/>
 		</exec>
 	</target>
 
-	<target name="postcompile" depends="link-386,link-x86_64,link-arm,link-arm64,link-fat">
+	<target name="postcompile" depends="link-386,link-arm,link-fat">
 		
 	</target>
 </project>
diff --git a/extensions/gdx-box2d/gdx-box2d/jni/com.badlogic.gdx.physics.box2d.Body.cpp b/extensions/gdx-box2d/gdx-box2d/jni/com.badlogic.gdx.physics.box2d.Body.cpp
index 5a89da4..c8b6825 100644
--- a/extensions/gdx-box2d/gdx-box2d/jni/com.badlogic.gdx.physics.box2d.Body.cpp
+++ b/extensions/gdx-box2d/gdx-box2d/jni/com.badlogic.gdx.physics.box2d.Body.cpp
@@ -38,10 +38,22 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniCreateFixtur
 
 }
 
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniDestroyFixture(JNIEnv* env, jobject object, jlong addr, jlong fixtureAddr) {
+
+
+//@line:133
+
+		b2Body* body = (b2Body*)addr;
+		b2Fixture* fixture = (b2Fixture*)fixtureAddr;
+		body->DestroyFixture(fixture);
+	
+
+}
+
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniSetTransform(JNIEnv* env, jobject object, jlong addr, jfloat positionX, jfloat positionY, jfloat angle) {
 
 
-//@line:151
+//@line:156
 
 		b2Body* body = (b2Body*)addr;
 		body->SetTransform(b2Vec2(positionX, positionY), angle);
@@ -53,7 +65,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetTransform(
 	float* vals = (float*)env->GetPrimitiveArrayCritical(obj_vals, 0);
 
 
-//@line:164
+//@line:169
 
 		b2Body* body = (b2Body*)addr;
 		b2Transform t = body->GetTransform();
@@ -70,7 +82,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetPosition(J
 	float* position = (float*)env->GetPrimitiveArrayCritical(obj_position, 0);
 
 
-//@line:185
+//@line:190
 
 		b2Body* body = (b2Body*)addr;
 		b2Vec2 p = body->GetPosition();
@@ -84,7 +96,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetPosition(J
 JNIEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetAngle(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:198
+//@line:203
 
 		b2Body* body = (b2Body*)addr;
 		return body->GetAngle();
@@ -96,7 +108,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetWorldCente
 	float* worldCenter = (float*)env->GetPrimitiveArrayCritical(obj_worldCenter, 0);
 
 
-//@line:214
+//@line:219
 
 		b2Body* body = (b2Body*)addr;
 		b2Vec2 w = body->GetWorldCenter();
@@ -111,7 +123,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetLocalCente
 	float* localCenter = (float*)env->GetPrimitiveArrayCritical(obj_localCenter, 0);
 
 
-//@line:232
+//@line:237
 
 		b2Body* body = (b2Body*)addr;
 		b2Vec2 w = body->GetLocalCenter();
@@ -125,7 +137,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetLocalCente
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniSetLinearVelocity(JNIEnv* env, jobject object, jlong addr, jfloat x, jfloat y) {
 
 
-//@line:249
+//@line:254
 
 		b2Body* body = (b2Body*)addr;
 		body->SetLinearVelocity(b2Vec2(x, y));
@@ -137,7 +149,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetLinearVelo
 	float* linearVelocity = (float*)env->GetPrimitiveArrayCritical(obj_linearVelocity, 0);
 
 
-//@line:265
+//@line:270
 
 		b2Body* body = (b2Body*)addr;
 		b2Vec2 l = body->GetLinearVelocity();
@@ -151,7 +163,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetLinearVelo
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniSetAngularVelocity(JNIEnv* env, jobject object, jlong addr, jfloat omega) {
 
 
-//@line:277
+//@line:282
 
 		b2Body* body = (b2Body*)addr;
 		body->SetAngularVelocity(omega);
@@ -162,7 +174,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniSetAngularVel
 JNIEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetAngularVelocity(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:287
+//@line:292
 
 		b2Body* body = (b2Body*)addr;
 		return body->GetAngularVelocity();
@@ -173,7 +185,7 @@ JNIEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetAngularV
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniApplyForce(JNIEnv* env, jobject object, jlong addr, jfloat forceX, jfloat forceY, jfloat pointX, jfloat pointY, jboolean wake) {
 
 
-//@line:312
+//@line:317
 
 		b2Body* body = (b2Body*)addr;
 		body->ApplyForce(b2Vec2(forceX, forceY), b2Vec2(pointX, pointY), wake);
@@ -184,7 +196,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniApplyForce(JN
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniApplyForceToCenter(JNIEnv* env, jobject object, jlong addr, jfloat forceX, jfloat forceY, jboolean wake) {
 
 
-//@line:330
+//@line:335
 
 		b2Body* body = (b2Body*)addr;
 		body->ApplyForceToCenter(b2Vec2(forceX, forceY), wake);
@@ -195,7 +207,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniApplyForceToC
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniApplyTorque(JNIEnv* env, jobject object, jlong addr, jfloat torque, jboolean wake) {
 
 
-//@line:343
+//@line:348
 
 		b2Body* body = (b2Body*)addr;
 		body->ApplyTorque(torque, wake);
@@ -206,7 +218,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniApplyTorque(J
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniApplyLinearImpulse(JNIEnv* env, jobject object, jlong addr, jfloat impulseX, jfloat impulseY, jfloat pointX, jfloat pointY, jboolean wake) {
 
 
-//@line:368
+//@line:373
 
 		b2Body* body = (b2Body*)addr;
 		body->ApplyLinearImpulse( b2Vec2( impulseX, impulseY ), b2Vec2( pointX, pointY ), wake);
@@ -217,7 +229,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniApplyLinearIm
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniApplyAngularImpulse(JNIEnv* env, jobject object, jlong addr, jfloat impulse, jboolean wake) {
 
 
-//@line:379
+//@line:384
 
 		b2Body* body = (b2Body*)addr;
 		body->ApplyAngularImpulse(impulse, wake);
@@ -228,7 +240,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniApplyAngularI
 JNIEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetMass(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:390
+//@line:395
 
 		b2Body* body = (b2Body*)addr;
 		return body->GetMass();
@@ -239,7 +251,7 @@ JNIEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetMass(JNI
 JNIEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetInertia(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:401
+//@line:406
 
 		b2Body* body = (b2Body*)addr;
 		return body->GetInertia();
@@ -251,7 +263,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetMassData(J
 	float* massData = (float*)env->GetPrimitiveArrayCritical(obj_massData, 0);
 
 
-//@line:419
+//@line:424
 
 		b2Body* body = (b2Body*)addr;
 		b2MassData m;
@@ -268,7 +280,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetMassData(J
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniSetMassData(JNIEnv* env, jobject object, jlong addr, jfloat mass, jfloat centerX, jfloat centerY, jfloat I) {
 
 
-//@line:436
+//@line:441
 
 		b2Body* body = (b2Body*)addr;
 		b2MassData m;
@@ -284,7 +296,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniSetMassData(J
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniResetMassData(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:452
+//@line:457
 
 		b2Body* body = (b2Body*)addr;
 		body->ResetMassData();
@@ -296,7 +308,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetWorldPoint
 	float* worldPoint = (float*)env->GetPrimitiveArrayCritical(obj_worldPoint, 0);
 
 
-//@line:470
+//@line:475
 
 		b2Body* body = (b2Body*)addr;
 		b2Vec2 w = body->GetWorldPoint( b2Vec2( localPointX, localPointY ) );
@@ -311,7 +323,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetWorldVecto
 	float* worldVector = (float*)env->GetPrimitiveArrayCritical(obj_worldVector, 0);
 
 
-//@line:490
+//@line:495
 
 		b2Body* body = (b2Body*)addr;
 		b2Vec2 w = body->GetWorldVector( b2Vec2( localVectorX, localVectorY ) );
@@ -326,7 +338,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetLocalPoint
 	float* localPoint = (float*)env->GetPrimitiveArrayCritical(obj_localPoint, 0);
 
 
-//@line:510
+//@line:515
 
 		b2Body* body = (b2Body*)addr;
 		b2Vec2 w = body->GetLocalPoint( b2Vec2( worldPointX, worldPointY ) );
@@ -341,7 +353,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetLocalVecto
 	float* worldVector = (float*)env->GetPrimitiveArrayCritical(obj_worldVector, 0);
 
 
-//@line:530
+//@line:535
 
 		b2Body* body = (b2Body*)addr;
 		b2Vec2 w = body->GetLocalVector( b2Vec2( worldVectorX, worldVectorY ) );
@@ -356,7 +368,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetLinearVelo
 	float* linVelWorld = (float*)env->GetPrimitiveArrayCritical(obj_linVelWorld, 0);
 
 
-//@line:550
+//@line:555
 
 		b2Body* body = (b2Body*)addr;
 		b2Vec2 w = body->GetLinearVelocityFromWorldPoint( b2Vec2( worldPointX, worldPointY ) );
@@ -371,7 +383,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetLinearVelo
 	float* linVelLoc = (float*)env->GetPrimitiveArrayCritical(obj_linVelLoc, 0);
 
 
-//@line:570
+//@line:575
 
 		b2Body* body = (b2Body*)addr;
 		b2Vec2 w = body->GetLinearVelocityFromLocalPoint( b2Vec2( localPointX, localPointY ) );
@@ -385,7 +397,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetLinearVelo
 JNIEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetLinearDamping(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:582
+//@line:587
 
 		b2Body* body = (b2Body*)addr;
 		return body->GetLinearDamping();
@@ -396,7 +408,7 @@ JNIEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetLinearDa
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniSetLinearDamping(JNIEnv* env, jobject object, jlong addr, jfloat linearDamping) {
 
 
-//@line:592
+//@line:597
 
 		b2Body* body = (b2Body*)addr;
 		body->SetLinearDamping(linearDamping);
@@ -407,7 +419,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniSetLinearDamp
 JNIEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetAngularDamping(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:602
+//@line:607
 
 		b2Body* body = (b2Body*)addr;
 		return body->GetAngularDamping();
@@ -418,7 +430,7 @@ JNIEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetAngularD
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniSetAngularDamping(JNIEnv* env, jobject object, jlong addr, jfloat angularDamping) {
 
 
-//@line:612
+//@line:617
 
 		b2Body* body = (b2Body*)addr;
 		body->SetAngularDamping(angularDamping);
@@ -427,7 +439,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniSetAngularDam
 }
 
 
-//@line:623
+//@line:628
 
 inline b2BodyType getBodyType( int type )
 {
@@ -443,7 +455,7 @@ inline b2BodyType getBodyType( int type )
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniSetType(JNIEnv* env, jobject object, jlong addr, jint type) {
 
 
-//@line:637
+//@line:642
 
 		b2Body* body = (b2Body*)addr;
 		body->SetType(getBodyType(type));
@@ -454,7 +466,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniSetType(JNIEn
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetType(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:651
+//@line:656
 
 		b2Body* body = (b2Body*)addr;
 		return body->GetType();
@@ -465,7 +477,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetType(JNIEn
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniSetBullet(JNIEnv* env, jobject object, jlong addr, jboolean flag) {
 
 
-//@line:661
+//@line:666
 
 		b2Body* body = (b2Body*)addr;
 		body->SetBullet(flag);
@@ -476,7 +488,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniSetBullet(JNI
 JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniIsBullet(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:671
+//@line:676
 
 		b2Body* body = (b2Body*)addr;
 		return body->IsBullet();
@@ -487,7 +499,7 @@ JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniIsBullet(
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniSetSleepingAllowed(JNIEnv* env, jobject object, jlong addr, jboolean flag) {
 
 
-//@line:681
+//@line:686
 
 		b2Body* body = (b2Body*)addr;
 		body->SetSleepingAllowed(flag);
@@ -498,7 +510,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniSetSleepingAl
 JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniIsSleepingAllowed(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:691
+//@line:696
 
 		b2Body* body = (b2Body*)addr;
 		return body->IsSleepingAllowed();
@@ -509,7 +521,7 @@ JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniIsSleepin
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniSetAwake(JNIEnv* env, jobject object, jlong addr, jboolean flag) {
 
 
-//@line:702
+//@line:707
 
 		b2Body* body = (b2Body*)addr;
 		body->SetAwake(flag);
@@ -520,7 +532,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniSetAwake(JNIE
 JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniIsAwake(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:713
+//@line:718
 
 		b2Body* body = (b2Body*)addr;
 		return body->IsAwake();
@@ -531,7 +543,7 @@ JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniIsAwake(J
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniSetActive(JNIEnv* env, jobject object, jlong addr, jboolean flag) {
 
 
-//@line:732
+//@line:733
 
 		b2Body* body = (b2Body*)addr;
 		body->SetActive(flag);
@@ -542,7 +554,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniSetActive(JNI
 JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniIsActive(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:742
+//@line:743
 
 		b2Body* body = (b2Body*)addr;
 		return body->IsActive();
@@ -553,7 +565,7 @@ JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniIsActive(
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniSetFixedRotation(JNIEnv* env, jobject object, jlong addr, jboolean flag) {
 
 
-//@line:752
+//@line:753
 
 		b2Body* body = (b2Body*)addr;
 		body->SetFixedRotation(flag);
@@ -564,7 +576,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniSetFixedRotat
 JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniIsFixedRotation(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:762
+//@line:763
 
 		b2Body* body = (b2Body*)addr;
 		return body->IsFixedRotation();
@@ -575,7 +587,7 @@ JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniIsFixedRo
 JNIEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetGravityScale(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:790
+//@line:791
 
 		b2Body* body = (b2Body*)addr;
 		return body->GetGravityScale();
@@ -586,7 +598,7 @@ JNIEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniGetGravityS
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniSetGravityScale(JNIEnv* env, jobject object, jlong addr, jfloat scale) {
 
 
-//@line:800
+//@line:801
 
 		b2Body* body = (b2Body*)addr;
 		body->SetGravityScale(scale);
diff --git a/extensions/gdx-box2d/gdx-box2d/jni/com.badlogic.gdx.physics.box2d.Body.h b/extensions/gdx-box2d/gdx-box2d/jni/com.badlogic.gdx.physics.box2d.Body.h
index bc28506..6b6de08 100644
--- a/extensions/gdx-box2d/gdx-box2d/jni/com.badlogic.gdx.physics.box2d.Body.h
+++ b/extensions/gdx-box2d/gdx-box2d/jni/com.badlogic.gdx.physics.box2d.Body.h
@@ -25,6 +25,14 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniCreateFixtur
 
 /*
  * Class:     com_badlogic_gdx_physics_box2d_Body
+ * Method:    jniDestroyFixture
+ * Signature: (JJ)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_Body_jniDestroyFixture
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     com_badlogic_gdx_physics_box2d_Body
  * Method:    jniSetTransform
  * Signature: (JFFF)V
  */
diff --git a/extensions/gdx-box2d/gdx-box2d/jni/com.badlogic.gdx.physics.box2d.World.cpp b/extensions/gdx-box2d/gdx-box2d/jni/com.badlogic.gdx.physics.box2d.World.cpp
index d1674a3..92d78a7 100644
--- a/extensions/gdx-box2d/gdx-box2d/jni/com.badlogic.gdx.physics.box2d.World.cpp
+++ b/extensions/gdx-box2d/gdx-box2d/jni/com.badlogic.gdx.physics.box2d.World.cpp
@@ -208,47 +208,10 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDestroyBody(
 
 }
 
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDestroyFixture(JNIEnv* env, jobject object, jlong addr, jlong bodyAddr, jlong fixtureAddr) {
-
-
-//@line:354
-
-		b2World* world = (b2World*)(addr);
-		b2Body* body = (b2Body*)(bodyAddr);
-		b2Fixture* fixture = (b2Fixture*)(fixtureAddr);
-		CustomContactFilter contactFilter(env, object);
-		CustomContactListener contactListener(env, object);
-		world->SetContactFilter(&contactFilter);
-		world->SetContactListener(&contactListener);
-		body->DestroyFixture(fixture);
-		world->SetContactFilter(&defaultFilter);
-		world->SetContactListener(0);
-	
-
-}
-
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDeactivateBody(JNIEnv* env, jobject object, jlong addr, jlong bodyAddr) {
-
-
-//@line:374
-
-		b2World* world = (b2World*)(addr);
-		b2Body* body = (b2Body*)(bodyAddr);	
-		CustomContactFilter contactFilter(env, object);
-		CustomContactListener contactListener(env, object);
-		world->SetContactFilter(&contactFilter);
-		world->SetContactListener(&contactListener);
-		body->SetActive(false);
-		world->SetContactFilter(&defaultFilter);
-		world->SetContactListener(0);
-	
-
-}
-
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateWheelJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat localAxisAX, jfloat localAxisAY, jboolean enableMotor, jfloat maxMotorTorque, jfloat motorSpeed, jfloat frequencyHz, jfloat dampingRatio) {
 
 
-//@line:479
+//@line:438
 
 		b2World* world = (b2World*)addr;
 		b2WheelJointDef def;
@@ -272,7 +235,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateWheel
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateRopeJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat maxLength) {
 
 
-//@line:498
+//@line:457
 
 		b2World* world = (b2World*)addr;
 		b2RopeJointDef def;
@@ -291,7 +254,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateRopeJ
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateDistanceJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat length, jfloat frequencyHz, jfloat dampingRatio) {
 
 
-//@line:512
+//@line:471
 
 		b2World* world = (b2World*)addr;
 		b2DistanceJointDef def;
@@ -312,7 +275,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateDista
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateFrictionJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat maxForce, jfloat maxTorque) {
 
 
-//@line:528
+//@line:487
 
 		b2World* world = (b2World*)addr;
 		b2FrictionJointDef def;
@@ -331,7 +294,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateFrict
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateGearJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jlong joint1, jlong joint2, jfloat ratio) {
 
 
-//@line:542
+//@line:501
 
 		b2World* world = (b2World*)addr;
 		b2GearJointDef def;
@@ -349,7 +312,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateGearJ
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateMotorJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat linearOffsetX, jfloat linearOffsetY, jfloat angularOffset, jfloat maxForce, jfloat maxTorque, jfloat correctionFactor) {
 
 
-//@line:555
+//@line:514
 
 		b2World* world = (b2World*)addr;
 		b2MotorJointDef def;
@@ -369,7 +332,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateMotor
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateMouseJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat targetX, jfloat targetY, jfloat maxForce, jfloat frequencyHz, jfloat dampingRatio) {
 
 
-//@line:570
+//@line:529
 
 		b2World* world = (b2World*)addr;
 		b2MouseJointDef def;
@@ -388,7 +351,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateMouse
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreatePrismaticJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat localAxisAX, jfloat localAxisAY, jfloat referenceAngle, jboolean enableLimit, jfloat lowerTranslation, jfloat upperTranslation, jboolean enableMotor, jfloat maxMotorForce, jfloat motorSpeed) {
 
 
-//@line:586
+//@line:545
 
 		b2World* world = (b2World*)addr;
 		b2PrismaticJointDef def;
@@ -413,7 +376,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreatePrism
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreatePulleyJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat groundAnchorAX, jfloat groundAnchorAY, jfloat groundAnchorBX, jfloat groundAnchorBY, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat lengthA, jfloat lengthB, jfloat ratio) {
 
 
-//@line:607
+//@line:566
 
 		b2World* world = (b2World*)addr;
 		b2PulleyJointDef def;
@@ -436,7 +399,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreatePulle
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateRevoluteJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat referenceAngle, jboolean enableLimit, jfloat lowerAngle, jfloat upperAngle, jboolean enableMotor, jfloat motorSpeed, jfloat maxMotorTorque) {
 
 
-//@line:626
+//@line:585
 
 		b2World* world = (b2World*)addr;
 		b2RevoluteJointDef def;
@@ -460,7 +423,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateRevol
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateWeldJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat referenceAngle, jfloat frequencyHz, jfloat dampingRatio) {
 
 
-//@line:645
+//@line:604
 
 		b2World* world = (b2World*)addr;
 		b2WeldJointDef def;
@@ -481,7 +444,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateWeldJ
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDestroyJoint(JNIEnv* env, jobject object, jlong addr, jlong jointAddr) {
 
 
-//@line:670
+//@line:629
 
 		b2World* world = (b2World*)addr;
 		b2Joint* joint = (b2Joint*)jointAddr;
@@ -499,7 +462,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDestroyJoint
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniStep(JNIEnv* env, jobject object, jlong addr, jfloat timeStep, jint velocityIterations, jint positionIterations) {
 
 
-//@line:690
+//@line:649
 
 		b2World* world = (b2World*)addr;
 		CustomContactFilter contactFilter(env, object);
@@ -516,7 +479,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniStep(JNIEnv*
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniClearForces(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:710
+//@line:669
 
 		b2World* world = (b2World*)addr;
 		world->ClearForces();
@@ -527,7 +490,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniClearForces(
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniSetWarmStarting(JNIEnv* env, jobject object, jlong addr, jboolean flag) {
 
 
-//@line:720
+//@line:679
 
 		b2World* world = (b2World*)addr;
 		world->SetWarmStarting(flag);
@@ -538,7 +501,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniSetWarmStart
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniSetContiousPhysics(JNIEnv* env, jobject object, jlong addr, jboolean flag) {
 
 
-//@line:730
+//@line:689
 
 		b2World* world = (b2World*)addr;
 		world->SetContinuousPhysics(flag);
@@ -549,7 +512,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniSetContiousP
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetProxyCount(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:740
+//@line:699
 
 		b2World* world = (b2World*)addr;
 		return world->GetProxyCount();
@@ -560,7 +523,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetProxyCoun
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetBodyCount(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:750
+//@line:709
 
 		b2World* world = (b2World*)addr;
 		return world->GetBodyCount();
@@ -571,7 +534,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetBodyCount
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetJointcount(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:765
+//@line:719
 
 		b2World* world = (b2World*)addr;
 		return world->GetJointCount();
@@ -582,7 +545,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetJointcoun
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetContactCount(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:775
+//@line:729
 
 		b2World* world = (b2World*)addr;
 		return world->GetContactCount();
@@ -593,7 +556,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetContactCo
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniSetGravity(JNIEnv* env, jobject object, jlong addr, jfloat gravityX, jfloat gravityY) {
 
 
-//@line:785
+//@line:739
 
 		b2World* world = (b2World*)addr;
 		world->SetGravity( b2Vec2( gravityX, gravityY ) );
@@ -605,7 +568,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetGravity(J
 	float* gravity = (float*)env->GetPrimitiveArrayCritical(obj_gravity, 0);
 
 
-//@line:801
+//@line:755
 
 		b2World* world = (b2World*)addr;
 		b2Vec2 g = world->GetGravity();
@@ -619,7 +582,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetGravity(J
 JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniIsLocked(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:813
+//@line:767
 
 		b2World* world = (b2World*)addr;
 		return world->IsLocked();
@@ -630,7 +593,7 @@ JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniIsLocked
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniSetAutoClearForces(JNIEnv* env, jobject object, jlong addr, jboolean flag) {
 
 
-//@line:823
+//@line:777
 
 		b2World* world = (b2World*)addr;
 		world->SetAutoClearForces(flag);
@@ -641,7 +604,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniSetAutoClear
 JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetAutoClearForces(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:833
+//@line:787
 
 		b2World* world = (b2World*)addr;
 		return world->GetAutoClearForces();
@@ -652,7 +615,7 @@ JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetAutoC
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniQueryAABB(JNIEnv* env, jobject object, jlong addr, jfloat lowX, jfloat lowY, jfloat upX, jfloat upY) {
 
 
-//@line:851
+//@line:805
 
 		b2World* world = (b2World*)addr;
 		b2AABB aabb;
@@ -669,7 +632,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetContactLi
 	long long* contacts = (long long*)env->GetPrimitiveArrayCritical(obj_contacts, 0);
 
 
-//@line:936
+//@line:881
 
 		b2World* world = (b2World*)addr;
 	
@@ -688,7 +651,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetContactLi
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDispose(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:952
+//@line:897
 
 		b2World* world = (b2World*)(addr);
 		delete world;
@@ -699,7 +662,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDispose(JNIE
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_setVelocityThreshold(JNIEnv* env, jclass clazz, jfloat threshold) {
 
 
-//@line:1012
+//@line:957
 
 		b2_velocityThreshold = threshold;
 	
@@ -709,7 +672,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_setVelocityThre
 JNIEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_box2d_World_getVelocityThreshold(JNIEnv* env, jclass clazz) {
 
 
-//@line:1017
+//@line:962
 
 		return b2_velocityThreshold;
 	
@@ -719,7 +682,7 @@ JNIEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_box2d_World_getVelocityTh
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniRayCast(JNIEnv* env, jobject object, jlong addr, jfloat aX, jfloat aY, jfloat bX, jfloat bY) {
 
 
-//@line:1032
+//@line:977
 
 		b2World *world = (b2World*)addr;
 		CustomRayCastCallback callback( env, object );	
diff --git a/extensions/gdx-box2d/gdx-box2d/jni/com.badlogic.gdx.physics.box2d.World.h b/extensions/gdx-box2d/gdx-box2d/jni/com.badlogic.gdx.physics.box2d.World.h
index 7e9eef6..86774fa 100644
--- a/extensions/gdx-box2d/gdx-box2d/jni/com.badlogic.gdx.physics.box2d.World.h
+++ b/extensions/gdx-box2d/gdx-box2d/jni/com.badlogic.gdx.physics.box2d.World.h
@@ -41,22 +41,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDestroyBody
 
 /*
  * Class:     com_badlogic_gdx_physics_box2d_World
- * Method:    jniDestroyFixture
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDestroyFixture
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     com_badlogic_gdx_physics_box2d_World
- * Method:    jniDeactivateBody
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDeactivateBody
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     com_badlogic_gdx_physics_box2d_World
  * Method:    jniCreateWheelJoint
  * Signature: (JJJZFFFFFFZFFFF)J
  */
diff --git a/extensions/gdx-box2d/gdx-box2d/jni/maven/pom.xml b/extensions/gdx-box2d/gdx-box2d/jni/maven/pom.xml
index 523db35..3bb57ad 100644
--- a/extensions/gdx-box2d/gdx-box2d/jni/maven/pom.xml
+++ b/extensions/gdx-box2d/gdx-box2d/jni/maven/pom.xml
@@ -4,7 +4,7 @@
     <parent>
         <groupId>com.badlogicgames.gdx</groupId>
         <artifactId>gdx-parent</artifactId>
-        <version>1.5.4-SNAPSHOT</version>
+        <version>1.4.2-SNAPSHOT</version>
         <relativePath>../../../../../</relativePath>
     </parent>
     
diff --git a/extensions/gdx-box2d/gdx-box2d/pom.xml b/extensions/gdx-box2d/gdx-box2d/pom.xml
index 29bf174..3ae7855 100644
--- a/extensions/gdx-box2d/gdx-box2d/pom.xml
+++ b/extensions/gdx-box2d/gdx-box2d/pom.xml
@@ -4,7 +4,7 @@
 	<parent>
 		<groupId>com.badlogicgames.gdx</groupId>
 		<artifactId>gdx-box2d-parent</artifactId>
-		<version>1.5.4-SNAPSHOT</version>
+		<version>1.4.2-SNAPSHOT</version>
 		<relativePath>../pom.xml</relativePath>
 	</parent>
 
diff --git a/extensions/gdx-box2d/gdx-box2d/src/com/badlogic/gdx/physics/box2d/Body.java b/extensions/gdx-box2d/gdx-box2d/src/com/badlogic/gdx/physics/box2d/Body.java
index 43e67c7..58e18f5 100644
--- a/extensions/gdx-box2d/gdx-box2d/src/com/badlogic/gdx/physics/box2d/Body.java
+++ b/extensions/gdx-box2d/gdx-box2d/src/com/badlogic/gdx/physics/box2d/Body.java
@@ -124,13 +124,18 @@ public class Body {
 	 * @param fixture the fixture to be removed.
 	 * @warning This function is locked during callbacks. */
 	public void destroyFixture (Fixture fixture) {
-		this.world.destroyFixture(this, fixture);
-		fixture.setUserData(null);
+		jniDestroyFixture(addr, fixture.addr);
 		this.world.fixtures.remove(fixture.addr);
 		this.fixtures.removeValue(fixture, true);
 		this.world.freeFixtures.free(fixture);
 	}
 
+	private native void jniDestroyFixture (long addr, long fixtureAddr); /*
+		b2Body* body = (b2Body*)addr;
+		b2Fixture* fixture = (b2Fixture*)fixtureAddr;
+		body->DestroyFixture(fixture);
+	*/
+
 	/** Set the position of the body's origin and rotation. This breaks any contacts and wakes the other bodies. Manipulating a
 	 * body's transform may cause non-physical behavior.
 	 * @param position the world position of the body's local origin.
@@ -722,11 +727,7 @@ inline b2BodyType getBodyType( int type )
 	 * participate in collisions, ray-casts, or queries. Joints connected to an inactive body are implicitly inactive. An inactive
 	 * body is still owned by a b2World object and remains in the body list. */
 	public void setActive (boolean flag) {
-		if (flag) {
-			jniSetActive(addr, flag);
-		} else {
-			this.world.deactivateBody(this);
-		}
+		jniSetActive(addr, flag);
 	}
 
 	private native void jniSetActive (long addr, boolean flag); /*
diff --git a/extensions/gdx-box2d/gdx-box2d/src/com/badlogic/gdx/physics/box2d/Box2DDebugRenderer.java b/extensions/gdx-box2d/gdx-box2d/src/com/badlogic/gdx/physics/box2d/Box2DDebugRenderer.java
index f38d262..252cc31 100644
--- a/extensions/gdx-box2d/gdx-box2d/src/com/badlogic/gdx/physics/box2d/Box2DDebugRenderer.java
+++ b/extensions/gdx-box2d/gdx-box2d/src/com/badlogic/gdx/physics/box2d/Box2DDebugRenderer.java
@@ -151,7 +151,7 @@ public class Box2DDebugRenderer implements Disposable {
 			CircleShape shape = (CircleShape)fixture.getShape();
 			float radius = shape.getRadius();
 			vertices[0].set(shape.getPosition());
-			transform.mul(vertices[0]);
+			vertices[0].rotate(transform.getRotation()).add(transform.getPosition());
 			lower.set(vertices[0].x - radius, vertices[0].y - radius);
 			upper.set(vertices[0].x + radius, vertices[0].y + radius);
 
diff --git a/extensions/gdx-box2d/gdx-box2d/src/com/badlogic/gdx/physics/box2d/Contact.java b/extensions/gdx-box2d/gdx-box2d/src/com/badlogic/gdx/physics/box2d/Contact.java
index b3a0414..6f127b6 100644
--- a/extensions/gdx-box2d/gdx-box2d/src/com/badlogic/gdx/physics/box2d/Contact.java
+++ b/extensions/gdx-box2d/gdx-box2d/src/com/badlogic/gdx/physics/box2d/Contact.java
@@ -41,9 +41,9 @@ public class Contact {
 		this.world = world;
 	}
 
+	/** Get the world manifold. */
 	private final float[] tmp = new float[8];
 
-	/** Get the world manifold. */
 	public WorldManifold getWorldManifold () {
 		int numContactPoints = jniGetWorldManifold(addr, tmp);
 
diff --git a/extensions/gdx-box2d/gdx-box2d/src/com/badlogic/gdx/physics/box2d/World.java b/extensions/gdx-box2d/gdx-box2d/src/com/badlogic/gdx/physics/box2d/World.java
index 9179300..7b88fef 100644
--- a/extensions/gdx-box2d/gdx-box2d/src/com/badlogic/gdx/physics/box2d/World.java
+++ b/extensions/gdx-box2d/gdx-box2d/src/com/badlogic/gdx/physics/box2d/World.java
@@ -204,7 +204,7 @@ b2ContactFilter defaultFilter;
 	};
 
 	/** the address of the world instance **/
-	protected final long addr;
+	private final long addr;
 
 	/** all known bodies **/
 	protected final LongMap<Body> bodies = new LongMap<Body>(100);
@@ -341,46 +341,6 @@ b2ContactFilter defaultFilter;
 		world->SetContactFilter(&defaultFilter);
 		world->SetContactListener(0);
 	*/
-	
-	/** Internal method for fixture destruction with notifying custom
-	 * contact listener
-	 * @param body
-	 * @param fixture */
-	void destroyFixture(Body body, Fixture fixture) {
-		jniDestroyFixture(addr, body.addr, fixture.addr);
-	}
-	
-	private native void jniDestroyFixture(long addr, long bodyAddr, long fixtureAddr); /*
-		b2World* world = (b2World*)(addr);
-		b2Body* body = (b2Body*)(bodyAddr);
-		b2Fixture* fixture = (b2Fixture*)(fixtureAddr);
-		CustomContactFilter contactFilter(env, object);
-		CustomContactListener contactListener(env, object);
-		world->SetContactFilter(&contactFilter);
-		world->SetContactListener(&contactListener);
-		body->DestroyFixture(fixture);
-		world->SetContactFilter(&defaultFilter);
-		world->SetContactListener(0);
-	*/
-	
-	/** Internal method for body deactivation with notifying custom
-	 * contact listener
-	 * @param body */
-	void deactivateBody(Body body) {
-		jniDeactivateBody(addr, body.addr);
-	}
-	
-	private native void jniDeactivateBody(long addr, long bodyAddr); /*
-		b2World* world = (b2World*)(addr);
-		b2Body* body = (b2Body*)(bodyAddr);	
-		CustomContactFilter contactFilter(env, object);
-		CustomContactListener contactListener(env, object);
-		world->SetContactFilter(&contactFilter);
-		world->SetContactListener(&contactListener);
-		body->SetActive(false);
-		world->SetContactFilter(&defaultFilter);
-		world->SetContactListener(0);
-	*/
 
 	/** Create a joint to constrain bodies together. No reference to the definition is retained. This may cause the connected bodies
 	 * to cease colliding.
@@ -750,11 +710,6 @@ b2ContactFilter defaultFilter;
 		b2World* world = (b2World*)addr;
 		return world->GetBodyCount();
 	*/
-	
-	/** Get the number of fixtures. */
-	public int getFixtureCount () {
-		return fixtures.size;
-	}
 
 	/** Get the number of joints. */
 	public int getJointCount () {
@@ -914,15 +869,6 @@ b2ContactFilter defaultFilter;
 		}		
 	}
 
-	/** @param fixtures an Array in which to place all fixtures currently in the simulation */
-	public void getFixtures (Array<Fixture> fixtures) {
-		fixtures.clear();
-		fixtures.ensureCapacity(this.fixtures.size);
-		for (Iterator<Fixture> iter = this.fixtures.values(); iter.hasNext();) {
-			fixtures.add(iter.next());
-		}		
-	}
-
 	/** @param joints an Array in which to place all joints currently in the simulation */
 	public void getJoints (Array<Joint> joints) {
 		joints.clear();
diff --git a/extensions/gdx-box2d/pom.xml b/extensions/gdx-box2d/pom.xml
index 90bb66f..d97684b 100644
--- a/extensions/gdx-box2d/pom.xml
+++ b/extensions/gdx-box2d/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.5.4-SNAPSHOT</version>
+    <version>1.4.2-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/extensions/gdx-bullet/jni/build-ios32.xml b/extensions/gdx-bullet/jni/build-ios32.xml
index 6ae41b3..51bf3ec 100755
--- a/extensions/gdx-bullet/jni/build-ios32.xml
+++ b/extensions/gdx-bullet/jni/build-ios32.xml
@@ -72,7 +72,7 @@
 				<exclude name="*.o"/>
 			</fileset>
 		</delete>
-	</target>		
+	</target>
 
 	<!-- compiles all C and C++ files to object files in the build directory, for 386 builds-->
 	<target name="compile-386" depends="clean,create-build-dir">
@@ -132,67 +132,8 @@
 	</target>
 	
 	<!-- compiles all C and C++ files to object files in the build directory, for 386 builds-->
-	<target name="compile-x86_64" depends="create-build-dir">
-		<mkdir dir="${buildDir}"/>
-		<antcall target="clean-objfiles"/>
-		<apply failonerror="true" executable="${g++}" dest="${buildDir}" verbose="true">
-			<arg line="-isysroot ${iphonesimulator-sdk} -arch x86_64 ${g++-opts}"/>
-			<arg value="-Ijni-headers"/>
-			<arg value="-Ijni-headers/${jniPlatform}"/>
-			<arg value="-I."/>
-						<arg value="-Isrc/bullet/"/>
-			<arg value="-Isrc/custom/"/>
-			<arg value="-Isrc/extras/Serialize/"/>
-
-			<srcfile/>
-			<arg value="-o"/>
-			<targetfile/>
-			<fileset refid="g++-files"/>
-			<compositemapper>
-				<mapper type="glob" from="*.cpp" to="*.o"/>
-				<mapper type="glob" from="*.mm" to="*.o"/>
-			</compositemapper>
-		</apply>
-		<apply failonerror="true" executable="${gcc}" dest="${buildDir}" verbose="true">
-			<arg line="-isysroot ${iphonesimulator-sdk} -arch x86_64 ${gcc-opts}"/>
-			<arg value="-Ijni-headers"/>
-			<arg value="-Ijni-headers/${jniPlatform}"/>
-			<arg value="-I."/>
-						<arg value="-Isrc/bullet/"/>
-			<arg value="-Isrc/custom/"/>
-			<arg value="-Isrc/extras/Serialize/"/>
-
-			<srcfile/>
-			<arg value="-o"/>
-			<targetfile/>
-			<fileset refid="gcc-files"/>
-			<compositemapper>
-				<mapper type="glob" from="*.c" to="*.o"/>
-			</compositemapper>
-		</apply>
-	</target>	
-
-	<!-- links the shared library based on the previously compiled object files -->
-	<target name="link-x86_64" depends="compile-x86_64">
-		<fileset dir="${buildDir}" id="objFileSet">
-			<patternset>
-				<include name="**/*.o" />
-			</patternset>
-		</fileset>
-		<pathconvert pathsep=" " property="objFiles" refid="objFileSet" />
-		<mkdir dir="${libsDir}" />
-		<exec executable="${linker}" failonerror="true" dir="${buildDir}">
-			<arg line="${linker-opts}" />
-			<arg path="${libsDir}/${libName}.x86_64" />
-			<arg line="${objFiles}"/>
-			<arg line="${libraries}" />
-		</exec>
-	</target>
-	
-	<!-- compiles all C and C++ files to object files in the build directory, for 386 builds-->
-	<target name="compile-arm" depends="create-build-dir">
+	<target name="compile-arm" depends="create-build-dir,clean-objfiles">
 		<mkdir dir="${buildDir}"/>
-		<antcall target="clean-objfiles"/>
 		<apply failonerror="true" executable="${g++}" dest="${buildDir}" verbose="true">
 			<arg line="-isysroot ${iphoneos-sdk} -arch armv7 ${g++-opts}"/>
 			<arg value="-Ijni-headers"/>
@@ -246,72 +187,14 @@
 			<arg line="${libraries}" />
 		</exec>
 	</target>
-	
-		<!-- compiles all C and C++ files to object files in the build directory, for 386 builds-->
-	<target name="compile-arm64" depends="create-build-dir,clean-objfiles">
-		<mkdir dir="${buildDir}"/>
-		<antcall target="clean-objfiles"/>
-		<apply failonerror="true" executable="${g++}" dest="${buildDir}" verbose="true">
-			<arg line="-isysroot ${iphoneos-sdk} -arch arm64 ${g++-opts}"/>
-			<arg value="-Ijni-headers"/>
-			<arg value="-Ijni-headers/${jniPlatform}"/>
-			<arg value="-I."/>
-						<arg value="-Isrc/bullet/"/>
-			<arg value="-Isrc/custom/"/>
-			<arg value="-Isrc/extras/Serialize/"/>
-
-			<srcfile/>
-			<arg value="-o"/>
-			<targetfile/>
-			<fileset refid="g++-files"/>
-			<compositemapper>
-				<mapper type="glob" from="*.cpp" to="*.o"/>
-				<mapper type="glob" from="*.mm" to="*.o"/>
-			</compositemapper>
-		</apply>
-		<apply failonerror="true" executable="${gcc}" dest="${buildDir}" verbose="true">
-			<arg line="-isysroot ${iphoneos-sdk} -arch arm64 ${gcc-opts}"/>
-			<arg value="-Ijni-headers"/>
-			<arg value="-Ijni-headers/${jniPlatform}"/>
-			<arg value="-I."/>
-						<arg value="-Isrc/bullet/"/>
-			<arg value="-Isrc/custom/"/>
-			<arg value="-Isrc/extras/Serialize/"/>
-
-			<srcfile/>
-			<arg value="-o"/>
-			<targetfile/>
-			<fileset refid="gcc-files"/>
-			<compositemapper>
-				<mapper type="glob" from="*.c" to="*.o"/>
-			</compositemapper>
-		</apply>
-	</target>	
-
-	<!-- links the shared library based on the previously compiled object files -->
-	<target name="link-arm64" depends="compile-arm64">
-		<fileset dir="${buildDir}" id="objFileSet">
-			<patternset>
-				<include name="**/*.o" />
-			</patternset>
-		</fileset>
-		<pathconvert pathsep=" " property="objFiles" refid="objFileSet" />
-		<mkdir dir="${libsDir}" />
-		<exec executable="${linker}" failonerror="true" dir="${buildDir}">
-			<arg line="${linker-opts}" />
-			<arg path="${libsDir}/${libName}.arm64" />
-			<arg line="${objFiles}"/>
-			<arg line="${libraries}" />
-		</exec>
-	</target>
 
 	<target name="link-fat">
 		<exec executable="lipo" failonerror="true" dir="${libsDir}">
-			<arg line="-create -output ${libName} ${libName}.386 ${libName}.x86_64 ${libName}.armv7"/>
+			<arg line="-create -output ${libName} ${libName}.386 ${libName}.armv7"/>
 		</exec>
 	</target>
 
-	<target name="postcompile" depends="link-386,link-x86_64,link-arm,link-fat">
+	<target name="postcompile" depends="link-386,link-arm,link-fat">
 		
 	</target>
 </project>
diff --git a/extensions/gdx-bullet/jni/maven/pom.xml b/extensions/gdx-bullet/jni/maven/pom.xml
index 7ef8a16..688cd50 100644
--- a/extensions/gdx-bullet/jni/maven/pom.xml
+++ b/extensions/gdx-bullet/jni/maven/pom.xml
@@ -4,7 +4,7 @@
     <parent>
         <groupId>com.badlogicgames.gdx</groupId>
         <artifactId>gdx-parent</artifactId>
-        <version>1.5.4-SNAPSHOT</version>
+        <version>1.4.2-SNAPSHOT</version>
         <relativePath>../../../../</relativePath>
     </parent>
     
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/classes.i b/extensions/gdx-bullet/jni/swig-src/collision/classes.i
index d067ade..2284154 100644
--- a/extensions/gdx-bullet/jni/swig-src/collision/classes.i
+++ b/extensions/gdx-bullet/jni/swig-src/collision/classes.i
@@ -1,6 +1,4 @@
 SPECIFY_CLASS(AllHitsRayResultCallback, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(BT_BOX_BOX_TRANSFORM_CACHE, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(BT_QUANTIZED_BVH_NODE, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(BroadphaseNativeTypes, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(ClosestConvexResultCallback, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(ClosestNotMeConvexResultCallback, com.badlogic.gdx.physics.bullet.collision)
@@ -16,14 +14,6 @@ SPECIFY_CLASS(ContactListener, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(ContactResultCallback, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(ConvexResultCallback, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(CustomCollisionDispatcher, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(GIM_BVH_DATA, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(GIM_BVH_DATA_ARRAY, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(GIM_BVH_TREE_NODE, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(GIM_BVH_TREE_NODE_ARRAY, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(GIM_CONTACT, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(GIM_PAIR, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(GIM_QUANTIZED_BVH_NODE_ARRAY, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(GIM_TRIANGLE_CONTACT, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(GdxCollisionObjectBridge, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(LocalConvexResult, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(LocalRayResult, com.badlogic.gdx.physics.bullet.collision)
@@ -50,15 +40,11 @@ SPECIFY_CLASS(SWIGTYPE_p_int, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(SWIGTYPE_p_p_btCollisionObject, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(SWIGTYPE_p_p_btDbvtNode, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(SWIGTYPE_p_p_btDbvtProxy, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(SWIGTYPE_p_p_btGenericMemoryPool, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(SWIGTYPE_p_p_btPersistentManifold, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(SWIGTYPE_p_p_btVector3, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(SWIGTYPE_p_p_unsigned_char, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(SWIGTYPE_p_size_t, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(SWIGTYPE_p_unsigned_int, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(SphereTriangleDetector, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(bt32BitAxisSweep3, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(btAABB, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btActivatingCollisionAlgorithm, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btAxisSweep3, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btAxisSweep3InternalInt, com.badlogic.gdx.physics.bullet.collision)
@@ -78,7 +64,6 @@ SPECIFY_CLASS(btBroadphaseProxy, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btBroadphaseRayCallback, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btBvhSubtreeInfo, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btBvhSubtreeInfoData, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(btBvhTree, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btBvhTriangleMeshShape, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btCapsuleShape, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btCapsuleShapeData, com.badlogic.gdx.physics.bullet.collision)
@@ -111,7 +96,6 @@ SPECIFY_CLASS(btConeShapeData, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btConeShapeX, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btConeShapeZ, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btConstraintRow, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(btContactArray, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btContactManifoldTypes, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btContinuousConvexCollision, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btConvex2dConvex2dAlgorithm, com.badlogic.gdx.physics.bullet.collision)
@@ -149,16 +133,6 @@ SPECIFY_CLASS(btElement, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btEmptyAlgorithm, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btEmptyShape, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btFace, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(btGImpactBvh, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(btGImpactCollisionAlgorithm, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(btGImpactCompoundShape, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(btGImpactMeshShape, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(btGImpactMeshShapeData, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(btGImpactMeshShapePart, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(btGImpactQuantizedBvh, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(btGImpactShapeInterface, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(btGenericMemoryPool, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(btGenericPoolAllocator, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btGhostObject, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btGhostPairCallback, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btGjkConvexCast, com.badlogic.gdx.physics.bullet.collision)
@@ -194,7 +168,6 @@ SPECIFY_CLASS(btOverlapFilterCallback, com.badlogic.gdx.physics.bullet.collision
 SPECIFY_CLASS(btOverlappingPairCache, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btOverlappingPairCallback, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btPairCachingGhostObject, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(btPairSet, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btPersistentManifold, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btPersistentManifoldArray, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btPointCollector, com.badlogic.gdx.physics.bullet.collision)
@@ -202,14 +175,11 @@ SPECIFY_CLASS(btPolyhedralContactClipping, com.badlogic.gdx.physics.bullet.colli
 SPECIFY_CLASS(btPolyhedralConvexAabbCachingShape, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btPolyhedralConvexShape, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btPositionAndRadius, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(btPrimitiveManagerBase, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(btPrimitiveTriangle, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btQuantizedBvh, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btQuantizedBvhDoubleData, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btQuantizedBvhFloatData, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btQuantizedBvhNode, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btQuantizedBvhNodeData, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(btQuantizedBvhTree, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btScaledBvhTriangleMeshShape, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btScaledTriangleMeshShapeData, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btShapeHull, com.badlogic.gdx.physics.bullet.collision)
@@ -231,7 +201,6 @@ SPECIFY_CLASS(btStridingMeshInterface, com.badlogic.gdx.physics.bullet.collision
 SPECIFY_CLASS(btStridingMeshInterfaceData, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btSubSimplexClosestResult, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btSubsimplexConvexCast, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(btTetrahedronShapeEx, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btTriangle, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btTriangleBuffer, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btTriangleCallback, com.badlogic.gdx.physics.bullet.collision)
@@ -247,10 +216,7 @@ SPECIFY_CLASS(btTriangleMeshShape, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btTriangleMeshShapeData, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btTriangleRaycastCallback, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btTriangleShape, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(btTriangleShapeEx, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btUniformScalingShape, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btUnionFind, com.badlogic.gdx.physics.bullet.collision)
 SPECIFY_CLASS(btUsageBitfield, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(btVoronoiSimplexSolver, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(eBT_PLANE_INTERSECTION_TYPE, com.badlogic.gdx.physics.bullet.collision)
-SPECIFY_CLASS(eGIMPACT_SHAPE_TYPE, com.badlogic.gdx.physics.bullet.collision)
\ No newline at end of file
+SPECIFY_CLASS(btVoronoiSimplexSolver, com.badlogic.gdx.physics.bullet.collision)
\ No newline at end of file
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/collision_wrap.cpp b/extensions/gdx-bullet/jni/swig-src/collision/collision_wrap.cpp
index 080988e..a74dbf8 100644
--- a/extensions/gdx-bullet/jni/swig-src/collision/collision_wrap.cpp
+++ b/extensions/gdx-bullet/jni/swig-src/collision/collision_wrap.cpp
@@ -1424,7 +1424,7 @@ void btMultiSapBroadphase::quicksort(btBroadphasePairArray& a, int lo, int hi)
 
 
 	// Inline (cached) method to retrieve the type's jclass
-	SWIGINTERN inline jclass &gdx_getClassbtBroadphasePair(JNIEnv * const &jenv) {
+	SWIGINTERN inline jclass &gdx_getClassbtBroadphasePair(JNIEnv * jenv) {
 		static jclass cls = NULL;
 		if (cls == NULL)
 			cls = (jclass) jenv->NewGlobalRef(jenv->FindClass("com/badlogic/gdx/physics/bullet/collision/btBroadphasePair"));
@@ -2263,6 +2263,72 @@ SWIGINTERN void btManifoldPoint_setLateralFrictionDir2(btManifoldPoint *self,btV
 #include <gdx/collision/ContactListener.h>
 bool custom_ContactListener_setEvents(ContactListener *listener);
 
+
+	// Inline (cached) method to retrieve the type's jclass
+	SWIGINTERN inline jclass &gdx_getClassbtCollisionObjectWrapper(JNIEnv * jenv) {
+		static jclass cls = NULL;
+		if (cls == NULL)
+			cls = (jclass) jenv->NewGlobalRef(jenv->FindClass("com/badlogic/gdx/physics/bullet/collision/btCollisionObjectWrapper"));
+		return cls;
+	}
+	
+	// Inline method to get the termporary instance
+	SWIGINTERN inline jobject gdx_getTempbtCollisionObjectWrapper(JNIEnv * jenv, void *cPtr, bool ownMem) {
+	  static jobject ret = NULL;
+	  jclass &clazz = gdx_getClassbtCollisionObjectWrapper(jenv);
+	  if (ret == NULL) {
+	    jfieldID field = jenv->GetStaticFieldID(clazz, "temp", "Lcom/badlogic/gdx/physics/bullet/collision/btCollisionObjectWrapper;");
+	    ret = jenv->NewGlobalRef(jenv->GetStaticObjectField(clazz, field));
+	  }
+	  
+	  static jmethodID reuseMethod = NULL;
+	  if (reuseMethod == NULL)
+		  reuseMethod = (jmethodID) jenv->GetMethodID(clazz, "reset", "(JZ)V");
+	  
+	  long ptr;
+	  *(const void **)&ptr = cPtr;
+	  jenv->CallVoidMethod(ret, reuseMethod, ptr, (jboolean)ownMem);
+	  return ret;
+	}
+
+	// Inline method to obtain an instance from the pool
+	SWIGINTERN inline jobject gdx_obtainbtCollisionObjectWrapper(JNIEnv * jenv, jclass clazz, void *cPtr, bool ownMem) {
+		static jmethodID obtainMethod = NULL;
+		if (obtainMethod == NULL)
+			obtainMethod = (jmethodID) jenv->GetStaticMethodID(clazz, "obtain", "(JZ)Lcom/badlogic/gdx/physics/bullet/collision/btCollisionObjectWrapper;");
+		
+		long ptr;
+		*(const void **)&ptr = cPtr; 
+		jobject ret = jenv->CallStaticObjectMethod(clazz, obtainMethod, ptr, (jboolean)ownMem);
+		
+		return ret;
+	}
+	
+	// Inline method to free an instance from the pool
+	SWIGINTERN inline void gdx_freebtCollisionObjectWrapper(JNIEnv * jenv, const jclass clazz, const jobject obj) {
+		static jmethodID freeMethod = NULL;
+		if (freeMethod == NULL)
+			freeMethod = (jmethodID) jenv->GetStaticMethodID(clazz, "free", "(Lcom/badlogic/gdx/physics/bullet/collision/btCollisionObjectWrapper;)V");
+		
+		jenv->CallStaticVoidMethod(clazz, freeMethod, obj);
+		
+		jenv->DeleteLocalRef(obj);
+	}
+	
+	// Simple raii class to auto free the instance from the pool 
+	class gdxAutoFreebtCollisionObjectWrapper {
+	private:
+		JNIEnv * jenv;
+		jobject jbtCollisionObjectWrapper;
+		jclass jclazz;
+	public:
+		gdxAutoFreebtCollisionObjectWrapper(JNIEnv * jenv, jclass jclazz, jobject jbtCollisionObjectWrapper) : 
+			jenv(jenv), jbtCollisionObjectWrapper(jbtCollisionObjectWrapper), jclazz(jclazz) { }
+		virtual ~gdxAutoFreebtCollisionObjectWrapper() {
+			gdx_freebtCollisionObjectWrapper(this->jenv, this->jclazz, this->jbtCollisionObjectWrapper);
+		}
+	};
+
 SWIGINTERN bool ContactListener_setEvents(ContactListener *self){
 		return custom_ContactListener_setEvents(self);
 	}
@@ -2340,190 +2406,6 @@ SWIGINTERN int btAlignedObjectArray_Sl_btBroadphasePair_Sg__getCollisionObjectsV
 		return count;
 	}
 
-#include <BulletCollision/Gimpact/btQuantization.h>
-
-
-#include <BulletCollision/Gimpact/btBoxCollision.h>
-
-
-
-	/* Gets a global ref to the temp class.  Do not release this. */
-	SWIGINTERN inline jclass gdx_getTempClassMatrix3(JNIEnv * jenv) {
-	  static jclass cls = NULL;
-	  if (cls == NULL) {
-		cls = (jclass) jenv->NewGlobalRef(jenv->FindClass("com/badlogic/gdx/physics/bullet/linearmath/LinearMath"));
-	  }
-	  return cls;
-	}
-	
-	SWIGINTERN inline jobject gdx_takePoolObjectMatrix3(JNIEnv * jenv, const char * poolName) {
-	  jclass tempClass = gdx_getTempClassMatrix3(jenv);
-	  
-	  static jfieldID poolField = NULL;
-	  if (poolField == NULL) {
-		poolField = jenv->GetStaticFieldID(tempClass, poolName, "Lcom/badlogic/gdx/utils/Pool;");
-	  }
-	  
-	  jobject poolObject = jenv->GetStaticObjectField(tempClass, poolField);
-	  jclass poolClass = jenv->GetObjectClass(poolObject);
-	  
-	  static jmethodID obtainMethod = NULL;
-	  if (obtainMethod == NULL) {
-		obtainMethod = (jmethodID) jenv->GetMethodID(poolClass, "obtain", "()Ljava/lang/Object;");
-	  }
-	  
-	  jobject ret = jenv->CallObjectMethod(poolObject, obtainMethod);
-	
-	  jenv->DeleteLocalRef(poolObject);
-	  jenv->DeleteLocalRef(poolClass);
-	
-	  return ret;
-	}
-	
-	SWIGINTERN inline void gdx_releasePoolObjectMatrix3(JNIEnv * jenv, const char * poolName, jobject obj) {
-	  jclass tempClass = gdx_getTempClassMatrix3(jenv);
-	  
-	  static jfieldID poolField = NULL;
-	  if (poolField == NULL) {
-		poolField = jenv->GetStaticFieldID(tempClass, poolName, "Lcom/badlogic/gdx/utils/Pool;");
-	  }
-	  
-	  jobject poolObject = jenv->GetStaticObjectField(tempClass, poolField);
-	  jclass poolClass = jenv->GetObjectClass(poolObject);
-	  
-	  static jmethodID freeMethod = NULL;
-	  if (freeMethod == NULL) {
-		freeMethod = (jmethodID) jenv->GetMethodID(poolClass, "free", "(Ljava/lang/Object;)V");
-	  }
-	  
-	  jenv->CallVoidMethod(poolObject, freeMethod, obj);
-	  
-	  jenv->DeleteLocalRef(poolObject);
-	  jenv->DeleteLocalRef(poolClass);
-	  jenv->DeleteLocalRef(obj);
-	}
-	
-	/*
-	 * A simple RAII wrapper to release jobjects we obtain from pools in 
-	 * directorin typemaps.  SWIG doesn't have hooks to release them after
-	 * they're used. 
-	 */
-	class gdxPoolAutoReleaseMatrix3 {
-	private:
-	  JNIEnv * jenv;
-	  const char * poolName;
-	  jobject obj;
-	public:
-	  gdxPoolAutoReleaseMatrix3(JNIEnv * jenv, const char * poolName, jobject obj) : 
-		jenv(jenv), poolName(poolName), obj(obj) { };
-	  virtual ~gdxPoolAutoReleaseMatrix3() {
-		gdx_releasePoolObjectMatrix3(this->jenv, this->poolName, this->obj);
-	  };
-	};
-
-
-	
-// Workaround for some strange swig behaviour
-
-
-	/* Gets a global ref to the temp class's Return Matrix3.  Do not release this. */ 
-	SWIGINTERN inline jobject gdx_getReturnMatrix3(JNIEnv * jenv) {
-	  static jobject ret = NULL;
-	  if (ret == NULL) {
-	    jclass tempClass = gdx_getTempClassMatrix3(jenv);
-	    jfieldID field = jenv->GetStaticFieldID(tempClass, "staticMatrix3", "Lcom/badlogic/gdx/math/Matrix3;");
-	    ret = jenv->NewGlobalRef(jenv->GetStaticObjectField(tempClass, field));
-	  }
-	  return ret;
-	}
-	
-	/* Sets the data in the Bullet type from the Gdx type. */
-	SWIGINTERN inline void gdx_setbtMatrix3x3FromMatrix3(JNIEnv * jenv, btMatrix3x3 & target, jobject source) {
-		Matrix3_to_btMatrix3(jenv, target, source);
-	}
-
-	SWIGINTERN inline void gdx_setbtMatrix3x3FromMatrix3(JNIEnv * jenv, btMatrix3x3 * target, jobject source) {
-		gdx_setbtMatrix3x3FromMatrix3(jenv, *target, source);
-	}
-
-	/* Sets the data in the Gdx type from the Bullet type. */
-	SWIGINTERN inline void gdx_setMatrix3FrombtMatrix3x3(JNIEnv * jenv, jobject target, const btMatrix3x3 & source) {
-		btMatrix3_to_Matrix3(jenv, target, source);
-	}
-
-	SWIGINTERN inline void gdx_setMatrix3FrombtMatrix3x3(JNIEnv * jenv, jobject target, const btMatrix3x3 * source) {
-		gdx_setMatrix3FrombtMatrix3x3(jenv, target, *source);
-	}
-
-	/*
-	 * RAII wrapper to commit changes made to a local btMatrix3x3 back to Matrix3
-	 */
-	class gdxAutoCommitMatrix3 {
-	private:
-	  JNIEnv * jenv;
-	  jobject jMatrix3;
-	  btMatrix3x3 & cbtMatrix3x3;
-	public:
-	  gdxAutoCommitMatrix3(JNIEnv * jenv, jobject jMatrix3, btMatrix3x3 & cbtMatrix3x3) : 
-	    jenv(jenv), jMatrix3(jMatrix3), cbtMatrix3x3(cbtMatrix3x3) { };
-	  gdxAutoCommitMatrix3(JNIEnv * jenv, jobject jMatrix3, btMatrix3x3 * cbtMatrix3x3) : 
-	    jenv(jenv), jMatrix3(jMatrix3), cbtMatrix3x3(*cbtMatrix3x3) { };
-	  virtual ~gdxAutoCommitMatrix3() {
-	    gdx_setMatrix3FrombtMatrix3x3(this->jenv, this->jMatrix3, this->cbtMatrix3x3);
-	  };
-	};
-
-	class gdxAutoCommitbtMatrix3x3AndReleaseMatrix3 {
-	private:
-	  JNIEnv * jenv;
-	  jobject jMatrix3;
-	  btMatrix3x3 & cbtMatrix3x3;
-	  const char * poolName;
-	public:
-	  gdxAutoCommitbtMatrix3x3AndReleaseMatrix3(JNIEnv * jenv, jobject jMatrix3, btMatrix3x3 & cbtMatrix3x3, const char *poolName) : 
-	    jenv(jenv), jMatrix3(jMatrix3), cbtMatrix3x3(cbtMatrix3x3), poolName(poolName) { };
-	  gdxAutoCommitbtMatrix3x3AndReleaseMatrix3(JNIEnv * jenv, jobject jMatrix3, btMatrix3x3 * cbtMatrix3x3, const char *poolName) : 
-	    jenv(jenv), jMatrix3(jMatrix3), cbtMatrix3x3(*cbtMatrix3x3), poolName(poolName) { };
-	  virtual ~gdxAutoCommitbtMatrix3x3AndReleaseMatrix3() {
-	    gdx_setbtMatrix3x3FromMatrix3(this->jenv, this->cbtMatrix3x3, this->jMatrix3);
-	    gdx_releasePoolObjectMatrix3(this->jenv, this->poolName, this->jMatrix3);
-	  };
-	};
-
-
-#include <BulletCollision/Gimpact/btClipPolygon.h>
-
-
-#include <BulletCollision/Gimpact/btGeometryOperations.h>
-
-
-#include <BulletCollision/Gimpact/btTriangleShapeEx.h>
-
-
-#include <BulletCollision/Gimpact/btGImpactBvh.h>
-
-
-#include <BulletCollision/Gimpact/btGImpactQuantizedBvh.h>
-
-
-#include <BulletCollision/Gimpact/btGImpactShape.h>
-
-
-#include <BulletCollision/Gimpact/btContactProcessing.h>
-
-
-#include <BulletCollision/Gimpact/btGenericPoolAllocator.h>
-
-
-#include <BulletCollision/Gimpact/btGImpactCollisionAlgorithm.h>
-
-
-#include <BulletCollision/Gimpact/btGImpactMassUtil.h>
-
-
-#include <BulletCollision/Gimpact/btGImpactMassUtil.h>
-
-
 
 /* ---------------------------------------------------
  * C++ director class methods
@@ -4456,10 +4338,10 @@ bool SwigDirector_ContactListener::onContactAdded(btManifoldPoint &cp, btCollisi
   JNIEnv * jenv = swigjnienv.getJNIEnv() ;
   jobject swigjobj = (jobject) NULL ;
   jlong jcp = 0 ;
-  jlong jcolObj0Wrap = 0 ;
+  jobject jcolObj0Wrap = 0 ;
   jint jpartId0  ;
   jint jindex0  ;
-  jlong jcolObj1Wrap = 0 ;
+  jobject jcolObj1Wrap = 0 ;
   jint jpartId1  ;
   jint jindex1  ;
   
@@ -4470,10 +4352,14 @@ bool SwigDirector_ContactListener::onContactAdded(btManifoldPoint &cp, btCollisi
   swigjobj = swig_get_self(jenv);
   if (swigjobj && jenv->IsSameObject(swigjobj, NULL) == JNI_FALSE) {
     *(btManifoldPoint **)&jcp = (btManifoldPoint *) &cp; 
-    *(btCollisionObjectWrapper **)&jcolObj0Wrap = (btCollisionObjectWrapper *) &colObj0Wrap; 
+    jclass jccolObj0Wrap = gdx_getClassbtCollisionObjectWrapper(jenv);
+    jcolObj0Wrap = gdx_obtainbtCollisionObjectWrapper(jenv, jccolObj0Wrap, (void*)&colObj0Wrap, false);
+    gdxAutoFreebtCollisionObjectWrapper autoRelease_jcolObj0Wrap(jenv, jccolObj0Wrap, jcolObj0Wrap);
     jpartId0 = (jint) partId0;
     jindex0 = (jint) index0;
-    *(btCollisionObjectWrapper **)&jcolObj1Wrap = (btCollisionObjectWrapper *) &colObj1Wrap; 
+    jclass jccolObj1Wrap = gdx_getClassbtCollisionObjectWrapper(jenv);
+    jcolObj1Wrap = gdx_obtainbtCollisionObjectWrapper(jenv, jccolObj1Wrap, (void*)&colObj1Wrap, false);
+    gdxAutoFreebtCollisionObjectWrapper autoRelease_jcolObj1Wrap(jenv, jccolObj1Wrap, jcolObj1Wrap);
     jpartId1 = (jint) partId1;
     jindex1 = (jint) index1;
     jresult = (jboolean) jenv->CallStaticBooleanMethod(Swig::jclass_CollisionJNI, Swig::director_methids[32], swigjobj, jcp, jcolObj0Wrap, jpartId0, jindex0, jcolObj1Wrap, jpartId1, jindex1);
@@ -4582,11 +4468,11 @@ bool SwigDirector_ContactListener::onContactAdded(btManifoldPoint &cp, btCollisi
   JNIEnv * jenv = swigjnienv.getJNIEnv() ;
   jobject swigjobj = (jobject) NULL ;
   jlong jcp = 0 ;
-  jlong jcolObj0Wrap = 0 ;
+  jobject jcolObj0Wrap = 0 ;
   jint jpartId0  ;
   jint jindex0  ;
   jboolean jmatch0  ;
-  jlong jcolObj1Wrap = 0 ;
+  jobject jcolObj1Wrap = 0 ;
   jint jpartId1  ;
   jint jindex1  ;
   jboolean jmatch1  ;
@@ -4598,11 +4484,15 @@ bool SwigDirector_ContactListener::onContactAdded(btManifoldPoint &cp, btCollisi
   swigjobj = swig_get_self(jenv);
   if (swigjobj && jenv->IsSameObject(swigjobj, NULL) == JNI_FALSE) {
     *(btManifoldPoint **)&jcp = (btManifoldPoint *) &cp; 
-    *(btCollisionObjectWrapper **)&jcolObj0Wrap = (btCollisionObjectWrapper *) &colObj0Wrap; 
+    jclass jccolObj0Wrap = gdx_getClassbtCollisionObjectWrapper(jenv);
+    jcolObj0Wrap = gdx_obtainbtCollisionObjectWrapper(jenv, jccolObj0Wrap, (void*)&colObj0Wrap, false);
+    gdxAutoFreebtCollisionObjectWrapper autoRelease_jcolObj0Wrap(jenv, jccolObj0Wrap, jcolObj0Wrap);
     jpartId0 = (jint) partId0;
     jindex0 = (jint) index0;
     jmatch0 = (jboolean) match0;
-    *(btCollisionObjectWrapper **)&jcolObj1Wrap = (btCollisionObjectWrapper *) &colObj1Wrap; 
+    jclass jccolObj1Wrap = gdx_getClassbtCollisionObjectWrapper(jenv);
+    jcolObj1Wrap = gdx_obtainbtCollisionObjectWrapper(jenv, jccolObj1Wrap, (void*)&colObj1Wrap, false);
+    gdxAutoFreebtCollisionObjectWrapper autoRelease_jcolObj1Wrap(jenv, jccolObj1Wrap, jcolObj1Wrap);
     jpartId1 = (jint) partId1;
     jindex1 = (jint) index1;
     jmatch1 = (jboolean) match1;
@@ -4719,10 +4609,10 @@ bool SwigDirector_ContactListener::onContactAdded(btCollisionObjectWrapper const
   JNIEnvWrapper swigjnienv(this) ;
   JNIEnv * jenv = swigjnienv.getJNIEnv() ;
   jobject swigjobj = (jobject) NULL ;
-  jlong jcolObj0Wrap = 0 ;
+  jobject jcolObj0Wrap = 0 ;
   jint jpartId0  ;
   jint jindex0  ;
-  jlong jcolObj1Wrap = 0 ;
+  jobject jcolObj1Wrap = 0 ;
   jint jpartId1  ;
   jint jindex1  ;
   
@@ -4732,10 +4622,14 @@ bool SwigDirector_ContactListener::onContactAdded(btCollisionObjectWrapper const
   }
   swigjobj = swig_get_self(jenv);
   if (swigjobj && jenv->IsSameObject(swigjobj, NULL) == JNI_FALSE) {
-    *(btCollisionObjectWrapper **)&jcolObj0Wrap = (btCollisionObjectWrapper *) &colObj0Wrap; 
+    jclass jccolObj0Wrap = gdx_getClassbtCollisionObjectWrapper(jenv);
+    jcolObj0Wrap = gdx_obtainbtCollisionObjectWrapper(jenv, jccolObj0Wrap, (void*)&colObj0Wrap, false);
+    gdxAutoFreebtCollisionObjectWrapper autoRelease_jcolObj0Wrap(jenv, jccolObj0Wrap, jcolObj0Wrap);
     jpartId0 = (jint) partId0;
     jindex0 = (jint) index0;
-    *(btCollisionObjectWrapper **)&jcolObj1Wrap = (btCollisionObjectWrapper *) &colObj1Wrap; 
+    jclass jccolObj1Wrap = gdx_getClassbtCollisionObjectWrapper(jenv);
+    jcolObj1Wrap = gdx_obtainbtCollisionObjectWrapper(jenv, jccolObj1Wrap, (void*)&colObj1Wrap, false);
+    gdxAutoFreebtCollisionObjectWrapper autoRelease_jcolObj1Wrap(jenv, jccolObj1Wrap, jcolObj1Wrap);
     jpartId1 = (jint) partId1;
     jindex1 = (jint) index1;
     jresult = (jboolean) jenv->CallStaticBooleanMethod(Swig::jclass_CollisionJNI, Swig::director_methids[38], swigjobj, jcolObj0Wrap, jpartId0, jindex0, jcolObj1Wrap, jpartId1, jindex1);
@@ -4839,11 +4733,11 @@ bool SwigDirector_ContactListener::onContactAdded(btCollisionObjectWrapper const
   JNIEnvWrapper swigjnienv(this) ;
   JNIEnv * jenv = swigjnienv.getJNIEnv() ;
   jobject swigjobj = (jobject) NULL ;
-  jlong jcolObj0Wrap = 0 ;
+  jobject jcolObj0Wrap = 0 ;
   jint jpartId0  ;
   jint jindex0  ;
   jboolean jmatch0  ;
-  jlong jcolObj1Wrap = 0 ;
+  jobject jcolObj1Wrap = 0 ;
   jint jpartId1  ;
   jint jindex1  ;
   jboolean jmatch1  ;
@@ -4854,11 +4748,15 @@ bool SwigDirector_ContactListener::onContactAdded(btCollisionObjectWrapper const
   }
   swigjobj = swig_get_self(jenv);
   if (swigjobj && jenv->IsSameObject(swigjobj, NULL) == JNI_FALSE) {
-    *(btCollisionObjectWrapper **)&jcolObj0Wrap = (btCollisionObjectWrapper *) &colObj0Wrap; 
+    jclass jccolObj0Wrap = gdx_getClassbtCollisionObjectWrapper(jenv);
+    jcolObj0Wrap = gdx_obtainbtCollisionObjectWrapper(jenv, jccolObj0Wrap, (void*)&colObj0Wrap, false);
+    gdxAutoFreebtCollisionObjectWrapper autoRelease_jcolObj0Wrap(jenv, jccolObj0Wrap, jcolObj0Wrap);
     jpartId0 = (jint) partId0;
     jindex0 = (jint) index0;
     jmatch0 = (jboolean) match0;
-    *(btCollisionObjectWrapper **)&jcolObj1Wrap = (btCollisionObjectWrapper *) &colObj1Wrap; 
+    jclass jccolObj1Wrap = gdx_getClassbtCollisionObjectWrapper(jenv);
+    jcolObj1Wrap = gdx_obtainbtCollisionObjectWrapper(jenv, jccolObj1Wrap, (void*)&colObj1Wrap, false);
+    gdxAutoFreebtCollisionObjectWrapper autoRelease_jcolObj1Wrap(jenv, jccolObj1Wrap, jcolObj1Wrap);
     jpartId1 = (jint) partId1;
     jindex1 = (jint) index1;
     jmatch1 = (jboolean) match1;
@@ -44175,7 +44073,7 @@ SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_Colli
 }
 
 
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_ContactListener_1onContactAdded_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_, jint jarg4, jint jarg5, jlong jarg6, jobject jarg6_, jint jarg7, jint jarg8) {
+SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_ContactListener_1onContactAdded_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jobject jarg3, jint jarg4, jint jarg5, jobject jarg6, jint jarg7, jint jarg8) {
   jboolean jresult = 0 ;
   ContactListener *arg1 = (ContactListener *) 0 ;
   btManifoldPoint *arg2 = 0 ;
@@ -44191,8 +44089,6 @@ SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_Colli
   (void)jcls;
   (void)jarg1_;
   (void)jarg2_;
-  (void)jarg3_;
-  (void)jarg6_;
   arg1 = *(ContactListener **)&jarg1; 
   arg2 = *(btManifoldPoint **)&jarg2;
   if (!arg2) {
@@ -44289,7 +44185,7 @@ SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_Colli
 }
 
 
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_ContactListener_1onContactAdded_1_1SWIG_13(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_, jint jarg4, jint jarg5, jboolean jarg6, jlong jarg7, jobject jarg7_, jint jarg8, jint jarg9, jboolean jarg10) {
+SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_ContactListener_1onContactAdded_1_1SWIG_13(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jobject jarg3, jint jarg4, jint jarg5, jboolean jarg6, jobject jarg7, jint jarg8, jint jarg9, jboolean jarg10) {
   jboolean jresult = 0 ;
   ContactListener *arg1 = (ContactListener *) 0 ;
   btManifoldPoint *arg2 = 0 ;
@@ -44307,8 +44203,6 @@ SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_Colli
   (void)jcls;
   (void)jarg1_;
   (void)jarg2_;
-  (void)jarg3_;
-  (void)jarg7_;
   arg1 = *(ContactListener **)&jarg1; 
   arg2 = *(btManifoldPoint **)&jarg2;
   if (!arg2) {
@@ -44415,7 +44309,7 @@ SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_Colli
 }
 
 
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_ContactListener_1onContactAdded_1_1SWIG_16(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jint jarg3, jint jarg4, jlong jarg5, jobject jarg5_, jint jarg6, jint jarg7) {
+SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_ContactListener_1onContactAdded_1_1SWIG_16(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jint jarg3, jint jarg4, jobject jarg5, jint jarg6, jint jarg7) {
   jboolean jresult = 0 ;
   ContactListener *arg1 = (ContactListener *) 0 ;
   btCollisionObjectWrapper *arg2 = 0 ;
@@ -44429,8 +44323,6 @@ SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_Colli
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
-  (void)jarg2_;
-  (void)jarg5_;
   arg1 = *(ContactListener **)&jarg1; 
   arg2 = *(btCollisionObjectWrapper **)&jarg2;
   if (!arg2) {
@@ -44508,7 +44400,7 @@ SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_Colli
 }
 
 
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_ContactListener_1onContactAdded_1_1SWIG_19(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jint jarg3, jint jarg4, jboolean jarg5, jlong jarg6, jobject jarg6_, jint jarg7, jint jarg8, jboolean jarg9) {
+SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_ContactListener_1onContactAdded_1_1SWIG_19(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jint jarg3, jint jarg4, jboolean jarg5, jobject jarg6, jint jarg7, jint jarg8, jboolean jarg9) {
   jboolean jresult = 0 ;
   ContactListener *arg1 = (ContactListener *) 0 ;
   btCollisionObjectWrapper *arg2 = 0 ;
@@ -44524,8 +44416,6 @@ SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_Colli
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
-  (void)jarg2_;
-  (void)jarg6_;
   arg1 = *(ContactListener **)&jarg1; 
   arg2 = *(btCollisionObjectWrapper **)&jarg2;
   if (!arg2) {
@@ -45507,6910 +45397,197 @@ SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_Collision
 }
 
 
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_bt_1calc_1quantization_1parameters(JNIEnv *jenv, jclass jcls, jobject jarg1, jobject jarg2, jobject jarg3, jobject jarg4, jobject jarg5, jfloat jarg6) {
-  btVector3 *arg1 = 0 ;
-  btVector3 *arg2 = 0 ;
-  btVector3 *arg3 = 0 ;
-  btVector3 *arg4 = 0 ;
-  btVector3 *arg5 = 0 ;
-  btScalar arg6 ;
-  
-  (void)jenv;
-  (void)jcls;
-  btVector3 local_arg1;
-  gdx_setbtVector3FromVector3(jenv, local_arg1, jarg1);
-  arg1 = &local_arg1;
-  gdxAutoCommitVector3 auto_commit_arg1(jenv, jarg1, &local_arg1);
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  btVector3 local_arg4;
-  gdx_setbtVector3FromVector3(jenv, local_arg4, jarg4);
-  arg4 = &local_arg4;
-  gdxAutoCommitVector3 auto_commit_arg4(jenv, jarg4, &local_arg4);
-  btVector3 local_arg5;
-  gdx_setbtVector3FromVector3(jenv, local_arg5, jarg5);
-  arg5 = &local_arg5;
-  gdxAutoCommitVector3 auto_commit_arg5(jenv, jarg5, &local_arg5);
-  arg6 = (btScalar)jarg6; 
-  bt_calc_quantization_parameters(*arg1,*arg2,*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5,arg6);
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btStorageResult_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btDiscreteCollisionDetectorInterface::Result **)&baseptr = *(btStorageResult **)&jarg1;
+    return baseptr;
 }
 
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_bt_1quantize_1clamp(JNIEnv *jenv, jclass jcls, jobject jarg1, jobject jarg2, jobject jarg3, jobject jarg4, jobject jarg5) {
-  unsigned short *arg1 = (unsigned short *) 0 ;
-  btVector3 *arg2 = 0 ;
-  btVector3 *arg3 = 0 ;
-  btVector3 *arg4 = 0 ;
-  btVector3 *arg5 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  {
-    arg1 = (unsigned short*)jenv->GetDirectBufferAddress(jarg1);
-    if (arg1 == NULL) {
-      SWIG_JavaThrowException(jenv, SWIG_JavaRuntimeException, "Unable to get address of direct buffer. Buffer must be allocated direct.");
-    }
-  }
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  btVector3 local_arg4;
-  gdx_setbtVector3FromVector3(jenv, local_arg4, jarg4);
-  arg4 = &local_arg4;
-  gdxAutoCommitVector3 auto_commit_arg4(jenv, jarg4, &local_arg4);
-  btVector3 local_arg5;
-  gdx_setbtVector3FromVector3(jenv, local_arg5, jarg5);
-  arg5 = &local_arg5;
-  gdxAutoCommitVector3 auto_commit_arg5(jenv, jarg5, &local_arg5);
-  bt_quantize_clamp(arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5);
-  
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btBroadphaseRayCallback_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btBroadphaseAabbCallback **)&baseptr = *(btBroadphaseRayCallback **)&jarg1;
+    return baseptr;
 }
 
-
-SWIGEXPORT jobject JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_bt_1unquantize(JNIEnv *jenv, jclass jcls, jobject jarg1, jobject jarg2, jobject jarg3) {
-  jobject jresult = 0 ;
-  unsigned short *arg1 = (unsigned short *) 0 ;
-  btVector3 *arg2 = 0 ;
-  btVector3 *arg3 = 0 ;
-  btVector3 result;
-  
-  (void)jenv;
-  (void)jcls;
-  {
-    arg1 = (unsigned short*)jenv->GetDirectBufferAddress(jarg1);
-    if (arg1 == NULL) {
-      SWIG_JavaThrowException(jenv, SWIG_JavaRuntimeException, "Unable to get address of direct buffer. Buffer must be allocated direct.");
-    }
-  }
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  result = bt_unquantize((unsigned short const *)arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
-  jresult = gdx_getReturnVector3(jenv);
-  gdx_setVector3FrombtVector3(jenv, jresult, result);
-  
-  return jresult;
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btDbvtProxy_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btBroadphaseProxy **)&baseptr = *(btDbvtProxy **)&jarg1;
+    return baseptr;
 }
 
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btDbvtBroadphase_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btBroadphaseInterface **)&baseptr = *(btDbvtBroadphase **)&jarg1;
+    return baseptr;
+}
 
-SWIGEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_bt_1mat3_1dot_1col(JNIEnv *jenv, jclass jcls, jobject jarg1, jobject jarg2, jint jarg3) {
-  jfloat jresult = 0 ;
-  btMatrix3x3 *arg1 = 0 ;
-  btVector3 *arg2 = 0 ;
-  int arg3 ;
-  btScalar result;
-  
-  (void)jenv;
-  (void)jcls;
-  btMatrix3x3 local_arg1;
-  gdx_setbtMatrix3x3FromMatrix3(jenv, local_arg1, jarg1);
-  arg1 = &local_arg1;
-  gdxAutoCommitMatrix3 auto_commit_arg1(jenv, jarg1, &local_arg1);
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  arg3 = (int)jarg3; 
-  result = (btScalar)bt_mat3_dot_col((btMatrix3x3 const &)*arg1,(btVector3 const &)*arg2,arg3);
-  jresult = (jfloat)result; 
-  return jresult;
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btSimpleBroadphaseProxy_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btBroadphaseProxy **)&baseptr = *(btSimpleBroadphaseProxy **)&jarg1;
+    return baseptr;
 }
 
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btSimpleBroadphase_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btBroadphaseInterface **)&baseptr = *(btSimpleBroadphase **)&jarg1;
+    return baseptr;
+}
 
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_BT_1BOX_1BOX_1TRANSFORM_1CACHE_1T1to0_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  BT_BOX_BOX_TRANSFORM_CACHE *arg1 = (BT_BOX_BOX_TRANSFORM_CACHE *) 0 ;
-  btVector3 *arg2 = (btVector3 *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(BT_BOX_BOX_TRANSFORM_CACHE **)&jarg1; 
-  arg2 = *(btVector3 **)&jarg2; 
-  if (arg1) (arg1)->m_T1to0 = *arg2;
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btMultiSapBroadphase_1btMultiSapProxy_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btBroadphaseProxy **)&baseptr = *(btMultiSapBroadphase::btMultiSapProxy **)&jarg1;
+    return baseptr;
 }
 
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btMultiSapBroadphase_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btBroadphaseInterface **)&baseptr = *(btMultiSapBroadphase **)&jarg1;
+    return baseptr;
+}
 
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_BT_1BOX_1BOX_1TRANSFORM_1CACHE_1T1to0_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  BT_BOX_BOX_TRANSFORM_CACHE *arg1 = (BT_BOX_BOX_TRANSFORM_CACHE *) 0 ;
-  btVector3 *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(BT_BOX_BOX_TRANSFORM_CACHE **)&jarg1; 
-  result = (btVector3 *)& ((arg1)->m_T1to0);
-  *(btVector3 **)&jresult = result; 
-  return jresult;
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAxisSweep3InternalShort_1Handle_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btBroadphaseProxy **)&baseptr = *(btAxisSweep3Internal< unsigned short >::Handle **)&jarg1;
+    return baseptr;
 }
 
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAxisSweep3InternalShort_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btBroadphaseInterface **)&baseptr = *(btAxisSweep3Internal< unsigned short > **)&jarg1;
+    return baseptr;
+}
 
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_BT_1BOX_1BOX_1TRANSFORM_1CACHE_1R1to0_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
-  BT_BOX_BOX_TRANSFORM_CACHE *arg1 = (BT_BOX_BOX_TRANSFORM_CACHE *) 0 ;
-  btMatrix3x3 arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(BT_BOX_BOX_TRANSFORM_CACHE **)&jarg1; 
-  gdx_setbtMatrix3x3FromMatrix3(jenv, arg2, jarg2);
-  if (arg1) (arg1)->m_R1to0 = arg2;
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAxisSweep3InternalInt_1Handle_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btBroadphaseProxy **)&baseptr = *(btAxisSweep3Internal< unsigned int >::Handle **)&jarg1;
+    return baseptr;
 }
 
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAxisSweep3InternalInt_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btBroadphaseInterface **)&baseptr = *(btAxisSweep3Internal< unsigned int > **)&jarg1;
+    return baseptr;
+}
 
-SWIGEXPORT jobject JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_BT_1BOX_1BOX_1TRANSFORM_1CACHE_1R1to0_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jobject jresult = 0 ;
-  BT_BOX_BOX_TRANSFORM_CACHE *arg1 = (BT_BOX_BOX_TRANSFORM_CACHE *) 0 ;
-  btMatrix3x3 result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(BT_BOX_BOX_TRANSFORM_CACHE **)&jarg1; 
-  result =  ((arg1)->m_R1to0);
-  jresult = gdx_getReturnMatrix3(jenv);
-  gdx_setMatrix3FrombtMatrix3x3(jenv, jresult, result);
-  return jresult;
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAxisSweep3_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btAxisSweep3Internal< unsigned short > **)&baseptr = *(btAxisSweep3 **)&jarg1;
+    return baseptr;
 }
 
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_bt32BitAxisSweep3_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btAxisSweep3Internal< unsigned int > **)&baseptr = *(bt32BitAxisSweep3 **)&jarg1;
+    return baseptr;
+}
 
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_BT_1BOX_1BOX_1TRANSFORM_1CACHE_1AR_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
-  BT_BOX_BOX_TRANSFORM_CACHE *arg1 = (BT_BOX_BOX_TRANSFORM_CACHE *) 0 ;
-  btMatrix3x3 arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(BT_BOX_BOX_TRANSFORM_CACHE **)&jarg1; 
-  gdx_setbtMatrix3x3FromMatrix3(jenv, arg2, jarg2);
-  if (arg1) (arg1)->m_AR = arg2;
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btOverlappingPairCache_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btOverlappingPairCallback **)&baseptr = *(btOverlappingPairCache **)&jarg1;
+    return baseptr;
 }
 
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btHashedOverlappingPairCache_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btOverlappingPairCache **)&baseptr = *(btHashedOverlappingPairCache **)&jarg1;
+    return baseptr;
+}
 
-SWIGEXPORT jobject JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_BT_1BOX_1BOX_1TRANSFORM_1CACHE_1AR_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jobject jresult = 0 ;
-  BT_BOX_BOX_TRANSFORM_CACHE *arg1 = (BT_BOX_BOX_TRANSFORM_CACHE *) 0 ;
-  btMatrix3x3 result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(BT_BOX_BOX_TRANSFORM_CACHE **)&jarg1; 
-  result =  ((arg1)->m_AR);
-  jresult = gdx_getReturnMatrix3(jenv);
-  gdx_setMatrix3FrombtMatrix3x3(jenv, jresult, result);
-  return jresult;
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btSortedOverlappingPairCache_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btOverlappingPairCache **)&baseptr = *(btSortedOverlappingPairCache **)&jarg1;
+    return baseptr;
 }
 
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btNullPairCache_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btOverlappingPairCache **)&baseptr = *(btNullPairCache **)&jarg1;
+    return baseptr;
+}
 
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_BT_1BOX_1BOX_1TRANSFORM_1CACHE_1calc_1absolute_1matrix(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  BT_BOX_BOX_TRANSFORM_CACHE *arg1 = (BT_BOX_BOX_TRANSFORM_CACHE *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(BT_BOX_BOX_TRANSFORM_CACHE **)&jarg1; 
-  (arg1)->calc_absolute_matrix();
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btConvexShape_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btCollisionShape **)&baseptr = *(btConvexShape **)&jarg1;
+    return baseptr;
 }
 
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btConvexInternalShape_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btConvexShape **)&baseptr = *(btConvexInternalShape **)&jarg1;
+    return baseptr;
+}
 
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1BT_1BOX_1BOX_1TRANSFORM_1CACHE(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  BT_BOX_BOX_TRANSFORM_CACHE *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (BT_BOX_BOX_TRANSFORM_CACHE *)new BT_BOX_BOX_TRANSFORM_CACHE();
-  *(BT_BOX_BOX_TRANSFORM_CACHE **)&jresult = result; 
-  return jresult;
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btConvexInternalAabbCachingShape_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btConvexInternalShape **)&baseptr = *(btConvexInternalAabbCachingShape **)&jarg1;
+    return baseptr;
 }
 
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPolyhedralConvexShape_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btConvexInternalShape **)&baseptr = *(btPolyhedralConvexShape **)&jarg1;
+    return baseptr;
+}
 
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_BT_1BOX_1BOX_1TRANSFORM_1CACHE_1calc_1from_1homogenic(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jobject jarg3) {
-  BT_BOX_BOX_TRANSFORM_CACHE *arg1 = (BT_BOX_BOX_TRANSFORM_CACHE *) 0 ;
-  btTransform *arg2 = 0 ;
-  btTransform *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(BT_BOX_BOX_TRANSFORM_CACHE **)&jarg1; 
-  btTransform local_arg2;
-  gdx_setbtTransformFromMatrix4(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitMatrix4 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  btTransform local_arg3;
-  gdx_setbtTransformFromMatrix4(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitMatrix4 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  (arg1)->calc_from_homogenic((btTransform const &)*arg2,(btTransform const &)*arg3);
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPolyhedralConvexAabbCachingShape_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btPolyhedralConvexShape **)&baseptr = *(btPolyhedralConvexAabbCachingShape **)&jarg1;
+    return baseptr;
 }
 
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_BT_1BOX_1BOX_1TRANSFORM_1CACHE_1calc_1from_1full_1invert(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jobject jarg3) {
-  BT_BOX_BOX_TRANSFORM_CACHE *arg1 = (BT_BOX_BOX_TRANSFORM_CACHE *) 0 ;
-  btTransform *arg2 = 0 ;
-  btTransform *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(BT_BOX_BOX_TRANSFORM_CACHE **)&jarg1; 
-  btTransform local_arg2;
-  gdx_setbtTransformFromMatrix4(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitMatrix4 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  btTransform local_arg3;
-  gdx_setbtTransformFromMatrix4(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitMatrix4 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  (arg1)->calc_from_full_invert((btTransform const &)*arg2,(btTransform const &)*arg3);
-}
-
-
-SWIGEXPORT jobject JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_BT_1BOX_1BOX_1TRANSFORM_1CACHE_1transform(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
-  jobject jresult = 0 ;
-  BT_BOX_BOX_TRANSFORM_CACHE *arg1 = (BT_BOX_BOX_TRANSFORM_CACHE *) 0 ;
-  btVector3 *arg2 = 0 ;
-  btVector3 result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(BT_BOX_BOX_TRANSFORM_CACHE **)&jarg1; 
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  result = ((BT_BOX_BOX_TRANSFORM_CACHE const *)arg1)->transform((btVector3 const &)*arg2);
-  jresult = gdx_getReturnVector3(jenv);
-  gdx_setVector3FrombtVector3(jenv, jresult, result);
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1BT_1BOX_1BOX_1TRANSFORM_1CACHE(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  BT_BOX_BOX_TRANSFORM_CACHE *arg1 = (BT_BOX_BOX_TRANSFORM_CACHE *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(BT_BOX_BOX_TRANSFORM_CACHE **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAABB_1min_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  btAABB *arg1 = (btAABB *) 0 ;
-  btVector3 *arg2 = (btVector3 *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btAABB **)&jarg1; 
-  arg2 = *(btVector3 **)&jarg2; 
-  if (arg1) (arg1)->m_min = *arg2;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAABB_1min_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btAABB *arg1 = (btAABB *) 0 ;
-  btVector3 *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btAABB **)&jarg1; 
-  result = (btVector3 *)& ((arg1)->m_min);
-  *(btVector3 **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAABB_1max_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  btAABB *arg1 = (btAABB *) 0 ;
-  btVector3 *arg2 = (btVector3 *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btAABB **)&jarg1; 
-  arg2 = *(btVector3 **)&jarg2; 
-  if (arg1) (arg1)->m_max = *arg2;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAABB_1max_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btAABB *arg1 = (btAABB *) 0 ;
-  btVector3 *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btAABB **)&jarg1; 
-  result = (btVector3 *)& ((arg1)->m_max);
-  *(btVector3 **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btAABB_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  btAABB *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (btAABB *)new btAABB();
-  *(btAABB **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btAABB_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jobject jarg1, jobject jarg2, jobject jarg3) {
-  jlong jresult = 0 ;
-  btVector3 *arg1 = 0 ;
-  btVector3 *arg2 = 0 ;
-  btVector3 *arg3 = 0 ;
-  btAABB *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  btVector3 local_arg1;
-  gdx_setbtVector3FromVector3(jenv, local_arg1, jarg1);
-  arg1 = &local_arg1;
-  gdxAutoCommitVector3 auto_commit_arg1(jenv, jarg1, &local_arg1);
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  result = (btAABB *)new btAABB((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
-  *(btAABB **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btAABB_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jobject jarg1, jobject jarg2, jobject jarg3, jfloat jarg4) {
-  jlong jresult = 0 ;
-  btVector3 *arg1 = 0 ;
-  btVector3 *arg2 = 0 ;
-  btVector3 *arg3 = 0 ;
-  btScalar arg4 ;
-  btAABB *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  btVector3 local_arg1;
-  gdx_setbtVector3FromVector3(jenv, local_arg1, jarg1);
-  arg1 = &local_arg1;
-  gdxAutoCommitVector3 auto_commit_arg1(jenv, jarg1, &local_arg1);
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  arg4 = (btScalar)jarg4; 
-  result = (btAABB *)new btAABB((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
-  *(btAABB **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btAABB_1_1SWIG_13(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btAABB *arg1 = 0 ;
-  btAABB *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btAABB **)&jarg1;
-  if (!arg1) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAABB const & reference is null");
-    return 0;
-  } 
-  result = (btAABB *)new btAABB((btAABB const &)*arg1);
-  *(btAABB **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btAABB_1_1SWIG_14(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jfloat jarg2) {
-  jlong jresult = 0 ;
-  btAABB *arg1 = 0 ;
-  btScalar arg2 ;
-  btAABB *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btAABB **)&jarg1;
-  if (!arg1) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAABB const & reference is null");
-    return 0;
-  } 
-  arg2 = (btScalar)jarg2; 
-  result = (btAABB *)new btAABB((btAABB const &)*arg1,arg2);
-  *(btAABB **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAABB_1invalidate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  btAABB *arg1 = (btAABB *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btAABB **)&jarg1; 
-  (arg1)->invalidate();
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAABB_1increment_1margin(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jfloat jarg2) {
-  btAABB *arg1 = (btAABB *) 0 ;
-  btScalar arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btAABB **)&jarg1; 
-  arg2 = (btScalar)jarg2; 
-  (arg1)->increment_margin(arg2);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAABB_1copy_1with_1margin(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jfloat jarg3) {
-  btAABB *arg1 = (btAABB *) 0 ;
-  btAABB *arg2 = 0 ;
-  btScalar arg3 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btAABB **)&jarg1; 
-  arg2 = *(btAABB **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAABB const & reference is null");
-    return ;
-  } 
-  arg3 = (btScalar)jarg3; 
-  (arg1)->copy_with_margin((btAABB const &)*arg2,arg3);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAABB_1appy_1transform(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
-  btAABB *arg1 = (btAABB *) 0 ;
-  btTransform *arg2 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btAABB **)&jarg1; 
-  btTransform local_arg2;
-  gdx_setbtTransformFromMatrix4(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitMatrix4 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  (arg1)->appy_transform((btTransform const &)*arg2);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAABB_1appy_1transform_1trans_1cache(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  btAABB *arg1 = (btAABB *) 0 ;
-  BT_BOX_BOX_TRANSFORM_CACHE *arg2 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btAABB **)&jarg1; 
-  arg2 = *(BT_BOX_BOX_TRANSFORM_CACHE **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "BT_BOX_BOX_TRANSFORM_CACHE const & reference is null");
-    return ;
-  } 
-  (arg1)->appy_transform_trans_cache((BT_BOX_BOX_TRANSFORM_CACHE const &)*arg2);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAABB_1merge(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  btAABB *arg1 = (btAABB *) 0 ;
-  btAABB *arg2 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btAABB **)&jarg1; 
-  arg2 = *(btAABB **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAABB const & reference is null");
-    return ;
-  } 
-  (arg1)->merge((btAABB const &)*arg2);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAABB_1get_1center_1extend(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jobject jarg3) {
-  btAABB *arg1 = (btAABB *) 0 ;
-  btVector3 *arg2 = 0 ;
-  btVector3 *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btAABB **)&jarg1; 
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  ((btAABB const *)arg1)->get_center_extend(*arg2,*arg3);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAABB_1find_1intersection(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_) {
-  btAABB *arg1 = (btAABB *) 0 ;
-  btAABB *arg2 = 0 ;
-  btAABB *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  (void)jarg3_;
-  arg1 = *(btAABB **)&jarg1; 
-  arg2 = *(btAABB **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAABB const & reference is null");
-    return ;
-  } 
-  arg3 = *(btAABB **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAABB & reference is null");
-    return ;
-  } 
-  ((btAABB const *)arg1)->find_intersection((btAABB const &)*arg2,*arg3);
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAABB_1has_1collision(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  jboolean jresult = 0 ;
-  btAABB *arg1 = (btAABB *) 0 ;
-  btAABB *arg2 = 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btAABB **)&jarg1; 
-  arg2 = *(btAABB **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAABB const & reference is null");
-    return 0;
-  } 
-  result = (bool)((btAABB const *)arg1)->has_collision((btAABB const &)*arg2);
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAABB_1collide_1ray(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jobject jarg3) {
-  jboolean jresult = 0 ;
-  btAABB *arg1 = (btAABB *) 0 ;
-  btVector3 *arg2 = 0 ;
-  btVector3 *arg3 = 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btAABB **)&jarg1; 
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  result = (bool)((btAABB const *)arg1)->collide_ray((btVector3 const &)*arg2,(btVector3 const &)*arg3);
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAABB_1projection_1interval(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jlong jarg3, jlong jarg4) {
-  btAABB *arg1 = (btAABB *) 0 ;
-  btVector3 *arg2 = 0 ;
-  btScalar *arg3 = 0 ;
-  btScalar *arg4 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btAABB **)&jarg1; 
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  arg3 = *(btScalar **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btScalar & reference is null");
-    return ;
-  } 
-  arg4 = *(btScalar **)&jarg4;
-  if (!arg4) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btScalar & reference is null");
-    return ;
-  } 
-  ((btAABB const *)arg1)->projection_interval((btVector3 const &)*arg2,*arg3,*arg4);
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAABB_1plane_1classify(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  jint jresult = 0 ;
-  btAABB *arg1 = (btAABB *) 0 ;
-  btVector4 *arg2 = 0 ;
-  eBT_PLANE_INTERSECTION_TYPE result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btAABB **)&jarg1; 
-  arg2 = *(btVector4 **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btVector4 const & reference is null");
-    return 0;
-  } 
-  result = (eBT_PLANE_INTERSECTION_TYPE)((btAABB const *)arg1)->plane_classify((btVector4 const &)*arg2);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAABB_1overlapping_1trans_1conservative(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jobject jarg3) {
-  jboolean jresult = 0 ;
-  btAABB *arg1 = (btAABB *) 0 ;
-  btAABB *arg2 = 0 ;
-  btTransform *arg3 = 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btAABB **)&jarg1; 
-  arg2 = *(btAABB **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAABB const & reference is null");
-    return 0;
-  } 
-  btTransform local_arg3;
-  gdx_setbtTransformFromMatrix4(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitMatrix4 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  result = (bool)((btAABB const *)arg1)->overlapping_trans_conservative((btAABB const &)*arg2,*arg3);
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAABB_1overlapping_1trans_1conservative2(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_) {
-  jboolean jresult = 0 ;
-  btAABB *arg1 = (btAABB *) 0 ;
-  btAABB *arg2 = 0 ;
-  BT_BOX_BOX_TRANSFORM_CACHE *arg3 = 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  (void)jarg3_;
-  arg1 = *(btAABB **)&jarg1; 
-  arg2 = *(btAABB **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAABB const & reference is null");
-    return 0;
-  } 
-  arg3 = *(BT_BOX_BOX_TRANSFORM_CACHE **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "BT_BOX_BOX_TRANSFORM_CACHE const & reference is null");
-    return 0;
-  } 
-  result = (bool)((btAABB const *)arg1)->overlapping_trans_conservative2((btAABB const &)*arg2,(BT_BOX_BOX_TRANSFORM_CACHE const &)*arg3);
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAABB_1overlapping_1trans_1cache(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_, jboolean jarg4) {
-  jboolean jresult = 0 ;
-  btAABB *arg1 = (btAABB *) 0 ;
-  btAABB *arg2 = 0 ;
-  BT_BOX_BOX_TRANSFORM_CACHE *arg3 = 0 ;
-  bool arg4 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  (void)jarg3_;
-  arg1 = *(btAABB **)&jarg1; 
-  arg2 = *(btAABB **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAABB const & reference is null");
-    return 0;
-  } 
-  arg3 = *(BT_BOX_BOX_TRANSFORM_CACHE **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "BT_BOX_BOX_TRANSFORM_CACHE const & reference is null");
-    return 0;
-  } 
-  arg4 = jarg4 ? true : false; 
-  result = (bool)((btAABB const *)arg1)->overlapping_trans_cache((btAABB const &)*arg2,(BT_BOX_BOX_TRANSFORM_CACHE const &)*arg3,arg4);
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAABB_1collide_1plane(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  jboolean jresult = 0 ;
-  btAABB *arg1 = (btAABB *) 0 ;
-  btVector4 *arg2 = 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btAABB **)&jarg1; 
-  arg2 = *(btVector4 **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btVector4 const & reference is null");
-    return 0;
-  } 
-  result = (bool)((btAABB const *)arg1)->collide_plane((btVector4 const &)*arg2);
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAABB_1collide_1triangle_1exact(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jobject jarg3, jobject jarg4, jlong jarg5, jobject jarg5_) {
-  jboolean jresult = 0 ;
-  btAABB *arg1 = (btAABB *) 0 ;
-  btVector3 *arg2 = 0 ;
-  btVector3 *arg3 = 0 ;
-  btVector3 *arg4 = 0 ;
-  btVector4 *arg5 = 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg5_;
-  arg1 = *(btAABB **)&jarg1; 
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  btVector3 local_arg4;
-  gdx_setbtVector3FromVector3(jenv, local_arg4, jarg4);
-  arg4 = &local_arg4;
-  gdxAutoCommitVector3 auto_commit_arg4(jenv, jarg4, &local_arg4);
-  arg5 = *(btVector4 **)&jarg5;
-  if (!arg5) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btVector4 const & reference is null");
-    return 0;
-  } 
-  result = (bool)((btAABB const *)arg1)->collide_triangle_exact((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector4 const &)*arg5);
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1btAABB(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  btAABB *arg1 = (btAABB *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(btAABB **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btCompareTransformsEqual(JNIEnv *jenv, jclass jcls, jobject jarg1, jobject jarg2) {
-  jboolean jresult = 0 ;
-  btTransform *arg1 = 0 ;
-  btTransform *arg2 = 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  btTransform local_arg1;
-  gdx_setbtTransformFromMatrix4(jenv, local_arg1, jarg1);
-  arg1 = &local_arg1;
-  gdxAutoCommitMatrix4 auto_commit_arg1(jenv, jarg1, &local_arg1);
-  btTransform local_arg2;
-  gdx_setbtTransformFromMatrix4(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitMatrix4 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  result = (bool)btCompareTransformsEqual((btTransform const &)*arg1,(btTransform const &)*arg2);
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_bt_1distance_1point_1plane(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
-  jfloat jresult = 0 ;
-  btVector4 *arg1 = 0 ;
-  btVector3 *arg2 = 0 ;
-  btScalar result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btVector4 **)&jarg1;
-  if (!arg1) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btVector4 const & reference is null");
-    return 0;
-  } 
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  result = (btScalar)bt_distance_point_plane((btVector4 const &)*arg1,(btVector3 const &)*arg2);
-  jresult = (jfloat)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_bt_1vec_1blend(JNIEnv *jenv, jclass jcls, jobject jarg1, jobject jarg2, jobject jarg3, jfloat jarg4) {
-  btVector3 *arg1 = 0 ;
-  btVector3 *arg2 = 0 ;
-  btVector3 *arg3 = 0 ;
-  btScalar arg4 ;
-  
-  (void)jenv;
-  (void)jcls;
-  btVector3 local_arg1;
-  gdx_setbtVector3FromVector3(jenv, local_arg1, jarg1);
-  arg1 = &local_arg1;
-  gdxAutoCommitVector3 auto_commit_arg1(jenv, jarg1, &local_arg1);
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  arg4 = (btScalar)jarg4; 
-  bt_vec_blend(*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_bt_1plane_1clip_1polygon_1collect(JNIEnv *jenv, jclass jcls, jobject jarg1, jobject jarg2, jfloat jarg3, jfloat jarg4, jlong jarg5, jobject jarg5_, jlong jarg6) {
-  btVector3 *arg1 = 0 ;
-  btVector3 *arg2 = 0 ;
-  btScalar arg3 ;
-  btScalar arg4 ;
-  btVector3 *arg5 = (btVector3 *) 0 ;
-  int *arg6 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg5_;
-  btVector3 local_arg1;
-  gdx_setbtVector3FromVector3(jenv, local_arg1, jarg1);
-  arg1 = &local_arg1;
-  gdxAutoCommitVector3 auto_commit_arg1(jenv, jarg1, &local_arg1);
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  arg3 = (btScalar)jarg3; 
-  arg4 = (btScalar)jarg4; 
-  arg5 = *(btVector3 **)&jarg5; 
-  arg6 = *(int **)&jarg6;
-  if (!arg6) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "int & reference is null");
-    return ;
-  } 
-  bt_plane_clip_polygon_collect((btVector3 const &)*arg1,(btVector3 const &)*arg2,arg3,arg4,arg5,*arg6);
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_bt_1plane_1clip_1polygon(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jint jarg3, jlong jarg4, jobject jarg4_) {
-  jint jresult = 0 ;
-  btVector4 *arg1 = 0 ;
-  btVector3 *arg2 = (btVector3 *) 0 ;
-  int arg3 ;
-  btVector3 *arg4 = (btVector3 *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  (void)jarg4_;
-  arg1 = *(btVector4 **)&jarg1;
-  if (!arg1) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btVector4 const & reference is null");
-    return 0;
-  } 
-  arg2 = *(btVector3 **)&jarg2; 
-  arg3 = (int)jarg3; 
-  arg4 = *(btVector3 **)&jarg4; 
-  result = (int)bt_plane_clip_polygon((btVector4 const &)*arg1,(btVector3 const *)arg2,arg3,arg4);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_bt_1plane_1clip_1triangle(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jobject jarg3, jobject jarg4, jlong jarg5, jobject jarg5_) {
-  jint jresult = 0 ;
-  btVector4 *arg1 = 0 ;
-  btVector3 *arg2 = 0 ;
-  btVector3 *arg3 = 0 ;
-  btVector3 *arg4 = 0 ;
-  btVector3 *arg5 = (btVector3 *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg5_;
-  arg1 = *(btVector4 **)&jarg1;
-  if (!arg1) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btVector4 const & reference is null");
-    return 0;
-  } 
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  btVector3 local_arg4;
-  gdx_setbtVector3FromVector3(jenv, local_arg4, jarg4);
-  arg4 = &local_arg4;
-  gdxAutoCommitVector3 auto_commit_arg4(jenv, jarg4, &local_arg4);
-  arg5 = *(btVector3 **)&jarg5; 
-  result = (int)bt_plane_clip_triangle((btVector4 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,arg5);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_bt_1edge_1plane(JNIEnv *jenv, jclass jcls, jobject jarg1, jobject jarg2, jobject jarg3, jlong jarg4, jobject jarg4_) {
-  btVector3 *arg1 = 0 ;
-  btVector3 *arg2 = 0 ;
-  btVector3 *arg3 = 0 ;
-  btVector4 *arg4 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg4_;
-  btVector3 local_arg1;
-  gdx_setbtVector3FromVector3(jenv, local_arg1, jarg1);
-  arg1 = &local_arg1;
-  gdxAutoCommitVector3 auto_commit_arg1(jenv, jarg1, &local_arg1);
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  arg4 = *(btVector4 **)&jarg4;
-  if (!arg4) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btVector4 & reference is null");
-    return ;
-  } 
-  bt_edge_plane((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_bt_1closest_1point_1on_1segment(JNIEnv *jenv, jclass jcls, jobject jarg1, jobject jarg2, jobject jarg3, jobject jarg4) {
-  btVector3 *arg1 = 0 ;
-  btVector3 *arg2 = 0 ;
-  btVector3 *arg3 = 0 ;
-  btVector3 *arg4 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  btVector3 local_arg1;
-  gdx_setbtVector3FromVector3(jenv, local_arg1, jarg1);
-  arg1 = &local_arg1;
-  gdxAutoCommitVector3 auto_commit_arg1(jenv, jarg1, &local_arg1);
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  btVector3 local_arg4;
-  gdx_setbtVector3FromVector3(jenv, local_arg4, jarg4);
-  arg4 = &local_arg4;
-  gdxAutoCommitVector3 auto_commit_arg4(jenv, jarg4, &local_arg4);
-  bt_closest_point_on_segment(*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_bt_1line_1plane_1collision(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jobject jarg3, jobject jarg4, jlong jarg5, jfloat jarg6, jfloat jarg7) {
-  jint jresult = 0 ;
-  btVector4 *arg1 = 0 ;
-  btVector3 *arg2 = 0 ;
-  btVector3 *arg3 = 0 ;
-  btVector3 *arg4 = 0 ;
-  btScalar *arg5 = 0 ;
-  btScalar arg6 ;
-  btScalar arg7 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btVector4 **)&jarg1;
-  if (!arg1) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btVector4 const & reference is null");
-    return 0;
-  } 
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  btVector3 local_arg4;
-  gdx_setbtVector3FromVector3(jenv, local_arg4, jarg4);
-  arg4 = &local_arg4;
-  gdxAutoCommitVector3 auto_commit_arg4(jenv, jarg4, &local_arg4);
-  arg5 = *(btScalar **)&jarg5;
-  if (!arg5) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btScalar & reference is null");
-    return 0;
-  } 
-  arg6 = (btScalar)jarg6; 
-  arg7 = (btScalar)jarg7; 
-  result = (int)bt_line_plane_collision((btVector4 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4,*arg5,arg6,arg7);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_bt_1segment_1collision(JNIEnv *jenv, jclass jcls, jobject jarg1, jobject jarg2, jobject jarg3, jobject jarg4, jobject jarg5, jobject jarg6) {
-  btVector3 *arg1 = 0 ;
-  btVector3 *arg2 = 0 ;
-  btVector3 *arg3 = 0 ;
-  btVector3 *arg4 = 0 ;
-  btVector3 *arg5 = 0 ;
-  btVector3 *arg6 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  btVector3 local_arg1;
-  gdx_setbtVector3FromVector3(jenv, local_arg1, jarg1);
-  arg1 = &local_arg1;
-  gdxAutoCommitVector3 auto_commit_arg1(jenv, jarg1, &local_arg1);
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  btVector3 local_arg4;
-  gdx_setbtVector3FromVector3(jenv, local_arg4, jarg4);
-  arg4 = &local_arg4;
-  gdxAutoCommitVector3 auto_commit_arg4(jenv, jarg4, &local_arg4);
-  btVector3 local_arg5;
-  gdx_setbtVector3FromVector3(jenv, local_arg5, jarg5);
-  arg5 = &local_arg5;
-  gdxAutoCommitVector3 auto_commit_arg5(jenv, jarg5, &local_arg5);
-  btVector3 local_arg6;
-  gdx_setbtVector3FromVector3(jenv, local_arg6, jarg6);
-  arg6 = &local_arg6;
-  gdxAutoCommitVector3 auto_commit_arg6(jenv, jarg6, &local_arg6);
-  bt_segment_collision((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,*arg5,*arg6);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1TRIANGLE_1CONTACT_1penetration_1depth_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jfloat jarg2) {
-  GIM_TRIANGLE_CONTACT *arg1 = (GIM_TRIANGLE_CONTACT *) 0 ;
-  btScalar arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_TRIANGLE_CONTACT **)&jarg1; 
-  arg2 = (btScalar)jarg2; 
-  if (arg1) (arg1)->m_penetration_depth = arg2;
-}
-
-
-SWIGEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1TRIANGLE_1CONTACT_1penetration_1depth_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jfloat jresult = 0 ;
-  GIM_TRIANGLE_CONTACT *arg1 = (GIM_TRIANGLE_CONTACT *) 0 ;
-  btScalar result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_TRIANGLE_CONTACT **)&jarg1; 
-  result = (btScalar) ((arg1)->m_penetration_depth);
-  jresult = (jfloat)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1TRIANGLE_1CONTACT_1point_1count_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  GIM_TRIANGLE_CONTACT *arg1 = (GIM_TRIANGLE_CONTACT *) 0 ;
-  int arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_TRIANGLE_CONTACT **)&jarg1; 
-  arg2 = (int)jarg2; 
-  if (arg1) (arg1)->m_point_count = arg2;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1TRIANGLE_1CONTACT_1point_1count_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  GIM_TRIANGLE_CONTACT *arg1 = (GIM_TRIANGLE_CONTACT *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_TRIANGLE_CONTACT **)&jarg1; 
-  result = (int) ((arg1)->m_point_count);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1TRIANGLE_1CONTACT_1separating_1normal_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  GIM_TRIANGLE_CONTACT *arg1 = (GIM_TRIANGLE_CONTACT *) 0 ;
-  btVector4 *arg2 = (btVector4 *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(GIM_TRIANGLE_CONTACT **)&jarg1; 
-  arg2 = *(btVector4 **)&jarg2; 
-  if (arg1) (arg1)->m_separating_normal = *arg2;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1TRIANGLE_1CONTACT_1separating_1normal_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  GIM_TRIANGLE_CONTACT *arg1 = (GIM_TRIANGLE_CONTACT *) 0 ;
-  btVector4 *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_TRIANGLE_CONTACT **)&jarg1; 
-  result = (btVector4 *)& ((arg1)->m_separating_normal);
-  *(btVector4 **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1TRIANGLE_1CONTACT_1points_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  GIM_TRIANGLE_CONTACT *arg1 = (GIM_TRIANGLE_CONTACT *) 0 ;
-  btVector3 *arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(GIM_TRIANGLE_CONTACT **)&jarg1; 
-  arg2 = *(btVector3 **)&jarg2; 
-  {
-    size_t ii;
-    btVector3 *b = (btVector3 *) arg1->m_points;
-    for (ii = 0; ii < (size_t)16; ii++) b[ii] = *((btVector3 *) arg2 + ii);
-  }
-  
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1TRIANGLE_1CONTACT_1points_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  GIM_TRIANGLE_CONTACT *arg1 = (GIM_TRIANGLE_CONTACT *) 0 ;
-  btVector3 *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_TRIANGLE_CONTACT **)&jarg1; 
-  result = (btVector3 *)(btVector3 *) ((arg1)->m_points);
-  *(btVector3 **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1TRIANGLE_1CONTACT_1copy_1from(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  GIM_TRIANGLE_CONTACT *arg1 = (GIM_TRIANGLE_CONTACT *) 0 ;
-  GIM_TRIANGLE_CONTACT *arg2 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(GIM_TRIANGLE_CONTACT **)&jarg1; 
-  arg2 = *(GIM_TRIANGLE_CONTACT **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "GIM_TRIANGLE_CONTACT const & reference is null");
-    return ;
-  } 
-  (arg1)->copy_from((GIM_TRIANGLE_CONTACT const &)*arg2);
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1GIM_1TRIANGLE_1CONTACT_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  GIM_TRIANGLE_CONTACT *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (GIM_TRIANGLE_CONTACT *)new GIM_TRIANGLE_CONTACT();
-  *(GIM_TRIANGLE_CONTACT **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1GIM_1TRIANGLE_1CONTACT_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  GIM_TRIANGLE_CONTACT *arg1 = 0 ;
-  GIM_TRIANGLE_CONTACT *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_TRIANGLE_CONTACT **)&jarg1;
-  if (!arg1) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "GIM_TRIANGLE_CONTACT const & reference is null");
-    return 0;
-  } 
-  result = (GIM_TRIANGLE_CONTACT *)new GIM_TRIANGLE_CONTACT((GIM_TRIANGLE_CONTACT const &)*arg1);
-  *(GIM_TRIANGLE_CONTACT **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1TRIANGLE_1CONTACT_1merge_1points(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jfloat jarg3, jlong jarg4, jobject jarg4_, jint jarg5) {
-  GIM_TRIANGLE_CONTACT *arg1 = (GIM_TRIANGLE_CONTACT *) 0 ;
-  btVector4 *arg2 = 0 ;
-  btScalar arg3 ;
-  btVector3 *arg4 = (btVector3 *) 0 ;
-  int arg5 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  (void)jarg4_;
-  arg1 = *(GIM_TRIANGLE_CONTACT **)&jarg1; 
-  arg2 = *(btVector4 **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btVector4 const & reference is null");
-    return ;
-  } 
-  arg3 = (btScalar)jarg3; 
-  arg4 = *(btVector3 **)&jarg4; 
-  arg5 = (int)jarg5; 
-  (arg1)->merge_points((btVector4 const &)*arg2,arg3,(btVector3 const *)arg4,arg5);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1GIM_1TRIANGLE_1CONTACT(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  GIM_TRIANGLE_CONTACT *arg1 = (GIM_TRIANGLE_CONTACT *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(GIM_TRIANGLE_CONTACT **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPrimitiveTriangle_1vertices_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  btPrimitiveTriangle *arg1 = (btPrimitiveTriangle *) 0 ;
-  btVector3 *arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btPrimitiveTriangle **)&jarg1; 
-  arg2 = *(btVector3 **)&jarg2; 
-  {
-    size_t ii;
-    btVector3 *b = (btVector3 *) arg1->m_vertices;
-    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((btVector3 *) arg2 + ii);
-  }
-  
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPrimitiveTriangle_1vertices_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btPrimitiveTriangle *arg1 = (btPrimitiveTriangle *) 0 ;
-  btVector3 *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btPrimitiveTriangle **)&jarg1; 
-  result = (btVector3 *)(btVector3 *) ((arg1)->m_vertices);
-  *(btVector3 **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPrimitiveTriangle_1plane_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  btPrimitiveTriangle *arg1 = (btPrimitiveTriangle *) 0 ;
-  btVector4 *arg2 = (btVector4 *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btPrimitiveTriangle **)&jarg1; 
-  arg2 = *(btVector4 **)&jarg2; 
-  if (arg1) (arg1)->m_plane = *arg2;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPrimitiveTriangle_1plane_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btPrimitiveTriangle *arg1 = (btPrimitiveTriangle *) 0 ;
-  btVector4 *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btPrimitiveTriangle **)&jarg1; 
-  result = (btVector4 *)& ((arg1)->m_plane);
-  *(btVector4 **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPrimitiveTriangle_1margin_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jfloat jarg2) {
-  btPrimitiveTriangle *arg1 = (btPrimitiveTriangle *) 0 ;
-  btScalar arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btPrimitiveTriangle **)&jarg1; 
-  arg2 = (btScalar)jarg2; 
-  if (arg1) (arg1)->m_margin = arg2;
-}
-
-
-SWIGEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPrimitiveTriangle_1margin_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jfloat jresult = 0 ;
-  btPrimitiveTriangle *arg1 = (btPrimitiveTriangle *) 0 ;
-  btScalar result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btPrimitiveTriangle **)&jarg1; 
-  result = (btScalar) ((arg1)->m_margin);
-  jresult = (jfloat)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPrimitiveTriangle_1dummy_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jfloat jarg2) {
-  btPrimitiveTriangle *arg1 = (btPrimitiveTriangle *) 0 ;
-  btScalar arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btPrimitiveTriangle **)&jarg1; 
-  arg2 = (btScalar)jarg2; 
-  if (arg1) (arg1)->m_dummy = arg2;
-}
-
-
-SWIGEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPrimitiveTriangle_1dummy_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jfloat jresult = 0 ;
-  btPrimitiveTriangle *arg1 = (btPrimitiveTriangle *) 0 ;
-  btScalar result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btPrimitiveTriangle **)&jarg1; 
-  result = (btScalar) ((arg1)->m_dummy);
-  jresult = (jfloat)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btPrimitiveTriangle(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  btPrimitiveTriangle *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (btPrimitiveTriangle *)new btPrimitiveTriangle();
-  *(btPrimitiveTriangle **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPrimitiveTriangle_1buildTriPlane(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  btPrimitiveTriangle *arg1 = (btPrimitiveTriangle *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btPrimitiveTriangle **)&jarg1; 
-  (arg1)->buildTriPlane();
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPrimitiveTriangle_1overlap_1test_1conservative(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  jboolean jresult = 0 ;
-  btPrimitiveTriangle *arg1 = (btPrimitiveTriangle *) 0 ;
-  btPrimitiveTriangle *arg2 = 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btPrimitiveTriangle **)&jarg1; 
-  arg2 = *(btPrimitiveTriangle **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btPrimitiveTriangle const & reference is null");
-    return 0;
-  } 
-  result = (bool)(arg1)->overlap_test_conservative((btPrimitiveTriangle const &)*arg2);
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPrimitiveTriangle_1get_1edge_1plane(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3, jobject jarg3_) {
-  btPrimitiveTriangle *arg1 = (btPrimitiveTriangle *) 0 ;
-  int arg2 ;
-  btVector4 *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg3_;
-  arg1 = *(btPrimitiveTriangle **)&jarg1; 
-  arg2 = (int)jarg2; 
-  arg3 = *(btVector4 **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btVector4 & reference is null");
-    return ;
-  } 
-  ((btPrimitiveTriangle const *)arg1)->get_edge_plane(arg2,*arg3);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPrimitiveTriangle_1applyTransform(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
-  btPrimitiveTriangle *arg1 = (btPrimitiveTriangle *) 0 ;
-  btTransform *arg2 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btPrimitiveTriangle **)&jarg1; 
-  btTransform local_arg2;
-  gdx_setbtTransformFromMatrix4(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitMatrix4 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  (arg1)->applyTransform((btTransform const &)*arg2);
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPrimitiveTriangle_1clip_1triangle(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_) {
-  jint jresult = 0 ;
-  btPrimitiveTriangle *arg1 = (btPrimitiveTriangle *) 0 ;
-  btPrimitiveTriangle *arg2 = 0 ;
-  btVector3 *arg3 = (btVector3 *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  (void)jarg3_;
-  arg1 = *(btPrimitiveTriangle **)&jarg1; 
-  arg2 = *(btPrimitiveTriangle **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btPrimitiveTriangle & reference is null");
-    return 0;
-  } 
-  arg3 = *(btVector3 **)&jarg3; 
-  result = (int)(arg1)->clip_triangle(*arg2,arg3);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPrimitiveTriangle_1find_1triangle_1collision_1clip_1method(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_) {
-  jboolean jresult = 0 ;
-  btPrimitiveTriangle *arg1 = (btPrimitiveTriangle *) 0 ;
-  btPrimitiveTriangle *arg2 = 0 ;
-  GIM_TRIANGLE_CONTACT *arg3 = 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  (void)jarg3_;
-  arg1 = *(btPrimitiveTriangle **)&jarg1; 
-  arg2 = *(btPrimitiveTriangle **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btPrimitiveTriangle & reference is null");
-    return 0;
-  } 
-  arg3 = *(GIM_TRIANGLE_CONTACT **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "GIM_TRIANGLE_CONTACT & reference is null");
-    return 0;
-  } 
-  result = (bool)(arg1)->find_triangle_collision_clip_method(*arg2,*arg3);
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1btPrimitiveTriangle(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  btPrimitiveTriangle *arg1 = (btPrimitiveTriangle *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(btPrimitiveTriangle **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btTriangleShapeEx_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  btTriangleShapeEx *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (btTriangleShapeEx *)new btTriangleShapeEx();
-  *(btTriangleShapeEx **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btTriangleShapeEx_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jobject jarg1, jobject jarg2, jobject jarg3) {
-  jlong jresult = 0 ;
-  btVector3 *arg1 = 0 ;
-  btVector3 *arg2 = 0 ;
-  btVector3 *arg3 = 0 ;
-  btTriangleShapeEx *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  btVector3 local_arg1;
-  gdx_setbtVector3FromVector3(jenv, local_arg1, jarg1);
-  arg1 = &local_arg1;
-  gdxAutoCommitVector3 auto_commit_arg1(jenv, jarg1, &local_arg1);
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  result = (btTriangleShapeEx *)new btTriangleShapeEx((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btVector3 const &)*arg3);
-  *(btTriangleShapeEx **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btTriangleShapeEx_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btTriangleShapeEx *arg1 = 0 ;
-  btTriangleShapeEx *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btTriangleShapeEx **)&jarg1;
-  if (!arg1) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btTriangleShapeEx const & reference is null");
-    return 0;
-  } 
-  result = (btTriangleShapeEx *)new btTriangleShapeEx((btTriangleShapeEx const &)*arg1);
-  *(btTriangleShapeEx **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btTriangleShapeEx_1applyTransform(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
-  btTriangleShapeEx *arg1 = (btTriangleShapeEx *) 0 ;
-  btTransform *arg2 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btTriangleShapeEx **)&jarg1; 
-  btTransform local_arg2;
-  gdx_setbtTransformFromMatrix4(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitMatrix4 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  (arg1)->applyTransform((btTransform const &)*arg2);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btTriangleShapeEx_1buildTriPlane(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  btTriangleShapeEx *arg1 = (btTriangleShapeEx *) 0 ;
-  btVector4 *arg2 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btTriangleShapeEx **)&jarg1; 
-  arg2 = *(btVector4 **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btVector4 & reference is null");
-    return ;
-  } 
-  ((btTriangleShapeEx const *)arg1)->buildTriPlane(*arg2);
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btTriangleShapeEx_1overlap_1test_1conservative(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  jboolean jresult = 0 ;
-  btTriangleShapeEx *arg1 = (btTriangleShapeEx *) 0 ;
-  btTriangleShapeEx *arg2 = 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btTriangleShapeEx **)&jarg1; 
-  arg2 = *(btTriangleShapeEx **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btTriangleShapeEx const & reference is null");
-    return 0;
-  } 
-  result = (bool)(arg1)->overlap_test_conservative((btTriangleShapeEx const &)*arg2);
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1btTriangleShapeEx(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  btTriangleShapeEx *arg1 = (btTriangleShapeEx *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(btTriangleShapeEx **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1PAIR_1index1_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  GIM_PAIR *arg1 = (GIM_PAIR *) 0 ;
-  int arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_PAIR **)&jarg1; 
-  arg2 = (int)jarg2; 
-  if (arg1) (arg1)->m_index1 = arg2;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1PAIR_1index1_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  GIM_PAIR *arg1 = (GIM_PAIR *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_PAIR **)&jarg1; 
-  result = (int) ((arg1)->m_index1);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1PAIR_1index2_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  GIM_PAIR *arg1 = (GIM_PAIR *) 0 ;
-  int arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_PAIR **)&jarg1; 
-  arg2 = (int)jarg2; 
-  if (arg1) (arg1)->m_index2 = arg2;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1PAIR_1index2_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  GIM_PAIR *arg1 = (GIM_PAIR *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_PAIR **)&jarg1; 
-  result = (int) ((arg1)->m_index2);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1GIM_1PAIR_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  GIM_PAIR *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (GIM_PAIR *)new GIM_PAIR();
-  *(GIM_PAIR **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1GIM_1PAIR_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  GIM_PAIR *arg1 = 0 ;
-  GIM_PAIR *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_PAIR **)&jarg1;
-  if (!arg1) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "GIM_PAIR const & reference is null");
-    return 0;
-  } 
-  result = (GIM_PAIR *)new GIM_PAIR((GIM_PAIR const &)*arg1);
-  *(GIM_PAIR **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1GIM_1PAIR_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jint jarg1, jint jarg2) {
-  jlong jresult = 0 ;
-  int arg1 ;
-  int arg2 ;
-  GIM_PAIR *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = (int)jarg1; 
-  arg2 = (int)jarg2; 
-  result = (GIM_PAIR *)new GIM_PAIR(arg1,arg2);
-  *(GIM_PAIR **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1GIM_1PAIR(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  GIM_PAIR *arg1 = (GIM_PAIR *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(GIM_PAIR **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btPairSet(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  btPairSet *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (btPairSet *)new btPairSet();
-  *(btPairSet **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPairSet_1push_1pair(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3) {
-  btPairSet *arg1 = (btPairSet *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btPairSet **)&jarg1; 
-  arg2 = (int)jarg2; 
-  arg3 = (int)jarg3; 
-  (arg1)->push_pair(arg2,arg3);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPairSet_1push_1pair_1inv(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3) {
-  btPairSet *arg1 = (btPairSet *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btPairSet **)&jarg1; 
-  arg2 = (int)jarg2; 
-  arg3 = (int)jarg3; 
-  (arg1)->push_pair_inv(arg2,arg3);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1btPairSet(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  btPairSet *arg1 = (btPairSet *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(btPairSet **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1BVH_1DATA_1bound_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  GIM_BVH_DATA *arg1 = (GIM_BVH_DATA *) 0 ;
-  btAABB *arg2 = (btAABB *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(GIM_BVH_DATA **)&jarg1; 
-  arg2 = *(btAABB **)&jarg2; 
-  if (arg1) (arg1)->m_bound = *arg2;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1BVH_1DATA_1bound_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  GIM_BVH_DATA *arg1 = (GIM_BVH_DATA *) 0 ;
-  btAABB *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_BVH_DATA **)&jarg1; 
-  result = (btAABB *)& ((arg1)->m_bound);
-  *(btAABB **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1BVH_1DATA_1data_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  GIM_BVH_DATA *arg1 = (GIM_BVH_DATA *) 0 ;
-  int arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_BVH_DATA **)&jarg1; 
-  arg2 = (int)jarg2; 
-  if (arg1) (arg1)->m_data = arg2;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1BVH_1DATA_1data_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  GIM_BVH_DATA *arg1 = (GIM_BVH_DATA *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_BVH_DATA **)&jarg1; 
-  result = (int) ((arg1)->m_data);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1GIM_1BVH_1DATA(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  GIM_BVH_DATA *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (GIM_BVH_DATA *)new GIM_BVH_DATA();
-  *(GIM_BVH_DATA **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1GIM_1BVH_1DATA(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  GIM_BVH_DATA *arg1 = (GIM_BVH_DATA *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(GIM_BVH_DATA **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1BVH_1TREE_1NODE_1bound_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  GIM_BVH_TREE_NODE *arg1 = (GIM_BVH_TREE_NODE *) 0 ;
-  btAABB *arg2 = (btAABB *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(GIM_BVH_TREE_NODE **)&jarg1; 
-  arg2 = *(btAABB **)&jarg2; 
-  if (arg1) (arg1)->m_bound = *arg2;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1BVH_1TREE_1NODE_1bound_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  GIM_BVH_TREE_NODE *arg1 = (GIM_BVH_TREE_NODE *) 0 ;
-  btAABB *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_BVH_TREE_NODE **)&jarg1; 
-  result = (btAABB *)& ((arg1)->m_bound);
-  *(btAABB **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1GIM_1BVH_1TREE_1NODE(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  GIM_BVH_TREE_NODE *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (GIM_BVH_TREE_NODE *)new GIM_BVH_TREE_NODE();
-  *(GIM_BVH_TREE_NODE **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1BVH_1TREE_1NODE_1isLeafNode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jboolean jresult = 0 ;
-  GIM_BVH_TREE_NODE *arg1 = (GIM_BVH_TREE_NODE *) 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_BVH_TREE_NODE **)&jarg1; 
-  result = (bool)((GIM_BVH_TREE_NODE const *)arg1)->isLeafNode();
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1BVH_1TREE_1NODE_1getEscapeIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  GIM_BVH_TREE_NODE *arg1 = (GIM_BVH_TREE_NODE *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_BVH_TREE_NODE **)&jarg1; 
-  result = (int)((GIM_BVH_TREE_NODE const *)arg1)->getEscapeIndex();
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1BVH_1TREE_1NODE_1setEscapeIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  GIM_BVH_TREE_NODE *arg1 = (GIM_BVH_TREE_NODE *) 0 ;
-  int arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_BVH_TREE_NODE **)&jarg1; 
-  arg2 = (int)jarg2; 
-  (arg1)->setEscapeIndex(arg2);
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1BVH_1TREE_1NODE_1getDataIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  GIM_BVH_TREE_NODE *arg1 = (GIM_BVH_TREE_NODE *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_BVH_TREE_NODE **)&jarg1; 
-  result = (int)((GIM_BVH_TREE_NODE const *)arg1)->getDataIndex();
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1BVH_1TREE_1NODE_1setDataIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  GIM_BVH_TREE_NODE *arg1 = (GIM_BVH_TREE_NODE *) 0 ;
-  int arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_BVH_TREE_NODE **)&jarg1; 
-  arg2 = (int)jarg2; 
-  (arg1)->setDataIndex(arg2);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1GIM_1BVH_1TREE_1NODE(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  GIM_BVH_TREE_NODE *arg1 = (GIM_BVH_TREE_NODE *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(GIM_BVH_TREE_NODE **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1GIM_1BVH_1DATA_1ARRAY(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  GIM_BVH_DATA_ARRAY *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (GIM_BVH_DATA_ARRAY *)new GIM_BVH_DATA_ARRAY();
-  *(GIM_BVH_DATA_ARRAY **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1GIM_1BVH_1DATA_1ARRAY(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  GIM_BVH_DATA_ARRAY *arg1 = (GIM_BVH_DATA_ARRAY *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(GIM_BVH_DATA_ARRAY **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1GIM_1BVH_1TREE_1NODE_1ARRAY(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  GIM_BVH_TREE_NODE_ARRAY *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (GIM_BVH_TREE_NODE_ARRAY *)new GIM_BVH_TREE_NODE_ARRAY();
-  *(GIM_BVH_TREE_NODE_ARRAY **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1GIM_1BVH_1TREE_1NODE_1ARRAY(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  GIM_BVH_TREE_NODE_ARRAY *arg1 = (GIM_BVH_TREE_NODE_ARRAY *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(GIM_BVH_TREE_NODE_ARRAY **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btBvhTree(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  btBvhTree *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (btBvhTree *)new btBvhTree();
-  *(btBvhTree **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btBvhTree_1build_1tree(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  btBvhTree *arg1 = (btBvhTree *) 0 ;
-  GIM_BVH_DATA_ARRAY *arg2 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btBvhTree **)&jarg1; 
-  arg2 = *(GIM_BVH_DATA_ARRAY **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "GIM_BVH_DATA_ARRAY & reference is null");
-    return ;
-  } 
-  (arg1)->build_tree(*arg2);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btBvhTree_1clearNodes(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  btBvhTree *arg1 = (btBvhTree *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btBvhTree **)&jarg1; 
-  (arg1)->clearNodes();
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btBvhTree_1getNodeCount(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btBvhTree *arg1 = (btBvhTree *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btBvhTree **)&jarg1; 
-  result = (int)((btBvhTree const *)arg1)->getNodeCount();
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btBvhTree_1isLeafNode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jboolean jresult = 0 ;
-  btBvhTree *arg1 = (btBvhTree *) 0 ;
-  int arg2 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btBvhTree **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (bool)((btBvhTree const *)arg1)->isLeafNode(arg2);
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btBvhTree_1getNodeData(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jint jresult = 0 ;
-  btBvhTree *arg1 = (btBvhTree *) 0 ;
-  int arg2 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btBvhTree **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (int)((btBvhTree const *)arg1)->getNodeData(arg2);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btBvhTree_1getNodeBound(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3, jobject jarg3_) {
-  btBvhTree *arg1 = (btBvhTree *) 0 ;
-  int arg2 ;
-  btAABB *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg3_;
-  arg1 = *(btBvhTree **)&jarg1; 
-  arg2 = (int)jarg2; 
-  arg3 = *(btAABB **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAABB & reference is null");
-    return ;
-  } 
-  ((btBvhTree const *)arg1)->getNodeBound(arg2,*arg3);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btBvhTree_1setNodeBound(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3, jobject jarg3_) {
-  btBvhTree *arg1 = (btBvhTree *) 0 ;
-  int arg2 ;
-  btAABB *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg3_;
-  arg1 = *(btBvhTree **)&jarg1; 
-  arg2 = (int)jarg2; 
-  arg3 = *(btAABB **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAABB const & reference is null");
-    return ;
-  } 
-  (arg1)->setNodeBound(arg2,(btAABB const &)*arg3);
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btBvhTree_1getLeftNode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jint jresult = 0 ;
-  btBvhTree *arg1 = (btBvhTree *) 0 ;
-  int arg2 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btBvhTree **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (int)((btBvhTree const *)arg1)->getLeftNode(arg2);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btBvhTree_1getRightNode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jint jresult = 0 ;
-  btBvhTree *arg1 = (btBvhTree *) 0 ;
-  int arg2 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btBvhTree **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (int)((btBvhTree const *)arg1)->getRightNode(arg2);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btBvhTree_1getEscapeNodeIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jint jresult = 0 ;
-  btBvhTree *arg1 = (btBvhTree *) 0 ;
-  int arg2 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btBvhTree **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (int)((btBvhTree const *)arg1)->getEscapeNodeIndex(arg2);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btBvhTree_1get_1node_1pointer_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jlong jresult = 0 ;
-  btBvhTree *arg1 = (btBvhTree *) 0 ;
-  int arg2 ;
-  GIM_BVH_TREE_NODE *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btBvhTree **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (GIM_BVH_TREE_NODE *)((btBvhTree const *)arg1)->get_node_pointer(arg2);
-  *(GIM_BVH_TREE_NODE **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btBvhTree_1get_1node_1pointer_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btBvhTree *arg1 = (btBvhTree *) 0 ;
-  GIM_BVH_TREE_NODE *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btBvhTree **)&jarg1; 
-  result = (GIM_BVH_TREE_NODE *)((btBvhTree const *)arg1)->get_node_pointer();
-  *(GIM_BVH_TREE_NODE **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1btBvhTree(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  btBvhTree *arg1 = (btBvhTree *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(btBvhTree **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1btPrimitiveManagerBase(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  btPrimitiveManagerBase *arg1 = (btPrimitiveManagerBase *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(btPrimitiveManagerBase **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPrimitiveManagerBase_1is_1trimesh(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jboolean jresult = 0 ;
-  btPrimitiveManagerBase *arg1 = (btPrimitiveManagerBase *) 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btPrimitiveManagerBase **)&jarg1; 
-  result = (bool)((btPrimitiveManagerBase const *)arg1)->is_trimesh();
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPrimitiveManagerBase_1get_1primitive_1count(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btPrimitiveManagerBase *arg1 = (btPrimitiveManagerBase *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btPrimitiveManagerBase **)&jarg1; 
-  result = (int)((btPrimitiveManagerBase const *)arg1)->get_primitive_count();
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPrimitiveManagerBase_1get_1primitive_1box(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3, jobject jarg3_) {
-  btPrimitiveManagerBase *arg1 = (btPrimitiveManagerBase *) 0 ;
-  int arg2 ;
-  btAABB *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg3_;
-  arg1 = *(btPrimitiveManagerBase **)&jarg1; 
-  arg2 = (int)jarg2; 
-  arg3 = *(btAABB **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAABB & reference is null");
-    return ;
-  } 
-  ((btPrimitiveManagerBase const *)arg1)->get_primitive_box(arg2,*arg3);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPrimitiveManagerBase_1get_1primitive_1triangle(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3, jobject jarg3_) {
-  btPrimitiveManagerBase *arg1 = (btPrimitiveManagerBase *) 0 ;
-  int arg2 ;
-  btPrimitiveTriangle *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg3_;
-  arg1 = *(btPrimitiveManagerBase **)&jarg1; 
-  arg2 = (int)jarg2; 
-  arg3 = *(btPrimitiveTriangle **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btPrimitiveTriangle & reference is null");
-    return ;
-  } 
-  ((btPrimitiveManagerBase const *)arg1)->get_primitive_triangle(arg2,*arg3);
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btGImpactBvh_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  btGImpactBvh *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (btGImpactBvh *)new btGImpactBvh();
-  *(btGImpactBvh **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btGImpactBvh_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btPrimitiveManagerBase *arg1 = (btPrimitiveManagerBase *) 0 ;
-  btGImpactBvh *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btPrimitiveManagerBase **)&jarg1; 
-  result = (btGImpactBvh *)new btGImpactBvh(arg1);
-  *(btGImpactBvh **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactBvh_1getGlobalBox(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGImpactBvh *arg1 = (btGImpactBvh *) 0 ;
-  btAABB result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactBvh **)&jarg1; 
-  result = ((btGImpactBvh const *)arg1)->getGlobalBox();
-  *(btAABB **)&jresult = new btAABB((const btAABB &)result); 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactBvh_1setPrimitiveManager(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  btGImpactBvh *arg1 = (btGImpactBvh *) 0 ;
-  btPrimitiveManagerBase *arg2 = (btPrimitiveManagerBase *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btGImpactBvh **)&jarg1; 
-  arg2 = *(btPrimitiveManagerBase **)&jarg2; 
-  (arg1)->setPrimitiveManager(arg2);
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactBvh_1getPrimitiveManager(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGImpactBvh *arg1 = (btGImpactBvh *) 0 ;
-  btPrimitiveManagerBase *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactBvh **)&jarg1; 
-  result = (btPrimitiveManagerBase *)((btGImpactBvh const *)arg1)->getPrimitiveManager();
-  *(btPrimitiveManagerBase **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactBvh_1update(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  btGImpactBvh *arg1 = (btGImpactBvh *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactBvh **)&jarg1; 
-  (arg1)->update();
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactBvh_1buildSet(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  btGImpactBvh *arg1 = (btGImpactBvh *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactBvh **)&jarg1; 
-  (arg1)->buildSet();
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactBvh_1boxQuery(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3) {
-  jboolean jresult = 0 ;
-  btGImpactBvh *arg1 = (btGImpactBvh *) 0 ;
-  btAABB *arg2 = 0 ;
-  btAlignedObjectArray< int > *arg3 = 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btGImpactBvh **)&jarg1; 
-  arg2 = *(btAABB **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAABB const & reference is null");
-    return 0;
-  } 
-  arg3 = *(btAlignedObjectArray< int > **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAlignedObjectArray< int > & reference is null");
-    return 0;
-  } 
-  result = (bool)((btGImpactBvh const *)arg1)->boxQuery((btAABB const &)*arg2,*arg3);
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactBvh_1boxQueryTrans(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jobject jarg3, jlong jarg4) {
-  jboolean jresult = 0 ;
-  btGImpactBvh *arg1 = (btGImpactBvh *) 0 ;
-  btAABB *arg2 = 0 ;
-  btTransform *arg3 = 0 ;
-  btAlignedObjectArray< int > *arg4 = 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btGImpactBvh **)&jarg1; 
-  arg2 = *(btAABB **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAABB const & reference is null");
-    return 0;
-  } 
-  btTransform local_arg3;
-  gdx_setbtTransformFromMatrix4(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitMatrix4 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  arg4 = *(btAlignedObjectArray< int > **)&jarg4;
-  if (!arg4) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAlignedObjectArray< int > & reference is null");
-    return 0;
-  } 
-  result = (bool)((btGImpactBvh const *)arg1)->boxQueryTrans((btAABB const &)*arg2,(btTransform const &)*arg3,*arg4);
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactBvh_1rayQuery(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jobject jarg3, jlong jarg4) {
-  jboolean jresult = 0 ;
-  btGImpactBvh *arg1 = (btGImpactBvh *) 0 ;
-  btVector3 *arg2 = 0 ;
-  btVector3 *arg3 = 0 ;
-  btAlignedObjectArray< int > *arg4 = 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactBvh **)&jarg1; 
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  arg4 = *(btAlignedObjectArray< int > **)&jarg4;
-  if (!arg4) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAlignedObjectArray< int > & reference is null");
-    return 0;
-  } 
-  result = (bool)((btGImpactBvh const *)arg1)->rayQuery((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactBvh_1hasHierarchy(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jboolean jresult = 0 ;
-  btGImpactBvh *arg1 = (btGImpactBvh *) 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactBvh **)&jarg1; 
-  result = (bool)((btGImpactBvh const *)arg1)->hasHierarchy();
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactBvh_1isTrimesh(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jboolean jresult = 0 ;
-  btGImpactBvh *arg1 = (btGImpactBvh *) 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactBvh **)&jarg1; 
-  result = (bool)((btGImpactBvh const *)arg1)->isTrimesh();
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactBvh_1getNodeCount(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btGImpactBvh *arg1 = (btGImpactBvh *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactBvh **)&jarg1; 
-  result = (int)((btGImpactBvh const *)arg1)->getNodeCount();
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactBvh_1isLeafNode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jboolean jresult = 0 ;
-  btGImpactBvh *arg1 = (btGImpactBvh *) 0 ;
-  int arg2 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactBvh **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (bool)((btGImpactBvh const *)arg1)->isLeafNode(arg2);
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactBvh_1getNodeData(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jint jresult = 0 ;
-  btGImpactBvh *arg1 = (btGImpactBvh *) 0 ;
-  int arg2 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactBvh **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (int)((btGImpactBvh const *)arg1)->getNodeData(arg2);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactBvh_1getNodeBound(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3, jobject jarg3_) {
-  btGImpactBvh *arg1 = (btGImpactBvh *) 0 ;
-  int arg2 ;
-  btAABB *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg3_;
-  arg1 = *(btGImpactBvh **)&jarg1; 
-  arg2 = (int)jarg2; 
-  arg3 = *(btAABB **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAABB & reference is null");
-    return ;
-  } 
-  ((btGImpactBvh const *)arg1)->getNodeBound(arg2,*arg3);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactBvh_1setNodeBound(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3, jobject jarg3_) {
-  btGImpactBvh *arg1 = (btGImpactBvh *) 0 ;
-  int arg2 ;
-  btAABB *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg3_;
-  arg1 = *(btGImpactBvh **)&jarg1; 
-  arg2 = (int)jarg2; 
-  arg3 = *(btAABB **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAABB const & reference is null");
-    return ;
-  } 
-  (arg1)->setNodeBound(arg2,(btAABB const &)*arg3);
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactBvh_1getLeftNode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jint jresult = 0 ;
-  btGImpactBvh *arg1 = (btGImpactBvh *) 0 ;
-  int arg2 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactBvh **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (int)((btGImpactBvh const *)arg1)->getLeftNode(arg2);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactBvh_1getRightNode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jint jresult = 0 ;
-  btGImpactBvh *arg1 = (btGImpactBvh *) 0 ;
-  int arg2 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactBvh **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (int)((btGImpactBvh const *)arg1)->getRightNode(arg2);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactBvh_1getEscapeNodeIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jint jresult = 0 ;
-  btGImpactBvh *arg1 = (btGImpactBvh *) 0 ;
-  int arg2 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactBvh **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (int)((btGImpactBvh const *)arg1)->getEscapeNodeIndex(arg2);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactBvh_1getNodeTriangle(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3, jobject jarg3_) {
-  btGImpactBvh *arg1 = (btGImpactBvh *) 0 ;
-  int arg2 ;
-  btPrimitiveTriangle *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg3_;
-  arg1 = *(btGImpactBvh **)&jarg1; 
-  arg2 = (int)jarg2; 
-  arg3 = *(btPrimitiveTriangle **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btPrimitiveTriangle & reference is null");
-    return ;
-  } 
-  ((btGImpactBvh const *)arg1)->getNodeTriangle(arg2,*arg3);
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactBvh_1get_1node_1pointer_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jlong jresult = 0 ;
-  btGImpactBvh *arg1 = (btGImpactBvh *) 0 ;
-  int arg2 ;
-  GIM_BVH_TREE_NODE *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactBvh **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (GIM_BVH_TREE_NODE *)((btGImpactBvh const *)arg1)->get_node_pointer(arg2);
-  *(GIM_BVH_TREE_NODE **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactBvh_1get_1node_1pointer_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGImpactBvh *arg1 = (btGImpactBvh *) 0 ;
-  GIM_BVH_TREE_NODE *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactBvh **)&jarg1; 
-  result = (GIM_BVH_TREE_NODE *)((btGImpactBvh const *)arg1)->get_node_pointer();
-  *(GIM_BVH_TREE_NODE **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactBvh_1find_1collision(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jlong jarg3, jobject jarg3_, jobject jarg4, jlong jarg5, jobject jarg5_) {
-  btGImpactBvh *arg1 = (btGImpactBvh *) 0 ;
-  btTransform *arg2 = 0 ;
-  btGImpactBvh *arg3 = (btGImpactBvh *) 0 ;
-  btTransform *arg4 = 0 ;
-  btPairSet *arg5 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg3_;
-  (void)jarg5_;
-  arg1 = *(btGImpactBvh **)&jarg1; 
-  btTransform local_arg2;
-  gdx_setbtTransformFromMatrix4(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitMatrix4 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  arg3 = *(btGImpactBvh **)&jarg3; 
-  btTransform local_arg4;
-  gdx_setbtTransformFromMatrix4(jenv, local_arg4, jarg4);
-  arg4 = &local_arg4;
-  gdxAutoCommitMatrix4 auto_commit_arg4(jenv, jarg4, &local_arg4);
-  arg5 = *(btPairSet **)&jarg5;
-  if (!arg5) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btPairSet & reference is null");
-    return ;
-  } 
-  btGImpactBvh::find_collision(arg1,(btTransform const &)*arg2,arg3,(btTransform const &)*arg4,*arg5);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1btGImpactBvh(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  btGImpactBvh *arg1 = (btGImpactBvh *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(btGImpactBvh **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_BT_1QUANTIZED_1BVH_1NODE_1quantizedAabbMin_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jintArray jarg2) {
-  BT_QUANTIZED_BVH_NODE *arg1 = (BT_QUANTIZED_BVH_NODE *) 0 ;
-  unsigned short *arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(BT_QUANTIZED_BVH_NODE **)&jarg1; 
-  if (jarg2 && jenv->GetArrayLength(jarg2) != 3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "incorrect array size");
-    return ;
-  }
-  arg2 = (unsigned short *)jenv->GetPrimitiveArrayCritical(jarg2, 0); 
-  {
-    size_t ii;
-    unsigned short *b = (unsigned short *) arg1->m_quantizedAabbMin;
-    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((unsigned short *) arg2 + ii);
-  }
-  jenv->ReleasePrimitiveArrayCritical(jarg2, (unsigned short *)arg2, 0); 
-}
-
-
-SWIGEXPORT jintArray JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_BT_1QUANTIZED_1BVH_1NODE_1quantizedAabbMin_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jintArray jresult = 0 ;
-  BT_QUANTIZED_BVH_NODE *arg1 = (BT_QUANTIZED_BVH_NODE *) 0 ;
-  unsigned short *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(BT_QUANTIZED_BVH_NODE **)&jarg1; 
-  result = (unsigned short *)(unsigned short *) ((arg1)->m_quantizedAabbMin);
-  /*jresult = SWIG_JavaArrayOut##Ushort(jenv, (unsigned short *)result, 3);*/ 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_BT_1QUANTIZED_1BVH_1NODE_1quantizedAabbMax_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jintArray jarg2) {
-  BT_QUANTIZED_BVH_NODE *arg1 = (BT_QUANTIZED_BVH_NODE *) 0 ;
-  unsigned short *arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(BT_QUANTIZED_BVH_NODE **)&jarg1; 
-  if (jarg2 && jenv->GetArrayLength(jarg2) != 3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "incorrect array size");
-    return ;
-  }
-  arg2 = (unsigned short *)jenv->GetPrimitiveArrayCritical(jarg2, 0); 
-  {
-    size_t ii;
-    unsigned short *b = (unsigned short *) arg1->m_quantizedAabbMax;
-    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((unsigned short *) arg2 + ii);
-  }
-  jenv->ReleasePrimitiveArrayCritical(jarg2, (unsigned short *)arg2, 0); 
-}
-
-
-SWIGEXPORT jintArray JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_BT_1QUANTIZED_1BVH_1NODE_1quantizedAabbMax_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jintArray jresult = 0 ;
-  BT_QUANTIZED_BVH_NODE *arg1 = (BT_QUANTIZED_BVH_NODE *) 0 ;
-  unsigned short *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(BT_QUANTIZED_BVH_NODE **)&jarg1; 
-  result = (unsigned short *)(unsigned short *) ((arg1)->m_quantizedAabbMax);
-  /*jresult = SWIG_JavaArrayOut##Ushort(jenv, (unsigned short *)result, 3);*/ 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_BT_1QUANTIZED_1BVH_1NODE_1escapeIndexOrDataIndex_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  BT_QUANTIZED_BVH_NODE *arg1 = (BT_QUANTIZED_BVH_NODE *) 0 ;
-  int arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(BT_QUANTIZED_BVH_NODE **)&jarg1; 
-  arg2 = (int)jarg2; 
-  if (arg1) (arg1)->m_escapeIndexOrDataIndex = arg2;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_BT_1QUANTIZED_1BVH_1NODE_1escapeIndexOrDataIndex_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  BT_QUANTIZED_BVH_NODE *arg1 = (BT_QUANTIZED_BVH_NODE *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(BT_QUANTIZED_BVH_NODE **)&jarg1; 
-  result = (int) ((arg1)->m_escapeIndexOrDataIndex);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1BT_1QUANTIZED_1BVH_1NODE(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  BT_QUANTIZED_BVH_NODE *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (BT_QUANTIZED_BVH_NODE *)new BT_QUANTIZED_BVH_NODE();
-  *(BT_QUANTIZED_BVH_NODE **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_BT_1QUANTIZED_1BVH_1NODE_1isLeafNode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jboolean jresult = 0 ;
-  BT_QUANTIZED_BVH_NODE *arg1 = (BT_QUANTIZED_BVH_NODE *) 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(BT_QUANTIZED_BVH_NODE **)&jarg1; 
-  result = (bool)((BT_QUANTIZED_BVH_NODE const *)arg1)->isLeafNode();
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_BT_1QUANTIZED_1BVH_1NODE_1getEscapeIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  BT_QUANTIZED_BVH_NODE *arg1 = (BT_QUANTIZED_BVH_NODE *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(BT_QUANTIZED_BVH_NODE **)&jarg1; 
-  result = (int)((BT_QUANTIZED_BVH_NODE const *)arg1)->getEscapeIndex();
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_BT_1QUANTIZED_1BVH_1NODE_1setEscapeIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  BT_QUANTIZED_BVH_NODE *arg1 = (BT_QUANTIZED_BVH_NODE *) 0 ;
-  int arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(BT_QUANTIZED_BVH_NODE **)&jarg1; 
-  arg2 = (int)jarg2; 
-  (arg1)->setEscapeIndex(arg2);
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_BT_1QUANTIZED_1BVH_1NODE_1getDataIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  BT_QUANTIZED_BVH_NODE *arg1 = (BT_QUANTIZED_BVH_NODE *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(BT_QUANTIZED_BVH_NODE **)&jarg1; 
-  result = (int)((BT_QUANTIZED_BVH_NODE const *)arg1)->getDataIndex();
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_BT_1QUANTIZED_1BVH_1NODE_1setDataIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  BT_QUANTIZED_BVH_NODE *arg1 = (BT_QUANTIZED_BVH_NODE *) 0 ;
-  int arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(BT_QUANTIZED_BVH_NODE **)&jarg1; 
-  arg2 = (int)jarg2; 
-  (arg1)->setDataIndex(arg2);
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_BT_1QUANTIZED_1BVH_1NODE_1testQuantizedBoxOverlapp(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jobject jarg3) {
-  jboolean jresult = 0 ;
-  BT_QUANTIZED_BVH_NODE *arg1 = (BT_QUANTIZED_BVH_NODE *) 0 ;
-  unsigned short *arg2 = (unsigned short *) 0 ;
-  unsigned short *arg3 = (unsigned short *) 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(BT_QUANTIZED_BVH_NODE **)&jarg1; 
-  {
-    arg2 = (unsigned short*)jenv->GetDirectBufferAddress(jarg2);
-    if (arg2 == NULL) {
-      SWIG_JavaThrowException(jenv, SWIG_JavaRuntimeException, "Unable to get address of direct buffer. Buffer must be allocated direct.");
-    }
-  }
-  {
-    arg3 = (unsigned short*)jenv->GetDirectBufferAddress(jarg3);
-    if (arg3 == NULL) {
-      SWIG_JavaThrowException(jenv, SWIG_JavaRuntimeException, "Unable to get address of direct buffer. Buffer must be allocated direct.");
-    }
-  }
-  result = (bool)((BT_QUANTIZED_BVH_NODE const *)arg1)->testQuantizedBoxOverlapp(arg2,arg3);
-  jresult = (jboolean)result; 
-  
-  
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1BT_1QUANTIZED_1BVH_1NODE(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  BT_QUANTIZED_BVH_NODE *arg1 = (BT_QUANTIZED_BVH_NODE *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(BT_QUANTIZED_BVH_NODE **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1GIM_1QUANTIZED_1BVH_1NODE_1ARRAY(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  GIM_QUANTIZED_BVH_NODE_ARRAY *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (GIM_QUANTIZED_BVH_NODE_ARRAY *)new GIM_QUANTIZED_BVH_NODE_ARRAY();
-  *(GIM_QUANTIZED_BVH_NODE_ARRAY **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1GIM_1QUANTIZED_1BVH_1NODE_1ARRAY(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  GIM_QUANTIZED_BVH_NODE_ARRAY *arg1 = (GIM_QUANTIZED_BVH_NODE_ARRAY *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(GIM_QUANTIZED_BVH_NODE_ARRAY **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btQuantizedBvhTree(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  btQuantizedBvhTree *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (btQuantizedBvhTree *)new btQuantizedBvhTree();
-  *(btQuantizedBvhTree **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btQuantizedBvhTree_1build_1tree(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  btQuantizedBvhTree *arg1 = (btQuantizedBvhTree *) 0 ;
-  GIM_BVH_DATA_ARRAY *arg2 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btQuantizedBvhTree **)&jarg1; 
-  arg2 = *(GIM_BVH_DATA_ARRAY **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "GIM_BVH_DATA_ARRAY & reference is null");
-    return ;
-  } 
-  (arg1)->build_tree(*arg2);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btQuantizedBvhTree_1quantizePoint(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jobject jarg3) {
-  btQuantizedBvhTree *arg1 = (btQuantizedBvhTree *) 0 ;
-  unsigned short *arg2 = (unsigned short *) 0 ;
-  btVector3 *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btQuantizedBvhTree **)&jarg1; 
-  {
-    arg2 = (unsigned short*)jenv->GetDirectBufferAddress(jarg2);
-    if (arg2 == NULL) {
-      SWIG_JavaThrowException(jenv, SWIG_JavaRuntimeException, "Unable to get address of direct buffer. Buffer must be allocated direct.");
-    }
-  }
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  ((btQuantizedBvhTree const *)arg1)->quantizePoint(arg2,(btVector3 const &)*arg3);
-  
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btQuantizedBvhTree_1testQuantizedBoxOverlapp(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jobject jarg3, jobject jarg4) {
-  jboolean jresult = 0 ;
-  btQuantizedBvhTree *arg1 = (btQuantizedBvhTree *) 0 ;
-  int arg2 ;
-  unsigned short *arg3 = (unsigned short *) 0 ;
-  unsigned short *arg4 = (unsigned short *) 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btQuantizedBvhTree **)&jarg1; 
-  arg2 = (int)jarg2; 
-  {
-    arg3 = (unsigned short*)jenv->GetDirectBufferAddress(jarg3);
-    if (arg3 == NULL) {
-      SWIG_JavaThrowException(jenv, SWIG_JavaRuntimeException, "Unable to get address of direct buffer. Buffer must be allocated direct.");
-    }
-  }
-  {
-    arg4 = (unsigned short*)jenv->GetDirectBufferAddress(jarg4);
-    if (arg4 == NULL) {
-      SWIG_JavaThrowException(jenv, SWIG_JavaRuntimeException, "Unable to get address of direct buffer. Buffer must be allocated direct.");
-    }
-  }
-  result = (bool)((btQuantizedBvhTree const *)arg1)->testQuantizedBoxOverlapp(arg2,arg3,arg4);
-  jresult = (jboolean)result; 
-  
-  
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btQuantizedBvhTree_1clearNodes(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  btQuantizedBvhTree *arg1 = (btQuantizedBvhTree *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btQuantizedBvhTree **)&jarg1; 
-  (arg1)->clearNodes();
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btQuantizedBvhTree_1getNodeCount(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btQuantizedBvhTree *arg1 = (btQuantizedBvhTree *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btQuantizedBvhTree **)&jarg1; 
-  result = (int)((btQuantizedBvhTree const *)arg1)->getNodeCount();
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btQuantizedBvhTree_1isLeafNode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jboolean jresult = 0 ;
-  btQuantizedBvhTree *arg1 = (btQuantizedBvhTree *) 0 ;
-  int arg2 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btQuantizedBvhTree **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (bool)((btQuantizedBvhTree const *)arg1)->isLeafNode(arg2);
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btQuantizedBvhTree_1getNodeData(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jint jresult = 0 ;
-  btQuantizedBvhTree *arg1 = (btQuantizedBvhTree *) 0 ;
-  int arg2 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btQuantizedBvhTree **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (int)((btQuantizedBvhTree const *)arg1)->getNodeData(arg2);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btQuantizedBvhTree_1getNodeBound(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3, jobject jarg3_) {
-  btQuantizedBvhTree *arg1 = (btQuantizedBvhTree *) 0 ;
-  int arg2 ;
-  btAABB *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg3_;
-  arg1 = *(btQuantizedBvhTree **)&jarg1; 
-  arg2 = (int)jarg2; 
-  arg3 = *(btAABB **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAABB & reference is null");
-    return ;
-  } 
-  ((btQuantizedBvhTree const *)arg1)->getNodeBound(arg2,*arg3);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btQuantizedBvhTree_1setNodeBound(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3, jobject jarg3_) {
-  btQuantizedBvhTree *arg1 = (btQuantizedBvhTree *) 0 ;
-  int arg2 ;
-  btAABB *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg3_;
-  arg1 = *(btQuantizedBvhTree **)&jarg1; 
-  arg2 = (int)jarg2; 
-  arg3 = *(btAABB **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAABB const & reference is null");
-    return ;
-  } 
-  (arg1)->setNodeBound(arg2,(btAABB const &)*arg3);
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btQuantizedBvhTree_1getLeftNode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jint jresult = 0 ;
-  btQuantizedBvhTree *arg1 = (btQuantizedBvhTree *) 0 ;
-  int arg2 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btQuantizedBvhTree **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (int)((btQuantizedBvhTree const *)arg1)->getLeftNode(arg2);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btQuantizedBvhTree_1getRightNode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jint jresult = 0 ;
-  btQuantizedBvhTree *arg1 = (btQuantizedBvhTree *) 0 ;
-  int arg2 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btQuantizedBvhTree **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (int)((btQuantizedBvhTree const *)arg1)->getRightNode(arg2);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btQuantizedBvhTree_1getEscapeNodeIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jint jresult = 0 ;
-  btQuantizedBvhTree *arg1 = (btQuantizedBvhTree *) 0 ;
-  int arg2 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btQuantizedBvhTree **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (int)((btQuantizedBvhTree const *)arg1)->getEscapeNodeIndex(arg2);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btQuantizedBvhTree_1get_1node_1pointer_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jlong jresult = 0 ;
-  btQuantizedBvhTree *arg1 = (btQuantizedBvhTree *) 0 ;
-  int arg2 ;
-  BT_QUANTIZED_BVH_NODE *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btQuantizedBvhTree **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (BT_QUANTIZED_BVH_NODE *)((btQuantizedBvhTree const *)arg1)->get_node_pointer(arg2);
-  *(BT_QUANTIZED_BVH_NODE **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btQuantizedBvhTree_1get_1node_1pointer_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btQuantizedBvhTree *arg1 = (btQuantizedBvhTree *) 0 ;
-  BT_QUANTIZED_BVH_NODE *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btQuantizedBvhTree **)&jarg1; 
-  result = (BT_QUANTIZED_BVH_NODE *)((btQuantizedBvhTree const *)arg1)->get_node_pointer();
-  *(BT_QUANTIZED_BVH_NODE **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1btQuantizedBvhTree(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  btQuantizedBvhTree *arg1 = (btQuantizedBvhTree *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(btQuantizedBvhTree **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btGImpactQuantizedBvh_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  btGImpactQuantizedBvh *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (btGImpactQuantizedBvh *)new btGImpactQuantizedBvh();
-  *(btGImpactQuantizedBvh **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btGImpactQuantizedBvh_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btPrimitiveManagerBase *arg1 = (btPrimitiveManagerBase *) 0 ;
-  btGImpactQuantizedBvh *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btPrimitiveManagerBase **)&jarg1; 
-  result = (btGImpactQuantizedBvh *)new btGImpactQuantizedBvh(arg1);
-  *(btGImpactQuantizedBvh **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactQuantizedBvh_1getGlobalBox(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGImpactQuantizedBvh *arg1 = (btGImpactQuantizedBvh *) 0 ;
-  btAABB result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactQuantizedBvh **)&jarg1; 
-  result = ((btGImpactQuantizedBvh const *)arg1)->getGlobalBox();
-  *(btAABB **)&jresult = new btAABB((const btAABB &)result); 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactQuantizedBvh_1setPrimitiveManager(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  btGImpactQuantizedBvh *arg1 = (btGImpactQuantizedBvh *) 0 ;
-  btPrimitiveManagerBase *arg2 = (btPrimitiveManagerBase *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btGImpactQuantizedBvh **)&jarg1; 
-  arg2 = *(btPrimitiveManagerBase **)&jarg2; 
-  (arg1)->setPrimitiveManager(arg2);
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactQuantizedBvh_1getPrimitiveManager(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGImpactQuantizedBvh *arg1 = (btGImpactQuantizedBvh *) 0 ;
-  btPrimitiveManagerBase *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactQuantizedBvh **)&jarg1; 
-  result = (btPrimitiveManagerBase *)((btGImpactQuantizedBvh const *)arg1)->getPrimitiveManager();
-  *(btPrimitiveManagerBase **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactQuantizedBvh_1update(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  btGImpactQuantizedBvh *arg1 = (btGImpactQuantizedBvh *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactQuantizedBvh **)&jarg1; 
-  (arg1)->update();
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactQuantizedBvh_1buildSet(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  btGImpactQuantizedBvh *arg1 = (btGImpactQuantizedBvh *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactQuantizedBvh **)&jarg1; 
-  (arg1)->buildSet();
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactQuantizedBvh_1boxQuery(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3) {
-  jboolean jresult = 0 ;
-  btGImpactQuantizedBvh *arg1 = (btGImpactQuantizedBvh *) 0 ;
-  btAABB *arg2 = 0 ;
-  btAlignedObjectArray< int > *arg3 = 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btGImpactQuantizedBvh **)&jarg1; 
-  arg2 = *(btAABB **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAABB const & reference is null");
-    return 0;
-  } 
-  arg3 = *(btAlignedObjectArray< int > **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAlignedObjectArray< int > & reference is null");
-    return 0;
-  } 
-  result = (bool)((btGImpactQuantizedBvh const *)arg1)->boxQuery((btAABB const &)*arg2,*arg3);
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactQuantizedBvh_1boxQueryTrans(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jobject jarg3, jlong jarg4) {
-  jboolean jresult = 0 ;
-  btGImpactQuantizedBvh *arg1 = (btGImpactQuantizedBvh *) 0 ;
-  btAABB *arg2 = 0 ;
-  btTransform *arg3 = 0 ;
-  btAlignedObjectArray< int > *arg4 = 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btGImpactQuantizedBvh **)&jarg1; 
-  arg2 = *(btAABB **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAABB const & reference is null");
-    return 0;
-  } 
-  btTransform local_arg3;
-  gdx_setbtTransformFromMatrix4(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitMatrix4 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  arg4 = *(btAlignedObjectArray< int > **)&jarg4;
-  if (!arg4) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAlignedObjectArray< int > & reference is null");
-    return 0;
-  } 
-  result = (bool)((btGImpactQuantizedBvh const *)arg1)->boxQueryTrans((btAABB const &)*arg2,(btTransform const &)*arg3,*arg4);
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactQuantizedBvh_1rayQuery(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jobject jarg3, jlong jarg4) {
-  jboolean jresult = 0 ;
-  btGImpactQuantizedBvh *arg1 = (btGImpactQuantizedBvh *) 0 ;
-  btVector3 *arg2 = 0 ;
-  btVector3 *arg3 = 0 ;
-  btAlignedObjectArray< int > *arg4 = 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactQuantizedBvh **)&jarg1; 
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  arg4 = *(btAlignedObjectArray< int > **)&jarg4;
-  if (!arg4) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAlignedObjectArray< int > & reference is null");
-    return 0;
-  } 
-  result = (bool)((btGImpactQuantizedBvh const *)arg1)->rayQuery((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactQuantizedBvh_1hasHierarchy(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jboolean jresult = 0 ;
-  btGImpactQuantizedBvh *arg1 = (btGImpactQuantizedBvh *) 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactQuantizedBvh **)&jarg1; 
-  result = (bool)((btGImpactQuantizedBvh const *)arg1)->hasHierarchy();
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactQuantizedBvh_1isTrimesh(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jboolean jresult = 0 ;
-  btGImpactQuantizedBvh *arg1 = (btGImpactQuantizedBvh *) 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactQuantizedBvh **)&jarg1; 
-  result = (bool)((btGImpactQuantizedBvh const *)arg1)->isTrimesh();
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactQuantizedBvh_1getNodeCount(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btGImpactQuantizedBvh *arg1 = (btGImpactQuantizedBvh *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactQuantizedBvh **)&jarg1; 
-  result = (int)((btGImpactQuantizedBvh const *)arg1)->getNodeCount();
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactQuantizedBvh_1isLeafNode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jboolean jresult = 0 ;
-  btGImpactQuantizedBvh *arg1 = (btGImpactQuantizedBvh *) 0 ;
-  int arg2 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactQuantizedBvh **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (bool)((btGImpactQuantizedBvh const *)arg1)->isLeafNode(arg2);
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactQuantizedBvh_1getNodeData(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jint jresult = 0 ;
-  btGImpactQuantizedBvh *arg1 = (btGImpactQuantizedBvh *) 0 ;
-  int arg2 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactQuantizedBvh **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (int)((btGImpactQuantizedBvh const *)arg1)->getNodeData(arg2);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactQuantizedBvh_1getNodeBound(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3, jobject jarg3_) {
-  btGImpactQuantizedBvh *arg1 = (btGImpactQuantizedBvh *) 0 ;
-  int arg2 ;
-  btAABB *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg3_;
-  arg1 = *(btGImpactQuantizedBvh **)&jarg1; 
-  arg2 = (int)jarg2; 
-  arg3 = *(btAABB **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAABB & reference is null");
-    return ;
-  } 
-  ((btGImpactQuantizedBvh const *)arg1)->getNodeBound(arg2,*arg3);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactQuantizedBvh_1setNodeBound(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3, jobject jarg3_) {
-  btGImpactQuantizedBvh *arg1 = (btGImpactQuantizedBvh *) 0 ;
-  int arg2 ;
-  btAABB *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg3_;
-  arg1 = *(btGImpactQuantizedBvh **)&jarg1; 
-  arg2 = (int)jarg2; 
-  arg3 = *(btAABB **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAABB const & reference is null");
-    return ;
-  } 
-  (arg1)->setNodeBound(arg2,(btAABB const &)*arg3);
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactQuantizedBvh_1getLeftNode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jint jresult = 0 ;
-  btGImpactQuantizedBvh *arg1 = (btGImpactQuantizedBvh *) 0 ;
-  int arg2 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactQuantizedBvh **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (int)((btGImpactQuantizedBvh const *)arg1)->getLeftNode(arg2);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactQuantizedBvh_1getRightNode(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jint jresult = 0 ;
-  btGImpactQuantizedBvh *arg1 = (btGImpactQuantizedBvh *) 0 ;
-  int arg2 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactQuantizedBvh **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (int)((btGImpactQuantizedBvh const *)arg1)->getRightNode(arg2);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactQuantizedBvh_1getEscapeNodeIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jint jresult = 0 ;
-  btGImpactQuantizedBvh *arg1 = (btGImpactQuantizedBvh *) 0 ;
-  int arg2 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactQuantizedBvh **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (int)((btGImpactQuantizedBvh const *)arg1)->getEscapeNodeIndex(arg2);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactQuantizedBvh_1getNodeTriangle(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3, jobject jarg3_) {
-  btGImpactQuantizedBvh *arg1 = (btGImpactQuantizedBvh *) 0 ;
-  int arg2 ;
-  btPrimitiveTriangle *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg3_;
-  arg1 = *(btGImpactQuantizedBvh **)&jarg1; 
-  arg2 = (int)jarg2; 
-  arg3 = *(btPrimitiveTriangle **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btPrimitiveTriangle & reference is null");
-    return ;
-  } 
-  ((btGImpactQuantizedBvh const *)arg1)->getNodeTriangle(arg2,*arg3);
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactQuantizedBvh_1get_1node_1pointer_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jlong jresult = 0 ;
-  btGImpactQuantizedBvh *arg1 = (btGImpactQuantizedBvh *) 0 ;
-  int arg2 ;
-  BT_QUANTIZED_BVH_NODE *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactQuantizedBvh **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (BT_QUANTIZED_BVH_NODE *)((btGImpactQuantizedBvh const *)arg1)->get_node_pointer(arg2);
-  *(BT_QUANTIZED_BVH_NODE **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactQuantizedBvh_1get_1node_1pointer_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGImpactQuantizedBvh *arg1 = (btGImpactQuantizedBvh *) 0 ;
-  BT_QUANTIZED_BVH_NODE *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactQuantizedBvh **)&jarg1; 
-  result = (BT_QUANTIZED_BVH_NODE *)((btGImpactQuantizedBvh const *)arg1)->get_node_pointer();
-  *(BT_QUANTIZED_BVH_NODE **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactQuantizedBvh_1find_1collision(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jlong jarg3, jobject jarg3_, jobject jarg4, jlong jarg5, jobject jarg5_) {
-  btGImpactQuantizedBvh *arg1 = (btGImpactQuantizedBvh *) 0 ;
-  btTransform *arg2 = 0 ;
-  btGImpactQuantizedBvh *arg3 = (btGImpactQuantizedBvh *) 0 ;
-  btTransform *arg4 = 0 ;
-  btPairSet *arg5 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg3_;
-  (void)jarg5_;
-  arg1 = *(btGImpactQuantizedBvh **)&jarg1; 
-  btTransform local_arg2;
-  gdx_setbtTransformFromMatrix4(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitMatrix4 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  arg3 = *(btGImpactQuantizedBvh **)&jarg3; 
-  btTransform local_arg4;
-  gdx_setbtTransformFromMatrix4(jenv, local_arg4, jarg4);
-  arg4 = &local_arg4;
-  gdxAutoCommitMatrix4 auto_commit_arg4(jenv, jarg4, &local_arg4);
-  arg5 = *(btPairSet **)&jarg5;
-  if (!arg5) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btPairSet & reference is null");
-    return ;
-  } 
-  btGImpactQuantizedBvh::find_collision((btGImpactQuantizedBvh const *)arg1,(btTransform const &)*arg2,(btGImpactQuantizedBvh const *)arg3,(btTransform const &)*arg4,*arg5);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1btGImpactQuantizedBvh(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  btGImpactQuantizedBvh *arg1 = (btGImpactQuantizedBvh *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(btGImpactQuantizedBvh **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btTetrahedronShapeEx(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  btTetrahedronShapeEx *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (btTetrahedronShapeEx *)new btTetrahedronShapeEx();
-  *(btTetrahedronShapeEx **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btTetrahedronShapeEx_1setVertices(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jobject jarg3, jobject jarg4, jobject jarg5) {
-  btTetrahedronShapeEx *arg1 = (btTetrahedronShapeEx *) 0 ;
-  btVector3 *arg2 = 0 ;
-  btVector3 *arg3 = 0 ;
-  btVector3 *arg4 = 0 ;
-  btVector3 *arg5 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btTetrahedronShapeEx **)&jarg1; 
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  btVector3 local_arg4;
-  gdx_setbtVector3FromVector3(jenv, local_arg4, jarg4);
-  arg4 = &local_arg4;
-  gdxAutoCommitVector3 auto_commit_arg4(jenv, jarg4, &local_arg4);
-  btVector3 local_arg5;
-  gdx_setbtVector3FromVector3(jenv, local_arg5, jarg5);
-  arg5 = &local_arg5;
-  gdxAutoCommitVector3 auto_commit_arg5(jenv, jarg5, &local_arg5);
-  (arg1)->setVertices((btVector3 const &)*arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4,(btVector3 const &)*arg5);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1btTetrahedronShapeEx(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  btTetrahedronShapeEx *arg1 = (btTetrahedronShapeEx *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(btTetrahedronShapeEx **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1updateBound(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  (arg1)->updateBound();
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1postUpdate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  (arg1)->postUpdate();
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1getLocalBox(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  btAABB *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  result = (btAABB *) &(arg1)->getLocalBox();
-  *(btAABB **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1getShapeType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  result = (int)((btGImpactShapeInterface const *)arg1)->getShapeType();
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1getGImpactShapeType(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  eGIMPACT_SHAPE_TYPE result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  result = (eGIMPACT_SHAPE_TYPE)((btGImpactShapeInterface const *)arg1)->getGImpactShapeType();
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1getBoxSet(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  btGImpactBoxSet *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  result = (btGImpactBoxSet *)((btGImpactShapeInterface const *)arg1)->getBoxSet();
-  *(btGImpactBoxSet **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1hasBoxSet(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jboolean jresult = 0 ;
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  result = (bool)((btGImpactShapeInterface const *)arg1)->hasBoxSet();
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1getPrimitiveManager(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  btPrimitiveManagerBase *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  result = (btPrimitiveManagerBase *)((btGImpactShapeInterface const *)arg1)->getPrimitiveManager();
-  *(btPrimitiveManagerBase **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1getNumChildShapes(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  result = (int)((btGImpactShapeInterface const *)arg1)->getNumChildShapes();
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1childrenHasTransform(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jboolean jresult = 0 ;
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  result = (bool)((btGImpactShapeInterface const *)arg1)->childrenHasTransform();
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1needsRetrieveTriangles(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jboolean jresult = 0 ;
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  result = (bool)((btGImpactShapeInterface const *)arg1)->needsRetrieveTriangles();
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1needsRetrieveTetrahedrons(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jboolean jresult = 0 ;
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  result = (bool)((btGImpactShapeInterface const *)arg1)->needsRetrieveTetrahedrons();
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1getBulletTriangle(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3, jobject jarg3_) {
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  int arg2 ;
-  btTriangleShapeEx *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg3_;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  arg2 = (int)jarg2; 
-  arg3 = *(btTriangleShapeEx **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btTriangleShapeEx & reference is null");
-    return ;
-  } 
-  ((btGImpactShapeInterface const *)arg1)->getBulletTriangle(arg2,*arg3);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1getBulletTetrahedron(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3, jobject jarg3_) {
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  int arg2 ;
-  btTetrahedronShapeEx *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg3_;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  arg2 = (int)jarg2; 
-  arg3 = *(btTetrahedronShapeEx **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btTetrahedronShapeEx & reference is null");
-    return ;
-  } 
-  ((btGImpactShapeInterface const *)arg1)->getBulletTetrahedron(arg2,*arg3);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1lockChildShapes(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  ((btGImpactShapeInterface const *)arg1)->lockChildShapes();
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1unlockChildShapes(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  ((btGImpactShapeInterface const *)arg1)->unlockChildShapes();
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1getPrimitiveTriangle(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3, jobject jarg3_) {
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  int arg2 ;
-  btPrimitiveTriangle *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg3_;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  arg2 = (int)jarg2; 
-  arg3 = *(btPrimitiveTriangle **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btPrimitiveTriangle & reference is null");
-    return ;
-  } 
-  ((btGImpactShapeInterface const *)arg1)->getPrimitiveTriangle(arg2,*arg3);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1getChildAabb(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jobject jarg3, jobject jarg4, jobject jarg5) {
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  int arg2 ;
-  btTransform *arg3 = 0 ;
-  btVector3 *arg4 = 0 ;
-  btVector3 *arg5 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  arg2 = (int)jarg2; 
-  btTransform local_arg3;
-  gdx_setbtTransformFromMatrix4(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitMatrix4 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  btVector3 local_arg4;
-  gdx_setbtVector3FromVector3(jenv, local_arg4, jarg4);
-  arg4 = &local_arg4;
-  gdxAutoCommitVector3 auto_commit_arg4(jenv, jarg4, &local_arg4);
-  btVector3 local_arg5;
-  gdx_setbtVector3FromVector3(jenv, local_arg5, jarg5);
-  arg5 = &local_arg5;
-  gdxAutoCommitVector3 auto_commit_arg5(jenv, jarg5, &local_arg5);
-  ((btGImpactShapeInterface const *)arg1)->getChildAabb(arg2,(btTransform const &)*arg3,*arg4,*arg5);
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1getChildShape_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jlong jresult = 0 ;
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  int arg2 ;
-  btCollisionShape *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (btCollisionShape *)(arg1)->getChildShape(arg2);
-  *(btCollisionShape **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jobject JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1getChildTransform(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jobject jresult = 0 ;
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  int arg2 ;
-  btTransform result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = ((btGImpactShapeInterface const *)arg1)->getChildTransform(arg2);
-  jresult = gdx_getReturnMatrix4(jenv);
-  gdx_setMatrix4FrombtTransform(jenv, jresult, result);
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1setChildTransform(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jobject jarg3) {
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  int arg2 ;
-  btTransform *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  arg2 = (int)jarg2; 
-  btTransform local_arg3;
-  gdx_setbtTransformFromMatrix4(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitMatrix4 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  (arg1)->setChildTransform(arg2,(btTransform const &)*arg3);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1rayTest(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jobject jarg3, jlong jarg4, jobject jarg4_) {
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  btVector3 *arg2 = 0 ;
-  btVector3 *arg3 = 0 ;
-  btCollisionWorld::RayResultCallback *arg4 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg4_;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  arg4 = *(btCollisionWorld::RayResultCallback **)&jarg4;
-  if (!arg4) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btCollisionWorld::RayResultCallback & reference is null");
-    return ;
-  } 
-  ((btGImpactShapeInterface const *)arg1)->rayTest((btVector3 const &)*arg2,(btVector3 const &)*arg3,*arg4);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1processAllTrianglesRay(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jobject jarg3, jobject jarg4) {
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  btTriangleCallback *arg2 = (btTriangleCallback *) 0 ;
-  btVector3 *arg3 = 0 ;
-  btVector3 *arg4 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  arg2 = *(btTriangleCallback **)&jarg2; 
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  btVector3 local_arg4;
-  gdx_setbtVector3FromVector3(jenv, local_arg4, jarg4);
-  arg4 = &local_arg4;
-  gdxAutoCommitVector3 auto_commit_arg4(jenv, jarg4, &local_arg4);
-  ((btGImpactShapeInterface const *)arg1)->processAllTrianglesRay(arg2,(btVector3 const &)*arg3,(btVector3 const &)*arg4);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1btGImpactShapeInterface(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  btGImpactShapeInterface *arg1 = (btGImpactShapeInterface *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(btGImpactShapeInterface **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1btGImpactCompoundShape_1CompoundPrimitiveManager(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  btGImpactCompoundShape::CompoundPrimitiveManager *arg1 = (btGImpactCompoundShape::CompoundPrimitiveManager *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(btGImpactCompoundShape::CompoundPrimitiveManager **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCompoundShape_1CompoundPrimitiveManager_1compoundShape_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  btGImpactCompoundShape::CompoundPrimitiveManager *arg1 = (btGImpactCompoundShape::CompoundPrimitiveManager *) 0 ;
-  btGImpactCompoundShape *arg2 = (btGImpactCompoundShape *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btGImpactCompoundShape::CompoundPrimitiveManager **)&jarg1; 
-  arg2 = *(btGImpactCompoundShape **)&jarg2; 
-  if (arg1) (arg1)->m_compoundShape = arg2;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCompoundShape_1CompoundPrimitiveManager_1compoundShape_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGImpactCompoundShape::CompoundPrimitiveManager *arg1 = (btGImpactCompoundShape::CompoundPrimitiveManager *) 0 ;
-  btGImpactCompoundShape *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactCompoundShape::CompoundPrimitiveManager **)&jarg1; 
-  result = (btGImpactCompoundShape *) ((arg1)->m_compoundShape);
-  *(btGImpactCompoundShape **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btGImpactCompoundShape_1CompoundPrimitiveManager_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGImpactCompoundShape::CompoundPrimitiveManager *arg1 = 0 ;
-  btGImpactCompoundShape::CompoundPrimitiveManager *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactCompoundShape::CompoundPrimitiveManager **)&jarg1;
-  if (!arg1) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btGImpactCompoundShape::CompoundPrimitiveManager const & reference is null");
-    return 0;
-  } 
-  result = (btGImpactCompoundShape::CompoundPrimitiveManager *)new btGImpactCompoundShape::CompoundPrimitiveManager((btGImpactCompoundShape::CompoundPrimitiveManager const &)*arg1);
-  *(btGImpactCompoundShape::CompoundPrimitiveManager **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btGImpactCompoundShape_1CompoundPrimitiveManager_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGImpactCompoundShape *arg1 = (btGImpactCompoundShape *) 0 ;
-  btGImpactCompoundShape::CompoundPrimitiveManager *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactCompoundShape **)&jarg1; 
-  result = (btGImpactCompoundShape::CompoundPrimitiveManager *)new btGImpactCompoundShape::CompoundPrimitiveManager(arg1);
-  *(btGImpactCompoundShape::CompoundPrimitiveManager **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btGImpactCompoundShape_1CompoundPrimitiveManager_1_1SWIG_12(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  btGImpactCompoundShape::CompoundPrimitiveManager *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (btGImpactCompoundShape::CompoundPrimitiveManager *)new btGImpactCompoundShape::CompoundPrimitiveManager();
-  *(btGImpactCompoundShape::CompoundPrimitiveManager **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btGImpactCompoundShape_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jboolean jarg1) {
-  jlong jresult = 0 ;
-  bool arg1 ;
-  btGImpactCompoundShape *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = jarg1 ? true : false; 
-  result = (btGImpactCompoundShape *)new btGImpactCompoundShape(arg1);
-  *(btGImpactCompoundShape **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btGImpactCompoundShape_1_1SWIG_11(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  btGImpactCompoundShape *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (btGImpactCompoundShape *)new btGImpactCompoundShape();
-  *(btGImpactCompoundShape **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1btGImpactCompoundShape(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  btGImpactCompoundShape *arg1 = (btGImpactCompoundShape *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(btGImpactCompoundShape **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCompoundShape_1getCompoundPrimitiveManager(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGImpactCompoundShape *arg1 = (btGImpactCompoundShape *) 0 ;
-  btGImpactCompoundShape::CompoundPrimitiveManager *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactCompoundShape **)&jarg1; 
-  result = (btGImpactCompoundShape::CompoundPrimitiveManager *)(arg1)->getCompoundPrimitiveManager();
-  *(btGImpactCompoundShape::CompoundPrimitiveManager **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCompoundShape_1addChildShape_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jlong jarg3, jobject jarg3_) {
-  btGImpactCompoundShape *arg1 = (btGImpactCompoundShape *) 0 ;
-  btTransform *arg2 = 0 ;
-  btCollisionShape *arg3 = (btCollisionShape *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg3_;
-  arg1 = *(btGImpactCompoundShape **)&jarg1; 
-  btTransform local_arg2;
-  gdx_setbtTransformFromMatrix4(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitMatrix4 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  arg3 = *(btCollisionShape **)&jarg3; 
-  (arg1)->addChildShape((btTransform const &)*arg2,arg3);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCompoundShape_1addChildShape_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  btGImpactCompoundShape *arg1 = (btGImpactCompoundShape *) 0 ;
-  btCollisionShape *arg2 = (btCollisionShape *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btGImpactCompoundShape **)&jarg1; 
-  arg2 = *(btCollisionShape **)&jarg2; 
-  (arg1)->addChildShape(arg2);
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCompoundShape_1getChildShape_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jlong jresult = 0 ;
-  btGImpactCompoundShape *arg1 = (btGImpactCompoundShape *) 0 ;
-  int arg2 ;
-  btCollisionShape *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactCompoundShape **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (btCollisionShape *)(arg1)->getChildShape(arg2);
-  *(btCollisionShape **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1margin_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jfloat jarg2) {
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  btScalar arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  arg2 = (btScalar)jarg2; 
-  if (arg1) (arg1)->m_margin = arg2;
-}
-
-
-SWIGEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1margin_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jfloat jresult = 0 ;
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  btScalar result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  result = (btScalar) ((arg1)->m_margin);
-  jresult = (jfloat)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1meshInterface_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  btStridingMeshInterface *arg2 = (btStridingMeshInterface *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  arg2 = *(btStridingMeshInterface **)&jarg2; 
-  if (arg1) (arg1)->m_meshInterface = arg2;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1meshInterface_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  btStridingMeshInterface *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  result = (btStridingMeshInterface *) ((arg1)->m_meshInterface);
-  *(btStridingMeshInterface **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1scale_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  btVector3 *arg2 = (btVector3 *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  arg2 = *(btVector3 **)&jarg2; 
-  if (arg1) (arg1)->m_scale = *arg2;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1scale_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  btVector3 *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  result = (btVector3 *)& ((arg1)->m_scale);
-  *(btVector3 **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1part_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  int arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  arg2 = (int)jarg2; 
-  if (arg1) (arg1)->m_part = arg2;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1part_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  result = (int) ((arg1)->m_part);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1lock_1count_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  int arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  arg2 = (int)jarg2; 
-  if (arg1) (arg1)->m_lock_count = arg2;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1lock_1count_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  result = (int) ((arg1)->m_lock_count);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1vertexbase_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  unsigned char *arg2 = (unsigned char *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  {
-    arg2 = (unsigned char*)jenv->GetDirectBufferAddress(jarg2);
-    if (arg2 == NULL) {
-      SWIG_JavaThrowException(jenv, SWIG_JavaRuntimeException, "Unable to get address of direct buffer. Buffer must be allocated direct.");
-    }
-  }
-  {
-    if (arg2) {
-      arg1->vertexbase = arg2;
-    } else {
-      arg1->vertexbase = 0;
-    }
-  }
-  
-}
-
-
-SWIGEXPORT jobject JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1vertexbase_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jobject jresult = 0 ;
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  unsigned char *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  result = (unsigned char *) ((arg1)->vertexbase);
-  *(unsigned char **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1numverts_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  int arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  arg2 = (int)jarg2; 
-  if (arg1) (arg1)->numverts = arg2;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1numverts_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  result = (int) ((arg1)->numverts);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1type_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  PHY_ScalarType arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  arg2 = (PHY_ScalarType)jarg2; 
-  if (arg1) (arg1)->type = arg2;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1type_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  PHY_ScalarType result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  result = (PHY_ScalarType) ((arg1)->type);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1stride_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  int arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  arg2 = (int)jarg2; 
-  if (arg1) (arg1)->stride = arg2;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1stride_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  result = (int) ((arg1)->stride);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1indexbase_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  unsigned char *arg2 = (unsigned char *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  {
-    arg2 = (unsigned char*)jenv->GetDirectBufferAddress(jarg2);
-    if (arg2 == NULL) {
-      SWIG_JavaThrowException(jenv, SWIG_JavaRuntimeException, "Unable to get address of direct buffer. Buffer must be allocated direct.");
-    }
-  }
-  {
-    if (arg2) {
-      arg1->indexbase = arg2;
-    } else {
-      arg1->indexbase = 0;
-    }
-  }
-  
-}
-
-
-SWIGEXPORT jobject JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1indexbase_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jobject jresult = 0 ;
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  unsigned char *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  result = (unsigned char *) ((arg1)->indexbase);
-  *(unsigned char **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1indexstride_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  int arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  arg2 = (int)jarg2; 
-  if (arg1) (arg1)->indexstride = arg2;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1indexstride_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  result = (int) ((arg1)->indexstride);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1numfaces_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  int arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  arg2 = (int)jarg2; 
-  if (arg1) (arg1)->numfaces = arg2;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1numfaces_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  result = (int) ((arg1)->numfaces);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1indicestype_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  PHY_ScalarType arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  arg2 = (PHY_ScalarType)jarg2; 
-  if (arg1) (arg1)->indicestype = arg2;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1indicestype_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  PHY_ScalarType result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  result = (PHY_ScalarType) ((arg1)->indicestype);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btGImpactMeshShapePart_1TrimeshPrimitiveManager_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (btGImpactMeshShapePart::TrimeshPrimitiveManager *)new btGImpactMeshShapePart::TrimeshPrimitiveManager();
-  *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btGImpactMeshShapePart_1TrimeshPrimitiveManager_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = 0 ;
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1;
-  if (!arg1) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btGImpactMeshShapePart::TrimeshPrimitiveManager const & reference is null");
-    return 0;
-  } 
-  result = (btGImpactMeshShapePart::TrimeshPrimitiveManager *)new btGImpactMeshShapePart::TrimeshPrimitiveManager((btGImpactMeshShapePart::TrimeshPrimitiveManager const &)*arg1);
-  *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btGImpactMeshShapePart_1TrimeshPrimitiveManager_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jlong jresult = 0 ;
-  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
-  int arg2 ;
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btStridingMeshInterface **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (btGImpactMeshShapePart::TrimeshPrimitiveManager *)new btGImpactMeshShapePart::TrimeshPrimitiveManager(arg1,arg2);
-  *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1btGImpactMeshShapePart_1TrimeshPrimitiveManager(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1lock(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  (arg1)->lock();
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1unlock(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  (arg1)->unlock();
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1get_1vertex_1count(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  result = (int)((btGImpactMeshShapePart::TrimeshPrimitiveManager const *)arg1)->get_vertex_count();
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1get_1indices(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3, jlong jarg4, jlong jarg5) {
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  int arg2 ;
-  unsigned int *arg3 = 0 ;
-  unsigned int *arg4 = 0 ;
-  unsigned int *arg5 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  arg2 = (int)jarg2; 
-  arg3 = *(unsigned int **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "unsigned int & reference is null");
-    return ;
-  } 
-  arg4 = *(unsigned int **)&jarg4;
-  if (!arg4) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "unsigned int & reference is null");
-    return ;
-  } 
-  arg5 = *(unsigned int **)&jarg5;
-  if (!arg5) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "unsigned int & reference is null");
-    return ;
-  } 
-  ((btGImpactMeshShapePart::TrimeshPrimitiveManager const *)arg1)->get_indices(arg2,*arg3,*arg4,*arg5);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1get_1vertex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg3) {
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  unsigned int arg2 ;
-  btVector3 *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  arg2 = (unsigned int)jarg2; 
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  ((btGImpactMeshShapePart::TrimeshPrimitiveManager const *)arg1)->get_vertex(arg2,*arg3);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1get_1bullet_1triangle(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3, jobject jarg3_) {
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *arg1 = (btGImpactMeshShapePart::TrimeshPrimitiveManager *) 0 ;
-  int arg2 ;
-  btTriangleShapeEx *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg3_;
-  arg1 = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1; 
-  arg2 = (int)jarg2; 
-  arg3 = *(btTriangleShapeEx **)&jarg3;
-  if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btTriangleShapeEx & reference is null");
-    return ;
-  } 
-  ((btGImpactMeshShapePart::TrimeshPrimitiveManager const *)arg1)->get_bullet_triangle(arg2,*arg3);
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btGImpactMeshShapePart_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  btGImpactMeshShapePart *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (btGImpactMeshShapePart *)new btGImpactMeshShapePart();
-  *(btGImpactMeshShapePart **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btGImpactMeshShapePart_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jlong jresult = 0 ;
-  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
-  int arg2 ;
-  btGImpactMeshShapePart *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btStridingMeshInterface **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (btGImpactMeshShapePart *)new btGImpactMeshShapePart(arg1,arg2);
-  *(btGImpactMeshShapePart **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1btGImpactMeshShapePart(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  btGImpactMeshShapePart *arg1 = (btGImpactMeshShapePart *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(btGImpactMeshShapePart **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1getChildShape_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jlong jresult = 0 ;
-  btGImpactMeshShapePart *arg1 = (btGImpactMeshShapePart *) 0 ;
-  int arg2 ;
-  btCollisionShape *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (btCollisionShape *)(arg1)->getChildShape(arg2);
-  *(btCollisionShape **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1getTrimeshPrimitiveManager(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGImpactMeshShapePart *arg1 = (btGImpactMeshShapePart *) 0 ;
-  btGImpactMeshShapePart::TrimeshPrimitiveManager *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart **)&jarg1; 
-  result = (btGImpactMeshShapePart::TrimeshPrimitiveManager *)(arg1)->getTrimeshPrimitiveManager();
-  *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1getVertexCount(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btGImpactMeshShapePart *arg1 = (btGImpactMeshShapePart *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart **)&jarg1; 
-  result = (int)((btGImpactMeshShapePart const *)arg1)->getVertexCount();
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1getVertex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jobject jarg3) {
-  btGImpactMeshShapePart *arg1 = (btGImpactMeshShapePart *) 0 ;
-  int arg2 ;
-  btVector3 *arg3 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart **)&jarg1; 
-  arg2 = (int)jarg2; 
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  ((btGImpactMeshShapePart const *)arg1)->getVertex(arg2,*arg3);
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1getPart(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btGImpactMeshShapePart *arg1 = (btGImpactMeshShapePart *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapePart **)&jarg1; 
-  result = (int)((btGImpactMeshShapePart const *)arg1)->getPart();
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btGImpactMeshShape(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btStridingMeshInterface *arg1 = (btStridingMeshInterface *) 0 ;
-  btGImpactMeshShape *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btStridingMeshInterface **)&jarg1; 
-  result = (btGImpactMeshShape *)new btGImpactMeshShape(arg1);
-  *(btGImpactMeshShape **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1btGImpactMeshShape(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  btGImpactMeshShape *arg1 = (btGImpactMeshShape *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(btGImpactMeshShape **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShape_1getMeshInterface_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGImpactMeshShape *arg1 = (btGImpactMeshShape *) 0 ;
-  btStridingMeshInterface *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShape **)&jarg1; 
-  result = (btStridingMeshInterface *)(arg1)->getMeshInterface();
-  *(btStridingMeshInterface **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShape_1getMeshPartCount(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btGImpactMeshShape *arg1 = (btGImpactMeshShape *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShape **)&jarg1; 
-  result = (int)((btGImpactMeshShape const *)arg1)->getMeshPartCount();
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShape_1getMeshPart_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jlong jresult = 0 ;
-  btGImpactMeshShape *arg1 = (btGImpactMeshShape *) 0 ;
-  int arg2 ;
-  btGImpactMeshShapePart *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShape **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (btGImpactMeshShapePart *)(arg1)->getMeshPart(arg2);
-  *(btGImpactMeshShapePart **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShape_1getChildShape_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jlong jresult = 0 ;
-  btGImpactMeshShape *arg1 = (btGImpactMeshShape *) 0 ;
-  int arg2 ;
-  btCollisionShape *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShape **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (btCollisionShape *)(arg1)->getChildShape(arg2);
-  *(btCollisionShape **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapeData_1collisionShapeData_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  btGImpactMeshShapeData *arg1 = (btGImpactMeshShapeData *) 0 ;
-  btCollisionShapeData *arg2 = (btCollisionShapeData *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btGImpactMeshShapeData **)&jarg1; 
-  arg2 = *(btCollisionShapeData **)&jarg2; 
-  if (arg1) (arg1)->m_collisionShapeData = *arg2;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapeData_1collisionShapeData_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGImpactMeshShapeData *arg1 = (btGImpactMeshShapeData *) 0 ;
-  btCollisionShapeData *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapeData **)&jarg1; 
-  result = (btCollisionShapeData *)& ((arg1)->m_collisionShapeData);
-  *(btCollisionShapeData **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapeData_1meshInterface_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  btGImpactMeshShapeData *arg1 = (btGImpactMeshShapeData *) 0 ;
-  btStridingMeshInterfaceData *arg2 = (btStridingMeshInterfaceData *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btGImpactMeshShapeData **)&jarg1; 
-  arg2 = *(btStridingMeshInterfaceData **)&jarg2; 
-  if (arg1) (arg1)->m_meshInterface = *arg2;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapeData_1meshInterface_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGImpactMeshShapeData *arg1 = (btGImpactMeshShapeData *) 0 ;
-  btStridingMeshInterfaceData *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapeData **)&jarg1; 
-  result = (btStridingMeshInterfaceData *)& ((arg1)->m_meshInterface);
-  *(btStridingMeshInterfaceData **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapeData_1localScaling_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  btGImpactMeshShapeData *arg1 = (btGImpactMeshShapeData *) 0 ;
-  btVector3FloatData *arg2 = (btVector3FloatData *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btGImpactMeshShapeData **)&jarg1; 
-  arg2 = *(btVector3FloatData **)&jarg2; 
-  if (arg1) (arg1)->m_localScaling = *arg2;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapeData_1localScaling_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGImpactMeshShapeData *arg1 = (btGImpactMeshShapeData *) 0 ;
-  btVector3FloatData *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapeData **)&jarg1; 
-  result = (btVector3FloatData *)& ((arg1)->m_localScaling);
-  *(btVector3FloatData **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapeData_1collisionMargin_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jfloat jarg2) {
-  btGImpactMeshShapeData *arg1 = (btGImpactMeshShapeData *) 0 ;
-  float arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapeData **)&jarg1; 
-  arg2 = (float)jarg2; 
-  if (arg1) (arg1)->m_collisionMargin = arg2;
-}
-
-
-SWIGEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapeData_1collisionMargin_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jfloat jresult = 0 ;
-  btGImpactMeshShapeData *arg1 = (btGImpactMeshShapeData *) 0 ;
-  float result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapeData **)&jarg1; 
-  result = (float) ((arg1)->m_collisionMargin);
-  jresult = (jfloat)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapeData_1gimpactSubType_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  btGImpactMeshShapeData *arg1 = (btGImpactMeshShapeData *) 0 ;
-  int arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapeData **)&jarg1; 
-  arg2 = (int)jarg2; 
-  if (arg1) (arg1)->m_gimpactSubType = arg2;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapeData_1gimpactSubType_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btGImpactMeshShapeData *arg1 = (btGImpactMeshShapeData *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactMeshShapeData **)&jarg1; 
-  result = (int) ((arg1)->m_gimpactSubType);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btGImpactMeshShapeData(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  btGImpactMeshShapeData *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (btGImpactMeshShapeData *)new btGImpactMeshShapeData();
-  *(btGImpactMeshShapeData **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1btGImpactMeshShapeData(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  btGImpactMeshShapeData *arg1 = (btGImpactMeshShapeData *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(btGImpactMeshShapeData **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1CONTACT_1point_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  GIM_CONTACT *arg1 = (GIM_CONTACT *) 0 ;
-  btVector3 *arg2 = (btVector3 *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(GIM_CONTACT **)&jarg1; 
-  arg2 = *(btVector3 **)&jarg2; 
-  if (arg1) (arg1)->m_point = *arg2;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1CONTACT_1point_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  GIM_CONTACT *arg1 = (GIM_CONTACT *) 0 ;
-  btVector3 *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_CONTACT **)&jarg1; 
-  result = (btVector3 *)& ((arg1)->m_point);
-  *(btVector3 **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1CONTACT_1normal_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  GIM_CONTACT *arg1 = (GIM_CONTACT *) 0 ;
-  btVector3 *arg2 = (btVector3 *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(GIM_CONTACT **)&jarg1; 
-  arg2 = *(btVector3 **)&jarg2; 
-  if (arg1) (arg1)->m_normal = *arg2;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1CONTACT_1normal_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  GIM_CONTACT *arg1 = (GIM_CONTACT *) 0 ;
-  btVector3 *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_CONTACT **)&jarg1; 
-  result = (btVector3 *)& ((arg1)->m_normal);
-  *(btVector3 **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1CONTACT_1depth_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jfloat jarg2) {
-  GIM_CONTACT *arg1 = (GIM_CONTACT *) 0 ;
-  btScalar arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_CONTACT **)&jarg1; 
-  arg2 = (btScalar)jarg2; 
-  if (arg1) (arg1)->m_depth = arg2;
-}
-
-
-SWIGEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1CONTACT_1depth_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jfloat jresult = 0 ;
-  GIM_CONTACT *arg1 = (GIM_CONTACT *) 0 ;
-  btScalar result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_CONTACT **)&jarg1; 
-  result = (btScalar) ((arg1)->m_depth);
-  jresult = (jfloat)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1CONTACT_1distance_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jfloat jarg2) {
-  GIM_CONTACT *arg1 = (GIM_CONTACT *) 0 ;
-  btScalar arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_CONTACT **)&jarg1; 
-  arg2 = (btScalar)jarg2; 
-  if (arg1) (arg1)->m_distance = arg2;
-}
-
-
-SWIGEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1CONTACT_1distance_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jfloat jresult = 0 ;
-  GIM_CONTACT *arg1 = (GIM_CONTACT *) 0 ;
-  btScalar result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_CONTACT **)&jarg1; 
-  result = (btScalar) ((arg1)->m_distance);
-  jresult = (jfloat)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1CONTACT_1feature1_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  GIM_CONTACT *arg1 = (GIM_CONTACT *) 0 ;
-  int arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_CONTACT **)&jarg1; 
-  arg2 = (int)jarg2; 
-  if (arg1) (arg1)->m_feature1 = arg2;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1CONTACT_1feature1_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  GIM_CONTACT *arg1 = (GIM_CONTACT *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_CONTACT **)&jarg1; 
-  result = (int) ((arg1)->m_feature1);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1CONTACT_1feature2_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  GIM_CONTACT *arg1 = (GIM_CONTACT *) 0 ;
-  int arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_CONTACT **)&jarg1; 
-  arg2 = (int)jarg2; 
-  if (arg1) (arg1)->m_feature2 = arg2;
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1CONTACT_1feature2_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  GIM_CONTACT *arg1 = (GIM_CONTACT *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_CONTACT **)&jarg1; 
-  result = (int) ((arg1)->m_feature2);
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1GIM_1CONTACT_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  GIM_CONTACT *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (GIM_CONTACT *)new GIM_CONTACT();
-  *(GIM_CONTACT **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1GIM_1CONTACT_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  GIM_CONTACT *arg1 = 0 ;
-  GIM_CONTACT *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_CONTACT **)&jarg1;
-  if (!arg1) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "GIM_CONTACT const & reference is null");
-    return 0;
-  } 
-  result = (GIM_CONTACT *)new GIM_CONTACT((GIM_CONTACT const &)*arg1);
-  *(GIM_CONTACT **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1GIM_1CONTACT_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jobject jarg1, jobject jarg2, jfloat jarg3, jint jarg4, jint jarg5) {
-  jlong jresult = 0 ;
-  btVector3 *arg1 = 0 ;
-  btVector3 *arg2 = 0 ;
-  btScalar arg3 ;
-  int arg4 ;
-  int arg5 ;
-  GIM_CONTACT *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  btVector3 local_arg1;
-  gdx_setbtVector3FromVector3(jenv, local_arg1, jarg1);
-  arg1 = &local_arg1;
-  gdxAutoCommitVector3 auto_commit_arg1(jenv, jarg1, &local_arg1);
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  arg3 = (btScalar)jarg3; 
-  arg4 = (int)jarg4; 
-  arg5 = (int)jarg5; 
-  result = (GIM_CONTACT *)new GIM_CONTACT((btVector3 const &)*arg1,(btVector3 const &)*arg2,arg3,arg4,arg5);
-  *(GIM_CONTACT **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1CONTACT_1calc_1key_1contact(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  GIM_CONTACT *arg1 = (GIM_CONTACT *) 0 ;
-  unsigned int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(GIM_CONTACT **)&jarg1; 
-  result = (unsigned int)((GIM_CONTACT const *)arg1)->calc_key_contact();
-  jresult = (jlong)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_GIM_1CONTACT_1interpolate_1normals(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jint jarg3) {
-  GIM_CONTACT *arg1 = (GIM_CONTACT *) 0 ;
-  btVector3 *arg2 = (btVector3 *) 0 ;
-  int arg3 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(GIM_CONTACT **)&jarg1; 
-  arg2 = *(btVector3 **)&jarg2; 
-  arg3 = (int)jarg3; 
-  (arg1)->interpolate_normals(arg2,arg3);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1GIM_1CONTACT(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  GIM_CONTACT *arg1 = (GIM_CONTACT *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(GIM_CONTACT **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btContactArray(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  btContactArray *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (btContactArray *)new btContactArray();
-  *(btContactArray **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btContactArray_1push_1contact(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2, jobject jarg3, jfloat jarg4, jint jarg5, jint jarg6) {
-  btContactArray *arg1 = (btContactArray *) 0 ;
-  btVector3 *arg2 = 0 ;
-  btVector3 *arg3 = 0 ;
-  btScalar arg4 ;
-  int arg5 ;
-  int arg6 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btContactArray **)&jarg1; 
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  btVector3 local_arg3;
-  gdx_setbtVector3FromVector3(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitVector3 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  arg4 = (btScalar)jarg4; 
-  arg5 = (int)jarg5; 
-  arg6 = (int)jarg6; 
-  (arg1)->push_contact((btVector3 const &)*arg2,(btVector3 const &)*arg3,arg4,arg5,arg6);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btContactArray_1push_1triangle_1contacts(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jint jarg3, jint jarg4) {
-  btContactArray *arg1 = (btContactArray *) 0 ;
-  GIM_TRIANGLE_CONTACT *arg2 = 0 ;
-  int arg3 ;
-  int arg4 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btContactArray **)&jarg1; 
-  arg2 = *(GIM_TRIANGLE_CONTACT **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "GIM_TRIANGLE_CONTACT const & reference is null");
-    return ;
-  } 
-  arg3 = (int)jarg3; 
-  arg4 = (int)jarg4; 
-  (arg1)->push_triangle_contacts((GIM_TRIANGLE_CONTACT const &)*arg2,arg3,arg4);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btContactArray_1merge_1contacts_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jboolean jarg3) {
-  btContactArray *arg1 = (btContactArray *) 0 ;
-  btContactArray *arg2 = 0 ;
-  bool arg3 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btContactArray **)&jarg1; 
-  arg2 = *(btContactArray **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btContactArray const & reference is null");
-    return ;
-  } 
-  arg3 = jarg3 ? true : false; 
-  (arg1)->merge_contacts((btContactArray const &)*arg2,arg3);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btContactArray_1merge_1contacts_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  btContactArray *arg1 = (btContactArray *) 0 ;
-  btContactArray *arg2 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btContactArray **)&jarg1; 
-  arg2 = *(btContactArray **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btContactArray const & reference is null");
-    return ;
-  } 
-  (arg1)->merge_contacts((btContactArray const &)*arg2);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btContactArray_1merge_1contacts_1unique(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
-  btContactArray *arg1 = (btContactArray *) 0 ;
-  btContactArray *arg2 = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btContactArray **)&jarg1; 
-  arg2 = *(btContactArray **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btContactArray const & reference is null");
-    return ;
-  } 
-  (arg1)->merge_contacts_unique((btContactArray const &)*arg2);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1btContactArray(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  btContactArray *arg1 = (btContactArray *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(btContactArray **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericMemoryPool_1pool_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
-  btGenericMemoryPool *arg1 = (btGenericMemoryPool *) 0 ;
-  unsigned char *arg2 = (unsigned char *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericMemoryPool **)&jarg1; 
-  {
-    arg2 = (unsigned char*)jenv->GetDirectBufferAddress(jarg2);
-    if (arg2 == NULL) {
-      SWIG_JavaThrowException(jenv, SWIG_JavaRuntimeException, "Unable to get address of direct buffer. Buffer must be allocated direct.");
-    }
-  }
-  {
-    if (arg2) {
-      arg1->m_pool = arg2;
-    } else {
-      arg1->m_pool = 0;
-    }
-  }
-  
-}
-
-
-SWIGEXPORT jobject JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericMemoryPool_1pool_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jobject jresult = 0 ;
-  btGenericMemoryPool *arg1 = (btGenericMemoryPool *) 0 ;
-  unsigned char *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericMemoryPool **)&jarg1; 
-  result = (unsigned char *) ((arg1)->m_pool);
-  *(unsigned char **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericMemoryPool_1free_1nodes_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
-  btGenericMemoryPool *arg1 = (btGenericMemoryPool *) 0 ;
-  size_t *arg2 = (size_t *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericMemoryPool **)&jarg1; 
-  arg2 = *(size_t **)&jarg2; 
-  if (arg1) (arg1)->m_free_nodes = arg2;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericMemoryPool_1free_1nodes_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGenericMemoryPool *arg1 = (btGenericMemoryPool *) 0 ;
-  size_t *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericMemoryPool **)&jarg1; 
-  result = (size_t *) ((arg1)->m_free_nodes);
-  *(size_t **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericMemoryPool_1allocated_1sizes_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
-  btGenericMemoryPool *arg1 = (btGenericMemoryPool *) 0 ;
-  size_t *arg2 = (size_t *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericMemoryPool **)&jarg1; 
-  arg2 = *(size_t **)&jarg2; 
-  if (arg1) (arg1)->m_allocated_sizes = arg2;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericMemoryPool_1allocated_1sizes_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGenericMemoryPool *arg1 = (btGenericMemoryPool *) 0 ;
-  size_t *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericMemoryPool **)&jarg1; 
-  result = (size_t *) ((arg1)->m_allocated_sizes);
-  *(size_t **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericMemoryPool_1allocated_1count_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
-  btGenericMemoryPool *arg1 = (btGenericMemoryPool *) 0 ;
-  size_t arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericMemoryPool **)&jarg1; 
-  arg2 = (size_t)jarg2; 
-  if (arg1) (arg1)->m_allocated_count = arg2;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericMemoryPool_1allocated_1count_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGenericMemoryPool *arg1 = (btGenericMemoryPool *) 0 ;
-  size_t result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericMemoryPool **)&jarg1; 
-  result =  ((arg1)->m_allocated_count);
-  jresult = (jlong)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericMemoryPool_1free_1nodes_1count_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
-  btGenericMemoryPool *arg1 = (btGenericMemoryPool *) 0 ;
-  size_t arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericMemoryPool **)&jarg1; 
-  arg2 = (size_t)jarg2; 
-  if (arg1) (arg1)->m_free_nodes_count = arg2;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericMemoryPool_1free_1nodes_1count_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGenericMemoryPool *arg1 = (btGenericMemoryPool *) 0 ;
-  size_t result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericMemoryPool **)&jarg1; 
-  result =  ((arg1)->m_free_nodes_count);
-  jresult = (jlong)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericMemoryPool_1init_1pool(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3) {
-  btGenericMemoryPool *arg1 = (btGenericMemoryPool *) 0 ;
-  size_t arg2 ;
-  size_t arg3 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericMemoryPool **)&jarg1; 
-  arg2 = (size_t)jarg2; 
-  arg3 = (size_t)jarg3; 
-  (arg1)->init_pool(arg2,arg3);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericMemoryPool_1end_1pool(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  btGenericMemoryPool *arg1 = (btGenericMemoryPool *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericMemoryPool **)&jarg1; 
-  (arg1)->end_pool();
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btGenericMemoryPool(JNIEnv *jenv, jclass jcls, jlong jarg1, jlong jarg2) {
-  jlong jresult = 0 ;
-  size_t arg1 ;
-  size_t arg2 ;
-  btGenericMemoryPool *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = (size_t)jarg1; 
-  arg2 = (size_t)jarg2; 
-  result = (btGenericMemoryPool *)new btGenericMemoryPool(arg1,arg2);
-  *(btGenericMemoryPool **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1btGenericMemoryPool(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  btGenericMemoryPool *arg1 = (btGenericMemoryPool *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(btGenericMemoryPool **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericMemoryPool_1get_1pool_1capacity(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGenericMemoryPool *arg1 = (btGenericMemoryPool *) 0 ;
-  size_t result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericMemoryPool **)&jarg1; 
-  result = (arg1)->get_pool_capacity();
-  jresult = (jlong)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericMemoryPool_1gem_1element_1size(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGenericMemoryPool *arg1 = (btGenericMemoryPool *) 0 ;
-  size_t result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericMemoryPool **)&jarg1; 
-  result = (arg1)->gem_element_size();
-  jresult = (jlong)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericMemoryPool_1get_1max_1element_1count(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGenericMemoryPool *arg1 = (btGenericMemoryPool *) 0 ;
-  size_t result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericMemoryPool **)&jarg1; 
-  result = (arg1)->get_max_element_count();
-  jresult = (jlong)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericMemoryPool_1get_1allocated_1count(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGenericMemoryPool *arg1 = (btGenericMemoryPool *) 0 ;
-  size_t result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericMemoryPool **)&jarg1; 
-  result = (arg1)->get_allocated_count();
-  jresult = (jlong)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericMemoryPool_1get_1free_1positions_1count(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGenericMemoryPool *arg1 = (btGenericMemoryPool *) 0 ;
-  size_t result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericMemoryPool **)&jarg1; 
-  result = (arg1)->get_free_positions_count();
-  jresult = (jlong)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericMemoryPool_1get_1element_1data(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
-  jlong jresult = 0 ;
-  btGenericMemoryPool *arg1 = (btGenericMemoryPool *) 0 ;
-  size_t arg2 ;
-  void *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericMemoryPool **)&jarg1; 
-  arg2 = (size_t)jarg2; 
-  result = (void *)(arg1)->get_element_data(arg2);
-  jresult = (jlong)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericMemoryPool_1allocate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
-  jlong jresult = 0 ;
-  btGenericMemoryPool *arg1 = (btGenericMemoryPool *) 0 ;
-  size_t arg2 ;
-  void *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericMemoryPool **)&jarg1; 
-  arg2 = (size_t)jarg2; 
-  result = (void *)(arg1)->allocate(arg2);
-  jresult = (jlong)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericMemoryPool_1freeMemory(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
-  jboolean jresult = 0 ;
-  btGenericMemoryPool *arg1 = (btGenericMemoryPool *) 0 ;
-  void *arg2 = (void *) 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericMemoryPool **)&jarg1; 
-  arg2 = (void *)jarg2; 
-  result = (bool)(arg1)->freeMemory(arg2);
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericPoolAllocator_1pools_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
-  btGenericPoolAllocator *arg1 = (btGenericPoolAllocator *) 0 ;
-  btGenericMemoryPool **arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericPoolAllocator **)&jarg1; 
-  arg2 = *(btGenericMemoryPool ***)&jarg2; 
-  {
-    size_t ii;
-    btGenericMemoryPool * *b = (btGenericMemoryPool * *) arg1->m_pools;
-    for (ii = 0; ii < (size_t)16; ii++) b[ii] = *((btGenericMemoryPool * *) arg2 + ii);
-  }
-  
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericPoolAllocator_1pools_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGenericPoolAllocator *arg1 = (btGenericPoolAllocator *) 0 ;
-  btGenericMemoryPool **result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericPoolAllocator **)&jarg1; 
-  result = (btGenericMemoryPool **)(btGenericMemoryPool **) ((arg1)->m_pools);
-  *(btGenericMemoryPool ***)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericPoolAllocator_1pool_1count_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
-  btGenericPoolAllocator *arg1 = (btGenericPoolAllocator *) 0 ;
-  size_t arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericPoolAllocator **)&jarg1; 
-  arg2 = (size_t)jarg2; 
-  if (arg1) (arg1)->m_pool_count = arg2;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericPoolAllocator_1pool_1count_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGenericPoolAllocator *arg1 = (btGenericPoolAllocator *) 0 ;
-  size_t result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericPoolAllocator **)&jarg1; 
-  result =  ((arg1)->m_pool_count);
-  jresult = (jlong)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericPoolAllocator_1get_1pool_1capacity(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGenericPoolAllocator *arg1 = (btGenericPoolAllocator *) 0 ;
-  size_t result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericPoolAllocator **)&jarg1; 
-  result = (arg1)->get_pool_capacity();
-  jresult = (jlong)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btGenericPoolAllocator(JNIEnv *jenv, jclass jcls, jlong jarg1, jlong jarg2) {
-  jlong jresult = 0 ;
-  size_t arg1 ;
-  size_t arg2 ;
-  btGenericPoolAllocator *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = (size_t)jarg1; 
-  arg2 = (size_t)jarg2; 
-  result = (btGenericPoolAllocator *)new btGenericPoolAllocator(arg1,arg2);
-  *(btGenericPoolAllocator **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1btGenericPoolAllocator(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  btGenericPoolAllocator *arg1 = (btGenericPoolAllocator *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(btGenericPoolAllocator **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericPoolAllocator_1allocate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
-  jlong jresult = 0 ;
-  btGenericPoolAllocator *arg1 = (btGenericPoolAllocator *) 0 ;
-  size_t arg2 ;
-  void *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericPoolAllocator **)&jarg1; 
-  arg2 = (size_t)jarg2; 
-  result = (void *)(arg1)->allocate(arg2);
-  jresult = (jlong)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGenericPoolAllocator_1freeMemory(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
-  jboolean jresult = 0 ;
-  btGenericPoolAllocator *arg1 = (btGenericPoolAllocator *) 0 ;
-  void *arg2 = (void *) 0 ;
-  bool result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGenericPoolAllocator **)&jarg1; 
-  arg2 = (void *)jarg2; 
-  result = (bool)(arg1)->freeMemory(arg2);
-  jresult = (jboolean)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPoolAlloc(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  jlong jresult = 0 ;
-  size_t arg1 ;
-  void *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = (size_t)jarg1; 
-  result = (void *)btPoolAlloc(arg1);
-  jresult = (jlong)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPoolRealloc(JNIEnv *jenv, jclass jcls, jlong jarg1, jlong jarg2, jlong jarg3) {
-  jlong jresult = 0 ;
-  void *arg1 = (void *) 0 ;
-  size_t arg2 ;
-  size_t arg3 ;
-  void *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = (void *)jarg1; 
-  arg2 = (size_t)jarg2; 
-  arg3 = (size_t)jarg3; 
-  result = (void *)btPoolRealloc(arg1,arg2,arg3);
-  jresult = (jlong)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPoolFree(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  void *arg1 = (void *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = (void *)jarg1; 
-  btPoolFree(arg1);
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btGImpactCollisionAlgorithm(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_) {
-  jlong jresult = 0 ;
-  btCollisionAlgorithmConstructionInfo *arg1 = 0 ;
-  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
-  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
-  btGImpactCollisionAlgorithm *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  (void)jarg3_;
-  arg1 = *(btCollisionAlgorithmConstructionInfo **)&jarg1;
-  if (!arg1) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btCollisionAlgorithmConstructionInfo const & reference is null");
-    return 0;
-  } 
-  arg2 = *(btCollisionObjectWrapper **)&jarg2; 
-  arg3 = *(btCollisionObjectWrapper **)&jarg3; 
-  result = (btGImpactCollisionAlgorithm *)new btGImpactCollisionAlgorithm((btCollisionAlgorithmConstructionInfo const &)*arg1,(btCollisionObjectWrapper const *)arg2,(btCollisionObjectWrapper const *)arg3);
-  *(btGImpactCollisionAlgorithm **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1btGImpactCollisionAlgorithm(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  btGImpactCollisionAlgorithm *arg1 = (btGImpactCollisionAlgorithm *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(btGImpactCollisionAlgorithm **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCollisionAlgorithm_1internalGetResultOut(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jlong jresult = 0 ;
-  btGImpactCollisionAlgorithm *arg1 = (btGImpactCollisionAlgorithm *) 0 ;
-  btManifoldResult *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactCollisionAlgorithm **)&jarg1; 
-  result = (btManifoldResult *)(arg1)->internalGetResultOut();
-  *(btManifoldResult **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_new_1btGImpactCollisionAlgorithm_1CreateFunc(JNIEnv *jenv, jclass jcls) {
-  jlong jresult = 0 ;
-  btGImpactCollisionAlgorithm::CreateFunc *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  result = (btGImpactCollisionAlgorithm::CreateFunc *)new btGImpactCollisionAlgorithm::CreateFunc();
-  *(btGImpactCollisionAlgorithm::CreateFunc **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_delete_1btGImpactCollisionAlgorithm_1CreateFunc(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  btGImpactCollisionAlgorithm::CreateFunc *arg1 = (btGImpactCollisionAlgorithm::CreateFunc *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(btGImpactCollisionAlgorithm::CreateFunc **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCollisionAlgorithm_1registerAlgorithm(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  btCollisionDispatcher *arg1 = (btCollisionDispatcher *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btCollisionDispatcher **)&jarg1; 
-  btGImpactCollisionAlgorithm::registerAlgorithm(arg1);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCollisionAlgorithm_1gimpact_1vs_1gimpact(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_, jlong jarg4, jobject jarg4_, jlong jarg5, jobject jarg5_) {
-  btGImpactCollisionAlgorithm *arg1 = (btGImpactCollisionAlgorithm *) 0 ;
-  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
-  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
-  btGImpactShapeInterface *arg4 = (btGImpactShapeInterface *) 0 ;
-  btGImpactShapeInterface *arg5 = (btGImpactShapeInterface *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  (void)jarg3_;
-  (void)jarg4_;
-  (void)jarg5_;
-  arg1 = *(btGImpactCollisionAlgorithm **)&jarg1; 
-  arg2 = *(btCollisionObjectWrapper **)&jarg2; 
-  arg3 = *(btCollisionObjectWrapper **)&jarg3; 
-  arg4 = *(btGImpactShapeInterface **)&jarg4; 
-  arg5 = *(btGImpactShapeInterface **)&jarg5; 
-  (arg1)->gimpact_vs_gimpact((btCollisionObjectWrapper const *)arg2,(btCollisionObjectWrapper const *)arg3,(btGImpactShapeInterface const *)arg4,(btGImpactShapeInterface const *)arg5);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCollisionAlgorithm_1gimpact_1vs_1shape(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_, jlong jarg4, jobject jarg4_, jlong jarg5, jobject jarg5_, jboolean jarg6) {
-  btGImpactCollisionAlgorithm *arg1 = (btGImpactCollisionAlgorithm *) 0 ;
-  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
-  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
-  btGImpactShapeInterface *arg4 = (btGImpactShapeInterface *) 0 ;
-  btCollisionShape *arg5 = (btCollisionShape *) 0 ;
-  bool arg6 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  (void)jarg3_;
-  (void)jarg4_;
-  (void)jarg5_;
-  arg1 = *(btGImpactCollisionAlgorithm **)&jarg1; 
-  arg2 = *(btCollisionObjectWrapper **)&jarg2; 
-  arg3 = *(btCollisionObjectWrapper **)&jarg3; 
-  arg4 = *(btGImpactShapeInterface **)&jarg4; 
-  arg5 = *(btCollisionShape **)&jarg5; 
-  arg6 = jarg6 ? true : false; 
-  (arg1)->gimpact_vs_shape((btCollisionObjectWrapper const *)arg2,(btCollisionObjectWrapper const *)arg3,(btGImpactShapeInterface const *)arg4,(btCollisionShape const *)arg5,arg6);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCollisionAlgorithm_1gimpact_1vs_1compoundshape(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_, jlong jarg4, jobject jarg4_, jlong jarg5, jobject jarg5_, jboolean jarg6) {
-  btGImpactCollisionAlgorithm *arg1 = (btGImpactCollisionAlgorithm *) 0 ;
-  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
-  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
-  btGImpactShapeInterface *arg4 = (btGImpactShapeInterface *) 0 ;
-  btCompoundShape *arg5 = (btCompoundShape *) 0 ;
-  bool arg6 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  (void)jarg3_;
-  (void)jarg4_;
-  (void)jarg5_;
-  arg1 = *(btGImpactCollisionAlgorithm **)&jarg1; 
-  arg2 = *(btCollisionObjectWrapper **)&jarg2; 
-  arg3 = *(btCollisionObjectWrapper **)&jarg3; 
-  arg4 = *(btGImpactShapeInterface **)&jarg4; 
-  arg5 = *(btCompoundShape **)&jarg5; 
-  arg6 = jarg6 ? true : false; 
-  (arg1)->gimpact_vs_compoundshape((btCollisionObjectWrapper const *)arg2,(btCollisionObjectWrapper const *)arg3,(btGImpactShapeInterface const *)arg4,(btCompoundShape const *)arg5,arg6);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCollisionAlgorithm_1gimpact_1vs_1concave(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jlong jarg3, jobject jarg3_, jlong jarg4, jobject jarg4_, jlong jarg5, jobject jarg5_, jboolean jarg6) {
-  btGImpactCollisionAlgorithm *arg1 = (btGImpactCollisionAlgorithm *) 0 ;
-  btCollisionObjectWrapper *arg2 = (btCollisionObjectWrapper *) 0 ;
-  btCollisionObjectWrapper *arg3 = (btCollisionObjectWrapper *) 0 ;
-  btGImpactShapeInterface *arg4 = (btGImpactShapeInterface *) 0 ;
-  btConcaveShape *arg5 = (btConcaveShape *) 0 ;
-  bool arg6 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  (void)jarg3_;
-  (void)jarg4_;
-  (void)jarg5_;
-  arg1 = *(btGImpactCollisionAlgorithm **)&jarg1; 
-  arg2 = *(btCollisionObjectWrapper **)&jarg2; 
-  arg3 = *(btCollisionObjectWrapper **)&jarg3; 
-  arg4 = *(btGImpactShapeInterface **)&jarg4; 
-  arg5 = *(btConcaveShape **)&jarg5; 
-  arg6 = jarg6 ? true : false; 
-  (arg1)->gimpact_vs_concave((btCollisionObjectWrapper const *)arg2,(btCollisionObjectWrapper const *)arg3,(btGImpactShapeInterface const *)arg4,(btConcaveShape const *)arg5,arg6);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCollisionAlgorithm_1setFace0(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  btGImpactCollisionAlgorithm *arg1 = (btGImpactCollisionAlgorithm *) 0 ;
-  int arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactCollisionAlgorithm **)&jarg1; 
-  arg2 = (int)jarg2; 
-  (arg1)->setFace0(arg2);
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCollisionAlgorithm_1getFace0(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btGImpactCollisionAlgorithm *arg1 = (btGImpactCollisionAlgorithm *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactCollisionAlgorithm **)&jarg1; 
-  result = (int)(arg1)->getFace0();
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCollisionAlgorithm_1setFace1(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  btGImpactCollisionAlgorithm *arg1 = (btGImpactCollisionAlgorithm *) 0 ;
-  int arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactCollisionAlgorithm **)&jarg1; 
-  arg2 = (int)jarg2; 
-  (arg1)->setFace1(arg2);
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCollisionAlgorithm_1getFace1(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btGImpactCollisionAlgorithm *arg1 = (btGImpactCollisionAlgorithm *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactCollisionAlgorithm **)&jarg1; 
-  result = (int)(arg1)->getFace1();
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCollisionAlgorithm_1setPart0(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  btGImpactCollisionAlgorithm *arg1 = (btGImpactCollisionAlgorithm *) 0 ;
-  int arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactCollisionAlgorithm **)&jarg1; 
-  arg2 = (int)jarg2; 
-  (arg1)->setPart0(arg2);
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCollisionAlgorithm_1getPart0(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btGImpactCollisionAlgorithm *arg1 = (btGImpactCollisionAlgorithm *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactCollisionAlgorithm **)&jarg1; 
-  result = (int)(arg1)->getPart0();
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCollisionAlgorithm_1setPart1(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  btGImpactCollisionAlgorithm *arg1 = (btGImpactCollisionAlgorithm *) 0 ;
-  int arg2 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactCollisionAlgorithm **)&jarg1; 
-  arg2 = (int)jarg2; 
-  (arg1)->setPart1(arg2);
-}
-
-
-SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCollisionAlgorithm_1getPart1(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
-  jint jresult = 0 ;
-  btGImpactCollisionAlgorithm *arg1 = (btGImpactCollisionAlgorithm *) 0 ;
-  int result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btGImpactCollisionAlgorithm **)&jarg1; 
-  result = (int)(arg1)->getPart1();
-  jresult = (jint)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jobject JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_gim_1inertia_1add_1transformed(JNIEnv *jenv, jclass jcls, jobject jarg1, jobject jarg2, jobject jarg3) {
-  jobject jresult = 0 ;
-  btVector3 *arg1 = 0 ;
-  btVector3 *arg2 = 0 ;
-  btTransform *arg3 = 0 ;
-  btVector3 result;
-  
-  (void)jenv;
-  (void)jcls;
-  btVector3 local_arg1;
-  gdx_setbtVector3FromVector3(jenv, local_arg1, jarg1);
-  arg1 = &local_arg1;
-  gdxAutoCommitVector3 auto_commit_arg1(jenv, jarg1, &local_arg1);
-  btVector3 local_arg2;
-  gdx_setbtVector3FromVector3(jenv, local_arg2, jarg2);
-  arg2 = &local_arg2;
-  gdxAutoCommitVector3 auto_commit_arg2(jenv, jarg2, &local_arg2);
-  btTransform local_arg3;
-  gdx_setbtTransformFromMatrix4(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitMatrix4 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  result = gim_inertia_add_transformed((btVector3 const &)*arg1,(btVector3 const &)*arg2,(btTransform const &)*arg3);
-  jresult = gdx_getReturnVector3(jenv);
-  gdx_setVector3FrombtVector3(jenv, jresult, result);
-  return jresult;
-}
-
-
-SWIGEXPORT jobject JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_gim_1get_1point_1inertia(JNIEnv *jenv, jclass jcls, jobject jarg1, jfloat jarg2) {
-  jobject jresult = 0 ;
-  btVector3 *arg1 = 0 ;
-  btScalar arg2 ;
-  btVector3 result;
-  
-  (void)jenv;
-  (void)jcls;
-  btVector3 local_arg1;
-  gdx_setbtVector3FromVector3(jenv, local_arg1, jarg1);
-  arg1 = &local_arg1;
-  gdxAutoCommitVector3 auto_commit_arg1(jenv, jarg1, &local_arg1);
-  arg2 = (btScalar)jarg2; 
-  result = gim_get_point_inertia((btVector3 const &)*arg1,arg2);
-  jresult = gdx_getReturnVector3(jenv);
-  gdx_setVector3FrombtVector3(jenv, jresult, result);
-  return jresult;
-}
-
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btStorageResult_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btDiscreteCollisionDetectorInterface::Result **)&baseptr = *(btStorageResult **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btBroadphaseRayCallback_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btBroadphaseAabbCallback **)&baseptr = *(btBroadphaseRayCallback **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btDbvtProxy_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btBroadphaseProxy **)&baseptr = *(btDbvtProxy **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btDbvtBroadphase_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btBroadphaseInterface **)&baseptr = *(btDbvtBroadphase **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btSimpleBroadphaseProxy_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btBroadphaseProxy **)&baseptr = *(btSimpleBroadphaseProxy **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btSimpleBroadphase_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btBroadphaseInterface **)&baseptr = *(btSimpleBroadphase **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btMultiSapBroadphase_1btMultiSapProxy_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btBroadphaseProxy **)&baseptr = *(btMultiSapBroadphase::btMultiSapProxy **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btMultiSapBroadphase_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btBroadphaseInterface **)&baseptr = *(btMultiSapBroadphase **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAxisSweep3InternalShort_1Handle_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btBroadphaseProxy **)&baseptr = *(btAxisSweep3Internal< unsigned short >::Handle **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAxisSweep3InternalShort_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btBroadphaseInterface **)&baseptr = *(btAxisSweep3Internal< unsigned short > **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAxisSweep3InternalInt_1Handle_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btBroadphaseProxy **)&baseptr = *(btAxisSweep3Internal< unsigned int >::Handle **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAxisSweep3InternalInt_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btBroadphaseInterface **)&baseptr = *(btAxisSweep3Internal< unsigned int > **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btAxisSweep3_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btAxisSweep3Internal< unsigned short > **)&baseptr = *(btAxisSweep3 **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_bt32BitAxisSweep3_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btAxisSweep3Internal< unsigned int > **)&baseptr = *(bt32BitAxisSweep3 **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btOverlappingPairCache_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btOverlappingPairCallback **)&baseptr = *(btOverlappingPairCache **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btHashedOverlappingPairCache_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btOverlappingPairCache **)&baseptr = *(btHashedOverlappingPairCache **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btSortedOverlappingPairCache_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btOverlappingPairCache **)&baseptr = *(btSortedOverlappingPairCache **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btNullPairCache_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btOverlappingPairCache **)&baseptr = *(btNullPairCache **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btConvexShape_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btCollisionShape **)&baseptr = *(btConvexShape **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btConvexInternalShape_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btConvexShape **)&baseptr = *(btConvexInternalShape **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btConvexInternalAabbCachingShape_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btConvexInternalShape **)&baseptr = *(btConvexInternalAabbCachingShape **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPolyhedralConvexShape_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btConvexInternalShape **)&baseptr = *(btPolyhedralConvexShape **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btPolyhedralConvexAabbCachingShape_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btPolyhedralConvexShape **)&baseptr = *(btPolyhedralConvexAabbCachingShape **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btConcaveShape_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btCollisionShape **)&baseptr = *(btConcaveShape **)&jarg1;
-    return baseptr;
-}
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btConcaveShape_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+    jlong baseptr = 0;
+    (void)jenv;
+    (void)jcls;
+    *(btCollisionShape **)&baseptr = *(btConcaveShape **)&jarg1;
+    return baseptr;
+}
 
 SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btStaticPlaneShape_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
     jlong baseptr = 0;
@@ -53044,86 +46221,6 @@ SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_Collisio
     return baseptr;
 }
 
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btTriangleShapeEx_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btTriangleShape **)&baseptr = *(btTriangleShapeEx **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btTetrahedronShapeEx_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btBU_Simplex1to4 **)&baseptr = *(btTetrahedronShapeEx **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactShapeInterface_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btConcaveShape **)&baseptr = *(btGImpactShapeInterface **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCompoundShape_1CompoundPrimitiveManager_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btPrimitiveManagerBase **)&baseptr = *(btGImpactCompoundShape::CompoundPrimitiveManager **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCompoundShape_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btGImpactShapeInterface **)&baseptr = *(btGImpactCompoundShape **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1TrimeshPrimitiveManager_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btPrimitiveManagerBase **)&baseptr = *(btGImpactMeshShapePart::TrimeshPrimitiveManager **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShapePart_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btGImpactShapeInterface **)&baseptr = *(btGImpactMeshShapePart **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactMeshShape_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btGImpactShapeInterface **)&baseptr = *(btGImpactMeshShape **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCollisionAlgorithm_1CreateFunc_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btCollisionAlgorithmCreateFunc **)&baseptr = *(btGImpactCollisionAlgorithm::CreateFunc **)&jarg1;
-    return baseptr;
-}
-
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_btGImpactCollisionAlgorithm_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btActivatingCollisionAlgorithm **)&baseptr = *(btGImpactCollisionAlgorithm **)&jarg1;
-    return baseptr;
-}
-
 SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_CollisionJNI_swig_1module_1init(JNIEnv *jenv, jclass jcls) {
   int i;
   
@@ -53228,7 +46325,7 @@ SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_Collision
       "SwigDirector_CustomCollisionDispatcher_needsResponse", "(Lcom/badlogic/gdx/physics/bullet/collision/CustomCollisionDispatcher;JJ)Z" 
     },
     {
-      "SwigDirector_ContactListener_onContactAdded__SWIG_0", "(Lcom/badlogic/gdx/physics/bullet/collision/ContactListener;JJIIJII)Z" 
+      "SwigDirector_ContactListener_onContactAdded__SWIG_0", "(Lcom/badlogic/gdx/physics/bullet/collision/ContactListener;JLcom/badlogic/gdx/physics/bullet/collision/btCollisionObjectWrapper;IILcom/badlogic/gdx/physics/bullet/collision/btCollisionObjectWrapper;II)Z" 
     },
     {
       "SwigDirector_ContactListener_onContactAdded__SWIG_1", "(Lcom/badlogic/gdx/physics/bullet/collision/ContactListener;JJIIJII)Z" 
@@ -53237,7 +46334,7 @@ SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_Collision
       "SwigDirector_ContactListener_onContactAdded__SWIG_2", "(Lcom/badlogic/gdx/physics/bullet/collision/ContactListener;JIIIIII)Z" 
     },
     {
-      "SwigDirector_ContactListener_onContactAdded__SWIG_3", "(Lcom/badlogic/gdx/physics/bullet/collision/ContactListener;JJIIZJIIZ)Z" 
+      "SwigDirector_ContactListener_onContactAdded__SWIG_3", "(Lcom/badlogic/gdx/physics/bullet/collision/ContactListener;JLcom/badlogic/gdx/physics/bullet/collision/btCollisionObjectWrapper;IIZLcom/badlogic/gdx/physics/bullet/collision/btCollisionObjectWrapper;IIZ)Z" 
     },
     {
       "SwigDirector_ContactListener_onContactAdded__SWIG_4", "(Lcom/badlogic/gdx/physics/bullet/collision/ContactListener;JJIIZJIIZ)Z" 
@@ -53246,7 +46343,7 @@ SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_Collision
       "SwigDirector_ContactListener_onContactAdded__SWIG_5", "(Lcom/badlogic/gdx/physics/bullet/collision/ContactListener;JIIIZIIIZ)Z" 
     },
     {
-      "SwigDirector_ContactListener_onContactAdded__SWIG_6", "(Lcom/badlogic/gdx/physics/bullet/collision/ContactListener;JIIJII)Z" 
+      "SwigDirector_ContactListener_onContactAdded__SWIG_6", "(Lcom/badlogic/gdx/physics/bullet/collision/ContactListener;Lcom/badlogic/gdx/physics/bullet/collision/btCollisionObjectWrapper;IILcom/badlogic/gdx/physics/bullet/collision/btCollisionObjectWrapper;II)Z" 
     },
     {
       "SwigDirector_ContactListener_onContactAdded__SWIG_7", "(Lcom/badlogic/gdx/physics/bullet/collision/ContactListener;JIIJII)Z" 
@@ -53255,7 +46352,7 @@ SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_collision_Collision
       "SwigDirector_ContactListener_onContactAdded__SWIG_8", "(Lcom/badlogic/gdx/physics/bullet/collision/ContactListener;IIIIII)Z" 
     },
     {
-      "SwigDirector_ContactListener_onContactAdded__SWIG_9", "(Lcom/badlogic/gdx/physics/bullet/collision/ContactListener;JIIZJIIZ)Z" 
+      "SwigDirector_ContactListener_onContactAdded__SWIG_9", "(Lcom/badlogic/gdx/physics/bullet/collision/ContactListener;Lcom/badlogic/gdx/physics/bullet/collision/btCollisionObjectWrapper;IIZLcom/badlogic/gdx/physics/bullet/collision/btCollisionObjectWrapper;IIZ)Z" 
     },
     {
       "SwigDirector_ContactListener_onContactAdded__SWIG_10", "(Lcom/badlogic/gdx/physics/bullet/collision/ContactListener;JIIZJIIZ)Z" 
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/BT_BOX_BOX_TRANSFORM_CACHE.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/BT_BOX_BOX_TRANSFORM_CACHE.java
deleted file mode 100644
index bd119a0..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/BT_BOX_BOX_TRANSFORM_CACHE.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class BT_BOX_BOX_TRANSFORM_CACHE extends BulletBase {
-	private long swigCPtr;
-	
-	protected BT_BOX_BOX_TRANSFORM_CACHE(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, cPtr, cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new BT_BOX_BOX_TRANSFORM_CACHE, normally you should not need this constructor it's intended for low-level usage. */ 
-	public BT_BOX_BOX_TRANSFORM_CACHE(long cPtr, boolean cMemoryOwn) {
-		this("BT_BOX_BOX_TRANSFORM_CACHE", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(swigCPtr = cPtr, cMemoryOwn);
-	}
-	
-	public static long getCPtr(BT_BOX_BOX_TRANSFORM_CACHE obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_BT_BOX_BOX_TRANSFORM_CACHE(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public void setT1to0(btVector3 value) {
-    CollisionJNI.BT_BOX_BOX_TRANSFORM_CACHE_T1to0_set(swigCPtr, this, btVector3.getCPtr(value), value);
-  }
-
-  public btVector3 getT1to0() {
-    long cPtr = CollisionJNI.BT_BOX_BOX_TRANSFORM_CACHE_T1to0_get(swigCPtr, this);
-    return (cPtr == 0) ? null : new btVector3(cPtr, false);
-  }
-
-  public void setR1to0(Matrix3 value) {
-    CollisionJNI.BT_BOX_BOX_TRANSFORM_CACHE_R1to0_set(swigCPtr, this, value);
-  }
-
-  public Matrix3 getR1to0() {
-	return CollisionJNI.BT_BOX_BOX_TRANSFORM_CACHE_R1to0_get(swigCPtr, this);
-}
-
-  public void setAR(Matrix3 value) {
-    CollisionJNI.BT_BOX_BOX_TRANSFORM_CACHE_AR_set(swigCPtr, this, value);
-  }
-
-  public Matrix3 getAR() {
-	return CollisionJNI.BT_BOX_BOX_TRANSFORM_CACHE_AR_get(swigCPtr, this);
-}
-
-  public void calc_absolute_matrix() {
-    CollisionJNI.BT_BOX_BOX_TRANSFORM_CACHE_calc_absolute_matrix(swigCPtr, this);
-  }
-
-  public BT_BOX_BOX_TRANSFORM_CACHE() {
-    this(CollisionJNI.new_BT_BOX_BOX_TRANSFORM_CACHE(), true);
-  }
-
-  public void calc_from_homogenic(Matrix4 trans0, Matrix4 trans1) {
-    CollisionJNI.BT_BOX_BOX_TRANSFORM_CACHE_calc_from_homogenic(swigCPtr, this, trans0, trans1);
-  }
-
-  public void calc_from_full_invert(Matrix4 trans0, Matrix4 trans1) {
-    CollisionJNI.BT_BOX_BOX_TRANSFORM_CACHE_calc_from_full_invert(swigCPtr, this, trans0, trans1);
-  }
-
-  public Vector3 transform(Vector3 point) {
-	return CollisionJNI.BT_BOX_BOX_TRANSFORM_CACHE_transform(swigCPtr, this, point);
-}
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/BT_QUANTIZED_BVH_NODE.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/BT_QUANTIZED_BVH_NODE.java
deleted file mode 100644
index 36e241f..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/BT_QUANTIZED_BVH_NODE.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class BT_QUANTIZED_BVH_NODE extends BulletBase {
-	private long swigCPtr;
-	
-	protected BT_QUANTIZED_BVH_NODE(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, cPtr, cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new BT_QUANTIZED_BVH_NODE, normally you should not need this constructor it's intended for low-level usage. */ 
-	public BT_QUANTIZED_BVH_NODE(long cPtr, boolean cMemoryOwn) {
-		this("BT_QUANTIZED_BVH_NODE", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(swigCPtr = cPtr, cMemoryOwn);
-	}
-	
-	public static long getCPtr(BT_QUANTIZED_BVH_NODE obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_BT_QUANTIZED_BVH_NODE(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public void setQuantizedAabbMin(int[] value) {
-    CollisionJNI.BT_QUANTIZED_BVH_NODE_quantizedAabbMin_set(swigCPtr, this, value);
-  }
-
-  public int[] getQuantizedAabbMin() {
-    return CollisionJNI.BT_QUANTIZED_BVH_NODE_quantizedAabbMin_get(swigCPtr, this);
-}
-
-  public void setQuantizedAabbMax(int[] value) {
-    CollisionJNI.BT_QUANTIZED_BVH_NODE_quantizedAabbMax_set(swigCPtr, this, value);
-  }
-
-  public int[] getQuantizedAabbMax() {
-    return CollisionJNI.BT_QUANTIZED_BVH_NODE_quantizedAabbMax_get(swigCPtr, this);
-}
-
-  public void setEscapeIndexOrDataIndex(int value) {
-    CollisionJNI.BT_QUANTIZED_BVH_NODE_escapeIndexOrDataIndex_set(swigCPtr, this, value);
-  }
-
-  public int getEscapeIndexOrDataIndex() {
-    return CollisionJNI.BT_QUANTIZED_BVH_NODE_escapeIndexOrDataIndex_get(swigCPtr, this);
-  }
-
-  public BT_QUANTIZED_BVH_NODE() {
-    this(CollisionJNI.new_BT_QUANTIZED_BVH_NODE(), true);
-  }
-
-  public boolean isLeafNode() {
-    return CollisionJNI.BT_QUANTIZED_BVH_NODE_isLeafNode(swigCPtr, this);
-  }
-
-  public int getEscapeIndex() {
-    return CollisionJNI.BT_QUANTIZED_BVH_NODE_getEscapeIndex(swigCPtr, this);
-  }
-
-  public void setEscapeIndex(int index) {
-    CollisionJNI.BT_QUANTIZED_BVH_NODE_setEscapeIndex(swigCPtr, this, index);
-  }
-
-  public int getDataIndex() {
-    return CollisionJNI.BT_QUANTIZED_BVH_NODE_getDataIndex(swigCPtr, this);
-  }
-
-  public void setDataIndex(int index) {
-    CollisionJNI.BT_QUANTIZED_BVH_NODE_setDataIndex(swigCPtr, this, index);
-  }
-
-  public boolean testQuantizedBoxOverlapp(java.nio.IntBuffer quantizedMin, java.nio.IntBuffer quantizedMax) {
-    assert quantizedMin.isDirect() : "Buffer must be allocated direct.";
-    assert quantizedMax.isDirect() : "Buffer must be allocated direct.";
-    {
-      return CollisionJNI.BT_QUANTIZED_BVH_NODE_testQuantizedBoxOverlapp(swigCPtr, this, quantizedMin, quantizedMax);
-    }
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/Collision.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/Collision.java
index 9d20a11..7e1dce1 100644
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/Collision.java
+++ b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/Collision.java
@@ -211,86 +211,4 @@ public class Collision implements CollisionConstants {
     return CollisionJNI.gContactBreakingThreshold_get();
   }
 
-  public static void bt_calc_quantization_parameters(Vector3 outMinBound, Vector3 outMaxBound, Vector3 bvhQuantization, Vector3 srcMinBound, Vector3 srcMaxBound, float quantizationMargin) {
-    CollisionJNI.bt_calc_quantization_parameters(outMinBound, outMaxBound, bvhQuantization, srcMinBound, srcMaxBound, quantizationMargin);
-  }
-
-  public static void bt_quantize_clamp(java.nio.IntBuffer out, Vector3 point, Vector3 min_bound, Vector3 max_bound, Vector3 bvhQuantization) {
-    assert out.isDirect() : "Buffer must be allocated direct.";
-    {
-      CollisionJNI.bt_quantize_clamp(out, point, min_bound, max_bound, bvhQuantization);
-    }
-  }
-
-  public static Vector3 bt_unquantize(java.nio.IntBuffer vecIn, Vector3 offset, Vector3 bvhQuantization) {
-    assert vecIn.isDirect() : "Buffer must be allocated direct.";
-    {
-	return CollisionJNI.bt_unquantize(vecIn, offset, bvhQuantization);
-}
-  }
-
-  public static float bt_mat3_dot_col(Matrix3 mat, Vector3 vec3, int colindex) {
-    return CollisionJNI.bt_mat3_dot_col(mat, vec3, colindex);
-  }
-
-  public static boolean btCompareTransformsEqual(Matrix4 t1, Matrix4 t2) {
-    return CollisionJNI.btCompareTransformsEqual(t1, t2);
-  }
-
-  public static float bt_distance_point_plane(btVector4 plane, Vector3 point) {
-    return CollisionJNI.bt_distance_point_plane(btVector4.getCPtr(plane), plane, point);
-  }
-
-  public static void bt_vec_blend(Vector3 vr, Vector3 va, Vector3 vb, float blend_factor) {
-    CollisionJNI.bt_vec_blend(vr, va, vb, blend_factor);
-  }
-
-  public static void bt_plane_clip_polygon_collect(Vector3 point0, Vector3 point1, float dist0, float dist1, btVector3 clipped, SWIGTYPE_p_int clipped_count) {
-    CollisionJNI.bt_plane_clip_polygon_collect(point0, point1, dist0, dist1, btVector3.getCPtr(clipped), clipped, SWIGTYPE_p_int.getCPtr(clipped_count));
-  }
-
-  public static int bt_plane_clip_polygon(btVector4 plane, btVector3 polygon_points, int polygon_point_count, btVector3 clipped) {
-    return CollisionJNI.bt_plane_clip_polygon(btVector4.getCPtr(plane), plane, btVector3.getCPtr(polygon_points), polygon_points, polygon_point_count, btVector3.getCPtr(clipped), clipped);
-  }
-
-  public static int bt_plane_clip_triangle(btVector4 plane, Vector3 point0, Vector3 point1, Vector3 point2, btVector3 clipped) {
-    return CollisionJNI.bt_plane_clip_triangle(btVector4.getCPtr(plane), plane, point0, point1, point2, btVector3.getCPtr(clipped), clipped);
-  }
-
-  public static void bt_edge_plane(Vector3 e1, Vector3 e2, Vector3 normal, btVector4 plane) {
-    CollisionJNI.bt_edge_plane(e1, e2, normal, btVector4.getCPtr(plane), plane);
-  }
-
-  public static void bt_closest_point_on_segment(Vector3 cp, Vector3 v, Vector3 e1, Vector3 e2) {
-    CollisionJNI.bt_closest_point_on_segment(cp, v, e1, e2);
-  }
-
-  public static int bt_line_plane_collision(btVector4 plane, Vector3 vDir, Vector3 vPoint, Vector3 pout, SWIGTYPE_p_float tparam, float tmin, float tmax) {
-    return CollisionJNI.bt_line_plane_collision(btVector4.getCPtr(plane), plane, vDir, vPoint, pout, SWIGTYPE_p_float.getCPtr(tparam), tmin, tmax);
-  }
-
-  public static void bt_segment_collision(Vector3 vA1, Vector3 vA2, Vector3 vB1, Vector3 vB2, Vector3 vPointA, Vector3 vPointB) {
-    CollisionJNI.bt_segment_collision(vA1, vA2, vB1, vB2, vPointA, vPointB);
-  }
-
-  public static long btPoolAlloc(long size) {
-    return CollisionJNI.btPoolAlloc(size);
-  }
-
-  public static long btPoolRealloc(long ptr, long oldsize, long newsize) {
-    return CollisionJNI.btPoolRealloc(ptr, oldsize, newsize);
-  }
-
-  public static void btPoolFree(long ptr) {
-    CollisionJNI.btPoolFree(ptr);
-  }
-
-  public static Vector3 gim_inertia_add_transformed(Vector3 source_inertia, Vector3 added_inertia, Matrix4 transform) {
-	return CollisionJNI.gim_inertia_add_transformed(source_inertia, added_inertia, transform);
-}
-
-  public static Vector3 gim_get_point_inertia(Vector3 point, float mass) {
-	return CollisionJNI.gim_get_point_inertia(point, mass);
-}
-
 }
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/CollisionConstants.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/CollisionConstants.java
index 291a4c1..784385a 100644
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/CollisionConstants.java
+++ b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/CollisionConstants.java
@@ -54,12 +54,4 @@ public interface CollisionConstants {
   public final static int NO_VIRTUAL_INTERFACE = 1;
   public final static int VORONOI_SIMPLEX_MAX_VERTS = 5;
   public final static double VORONOI_DEFAULT_EQUAL_VERTEX_THRESHOLD = 0.0001;
-  public final static double BOX_PLANE_EPSILON = 0.000001;
-  public final static double PLANEDIREPSILON = 0.0000001;
-  public final static double PARALELENORMALS = 0.000001;
-  public final static int MAX_TRI_CLIPPING = 16;
-  public final static int NORMAL_CONTACT_AVERAGE = 1;
-  public final static double CONTACT_DIFF_EPSILON = 0.00001;
-  public final static int BT_DEFAULT_MAX_POOLS = 16;
-  public final static int GIMPACT_VS_PLANE_COLLISION = 1;
 }
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/CollisionJNI.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/CollisionJNI.java
index 24f1316..bb4c1bf 100644
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/CollisionJNI.java
+++ b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/CollisionJNI.java
@@ -2412,16 +2412,16 @@ public class CollisionJNI {
   public final static native void ContactListener_enableOnAdded(long jarg1, ContactListener jarg1_);
   public final static native void ContactListener_disableOnAdded(long jarg1, ContactListener jarg1_);
   public final static native boolean ContactListener_isOnAddedEnabled(long jarg1, ContactListener jarg1_);
-  public final static native boolean ContactListener_onContactAdded__SWIG_0(long jarg1, ContactListener jarg1_, long jarg2, btManifoldPoint jarg2_, long jarg3, btCollisionObjectWrapper jarg3_, int jarg4, int jarg5, long jarg6, btCollisionObjectWrapper jarg6_, int jarg7, int jarg8);
+  public final static native boolean ContactListener_onContactAdded__SWIG_0(long jarg1, ContactListener jarg1_, long jarg2, btManifoldPoint jarg2_, btCollisionObjectWrapper jarg3, int jarg4, int jarg5, btCollisionObjectWrapper jarg6, int jarg7, int jarg8);
   public final static native boolean ContactListener_onContactAdded__SWIG_1(long jarg1, ContactListener jarg1_, long jarg2, btManifoldPoint jarg2_, long jarg3, btCollisionObject jarg3_, int jarg4, int jarg5, long jarg6, btCollisionObject jarg6_, int jarg7, int jarg8);
   public final static native boolean ContactListener_onContactAdded__SWIG_2(long jarg1, ContactListener jarg1_, long jarg2, btManifoldPoint jarg2_, int jarg3, int jarg4, int jarg5, int jarg6, int jarg7, int jarg8);
-  public final static native boolean ContactListener_onContactAdded__SWIG_3(long jarg1, ContactListener jarg1_, long jarg2, btManifoldPoint jarg2_, long jarg3, btCollisionObjectWrapper jarg3_, int jarg4, int jarg5, boolean jarg6, long jarg7, btCollisionObjectWrapper jarg7_, int jarg8, int jarg9, boolean jarg10);
+  public final static native boolean ContactListener_onContactAdded__SWIG_3(long jarg1, ContactListener jarg1_, long jarg2, btManifoldPoint jarg2_, btCollisionObjectWrapper jarg3, int jarg4, int jarg5, boolean jarg6, btCollisionObjectWrapper jarg7, int jarg8, int jarg9, boolean jarg10);
   public final static native boolean ContactListener_onContactAdded__SWIG_4(long jarg1, ContactListener jarg1_, long jarg2, btManifoldPoint jarg2_, long jarg3, btCollisionObject jarg3_, int jarg4, int jarg5, boolean jarg6, long jarg7, btCollisionObject jarg7_, int jarg8, int jarg9, boolean jarg10);
   public final static native boolean ContactListener_onContactAdded__SWIG_5(long jarg1, ContactListener jarg1_, long jarg2, btManifoldPoint jarg2_, int jarg3, int jarg4, int jarg5, boolean jarg6, int jarg7, int jarg8, int jarg9, boolean jarg10);
-  public final static native boolean ContactListener_onContactAdded__SWIG_6(long jarg1, ContactListener jarg1_, long jarg2, btCollisionObjectWrapper jarg2_, int jarg3, int jarg4, long jarg5, btCollisionObjectWrapper jarg5_, int jarg6, int jarg7);
+  public final static native boolean ContactListener_onContactAdded__SWIG_6(long jarg1, ContactListener jarg1_, btCollisionObjectWrapper jarg2, int jarg3, int jarg4, btCollisionObjectWrapper jarg5, int jarg6, int jarg7);
   public final static native boolean ContactListener_onContactAdded__SWIG_7(long jarg1, ContactListener jarg1_, long jarg2, btCollisionObject jarg2_, int jarg3, int jarg4, long jarg5, btCollisionObject jarg5_, int jarg6, int jarg7);
   public final static native boolean ContactListener_onContactAdded__SWIG_8(long jarg1, ContactListener jarg1_, int jarg2, int jarg3, int jarg4, int jarg5, int jarg6, int jarg7);
-  public final static native boolean ContactListener_onContactAdded__SWIG_9(long jarg1, ContactListener jarg1_, long jarg2, btCollisionObjectWrapper jarg2_, int jarg3, int jarg4, boolean jarg5, long jarg6, btCollisionObjectWrapper jarg6_, int jarg7, int jarg8, boolean jarg9);
+  public final static native boolean ContactListener_onContactAdded__SWIG_9(long jarg1, ContactListener jarg1_, btCollisionObjectWrapper jarg2, int jarg3, int jarg4, boolean jarg5, btCollisionObjectWrapper jarg6, int jarg7, int jarg8, boolean jarg9);
   public final static native boolean ContactListener_onContactAdded__SWIG_10(long jarg1, ContactListener jarg1_, long jarg2, btCollisionObject jarg2_, int jarg3, int jarg4, boolean jarg5, long jarg6, btCollisionObject jarg6_, int jarg7, int jarg8, boolean jarg9);
   public final static native boolean ContactListener_onContactAdded__SWIG_11(long jarg1, ContactListener jarg1_, int jarg2, int jarg3, int jarg4, boolean jarg5, int jarg6, int jarg7, int jarg8, boolean jarg9);
   public final static native void ContactListener_enableOnProcessed(long jarg1, ContactListener jarg1_);
@@ -2479,408 +2479,6 @@ public class CollisionJNI {
   public final static native int btBroadphasePairArray_getCollisionObjectsValue(long jarg1, btBroadphasePairArray jarg1_, int[] jarg2, int jarg3, int jarg4);
   public final static native long new_btBroadphasePairArray();
   public final static native void delete_btBroadphasePairArray(long jarg1);
-  public final static native void bt_calc_quantization_parameters(Vector3 jarg1, Vector3 jarg2, Vector3 jarg3, Vector3 jarg4, Vector3 jarg5, float jarg6);
-  public final static native void bt_quantize_clamp(java.nio.IntBuffer jarg1, Vector3 jarg2, Vector3 jarg3, Vector3 jarg4, Vector3 jarg5);
-  public final static native Vector3 bt_unquantize(java.nio.IntBuffer jarg1, Vector3 jarg2, Vector3 jarg3);
-  public final static native float bt_mat3_dot_col(Matrix3 jarg1, Vector3 jarg2, int jarg3);
-  public final static native void BT_BOX_BOX_TRANSFORM_CACHE_T1to0_set(long jarg1, BT_BOX_BOX_TRANSFORM_CACHE jarg1_, long jarg2, btVector3 jarg2_);
-  public final static native long BT_BOX_BOX_TRANSFORM_CACHE_T1to0_get(long jarg1, BT_BOX_BOX_TRANSFORM_CACHE jarg1_);
-  public final static native void BT_BOX_BOX_TRANSFORM_CACHE_R1to0_set(long jarg1, BT_BOX_BOX_TRANSFORM_CACHE jarg1_, Matrix3 jarg2);
-  public final static native Matrix3 BT_BOX_BOX_TRANSFORM_CACHE_R1to0_get(long jarg1, BT_BOX_BOX_TRANSFORM_CACHE jarg1_);
-  public final static native void BT_BOX_BOX_TRANSFORM_CACHE_AR_set(long jarg1, BT_BOX_BOX_TRANSFORM_CACHE jarg1_, Matrix3 jarg2);
-  public final static native Matrix3 BT_BOX_BOX_TRANSFORM_CACHE_AR_get(long jarg1, BT_BOX_BOX_TRANSFORM_CACHE jarg1_);
-  public final static native void BT_BOX_BOX_TRANSFORM_CACHE_calc_absolute_matrix(long jarg1, BT_BOX_BOX_TRANSFORM_CACHE jarg1_);
-  public final static native long new_BT_BOX_BOX_TRANSFORM_CACHE();
-  public final static native void BT_BOX_BOX_TRANSFORM_CACHE_calc_from_homogenic(long jarg1, BT_BOX_BOX_TRANSFORM_CACHE jarg1_, Matrix4 jarg2, Matrix4 jarg3);
-  public final static native void BT_BOX_BOX_TRANSFORM_CACHE_calc_from_full_invert(long jarg1, BT_BOX_BOX_TRANSFORM_CACHE jarg1_, Matrix4 jarg2, Matrix4 jarg3);
-  public final static native Vector3 BT_BOX_BOX_TRANSFORM_CACHE_transform(long jarg1, BT_BOX_BOX_TRANSFORM_CACHE jarg1_, Vector3 jarg2);
-  public final static native void delete_BT_BOX_BOX_TRANSFORM_CACHE(long jarg1);
-  public final static native void btAABB_min_set(long jarg1, btAABB jarg1_, long jarg2, btVector3 jarg2_);
-  public final static native long btAABB_min_get(long jarg1, btAABB jarg1_);
-  public final static native void btAABB_max_set(long jarg1, btAABB jarg1_, long jarg2, btVector3 jarg2_);
-  public final static native long btAABB_max_get(long jarg1, btAABB jarg1_);
-  public final static native long new_btAABB__SWIG_0();
-  public final static native long new_btAABB__SWIG_1(Vector3 jarg1, Vector3 jarg2, Vector3 jarg3);
-  public final static native long new_btAABB__SWIG_2(Vector3 jarg1, Vector3 jarg2, Vector3 jarg3, float jarg4);
-  public final static native long new_btAABB__SWIG_3(long jarg1, btAABB jarg1_);
-  public final static native long new_btAABB__SWIG_4(long jarg1, btAABB jarg1_, float jarg2);
-  public final static native void btAABB_invalidate(long jarg1, btAABB jarg1_);
-  public final static native void btAABB_increment_margin(long jarg1, btAABB jarg1_, float jarg2);
-  public final static native void btAABB_copy_with_margin(long jarg1, btAABB jarg1_, long jarg2, btAABB jarg2_, float jarg3);
-  public final static native void btAABB_appy_transform(long jarg1, btAABB jarg1_, Matrix4 jarg2);
-  public final static native void btAABB_appy_transform_trans_cache(long jarg1, btAABB jarg1_, long jarg2, BT_BOX_BOX_TRANSFORM_CACHE jarg2_);
-  public final static native void btAABB_merge(long jarg1, btAABB jarg1_, long jarg2, btAABB jarg2_);
-  public final static native void btAABB_get_center_extend(long jarg1, btAABB jarg1_, Vector3 jarg2, Vector3 jarg3);
-  public final static native void btAABB_find_intersection(long jarg1, btAABB jarg1_, long jarg2, btAABB jarg2_, long jarg3, btAABB jarg3_);
-  public final static native boolean btAABB_has_collision(long jarg1, btAABB jarg1_, long jarg2, btAABB jarg2_);
-  public final static native boolean btAABB_collide_ray(long jarg1, btAABB jarg1_, Vector3 jarg2, Vector3 jarg3);
-  public final static native void btAABB_projection_interval(long jarg1, btAABB jarg1_, Vector3 jarg2, long jarg3, long jarg4);
-  public final static native int btAABB_plane_classify(long jarg1, btAABB jarg1_, long jarg2, btVector4 jarg2_);
-  public final static native boolean btAABB_overlapping_trans_conservative(long jarg1, btAABB jarg1_, long jarg2, btAABB jarg2_, Matrix4 jarg3);
-  public final static native boolean btAABB_overlapping_trans_conservative2(long jarg1, btAABB jarg1_, long jarg2, btAABB jarg2_, long jarg3, BT_BOX_BOX_TRANSFORM_CACHE jarg3_);
-  public final static native boolean btAABB_overlapping_trans_cache(long jarg1, btAABB jarg1_, long jarg2, btAABB jarg2_, long jarg3, BT_BOX_BOX_TRANSFORM_CACHE jarg3_, boolean jarg4);
-  public final static native boolean btAABB_collide_plane(long jarg1, btAABB jarg1_, long jarg2, btVector4 jarg2_);
-  public final static native boolean btAABB_collide_triangle_exact(long jarg1, btAABB jarg1_, Vector3 jarg2, Vector3 jarg3, Vector3 jarg4, long jarg5, btVector4 jarg5_);
-  public final static native void delete_btAABB(long jarg1);
-  public final static native boolean btCompareTransformsEqual(Matrix4 jarg1, Matrix4 jarg2);
-  public final static native float bt_distance_point_plane(long jarg1, btVector4 jarg1_, Vector3 jarg2);
-  public final static native void bt_vec_blend(Vector3 jarg1, Vector3 jarg2, Vector3 jarg3, float jarg4);
-  public final static native void bt_plane_clip_polygon_collect(Vector3 jarg1, Vector3 jarg2, float jarg3, float jarg4, long jarg5, btVector3 jarg5_, long jarg6);
-  public final static native int bt_plane_clip_polygon(long jarg1, btVector4 jarg1_, long jarg2, btVector3 jarg2_, int jarg3, long jarg4, btVector3 jarg4_);
-  public final static native int bt_plane_clip_triangle(long jarg1, btVector4 jarg1_, Vector3 jarg2, Vector3 jarg3, Vector3 jarg4, long jarg5, btVector3 jarg5_);
-  public final static native void bt_edge_plane(Vector3 jarg1, Vector3 jarg2, Vector3 jarg3, long jarg4, btVector4 jarg4_);
-  public final static native void bt_closest_point_on_segment(Vector3 jarg1, Vector3 jarg2, Vector3 jarg3, Vector3 jarg4);
-  public final static native int bt_line_plane_collision(long jarg1, btVector4 jarg1_, Vector3 jarg2, Vector3 jarg3, Vector3 jarg4, long jarg5, float jarg6, float jarg7);
-  public final static native void bt_segment_collision(Vector3 jarg1, Vector3 jarg2, Vector3 jarg3, Vector3 jarg4, Vector3 jarg5, Vector3 jarg6);
-  public final static native void GIM_TRIANGLE_CONTACT_penetration_depth_set(long jarg1, GIM_TRIANGLE_CONTACT jarg1_, float jarg2);
-  public final static native float GIM_TRIANGLE_CONTACT_penetration_depth_get(long jarg1, GIM_TRIANGLE_CONTACT jarg1_);
-  public final static native void GIM_TRIANGLE_CONTACT_point_count_set(long jarg1, GIM_TRIANGLE_CONTACT jarg1_, int jarg2);
-  public final static native int GIM_TRIANGLE_CONTACT_point_count_get(long jarg1, GIM_TRIANGLE_CONTACT jarg1_);
-  public final static native void GIM_TRIANGLE_CONTACT_separating_normal_set(long jarg1, GIM_TRIANGLE_CONTACT jarg1_, long jarg2, btVector4 jarg2_);
-  public final static native long GIM_TRIANGLE_CONTACT_separating_normal_get(long jarg1, GIM_TRIANGLE_CONTACT jarg1_);
-  public final static native void GIM_TRIANGLE_CONTACT_points_set(long jarg1, GIM_TRIANGLE_CONTACT jarg1_, long jarg2, btVector3 jarg2_);
-  public final static native long GIM_TRIANGLE_CONTACT_points_get(long jarg1, GIM_TRIANGLE_CONTACT jarg1_);
-  public final static native void GIM_TRIANGLE_CONTACT_copy_from(long jarg1, GIM_TRIANGLE_CONTACT jarg1_, long jarg2, GIM_TRIANGLE_CONTACT jarg2_);
-  public final static native long new_GIM_TRIANGLE_CONTACT__SWIG_0();
-  public final static native long new_GIM_TRIANGLE_CONTACT__SWIG_1(long jarg1, GIM_TRIANGLE_CONTACT jarg1_);
-  public final static native void GIM_TRIANGLE_CONTACT_merge_points(long jarg1, GIM_TRIANGLE_CONTACT jarg1_, long jarg2, btVector4 jarg2_, float jarg3, long jarg4, btVector3 jarg4_, int jarg5);
-  public final static native void delete_GIM_TRIANGLE_CONTACT(long jarg1);
-  public final static native void btPrimitiveTriangle_vertices_set(long jarg1, btPrimitiveTriangle jarg1_, long jarg2, btVector3 jarg2_);
-  public final static native long btPrimitiveTriangle_vertices_get(long jarg1, btPrimitiveTriangle jarg1_);
-  public final static native void btPrimitiveTriangle_plane_set(long jarg1, btPrimitiveTriangle jarg1_, long jarg2, btVector4 jarg2_);
-  public final static native long btPrimitiveTriangle_plane_get(long jarg1, btPrimitiveTriangle jarg1_);
-  public final static native void btPrimitiveTriangle_margin_set(long jarg1, btPrimitiveTriangle jarg1_, float jarg2);
-  public final static native float btPrimitiveTriangle_margin_get(long jarg1, btPrimitiveTriangle jarg1_);
-  public final static native void btPrimitiveTriangle_dummy_set(long jarg1, btPrimitiveTriangle jarg1_, float jarg2);
-  public final static native float btPrimitiveTriangle_dummy_get(long jarg1, btPrimitiveTriangle jarg1_);
-  public final static native long new_btPrimitiveTriangle();
-  public final static native void btPrimitiveTriangle_buildTriPlane(long jarg1, btPrimitiveTriangle jarg1_);
-  public final static native boolean btPrimitiveTriangle_overlap_test_conservative(long jarg1, btPrimitiveTriangle jarg1_, long jarg2, btPrimitiveTriangle jarg2_);
-  public final static native void btPrimitiveTriangle_get_edge_plane(long jarg1, btPrimitiveTriangle jarg1_, int jarg2, long jarg3, btVector4 jarg3_);
-  public final static native void btPrimitiveTriangle_applyTransform(long jarg1, btPrimitiveTriangle jarg1_, Matrix4 jarg2);
-  public final static native int btPrimitiveTriangle_clip_triangle(long jarg1, btPrimitiveTriangle jarg1_, long jarg2, btPrimitiveTriangle jarg2_, long jarg3, btVector3 jarg3_);
-  public final static native boolean btPrimitiveTriangle_find_triangle_collision_clip_method(long jarg1, btPrimitiveTriangle jarg1_, long jarg2, btPrimitiveTriangle jarg2_, long jarg3, GIM_TRIANGLE_CONTACT jarg3_);
-  public final static native void delete_btPrimitiveTriangle(long jarg1);
-  public final static native long new_btTriangleShapeEx__SWIG_0();
-  public final static native long new_btTriangleShapeEx__SWIG_1(Vector3 jarg1, Vector3 jarg2, Vector3 jarg3);
-  public final static native long new_btTriangleShapeEx__SWIG_2(long jarg1, btTriangleShapeEx jarg1_);
-  public final static native void btTriangleShapeEx_applyTransform(long jarg1, btTriangleShapeEx jarg1_, Matrix4 jarg2);
-  public final static native void btTriangleShapeEx_buildTriPlane(long jarg1, btTriangleShapeEx jarg1_, long jarg2, btVector4 jarg2_);
-  public final static native boolean btTriangleShapeEx_overlap_test_conservative(long jarg1, btTriangleShapeEx jarg1_, long jarg2, btTriangleShapeEx jarg2_);
-  public final static native void delete_btTriangleShapeEx(long jarg1);
-  public final static native void GIM_PAIR_index1_set(long jarg1, GIM_PAIR jarg1_, int jarg2);
-  public final static native int GIM_PAIR_index1_get(long jarg1, GIM_PAIR jarg1_);
-  public final static native void GIM_PAIR_index2_set(long jarg1, GIM_PAIR jarg1_, int jarg2);
-  public final static native int GIM_PAIR_index2_get(long jarg1, GIM_PAIR jarg1_);
-  public final static native long new_GIM_PAIR__SWIG_0();
-  public final static native long new_GIM_PAIR__SWIG_1(long jarg1, GIM_PAIR jarg1_);
-  public final static native long new_GIM_PAIR__SWIG_2(int jarg1, int jarg2);
-  public final static native void delete_GIM_PAIR(long jarg1);
-  public final static native long new_btPairSet();
-  public final static native void btPairSet_push_pair(long jarg1, btPairSet jarg1_, int jarg2, int jarg3);
-  public final static native void btPairSet_push_pair_inv(long jarg1, btPairSet jarg1_, int jarg2, int jarg3);
-  public final static native void delete_btPairSet(long jarg1);
-  public final static native void GIM_BVH_DATA_bound_set(long jarg1, GIM_BVH_DATA jarg1_, long jarg2, btAABB jarg2_);
-  public final static native long GIM_BVH_DATA_bound_get(long jarg1, GIM_BVH_DATA jarg1_);
-  public final static native void GIM_BVH_DATA_data_set(long jarg1, GIM_BVH_DATA jarg1_, int jarg2);
-  public final static native int GIM_BVH_DATA_data_get(long jarg1, GIM_BVH_DATA jarg1_);
-  public final static native long new_GIM_BVH_DATA();
-  public final static native void delete_GIM_BVH_DATA(long jarg1);
-  public final static native void GIM_BVH_TREE_NODE_bound_set(long jarg1, GIM_BVH_TREE_NODE jarg1_, long jarg2, btAABB jarg2_);
-  public final static native long GIM_BVH_TREE_NODE_bound_get(long jarg1, GIM_BVH_TREE_NODE jarg1_);
-  public final static native long new_GIM_BVH_TREE_NODE();
-  public final static native boolean GIM_BVH_TREE_NODE_isLeafNode(long jarg1, GIM_BVH_TREE_NODE jarg1_);
-  public final static native int GIM_BVH_TREE_NODE_getEscapeIndex(long jarg1, GIM_BVH_TREE_NODE jarg1_);
-  public final static native void GIM_BVH_TREE_NODE_setEscapeIndex(long jarg1, GIM_BVH_TREE_NODE jarg1_, int jarg2);
-  public final static native int GIM_BVH_TREE_NODE_getDataIndex(long jarg1, GIM_BVH_TREE_NODE jarg1_);
-  public final static native void GIM_BVH_TREE_NODE_setDataIndex(long jarg1, GIM_BVH_TREE_NODE jarg1_, int jarg2);
-  public final static native void delete_GIM_BVH_TREE_NODE(long jarg1);
-  public final static native long new_GIM_BVH_DATA_ARRAY();
-  public final static native void delete_GIM_BVH_DATA_ARRAY(long jarg1);
-  public final static native long new_GIM_BVH_TREE_NODE_ARRAY();
-  public final static native void delete_GIM_BVH_TREE_NODE_ARRAY(long jarg1);
-  public final static native long new_btBvhTree();
-  public final static native void btBvhTree_build_tree(long jarg1, btBvhTree jarg1_, long jarg2, GIM_BVH_DATA_ARRAY jarg2_);
-  public final static native void btBvhTree_clearNodes(long jarg1, btBvhTree jarg1_);
-  public final static native int btBvhTree_getNodeCount(long jarg1, btBvhTree jarg1_);
-  public final static native boolean btBvhTree_isLeafNode(long jarg1, btBvhTree jarg1_, int jarg2);
-  public final static native int btBvhTree_getNodeData(long jarg1, btBvhTree jarg1_, int jarg2);
-  public final static native void btBvhTree_getNodeBound(long jarg1, btBvhTree jarg1_, int jarg2, long jarg3, btAABB jarg3_);
-  public final static native void btBvhTree_setNodeBound(long jarg1, btBvhTree jarg1_, int jarg2, long jarg3, btAABB jarg3_);
-  public final static native int btBvhTree_getLeftNode(long jarg1, btBvhTree jarg1_, int jarg2);
-  public final static native int btBvhTree_getRightNode(long jarg1, btBvhTree jarg1_, int jarg2);
-  public final static native int btBvhTree_getEscapeNodeIndex(long jarg1, btBvhTree jarg1_, int jarg2);
-  public final static native long btBvhTree_get_node_pointer__SWIG_0(long jarg1, btBvhTree jarg1_, int jarg2);
-  public final static native long btBvhTree_get_node_pointer__SWIG_1(long jarg1, btBvhTree jarg1_);
-  public final static native void delete_btBvhTree(long jarg1);
-  public final static native void delete_btPrimitiveManagerBase(long jarg1);
-  public final static native boolean btPrimitiveManagerBase_is_trimesh(long jarg1, btPrimitiveManagerBase jarg1_);
-  public final static native int btPrimitiveManagerBase_get_primitive_count(long jarg1, btPrimitiveManagerBase jarg1_);
-  public final static native void btPrimitiveManagerBase_get_primitive_box(long jarg1, btPrimitiveManagerBase jarg1_, int jarg2, long jarg3, btAABB jarg3_);
-  public final static native void btPrimitiveManagerBase_get_primitive_triangle(long jarg1, btPrimitiveManagerBase jarg1_, int jarg2, long jarg3, btPrimitiveTriangle jarg3_);
-  public final static native long new_btGImpactBvh__SWIG_0();
-  public final static native long new_btGImpactBvh__SWIG_1(long jarg1, btPrimitiveManagerBase jarg1_);
-  public final static native long btGImpactBvh_getGlobalBox(long jarg1, btGImpactBvh jarg1_);
-  public final static native void btGImpactBvh_setPrimitiveManager(long jarg1, btGImpactBvh jarg1_, long jarg2, btPrimitiveManagerBase jarg2_);
-  public final static native long btGImpactBvh_getPrimitiveManager(long jarg1, btGImpactBvh jarg1_);
-  public final static native void btGImpactBvh_update(long jarg1, btGImpactBvh jarg1_);
-  public final static native void btGImpactBvh_buildSet(long jarg1, btGImpactBvh jarg1_);
-  public final static native boolean btGImpactBvh_boxQuery(long jarg1, btGImpactBvh jarg1_, long jarg2, btAABB jarg2_, long jarg3);
-  public final static native boolean btGImpactBvh_boxQueryTrans(long jarg1, btGImpactBvh jarg1_, long jarg2, btAABB jarg2_, Matrix4 jarg3, long jarg4);
-  public final static native boolean btGImpactBvh_rayQuery(long jarg1, btGImpactBvh jarg1_, Vector3 jarg2, Vector3 jarg3, long jarg4);
-  public final static native boolean btGImpactBvh_hasHierarchy(long jarg1, btGImpactBvh jarg1_);
-  public final static native boolean btGImpactBvh_isTrimesh(long jarg1, btGImpactBvh jarg1_);
-  public final static native int btGImpactBvh_getNodeCount(long jarg1, btGImpactBvh jarg1_);
-  public final static native boolean btGImpactBvh_isLeafNode(long jarg1, btGImpactBvh jarg1_, int jarg2);
-  public final static native int btGImpactBvh_getNodeData(long jarg1, btGImpactBvh jarg1_, int jarg2);
-  public final static native void btGImpactBvh_getNodeBound(long jarg1, btGImpactBvh jarg1_, int jarg2, long jarg3, btAABB jarg3_);
-  public final static native void btGImpactBvh_setNodeBound(long jarg1, btGImpactBvh jarg1_, int jarg2, long jarg3, btAABB jarg3_);
-  public final static native int btGImpactBvh_getLeftNode(long jarg1, btGImpactBvh jarg1_, int jarg2);
-  public final static native int btGImpactBvh_getRightNode(long jarg1, btGImpactBvh jarg1_, int jarg2);
-  public final static native int btGImpactBvh_getEscapeNodeIndex(long jarg1, btGImpactBvh jarg1_, int jarg2);
-  public final static native void btGImpactBvh_getNodeTriangle(long jarg1, btGImpactBvh jarg1_, int jarg2, long jarg3, btPrimitiveTriangle jarg3_);
-  public final static native long btGImpactBvh_get_node_pointer__SWIG_0(long jarg1, btGImpactBvh jarg1_, int jarg2);
-  public final static native long btGImpactBvh_get_node_pointer__SWIG_1(long jarg1, btGImpactBvh jarg1_);
-  public final static native void btGImpactBvh_find_collision(long jarg1, btGImpactBvh jarg1_, Matrix4 jarg2, long jarg3, btGImpactBvh jarg3_, Matrix4 jarg4, long jarg5, btPairSet jarg5_);
-  public final static native void delete_btGImpactBvh(long jarg1);
-  public final static native void BT_QUANTIZED_BVH_NODE_quantizedAabbMin_set(long jarg1, BT_QUANTIZED_BVH_NODE jarg1_, int[] jarg2);
-  public final static native int[] BT_QUANTIZED_BVH_NODE_quantizedAabbMin_get(long jarg1, BT_QUANTIZED_BVH_NODE jarg1_);
-  public final static native void BT_QUANTIZED_BVH_NODE_quantizedAabbMax_set(long jarg1, BT_QUANTIZED_BVH_NODE jarg1_, int[] jarg2);
-  public final static native int[] BT_QUANTIZED_BVH_NODE_quantizedAabbMax_get(long jarg1, BT_QUANTIZED_BVH_NODE jarg1_);
-  public final static native void BT_QUANTIZED_BVH_NODE_escapeIndexOrDataIndex_set(long jarg1, BT_QUANTIZED_BVH_NODE jarg1_, int jarg2);
-  public final static native int BT_QUANTIZED_BVH_NODE_escapeIndexOrDataIndex_get(long jarg1, BT_QUANTIZED_BVH_NODE jarg1_);
-  public final static native long new_BT_QUANTIZED_BVH_NODE();
-  public final static native boolean BT_QUANTIZED_BVH_NODE_isLeafNode(long jarg1, BT_QUANTIZED_BVH_NODE jarg1_);
-  public final static native int BT_QUANTIZED_BVH_NODE_getEscapeIndex(long jarg1, BT_QUANTIZED_BVH_NODE jarg1_);
-  public final static native void BT_QUANTIZED_BVH_NODE_setEscapeIndex(long jarg1, BT_QUANTIZED_BVH_NODE jarg1_, int jarg2);
-  public final static native int BT_QUANTIZED_BVH_NODE_getDataIndex(long jarg1, BT_QUANTIZED_BVH_NODE jarg1_);
-  public final static native void BT_QUANTIZED_BVH_NODE_setDataIndex(long jarg1, BT_QUANTIZED_BVH_NODE jarg1_, int jarg2);
-  public final static native boolean BT_QUANTIZED_BVH_NODE_testQuantizedBoxOverlapp(long jarg1, BT_QUANTIZED_BVH_NODE jarg1_, java.nio.IntBuffer jarg2, java.nio.IntBuffer jarg3);
-  public final static native void delete_BT_QUANTIZED_BVH_NODE(long jarg1);
-  public final static native long new_GIM_QUANTIZED_BVH_NODE_ARRAY();
-  public final static native void delete_GIM_QUANTIZED_BVH_NODE_ARRAY(long jarg1);
-  public final static native long new_btQuantizedBvhTree();
-  public final static native void btQuantizedBvhTree_build_tree(long jarg1, btQuantizedBvhTree jarg1_, long jarg2, GIM_BVH_DATA_ARRAY jarg2_);
-  public final static native void btQuantizedBvhTree_quantizePoint(long jarg1, btQuantizedBvhTree jarg1_, java.nio.IntBuffer jarg2, Vector3 jarg3);
-  public final static native boolean btQuantizedBvhTree_testQuantizedBoxOverlapp(long jarg1, btQuantizedBvhTree jarg1_, int jarg2, java.nio.IntBuffer jarg3, java.nio.IntBuffer jarg4);
-  public final static native void btQuantizedBvhTree_clearNodes(long jarg1, btQuantizedBvhTree jarg1_);
-  public final static native int btQuantizedBvhTree_getNodeCount(long jarg1, btQuantizedBvhTree jarg1_);
-  public final static native boolean btQuantizedBvhTree_isLeafNode(long jarg1, btQuantizedBvhTree jarg1_, int jarg2);
-  public final static native int btQuantizedBvhTree_getNodeData(long jarg1, btQuantizedBvhTree jarg1_, int jarg2);
-  public final static native void btQuantizedBvhTree_getNodeBound(long jarg1, btQuantizedBvhTree jarg1_, int jarg2, long jarg3, btAABB jarg3_);
-  public final static native void btQuantizedBvhTree_setNodeBound(long jarg1, btQuantizedBvhTree jarg1_, int jarg2, long jarg3, btAABB jarg3_);
-  public final static native int btQuantizedBvhTree_getLeftNode(long jarg1, btQuantizedBvhTree jarg1_, int jarg2);
-  public final static native int btQuantizedBvhTree_getRightNode(long jarg1, btQuantizedBvhTree jarg1_, int jarg2);
-  public final static native int btQuantizedBvhTree_getEscapeNodeIndex(long jarg1, btQuantizedBvhTree jarg1_, int jarg2);
-  public final static native long btQuantizedBvhTree_get_node_pointer__SWIG_0(long jarg1, btQuantizedBvhTree jarg1_, int jarg2);
-  public final static native long btQuantizedBvhTree_get_node_pointer__SWIG_1(long jarg1, btQuantizedBvhTree jarg1_);
-  public final static native void delete_btQuantizedBvhTree(long jarg1);
-  public final static native long new_btGImpactQuantizedBvh__SWIG_0();
-  public final static native long new_btGImpactQuantizedBvh__SWIG_1(long jarg1, btPrimitiveManagerBase jarg1_);
-  public final static native long btGImpactQuantizedBvh_getGlobalBox(long jarg1, btGImpactQuantizedBvh jarg1_);
-  public final static native void btGImpactQuantizedBvh_setPrimitiveManager(long jarg1, btGImpactQuantizedBvh jarg1_, long jarg2, btPrimitiveManagerBase jarg2_);
-  public final static native long btGImpactQuantizedBvh_getPrimitiveManager(long jarg1, btGImpactQuantizedBvh jarg1_);
-  public final static native void btGImpactQuantizedBvh_update(long jarg1, btGImpactQuantizedBvh jarg1_);
-  public final static native void btGImpactQuantizedBvh_buildSet(long jarg1, btGImpactQuantizedBvh jarg1_);
-  public final static native boolean btGImpactQuantizedBvh_boxQuery(long jarg1, btGImpactQuantizedBvh jarg1_, long jarg2, btAABB jarg2_, long jarg3);
-  public final static native boolean btGImpactQuantizedBvh_boxQueryTrans(long jarg1, btGImpactQuantizedBvh jarg1_, long jarg2, btAABB jarg2_, Matrix4 jarg3, long jarg4);
-  public final static native boolean btGImpactQuantizedBvh_rayQuery(long jarg1, btGImpactQuantizedBvh jarg1_, Vector3 jarg2, Vector3 jarg3, long jarg4);
-  public final static native boolean btGImpactQuantizedBvh_hasHierarchy(long jarg1, btGImpactQuantizedBvh jarg1_);
-  public final static native boolean btGImpactQuantizedBvh_isTrimesh(long jarg1, btGImpactQuantizedBvh jarg1_);
-  public final static native int btGImpactQuantizedBvh_getNodeCount(long jarg1, btGImpactQuantizedBvh jarg1_);
-  public final static native boolean btGImpactQuantizedBvh_isLeafNode(long jarg1, btGImpactQuantizedBvh jarg1_, int jarg2);
-  public final static native int btGImpactQuantizedBvh_getNodeData(long jarg1, btGImpactQuantizedBvh jarg1_, int jarg2);
-  public final static native void btGImpactQuantizedBvh_getNodeBound(long jarg1, btGImpactQuantizedBvh jarg1_, int jarg2, long jarg3, btAABB jarg3_);
-  public final static native void btGImpactQuantizedBvh_setNodeBound(long jarg1, btGImpactQuantizedBvh jarg1_, int jarg2, long jarg3, btAABB jarg3_);
-  public final static native int btGImpactQuantizedBvh_getLeftNode(long jarg1, btGImpactQuantizedBvh jarg1_, int jarg2);
-  public final static native int btGImpactQuantizedBvh_getRightNode(long jarg1, btGImpactQuantizedBvh jarg1_, int jarg2);
-  public final static native int btGImpactQuantizedBvh_getEscapeNodeIndex(long jarg1, btGImpactQuantizedBvh jarg1_, int jarg2);
-  public final static native void btGImpactQuantizedBvh_getNodeTriangle(long jarg1, btGImpactQuantizedBvh jarg1_, int jarg2, long jarg3, btPrimitiveTriangle jarg3_);
-  public final static native long btGImpactQuantizedBvh_get_node_pointer__SWIG_0(long jarg1, btGImpactQuantizedBvh jarg1_, int jarg2);
-  public final static native long btGImpactQuantizedBvh_get_node_pointer__SWIG_1(long jarg1, btGImpactQuantizedBvh jarg1_);
-  public final static native void btGImpactQuantizedBvh_find_collision(long jarg1, btGImpactQuantizedBvh jarg1_, Matrix4 jarg2, long jarg3, btGImpactQuantizedBvh jarg3_, Matrix4 jarg4, long jarg5, btPairSet jarg5_);
-  public final static native void delete_btGImpactQuantizedBvh(long jarg1);
-  public final static native long new_btTetrahedronShapeEx();
-  public final static native void btTetrahedronShapeEx_setVertices(long jarg1, btTetrahedronShapeEx jarg1_, Vector3 jarg2, Vector3 jarg3, Vector3 jarg4, Vector3 jarg5);
-  public final static native void delete_btTetrahedronShapeEx(long jarg1);
-  public final static native void btGImpactShapeInterface_updateBound(long jarg1, btGImpactShapeInterface jarg1_);
-  public final static native void btGImpactShapeInterface_postUpdate(long jarg1, btGImpactShapeInterface jarg1_);
-  public final static native long btGImpactShapeInterface_getLocalBox(long jarg1, btGImpactShapeInterface jarg1_);
-  public final static native int btGImpactShapeInterface_getShapeType(long jarg1, btGImpactShapeInterface jarg1_);
-  public final static native int btGImpactShapeInterface_getGImpactShapeType(long jarg1, btGImpactShapeInterface jarg1_);
-  public final static native long btGImpactShapeInterface_getBoxSet(long jarg1, btGImpactShapeInterface jarg1_);
-  public final static native boolean btGImpactShapeInterface_hasBoxSet(long jarg1, btGImpactShapeInterface jarg1_);
-  public final static native long btGImpactShapeInterface_getPrimitiveManager(long jarg1, btGImpactShapeInterface jarg1_);
-  public final static native int btGImpactShapeInterface_getNumChildShapes(long jarg1, btGImpactShapeInterface jarg1_);
-  public final static native boolean btGImpactShapeInterface_childrenHasTransform(long jarg1, btGImpactShapeInterface jarg1_);
-  public final static native boolean btGImpactShapeInterface_needsRetrieveTriangles(long jarg1, btGImpactShapeInterface jarg1_);
-  public final static native boolean btGImpactShapeInterface_needsRetrieveTetrahedrons(long jarg1, btGImpactShapeInterface jarg1_);
-  public final static native void btGImpactShapeInterface_getBulletTriangle(long jarg1, btGImpactShapeInterface jarg1_, int jarg2, long jarg3, btTriangleShapeEx jarg3_);
-  public final static native void btGImpactShapeInterface_getBulletTetrahedron(long jarg1, btGImpactShapeInterface jarg1_, int jarg2, long jarg3, btTetrahedronShapeEx jarg3_);
-  public final static native void btGImpactShapeInterface_lockChildShapes(long jarg1, btGImpactShapeInterface jarg1_);
-  public final static native void btGImpactShapeInterface_unlockChildShapes(long jarg1, btGImpactShapeInterface jarg1_);
-  public final static native void btGImpactShapeInterface_getPrimitiveTriangle(long jarg1, btGImpactShapeInterface jarg1_, int jarg2, long jarg3, btPrimitiveTriangle jarg3_);
-  public final static native void btGImpactShapeInterface_getChildAabb(long jarg1, btGImpactShapeInterface jarg1_, int jarg2, Matrix4 jarg3, Vector3 jarg4, Vector3 jarg5);
-  public final static native long btGImpactShapeInterface_getChildShape__SWIG_0(long jarg1, btGImpactShapeInterface jarg1_, int jarg2);
-  public final static native Matrix4 btGImpactShapeInterface_getChildTransform(long jarg1, btGImpactShapeInterface jarg1_, int jarg2);
-  public final static native void btGImpactShapeInterface_setChildTransform(long jarg1, btGImpactShapeInterface jarg1_, int jarg2, Matrix4 jarg3);
-  public final static native void btGImpactShapeInterface_rayTest(long jarg1, btGImpactShapeInterface jarg1_, Vector3 jarg2, Vector3 jarg3, long jarg4, RayResultCallback jarg4_);
-  public final static native void btGImpactShapeInterface_processAllTrianglesRay(long jarg1, btGImpactShapeInterface jarg1_, long jarg2, btTriangleCallback jarg2_, Vector3 jarg3, Vector3 jarg4);
-  public final static native void delete_btGImpactShapeInterface(long jarg1);
-  public final static native void delete_btGImpactCompoundShape_CompoundPrimitiveManager(long jarg1);
-  public final static native void btGImpactCompoundShape_CompoundPrimitiveManager_compoundShape_set(long jarg1, btGImpactCompoundShape.CompoundPrimitiveManager jarg1_, long jarg2, btGImpactCompoundShape jarg2_);
-  public final static native long btGImpactCompoundShape_CompoundPrimitiveManager_compoundShape_get(long jarg1, btGImpactCompoundShape.CompoundPrimitiveManager jarg1_);
-  public final static native long new_btGImpactCompoundShape_CompoundPrimitiveManager__SWIG_0(long jarg1, btGImpactCompoundShape.CompoundPrimitiveManager jarg1_);
-  public final static native long new_btGImpactCompoundShape_CompoundPrimitiveManager__SWIG_1(long jarg1, btGImpactCompoundShape jarg1_);
-  public final static native long new_btGImpactCompoundShape_CompoundPrimitiveManager__SWIG_2();
-  public final static native long new_btGImpactCompoundShape__SWIG_0(boolean jarg1);
-  public final static native long new_btGImpactCompoundShape__SWIG_1();
-  public final static native void delete_btGImpactCompoundShape(long jarg1);
-  public final static native long btGImpactCompoundShape_getCompoundPrimitiveManager(long jarg1, btGImpactCompoundShape jarg1_);
-  public final static native void btGImpactCompoundShape_addChildShape__SWIG_0(long jarg1, btGImpactCompoundShape jarg1_, Matrix4 jarg2, long jarg3, btCollisionShape jarg3_);
-  public final static native void btGImpactCompoundShape_addChildShape__SWIG_1(long jarg1, btGImpactCompoundShape jarg1_, long jarg2, btCollisionShape jarg2_);
-  public final static native long btGImpactCompoundShape_getChildShape__SWIG_0(long jarg1, btGImpactCompoundShape jarg1_, int jarg2);
-  public final static native void btGImpactMeshShapePart_TrimeshPrimitiveManager_margin_set(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_, float jarg2);
-  public final static native float btGImpactMeshShapePart_TrimeshPrimitiveManager_margin_get(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_);
-  public final static native void btGImpactMeshShapePart_TrimeshPrimitiveManager_meshInterface_set(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_, long jarg2, btStridingMeshInterface jarg2_);
-  public final static native long btGImpactMeshShapePart_TrimeshPrimitiveManager_meshInterface_get(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_);
-  public final static native void btGImpactMeshShapePart_TrimeshPrimitiveManager_scale_set(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_, long jarg2, btVector3 jarg2_);
-  public final static native long btGImpactMeshShapePart_TrimeshPrimitiveManager_scale_get(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_);
-  public final static native void btGImpactMeshShapePart_TrimeshPrimitiveManager_part_set(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_, int jarg2);
-  public final static native int btGImpactMeshShapePart_TrimeshPrimitiveManager_part_get(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_);
-  public final static native void btGImpactMeshShapePart_TrimeshPrimitiveManager_lock_count_set(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_, int jarg2);
-  public final static native int btGImpactMeshShapePart_TrimeshPrimitiveManager_lock_count_get(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_);
-  public final static native void btGImpactMeshShapePart_TrimeshPrimitiveManager_vertexbase_set(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_, java.nio.ByteBuffer jarg2);
-  public final static native java.nio.ByteBuffer btGImpactMeshShapePart_TrimeshPrimitiveManager_vertexbase_get(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_);
-  public final static native void btGImpactMeshShapePart_TrimeshPrimitiveManager_numverts_set(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_, int jarg2);
-  public final static native int btGImpactMeshShapePart_TrimeshPrimitiveManager_numverts_get(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_);
-  public final static native void btGImpactMeshShapePart_TrimeshPrimitiveManager_type_set(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_, int jarg2);
-  public final static native int btGImpactMeshShapePart_TrimeshPrimitiveManager_type_get(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_);
-  public final static native void btGImpactMeshShapePart_TrimeshPrimitiveManager_stride_set(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_, int jarg2);
-  public final static native int btGImpactMeshShapePart_TrimeshPrimitiveManager_stride_get(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_);
-  public final static native void btGImpactMeshShapePart_TrimeshPrimitiveManager_indexbase_set(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_, java.nio.ByteBuffer jarg2);
-  public final static native java.nio.ByteBuffer btGImpactMeshShapePart_TrimeshPrimitiveManager_indexbase_get(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_);
-  public final static native void btGImpactMeshShapePart_TrimeshPrimitiveManager_indexstride_set(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_, int jarg2);
-  public final static native int btGImpactMeshShapePart_TrimeshPrimitiveManager_indexstride_get(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_);
-  public final static native void btGImpactMeshShapePart_TrimeshPrimitiveManager_numfaces_set(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_, int jarg2);
-  public final static native int btGImpactMeshShapePart_TrimeshPrimitiveManager_numfaces_get(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_);
-  public final static native void btGImpactMeshShapePart_TrimeshPrimitiveManager_indicestype_set(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_, int jarg2);
-  public final static native int btGImpactMeshShapePart_TrimeshPrimitiveManager_indicestype_get(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_);
-  public final static native long new_btGImpactMeshShapePart_TrimeshPrimitiveManager__SWIG_0();
-  public final static native long new_btGImpactMeshShapePart_TrimeshPrimitiveManager__SWIG_1(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_);
-  public final static native long new_btGImpactMeshShapePart_TrimeshPrimitiveManager__SWIG_2(long jarg1, btStridingMeshInterface jarg1_, int jarg2);
-  public final static native void delete_btGImpactMeshShapePart_TrimeshPrimitiveManager(long jarg1);
-  public final static native void btGImpactMeshShapePart_TrimeshPrimitiveManager_lock(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_);
-  public final static native void btGImpactMeshShapePart_TrimeshPrimitiveManager_unlock(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_);
-  public final static native int btGImpactMeshShapePart_TrimeshPrimitiveManager_get_vertex_count(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_);
-  public final static native void btGImpactMeshShapePart_TrimeshPrimitiveManager_get_indices(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_, int jarg2, long jarg3, long jarg4, long jarg5);
-  public final static native void btGImpactMeshShapePart_TrimeshPrimitiveManager_get_vertex(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_, long jarg2, Vector3 jarg3);
-  public final static native void btGImpactMeshShapePart_TrimeshPrimitiveManager_get_bullet_triangle(long jarg1, btGImpactMeshShapePart.TrimeshPrimitiveManager jarg1_, int jarg2, long jarg3, btTriangleShapeEx jarg3_);
-  public final static native long new_btGImpactMeshShapePart__SWIG_0();
-  public final static native long new_btGImpactMeshShapePart__SWIG_1(long jarg1, btStridingMeshInterface jarg1_, int jarg2);
-  public final static native void delete_btGImpactMeshShapePart(long jarg1);
-  public final static native long btGImpactMeshShapePart_getChildShape__SWIG_0(long jarg1, btGImpactMeshShapePart jarg1_, int jarg2);
-  public final static native long btGImpactMeshShapePart_getTrimeshPrimitiveManager(long jarg1, btGImpactMeshShapePart jarg1_);
-  public final static native int btGImpactMeshShapePart_getVertexCount(long jarg1, btGImpactMeshShapePart jarg1_);
-  public final static native void btGImpactMeshShapePart_getVertex(long jarg1, btGImpactMeshShapePart jarg1_, int jarg2, Vector3 jarg3);
-  public final static native int btGImpactMeshShapePart_getPart(long jarg1, btGImpactMeshShapePart jarg1_);
-  public final static native long new_btGImpactMeshShape(long jarg1, btStridingMeshInterface jarg1_);
-  public final static native void delete_btGImpactMeshShape(long jarg1);
-  public final static native long btGImpactMeshShape_getMeshInterface__SWIG_0(long jarg1, btGImpactMeshShape jarg1_);
-  public final static native int btGImpactMeshShape_getMeshPartCount(long jarg1, btGImpactMeshShape jarg1_);
-  public final static native long btGImpactMeshShape_getMeshPart__SWIG_0(long jarg1, btGImpactMeshShape jarg1_, int jarg2);
-  public final static native long btGImpactMeshShape_getChildShape__SWIG_0(long jarg1, btGImpactMeshShape jarg1_, int jarg2);
-  public final static native void btGImpactMeshShapeData_collisionShapeData_set(long jarg1, btGImpactMeshShapeData jarg1_, long jarg2, btCollisionShapeData jarg2_);
-  public final static native long btGImpactMeshShapeData_collisionShapeData_get(long jarg1, btGImpactMeshShapeData jarg1_);
-  public final static native void btGImpactMeshShapeData_meshInterface_set(long jarg1, btGImpactMeshShapeData jarg1_, long jarg2, btStridingMeshInterfaceData jarg2_);
-  public final static native long btGImpactMeshShapeData_meshInterface_get(long jarg1, btGImpactMeshShapeData jarg1_);
-  public final static native void btGImpactMeshShapeData_localScaling_set(long jarg1, btGImpactMeshShapeData jarg1_, long jarg2, btVector3FloatData jarg2_);
-  public final static native long btGImpactMeshShapeData_localScaling_get(long jarg1, btGImpactMeshShapeData jarg1_);
-  public final static native void btGImpactMeshShapeData_collisionMargin_set(long jarg1, btGImpactMeshShapeData jarg1_, float jarg2);
-  public final static native float btGImpactMeshShapeData_collisionMargin_get(long jarg1, btGImpactMeshShapeData jarg1_);
-  public final static native void btGImpactMeshShapeData_gimpactSubType_set(long jarg1, btGImpactMeshShapeData jarg1_, int jarg2);
-  public final static native int btGImpactMeshShapeData_gimpactSubType_get(long jarg1, btGImpactMeshShapeData jarg1_);
-  public final static native long new_btGImpactMeshShapeData();
-  public final static native void delete_btGImpactMeshShapeData(long jarg1);
-  public final static native void GIM_CONTACT_point_set(long jarg1, GIM_CONTACT jarg1_, long jarg2, btVector3 jarg2_);
-  public final static native long GIM_CONTACT_point_get(long jarg1, GIM_CONTACT jarg1_);
-  public final static native void GIM_CONTACT_normal_set(long jarg1, GIM_CONTACT jarg1_, long jarg2, btVector3 jarg2_);
-  public final static native long GIM_CONTACT_normal_get(long jarg1, GIM_CONTACT jarg1_);
-  public final static native void GIM_CONTACT_depth_set(long jarg1, GIM_CONTACT jarg1_, float jarg2);
-  public final static native float GIM_CONTACT_depth_get(long jarg1, GIM_CONTACT jarg1_);
-  public final static native void GIM_CONTACT_distance_set(long jarg1, GIM_CONTACT jarg1_, float jarg2);
-  public final static native float GIM_CONTACT_distance_get(long jarg1, GIM_CONTACT jarg1_);
-  public final static native void GIM_CONTACT_feature1_set(long jarg1, GIM_CONTACT jarg1_, int jarg2);
-  public final static native int GIM_CONTACT_feature1_get(long jarg1, GIM_CONTACT jarg1_);
-  public final static native void GIM_CONTACT_feature2_set(long jarg1, GIM_CONTACT jarg1_, int jarg2);
-  public final static native int GIM_CONTACT_feature2_get(long jarg1, GIM_CONTACT jarg1_);
-  public final static native long new_GIM_CONTACT__SWIG_0();
-  public final static native long new_GIM_CONTACT__SWIG_1(long jarg1, GIM_CONTACT jarg1_);
-  public final static native long new_GIM_CONTACT__SWIG_2(Vector3 jarg1, Vector3 jarg2, float jarg3, int jarg4, int jarg5);
-  public final static native long GIM_CONTACT_calc_key_contact(long jarg1, GIM_CONTACT jarg1_);
-  public final static native void GIM_CONTACT_interpolate_normals(long jarg1, GIM_CONTACT jarg1_, long jarg2, btVector3 jarg2_, int jarg3);
-  public final static native void delete_GIM_CONTACT(long jarg1);
-  public final static native long new_btContactArray();
-  public final static native void btContactArray_push_contact(long jarg1, btContactArray jarg1_, Vector3 jarg2, Vector3 jarg3, float jarg4, int jarg5, int jarg6);
-  public final static native void btContactArray_push_triangle_contacts(long jarg1, btContactArray jarg1_, long jarg2, GIM_TRIANGLE_CONTACT jarg2_, int jarg3, int jarg4);
-  public final static native void btContactArray_merge_contacts__SWIG_0(long jarg1, btContactArray jarg1_, long jarg2, btContactArray jarg2_, boolean jarg3);
-  public final static native void btContactArray_merge_contacts__SWIG_1(long jarg1, btContactArray jarg1_, long jarg2, btContactArray jarg2_);
-  public final static native void btContactArray_merge_contacts_unique(long jarg1, btContactArray jarg1_, long jarg2, btContactArray jarg2_);
-  public final static native void delete_btContactArray(long jarg1);
-  public final static native void btGenericMemoryPool_pool_set(long jarg1, btGenericMemoryPool jarg1_, java.nio.ByteBuffer jarg2);
-  public final static native java.nio.ByteBuffer btGenericMemoryPool_pool_get(long jarg1, btGenericMemoryPool jarg1_);
-  public final static native void btGenericMemoryPool_free_nodes_set(long jarg1, btGenericMemoryPool jarg1_, long jarg2);
-  public final static native long btGenericMemoryPool_free_nodes_get(long jarg1, btGenericMemoryPool jarg1_);
-  public final static native void btGenericMemoryPool_allocated_sizes_set(long jarg1, btGenericMemoryPool jarg1_, long jarg2);
-  public final static native long btGenericMemoryPool_allocated_sizes_get(long jarg1, btGenericMemoryPool jarg1_);
-  public final static native void btGenericMemoryPool_allocated_count_set(long jarg1, btGenericMemoryPool jarg1_, long jarg2);
-  public final static native long btGenericMemoryPool_allocated_count_get(long jarg1, btGenericMemoryPool jarg1_);
-  public final static native void btGenericMemoryPool_free_nodes_count_set(long jarg1, btGenericMemoryPool jarg1_, long jarg2);
-  public final static native long btGenericMemoryPool_free_nodes_count_get(long jarg1, btGenericMemoryPool jarg1_);
-  public final static native void btGenericMemoryPool_init_pool(long jarg1, btGenericMemoryPool jarg1_, long jarg2, long jarg3);
-  public final static native void btGenericMemoryPool_end_pool(long jarg1, btGenericMemoryPool jarg1_);
-  public final static native long new_btGenericMemoryPool(long jarg1, long jarg2);
-  public final static native void delete_btGenericMemoryPool(long jarg1);
-  public final static native long btGenericMemoryPool_get_pool_capacity(long jarg1, btGenericMemoryPool jarg1_);
-  public final static native long btGenericMemoryPool_gem_element_size(long jarg1, btGenericMemoryPool jarg1_);
-  public final static native long btGenericMemoryPool_get_max_element_count(long jarg1, btGenericMemoryPool jarg1_);
-  public final static native long btGenericMemoryPool_get_allocated_count(long jarg1, btGenericMemoryPool jarg1_);
-  public final static native long btGenericMemoryPool_get_free_positions_count(long jarg1, btGenericMemoryPool jarg1_);
-  public final static native long btGenericMemoryPool_get_element_data(long jarg1, btGenericMemoryPool jarg1_, long jarg2);
-  public final static native long btGenericMemoryPool_allocate(long jarg1, btGenericMemoryPool jarg1_, long jarg2);
-  public final static native boolean btGenericMemoryPool_freeMemory(long jarg1, btGenericMemoryPool jarg1_, long jarg2);
-  public final static native void btGenericPoolAllocator_pools_set(long jarg1, btGenericPoolAllocator jarg1_, long jarg2);
-  public final static native long btGenericPoolAllocator_pools_get(long jarg1, btGenericPoolAllocator jarg1_);
-  public final static native void btGenericPoolAllocator_pool_count_set(long jarg1, btGenericPoolAllocator jarg1_, long jarg2);
-  public final static native long btGenericPoolAllocator_pool_count_get(long jarg1, btGenericPoolAllocator jarg1_);
-  public final static native long btGenericPoolAllocator_get_pool_capacity(long jarg1, btGenericPoolAllocator jarg1_);
-  public final static native long new_btGenericPoolAllocator(long jarg1, long jarg2);
-  public final static native void delete_btGenericPoolAllocator(long jarg1);
-  public final static native long btGenericPoolAllocator_allocate(long jarg1, btGenericPoolAllocator jarg1_, long jarg2);
-  public final static native boolean btGenericPoolAllocator_freeMemory(long jarg1, btGenericPoolAllocator jarg1_, long jarg2);
-  public final static native long btPoolAlloc(long jarg1);
-  public final static native long btPoolRealloc(long jarg1, long jarg2, long jarg3);
-  public final static native void btPoolFree(long jarg1);
-  public final static native long new_btGImpactCollisionAlgorithm(long jarg1, btCollisionAlgorithmConstructionInfo jarg1_, long jarg2, btCollisionObjectWrapper jarg2_, long jarg3, btCollisionObjectWrapper jarg3_);
-  public final static native void delete_btGImpactCollisionAlgorithm(long jarg1);
-  public final static native long btGImpactCollisionAlgorithm_internalGetResultOut(long jarg1, btGImpactCollisionAlgorithm jarg1_);
-  public final static native long new_btGImpactCollisionAlgorithm_CreateFunc();
-  public final static native void delete_btGImpactCollisionAlgorithm_CreateFunc(long jarg1);
-  public final static native void btGImpactCollisionAlgorithm_registerAlgorithm(long jarg1, btCollisionDispatcher jarg1_);
-  public final static native void btGImpactCollisionAlgorithm_gimpact_vs_gimpact(long jarg1, btGImpactCollisionAlgorithm jarg1_, long jarg2, btCollisionObjectWrapper jarg2_, long jarg3, btCollisionObjectWrapper jarg3_, long jarg4, btGImpactShapeInterface jarg4_, long jarg5, btGImpactShapeInterface jarg5_);
-  public final static native void btGImpactCollisionAlgorithm_gimpact_vs_shape(long jarg1, btGImpactCollisionAlgorithm jarg1_, long jarg2, btCollisionObjectWrapper jarg2_, long jarg3, btCollisionObjectWrapper jarg3_, long jarg4, btGImpactShapeInterface jarg4_, long jarg5, btCollisionShape jarg5_, boolean jarg6);
-  public final static native void btGImpactCollisionAlgorithm_gimpact_vs_compoundshape(long jarg1, btGImpactCollisionAlgorithm jarg1_, long jarg2, btCollisionObjectWrapper jarg2_, long jarg3, btCollisionObjectWrapper jarg3_, long jarg4, btGImpactShapeInterface jarg4_, long jarg5, btCompoundShape jarg5_, boolean jarg6);
-  public final static native void btGImpactCollisionAlgorithm_gimpact_vs_concave(long jarg1, btGImpactCollisionAlgorithm jarg1_, long jarg2, btCollisionObjectWrapper jarg2_, long jarg3, btCollisionObjectWrapper jarg3_, long jarg4, btGImpactShapeInterface jarg4_, long jarg5, btConcaveShape jarg5_, boolean jarg6);
-  public final static native void btGImpactCollisionAlgorithm_setFace0(long jarg1, btGImpactCollisionAlgorithm jarg1_, int jarg2);
-  public final static native int btGImpactCollisionAlgorithm_getFace0(long jarg1, btGImpactCollisionAlgorithm jarg1_);
-  public final static native void btGImpactCollisionAlgorithm_setFace1(long jarg1, btGImpactCollisionAlgorithm jarg1_, int jarg2);
-  public final static native int btGImpactCollisionAlgorithm_getFace1(long jarg1, btGImpactCollisionAlgorithm jarg1_);
-  public final static native void btGImpactCollisionAlgorithm_setPart0(long jarg1, btGImpactCollisionAlgorithm jarg1_, int jarg2);
-  public final static native int btGImpactCollisionAlgorithm_getPart0(long jarg1, btGImpactCollisionAlgorithm jarg1_);
-  public final static native void btGImpactCollisionAlgorithm_setPart1(long jarg1, btGImpactCollisionAlgorithm jarg1_, int jarg2);
-  public final static native int btGImpactCollisionAlgorithm_getPart1(long jarg1, btGImpactCollisionAlgorithm jarg1_);
-  public final static native Vector3 gim_inertia_add_transformed(Vector3 jarg1, Vector3 jarg2, Matrix4 jarg3);
-  public final static native Vector3 gim_get_point_inertia(Vector3 jarg1, float jarg2);
   public final static native long btStorageResult_SWIGUpcast(long jarg1);
   public final static native long btBroadphaseRayCallback_SWIGUpcast(long jarg1);
   public final static native long btDbvtProxy_SWIGUpcast(long jarg1);
@@ -2984,16 +2582,6 @@ public class CollisionJNI {
   public final static native long btPointCollector_SWIGUpcast(long jarg1);
   public final static native long btMultiSphereShape_SWIGUpcast(long jarg1);
   public final static native long CustomCollisionDispatcher_SWIGUpcast(long jarg1);
-  public final static native long btTriangleShapeEx_SWIGUpcast(long jarg1);
-  public final static native long btTetrahedronShapeEx_SWIGUpcast(long jarg1);
-  public final static native long btGImpactShapeInterface_SWIGUpcast(long jarg1);
-  public final static native long btGImpactCompoundShape_CompoundPrimitiveManager_SWIGUpcast(long jarg1);
-  public final static native long btGImpactCompoundShape_SWIGUpcast(long jarg1);
-  public final static native long btGImpactMeshShapePart_TrimeshPrimitiveManager_SWIGUpcast(long jarg1);
-  public final static native long btGImpactMeshShapePart_SWIGUpcast(long jarg1);
-  public final static native long btGImpactMeshShape_SWIGUpcast(long jarg1);
-  public final static native long btGImpactCollisionAlgorithm_CreateFunc_SWIGUpcast(long jarg1);
-  public final static native long btGImpactCollisionAlgorithm_SWIGUpcast(long jarg1);
 
   public static boolean SwigDirector_btBroadphaseAabbCallback_process(btBroadphaseAabbCallback self, long proxy) {
     return self.process((proxy == 0) ? null : new btBroadphaseProxy(proxy, false));
@@ -3071,7 +2659,7 @@ public class CollisionJNI {
     return self.needsCollision((proxy0 == 0) ? null : new btBroadphaseProxy(proxy0, false));
   }
   public static float SwigDirector_ContactResultCallback_addSingleResult(ContactResultCallback self, long cp, long colObj0Wrap, int partId0, int index0, long colObj1Wrap, int partId1, int index1) {
-    return self.addSingleResult(new btManifoldPoint(cp, false), btCollisionObjectWrapper.obtainForArgument(colObj0Wrap, false), partId0, index0, btCollisionObjectWrapper.obtainForArgument(colObj1Wrap, false), partId1, index1);
+    return self.addSingleResult(new btManifoldPoint(cp, false), (colObj0Wrap == 0) ? null : new btCollisionObjectWrapper(colObj0Wrap, false), partId0, index0, (colObj1Wrap == 0) ? null : new btCollisionObjectWrapper(colObj1Wrap, false), partId1, index1);
   }
   public static void SwigDirector_btTriangleRaycastCallback_processTriangle(btTriangleRaycastCallback self, long triangle, int partId, int triangleIndex) {
     self.processTriangle((triangle == 0) ? null : new btVector3(triangle, false), partId, triangleIndex);
@@ -3091,8 +2679,8 @@ public class CollisionJNI {
   public static boolean SwigDirector_CustomCollisionDispatcher_needsResponse(CustomCollisionDispatcher self, long body0, long body1) {
     return self.needsResponse(btCollisionObject.getInstance(body0, false), btCollisionObject.getInstance(body1, false));
   }
-  public static boolean SwigDirector_ContactListener_onContactAdded__SWIG_0(ContactListener self, long cp, long colObj0Wrap, int partId0, int index0, long colObj1Wrap, int partId1, int index1) {
-    return self.onContactAdded(btManifoldPoint.obtainForArgument(cp, false), btCollisionObjectWrapper.obtainForArgument(colObj0Wrap, false), partId0, index0, btCollisionObjectWrapper.obtainForArgument(colObj1Wrap, false), partId1, index1);
+  public static boolean SwigDirector_ContactListener_onContactAdded__SWIG_0(ContactListener self, long cp, btCollisionObjectWrapper colObj0Wrap, int partId0, int index0, btCollisionObjectWrapper colObj1Wrap, int partId1, int index1) {
+    return self.onContactAdded(btManifoldPoint.obtainForArgument(cp, false), colObj0Wrap, partId0, index0, colObj1Wrap, partId1, index1);
   }
   public static boolean SwigDirector_ContactListener_onContactAdded__SWIG_1(ContactListener self, long cp, long colObj0, int partId0, int index0, long colObj1, int partId1, int index1) {
     return self.onContactAdded(btManifoldPoint.obtainForArgument(cp, false), btCollisionObject.getInstance(colObj0, false), partId0, index0, btCollisionObject.getInstance(colObj1, false), partId1, index1);
@@ -3100,8 +2688,8 @@ public class CollisionJNI {
   public static boolean SwigDirector_ContactListener_onContactAdded__SWIG_2(ContactListener self, long cp, int userValue0, int partId0, int index0, int userValue1, int partId1, int index1) {
     return self.onContactAdded(btManifoldPoint.obtainForArgument(cp, false), userValue0, partId0, index0, userValue1, partId1, index1);
   }
-  public static boolean SwigDirector_ContactListener_onContactAdded__SWIG_3(ContactListener self, long cp, long colObj0Wrap, int partId0, int index0, boolean match0, long colObj1Wrap, int partId1, int index1, boolean match1) {
-    return self.onContactAdded(btManifoldPoint.obtainForArgument(cp, false), btCollisionObjectWrapper.obtainForArgument(colObj0Wrap, false), partId0, index0, match0, btCollisionObjectWrapper.obtainForArgument(colObj1Wrap, false), partId1, index1, match1);
+  public static boolean SwigDirector_ContactListener_onContactAdded__SWIG_3(ContactListener self, long cp, btCollisionObjectWrapper colObj0Wrap, int partId0, int index0, boolean match0, btCollisionObjectWrapper colObj1Wrap, int partId1, int index1, boolean match1) {
+    return self.onContactAdded(btManifoldPoint.obtainForArgument(cp, false), colObj0Wrap, partId0, index0, match0, colObj1Wrap, partId1, index1, match1);
   }
   public static boolean SwigDirector_ContactListener_onContactAdded__SWIG_4(ContactListener self, long cp, long colObj0, int partId0, int index0, boolean match0, long colObj1, int partId1, int index1, boolean match1) {
     return self.onContactAdded(btManifoldPoint.obtainForArgument(cp, false), btCollisionObject.getInstance(colObj0, false), partId0, index0, match0, btCollisionObject.getInstance(colObj1, false), partId1, index1, match1);
@@ -3109,8 +2697,8 @@ public class CollisionJNI {
   public static boolean SwigDirector_ContactListener_onContactAdded__SWIG_5(ContactListener self, long cp, int userValue0, int partId0, int index0, boolean match0, int userValue1, int partId1, int index1, boolean match1) {
     return self.onContactAdded(btManifoldPoint.obtainForArgument(cp, false), userValue0, partId0, index0, match0, userValue1, partId1, index1, match1);
   }
-  public static boolean SwigDirector_ContactListener_onContactAdded__SWIG_6(ContactListener self, long colObj0Wrap, int partId0, int index0, long colObj1Wrap, int partId1, int index1) {
-    return self.onContactAdded(btCollisionObjectWrapper.obtainForArgument(colObj0Wrap, false), partId0, index0, btCollisionObjectWrapper.obtainForArgument(colObj1Wrap, false), partId1, index1);
+  public static boolean SwigDirector_ContactListener_onContactAdded__SWIG_6(ContactListener self, btCollisionObjectWrapper colObj0Wrap, int partId0, int index0, btCollisionObjectWrapper colObj1Wrap, int partId1, int index1) {
+    return self.onContactAdded(colObj0Wrap, partId0, index0, colObj1Wrap, partId1, index1);
   }
   public static boolean SwigDirector_ContactListener_onContactAdded__SWIG_7(ContactListener self, long colObj0, int partId0, int index0, long colObj1, int partId1, int index1) {
     return self.onContactAdded(btCollisionObject.getInstance(colObj0, false), partId0, index0, btCollisionObject.getInstance(colObj1, false), partId1, index1);
@@ -3118,8 +2706,8 @@ public class CollisionJNI {
   public static boolean SwigDirector_ContactListener_onContactAdded__SWIG_8(ContactListener self, int userValue0, int partId0, int index0, int userValue1, int partId1, int index1) {
     return self.onContactAdded(userValue0, partId0, index0, userValue1, partId1, index1);
   }
-  public static boolean SwigDirector_ContactListener_onContactAdded__SWIG_9(ContactListener self, long colObj0Wrap, int partId0, int index0, boolean match0, long colObj1Wrap, int partId1, int index1, boolean match1) {
-    return self.onContactAdded(btCollisionObjectWrapper.obtainForArgument(colObj0Wrap, false), partId0, index0, match0, btCollisionObjectWrapper.obtainForArgument(colObj1Wrap, false), partId1, index1, match1);
+  public static boolean SwigDirector_ContactListener_onContactAdded__SWIG_9(ContactListener self, btCollisionObjectWrapper colObj0Wrap, int partId0, int index0, boolean match0, btCollisionObjectWrapper colObj1Wrap, int partId1, int index1, boolean match1) {
+    return self.onContactAdded(colObj0Wrap, partId0, index0, match0, colObj1Wrap, partId1, index1, match1);
   }
   public static boolean SwigDirector_ContactListener_onContactAdded__SWIG_10(ContactListener self, long colObj0, int partId0, int index0, boolean match0, long colObj1, int partId1, int index1, boolean match1) {
     return self.onContactAdded(btCollisionObject.getInstance(colObj0, false), partId0, index0, match0, btCollisionObject.getInstance(colObj1, false), partId1, index1, match1);
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/CollisionObjectWrapper.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/CollisionObjectWrapper.java
index 3895695..c78d483 100644
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/CollisionObjectWrapper.java
+++ b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/CollisionObjectWrapper.java
@@ -63,13 +63,13 @@ public class CollisionObjectWrapper extends BulletBase {
 	@Override
 	protected void construct() {
 		super.construct();
-		wrapper = new btCollisionObjectWrapper(getWrapper().getCPointer(), false);
+		wrapper = btCollisionObjectWrapper.obtain(getWrapper().getCPointer(), false);
 	}
 
 	@Override
 	public void dispose() {
 		if (wrapper != null) {
-			wrapper.dispose();
+			btCollisionObjectWrapper.free(wrapper);
 			wrapper = null;
 		}
 		super.dispose();
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/ContactListener.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/ContactListener.java
index f058421..5ff639e 100644
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/ContactListener.java
+++ b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/ContactListener.java
@@ -106,7 +106,7 @@ public class ContactListener extends BulletBase {
   }
 
   public boolean onContactAdded(btManifoldPoint cp, btCollisionObjectWrapper colObj0Wrap, int partId0, int index0, btCollisionObjectWrapper colObj1Wrap, int partId1, int index1) {
-    return CollisionJNI.ContactListener_onContactAdded__SWIG_0(swigCPtr, this, btManifoldPoint.getCPtr(cp), cp, btCollisionObjectWrapper.getCPtr(colObj0Wrap), colObj0Wrap, partId0, index0, btCollisionObjectWrapper.getCPtr(colObj1Wrap), colObj1Wrap, partId1, index1);
+    return CollisionJNI.ContactListener_onContactAdded__SWIG_0(swigCPtr, this, btManifoldPoint.getCPtr(cp), cp, colObj0Wrap, partId0, index0, colObj1Wrap, partId1, index1);
   }
 
   public boolean onContactAdded(btManifoldPoint cp, btCollisionObject colObj0, int partId0, int index0, btCollisionObject colObj1, int partId1, int index1) {
@@ -118,7 +118,7 @@ public class ContactListener extends BulletBase {
   }
 
   public boolean onContactAdded(btManifoldPoint cp, btCollisionObjectWrapper colObj0Wrap, int partId0, int index0, boolean match0, btCollisionObjectWrapper colObj1Wrap, int partId1, int index1, boolean match1) {
-    return CollisionJNI.ContactListener_onContactAdded__SWIG_3(swigCPtr, this, btManifoldPoint.getCPtr(cp), cp, btCollisionObjectWrapper.getCPtr(colObj0Wrap), colObj0Wrap, partId0, index0, match0, btCollisionObjectWrapper.getCPtr(colObj1Wrap), colObj1Wrap, partId1, index1, match1);
+    return CollisionJNI.ContactListener_onContactAdded__SWIG_3(swigCPtr, this, btManifoldPoint.getCPtr(cp), cp, colObj0Wrap, partId0, index0, match0, colObj1Wrap, partId1, index1, match1);
   }
 
   public boolean onContactAdded(btManifoldPoint cp, btCollisionObject colObj0, int partId0, int index0, boolean match0, btCollisionObject colObj1, int partId1, int index1, boolean match1) {
@@ -130,7 +130,7 @@ public class ContactListener extends BulletBase {
   }
 
   public boolean onContactAdded(btCollisionObjectWrapper colObj0Wrap, int partId0, int index0, btCollisionObjectWrapper colObj1Wrap, int partId1, int index1) {
-    return CollisionJNI.ContactListener_onContactAdded__SWIG_6(swigCPtr, this, btCollisionObjectWrapper.getCPtr(colObj0Wrap), colObj0Wrap, partId0, index0, btCollisionObjectWrapper.getCPtr(colObj1Wrap), colObj1Wrap, partId1, index1);
+    return CollisionJNI.ContactListener_onContactAdded__SWIG_6(swigCPtr, this, colObj0Wrap, partId0, index0, colObj1Wrap, partId1, index1);
   }
 
   public boolean onContactAdded(btCollisionObject colObj0, int partId0, int index0, btCollisionObject colObj1, int partId1, int index1) {
@@ -142,7 +142,7 @@ public class ContactListener extends BulletBase {
   }
 
   public boolean onContactAdded(btCollisionObjectWrapper colObj0Wrap, int partId0, int index0, boolean match0, btCollisionObjectWrapper colObj1Wrap, int partId1, int index1, boolean match1) {
-    return CollisionJNI.ContactListener_onContactAdded__SWIG_9(swigCPtr, this, btCollisionObjectWrapper.getCPtr(colObj0Wrap), colObj0Wrap, partId0, index0, match0, btCollisionObjectWrapper.getCPtr(colObj1Wrap), colObj1Wrap, partId1, index1, match1);
+    return CollisionJNI.ContactListener_onContactAdded__SWIG_9(swigCPtr, this, colObj0Wrap, partId0, index0, match0, colObj1Wrap, partId1, index1, match1);
   }
 
   public boolean onContactAdded(btCollisionObject colObj0, int partId0, int index0, boolean match0, btCollisionObject colObj1, int partId1, int index1, boolean match1) {
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_BVH_DATA.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_BVH_DATA.java
deleted file mode 100644
index 2d336ef..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_BVH_DATA.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class GIM_BVH_DATA extends BulletBase {
-	private long swigCPtr;
-	
-	protected GIM_BVH_DATA(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, cPtr, cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new GIM_BVH_DATA, normally you should not need this constructor it's intended for low-level usage. */ 
-	public GIM_BVH_DATA(long cPtr, boolean cMemoryOwn) {
-		this("GIM_BVH_DATA", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(swigCPtr = cPtr, cMemoryOwn);
-	}
-	
-	public static long getCPtr(GIM_BVH_DATA obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_GIM_BVH_DATA(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public void setBound(btAABB value) {
-    CollisionJNI.GIM_BVH_DATA_bound_set(swigCPtr, this, btAABB.getCPtr(value), value);
-  }
-
-  public btAABB getBound() {
-    long cPtr = CollisionJNI.GIM_BVH_DATA_bound_get(swigCPtr, this);
-    return (cPtr == 0) ? null : new btAABB(cPtr, false);
-  }
-
-  public void setData(int value) {
-    CollisionJNI.GIM_BVH_DATA_data_set(swigCPtr, this, value);
-  }
-
-  public int getData() {
-    return CollisionJNI.GIM_BVH_DATA_data_get(swigCPtr, this);
-  }
-
-  public GIM_BVH_DATA() {
-    this(CollisionJNI.new_GIM_BVH_DATA(), true);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_BVH_DATA_ARRAY.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_BVH_DATA_ARRAY.java
deleted file mode 100644
index 1a98f8e..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_BVH_DATA_ARRAY.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class GIM_BVH_DATA_ARRAY extends BulletBase {
-	private long swigCPtr;
-	
-	protected GIM_BVH_DATA_ARRAY(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, cPtr, cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new GIM_BVH_DATA_ARRAY, normally you should not need this constructor it's intended for low-level usage. */ 
-	public GIM_BVH_DATA_ARRAY(long cPtr, boolean cMemoryOwn) {
-		this("GIM_BVH_DATA_ARRAY", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(swigCPtr = cPtr, cMemoryOwn);
-	}
-	
-	public static long getCPtr(GIM_BVH_DATA_ARRAY obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_GIM_BVH_DATA_ARRAY(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public GIM_BVH_DATA_ARRAY() {
-    this(CollisionJNI.new_GIM_BVH_DATA_ARRAY(), true);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_BVH_TREE_NODE.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_BVH_TREE_NODE.java
deleted file mode 100644
index 9b3a2ff..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_BVH_TREE_NODE.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class GIM_BVH_TREE_NODE extends BulletBase {
-	private long swigCPtr;
-	
-	protected GIM_BVH_TREE_NODE(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, cPtr, cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new GIM_BVH_TREE_NODE, normally you should not need this constructor it's intended for low-level usage. */ 
-	public GIM_BVH_TREE_NODE(long cPtr, boolean cMemoryOwn) {
-		this("GIM_BVH_TREE_NODE", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(swigCPtr = cPtr, cMemoryOwn);
-	}
-	
-	public static long getCPtr(GIM_BVH_TREE_NODE obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_GIM_BVH_TREE_NODE(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public void setBound(btAABB value) {
-    CollisionJNI.GIM_BVH_TREE_NODE_bound_set(swigCPtr, this, btAABB.getCPtr(value), value);
-  }
-
-  public btAABB getBound() {
-    long cPtr = CollisionJNI.GIM_BVH_TREE_NODE_bound_get(swigCPtr, this);
-    return (cPtr == 0) ? null : new btAABB(cPtr, false);
-  }
-
-  public GIM_BVH_TREE_NODE() {
-    this(CollisionJNI.new_GIM_BVH_TREE_NODE(), true);
-  }
-
-  public boolean isLeafNode() {
-    return CollisionJNI.GIM_BVH_TREE_NODE_isLeafNode(swigCPtr, this);
-  }
-
-  public int getEscapeIndex() {
-    return CollisionJNI.GIM_BVH_TREE_NODE_getEscapeIndex(swigCPtr, this);
-  }
-
-  public void setEscapeIndex(int index) {
-    CollisionJNI.GIM_BVH_TREE_NODE_setEscapeIndex(swigCPtr, this, index);
-  }
-
-  public int getDataIndex() {
-    return CollisionJNI.GIM_BVH_TREE_NODE_getDataIndex(swigCPtr, this);
-  }
-
-  public void setDataIndex(int index) {
-    CollisionJNI.GIM_BVH_TREE_NODE_setDataIndex(swigCPtr, this, index);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_BVH_TREE_NODE_ARRAY.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_BVH_TREE_NODE_ARRAY.java
deleted file mode 100644
index 1ca773d..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_BVH_TREE_NODE_ARRAY.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class GIM_BVH_TREE_NODE_ARRAY extends BulletBase {
-	private long swigCPtr;
-	
-	protected GIM_BVH_TREE_NODE_ARRAY(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, cPtr, cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new GIM_BVH_TREE_NODE_ARRAY, normally you should not need this constructor it's intended for low-level usage. */ 
-	public GIM_BVH_TREE_NODE_ARRAY(long cPtr, boolean cMemoryOwn) {
-		this("GIM_BVH_TREE_NODE_ARRAY", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(swigCPtr = cPtr, cMemoryOwn);
-	}
-	
-	public static long getCPtr(GIM_BVH_TREE_NODE_ARRAY obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_GIM_BVH_TREE_NODE_ARRAY(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public GIM_BVH_TREE_NODE_ARRAY() {
-    this(CollisionJNI.new_GIM_BVH_TREE_NODE_ARRAY(), true);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_CONTACT.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_CONTACT.java
deleted file mode 100644
index d376f14..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_CONTACT.java
+++ /dev/null
@@ -1,131 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class GIM_CONTACT extends BulletBase {
-	private long swigCPtr;
-	
-	protected GIM_CONTACT(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, cPtr, cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new GIM_CONTACT, normally you should not need this constructor it's intended for low-level usage. */ 
-	public GIM_CONTACT(long cPtr, boolean cMemoryOwn) {
-		this("GIM_CONTACT", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(swigCPtr = cPtr, cMemoryOwn);
-	}
-	
-	public static long getCPtr(GIM_CONTACT obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_GIM_CONTACT(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public void setPoint(btVector3 value) {
-    CollisionJNI.GIM_CONTACT_point_set(swigCPtr, this, btVector3.getCPtr(value), value);
-  }
-
-  public btVector3 getPoint() {
-    long cPtr = CollisionJNI.GIM_CONTACT_point_get(swigCPtr, this);
-    return (cPtr == 0) ? null : new btVector3(cPtr, false);
-  }
-
-  public void setNormal(btVector3 value) {
-    CollisionJNI.GIM_CONTACT_normal_set(swigCPtr, this, btVector3.getCPtr(value), value);
-  }
-
-  public btVector3 getNormal() {
-    long cPtr = CollisionJNI.GIM_CONTACT_normal_get(swigCPtr, this);
-    return (cPtr == 0) ? null : new btVector3(cPtr, false);
-  }
-
-  public void setDepth(float value) {
-    CollisionJNI.GIM_CONTACT_depth_set(swigCPtr, this, value);
-  }
-
-  public float getDepth() {
-    return CollisionJNI.GIM_CONTACT_depth_get(swigCPtr, this);
-  }
-
-  public void setDistance(float value) {
-    CollisionJNI.GIM_CONTACT_distance_set(swigCPtr, this, value);
-  }
-
-  public float getDistance() {
-    return CollisionJNI.GIM_CONTACT_distance_get(swigCPtr, this);
-  }
-
-  public void setFeature1(int value) {
-    CollisionJNI.GIM_CONTACT_feature1_set(swigCPtr, this, value);
-  }
-
-  public int getFeature1() {
-    return CollisionJNI.GIM_CONTACT_feature1_get(swigCPtr, this);
-  }
-
-  public void setFeature2(int value) {
-    CollisionJNI.GIM_CONTACT_feature2_set(swigCPtr, this, value);
-  }
-
-  public int getFeature2() {
-    return CollisionJNI.GIM_CONTACT_feature2_get(swigCPtr, this);
-  }
-
-  public GIM_CONTACT() {
-    this(CollisionJNI.new_GIM_CONTACT__SWIG_0(), true);
-  }
-
-  public GIM_CONTACT(GIM_CONTACT contact) {
-    this(CollisionJNI.new_GIM_CONTACT__SWIG_1(GIM_CONTACT.getCPtr(contact), contact), true);
-  }
-
-  public GIM_CONTACT(Vector3 point, Vector3 normal, float depth, int feature1, int feature2) {
-    this(CollisionJNI.new_GIM_CONTACT__SWIG_2(point, normal, depth, feature1, feature2), true);
-  }
-
-  public long calc_key_contact() {
-    return CollisionJNI.GIM_CONTACT_calc_key_contact(swigCPtr, this);
-  }
-
-  public void interpolate_normals(btVector3 normals, int normal_count) {
-    CollisionJNI.GIM_CONTACT_interpolate_normals(swigCPtr, this, btVector3.getCPtr(normals), normals, normal_count);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_PAIR.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_PAIR.java
deleted file mode 100644
index 048a296..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_PAIR.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class GIM_PAIR extends BulletBase {
-	private long swigCPtr;
-	
-	protected GIM_PAIR(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, cPtr, cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new GIM_PAIR, normally you should not need this constructor it's intended for low-level usage. */ 
-	public GIM_PAIR(long cPtr, boolean cMemoryOwn) {
-		this("GIM_PAIR", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(swigCPtr = cPtr, cMemoryOwn);
-	}
-	
-	public static long getCPtr(GIM_PAIR obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_GIM_PAIR(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public void setIndex1(int value) {
-    CollisionJNI.GIM_PAIR_index1_set(swigCPtr, this, value);
-  }
-
-  public int getIndex1() {
-    return CollisionJNI.GIM_PAIR_index1_get(swigCPtr, this);
-  }
-
-  public void setIndex2(int value) {
-    CollisionJNI.GIM_PAIR_index2_set(swigCPtr, this, value);
-  }
-
-  public int getIndex2() {
-    return CollisionJNI.GIM_PAIR_index2_get(swigCPtr, this);
-  }
-
-  public GIM_PAIR() {
-    this(CollisionJNI.new_GIM_PAIR__SWIG_0(), true);
-  }
-
-  public GIM_PAIR(GIM_PAIR p) {
-    this(CollisionJNI.new_GIM_PAIR__SWIG_1(GIM_PAIR.getCPtr(p), p), true);
-  }
-
-  public GIM_PAIR(int index1, int index2) {
-    this(CollisionJNI.new_GIM_PAIR__SWIG_2(index1, index2), true);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_QUANTIZED_BVH_NODE_ARRAY.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_QUANTIZED_BVH_NODE_ARRAY.java
deleted file mode 100644
index f105fb7..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_QUANTIZED_BVH_NODE_ARRAY.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class GIM_QUANTIZED_BVH_NODE_ARRAY extends BulletBase {
-	private long swigCPtr;
-	
-	protected GIM_QUANTIZED_BVH_NODE_ARRAY(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, cPtr, cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new GIM_QUANTIZED_BVH_NODE_ARRAY, normally you should not need this constructor it's intended for low-level usage. */ 
-	public GIM_QUANTIZED_BVH_NODE_ARRAY(long cPtr, boolean cMemoryOwn) {
-		this("GIM_QUANTIZED_BVH_NODE_ARRAY", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(swigCPtr = cPtr, cMemoryOwn);
-	}
-	
-	public static long getCPtr(GIM_QUANTIZED_BVH_NODE_ARRAY obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_GIM_QUANTIZED_BVH_NODE_ARRAY(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public GIM_QUANTIZED_BVH_NODE_ARRAY() {
-    this(CollisionJNI.new_GIM_QUANTIZED_BVH_NODE_ARRAY(), true);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_TRIANGLE_CONTACT.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_TRIANGLE_CONTACT.java
deleted file mode 100644
index af2b7c0..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/GIM_TRIANGLE_CONTACT.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class GIM_TRIANGLE_CONTACT extends BulletBase {
-	private long swigCPtr;
-	
-	protected GIM_TRIANGLE_CONTACT(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, cPtr, cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new GIM_TRIANGLE_CONTACT, normally you should not need this constructor it's intended for low-level usage. */ 
-	public GIM_TRIANGLE_CONTACT(long cPtr, boolean cMemoryOwn) {
-		this("GIM_TRIANGLE_CONTACT", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(swigCPtr = cPtr, cMemoryOwn);
-	}
-	
-	public static long getCPtr(GIM_TRIANGLE_CONTACT obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_GIM_TRIANGLE_CONTACT(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public void setPenetration_depth(float value) {
-    CollisionJNI.GIM_TRIANGLE_CONTACT_penetration_depth_set(swigCPtr, this, value);
-  }
-
-  public float getPenetration_depth() {
-    return CollisionJNI.GIM_TRIANGLE_CONTACT_penetration_depth_get(swigCPtr, this);
-  }
-
-  public void setPoint_count(int value) {
-    CollisionJNI.GIM_TRIANGLE_CONTACT_point_count_set(swigCPtr, this, value);
-  }
-
-  public int getPoint_count() {
-    return CollisionJNI.GIM_TRIANGLE_CONTACT_point_count_get(swigCPtr, this);
-  }
-
-  public void setSeparating_normal(btVector4 value) {
-    CollisionJNI.GIM_TRIANGLE_CONTACT_separating_normal_set(swigCPtr, this, btVector4.getCPtr(value), value);
-  }
-
-  public btVector4 getSeparating_normal() {
-    long cPtr = CollisionJNI.GIM_TRIANGLE_CONTACT_separating_normal_get(swigCPtr, this);
-    return (cPtr == 0) ? null : new btVector4(cPtr, false);
-  }
-
-  public void setPoints(btVector3 value) {
-    CollisionJNI.GIM_TRIANGLE_CONTACT_points_set(swigCPtr, this, btVector3.getCPtr(value), value);
-  }
-
-  public btVector3 getPoints() {
-    long cPtr = CollisionJNI.GIM_TRIANGLE_CONTACT_points_get(swigCPtr, this);
-    return (cPtr == 0) ? null : new btVector3(cPtr, false);
-  }
-
-  public void copy_from(GIM_TRIANGLE_CONTACT other) {
-    CollisionJNI.GIM_TRIANGLE_CONTACT_copy_from(swigCPtr, this, GIM_TRIANGLE_CONTACT.getCPtr(other), other);
-  }
-
-  public GIM_TRIANGLE_CONTACT() {
-    this(CollisionJNI.new_GIM_TRIANGLE_CONTACT__SWIG_0(), true);
-  }
-
-  public GIM_TRIANGLE_CONTACT(GIM_TRIANGLE_CONTACT other) {
-    this(CollisionJNI.new_GIM_TRIANGLE_CONTACT__SWIG_1(GIM_TRIANGLE_CONTACT.getCPtr(other), other), true);
-  }
-
-  public void merge_points(btVector4 plane, float margin, btVector3 points, int point_count) {
-    CollisionJNI.GIM_TRIANGLE_CONTACT_merge_points(swigCPtr, this, btVector4.getCPtr(plane), plane, margin, btVector3.getCPtr(points), points, point_count);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/SWIGTYPE_p_p_btGenericMemoryPool.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/SWIGTYPE_p_p_btGenericMemoryPool.java
deleted file mode 100644
index 79c87e0..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/SWIGTYPE_p_p_btGenericMemoryPool.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-public class SWIGTYPE_p_p_btGenericMemoryPool {
-  private long swigCPtr;
-
-  protected SWIGTYPE_p_p_btGenericMemoryPool(long cPtr, boolean futureUse) {
-    swigCPtr = cPtr;
-  }
-
-  protected SWIGTYPE_p_p_btGenericMemoryPool() {
-    swigCPtr = 0;
-  }
-
-  protected static long getCPtr(SWIGTYPE_p_p_btGenericMemoryPool obj) {
-    return (obj == null) ? 0 : obj.swigCPtr;
-  }
-}
-
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/SWIGTYPE_p_size_t.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/SWIGTYPE_p_size_t.java
deleted file mode 100644
index 5adbecb..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/SWIGTYPE_p_size_t.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-public class SWIGTYPE_p_size_t {
-  private long swigCPtr;
-
-  protected SWIGTYPE_p_size_t(long cPtr, boolean futureUse) {
-    swigCPtr = cPtr;
-  }
-
-  protected SWIGTYPE_p_size_t() {
-    swigCPtr = 0;
-  }
-
-  protected static long getCPtr(SWIGTYPE_p_size_t obj) {
-    return (obj == null) ? 0 : obj.swigCPtr;
-  }
-}
-
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/SWIGTYPE_p_unsigned_int.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/SWIGTYPE_p_unsigned_int.java
deleted file mode 100644
index d02940e..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/SWIGTYPE_p_unsigned_int.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-public class SWIGTYPE_p_unsigned_int {
-  private long swigCPtr;
-
-  protected SWIGTYPE_p_unsigned_int(long cPtr, boolean futureUse) {
-    swigCPtr = cPtr;
-  }
-
-  protected SWIGTYPE_p_unsigned_int() {
-    swigCPtr = 0;
-  }
-
-  protected static long getCPtr(SWIGTYPE_p_unsigned_int obj) {
-    return (obj == null) ? 0 : obj.swigCPtr;
-  }
-}
-
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btAABB.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btAABB.java
deleted file mode 100644
index 32aed53..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btAABB.java
+++ /dev/null
@@ -1,167 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class btAABB extends BulletBase {
-	private long swigCPtr;
-	
-	protected btAABB(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, cPtr, cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new btAABB, normally you should not need this constructor it's intended for low-level usage. */ 
-	public btAABB(long cPtr, boolean cMemoryOwn) {
-		this("btAABB", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(swigCPtr = cPtr, cMemoryOwn);
-	}
-	
-	public static long getCPtr(btAABB obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_btAABB(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public void setMin(btVector3 value) {
-    CollisionJNI.btAABB_min_set(swigCPtr, this, btVector3.getCPtr(value), value);
-  }
-
-  public btVector3 getMin() {
-    long cPtr = CollisionJNI.btAABB_min_get(swigCPtr, this);
-    return (cPtr == 0) ? null : new btVector3(cPtr, false);
-  }
-
-  public void setMax(btVector3 value) {
-    CollisionJNI.btAABB_max_set(swigCPtr, this, btVector3.getCPtr(value), value);
-  }
-
-  public btVector3 getMax() {
-    long cPtr = CollisionJNI.btAABB_max_get(swigCPtr, this);
-    return (cPtr == 0) ? null : new btVector3(cPtr, false);
-  }
-
-  public btAABB() {
-    this(CollisionJNI.new_btAABB__SWIG_0(), true);
-  }
-
-  public btAABB(Vector3 V1, Vector3 V2, Vector3 V3) {
-    this(CollisionJNI.new_btAABB__SWIG_1(V1, V2, V3), true);
-  }
-
-  public btAABB(Vector3 V1, Vector3 V2, Vector3 V3, float margin) {
-    this(CollisionJNI.new_btAABB__SWIG_2(V1, V2, V3, margin), true);
-  }
-
-  public btAABB(btAABB other) {
-    this(CollisionJNI.new_btAABB__SWIG_3(btAABB.getCPtr(other), other), true);
-  }
-
-  public btAABB(btAABB other, float margin) {
-    this(CollisionJNI.new_btAABB__SWIG_4(btAABB.getCPtr(other), other, margin), true);
-  }
-
-  public void invalidate() {
-    CollisionJNI.btAABB_invalidate(swigCPtr, this);
-  }
-
-  public void increment_margin(float margin) {
-    CollisionJNI.btAABB_increment_margin(swigCPtr, this, margin);
-  }
-
-  public void copy_with_margin(btAABB other, float margin) {
-    CollisionJNI.btAABB_copy_with_margin(swigCPtr, this, btAABB.getCPtr(other), other, margin);
-  }
-
-  public void appy_transform(Matrix4 trans) {
-    CollisionJNI.btAABB_appy_transform(swigCPtr, this, trans);
-  }
-
-  public void appy_transform_trans_cache(BT_BOX_BOX_TRANSFORM_CACHE trans) {
-    CollisionJNI.btAABB_appy_transform_trans_cache(swigCPtr, this, BT_BOX_BOX_TRANSFORM_CACHE.getCPtr(trans), trans);
-  }
-
-  public void merge(btAABB box) {
-    CollisionJNI.btAABB_merge(swigCPtr, this, btAABB.getCPtr(box), box);
-  }
-
-  public void get_center_extend(Vector3 center, Vector3 extend) {
-    CollisionJNI.btAABB_get_center_extend(swigCPtr, this, center, extend);
-  }
-
-  public void find_intersection(btAABB other, btAABB intersection) {
-    CollisionJNI.btAABB_find_intersection(swigCPtr, this, btAABB.getCPtr(other), other, btAABB.getCPtr(intersection), intersection);
-  }
-
-  public boolean has_collision(btAABB other) {
-    return CollisionJNI.btAABB_has_collision(swigCPtr, this, btAABB.getCPtr(other), other);
-  }
-
-  public boolean collide_ray(Vector3 vorigin, Vector3 vdir) {
-    return CollisionJNI.btAABB_collide_ray(swigCPtr, this, vorigin, vdir);
-  }
-
-  public void projection_interval(Vector3 direction, SWIGTYPE_p_float vmin, SWIGTYPE_p_float vmax) {
-    CollisionJNI.btAABB_projection_interval(swigCPtr, this, direction, SWIGTYPE_p_float.getCPtr(vmin), SWIGTYPE_p_float.getCPtr(vmax));
-  }
-
-  public int plane_classify(btVector4 plane) {
-    return CollisionJNI.btAABB_plane_classify(swigCPtr, this, btVector4.getCPtr(plane), plane);
-  }
-
-  public boolean overlapping_trans_conservative(btAABB box, Matrix4 trans1_to_0) {
-    return CollisionJNI.btAABB_overlapping_trans_conservative(swigCPtr, this, btAABB.getCPtr(box), box, trans1_to_0);
-  }
-
-  public boolean overlapping_trans_conservative2(btAABB box, BT_BOX_BOX_TRANSFORM_CACHE trans1_to_0) {
-    return CollisionJNI.btAABB_overlapping_trans_conservative2(swigCPtr, this, btAABB.getCPtr(box), box, BT_BOX_BOX_TRANSFORM_CACHE.getCPtr(trans1_to_0), trans1_to_0);
-  }
-
-  public boolean overlapping_trans_cache(btAABB box, BT_BOX_BOX_TRANSFORM_CACHE transcache, boolean fulltest) {
-    return CollisionJNI.btAABB_overlapping_trans_cache(swigCPtr, this, btAABB.getCPtr(box), box, BT_BOX_BOX_TRANSFORM_CACHE.getCPtr(transcache), transcache, fulltest);
-  }
-
-  public boolean collide_plane(btVector4 plane) {
-    return CollisionJNI.btAABB_collide_plane(swigCPtr, this, btVector4.getCPtr(plane), plane);
-  }
-
-  public boolean collide_triangle_exact(Vector3 p1, Vector3 p2, Vector3 p3, btVector4 triangle_plane) {
-    return CollisionJNI.btAABB_collide_triangle_exact(swigCPtr, this, p1, p2, p3, btVector4.getCPtr(triangle_plane), triangle_plane);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btBvhTree.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btBvhTree.java
deleted file mode 100644
index 57f44d9..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btBvhTree.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class btBvhTree extends BulletBase {
-	private long swigCPtr;
-	
-	protected btBvhTree(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, cPtr, cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new btBvhTree, normally you should not need this constructor it's intended for low-level usage. */ 
-	public btBvhTree(long cPtr, boolean cMemoryOwn) {
-		this("btBvhTree", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(swigCPtr = cPtr, cMemoryOwn);
-	}
-	
-	public static long getCPtr(btBvhTree obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_btBvhTree(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public btBvhTree() {
-    this(CollisionJNI.new_btBvhTree(), true);
-  }
-
-  public void build_tree(GIM_BVH_DATA_ARRAY primitive_boxes) {
-    CollisionJNI.btBvhTree_build_tree(swigCPtr, this, GIM_BVH_DATA_ARRAY.getCPtr(primitive_boxes), primitive_boxes);
-  }
-
-  public void clearNodes() {
-    CollisionJNI.btBvhTree_clearNodes(swigCPtr, this);
-  }
-
-  public int getNodeCount() {
-    return CollisionJNI.btBvhTree_getNodeCount(swigCPtr, this);
-  }
-
-  public boolean isLeafNode(int nodeindex) {
-    return CollisionJNI.btBvhTree_isLeafNode(swigCPtr, this, nodeindex);
-  }
-
-  public int getNodeData(int nodeindex) {
-    return CollisionJNI.btBvhTree_getNodeData(swigCPtr, this, nodeindex);
-  }
-
-  public void getNodeBound(int nodeindex, btAABB bound) {
-    CollisionJNI.btBvhTree_getNodeBound(swigCPtr, this, nodeindex, btAABB.getCPtr(bound), bound);
-  }
-
-  public void setNodeBound(int nodeindex, btAABB bound) {
-    CollisionJNI.btBvhTree_setNodeBound(swigCPtr, this, nodeindex, btAABB.getCPtr(bound), bound);
-  }
-
-  public int getLeftNode(int nodeindex) {
-    return CollisionJNI.btBvhTree_getLeftNode(swigCPtr, this, nodeindex);
-  }
-
-  public int getRightNode(int nodeindex) {
-    return CollisionJNI.btBvhTree_getRightNode(swigCPtr, this, nodeindex);
-  }
-
-  public int getEscapeNodeIndex(int nodeindex) {
-    return CollisionJNI.btBvhTree_getEscapeNodeIndex(swigCPtr, this, nodeindex);
-  }
-
-  public GIM_BVH_TREE_NODE get_node_pointer(int index) {
-    long cPtr = CollisionJNI.btBvhTree_get_node_pointer__SWIG_0(swigCPtr, this, index);
-    return (cPtr == 0) ? null : new GIM_BVH_TREE_NODE(cPtr, false);
-  }
-
-  public GIM_BVH_TREE_NODE get_node_pointer() {
-    long cPtr = CollisionJNI.btBvhTree_get_node_pointer__SWIG_1(swigCPtr, this);
-    return (cPtr == 0) ? null : new GIM_BVH_TREE_NODE(cPtr, false);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btCollisionObjectWrapper.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btCollisionObjectWrapper.java
index 50c2d5a..b2533e3 100644
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btCollisionObjectWrapper.java
+++ b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btCollisionObjectWrapper.java
@@ -57,15 +57,23 @@ public class btCollisionObjectWrapper extends BulletBase {
 		temp.reset(cPtr, own);
 		return temp;
 	}
-
-	private static btCollisionObjectWrapper[] argumentInstances = new btCollisionObjectWrapper[] {new btCollisionObjectWrapper(0, false),
-		new btCollisionObjectWrapper(0, false), new btCollisionObjectWrapper(0, false), new btCollisionObjectWrapper(0, false)};
-	private static int argumentIndex = -1;
-	/** Obtains a temporary instance, used for callback methods with one or more btManifoldPoint arguments */
-	protected static btCollisionObjectWrapper obtainForArgument(final long swigCPtr, boolean owner) {
-		btCollisionObjectWrapper instance = argumentInstances[argumentIndex = (argumentIndex + 1) & 3];
-		instance.reset(swigCPtr, owner);
-		return instance;
+	/** Pool of btCollisionObjectWrapper instances, used by director interface to provide the arguments. */
+	protected static final com.badlogic.gdx.utils.Pool<btCollisionObjectWrapper> pool = new com.badlogic.gdx.utils.Pool<btCollisionObjectWrapper>() {
+		@Override
+		protected btCollisionObjectWrapper newObject() {
+			return new btCollisionObjectWrapper(0, false);
+		}
+	};
+	/** Reuses a previous freed instance or creates a new instance and set it to reflect the specified native object */
+	public static btCollisionObjectWrapper obtain(long cPtr, boolean own) {
+		final btCollisionObjectWrapper result = pool.obtain();
+		result.reset(cPtr, own);
+		return result;
+	}
+	/** delete the native object if required and allow the instance to be reused by the obtain method */
+	public static void free(final btCollisionObjectWrapper inst) {
+		inst.dispose();
+		pool.free(inst);
 	}
 
 	@Override
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btContactArray.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btContactArray.java
deleted file mode 100644
index e261ed9..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btContactArray.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class btContactArray extends BulletBase {
-	private long swigCPtr;
-	
-	protected btContactArray(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, cPtr, cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new btContactArray, normally you should not need this constructor it's intended for low-level usage. */ 
-	public btContactArray(long cPtr, boolean cMemoryOwn) {
-		this("btContactArray", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(swigCPtr = cPtr, cMemoryOwn);
-	}
-	
-	public static long getCPtr(btContactArray obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_btContactArray(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public btContactArray() {
-    this(CollisionJNI.new_btContactArray(), true);
-  }
-
-  public void push_contact(Vector3 point, Vector3 normal, float depth, int feature1, int feature2) {
-    CollisionJNI.btContactArray_push_contact(swigCPtr, this, point, normal, depth, feature1, feature2);
-  }
-
-  public void push_triangle_contacts(GIM_TRIANGLE_CONTACT tricontact, int feature1, int feature2) {
-    CollisionJNI.btContactArray_push_triangle_contacts(swigCPtr, this, GIM_TRIANGLE_CONTACT.getCPtr(tricontact), tricontact, feature1, feature2);
-  }
-
-  public void merge_contacts(btContactArray contacts, boolean normal_contact_average) {
-    CollisionJNI.btContactArray_merge_contacts__SWIG_0(swigCPtr, this, btContactArray.getCPtr(contacts), contacts, normal_contact_average);
-  }
-
-  public void merge_contacts(btContactArray contacts) {
-    CollisionJNI.btContactArray_merge_contacts__SWIG_1(swigCPtr, this, btContactArray.getCPtr(contacts), contacts);
-  }
-
-  public void merge_contacts_unique(btContactArray contacts) {
-    CollisionJNI.btContactArray_merge_contacts_unique(swigCPtr, this, btContactArray.getCPtr(contacts), contacts);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactBvh.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactBvh.java
deleted file mode 100644
index 92df12a..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactBvh.java
+++ /dev/null
@@ -1,160 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class btGImpactBvh extends BulletBase {
-	private long swigCPtr;
-	
-	protected btGImpactBvh(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, cPtr, cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new btGImpactBvh, normally you should not need this constructor it's intended for low-level usage. */ 
-	public btGImpactBvh(long cPtr, boolean cMemoryOwn) {
-		this("btGImpactBvh", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(swigCPtr = cPtr, cMemoryOwn);
-	}
-	
-	public static long getCPtr(btGImpactBvh obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_btGImpactBvh(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public btGImpactBvh() {
-    this(CollisionJNI.new_btGImpactBvh__SWIG_0(), true);
-  }
-
-  public btGImpactBvh(btPrimitiveManagerBase primitive_manager) {
-    this(CollisionJNI.new_btGImpactBvh__SWIG_1(btPrimitiveManagerBase.getCPtr(primitive_manager), primitive_manager), true);
-  }
-
-  public btAABB getGlobalBox() {
-    return new btAABB(CollisionJNI.btGImpactBvh_getGlobalBox(swigCPtr, this), true);
-  }
-
-  public void setPrimitiveManager(btPrimitiveManagerBase primitive_manager) {
-    CollisionJNI.btGImpactBvh_setPrimitiveManager(swigCPtr, this, btPrimitiveManagerBase.getCPtr(primitive_manager), primitive_manager);
-  }
-
-  public btPrimitiveManagerBase getPrimitiveManager() {
-    long cPtr = CollisionJNI.btGImpactBvh_getPrimitiveManager(swigCPtr, this);
-    return (cPtr == 0) ? null : new btPrimitiveManagerBase(cPtr, false);
-  }
-
-  public void update() {
-    CollisionJNI.btGImpactBvh_update(swigCPtr, this);
-  }
-
-  public void buildSet() {
-    CollisionJNI.btGImpactBvh_buildSet(swigCPtr, this);
-  }
-
-  public boolean boxQuery(btAABB box, SWIGTYPE_p_btAlignedObjectArrayT_int_t collided_results) {
-    return CollisionJNI.btGImpactBvh_boxQuery(swigCPtr, this, btAABB.getCPtr(box), box, SWIGTYPE_p_btAlignedObjectArrayT_int_t.getCPtr(collided_results));
-  }
-
-  public boolean boxQueryTrans(btAABB box, Matrix4 transform, SWIGTYPE_p_btAlignedObjectArrayT_int_t collided_results) {
-    return CollisionJNI.btGImpactBvh_boxQueryTrans(swigCPtr, this, btAABB.getCPtr(box), box, transform, SWIGTYPE_p_btAlignedObjectArrayT_int_t.getCPtr(collided_results));
-  }
-
-  public boolean rayQuery(Vector3 ray_dir, Vector3 ray_origin, SWIGTYPE_p_btAlignedObjectArrayT_int_t collided_results) {
-    return CollisionJNI.btGImpactBvh_rayQuery(swigCPtr, this, ray_dir, ray_origin, SWIGTYPE_p_btAlignedObjectArrayT_int_t.getCPtr(collided_results));
-  }
-
-  public boolean hasHierarchy() {
-    return CollisionJNI.btGImpactBvh_hasHierarchy(swigCPtr, this);
-  }
-
-  public boolean isTrimesh() {
-    return CollisionJNI.btGImpactBvh_isTrimesh(swigCPtr, this);
-  }
-
-  public int getNodeCount() {
-    return CollisionJNI.btGImpactBvh_getNodeCount(swigCPtr, this);
-  }
-
-  public boolean isLeafNode(int nodeindex) {
-    return CollisionJNI.btGImpactBvh_isLeafNode(swigCPtr, this, nodeindex);
-  }
-
-  public int getNodeData(int nodeindex) {
-    return CollisionJNI.btGImpactBvh_getNodeData(swigCPtr, this, nodeindex);
-  }
-
-  public void getNodeBound(int nodeindex, btAABB bound) {
-    CollisionJNI.btGImpactBvh_getNodeBound(swigCPtr, this, nodeindex, btAABB.getCPtr(bound), bound);
-  }
-
-  public void setNodeBound(int nodeindex, btAABB bound) {
-    CollisionJNI.btGImpactBvh_setNodeBound(swigCPtr, this, nodeindex, btAABB.getCPtr(bound), bound);
-  }
-
-  public int getLeftNode(int nodeindex) {
-    return CollisionJNI.btGImpactBvh_getLeftNode(swigCPtr, this, nodeindex);
-  }
-
-  public int getRightNode(int nodeindex) {
-    return CollisionJNI.btGImpactBvh_getRightNode(swigCPtr, this, nodeindex);
-  }
-
-  public int getEscapeNodeIndex(int nodeindex) {
-    return CollisionJNI.btGImpactBvh_getEscapeNodeIndex(swigCPtr, this, nodeindex);
-  }
-
-  public void getNodeTriangle(int nodeindex, btPrimitiveTriangle triangle) {
-    CollisionJNI.btGImpactBvh_getNodeTriangle(swigCPtr, this, nodeindex, btPrimitiveTriangle.getCPtr(triangle), triangle);
-  }
-
-  public GIM_BVH_TREE_NODE get_node_pointer(int index) {
-    long cPtr = CollisionJNI.btGImpactBvh_get_node_pointer__SWIG_0(swigCPtr, this, index);
-    return (cPtr == 0) ? null : new GIM_BVH_TREE_NODE(cPtr, false);
-  }
-
-  public GIM_BVH_TREE_NODE get_node_pointer() {
-    long cPtr = CollisionJNI.btGImpactBvh_get_node_pointer__SWIG_1(swigCPtr, this);
-    return (cPtr == 0) ? null : new GIM_BVH_TREE_NODE(cPtr, false);
-  }
-
-  public static void find_collision(btGImpactBvh boxset1, Matrix4 trans1, btGImpactBvh boxset2, Matrix4 trans2, btPairSet collision_pairs) {
-    CollisionJNI.btGImpactBvh_find_collision(btGImpactBvh.getCPtr(boxset1), boxset1, trans1, btGImpactBvh.getCPtr(boxset2), boxset2, trans2, btPairSet.getCPtr(collision_pairs), collision_pairs);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactCollisionAlgorithm.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactCollisionAlgorithm.java
deleted file mode 100644
index d471d5c..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactCollisionAlgorithm.java
+++ /dev/null
@@ -1,171 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class btGImpactCollisionAlgorithm extends btActivatingCollisionAlgorithm {
-	private long swigCPtr;
-	
-	protected btGImpactCollisionAlgorithm(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, CollisionJNI.btGImpactCollisionAlgorithm_SWIGUpcast(cPtr), cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new btGImpactCollisionAlgorithm, normally you should not need this constructor it's intended for low-level usage. */
-	public btGImpactCollisionAlgorithm(long cPtr, boolean cMemoryOwn) {
-		this("btGImpactCollisionAlgorithm", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(CollisionJNI.btGImpactCollisionAlgorithm_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);
-	}
-	
-	public static long getCPtr(btGImpactCollisionAlgorithm obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_btGImpactCollisionAlgorithm(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public btGImpactCollisionAlgorithm(btCollisionAlgorithmConstructionInfo ci, btCollisionObjectWrapper body0Wrap, btCollisionObjectWrapper body1Wrap) {
-    this(CollisionJNI.new_btGImpactCollisionAlgorithm(btCollisionAlgorithmConstructionInfo.getCPtr(ci), ci, btCollisionObjectWrapper.getCPtr(body0Wrap), body0Wrap, btCollisionObjectWrapper.getCPtr(body1Wrap), body1Wrap), true);
-  }
-
-  public btManifoldResult internalGetResultOut() {
-    long cPtr = CollisionJNI.btGImpactCollisionAlgorithm_internalGetResultOut(swigCPtr, this);
-    return (cPtr == 0) ? null : new btManifoldResult(cPtr, false);
-  }
-
-  static public class CreateFunc extends btCollisionAlgorithmCreateFunc {
-  	private long swigCPtr;
-  	
-  	protected CreateFunc(final String className, long cPtr, boolean cMemoryOwn) {
-  		super(className, CollisionJNI.btGImpactCollisionAlgorithm_CreateFunc_SWIGUpcast(cPtr), cMemoryOwn);
-  		swigCPtr = cPtr;
-  	}
-  	
-  	/** Construct a new CreateFunc, normally you should not need this constructor it's intended for low-level usage. */
-  	public CreateFunc(long cPtr, boolean cMemoryOwn) {
-  		this("CreateFunc", cPtr, cMemoryOwn);
-  		construct();
-  	}
-  	
-  	@Override
-  	protected void reset(long cPtr, boolean cMemoryOwn) {
-  		if (!destroyed)
-  			destroy();
-  		super.reset(CollisionJNI.btGImpactCollisionAlgorithm_CreateFunc_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);
-  	}
-  	
-  	public static long getCPtr(CreateFunc obj) {
-  		return (obj == null) ? 0 : obj.swigCPtr;
-  	}
-  
-  	@Override
-  	protected void finalize() throws Throwable {
-  		if (!destroyed)
-  			destroy();
-  		super.finalize();
-  	}
-  
-    @Override protected synchronized void delete() {
-  		if (swigCPtr != 0) {
-  			if (swigCMemOwn) {
-  				swigCMemOwn = false;
-  				CollisionJNI.delete_btGImpactCollisionAlgorithm_CreateFunc(swigCPtr);
-  			}
-  			swigCPtr = 0;
-  		}
-  		super.delete();
-  	}
-  
-    public CreateFunc() {
-      this(CollisionJNI.new_btGImpactCollisionAlgorithm_CreateFunc(), true);
-    }
-  
-  }
-
-  public static void registerAlgorithm(btCollisionDispatcher dispatcher) {
-    CollisionJNI.btGImpactCollisionAlgorithm_registerAlgorithm(btCollisionDispatcher.getCPtr(dispatcher), dispatcher);
-  }
-
-  public void gimpact_vs_gimpact(btCollisionObjectWrapper body0Wrap, btCollisionObjectWrapper body1Wrap, btGImpactShapeInterface shape0, btGImpactShapeInterface shape1) {
-    CollisionJNI.btGImpactCollisionAlgorithm_gimpact_vs_gimpact(swigCPtr, this, btCollisionObjectWrapper.getCPtr(body0Wrap), body0Wrap, btCollisionObjectWrapper.getCPtr(body1Wrap), body1Wrap, btGImpactShapeInterface.getCPtr(shape0), shape0, btGImpactShapeInterface.getCPtr(shape1), shape1);
-  }
-
-  public void gimpact_vs_shape(btCollisionObjectWrapper body0Wrap, btCollisionObjectWrapper body1Wrap, btGImpactShapeInterface shape0, btCollisionShape shape1, boolean swapped) {
-    CollisionJNI.btGImpactCollisionAlgorithm_gimpact_vs_shape(swigCPtr, this, btCollisionObjectWrapper.getCPtr(body0Wrap), body0Wrap, btCollisionObjectWrapper.getCPtr(body1Wrap), body1Wrap, btGImpactShapeInterface.getCPtr(shape0), shape0, btCollisionShape.getCPtr(shape1), shape1, swapped);
-  }
-
-  public void gimpact_vs_compoundshape(btCollisionObjectWrapper body0Wrap, btCollisionObjectWrapper body1Wrap, btGImpactShapeInterface shape0, btCompoundShape shape1, boolean swapped) {
-    CollisionJNI.btGImpactCollisionAlgorithm_gimpact_vs_compoundshape(swigCPtr, this, btCollisionObjectWrapper.getCPtr(body0Wrap), body0Wrap, btCollisionObjectWrapper.getCPtr(body1Wrap), body1Wrap, btGImpactShapeInterface.getCPtr(shape0), shape0, btCompoundShape.getCPtr(shape1), shape1, swapped);
-  }
-
-  public void gimpact_vs_concave(btCollisionObjectWrapper body0Wrap, btCollisionObjectWrapper body1Wrap, btGImpactShapeInterface shape0, btConcaveShape shape1, boolean swapped) {
-    CollisionJNI.btGImpactCollisionAlgorithm_gimpact_vs_concave(swigCPtr, this, btCollisionObjectWrapper.getCPtr(body0Wrap), body0Wrap, btCollisionObjectWrapper.getCPtr(body1Wrap), body1Wrap, btGImpactShapeInterface.getCPtr(shape0), shape0, btConcaveShape.getCPtr(shape1), shape1, swapped);
-  }
-
-  public void setFace0(int value) {
-    CollisionJNI.btGImpactCollisionAlgorithm_setFace0(swigCPtr, this, value);
-  }
-
-  public int getFace0() {
-    return CollisionJNI.btGImpactCollisionAlgorithm_getFace0(swigCPtr, this);
-  }
-
-  public void setFace1(int value) {
-    CollisionJNI.btGImpactCollisionAlgorithm_setFace1(swigCPtr, this, value);
-  }
-
-  public int getFace1() {
-    return CollisionJNI.btGImpactCollisionAlgorithm_getFace1(swigCPtr, this);
-  }
-
-  public void setPart0(int value) {
-    CollisionJNI.btGImpactCollisionAlgorithm_setPart0(swigCPtr, this, value);
-  }
-
-  public int getPart0() {
-    return CollisionJNI.btGImpactCollisionAlgorithm_getPart0(swigCPtr, this);
-  }
-
-  public void setPart1(int value) {
-    CollisionJNI.btGImpactCollisionAlgorithm_setPart1(swigCPtr, this, value);
-  }
-
-  public int getPart1() {
-    return CollisionJNI.btGImpactCollisionAlgorithm_getPart1(swigCPtr, this);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactCompoundShape.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactCompoundShape.java
deleted file mode 100644
index 0fdc7a9..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactCompoundShape.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class btGImpactCompoundShape extends btGImpactShapeInterface {
-	private long swigCPtr;
-	
-	protected btGImpactCompoundShape(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, CollisionJNI.btGImpactCompoundShape_SWIGUpcast(cPtr), cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new btGImpactCompoundShape, normally you should not need this constructor it's intended for low-level usage. */
-	public btGImpactCompoundShape(long cPtr, boolean cMemoryOwn) {
-		this("btGImpactCompoundShape", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(CollisionJNI.btGImpactCompoundShape_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);
-	}
-	
-	public static long getCPtr(btGImpactCompoundShape obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_btGImpactCompoundShape(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  static public class CompoundPrimitiveManager extends btPrimitiveManagerBase {
-  	private long swigCPtr;
-  	
-  	protected CompoundPrimitiveManager(final String className, long cPtr, boolean cMemoryOwn) {
-  		super(className, CollisionJNI.btGImpactCompoundShape_CompoundPrimitiveManager_SWIGUpcast(cPtr), cMemoryOwn);
-  		swigCPtr = cPtr;
-  	}
-  	
-  	/** Construct a new CompoundPrimitiveManager, normally you should not need this constructor it's intended for low-level usage. */
-  	public CompoundPrimitiveManager(long cPtr, boolean cMemoryOwn) {
-  		this("CompoundPrimitiveManager", cPtr, cMemoryOwn);
-  		construct();
-  	}
-  	
-  	@Override
-  	protected void reset(long cPtr, boolean cMemoryOwn) {
-  		if (!destroyed)
-  			destroy();
-  		super.reset(CollisionJNI.btGImpactCompoundShape_CompoundPrimitiveManager_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);
-  	}
-  	
-  	public static long getCPtr(CompoundPrimitiveManager obj) {
-  		return (obj == null) ? 0 : obj.swigCPtr;
-  	}
-  
-  	@Override
-  	protected void finalize() throws Throwable {
-  		if (!destroyed)
-  			destroy();
-  		super.finalize();
-  	}
-  
-    @Override protected synchronized void delete() {
-  		if (swigCPtr != 0) {
-  			if (swigCMemOwn) {
-  				swigCMemOwn = false;
-  				CollisionJNI.delete_btGImpactCompoundShape_CompoundPrimitiveManager(swigCPtr);
-  			}
-  			swigCPtr = 0;
-  		}
-  		super.delete();
-  	}
-  
-    public void setCompoundShape(btGImpactCompoundShape value) {
-      CollisionJNI.btGImpactCompoundShape_CompoundPrimitiveManager_compoundShape_set(swigCPtr, this, btGImpactCompoundShape.getCPtr(value), value);
-    }
-  
-    public btGImpactCompoundShape getCompoundShape() {
-      long cPtr = CollisionJNI.btGImpactCompoundShape_CompoundPrimitiveManager_compoundShape_get(swigCPtr, this);
-      return (cPtr == 0) ? null : new btGImpactCompoundShape(cPtr, false);
-    }
-  
-    public CompoundPrimitiveManager(btGImpactCompoundShape.CompoundPrimitiveManager compound) {
-      this(CollisionJNI.new_btGImpactCompoundShape_CompoundPrimitiveManager__SWIG_0(btGImpactCompoundShape.CompoundPrimitiveManager.getCPtr(compound), compound), true);
-    }
-  
-    public CompoundPrimitiveManager(btGImpactCompoundShape compoundShape) {
-      this(CollisionJNI.new_btGImpactCompoundShape_CompoundPrimitiveManager__SWIG_1(btGImpactCompoundShape.getCPtr(compoundShape), compoundShape), true);
-    }
-  
-    public CompoundPrimitiveManager() {
-      this(CollisionJNI.new_btGImpactCompoundShape_CompoundPrimitiveManager__SWIG_2(), true);
-    }
-  
-  }
-
-  public btGImpactCompoundShape(boolean children_has_transform) {
-    this(CollisionJNI.new_btGImpactCompoundShape__SWIG_0(children_has_transform), true);
-  }
-
-  public btGImpactCompoundShape() {
-    this(CollisionJNI.new_btGImpactCompoundShape__SWIG_1(), true);
-  }
-
-  public btGImpactCompoundShape.CompoundPrimitiveManager getCompoundPrimitiveManager() {
-    long cPtr = CollisionJNI.btGImpactCompoundShape_getCompoundPrimitiveManager(swigCPtr, this);
-    return (cPtr == 0) ? null : new btGImpactCompoundShape.CompoundPrimitiveManager(cPtr, false);
-  }
-
-  public void addChildShape(Matrix4 localTransform, btCollisionShape shape) {
-    CollisionJNI.btGImpactCompoundShape_addChildShape__SWIG_0(swigCPtr, this, localTransform, btCollisionShape.getCPtr(shape), shape);
-  }
-
-  public void addChildShape(btCollisionShape shape) {
-    CollisionJNI.btGImpactCompoundShape_addChildShape__SWIG_1(swigCPtr, this, btCollisionShape.getCPtr(shape), shape);
-  }
-
-  public btCollisionShape getChildShape(int index) {
-    long cPtr = CollisionJNI.btGImpactCompoundShape_getChildShape__SWIG_0(swigCPtr, this, index);
-    return (cPtr == 0) ? null : btCollisionShape.newDerivedObject(cPtr, false);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactMeshShape.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactMeshShape.java
deleted file mode 100644
index e908249..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactMeshShape.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class btGImpactMeshShape extends btGImpactShapeInterface {
-	private long swigCPtr;
-	
-	protected btGImpactMeshShape(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, CollisionJNI.btGImpactMeshShape_SWIGUpcast(cPtr), cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new btGImpactMeshShape, normally you should not need this constructor it's intended for low-level usage. */
-	public btGImpactMeshShape(long cPtr, boolean cMemoryOwn) {
-		this("btGImpactMeshShape", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(CollisionJNI.btGImpactMeshShape_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);
-	}
-	
-	public static long getCPtr(btGImpactMeshShape obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_btGImpactMeshShape(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public btGImpactMeshShape(btStridingMeshInterface meshInterface) {
-    this(CollisionJNI.new_btGImpactMeshShape(btStridingMeshInterface.getCPtr(meshInterface), meshInterface), true);
-  }
-
-  public btStridingMeshInterface getMeshInterface() {
-    long cPtr = CollisionJNI.btGImpactMeshShape_getMeshInterface__SWIG_0(swigCPtr, this);
-    return (cPtr == 0) ? null : new btStridingMeshInterface(cPtr, false);
-  }
-
-  public int getMeshPartCount() {
-    return CollisionJNI.btGImpactMeshShape_getMeshPartCount(swigCPtr, this);
-  }
-
-  public btGImpactMeshShapePart getMeshPart(int index) {
-    long cPtr = CollisionJNI.btGImpactMeshShape_getMeshPart__SWIG_0(swigCPtr, this, index);
-    return (cPtr == 0) ? null : new btGImpactMeshShapePart(cPtr, false);
-  }
-
-  public btCollisionShape getChildShape(int index) {
-    long cPtr = CollisionJNI.btGImpactMeshShape_getChildShape__SWIG_0(swigCPtr, this, index);
-    return (cPtr == 0) ? null : btCollisionShape.newDerivedObject(cPtr, false);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactMeshShapeData.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactMeshShapeData.java
deleted file mode 100644
index 7bc9297..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactMeshShapeData.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class btGImpactMeshShapeData extends BulletBase {
-	private long swigCPtr;
-	
-	protected btGImpactMeshShapeData(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, cPtr, cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new btGImpactMeshShapeData, normally you should not need this constructor it's intended for low-level usage. */ 
-	public btGImpactMeshShapeData(long cPtr, boolean cMemoryOwn) {
-		this("btGImpactMeshShapeData", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(swigCPtr = cPtr, cMemoryOwn);
-	}
-	
-	public static long getCPtr(btGImpactMeshShapeData obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_btGImpactMeshShapeData(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public void setCollisionShapeData(btCollisionShapeData value) {
-    CollisionJNI.btGImpactMeshShapeData_collisionShapeData_set(swigCPtr, this, btCollisionShapeData.getCPtr(value), value);
-  }
-
-  public btCollisionShapeData getCollisionShapeData() {
-    long cPtr = CollisionJNI.btGImpactMeshShapeData_collisionShapeData_get(swigCPtr, this);
-    return (cPtr == 0) ? null : new btCollisionShapeData(cPtr, false);
-  }
-
-  public void setMeshInterface(btStridingMeshInterfaceData value) {
-    CollisionJNI.btGImpactMeshShapeData_meshInterface_set(swigCPtr, this, btStridingMeshInterfaceData.getCPtr(value), value);
-  }
-
-  public btStridingMeshInterfaceData getMeshInterface() {
-    long cPtr = CollisionJNI.btGImpactMeshShapeData_meshInterface_get(swigCPtr, this);
-    return (cPtr == 0) ? null : new btStridingMeshInterfaceData(cPtr, false);
-  }
-
-  public void setLocalScaling(btVector3FloatData value) {
-    CollisionJNI.btGImpactMeshShapeData_localScaling_set(swigCPtr, this, btVector3FloatData.getCPtr(value), value);
-  }
-
-  public btVector3FloatData getLocalScaling() {
-    long cPtr = CollisionJNI.btGImpactMeshShapeData_localScaling_get(swigCPtr, this);
-    return (cPtr == 0) ? null : new btVector3FloatData(cPtr, false);
-  }
-
-  public void setCollisionMargin(float value) {
-    CollisionJNI.btGImpactMeshShapeData_collisionMargin_set(swigCPtr, this, value);
-  }
-
-  public float getCollisionMargin() {
-    return CollisionJNI.btGImpactMeshShapeData_collisionMargin_get(swigCPtr, this);
-  }
-
-  public void setGimpactSubType(int value) {
-    CollisionJNI.btGImpactMeshShapeData_gimpactSubType_set(swigCPtr, this, value);
-  }
-
-  public int getGimpactSubType() {
-    return CollisionJNI.btGImpactMeshShapeData_gimpactSubType_get(swigCPtr, this);
-  }
-
-  public btGImpactMeshShapeData() {
-    this(CollisionJNI.new_btGImpactMeshShapeData(), true);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactMeshShapePart.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactMeshShapePart.java
deleted file mode 100644
index 00067cf..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactMeshShapePart.java
+++ /dev/null
@@ -1,284 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class btGImpactMeshShapePart extends btGImpactShapeInterface {
-	private long swigCPtr;
-	
-	protected btGImpactMeshShapePart(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, CollisionJNI.btGImpactMeshShapePart_SWIGUpcast(cPtr), cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new btGImpactMeshShapePart, normally you should not need this constructor it's intended for low-level usage. */
-	public btGImpactMeshShapePart(long cPtr, boolean cMemoryOwn) {
-		this("btGImpactMeshShapePart", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(CollisionJNI.btGImpactMeshShapePart_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);
-	}
-	
-	public static long getCPtr(btGImpactMeshShapePart obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_btGImpactMeshShapePart(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  static public class TrimeshPrimitiveManager extends btPrimitiveManagerBase {
-  	private long swigCPtr;
-  	
-  	protected TrimeshPrimitiveManager(final String className, long cPtr, boolean cMemoryOwn) {
-  		super(className, CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_SWIGUpcast(cPtr), cMemoryOwn);
-  		swigCPtr = cPtr;
-  	}
-  	
-  	/** Construct a new TrimeshPrimitiveManager, normally you should not need this constructor it's intended for low-level usage. */
-  	public TrimeshPrimitiveManager(long cPtr, boolean cMemoryOwn) {
-  		this("TrimeshPrimitiveManager", cPtr, cMemoryOwn);
-  		construct();
-  	}
-  	
-  	@Override
-  	protected void reset(long cPtr, boolean cMemoryOwn) {
-  		if (!destroyed)
-  			destroy();
-  		super.reset(CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);
-  	}
-  	
-  	public static long getCPtr(TrimeshPrimitiveManager obj) {
-  		return (obj == null) ? 0 : obj.swigCPtr;
-  	}
-  
-  	@Override
-  	protected void finalize() throws Throwable {
-  		if (!destroyed)
-  			destroy();
-  		super.finalize();
-  	}
-  
-    @Override protected synchronized void delete() {
-  		if (swigCPtr != 0) {
-  			if (swigCMemOwn) {
-  				swigCMemOwn = false;
-  				CollisionJNI.delete_btGImpactMeshShapePart_TrimeshPrimitiveManager(swigCPtr);
-  			}
-  			swigCPtr = 0;
-  		}
-  		super.delete();
-  	}
-  
-    public void setMargin(float value) {
-      CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_margin_set(swigCPtr, this, value);
-    }
-  
-    public float getMargin() {
-      return CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_margin_get(swigCPtr, this);
-    }
-  
-    public void setMeshInterface(btStridingMeshInterface value) {
-      CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_meshInterface_set(swigCPtr, this, btStridingMeshInterface.getCPtr(value), value);
-    }
-  
-    public btStridingMeshInterface getMeshInterface() {
-      long cPtr = CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_meshInterface_get(swigCPtr, this);
-      return (cPtr == 0) ? null : new btStridingMeshInterface(cPtr, false);
-    }
-  
-    public void setScale(btVector3 value) {
-      CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_scale_set(swigCPtr, this, btVector3.getCPtr(value), value);
-    }
-  
-    public btVector3 getScale() {
-      long cPtr = CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_scale_get(swigCPtr, this);
-      return (cPtr == 0) ? null : new btVector3(cPtr, false);
-    }
-  
-    public void setPart(int value) {
-      CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_part_set(swigCPtr, this, value);
-    }
-  
-    public int getPart() {
-      return CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_part_get(swigCPtr, this);
-    }
-  
-    public void setLock_count(int value) {
-      CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_lock_count_set(swigCPtr, this, value);
-    }
-  
-    public int getLock_count() {
-      return CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_lock_count_get(swigCPtr, this);
-    }
-  
-    public void setVertexbase(java.nio.ByteBuffer value) {
-      assert value.isDirect() : "Buffer must be allocated direct.";
-      {
-        CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_vertexbase_set(swigCPtr, this, value);
-      }
-    }
-  
-    public java.nio.ByteBuffer getVertexbase() {
-      return CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_vertexbase_get(swigCPtr, this);
-  }
-  
-    public void setNumverts(int value) {
-      CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_numverts_set(swigCPtr, this, value);
-    }
-  
-    public int getNumverts() {
-      return CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_numverts_get(swigCPtr, this);
-    }
-  
-    public void setType(int value) {
-      CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_type_set(swigCPtr, this, value);
-    }
-  
-    public int getType() {
-      return CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_type_get(swigCPtr, this);
-    }
-  
-    public void setStride(int value) {
-      CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_stride_set(swigCPtr, this, value);
-    }
-  
-    public int getStride() {
-      return CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_stride_get(swigCPtr, this);
-    }
-  
-    public void setIndexbase(java.nio.ByteBuffer value) {
-      assert value.isDirect() : "Buffer must be allocated direct.";
-      {
-        CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_indexbase_set(swigCPtr, this, value);
-      }
-    }
-  
-    public java.nio.ByteBuffer getIndexbase() {
-      return CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_indexbase_get(swigCPtr, this);
-  }
-  
-    public void setIndexstride(int value) {
-      CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_indexstride_set(swigCPtr, this, value);
-    }
-  
-    public int getIndexstride() {
-      return CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_indexstride_get(swigCPtr, this);
-    }
-  
-    public void setNumfaces(int value) {
-      CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_numfaces_set(swigCPtr, this, value);
-    }
-  
-    public int getNumfaces() {
-      return CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_numfaces_get(swigCPtr, this);
-    }
-  
-    public void setIndicestype(int value) {
-      CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_indicestype_set(swigCPtr, this, value);
-    }
-  
-    public int getIndicestype() {
-      return CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_indicestype_get(swigCPtr, this);
-    }
-  
-    public TrimeshPrimitiveManager() {
-      this(CollisionJNI.new_btGImpactMeshShapePart_TrimeshPrimitiveManager__SWIG_0(), true);
-    }
-  
-    public TrimeshPrimitiveManager(btGImpactMeshShapePart.TrimeshPrimitiveManager manager) {
-      this(CollisionJNI.new_btGImpactMeshShapePart_TrimeshPrimitiveManager__SWIG_1(btGImpactMeshShapePart.TrimeshPrimitiveManager.getCPtr(manager), manager), true);
-    }
-  
-    public TrimeshPrimitiveManager(btStridingMeshInterface meshInterface, int part) {
-      this(CollisionJNI.new_btGImpactMeshShapePart_TrimeshPrimitiveManager__SWIG_2(btStridingMeshInterface.getCPtr(meshInterface), meshInterface, part), true);
-    }
-  
-    public void lock() {
-      CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_lock(swigCPtr, this);
-    }
-  
-    public void unlock() {
-      CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_unlock(swigCPtr, this);
-    }
-  
-    public int get_vertex_count() {
-      return CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_get_vertex_count(swigCPtr, this);
-    }
-  
-    public void get_indices(int face_index, SWIGTYPE_p_unsigned_int i0, SWIGTYPE_p_unsigned_int i1, SWIGTYPE_p_unsigned_int i2) {
-      CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_get_indices(swigCPtr, this, face_index, SWIGTYPE_p_unsigned_int.getCPtr(i0), SWIGTYPE_p_unsigned_int.getCPtr(i1), SWIGTYPE_p_unsigned_int.getCPtr(i2));
-    }
-  
-    public void get_vertex(long vertex_index, Vector3 vertex) {
-      CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_get_vertex(swigCPtr, this, vertex_index, vertex);
-    }
-  
-    public void get_bullet_triangle(int prim_index, btTriangleShapeEx triangle) {
-      CollisionJNI.btGImpactMeshShapePart_TrimeshPrimitiveManager_get_bullet_triangle(swigCPtr, this, prim_index, btTriangleShapeEx.getCPtr(triangle), triangle);
-    }
-  
-  }
-
-  public btGImpactMeshShapePart() {
-    this(CollisionJNI.new_btGImpactMeshShapePart__SWIG_0(), true);
-  }
-
-  public btGImpactMeshShapePart(btStridingMeshInterface meshInterface, int part) {
-    this(CollisionJNI.new_btGImpactMeshShapePart__SWIG_1(btStridingMeshInterface.getCPtr(meshInterface), meshInterface, part), true);
-  }
-
-  public btCollisionShape getChildShape(int index) {
-    long cPtr = CollisionJNI.btGImpactMeshShapePart_getChildShape__SWIG_0(swigCPtr, this, index);
-    return (cPtr == 0) ? null : btCollisionShape.newDerivedObject(cPtr, false);
-  }
-
-  public btGImpactMeshShapePart.TrimeshPrimitiveManager getTrimeshPrimitiveManager() {
-    long cPtr = CollisionJNI.btGImpactMeshShapePart_getTrimeshPrimitiveManager(swigCPtr, this);
-    return (cPtr == 0) ? null : new btGImpactMeshShapePart.TrimeshPrimitiveManager(cPtr, false);
-  }
-
-  public int getVertexCount() {
-    return CollisionJNI.btGImpactMeshShapePart_getVertexCount(swigCPtr, this);
-  }
-
-  public void getVertex(int vertex_index, Vector3 vertex) {
-    CollisionJNI.btGImpactMeshShapePart_getVertex(swigCPtr, this, vertex_index, vertex);
-  }
-
-  public int getPart() {
-    return CollisionJNI.btGImpactMeshShapePart_getPart(swigCPtr, this);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactQuantizedBvh.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactQuantizedBvh.java
deleted file mode 100644
index 2be3604..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactQuantizedBvh.java
+++ /dev/null
@@ -1,160 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class btGImpactQuantizedBvh extends BulletBase {
-	private long swigCPtr;
-	
-	protected btGImpactQuantizedBvh(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, cPtr, cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new btGImpactQuantizedBvh, normally you should not need this constructor it's intended for low-level usage. */ 
-	public btGImpactQuantizedBvh(long cPtr, boolean cMemoryOwn) {
-		this("btGImpactQuantizedBvh", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(swigCPtr = cPtr, cMemoryOwn);
-	}
-	
-	public static long getCPtr(btGImpactQuantizedBvh obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_btGImpactQuantizedBvh(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public btGImpactQuantizedBvh() {
-    this(CollisionJNI.new_btGImpactQuantizedBvh__SWIG_0(), true);
-  }
-
-  public btGImpactQuantizedBvh(btPrimitiveManagerBase primitive_manager) {
-    this(CollisionJNI.new_btGImpactQuantizedBvh__SWIG_1(btPrimitiveManagerBase.getCPtr(primitive_manager), primitive_manager), true);
-  }
-
-  public btAABB getGlobalBox() {
-    return new btAABB(CollisionJNI.btGImpactQuantizedBvh_getGlobalBox(swigCPtr, this), true);
-  }
-
-  public void setPrimitiveManager(btPrimitiveManagerBase primitive_manager) {
-    CollisionJNI.btGImpactQuantizedBvh_setPrimitiveManager(swigCPtr, this, btPrimitiveManagerBase.getCPtr(primitive_manager), primitive_manager);
-  }
-
-  public btPrimitiveManagerBase getPrimitiveManager() {
-    long cPtr = CollisionJNI.btGImpactQuantizedBvh_getPrimitiveManager(swigCPtr, this);
-    return (cPtr == 0) ? null : new btPrimitiveManagerBase(cPtr, false);
-  }
-
-  public void update() {
-    CollisionJNI.btGImpactQuantizedBvh_update(swigCPtr, this);
-  }
-
-  public void buildSet() {
-    CollisionJNI.btGImpactQuantizedBvh_buildSet(swigCPtr, this);
-  }
-
-  public boolean boxQuery(btAABB box, SWIGTYPE_p_btAlignedObjectArrayT_int_t collided_results) {
-    return CollisionJNI.btGImpactQuantizedBvh_boxQuery(swigCPtr, this, btAABB.getCPtr(box), box, SWIGTYPE_p_btAlignedObjectArrayT_int_t.getCPtr(collided_results));
-  }
-
-  public boolean boxQueryTrans(btAABB box, Matrix4 transform, SWIGTYPE_p_btAlignedObjectArrayT_int_t collided_results) {
-    return CollisionJNI.btGImpactQuantizedBvh_boxQueryTrans(swigCPtr, this, btAABB.getCPtr(box), box, transform, SWIGTYPE_p_btAlignedObjectArrayT_int_t.getCPtr(collided_results));
-  }
-
-  public boolean rayQuery(Vector3 ray_dir, Vector3 ray_origin, SWIGTYPE_p_btAlignedObjectArrayT_int_t collided_results) {
-    return CollisionJNI.btGImpactQuantizedBvh_rayQuery(swigCPtr, this, ray_dir, ray_origin, SWIGTYPE_p_btAlignedObjectArrayT_int_t.getCPtr(collided_results));
-  }
-
-  public boolean hasHierarchy() {
-    return CollisionJNI.btGImpactQuantizedBvh_hasHierarchy(swigCPtr, this);
-  }
-
-  public boolean isTrimesh() {
-    return CollisionJNI.btGImpactQuantizedBvh_isTrimesh(swigCPtr, this);
-  }
-
-  public int getNodeCount() {
-    return CollisionJNI.btGImpactQuantizedBvh_getNodeCount(swigCPtr, this);
-  }
-
-  public boolean isLeafNode(int nodeindex) {
-    return CollisionJNI.btGImpactQuantizedBvh_isLeafNode(swigCPtr, this, nodeindex);
-  }
-
-  public int getNodeData(int nodeindex) {
-    return CollisionJNI.btGImpactQuantizedBvh_getNodeData(swigCPtr, this, nodeindex);
-  }
-
-  public void getNodeBound(int nodeindex, btAABB bound) {
-    CollisionJNI.btGImpactQuantizedBvh_getNodeBound(swigCPtr, this, nodeindex, btAABB.getCPtr(bound), bound);
-  }
-
-  public void setNodeBound(int nodeindex, btAABB bound) {
-    CollisionJNI.btGImpactQuantizedBvh_setNodeBound(swigCPtr, this, nodeindex, btAABB.getCPtr(bound), bound);
-  }
-
-  public int getLeftNode(int nodeindex) {
-    return CollisionJNI.btGImpactQuantizedBvh_getLeftNode(swigCPtr, this, nodeindex);
-  }
-
-  public int getRightNode(int nodeindex) {
-    return CollisionJNI.btGImpactQuantizedBvh_getRightNode(swigCPtr, this, nodeindex);
-  }
-
-  public int getEscapeNodeIndex(int nodeindex) {
-    return CollisionJNI.btGImpactQuantizedBvh_getEscapeNodeIndex(swigCPtr, this, nodeindex);
-  }
-
-  public void getNodeTriangle(int nodeindex, btPrimitiveTriangle triangle) {
-    CollisionJNI.btGImpactQuantizedBvh_getNodeTriangle(swigCPtr, this, nodeindex, btPrimitiveTriangle.getCPtr(triangle), triangle);
-  }
-
-  public BT_QUANTIZED_BVH_NODE get_node_pointer(int index) {
-    long cPtr = CollisionJNI.btGImpactQuantizedBvh_get_node_pointer__SWIG_0(swigCPtr, this, index);
-    return (cPtr == 0) ? null : new BT_QUANTIZED_BVH_NODE(cPtr, false);
-  }
-
-  public BT_QUANTIZED_BVH_NODE get_node_pointer() {
-    long cPtr = CollisionJNI.btGImpactQuantizedBvh_get_node_pointer__SWIG_1(swigCPtr, this);
-    return (cPtr == 0) ? null : new BT_QUANTIZED_BVH_NODE(cPtr, false);
-  }
-
-  public static void find_collision(btGImpactQuantizedBvh boxset1, Matrix4 trans1, btGImpactQuantizedBvh boxset2, Matrix4 trans2, btPairSet collision_pairs) {
-    CollisionJNI.btGImpactQuantizedBvh_find_collision(btGImpactQuantizedBvh.getCPtr(boxset1), boxset1, trans1, btGImpactQuantizedBvh.getCPtr(boxset2), boxset2, trans2, btPairSet.getCPtr(collision_pairs), collision_pairs);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactShapeInterface.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactShapeInterface.java
deleted file mode 100644
index c91e76b..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGImpactShapeInterface.java
+++ /dev/null
@@ -1,156 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class btGImpactShapeInterface extends btConcaveShape {
-	private long swigCPtr;
-	
-	protected btGImpactShapeInterface(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, CollisionJNI.btGImpactShapeInterface_SWIGUpcast(cPtr), cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new btGImpactShapeInterface, normally you should not need this constructor it's intended for low-level usage. */
-	public btGImpactShapeInterface(long cPtr, boolean cMemoryOwn) {
-		this("btGImpactShapeInterface", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(CollisionJNI.btGImpactShapeInterface_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);
-	}
-	
-	public static long getCPtr(btGImpactShapeInterface obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_btGImpactShapeInterface(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public void updateBound() {
-    CollisionJNI.btGImpactShapeInterface_updateBound(swigCPtr, this);
-  }
-
-  public void postUpdate() {
-    CollisionJNI.btGImpactShapeInterface_postUpdate(swigCPtr, this);
-  }
-
-  public btAABB getLocalBox() {
-    return new btAABB(CollisionJNI.btGImpactShapeInterface_getLocalBox(swigCPtr, this), false);
-  }
-
-  public int getShapeType() {
-    return CollisionJNI.btGImpactShapeInterface_getShapeType(swigCPtr, this);
-  }
-
-  public int getGImpactShapeType() {
-    return CollisionJNI.btGImpactShapeInterface_getGImpactShapeType(swigCPtr, this);
-  }
-
-  public btGImpactQuantizedBvh getBoxSet() {
-    long cPtr = CollisionJNI.btGImpactShapeInterface_getBoxSet(swigCPtr, this);
-    return (cPtr == 0) ? null : new btGImpactQuantizedBvh(cPtr, false);
-  }
-
-  public boolean hasBoxSet() {
-    return CollisionJNI.btGImpactShapeInterface_hasBoxSet(swigCPtr, this);
-  }
-
-  public btPrimitiveManagerBase getPrimitiveManager() {
-    long cPtr = CollisionJNI.btGImpactShapeInterface_getPrimitiveManager(swigCPtr, this);
-    return (cPtr == 0) ? null : new btPrimitiveManagerBase(cPtr, false);
-  }
-
-  public int getNumChildShapes() {
-    return CollisionJNI.btGImpactShapeInterface_getNumChildShapes(swigCPtr, this);
-  }
-
-  public boolean childrenHasTransform() {
-    return CollisionJNI.btGImpactShapeInterface_childrenHasTransform(swigCPtr, this);
-  }
-
-  public boolean needsRetrieveTriangles() {
-    return CollisionJNI.btGImpactShapeInterface_needsRetrieveTriangles(swigCPtr, this);
-  }
-
-  public boolean needsRetrieveTetrahedrons() {
-    return CollisionJNI.btGImpactShapeInterface_needsRetrieveTetrahedrons(swigCPtr, this);
-  }
-
-  public void getBulletTriangle(int prim_index, btTriangleShapeEx triangle) {
-    CollisionJNI.btGImpactShapeInterface_getBulletTriangle(swigCPtr, this, prim_index, btTriangleShapeEx.getCPtr(triangle), triangle);
-  }
-
-  public void getBulletTetrahedron(int prim_index, btTetrahedronShapeEx tetrahedron) {
-    CollisionJNI.btGImpactShapeInterface_getBulletTetrahedron(swigCPtr, this, prim_index, btTetrahedronShapeEx.getCPtr(tetrahedron), tetrahedron);
-  }
-
-  public void lockChildShapes() {
-    CollisionJNI.btGImpactShapeInterface_lockChildShapes(swigCPtr, this);
-  }
-
-  public void unlockChildShapes() {
-    CollisionJNI.btGImpactShapeInterface_unlockChildShapes(swigCPtr, this);
-  }
-
-  public void getPrimitiveTriangle(int index, btPrimitiveTriangle triangle) {
-    CollisionJNI.btGImpactShapeInterface_getPrimitiveTriangle(swigCPtr, this, index, btPrimitiveTriangle.getCPtr(triangle), triangle);
-  }
-
-  public void getChildAabb(int child_index, Matrix4 t, Vector3 aabbMin, Vector3 aabbMax) {
-    CollisionJNI.btGImpactShapeInterface_getChildAabb(swigCPtr, this, child_index, t, aabbMin, aabbMax);
-  }
-
-  public btCollisionShape getChildShape(int index) {
-    long cPtr = CollisionJNI.btGImpactShapeInterface_getChildShape__SWIG_0(swigCPtr, this, index);
-    return (cPtr == 0) ? null : btCollisionShape.newDerivedObject(cPtr, false);
-  }
-
-  public Matrix4 getChildTransform(int index) {
-	return CollisionJNI.btGImpactShapeInterface_getChildTransform(swigCPtr, this, index);
-}
-
-  public void setChildTransform(int index, Matrix4 transform) {
-    CollisionJNI.btGImpactShapeInterface_setChildTransform(swigCPtr, this, index, transform);
-  }
-
-  public void rayTest(Vector3 rayFrom, Vector3 rayTo, RayResultCallback resultCallback) {
-    CollisionJNI.btGImpactShapeInterface_rayTest(swigCPtr, this, rayFrom, rayTo, RayResultCallback.getCPtr(resultCallback), resultCallback);
-  }
-
-  public void processAllTrianglesRay(btTriangleCallback arg0, Vector3 arg1, Vector3 arg2) {
-    CollisionJNI.btGImpactShapeInterface_processAllTrianglesRay(swigCPtr, this, btTriangleCallback.getCPtr(arg0), arg0, arg1, arg2);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGenericMemoryPool.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGenericMemoryPool.java
deleted file mode 100644
index 71fd23a..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGenericMemoryPool.java
+++ /dev/null
@@ -1,150 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class btGenericMemoryPool extends BulletBase {
-	private long swigCPtr;
-	
-	protected btGenericMemoryPool(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, cPtr, cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new btGenericMemoryPool, normally you should not need this constructor it's intended for low-level usage. */ 
-	public btGenericMemoryPool(long cPtr, boolean cMemoryOwn) {
-		this("btGenericMemoryPool", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(swigCPtr = cPtr, cMemoryOwn);
-	}
-	
-	public static long getCPtr(btGenericMemoryPool obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_btGenericMemoryPool(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public void setPool(java.nio.ByteBuffer value) {
-    assert value.isDirect() : "Buffer must be allocated direct.";
-    {
-      CollisionJNI.btGenericMemoryPool_pool_set(swigCPtr, this, value);
-    }
-  }
-
-  public java.nio.ByteBuffer getPool() {
-    return CollisionJNI.btGenericMemoryPool_pool_get(swigCPtr, this);
-}
-
-  public void setFree_nodes(SWIGTYPE_p_size_t value) {
-    CollisionJNI.btGenericMemoryPool_free_nodes_set(swigCPtr, this, SWIGTYPE_p_size_t.getCPtr(value));
-  }
-
-  public SWIGTYPE_p_size_t getFree_nodes() {
-    long cPtr = CollisionJNI.btGenericMemoryPool_free_nodes_get(swigCPtr, this);
-    return (cPtr == 0) ? null : new SWIGTYPE_p_size_t(cPtr, false);
-  }
-
-  public void setAllocated_sizes(SWIGTYPE_p_size_t value) {
-    CollisionJNI.btGenericMemoryPool_allocated_sizes_set(swigCPtr, this, SWIGTYPE_p_size_t.getCPtr(value));
-  }
-
-  public SWIGTYPE_p_size_t getAllocated_sizes() {
-    long cPtr = CollisionJNI.btGenericMemoryPool_allocated_sizes_get(swigCPtr, this);
-    return (cPtr == 0) ? null : new SWIGTYPE_p_size_t(cPtr, false);
-  }
-
-  public void setAllocated_count(long value) {
-    CollisionJNI.btGenericMemoryPool_allocated_count_set(swigCPtr, this, value);
-  }
-
-  public long getAllocated_count() {
-    return CollisionJNI.btGenericMemoryPool_allocated_count_get(swigCPtr, this);
-  }
-
-  public void setFree_nodes_count(long value) {
-    CollisionJNI.btGenericMemoryPool_free_nodes_count_set(swigCPtr, this, value);
-  }
-
-  public long getFree_nodes_count() {
-    return CollisionJNI.btGenericMemoryPool_free_nodes_count_get(swigCPtr, this);
-  }
-
-  public void init_pool(long element_size, long element_count) {
-    CollisionJNI.btGenericMemoryPool_init_pool(swigCPtr, this, element_size, element_count);
-  }
-
-  public void end_pool() {
-    CollisionJNI.btGenericMemoryPool_end_pool(swigCPtr, this);
-  }
-
-  public btGenericMemoryPool(long element_size, long element_count) {
-    this(CollisionJNI.new_btGenericMemoryPool(element_size, element_count), true);
-  }
-
-  public long get_pool_capacity() {
-    return CollisionJNI.btGenericMemoryPool_get_pool_capacity(swigCPtr, this);
-  }
-
-  public long gem_element_size() {
-    return CollisionJNI.btGenericMemoryPool_gem_element_size(swigCPtr, this);
-  }
-
-  public long get_max_element_count() {
-    return CollisionJNI.btGenericMemoryPool_get_max_element_count(swigCPtr, this);
-  }
-
-  public long get_allocated_count() {
-    return CollisionJNI.btGenericMemoryPool_get_allocated_count(swigCPtr, this);
-  }
-
-  public long get_free_positions_count() {
-    return CollisionJNI.btGenericMemoryPool_get_free_positions_count(swigCPtr, this);
-  }
-
-  public long get_element_data(long element_index) {
-    return CollisionJNI.btGenericMemoryPool_get_element_data(swigCPtr, this, element_index);
-  }
-
-  public long allocate(long size_bytes) {
-    return CollisionJNI.btGenericMemoryPool_allocate(swigCPtr, this, size_bytes);
-  }
-
-  public boolean freeMemory(long pointer) {
-    return CollisionJNI.btGenericMemoryPool_freeMemory(swigCPtr, this, pointer);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGenericPoolAllocator.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGenericPoolAllocator.java
deleted file mode 100644
index 6397316..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btGenericPoolAllocator.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class btGenericPoolAllocator extends BulletBase {
-	private long swigCPtr;
-	
-	protected btGenericPoolAllocator(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, cPtr, cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new btGenericPoolAllocator, normally you should not need this constructor it's intended for low-level usage. */ 
-	public btGenericPoolAllocator(long cPtr, boolean cMemoryOwn) {
-		this("btGenericPoolAllocator", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(swigCPtr = cPtr, cMemoryOwn);
-	}
-	
-	public static long getCPtr(btGenericPoolAllocator obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_btGenericPoolAllocator(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public void setPools(SWIGTYPE_p_p_btGenericMemoryPool value) {
-    CollisionJNI.btGenericPoolAllocator_pools_set(swigCPtr, this, SWIGTYPE_p_p_btGenericMemoryPool.getCPtr(value));
-  }
-
-  public SWIGTYPE_p_p_btGenericMemoryPool getPools() {
-    long cPtr = CollisionJNI.btGenericPoolAllocator_pools_get(swigCPtr, this);
-    return (cPtr == 0) ? null : new SWIGTYPE_p_p_btGenericMemoryPool(cPtr, false);
-  }
-
-  public void setPool_count(long value) {
-    CollisionJNI.btGenericPoolAllocator_pool_count_set(swigCPtr, this, value);
-  }
-
-  public long getPool_count() {
-    return CollisionJNI.btGenericPoolAllocator_pool_count_get(swigCPtr, this);
-  }
-
-  public long get_pool_capacity() {
-    return CollisionJNI.btGenericPoolAllocator_get_pool_capacity(swigCPtr, this);
-  }
-
-  public btGenericPoolAllocator(long pool_element_size, long pool_element_count) {
-    this(CollisionJNI.new_btGenericPoolAllocator(pool_element_size, pool_element_count), true);
-  }
-
-  public long allocate(long size_bytes) {
-    return CollisionJNI.btGenericPoolAllocator_allocate(swigCPtr, this, size_bytes);
-  }
-
-  public boolean freeMemory(long pointer) {
-    return CollisionJNI.btGenericPoolAllocator_freeMemory(swigCPtr, this, pointer);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btPairSet.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btPairSet.java
deleted file mode 100644
index 997594a..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btPairSet.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class btPairSet extends BulletBase {
-	private long swigCPtr;
-	
-	protected btPairSet(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, cPtr, cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new btPairSet, normally you should not need this constructor it's intended for low-level usage. */ 
-	public btPairSet(long cPtr, boolean cMemoryOwn) {
-		this("btPairSet", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(swigCPtr = cPtr, cMemoryOwn);
-	}
-	
-	public static long getCPtr(btPairSet obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_btPairSet(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public btPairSet() {
-    this(CollisionJNI.new_btPairSet(), true);
-  }
-
-  public void push_pair(int index1, int index2) {
-    CollisionJNI.btPairSet_push_pair(swigCPtr, this, index1, index2);
-  }
-
-  public void push_pair_inv(int index1, int index2) {
-    CollisionJNI.btPairSet_push_pair_inv(swigCPtr, this, index1, index2);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btPrimitiveManagerBase.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btPrimitiveManagerBase.java
deleted file mode 100644
index 813eac0..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btPrimitiveManagerBase.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class btPrimitiveManagerBase extends BulletBase {
-	private long swigCPtr;
-	
-	protected btPrimitiveManagerBase(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, cPtr, cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new btPrimitiveManagerBase, normally you should not need this constructor it's intended for low-level usage. */ 
-	public btPrimitiveManagerBase(long cPtr, boolean cMemoryOwn) {
-		this("btPrimitiveManagerBase", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(swigCPtr = cPtr, cMemoryOwn);
-	}
-	
-	public static long getCPtr(btPrimitiveManagerBase obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_btPrimitiveManagerBase(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public boolean is_trimesh() {
-    return CollisionJNI.btPrimitiveManagerBase_is_trimesh(swigCPtr, this);
-  }
-
-  public int get_primitive_count() {
-    return CollisionJNI.btPrimitiveManagerBase_get_primitive_count(swigCPtr, this);
-  }
-
-  public void get_primitive_box(int prim_index, btAABB primbox) {
-    CollisionJNI.btPrimitiveManagerBase_get_primitive_box(swigCPtr, this, prim_index, btAABB.getCPtr(primbox), primbox);
-  }
-
-  public void get_primitive_triangle(int prim_index, btPrimitiveTriangle triangle) {
-    CollisionJNI.btPrimitiveManagerBase_get_primitive_triangle(swigCPtr, this, prim_index, btPrimitiveTriangle.getCPtr(triangle), triangle);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btPrimitiveTriangle.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btPrimitiveTriangle.java
deleted file mode 100644
index 15bc397..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btPrimitiveTriangle.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class btPrimitiveTriangle extends BulletBase {
-	private long swigCPtr;
-	
-	protected btPrimitiveTriangle(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, cPtr, cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new btPrimitiveTriangle, normally you should not need this constructor it's intended for low-level usage. */ 
-	public btPrimitiveTriangle(long cPtr, boolean cMemoryOwn) {
-		this("btPrimitiveTriangle", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(swigCPtr = cPtr, cMemoryOwn);
-	}
-	
-	public static long getCPtr(btPrimitiveTriangle obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_btPrimitiveTriangle(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public void setVertices(btVector3 value) {
-    CollisionJNI.btPrimitiveTriangle_vertices_set(swigCPtr, this, btVector3.getCPtr(value), value);
-  }
-
-  public btVector3 getVertices() {
-    long cPtr = CollisionJNI.btPrimitiveTriangle_vertices_get(swigCPtr, this);
-    return (cPtr == 0) ? null : new btVector3(cPtr, false);
-  }
-
-  public void setPlane(btVector4 value) {
-    CollisionJNI.btPrimitiveTriangle_plane_set(swigCPtr, this, btVector4.getCPtr(value), value);
-  }
-
-  public btVector4 getPlane() {
-    long cPtr = CollisionJNI.btPrimitiveTriangle_plane_get(swigCPtr, this);
-    return (cPtr == 0) ? null : new btVector4(cPtr, false);
-  }
-
-  public void setMargin(float value) {
-    CollisionJNI.btPrimitiveTriangle_margin_set(swigCPtr, this, value);
-  }
-
-  public float getMargin() {
-    return CollisionJNI.btPrimitiveTriangle_margin_get(swigCPtr, this);
-  }
-
-  public void setDummy(float value) {
-    CollisionJNI.btPrimitiveTriangle_dummy_set(swigCPtr, this, value);
-  }
-
-  public float getDummy() {
-    return CollisionJNI.btPrimitiveTriangle_dummy_get(swigCPtr, this);
-  }
-
-  public btPrimitiveTriangle() {
-    this(CollisionJNI.new_btPrimitiveTriangle(), true);
-  }
-
-  public void buildTriPlane() {
-    CollisionJNI.btPrimitiveTriangle_buildTriPlane(swigCPtr, this);
-  }
-
-  public boolean overlap_test_conservative(btPrimitiveTriangle other) {
-    return CollisionJNI.btPrimitiveTriangle_overlap_test_conservative(swigCPtr, this, btPrimitiveTriangle.getCPtr(other), other);
-  }
-
-  public void get_edge_plane(int edge_index, btVector4 plane) {
-    CollisionJNI.btPrimitiveTriangle_get_edge_plane(swigCPtr, this, edge_index, btVector4.getCPtr(plane), plane);
-  }
-
-  public void applyTransform(Matrix4 t) {
-    CollisionJNI.btPrimitiveTriangle_applyTransform(swigCPtr, this, t);
-  }
-
-  public int clip_triangle(btPrimitiveTriangle other, btVector3 clipped_points) {
-    return CollisionJNI.btPrimitiveTriangle_clip_triangle(swigCPtr, this, btPrimitiveTriangle.getCPtr(other), other, btVector3.getCPtr(clipped_points), clipped_points);
-  }
-
-  public boolean find_triangle_collision_clip_method(btPrimitiveTriangle other, GIM_TRIANGLE_CONTACT contacts) {
-    return CollisionJNI.btPrimitiveTriangle_find_triangle_collision_clip_method(swigCPtr, this, btPrimitiveTriangle.getCPtr(other), other, GIM_TRIANGLE_CONTACT.getCPtr(contacts), contacts);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btQuantizedBvhTree.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btQuantizedBvhTree.java
deleted file mode 100644
index b097995..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btQuantizedBvhTree.java
+++ /dev/null
@@ -1,130 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class btQuantizedBvhTree extends BulletBase {
-	private long swigCPtr;
-	
-	protected btQuantizedBvhTree(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, cPtr, cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new btQuantizedBvhTree, normally you should not need this constructor it's intended for low-level usage. */ 
-	public btQuantizedBvhTree(long cPtr, boolean cMemoryOwn) {
-		this("btQuantizedBvhTree", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(swigCPtr = cPtr, cMemoryOwn);
-	}
-	
-	public static long getCPtr(btQuantizedBvhTree obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_btQuantizedBvhTree(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public btQuantizedBvhTree() {
-    this(CollisionJNI.new_btQuantizedBvhTree(), true);
-  }
-
-  public void build_tree(GIM_BVH_DATA_ARRAY primitive_boxes) {
-    CollisionJNI.btQuantizedBvhTree_build_tree(swigCPtr, this, GIM_BVH_DATA_ARRAY.getCPtr(primitive_boxes), primitive_boxes);
-  }
-
-  public void quantizePoint(java.nio.IntBuffer quantizedpoint, Vector3 point) {
-    assert quantizedpoint.isDirect() : "Buffer must be allocated direct.";
-    {
-      CollisionJNI.btQuantizedBvhTree_quantizePoint(swigCPtr, this, quantizedpoint, point);
-    }
-  }
-
-  public boolean testQuantizedBoxOverlapp(int node_index, java.nio.IntBuffer quantizedMin, java.nio.IntBuffer quantizedMax) {
-    assert quantizedMin.isDirect() : "Buffer must be allocated direct.";
-    assert quantizedMax.isDirect() : "Buffer must be allocated direct.";
-    {
-      return CollisionJNI.btQuantizedBvhTree_testQuantizedBoxOverlapp(swigCPtr, this, node_index, quantizedMin, quantizedMax);
-    }
-  }
-
-  public void clearNodes() {
-    CollisionJNI.btQuantizedBvhTree_clearNodes(swigCPtr, this);
-  }
-
-  public int getNodeCount() {
-    return CollisionJNI.btQuantizedBvhTree_getNodeCount(swigCPtr, this);
-  }
-
-  public boolean isLeafNode(int nodeindex) {
-    return CollisionJNI.btQuantizedBvhTree_isLeafNode(swigCPtr, this, nodeindex);
-  }
-
-  public int getNodeData(int nodeindex) {
-    return CollisionJNI.btQuantizedBvhTree_getNodeData(swigCPtr, this, nodeindex);
-  }
-
-  public void getNodeBound(int nodeindex, btAABB bound) {
-    CollisionJNI.btQuantizedBvhTree_getNodeBound(swigCPtr, this, nodeindex, btAABB.getCPtr(bound), bound);
-  }
-
-  public void setNodeBound(int nodeindex, btAABB bound) {
-    CollisionJNI.btQuantizedBvhTree_setNodeBound(swigCPtr, this, nodeindex, btAABB.getCPtr(bound), bound);
-  }
-
-  public int getLeftNode(int nodeindex) {
-    return CollisionJNI.btQuantizedBvhTree_getLeftNode(swigCPtr, this, nodeindex);
-  }
-
-  public int getRightNode(int nodeindex) {
-    return CollisionJNI.btQuantizedBvhTree_getRightNode(swigCPtr, this, nodeindex);
-  }
-
-  public int getEscapeNodeIndex(int nodeindex) {
-    return CollisionJNI.btQuantizedBvhTree_getEscapeNodeIndex(swigCPtr, this, nodeindex);
-  }
-
-  public BT_QUANTIZED_BVH_NODE get_node_pointer(int index) {
-    long cPtr = CollisionJNI.btQuantizedBvhTree_get_node_pointer__SWIG_0(swigCPtr, this, index);
-    return (cPtr == 0) ? null : new BT_QUANTIZED_BVH_NODE(cPtr, false);
-  }
-
-  public BT_QUANTIZED_BVH_NODE get_node_pointer() {
-    long cPtr = CollisionJNI.btQuantizedBvhTree_get_node_pointer__SWIG_1(swigCPtr, this);
-    return (cPtr == 0) ? null : new BT_QUANTIZED_BVH_NODE(cPtr, false);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btTetrahedronShapeEx.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btTetrahedronShapeEx.java
deleted file mode 100644
index 48a2d0a..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btTetrahedronShapeEx.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class btTetrahedronShapeEx extends btBU_Simplex1to4 {
-	private long swigCPtr;
-	
-	protected btTetrahedronShapeEx(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, CollisionJNI.btTetrahedronShapeEx_SWIGUpcast(cPtr), cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new btTetrahedronShapeEx, normally you should not need this constructor it's intended for low-level usage. */
-	public btTetrahedronShapeEx(long cPtr, boolean cMemoryOwn) {
-		this("btTetrahedronShapeEx", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(CollisionJNI.btTetrahedronShapeEx_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);
-	}
-	
-	public static long getCPtr(btTetrahedronShapeEx obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_btTetrahedronShapeEx(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public btTetrahedronShapeEx() {
-    this(CollisionJNI.new_btTetrahedronShapeEx(), true);
-  }
-
-  public void setVertices(Vector3 v0, Vector3 v1, Vector3 v2, Vector3 v3) {
-    CollisionJNI.btTetrahedronShapeEx_setVertices(swigCPtr, this, v0, v1, v2, v3);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btTriangleShapeEx.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btTriangleShapeEx.java
deleted file mode 100644
index 84da962..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/btTriangleShapeEx.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class btTriangleShapeEx extends btTriangleShape {
-	private long swigCPtr;
-	
-	protected btTriangleShapeEx(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, CollisionJNI.btTriangleShapeEx_SWIGUpcast(cPtr), cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new btTriangleShapeEx, normally you should not need this constructor it's intended for low-level usage. */
-	public btTriangleShapeEx(long cPtr, boolean cMemoryOwn) {
-		this("btTriangleShapeEx", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(CollisionJNI.btTriangleShapeEx_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);
-	}
-	
-	public static long getCPtr(btTriangleShapeEx obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				CollisionJNI.delete_btTriangleShapeEx(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public btTriangleShapeEx() {
-    this(CollisionJNI.new_btTriangleShapeEx__SWIG_0(), true);
-  }
-
-  public btTriangleShapeEx(Vector3 p0, Vector3 p1, Vector3 p2) {
-    this(CollisionJNI.new_btTriangleShapeEx__SWIG_1(p0, p1, p2), true);
-  }
-
-  public btTriangleShapeEx(btTriangleShapeEx other) {
-    this(CollisionJNI.new_btTriangleShapeEx__SWIG_2(btTriangleShapeEx.getCPtr(other), other), true);
-  }
-
-  public void applyTransform(Matrix4 t) {
-    CollisionJNI.btTriangleShapeEx_applyTransform(swigCPtr, this, t);
-  }
-
-  public void buildTriPlane(btVector4 plane) {
-    CollisionJNI.btTriangleShapeEx_buildTriPlane(swigCPtr, this, btVector4.getCPtr(plane), plane);
-  }
-
-  public boolean overlap_test_conservative(btTriangleShapeEx other) {
-    return CollisionJNI.btTriangleShapeEx_overlap_test_conservative(swigCPtr, this, btTriangleShapeEx.getCPtr(other), other);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/eBT_PLANE_INTERSECTION_TYPE.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/eBT_PLANE_INTERSECTION_TYPE.java
deleted file mode 100644
index cf90b22..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/eBT_PLANE_INTERSECTION_TYPE.java
+++ /dev/null
@@ -1,16 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-public final class eBT_PLANE_INTERSECTION_TYPE {
-  public final static int BT_CONST_BACK_PLANE = 0;
-  public final static int BT_CONST_COLLIDE_PLANE = BT_CONST_BACK_PLANE + 1;
-  public final static int BT_CONST_FRONT_PLANE = BT_CONST_COLLIDE_PLANE + 1;
-}
-
diff --git a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/eGIMPACT_SHAPE_TYPE.java b/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/eGIMPACT_SHAPE_TYPE.java
deleted file mode 100644
index bcf6495..0000000
--- a/extensions/gdx-bullet/jni/swig-src/collision/com/badlogic/gdx/physics/bullet/collision/eGIMPACT_SHAPE_TYPE.java
+++ /dev/null
@@ -1,16 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.collision;
-
-public final class eGIMPACT_SHAPE_TYPE {
-  public final static int CONST_GIMPACT_COMPOUND_SHAPE = 0;
-  public final static int CONST_GIMPACT_TRIMESH_SHAPE_PART = CONST_GIMPACT_COMPOUND_SHAPE + 1;
-  public final static int CONST_GIMPACT_TRIMESH_SHAPE = CONST_GIMPACT_TRIMESH_SHAPE_PART + 1;
-}
-
diff --git a/extensions/gdx-bullet/jni/swig-src/dynamics/classes.i b/extensions/gdx-bullet/jni/swig-src/dynamics/classes.i
index b3dd1d0..58ea567 100644
--- a/extensions/gdx-bullet/jni/swig-src/dynamics/classes.i
+++ b/extensions/gdx-bullet/jni/swig-src/dynamics/classes.i
@@ -36,7 +36,6 @@ SPECIFY_CLASS(btDynamicsWorld, com.badlogic.gdx.physics.bullet.dynamics)
 SPECIFY_CLASS(btDynamicsWorldDoubleData, com.badlogic.gdx.physics.bullet.dynamics)
 SPECIFY_CLASS(btDynamicsWorldFloatData, com.badlogic.gdx.physics.bullet.dynamics)
 SPECIFY_CLASS(btDynamicsWorldType, com.badlogic.gdx.physics.bullet.dynamics)
-SPECIFY_CLASS(btFixedConstraint, com.badlogic.gdx.physics.bullet.dynamics)
 SPECIFY_CLASS(btGeneric6DofConstraint, com.badlogic.gdx.physics.bullet.dynamics)
 SPECIFY_CLASS(btGeneric6DofConstraintData, com.badlogic.gdx.physics.bullet.dynamics)
 SPECIFY_CLASS(btGeneric6DofConstraintDoubleData2, com.badlogic.gdx.physics.bullet.dynamics)
diff --git a/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/DynamicsJNI.java b/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/DynamicsJNI.java
index d502c66..07c12cd 100644
--- a/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/DynamicsJNI.java
+++ b/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/DynamicsJNI.java
@@ -1407,12 +1407,6 @@ public class DynamicsJNI {
   public final static native void btHinge2Constraint_setUpperLimit(long jarg1, btHinge2Constraint jarg1_, float jarg2);
   public final static native void btHinge2Constraint_setLowerLimit(long jarg1, btHinge2Constraint jarg1_, float jarg2);
   public final static native void delete_btHinge2Constraint(long jarg1);
-  public final static native long new_btFixedConstraint(long jarg1, btRigidBody jarg1_, long jarg2, btRigidBody jarg2_, Matrix4 jarg3, Matrix4 jarg4);
-  public final static native void delete_btFixedConstraint(long jarg1);
-  public final static native void btFixedConstraint_setParam__SWIG_0(long jarg1, btFixedConstraint jarg1_, int jarg2, float jarg3, int jarg4);
-  public final static native void btFixedConstraint_setParam__SWIG_1(long jarg1, btFixedConstraint jarg1_, int jarg2, float jarg3);
-  public final static native float btFixedConstraint_getParam__SWIG_0(long jarg1, btFixedConstraint jarg1_, int jarg2, int jarg3);
-  public final static native float btFixedConstraint_getParam__SWIG_1(long jarg1, btFixedConstraint jarg1_, int jarg2);
   public final static native void delete_btVehicleRaycaster(long jarg1);
   public final static native long new_btVehicleRaycaster_btVehicleRaycasterResult();
   public final static native void btVehicleRaycaster_btVehicleRaycasterResult_hitPointInWorld_set(long jarg1, btVehicleRaycaster.btVehicleRaycasterResult jarg1_, long jarg2, btVector3 jarg2_);
@@ -1590,7 +1584,6 @@ public class DynamicsJNI {
   public final static native long btGeneric6DofSpringConstraint_SWIGUpcast(long jarg1);
   public final static native long btHingeConstraint_SWIGUpcast(long jarg1);
   public final static native long btHinge2Constraint_SWIGUpcast(long jarg1);
-  public final static native long btFixedConstraint_SWIGUpcast(long jarg1);
   public final static native long btRaycastVehicle_SWIGUpcast(long jarg1);
   public final static native long btDefaultVehicleRaycaster_SWIGUpcast(long jarg1);
 
diff --git a/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btConeTwistConstraint.java b/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btConeTwistConstraint.java
index 6f44da3..6b34f9e 100644
--- a/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btConeTwistConstraint.java
+++ b/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btConeTwistConstraint.java
@@ -80,12 +80,12 @@ public class btConeTwistConstraint extends btTypedConstraint {
   }
 
   public btRigidBody getRigidBodyA() {
-	return btRigidBody.getInstance(DynamicsJNI.btConeTwistConstraint_getRigidBodyA(swigCPtr, this), false);
-}
+    return new btRigidBody(DynamicsJNI.btConeTwistConstraint_getRigidBodyA(swigCPtr, this), false);
+  }
 
   public btRigidBody getRigidBodyB() {
-	return btRigidBody.getInstance(DynamicsJNI.btConeTwistConstraint_getRigidBodyB(swigCPtr, this), false);
-}
+    return new btRigidBody(DynamicsJNI.btConeTwistConstraint_getRigidBodyB(swigCPtr, this), false);
+  }
 
   public void setAngularOnly(boolean angularOnly) {
     DynamicsJNI.btConeTwistConstraint_setAngularOnly(swigCPtr, this, angularOnly);
diff --git a/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btFixedConstraint.java b/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btFixedConstraint.java
deleted file mode 100644
index ec66ee1..0000000
--- a/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btFixedConstraint.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 3.0.2
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet.dynamics;
-
-import com.badlogic.gdx.physics.bullet.BulletBase;
-import com.badlogic.gdx.physics.bullet.linearmath.*;
-import com.badlogic.gdx.physics.bullet.collision.*;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-
-public class btFixedConstraint extends btTypedConstraint {
-	private long swigCPtr;
-	
-	protected btFixedConstraint(final String className, long cPtr, boolean cMemoryOwn) {
-		super(className, DynamicsJNI.btFixedConstraint_SWIGUpcast(cPtr), cMemoryOwn);
-		swigCPtr = cPtr;
-	}
-	
-	/** Construct a new btFixedConstraint, normally you should not need this constructor it's intended for low-level usage. */
-	public btFixedConstraint(long cPtr, boolean cMemoryOwn) {
-		this("btFixedConstraint", cPtr, cMemoryOwn);
-		construct();
-	}
-	
-	@Override
-	protected void reset(long cPtr, boolean cMemoryOwn) {
-		if (!destroyed)
-			destroy();
-		super.reset(DynamicsJNI.btFixedConstraint_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);
-	}
-	
-	public static long getCPtr(btFixedConstraint obj) {
-		return (obj == null) ? 0 : obj.swigCPtr;
-	}
-
-	@Override
-	protected void finalize() throws Throwable {
-		if (!destroyed)
-			destroy();
-		super.finalize();
-	}
-
-  @Override protected synchronized void delete() {
-		if (swigCPtr != 0) {
-			if (swigCMemOwn) {
-				swigCMemOwn = false;
-				DynamicsJNI.delete_btFixedConstraint(swigCPtr);
-			}
-			swigCPtr = 0;
-		}
-		super.delete();
-	}
-
-  public btFixedConstraint(btRigidBody rbA, btRigidBody rbB, Matrix4 frameInA, Matrix4 frameInB) {
-    this(DynamicsJNI.new_btFixedConstraint(btRigidBody.getCPtr(rbA), rbA, btRigidBody.getCPtr(rbB), rbB, frameInA, frameInB), true);
-  }
-
-  public void setParam(int num, float value, int axis) {
-    DynamicsJNI.btFixedConstraint_setParam__SWIG_0(swigCPtr, this, num, value, axis);
-  }
-
-  public void setParam(int num, float value) {
-    DynamicsJNI.btFixedConstraint_setParam__SWIG_1(swigCPtr, this, num, value);
-  }
-
-  public float getParam(int num, int axis) {
-    return DynamicsJNI.btFixedConstraint_getParam__SWIG_0(swigCPtr, this, num, axis);
-  }
-
-  public float getParam(int num) {
-    return DynamicsJNI.btFixedConstraint_getParam__SWIG_1(swigCPtr, this, num);
-  }
-
-}
diff --git a/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btHingeConstraint.java b/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btHingeConstraint.java
index aa17796..46b6c3e 100644
--- a/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btHingeConstraint.java
+++ b/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btHingeConstraint.java
@@ -112,12 +112,12 @@ public class btHingeConstraint extends btTypedConstraint {
   }
 
   public btRigidBody getRigidBodyA() {
-	return btRigidBody.getInstance(DynamicsJNI.btHingeConstraint_getRigidBodyA__SWIG_0(swigCPtr, this), false);
-}
+    return new btRigidBody(DynamicsJNI.btHingeConstraint_getRigidBodyA__SWIG_0(swigCPtr, this), false);
+  }
 
   public btRigidBody getRigidBodyB() {
-	return btRigidBody.getInstance(DynamicsJNI.btHingeConstraint_getRigidBodyB__SWIG_0(swigCPtr, this), false);
-}
+    return new btRigidBody(DynamicsJNI.btHingeConstraint_getRigidBodyB__SWIG_0(swigCPtr, this), false);
+  }
 
   public Matrix4 getFrameOffsetA() {
 	return DynamicsJNI.btHingeConstraint_getFrameOffsetA(swigCPtr, this);
diff --git a/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btRaycastVehicle.java b/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btRaycastVehicle.java
index 167cbf9..1148894 100644
--- a/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btRaycastVehicle.java
+++ b/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btRaycastVehicle.java
@@ -246,8 +246,9 @@ public class btRaycastVehicle extends btActionInterface {
   }
 
   public btRigidBody getRigidBody() {
-	return btRigidBody.getInstance(DynamicsJNI.btRaycastVehicle_getRigidBody__SWIG_0(swigCPtr, this), false);
-}
+    long cPtr = DynamicsJNI.btRaycastVehicle_getRigidBody__SWIG_0(swigCPtr, this);
+    return (cPtr == 0) ? null : new btRigidBody(cPtr, false);
+  }
 
   public int getRightAxis() {
     return DynamicsJNI.btRaycastVehicle_getRightAxis(swigCPtr, this);
diff --git a/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btRigidBody.java b/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btRigidBody.java
index d03a4b5..e5f6b09 100644
--- a/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btRigidBody.java
+++ b/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btRigidBody.java
@@ -61,21 +61,6 @@ public class btRigidBody extends btCollisionObject {
 
 	protected btMotionState motionState;
 	
-	/** @return The existing instance for the specified pointer, or null if the instance doesn't exist */
-	public static btRigidBody getInstance(final long swigCPtr) {
-		return (btRigidBody)btCollisionObject.getInstance(swigCPtr);
-	}
-		
-	/** @return The existing instance for the specified pointer, or a newly created instance if the instance didn't exist */
-	public static btRigidBody getInstance(final long swigCPtr, boolean owner) {
-		if (swigCPtr == 0)
-			return null;
-		btRigidBody result = getInstance(swigCPtr);
-		if (result == null)
-				result = new btRigidBody(swigCPtr, owner);
-		return result;
-	}
-	
 	public btRigidBody(btRigidBodyConstructionInfo constructionInfo) {
 		this(false, constructionInfo);
 		refCollisionShape(constructionInfo.getCollisionShape());
diff --git a/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btSliderConstraint.java b/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btSliderConstraint.java
index 7750b4a..28cc9a7 100644
--- a/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btSliderConstraint.java
+++ b/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btSliderConstraint.java
@@ -76,12 +76,12 @@ public class btSliderConstraint extends btTypedConstraint {
   }
 
   public btRigidBody getRigidBodyA() {
-	return btRigidBody.getInstance(DynamicsJNI.btSliderConstraint_getRigidBodyA(swigCPtr, this), false);
-}
+    return new btRigidBody(DynamicsJNI.btSliderConstraint_getRigidBodyA(swigCPtr, this), false);
+  }
 
   public btRigidBody getRigidBodyB() {
-	return btRigidBody.getInstance(DynamicsJNI.btSliderConstraint_getRigidBodyB(swigCPtr, this), false);
-}
+    return new btRigidBody(DynamicsJNI.btSliderConstraint_getRigidBodyB(swigCPtr, this), false);
+  }
 
   public Matrix4 getCalculatedTransformA() {
 	return DynamicsJNI.btSliderConstraint_getCalculatedTransformA(swigCPtr, this);
diff --git a/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btSolverBody.java b/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btSolverBody.java
index 84fa1de..f8bd044 100644
--- a/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btSolverBody.java
+++ b/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btSolverBody.java
@@ -172,8 +172,9 @@ public class btSolverBody extends BulletBase {
   }
 
   public btRigidBody getOriginalBody() {
-	return btRigidBody.getInstance(DynamicsJNI.btSolverBody_originalBody_get(swigCPtr, this), false);
-}
+    long cPtr = DynamicsJNI.btSolverBody_originalBody_get(swigCPtr, this);
+    return (cPtr == 0) ? null : new btRigidBody(cPtr, false);
+  }
 
   public void getVelocityInLocalPointNoDelta(Vector3 rel_pos, Vector3 velocity) {
     DynamicsJNI.btSolverBody_getVelocityInLocalPointNoDelta(swigCPtr, this, rel_pos, velocity);
diff --git a/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btTypedConstraint.java b/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btTypedConstraint.java
index 8680a0b..0e41a7b 100644
--- a/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btTypedConstraint.java
+++ b/extensions/gdx-bullet/jni/swig-src/dynamics/com/badlogic/gdx/physics/bullet/dynamics/btTypedConstraint.java
@@ -125,8 +125,8 @@ public class btTypedConstraint extends btTypedObject {
   }
 
   public static btRigidBody getFixedBody() {
-	return btRigidBody.getInstance(DynamicsJNI.btTypedConstraint_getFixedBody(), false);
-}
+    return new btRigidBody(DynamicsJNI.btTypedConstraint_getFixedBody(), false);
+  }
 
   static public class btConstraintInfo2 extends BulletBase {
   	private long swigCPtr;
@@ -351,12 +351,12 @@ public class btTypedConstraint extends btTypedObject {
   }
 
   public btRigidBody getRigidBodyA() {
-	return btRigidBody.getInstance(DynamicsJNI.btTypedConstraint_getRigidBodyA__SWIG_0(swigCPtr, this), false);
-}
+    return new btRigidBody(DynamicsJNI.btTypedConstraint_getRigidBodyA__SWIG_0(swigCPtr, this), false);
+  }
 
   public btRigidBody getRigidBodyB() {
-	return btRigidBody.getInstance(DynamicsJNI.btTypedConstraint_getRigidBodyB__SWIG_0(swigCPtr, this), false);
-}
+    return new btRigidBody(DynamicsJNI.btTypedConstraint_getRigidBodyB__SWIG_0(swigCPtr, this), false);
+  }
 
   public int getUserConstraintType() {
     return DynamicsJNI.btTypedConstraint_getUserConstraintType(swigCPtr, this);
diff --git a/extensions/gdx-bullet/jni/swig-src/dynamics/dynamics_wrap.cpp b/extensions/gdx-bullet/jni/swig-src/dynamics/dynamics_wrap.cpp
index c7e8c1e..deac1dd 100644
--- a/extensions/gdx-bullet/jni/swig-src/dynamics/dynamics_wrap.cpp
+++ b/extensions/gdx-bullet/jni/swig-src/dynamics/dynamics_wrap.cpp
@@ -1900,9 +1900,6 @@ SWIGINTERN btRigidBody *new_btRigidBody__SWIG_1(bool dummy,btScalar mass,btMotio
 #include <BulletDynamics/ConstraintSolver/btHinge2Constraint.h>
 
 
-#include <BulletDynamics/ConstraintSolver/btFixedConstraint.h>
-
-
 #include <BulletDynamics/Vehicle/btVehicleRaycaster.h>
 
 
@@ -23334,120 +23331,6 @@ SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_dynamics_DynamicsJN
 }
 
 
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_dynamics_DynamicsJNI_new_1btFixedConstraint(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jobject jarg3, jobject jarg4) {
-  jlong jresult = 0 ;
-  btRigidBody *arg1 = 0 ;
-  btRigidBody *arg2 = 0 ;
-  btTransform *arg3 = 0 ;
-  btTransform *arg4 = 0 ;
-  btFixedConstraint *result = 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  (void)jarg2_;
-  arg1 = *(btRigidBody **)&jarg1;
-  if (!arg1) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btRigidBody & reference is null");
-    return 0;
-  } 
-  arg2 = *(btRigidBody **)&jarg2;
-  if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btRigidBody & reference is null");
-    return 0;
-  } 
-  btTransform local_arg3;
-  gdx_setbtTransformFromMatrix4(jenv, local_arg3, jarg3);
-  arg3 = &local_arg3;
-  gdxAutoCommitMatrix4 auto_commit_arg3(jenv, jarg3, &local_arg3);
-  btTransform local_arg4;
-  gdx_setbtTransformFromMatrix4(jenv, local_arg4, jarg4);
-  arg4 = &local_arg4;
-  gdxAutoCommitMatrix4 auto_commit_arg4(jenv, jarg4, &local_arg4);
-  result = (btFixedConstraint *)new btFixedConstraint(*arg1,*arg2,(btTransform const &)*arg3,(btTransform const &)*arg4);
-  *(btFixedConstraint **)&jresult = result; 
-  return jresult;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_dynamics_DynamicsJNI_delete_1btFixedConstraint(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-  btFixedConstraint *arg1 = (btFixedConstraint *) 0 ;
-  
-  (void)jenv;
-  (void)jcls;
-  arg1 = *(btFixedConstraint **)&jarg1; 
-  delete arg1;
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_dynamics_DynamicsJNI_btFixedConstraint_1setParam_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jfloat jarg3, jint jarg4) {
-  btFixedConstraint *arg1 = (btFixedConstraint *) 0 ;
-  int arg2 ;
-  btScalar arg3 ;
-  int arg4 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btFixedConstraint **)&jarg1; 
-  arg2 = (int)jarg2; 
-  arg3 = (btScalar)jarg3; 
-  arg4 = (int)jarg4; 
-  (arg1)->setParam(arg2,arg3,arg4);
-}
-
-
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_dynamics_DynamicsJNI_btFixedConstraint_1setParam_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jfloat jarg3) {
-  btFixedConstraint *arg1 = (btFixedConstraint *) 0 ;
-  int arg2 ;
-  btScalar arg3 ;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btFixedConstraint **)&jarg1; 
-  arg2 = (int)jarg2; 
-  arg3 = (btScalar)jarg3; 
-  (arg1)->setParam(arg2,arg3);
-}
-
-
-SWIGEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_bullet_dynamics_DynamicsJNI_btFixedConstraint_1getParam_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3) {
-  jfloat jresult = 0 ;
-  btFixedConstraint *arg1 = (btFixedConstraint *) 0 ;
-  int arg2 ;
-  int arg3 ;
-  btScalar result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btFixedConstraint **)&jarg1; 
-  arg2 = (int)jarg2; 
-  arg3 = (int)jarg3; 
-  result = (btScalar)((btFixedConstraint const *)arg1)->getParam(arg2,arg3);
-  jresult = (jfloat)result; 
-  return jresult;
-}
-
-
-SWIGEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_bullet_dynamics_DynamicsJNI_btFixedConstraint_1getParam_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
-  jfloat jresult = 0 ;
-  btFixedConstraint *arg1 = (btFixedConstraint *) 0 ;
-  int arg2 ;
-  btScalar result;
-  
-  (void)jenv;
-  (void)jcls;
-  (void)jarg1_;
-  arg1 = *(btFixedConstraint **)&jarg1; 
-  arg2 = (int)jarg2; 
-  result = (btScalar)((btFixedConstraint const *)arg1)->getParam(arg2);
-  jresult = (jfloat)result; 
-  return jresult;
-}
-
-
 SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_dynamics_DynamicsJNI_delete_1btVehicleRaycaster(JNIEnv *jenv, jclass jcls, jlong jarg1) {
   btVehicleRaycaster *arg1 = (btVehicleRaycaster *) 0 ;
   
@@ -25904,14 +25787,6 @@ SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_dynamics_DynamicsJ
     return baseptr;
 }
 
-SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_dynamics_DynamicsJNI_btFixedConstraint_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
-    jlong baseptr = 0;
-    (void)jenv;
-    (void)jcls;
-    *(btTypedConstraint **)&baseptr = *(btFixedConstraint **)&jarg1;
-    return baseptr;
-}
-
 SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_dynamics_DynamicsJNI_btRaycastVehicle_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
     jlong baseptr = 0;
     (void)jenv;
diff --git a/extensions/gdx-bullet/jni/swig-src/extras/classes.i b/extensions/gdx-bullet/jni/swig-src/extras/classes.i
index be620c7..a0d898e 100644
--- a/extensions/gdx-bullet/jni/swig-src/extras/classes.i
+++ b/extensions/gdx-bullet/jni/swig-src/extras/classes.i
@@ -1,6 +1,7 @@
 SPECIFY_CLASS(Extras, com.badlogic.gdx.physics.bullet.extras)
 SPECIFY_CLASS(ExtrasJNI, com.badlogic.gdx.physics.bullet.extras)
 SPECIFY_CLASS(SWIGTYPE_p_bParse__btBulletFile, com.badlogic.gdx.physics.bullet.extras)
+SPECIFY_CLASS(SWIGTYPE_p_btGImpactMeshShape, com.badlogic.gdx.physics.bullet.extras)
 SPECIFY_CLASS(btBulletWorldImporter, com.badlogic.gdx.physics.bullet.extras)
 SPECIFY_CLASS(btStringArray, com.badlogic.gdx.physics.bullet.extras)
 SPECIFY_CLASS(btWorldImporter, com.badlogic.gdx.physics.bullet.extras)
\ No newline at end of file
diff --git a/extensions/gdx-bullet/jni/swig-src/extras/com/badlogic/gdx/physics/bullet/extras/ExtrasJNI.java b/extensions/gdx-bullet/jni/swig-src/extras/com/badlogic/gdx/physics/bullet/extras/ExtrasJNI.java
index a63e3cc..f92c5e7 100644
--- a/extensions/gdx-bullet/jni/swig-src/extras/com/badlogic/gdx/physics/bullet/extras/ExtrasJNI.java
+++ b/extensions/gdx-bullet/jni/swig-src/extras/com/badlogic/gdx/physics/bullet/extras/ExtrasJNI.java
@@ -160,7 +160,7 @@ public class ExtrasJNI {
     return btCollisionShape.getCPtr(self.createConvexTriangleMeshShape((trimesh == 0) ? null : new btStridingMeshInterface(trimesh, false)));
   }
   public static long SwigDirector_btBulletWorldImporter_createGimpactShape(btBulletWorldImporter self, long trimesh) {
-    return btGImpactMeshShape.getCPtr(self.createGimpactShape((trimesh == 0) ? null : new btStridingMeshInterface(trimesh, false)));
+    return SWIGTYPE_p_btGImpactMeshShape.getCPtr(self.createGimpactShape((trimesh == 0) ? null : new btStridingMeshInterface(trimesh, false)));
   }
   public static long SwigDirector_btBulletWorldImporter_createStridingMeshInterfaceData(btBulletWorldImporter self, long interfaceData) {
     return btStridingMeshInterfaceData.getCPtr(self.createStridingMeshInterfaceData((interfaceData == 0) ? null : new btStridingMeshInterfaceData(interfaceData, false)));
diff --git a/extensions/gdx-bullet/jni/swig-src/extras/com/badlogic/gdx/physics/bullet/extras/SWIGTYPE_p_btGImpactMeshShape.java b/extensions/gdx-bullet/jni/swig-src/extras/com/badlogic/gdx/physics/bullet/extras/SWIGTYPE_p_btGImpactMeshShape.java
new file mode 100644
index 0000000..3d699c6
--- /dev/null
+++ b/extensions/gdx-bullet/jni/swig-src/extras/com/badlogic/gdx/physics/bullet/extras/SWIGTYPE_p_btGImpactMeshShape.java
@@ -0,0 +1,26 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 3.0.2
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package com.badlogic.gdx.physics.bullet.extras;
+
+public class SWIGTYPE_p_btGImpactMeshShape {
+  private long swigCPtr;
+
+  protected SWIGTYPE_p_btGImpactMeshShape(long cPtr, boolean futureUse) {
+    swigCPtr = cPtr;
+  }
+
+  protected SWIGTYPE_p_btGImpactMeshShape() {
+    swigCPtr = 0;
+  }
+
+  protected static long getCPtr(SWIGTYPE_p_btGImpactMeshShape obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+}
+
diff --git a/extensions/gdx-bullet/jni/swig-src/extras/com/badlogic/gdx/physics/bullet/extras/btWorldImporter.java b/extensions/gdx-bullet/jni/swig-src/extras/com/badlogic/gdx/physics/bullet/extras/btWorldImporter.java
index 690ab47..e2fe7bf 100644
--- a/extensions/gdx-bullet/jni/swig-src/extras/com/badlogic/gdx/physics/bullet/extras/btWorldImporter.java
+++ b/extensions/gdx-bullet/jni/swig-src/extras/com/badlogic/gdx/physics/bullet/extras/btWorldImporter.java
@@ -126,8 +126,9 @@ public class btWorldImporter extends BulletBase {
   }
 
   public btRigidBody getRigidBodyByName(String name) {
-	return btRigidBody.getInstance(ExtrasJNI.btWorldImporter_getRigidBodyByName(swigCPtr, this, name), false);
-}
+    long cPtr = ExtrasJNI.btWorldImporter_getRigidBodyByName(swigCPtr, this, name);
+    return (cPtr == 0) ? null : new btRigidBody(cPtr, false);
+  }
 
   public btTypedConstraint getConstraintByName(String name) {
     long cPtr = ExtrasJNI.btWorldImporter_getConstraintByName(swigCPtr, this, name);
@@ -143,8 +144,9 @@ public class btWorldImporter extends BulletBase {
   }
 
   public btRigidBody createRigidBody(boolean isDynamic, float mass, Matrix4 startTransform, btCollisionShape shape, String bodyName) {
-	return btRigidBody.getInstance(ExtrasJNI.btWorldImporter_createRigidBody(swigCPtr, this, isDynamic, mass, startTransform, btCollisionShape.getCPtr(shape), shape, bodyName), false);
-}
+    long cPtr = ExtrasJNI.btWorldImporter_createRigidBody(swigCPtr, this, isDynamic, mass, startTransform, btCollisionShape.getCPtr(shape), shape, bodyName);
+    return (cPtr == 0) ? null : new btRigidBody(cPtr, false);
+  }
 
   public btCollisionObject createCollisionObject(Matrix4 startTransform, btCollisionShape shape, String bodyName) {
 	return btCollisionObject.getInstance(ExtrasJNI.btWorldImporter_createCollisionObject(swigCPtr, this, startTransform, btCollisionShape.getCPtr(shape), shape, bodyName), false);
@@ -210,9 +212,9 @@ public class btWorldImporter extends BulletBase {
     return (cPtr == 0) ? null : btCollisionShape.newDerivedObject(cPtr, false);
   }
 
-  public btGImpactMeshShape createGimpactShape(btStridingMeshInterface trimesh) {
+  public SWIGTYPE_p_btGImpactMeshShape createGimpactShape(btStridingMeshInterface trimesh) {
     long cPtr = ExtrasJNI.btWorldImporter_createGimpactShape(swigCPtr, this, btStridingMeshInterface.getCPtr(trimesh), trimesh);
-    return (cPtr == 0) ? null : new btGImpactMeshShape(cPtr, false);
+    return (cPtr == 0) ? null : new SWIGTYPE_p_btGImpactMeshShape(cPtr, false);
   }
 
   public btStridingMeshInterfaceData createStridingMeshInterfaceData(btStridingMeshInterfaceData interfaceData) {
diff --git a/extensions/gdx-bullet/jni/swig-src/extras/extras_wrap.cpp b/extensions/gdx-bullet/jni/swig-src/extras/extras_wrap.cpp
index 317cc04..9a0484f 100644
--- a/extensions/gdx-bullet/jni/swig-src/extras/extras_wrap.cpp
+++ b/extensions/gdx-bullet/jni/swig-src/extras/extras_wrap.cpp
@@ -2775,7 +2775,7 @@ void SwigDirector_btBulletWorldImporter::swig_connect_director(JNIEnv *jenv, job
       "createConvexTriangleMeshShape", "(Lcom/badlogic/gdx/physics/bullet/collision/btStridingMeshInterface;)Lcom/badlogic/gdx/physics/bullet/collision/btCollisionShape;", NULL 
     },
     {
-      "createGimpactShape", "(Lcom/badlogic/gdx/physics/bullet/collision/btStridingMeshInterface;)Lcom/badlogic/gdx/physics/bullet/collision/btGImpactMeshShape;", NULL 
+      "createGimpactShape", "(Lcom/badlogic/gdx/physics/bullet/collision/btStridingMeshInterface;)Lcom/badlogic/gdx/physics/bullet/extras/SWIGTYPE_p_btGImpactMeshShape;", NULL 
     },
     {
       "createStridingMeshInterfaceData", "(Lcom/badlogic/gdx/physics/bullet/collision/btStridingMeshInterfaceData;)Lcom/badlogic/gdx/physics/bullet/collision/btStridingMeshInterfaceData;", NULL 
diff --git a/extensions/gdx-bullet/jni/swig-src/linearmath/com/badlogic/gdx/physics/bullet/linearmath/LinearMath.java b/extensions/gdx-bullet/jni/swig-src/linearmath/com/badlogic/gdx/physics/bullet/linearmath/LinearMath.java
index 1aec3eb..7b1a4f3 100644
--- a/extensions/gdx-bullet/jni/swig-src/linearmath/com/badlogic/gdx/physics/bullet/linearmath/LinearMath.java
+++ b/extensions/gdx-bullet/jni/swig-src/linearmath/com/badlogic/gdx/physics/bullet/linearmath/LinearMath.java
@@ -63,6 +63,14 @@ public class LinearMath implements LinearMathConstants {
     return LinearMathJNI.btGetVersion();
   }
 
+  public static void setBtInfinityMask(int value) {
+    LinearMathJNI.btInfinityMask_set(value);
+  }
+
+  public static int getBtInfinityMask() {
+    return LinearMathJNI.btInfinityMask_get();
+  }
+
   public static float btSqrt(float y) {
     return LinearMathJNI.btSqrt(y);
   }
diff --git a/extensions/gdx-bullet/jni/swig-src/linearmath/com/badlogic/gdx/physics/bullet/linearmath/LinearMathJNI.java b/extensions/gdx-bullet/jni/swig-src/linearmath/com/badlogic/gdx/physics/bullet/linearmath/LinearMathJNI.java
index 66b6a26..8310f73 100644
--- a/extensions/gdx-bullet/jni/swig-src/linearmath/com/badlogic/gdx/physics/bullet/linearmath/LinearMathJNI.java
+++ b/extensions/gdx-bullet/jni/swig-src/linearmath/com/badlogic/gdx/physics/bullet/linearmath/LinearMathJNI.java
@@ -17,6 +17,8 @@ import com.badlogic.gdx.utils.Pool;
 
 public class LinearMathJNI {
   public final static native int btGetVersion();
+  public final static native void btInfinityMask_set(int jarg1);
+  public final static native int btInfinityMask_get();
   public final static native float btSqrt(float jarg1);
   public final static native float btFabs(float jarg1);
   public final static native float btCos(float jarg1);
diff --git a/extensions/gdx-bullet/jni/swig-src/linearmath/linearmath_wrap.cpp b/extensions/gdx-bullet/jni/swig-src/linearmath/linearmath_wrap.cpp
index 2ca2fa5..62ad948 100644
--- a/extensions/gdx-bullet/jni/swig-src/linearmath/linearmath_wrap.cpp
+++ b/extensions/gdx-bullet/jni/swig-src/linearmath/linearmath_wrap.cpp
@@ -2943,6 +2943,28 @@ SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_linearmath_LinearMa
 }
 
 
+SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_linearmath_LinearMathJNI_btInfinityMask_1set(JNIEnv *jenv, jclass jcls, jint jarg1) {
+  int arg1 ;
+  
+  (void)jenv;
+  (void)jcls;
+  arg1 = (int)jarg1; 
+  btInfinityMask = arg1;
+}
+
+
+SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_linearmath_LinearMathJNI_btInfinityMask_1get(JNIEnv *jenv, jclass jcls) {
+  jint jresult = 0 ;
+  int result;
+  
+  (void)jenv;
+  (void)jcls;
+  result = (int)btInfinityMask;
+  jresult = (jint)result; 
+  return jresult;
+}
+
+
 SWIGEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_bullet_linearmath_LinearMathJNI_btSqrt(JNIEnv *jenv, jclass jcls, jfloat jarg1) {
   jfloat jresult = 0 ;
   btScalar arg1 ;
diff --git a/extensions/gdx-bullet/jni/swig-src/softbody/com/badlogic/gdx/physics/bullet/softbody/btSoftBody.java b/extensions/gdx-bullet/jni/swig-src/softbody/com/badlogic/gdx/physics/bullet/softbody/btSoftBody.java
index 9947543..6a77291 100644
--- a/extensions/gdx-bullet/jni/swig-src/softbody/com/badlogic/gdx/physics/bullet/softbody/btSoftBody.java
+++ b/extensions/gdx-bullet/jni/swig-src/softbody/com/badlogic/gdx/physics/bullet/softbody/btSoftBody.java
@@ -1657,8 +1657,9 @@ public class btSoftBody extends btCollisionObject {
     }
   
     public btRigidBody getBody() {
-  	return btRigidBody.getInstance(SoftbodyJNI.btSoftBody_Anchor_body_get(swigCPtr, this), false);
-  }
+      long cPtr = SoftbodyJNI.btSoftBody_Anchor_body_get(swigCPtr, this);
+      return (cPtr == 0) ? null : new btRigidBody(cPtr, false);
+    }
   
     public void setInfluence(float value) {
       SoftbodyJNI.btSoftBody_Anchor_influence_set(swigCPtr, this, value);
@@ -2313,8 +2314,9 @@ public class btSoftBody extends btCollisionObject {
     }
   
     public btRigidBody getRigid() {
-  	return btRigidBody.getInstance(SoftbodyJNI.btSoftBody_Body_rigid_get(swigCPtr, this), false);
-  }
+      long cPtr = SoftbodyJNI.btSoftBody_Body_rigid_get(swigCPtr, this);
+      return (cPtr == 0) ? null : new btRigidBody(cPtr, false);
+    }
   
     public void setCollisionObject(btCollisionObject value) {
       SoftbodyJNI.btSoftBody_Body_collisionObject_set(swigCPtr, this, btCollisionObject.getCPtr(value), value);
diff --git a/extensions/gdx-bullet/jni/swig-src/softbody/com/badlogic/gdx/physics/bullet/softbody/btSoftColliders.java b/extensions/gdx-bullet/jni/swig-src/softbody/com/badlogic/gdx/physics/bullet/softbody/btSoftColliders.java
index 80dae0c..be51ba3 100644
--- a/extensions/gdx-bullet/jni/swig-src/softbody/com/badlogic/gdx/physics/bullet/softbody/btSoftColliders.java
+++ b/extensions/gdx-bullet/jni/swig-src/softbody/com/badlogic/gdx/physics/bullet/softbody/btSoftColliders.java
@@ -354,8 +354,9 @@ public class btSoftColliders extends BulletBase {
     }
   
     public btRigidBody getRigidBody() {
-  	return btRigidBody.getInstance(SoftbodyJNI.btSoftColliders_CollideSDF_RS_rigidBody_get(swigCPtr, this), false);
-  }
+      long cPtr = SoftbodyJNI.btSoftColliders_CollideSDF_RS_rigidBody_get(swigCPtr, this);
+      return (cPtr == 0) ? null : new btRigidBody(cPtr, false);
+    }
   
     public void setDynmargin(float value) {
       SoftbodyJNI.btSoftColliders_CollideSDF_RS_dynmargin_set(swigCPtr, this, value);
diff --git a/extensions/gdx-bullet/jni/swig/collision/btCollisionObject.i b/extensions/gdx-bullet/jni/swig/collision/btCollisionObject.i
index 4575512..e9445fd 100644
--- a/extensions/gdx-bullet/jni/swig/collision/btCollisionObject.i
+++ b/extensions/gdx-bullet/jni/swig/collision/btCollisionObject.i
@@ -13,10 +13,6 @@
 	return btCollisionObject.getInstance($jnicall, $owner);
 }
 
-%typemap(javaout) 	btCollisionObject, const btCollisionObject, btCollisionObject & {
-	return btCollisionObject.getInstance($jnicall, $owner);
-}
-
 %typemap(javadirectorin) btCollisionObject *, const btCollisionObject *, btCollisionObject * const &	"btCollisionObject.getInstance($1, false)"
 
 %typemap(javacode) btCollisionObject %{
diff --git a/extensions/gdx-bullet/jni/swig/collision/btCollisionObjectWrapper.i b/extensions/gdx-bullet/jni/swig/collision/btCollisionObjectWrapper.i
index fd08e10..61c5f3c 100644
--- a/extensions/gdx-bullet/jni/swig/collision/btCollisionObjectWrapper.i
+++ b/extensions/gdx-bullet/jni/swig/collision/btCollisionObjectWrapper.i
@@ -1,11 +1,6 @@
 %module btCollisionObjectWrapper
 
-%typemap(javadirectorin) btCollisionObjectWrapper, const btCollisionObjectWrapper, const btCollisionObjectWrapper &, btCollisionObjectWrapper & 	"btCollisionObjectWrapper.obtainForArgument($1, false)"
-%typemap(javadirectorin) btCollisionObjectWrapper *, const btCollisionObjectWrapper *, btCollisionObjectWrapper * const &	"btCollisionObjectWrapper.obtainForArgument($1, false)"
-
-%typemap(javaout) 	btCollisionObjectWrapper *, const btCollisionObjectWrapper *, btCollisionObjectWrapper * const & {
-	return btCollisionObjectWrapper.internalTemp($jnicall, $owner);
-}
+CREATE_POOLED_OBJECT(btCollisionObjectWrapper, com/badlogic/gdx/physics/bullet/collision/btCollisionObjectWrapper);
 
 %nodefaultdtor btCollisionObjectWrapper;
 
@@ -16,15 +11,23 @@
 		temp.reset(cPtr, own);
 		return temp;
 	}
-
-	private static btCollisionObjectWrapper[] argumentInstances = new btCollisionObjectWrapper[] {new btCollisionObjectWrapper(0, false),
-		new btCollisionObjectWrapper(0, false), new btCollisionObjectWrapper(0, false), new btCollisionObjectWrapper(0, false)};
-	private static int argumentIndex = -1;
-	/** Obtains a temporary instance, used for callback methods with one or more btManifoldPoint arguments */
-	protected static btCollisionObjectWrapper obtainForArgument(final long swigCPtr, boolean owner) {
-		btCollisionObjectWrapper instance = argumentInstances[argumentIndex = (argumentIndex + 1) & 3];
-		instance.reset(swigCPtr, owner);
-		return instance;
+	/** Pool of btCollisionObjectWrapper instances, used by director interface to provide the arguments. */
+	protected static final com.badlogic.gdx.utils.Pool<btCollisionObjectWrapper> pool = new com.badlogic.gdx.utils.Pool<btCollisionObjectWrapper>() {
+		@Override
+		protected btCollisionObjectWrapper newObject() {
+			return new btCollisionObjectWrapper(0, false);
+		}
+	};
+	/** Reuses a previous freed instance or creates a new instance and set it to reflect the specified native object */
+	public static btCollisionObjectWrapper obtain(long cPtr, boolean own) {
+		final btCollisionObjectWrapper result = pool.obtain();
+		result.reset(cPtr, own);
+		return result;
+	}
+	/** delete the native object if required and allow the instance to be reused by the obtain method */
+	public static void free(final btCollisionObjectWrapper inst) {
+		inst.dispose();
+		pool.free(inst);
 	}
 
 	@Override
@@ -43,13 +46,13 @@
 	@Override
 	protected void construct() {
 		super.construct();
-		wrapper = new btCollisionObjectWrapper(getWrapper().getCPointer(), false);
+		wrapper = btCollisionObjectWrapper.obtain(getWrapper().getCPointer(), false);
 	}
 
 	@Override
 	public void dispose() {
 		if (wrapper != null) {
-			wrapper.dispose();
+			btCollisionObjectWrapper.free(wrapper);
 			wrapper = null;
 		}
 		super.dispose();
diff --git a/extensions/gdx-bullet/jni/swig/collision/btManifoldPoint.i b/extensions/gdx-bullet/jni/swig/collision/btManifoldPoint.i
index 1f3f47c..8640ad0 100644
--- a/extensions/gdx-bullet/jni/swig/collision/btManifoldPoint.i
+++ b/extensions/gdx-bullet/jni/swig/collision/btManifoldPoint.i
@@ -1,7 +1,6 @@
 %module btManifoldPoint
 
 %typemap(javadirectorin) btManifoldPoint, const btManifoldPoint, const btManifoldPoint &, btManifoldPoint & 	"btManifoldPoint.obtainForArgument($1, false)"
-%typemap(javadirectorin) btManifoldPoint *, const btManifoldPoint *, btManifoldPoint * const &		"btManifoldPoint.obtainForArgument($1, false)"
 
 %typemap(javaout) 	btManifoldPoint *, const btManifoldPoint *, btManifoldPoint * const & {
 	return btManifoldPoint.obtainTemp($jnicall, $owner);
diff --git a/extensions/gdx-bullet/jni/swig/collision/collision.i b/extensions/gdx-bullet/jni/swig/collision/collision.i
index beb28a6..5ff64e2 100644
--- a/extensions/gdx-bullet/jni/swig/collision/collision.i
+++ b/extensions/gdx-bullet/jni/swig/collision/collision.i
@@ -538,5 +538,3 @@ void btMultiSapBroadphase::quicksort(btBroadphasePairArray& a, int lo, int hi)
 %include "./ContactCache.i"
 
 %include "./btBroadphasePairArray.i"
-
-%include "./gimpact.i"
\ No newline at end of file
diff --git a/extensions/gdx-bullet/jni/swig/collision/gimpact.i b/extensions/gdx-bullet/jni/swig/collision/gimpact.i
deleted file mode 100644
index daa5aa6..0000000
--- a/extensions/gdx-bullet/jni/swig/collision/gimpact.i
+++ /dev/null
@@ -1,73 +0,0 @@
-/** @author Xoppa */
-%module Gimpact
-
-%{
-#include <BulletCollision/Gimpact/btQuantization.h>
-%}
-%include "BulletCollision/Gimpact/btQuantization.h"
-
-%{
-#include <BulletCollision/Gimpact/btBoxCollision.h>
-%}
-%include "BulletCollision/Gimpact/btBoxCollision.h"
-
-%{
-#include <BulletCollision/Gimpact/btClipPolygon.h>
-%}
-%include "BulletCollision/Gimpact/btClipPolygon.h"
-
-%{
-#include <BulletCollision/Gimpact/btGeometryOperations.h>
-%}
-%include "BulletCollision/Gimpact/btGeometryOperations.h"
-
-%{
-#include <BulletCollision/Gimpact/btTriangleShapeEx.h>
-%}
-%include "BulletCollision/Gimpact/btTriangleShapeEx.h"
-
-%{
-#include <BulletCollision/Gimpact/btGImpactBvh.h>
-%}
-%include "BulletCollision/Gimpact/btGImpactBvh.h"
-
-%{
-#include <BulletCollision/Gimpact/btGImpactQuantizedBvh.h>
-%}
-%include "BulletCollision/Gimpact/btGImpactQuantizedBvh.h"
-
-%{
-#include <BulletCollision/Gimpact/btGImpactShape.h>
-%}
-%include "BulletCollision/Gimpact/btGImpactShape.h"
-
-%{
-#include <BulletCollision/Gimpact/btContactProcessing.h>
-%}
-%include "BulletCollision/Gimpact/btContactProcessing.h"
-
-//%{
-//#include <BulletCollision/Gimpact/btCompoundFromGimpact.h>
-//%}
-//%include "BulletCollision/Gimpact/btCompoundFromGimpact.h"
-
-%{
-#include <BulletCollision/Gimpact/btGenericPoolAllocator.h>
-%}
-%include "BulletCollision/Gimpact/btGenericPoolAllocator.h"
-
-%{
-#include <BulletCollision/Gimpact/btGImpactCollisionAlgorithm.h>
-%}
-%include "BulletCollision/Gimpact/btGImpactCollisionAlgorithm.h"
-
-%{
-#include <BulletCollision/Gimpact/btGImpactMassUtil.h>
-%}
-%include "BulletCollision/Gimpact/btGImpactMassUtil.h"
-
-%{
-#include <BulletCollision/Gimpact/btGImpactMassUtil.h>
-%}
-%include "BulletCollision/Gimpact/btGImpactMassUtil.h"
-
diff --git a/extensions/gdx-bullet/jni/swig/common/gdxPooledObject.i b/extensions/gdx-bullet/jni/swig/common/gdxPooledObject.i
index 21a9b73..a9d7aec 100644
--- a/extensions/gdx-bullet/jni/swig/common/gdxPooledObject.i
+++ b/extensions/gdx-bullet/jni/swig/common/gdxPooledObject.i
@@ -33,7 +33,7 @@
 
 %fragment(gdxToString(gdxPooled##JTYPE), "header") {
 	// Inline (cached) method to retrieve the type's jclass
-	SWIGINTERN inline jclass &gdx_getClass##JTYPE(JNIEnv * const &jenv) {
+	SWIGINTERN inline jclass &gdx_getClass##JTYPE(JNIEnv * jenv) {
 		static jclass cls = NULL;
 		if (cls == NULL)
 			cls = (jclass) jenv->NewGlobalRef(jenv->FindClass(gdxToString(_JCLASS)));
diff --git a/extensions/gdx-bullet/jni/swig/dynamics/btRigidBody.i b/extensions/gdx-bullet/jni/swig/dynamics/btRigidBody.i
index 9c0d970..f09e007 100644
--- a/extensions/gdx-bullet/jni/swig/dynamics/btRigidBody.i
+++ b/extensions/gdx-bullet/jni/swig/dynamics/btRigidBody.i
@@ -14,16 +14,6 @@
 %ignore btRigidBody::btRigidBodyConstructionInfo::btRigidBodyConstructionInfo(btScalar mass, btMotionState* motionState, btCollisionShape* collisionShape);
 %ignore btRigidBody::btRigidBodyConstructionInfo::btRigidBodyConstructionInfo(btScalar mass, btMotionState* motionState, btCollisionShape* collisionShape, const btVector3& localInertia);
 
-%typemap(javaout) 	btRigidBody *, const btRigidBody *, btRigidBody * const & {
-	return btRigidBody.getInstance($jnicall, $owner);
-}
-
-%typemap(javaout) 	btRigidBody, const btRigidBody, btRigidBody & {
-	return btRigidBody.getInstance($jnicall, $owner);
-}
-
-%typemap(javadirectorin) btRigidBody *, const btRigidBody *, btRigidBody * const &	"btRigidBody.getInstance($1, false)"
-
 %typemap(javacode) btRigidBody::btRigidBodyConstructionInfo %{
 	protected btMotionState motionState;
 	
@@ -122,21 +112,6 @@
 %typemap(javacode) btRigidBody %{
 	protected btMotionState motionState;
 	
-	/** @return The existing instance for the specified pointer, or null if the instance doesn't exist */
-	public static btRigidBody getInstance(final long swigCPtr) {
-		return (btRigidBody)btCollisionObject.getInstance(swigCPtr);
-	}
-		
-	/** @return The existing instance for the specified pointer, or a newly created instance if the instance didn't exist */
-	public static btRigidBody getInstance(final long swigCPtr, boolean owner) {
-		if (swigCPtr == 0)
-			return null;
-		btRigidBody result = getInstance(swigCPtr);
-		if (result == null)
-				result = new btRigidBody(swigCPtr, owner);
-		return result;
-	}
-	
 	public btRigidBody(btRigidBodyConstructionInfo constructionInfo) {
 		this(false, constructionInfo);
 		refCollisionShape(constructionInfo.getCollisionShape());
diff --git a/extensions/gdx-bullet/jni/swig/dynamics/dynamics.i b/extensions/gdx-bullet/jni/swig/dynamics/dynamics.i
index e6e7570..ebb2b81 100644
--- a/extensions/gdx-bullet/jni/swig/dynamics/dynamics.i
+++ b/extensions/gdx-bullet/jni/swig/dynamics/dynamics.i
@@ -168,11 +168,6 @@ import com.badlogic.gdx.math.Matrix4;
 %include "BulletDynamics/ConstraintSolver/btHinge2Constraint.h"
 
 %{
-#include <BulletDynamics/ConstraintSolver/btFixedConstraint.h>
-%}
-%include "BulletDynamics/ConstraintSolver/btFixedConstraint.h"
-
-%{
 #include <BulletDynamics/Vehicle/btVehicleRaycaster.h>
 %}
 %include "BulletDynamics/Vehicle/btVehicleRaycaster.h"
diff --git a/extensions/gdx-bullet/jni/swig/linearmath/linearmath.i b/extensions/gdx-bullet/jni/swig/linearmath/linearmath.i
index b47be2d..085e964 100644
--- a/extensions/gdx-bullet/jni/swig/linearmath/linearmath.i
+++ b/extensions/gdx-bullet/jni/swig/linearmath/linearmath.i
@@ -18,9 +18,6 @@ static  int btInfinityMask = 0x7F800000;
  * btScalar.h defines macros the other types need, so process it first.  
  * It also defines some static functions that end up in gdxBulletJNI.java.
  */
-%ignore btInfMaskConverter;
-%ignore btInfinityMask;
-%ignore btGetInfinityMask();
 %include "LinearMath/btScalar.h"
 
 %include "btTransform.i"
diff --git a/extensions/gdx-bullet/pom.xml b/extensions/gdx-bullet/pom.xml
index 8e15d53..275657b 100644
--- a/extensions/gdx-bullet/pom.xml
+++ b/extensions/gdx-bullet/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.5.4-SNAPSHOT</version>
+    <version>1.4.2-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/extensions/gdx-bullet/src/com/badlogic/gdx/physics/bullet/Bullet.java b/extensions/gdx-bullet/src/com/badlogic/gdx/physics/bullet/Bullet.java
index 924264c..44cf596 100644
--- a/extensions/gdx-bullet/src/com/badlogic/gdx/physics/bullet/Bullet.java
+++ b/extensions/gdx-bullet/src/com/badlogic/gdx/physics/bullet/Bullet.java
@@ -18,8 +18,8 @@ package com.badlogic.gdx.physics.bullet;
 
 import java.util.Arrays;
 
+import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.g3d.model.MeshPart;
-import com.badlogic.gdx.graphics.g3d.model.Node;
 import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.physics.bullet.collision.btBvhTriangleMeshShape;
 import com.badlogic.gdx.physics.bullet.collision.btCollisionShape;
@@ -27,6 +27,7 @@ import com.badlogic.gdx.physics.bullet.collision.btCompoundShape;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.Pool;
 import com.badlogic.gdx.utils.SharedLibraryLoader;
+import com.badlogic.gdx.graphics.g3d.model.Node;
 
 public class Bullet {
 	protected static boolean useRefCounting = false;
@@ -92,10 +93,10 @@ public class Bullet {
 			for (int i = 0, n = node.parts.size; i < n; i++)
 				part.parts.add(node.parts.get(i).meshPart);
 		}
-		if (node.hasChildren()) {
+		if (node.children.size > 0) {
 			final boolean transformed = applyTransform && !Arrays.equals(transform.val, idt.val); 
 			final int o = transformed ? out.size : offset;
-			getShapeParts(node.getChildren(), out, o, pool);
+			getShapeParts(node.children, out, o, pool);
 			if (transformed) {
 				for (int i = o, n = out.size; i < n; i++) {
 					final ShapePart part = out.get(i);
@@ -106,9 +107,10 @@ public class Bullet {
 		}
 	}
 	
-	public static <T extends Node> void getShapeParts(final Iterable<T> nodes, final Array<ShapePart> out, final int offset, final Pool<ShapePart> pool) {
-		for (T node : nodes)
-			getShapeParts(node, true, out, offset, pool);
+	public static void getShapeParts(final Array<Node> nodes, final Array<ShapePart> out, final int offset, final Pool<ShapePart> pool) {
+		final int n = nodes.size;
+		for (int i = 0; i < n; i++)
+			getShapeParts(nodes.get(i), true, out, offset, pool);
 	}
 
 	public static btCollisionShape obtainStaticNodeShape(final Node node, final boolean applyTransform) {
diff --git a/extensions/gdx-controllers/gdx-controllers-android/pom.xml b/extensions/gdx-controllers/gdx-controllers-android/pom.xml
index 04fd490..630e3cc 100644
--- a/extensions/gdx-controllers/gdx-controllers-android/pom.xml
+++ b/extensions/gdx-controllers/gdx-controllers-android/pom.xml
@@ -4,7 +4,7 @@
 	<parent>
 		<groupId>com.badlogicgames.gdx</groupId>
 		<artifactId>gdx-controllers-parent</artifactId>
-		<version>1.5.4-SNAPSHOT</version>
+		<version>1.4.2-SNAPSHOT</version>
 		<relativePath>../pom.xml</relativePath>
 	</parent>
 
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/maven/pom.xml b/extensions/gdx-controllers/gdx-controllers-desktop/jni/maven/pom.xml
index 979969c..c3edb64 100644
--- a/extensions/gdx-controllers/gdx-controllers-desktop/jni/maven/pom.xml
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/maven/pom.xml
@@ -4,7 +4,7 @@
     <parent>
         <groupId>com.badlogicgames.gdx</groupId>
         <artifactId>gdx-controllers-parent</artifactId>
-        <version>1.5.4-SNAPSHOT</version>
+        <version>1.4.2-SNAPSHOT</version>
         <relativePath>../../../</relativePath>
     </parent>
     
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/pom.xml b/extensions/gdx-controllers/gdx-controllers-desktop/pom.xml
index d2858e9..0dbe3c2 100644
--- a/extensions/gdx-controllers/gdx-controllers-desktop/pom.xml
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-controllers-parent</artifactId>
-    <version>1.5.4-SNAPSHOT</version>
+    <version>1.4.2-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/desktop/OisControllers.java b/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/desktop/OisControllers.java
index 1bbd1d9..a3bdf64 100644
--- a/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/desktop/OisControllers.java
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/desktop/OisControllers.java
@@ -44,10 +44,6 @@ public class OisControllers {
 	Ois ois = new Ois(hwnd);
 	OisController[] controllers;
 
-	private static final boolean IS_MAC = System.getProperty("os.name").toLowerCase().contains("mac");
-	private static final boolean IS_WINDOWS = System.getProperty("os.name").toLowerCase().contains("windows");
-	private static final long CHECK_FOR_LOST_WINDOW_HANDLE_INTERVAL = 1000000000L; // in nanoseconds. 1000000000 == 1 second
-
 	public OisControllers (final DesktopControllerManager manager) {
 		this.manager = manager;
 		ArrayList<OisJoystick> joysticks = ois.getJoysticks();
@@ -59,28 +55,19 @@ public class OisControllers {
 		}
 
 		new Runnable() {
-
-			private long lastCheckForLostWindowHandleTime;
-
 			public void run () {
-				// we won't do the rather heavy check for a lost window handle each and every frame, but rather each second only
-				long now = System.nanoTime();
-				if (now - lastCheckForLostWindowHandleTime > CHECK_FOR_LOST_WINDOW_HANDLE_INTERVAL) {
-					lastCheckForLostWindowHandleTime = now;
-
-					long newWindowHandle = getWindowHandle();
-					if (hwnd != newWindowHandle) {
-						hwnd = newWindowHandle;
-						ois = new Ois(newWindowHandle);
-
-						ArrayList<OisJoystick> joysticks = ois.getJoysticks();
-						controllers = new OisController[joysticks.size()];
-						manager.controllers.clear();
-						for (int i = 0, n = joysticks.size(); i < n; i++) {
-							OisJoystick joystick = joysticks.get(i);
-							controllers[i] = new OisController(joystick);
-							manager.controllers.add(controllers[i]);
-						}
+				long newWindowHandle = getWindowHandle();
+				if(hwnd != newWindowHandle){
+					hwnd = newWindowHandle;
+					ois = new Ois(newWindowHandle);
+					
+					ArrayList<OisJoystick> joysticks = ois.getJoysticks();
+					controllers = new OisController[joysticks.size()];
+					manager.controllers.clear();
+					for (int i = 0, n = joysticks.size(); i < n; i++) {
+						OisJoystick joystick = joysticks.get(i);
+						controllers[i] = new OisController(joystick);
+						manager.controllers.add(controllers[i]);
 					}
 				}
 				ois.update();
@@ -230,7 +217,7 @@ public class OisControllers {
 	/** Returns the window handle from LWJGL needed by OIS. */
 	static public long getWindowHandle () {
 		// don't need a window handle for Mac OS X
-		if (IS_MAC) {
+		if (System.getProperty("os.name").toLowerCase().contains("mac")) {
 			return 0;
 		}
 
@@ -249,7 +236,8 @@ public class OisControllers {
 				Method getImplementation = displayClass.getDeclaredMethod("getImplementation", new Class[0]);
 				getImplementation.setAccessible(true);
 				Object display = getImplementation.invoke(null, (Object[])null);
-				Field field = display.getClass().getDeclaredField(IS_WINDOWS ? "hwnd" : "parent_window");
+				String fieldName = System.getProperty("os.name").toLowerCase().contains("windows") ? "hwnd" : "parent_window";
+				Field field = display.getClass().getDeclaredField(fieldName);
 				field.setAccessible(true);
 				return (Long)field.get(display);
 			}
diff --git a/extensions/gdx-controllers/gdx-controllers-gwt/pom.xml b/extensions/gdx-controllers/gdx-controllers-gwt/pom.xml
index d67093e..dfe72f3 100644
--- a/extensions/gdx-controllers/gdx-controllers-gwt/pom.xml
+++ b/extensions/gdx-controllers/gdx-controllers-gwt/pom.xml
@@ -4,7 +4,7 @@
 	<parent>
 		<groupId>com.badlogicgames.gdx</groupId>
 		<artifactId>gdx-controllers-parent</artifactId>
-		<version>1.5.4-SNAPSHOT</version>
+		<version>1.4.2-SNAPSHOT</version>
 		<relativePath>../pom.xml</relativePath>
 	</parent>
 
diff --git a/extensions/gdx-controllers/gdx-controllers-gwt/src/com/badlogic/gdx/controllers/gwt/emu/com/badlogic/gdx/controllers/mappings/Ouya.java b/extensions/gdx-controllers/gdx-controllers-gwt/src/com/badlogic/gdx/controllers/gwt/emu/com/badlogic/gdx/controllers/mappings/Ouya.java
index 6f70c2f..6ea29e3 100644
--- a/extensions/gdx-controllers/gdx-controllers-gwt/src/com/badlogic/gdx/controllers/gwt/emu/com/badlogic/gdx/controllers/mappings/Ouya.java
+++ b/extensions/gdx-controllers/gdx-controllers-gwt/src/com/badlogic/gdx/controllers/gwt/emu/com/badlogic/gdx/controllers/mappings/Ouya.java
@@ -1,12 +1,12 @@
 /*******************************************************************************
  * Copyright 2011 See AUTHORS file.
- *
+ * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *
+ * 
  *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * 
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -18,32 +18,62 @@ package com.badlogic.gdx.controllers.mappings;
 
 import com.badlogic.gdx.controllers.Controller;
 
-/** Button and axis indices for the OUYA {@link Controller}.
- * @author mzechner */
+/**
+ * Button and axis indices for the OUYA {@link Controller}.
+ * @author mzechner
+ *
+ */
 public class Ouya {
 	public static final String ID = "OUYA Game Controller";
-	public static final int BUTTON_O = 0;
-	public static final int BUTTON_U = 1;
-	public static final int BUTTON_Y = 2;
-	public static final int BUTTON_A = 3;
-	public static final int BUTTON_DPAD_UP = 12;
-	public static final int BUTTON_DPAD_DOWN = 13;
-	public static final int BUTTON_DPAD_RIGHT = 14;
-	public static final int BUTTON_DPAD_LEFT = 15;
-	public static final int BUTTON_L1 = 4;
-	public static final int BUTTON_L2 = 6;
-	public static final int BUTTON_L3 = 17; // unverified
-	public static final int BUTTON_R1 = 5;
-	public static final int BUTTON_R2 = 7;
-	public static final int BUTTON_R3 = 18; // unverified
-	public static final int AXIS_LEFT_X = 0;
-	public static final int AXIS_LEFT_Y = 1;
-	public static final int AXIS_LEFT_TRIGGER = 10;
-	public static final int AXIS_RIGHT_X = 3;
-	public static final int AXIS_RIGHT_Y = 4;
-	public static final int AXIS_RIGHT_TRIGGER = 11;
-	public static final int BUTTON_MENU = 108; // unverified
+	public static final int BUTTON_O;
+	public static final int BUTTON_U;
+	public static final int BUTTON_Y;
+	public static final int BUTTON_A;
+	public static final int BUTTON_MENU;
+	public static final int BUTTON_DPAD_UP;
+	public static final int BUTTON_DPAD_DOWN;
+	public static final int BUTTON_DPAD_RIGHT;
+	public static final int BUTTON_DPAD_LEFT;
+	public static final int BUTTON_L1;
+	public static final int BUTTON_L2;
+	public static final int BUTTON_L3;
+	public static final int BUTTON_R1;
+	public static final int BUTTON_R2;
+	public static final int BUTTON_R3;
+	public static final int AXIS_LEFT_X;
+	public static final int AXIS_LEFT_Y;
+	public static final int AXIS_LEFT_TRIGGER;
+	public static final int AXIS_RIGHT_X;
+	public static final int AXIS_RIGHT_Y;
+	public static final int AXIS_RIGHT_TRIGGER;
 	public static final float STICK_DEADZONE = 0.25F;
 	/** whether the app is running on a real Ouya device **/
-	public static final boolean runningOnOuya = false;
+	public static final boolean runningOnOuya;
+	
+	static {
+		runningOnOuya = false;
+	
+		// Based on the "Standard" gamepad mapping
+		BUTTON_O = 0;
+		BUTTON_U = 1;
+		BUTTON_Y = 2;
+		BUTTON_A = 3;
+		BUTTON_DPAD_UP = 12;
+		BUTTON_DPAD_DOWN = 13;
+		BUTTON_DPAD_RIGHT = 14;
+		BUTTON_DPAD_LEFT = 15;
+		BUTTON_L1 = 4;
+		BUTTON_L2 = 6;
+		BUTTON_L3 = 17; // unverified
+		BUTTON_R1 = 5;
+		BUTTON_R2 = 7;
+		BUTTON_R3 = 18; // unverified
+		AXIS_LEFT_X = 0;
+		AXIS_LEFT_Y = 1;
+		AXIS_LEFT_TRIGGER = 10;
+		AXIS_RIGHT_X = 3;
+		AXIS_RIGHT_Y = 4;
+		AXIS_RIGHT_TRIGGER = 11;
+		BUTTON_MENU = 108; // unverified
+	}
 }
diff --git a/extensions/gdx-controllers/gdx-controllers/pom.xml b/extensions/gdx-controllers/gdx-controllers/pom.xml
index dfef725..b30e892 100644
--- a/extensions/gdx-controllers/gdx-controllers/pom.xml
+++ b/extensions/gdx-controllers/gdx-controllers/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-controllers-parent</artifactId>
-    <version>1.5.4-SNAPSHOT</version>
+    <version>1.4.2-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/extensions/gdx-controllers/gdx-controllers/src/com/badlogic/gdx/controllers/mappings/Ouya.java b/extensions/gdx-controllers/gdx-controllers/src/com/badlogic/gdx/controllers/mappings/Ouya.java
index e9475a5..9ada25b 100644
--- a/extensions/gdx-controllers/gdx-controllers/src/com/badlogic/gdx/controllers/mappings/Ouya.java
+++ b/extensions/gdx-controllers/gdx-controllers/src/com/badlogic/gdx/controllers/mappings/Ouya.java
@@ -1,12 +1,12 @@
 /*******************************************************************************
  * Copyright 2011 See AUTHORS file.
- *
+ * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *
+ * 
  *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * 
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -24,35 +24,35 @@ import com.badlogic.gdx.controllers.Controller;
  * @author mzechner */
 public class Ouya {
 	public static final String ID = "OUYA Game Controller";
-	public static final int BUTTON_O = 96;
-	public static final int BUTTON_U = 99;
-	public static final int BUTTON_Y = 100;
-	public static final int BUTTON_A = 97;
-	public static final int BUTTON_MENU = 82;
-	public static final int BUTTON_DPAD_UP = 19;
-	public static final int BUTTON_DPAD_DOWN = 20;
-	public static final int BUTTON_DPAD_RIGHT = 22;
-	public static final int BUTTON_DPAD_LEFT = 21;
-	public static final int BUTTON_L1 = 104;
-	public static final int BUTTON_L2 = 102;
-	public static final int BUTTON_L3 = 106;
-	public static final int BUTTON_R1 = 105;
-	public static final int BUTTON_R2 = 103;
-	public static final int BUTTON_R3 = 107;
-	public static final int AXIS_LEFT_X = 0;
-	public static final int AXIS_LEFT_Y = 1;
-	public static final int AXIS_LEFT_TRIGGER = 2;
-	public static final int AXIS_RIGHT_X = 3;
-	public static final int AXIS_RIGHT_Y = 4;
-	public static final int AXIS_RIGHT_TRIGGER = 5;
+	public static final int BUTTON_O;
+	public static final int BUTTON_U;
+	public static final int BUTTON_Y;
+	public static final int BUTTON_A;
+	public static final int BUTTON_MENU;
+	public static final int BUTTON_DPAD_UP;
+	public static final int BUTTON_DPAD_DOWN;
+	public static final int BUTTON_DPAD_RIGHT;
+	public static final int BUTTON_DPAD_LEFT;
+	public static final int BUTTON_L1;
+	public static final int BUTTON_L2;
+	public static final int BUTTON_L3;
+	public static final int BUTTON_R1;
+	public static final int BUTTON_R2;
+	public static final int BUTTON_R3;
+	public static final int AXIS_LEFT_X;
+	public static final int AXIS_LEFT_Y;
+	public static final int AXIS_LEFT_TRIGGER;
+	public static final int AXIS_RIGHT_X;
+	public static final int AXIS_RIGHT_Y;
+	public static final int AXIS_RIGHT_TRIGGER;
 	public static final float STICK_DEADZONE = 0.25F;
-
+	
 	/** whether the app is running on a real Ouya device **/
 	public static final boolean runningOnOuya;
 
 	/** To allow users to simulate running on Ouya **/
 	public static boolean simulateRunningOnOuya = false;
-
+	
 	static {
 		boolean isOuya = false;
 		try {
@@ -63,10 +63,35 @@ public class Ouya {
 		} catch (Exception e) {
 		}
 		runningOnOuya = isOuya;
-	}
 
-	/** To allow users to have a single check to see if running on the Ouya that also consideres the simulation flag **/
-	public static boolean isRunningOnOuya () {
+		BUTTON_O = 96;
+		BUTTON_U = 99;
+		BUTTON_Y = 100;
+		BUTTON_A = 97;
+		BUTTON_MENU = 82;
+		BUTTON_DPAD_UP = 19;
+		BUTTON_DPAD_DOWN = 20;
+		BUTTON_DPAD_RIGHT = 22;
+		BUTTON_DPAD_LEFT = 21;
+		BUTTON_L1 = 104;
+		BUTTON_L2 = 102;
+		BUTTON_L3 = 106;
+		BUTTON_R1 = 105;
+		BUTTON_R2 = 103;
+		BUTTON_R3 = 107;
+		AXIS_LEFT_X = 0;
+		AXIS_LEFT_Y = 1;
+		AXIS_LEFT_TRIGGER = 2;
+		AXIS_RIGHT_X = 3;
+		AXIS_RIGHT_Y = 4;
+		AXIS_RIGHT_TRIGGER = 5;
+
+	}
+	
+	/** To allow users to have a single check to see if running on the Ouya 
+		that also consideres the simulation flag **/
+	public static boolean isRunningOnOuya()
+	{
 		return runningOnOuya || simulateRunningOnOuya;
 	}
 }
diff --git a/extensions/gdx-controllers/pom.xml b/extensions/gdx-controllers/pom.xml
index 40f6163..e5062fe 100644
--- a/extensions/gdx-controllers/pom.xml
+++ b/extensions/gdx-controllers/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.5.4-SNAPSHOT</version>
+    <version>1.4.2-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/extensions/gdx-freetype/jni/build-ios32.xml b/extensions/gdx-freetype/jni/build-ios32.xml
index 6b8a11f..3c189b6 100755
--- a/extensions/gdx-freetype/jni/build-ios32.xml
+++ b/extensions/gdx-freetype/jni/build-ios32.xml
@@ -113,7 +113,7 @@
 				<exclude name="*.o"/>
 			</fileset>
 		</delete>
-	</target>		
+	</target>
 
 	<!-- compiles all C and C++ files to object files in the build directory, for 386 builds-->
 	<target name="compile-386" depends="clean,create-build-dir">
@@ -169,63 +169,8 @@
 	</target>
 	
 	<!-- compiles all C and C++ files to object files in the build directory, for 386 builds-->
-	<target name="compile-x86_64" depends="create-build-dir">
-		<mkdir dir="${buildDir}"/>
-		<antcall target="clean-objfiles"/>
-		<apply failonerror="true" executable="${g++}" dest="${buildDir}" verbose="true">
-			<arg line="-isysroot ${iphonesimulator-sdk} -arch x86_64 ${g++-opts}"/>
-			<arg value="-Ijni-headers"/>
-			<arg value="-Ijni-headers/${jniPlatform}"/>
-			<arg value="-I."/>
-						<arg value="-Ifreetype-2.4.10/include"/>
-
-			<srcfile/>
-			<arg value="-o"/>
-			<targetfile/>
-			<fileset refid="g++-files"/>
-			<compositemapper>
-				<mapper type="glob" from="*.cpp" to="*.o"/>
-				<mapper type="glob" from="*.mm" to="*.o"/>
-			</compositemapper>
-		</apply>
-		<apply failonerror="true" executable="${gcc}" dest="${buildDir}" verbose="true">
-			<arg line="-isysroot ${iphonesimulator-sdk} -arch x86_64 ${gcc-opts}"/>
-			<arg value="-Ijni-headers"/>
-			<arg value="-Ijni-headers/${jniPlatform}"/>
-			<arg value="-I."/>
-						<arg value="-Ifreetype-2.4.10/include"/>
-
-			<srcfile/>
-			<arg value="-o"/>
-			<targetfile/>
-			<fileset refid="gcc-files"/>
-			<compositemapper>
-				<mapper type="glob" from="*.c" to="*.o"/>
-			</compositemapper>
-		</apply>
-	</target>	
-
-	<!-- links the shared library based on the previously compiled object files -->
-	<target name="link-x86_64" depends="compile-x86_64">
-		<fileset dir="${buildDir}" id="objFileSet">
-			<patternset>
-				<include name="**/*.o" />
-			</patternset>
-		</fileset>
-		<pathconvert pathsep=" " property="objFiles" refid="objFileSet" />
-		<mkdir dir="${libsDir}" />
-		<exec executable="${linker}" failonerror="true" dir="${buildDir}">
-			<arg line="${linker-opts}" />
-			<arg path="${libsDir}/${libName}.x86_64" />
-			<arg line="${objFiles}"/>
-			<arg line="${libraries}" />
-		</exec>
-	</target>
-	
-	<!-- compiles all C and C++ files to object files in the build directory, for 386 builds-->
-	<target name="compile-arm" depends="create-build-dir">
+	<target name="compile-arm" depends="create-build-dir,clean-objfiles">
 		<mkdir dir="${buildDir}"/>
-		<antcall target="clean-objfiles"/>
 		<apply failonerror="true" executable="${g++}" dest="${buildDir}" verbose="true">
 			<arg line="-isysroot ${iphoneos-sdk} -arch armv7 ${g++-opts}"/>
 			<arg value="-Ijni-headers"/>
@@ -275,68 +220,14 @@
 			<arg line="${libraries}" />
 		</exec>
 	</target>
-	
-		<!-- compiles all C and C++ files to object files in the build directory, for 386 builds-->
-	<target name="compile-arm64" depends="create-build-dir,clean-objfiles">
-		<mkdir dir="${buildDir}"/>
-		<antcall target="clean-objfiles"/>
-		<apply failonerror="true" executable="${g++}" dest="${buildDir}" verbose="true">
-			<arg line="-isysroot ${iphoneos-sdk} -arch arm64 ${g++-opts}"/>
-			<arg value="-Ijni-headers"/>
-			<arg value="-Ijni-headers/${jniPlatform}"/>
-			<arg value="-I."/>
-						<arg value="-Ifreetype-2.4.10/include"/>
-
-			<srcfile/>
-			<arg value="-o"/>
-			<targetfile/>
-			<fileset refid="g++-files"/>
-			<compositemapper>
-				<mapper type="glob" from="*.cpp" to="*.o"/>
-				<mapper type="glob" from="*.mm" to="*.o"/>
-			</compositemapper>
-		</apply>
-		<apply failonerror="true" executable="${gcc}" dest="${buildDir}" verbose="true">
-			<arg line="-isysroot ${iphoneos-sdk} -arch arm64 ${gcc-opts}"/>
-			<arg value="-Ijni-headers"/>
-			<arg value="-Ijni-headers/${jniPlatform}"/>
-			<arg value="-I."/>
-						<arg value="-Ifreetype-2.4.10/include"/>
-
-			<srcfile/>
-			<arg value="-o"/>
-			<targetfile/>
-			<fileset refid="gcc-files"/>
-			<compositemapper>
-				<mapper type="glob" from="*.c" to="*.o"/>
-			</compositemapper>
-		</apply>
-	</target>	
-
-	<!-- links the shared library based on the previously compiled object files -->
-	<target name="link-arm64" depends="compile-arm64">
-		<fileset dir="${buildDir}" id="objFileSet">
-			<patternset>
-				<include name="**/*.o" />
-			</patternset>
-		</fileset>
-		<pathconvert pathsep=" " property="objFiles" refid="objFileSet" />
-		<mkdir dir="${libsDir}" />
-		<exec executable="${linker}" failonerror="true" dir="${buildDir}">
-			<arg line="${linker-opts}" />
-			<arg path="${libsDir}/${libName}.arm64" />
-			<arg line="${objFiles}"/>
-			<arg line="${libraries}" />
-		</exec>
-	</target>
 
 	<target name="link-fat">
 		<exec executable="lipo" failonerror="true" dir="${libsDir}">
-			<arg line="-create -output ${libName} ${libName}.386 ${libName}.x86_64 ${libName}.armv7 ${libName}.arm64"/>
+			<arg line="-create -output ${libName} ${libName}.386 ${libName}.armv7"/>
 		</exec>
 	</target>
 
-	<target name="postcompile" depends="link-386,link-x86_64,link-arm,link-arm64,link-fat">
+	<target name="postcompile" depends="link-386,link-arm,link-fat">
 		
 	</target>
 </project>
diff --git a/extensions/gdx-freetype/jni/com.badlogic.gdx.graphics.g2d.freetype.FreeType.cpp b/extensions/gdx-freetype/jni/com.badlogic.gdx.graphics.g2d.freetype.FreeType.cpp
index 067dfd9..cf20be6 100644
--- a/extensions/gdx-freetype/jni/com.badlogic.gdx.graphics.g2d.freetype.FreeType.cpp
+++ b/extensions/gdx-freetype/jni/com.badlogic.gdx.graphics.g2d.freetype.FreeType.cpp
@@ -1,68 +1,13 @@
 #include <com.badlogic.gdx.graphics.g2d.freetype.FreeType.h>
 
-//@line:35
+//@line:32
 
 	#include <ft2build.h>
 	#include FT_FREETYPE_H
-	#include FT_STROKER_H
-	 JNIEXPORT void JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Library_doneFreeType(JNIEnv* env, jclass clazz, jlong library) {
+	 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getFaceFlags(JNIEnv* env, jclass clazz, jlong face) {
 
 
-//@line:64
-
-			FT_Done_FreeType((FT_Library)library);
-		
-
-}
-
-static inline jlong wrapped_Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Library_newMemoryFace
-(JNIEnv* env, jclass clazz, jlong library, jobject obj_data, jint dataSize, jint faceIndex, char* data) {
-
-//@line:87
-
-			FT_Face face = 0;
-			FT_Error error = FT_New_Memory_Face((FT_Library)library, (const FT_Byte*)data, dataSize, faceIndex, &face);
-			if(error) return 0;
-			else return (jlong)face;
-		
-}
-
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Library_newMemoryFace(JNIEnv* env, jclass clazz, jlong library, jobject obj_data, jint dataSize, jint faceIndex) {
-	char* data = (char*)(obj_data?env->GetDirectBufferAddress(obj_data):0);
-
-	jlong JNI_returnValue = wrapped_Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Library_newMemoryFace(env, clazz, library, obj_data, dataSize, faceIndex, data);
-
-
-	return JNI_returnValue;
-}
-
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Library_strokerNew(JNIEnv* env, jclass clazz, jlong library) {
-
-
-//@line:100
-
-         FT_Stroker stroker;
-         FT_Error error = FT_Stroker_New((FT_Library)library, &stroker);
-			if(error) return 0;
-			else return (jlong)stroker;
-		
-
-}
-
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_doneFace(JNIEnv* env, jclass clazz, jlong face) {
-
-
-//@line:126
-
-			FT_Done_Face((FT_Face)face);
-		
-
-}
-
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getFaceFlags(JNIEnv* env, jclass clazz, jlong face) {
-
-
-//@line:134
+//@line:65
 
 			return ((FT_Face)face)->face_flags;
 		
@@ -72,7 +17,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getStyleFlags(JNIEnv* env, jclass clazz, jlong face) {
 
 
-//@line:142
+//@line:73
 
 			return ((FT_Face)face)->style_flags;
 		
@@ -82,7 +27,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getNumGlyphs(JNIEnv* env, jclass clazz, jlong face) {
 
 
-//@line:150
+//@line:81
 
 			return ((FT_Face)face)->num_glyphs;
 		
@@ -92,7 +37,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getAscender(JNIEnv* env, jclass clazz, jlong face) {
 
 
-//@line:158
+//@line:89
 
 			return ((FT_Face)face)->ascender;
 		
@@ -102,7 +47,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getDescender(JNIEnv* env, jclass clazz, jlong face) {
 
 
-//@line:166
+//@line:97
 
 			return ((FT_Face)face)->descender;
 		
@@ -112,7 +57,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getHeight(JNIEnv* env, jclass clazz, jlong face) {
 
 
-//@line:174
+//@line:105
 
 			return ((FT_Face)face)->height;
 		
@@ -122,7 +67,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getMaxAdvanceWidth(JNIEnv* env, jclass clazz, jlong face) {
 
 
-//@line:182
+//@line:113
 
 			return ((FT_Face)face)->max_advance_width;
 		
@@ -132,7 +77,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getMaxAdvanceHeight(JNIEnv* env, jclass clazz, jlong face) {
 
 
-//@line:190
+//@line:121
 
 			return ((FT_Face)face)->max_advance_height;
 		
@@ -142,7 +87,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getUnderlinePosition(JNIEnv* env, jclass clazz, jlong face) {
 
 
-//@line:198
+//@line:129
 
 			return ((FT_Face)face)->underline_position;
 		
@@ -152,67 +97,17 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getUnderlineThickness(JNIEnv* env, jclass clazz, jlong face) {
 
 
-//@line:206
+//@line:137
 
 			return ((FT_Face)face)->underline_thickness;
 		
 
 }
 
-JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_selectSize(JNIEnv* env, jclass clazz, jlong face, jint strike_index) {
-
-
-//@line:214
-
-			return !FT_Select_Size((FT_Face)face, strike_index);
-		
-
-}
-
-JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_setCharSize(JNIEnv* env, jclass clazz, jlong face, jint charWidth, jint charHeight, jint horzResolution, jint vertResolution) {
-
-
-//@line:222
-
-			return !FT_Set_Char_Size((FT_Face)face, charWidth, charHeight, horzResolution, vertResolution);
-		
-
-}
-
-JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_setPixelSizes(JNIEnv* env, jclass clazz, jlong face, jint pixelWidth, jint pixelHeight) {
-
-
-//@line:230
-
-			return !FT_Set_Pixel_Sizes((FT_Face)face, pixelWidth, pixelHeight);
-		
-
-}
-
-JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_loadGlyph(JNIEnv* env, jclass clazz, jlong face, jint glyphIndex, jint loadFlags) {
-
-
-//@line:238
-
-			return !FT_Load_Glyph((FT_Face)face, glyphIndex, loadFlags);
-		
-
-}
-
-JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_loadChar(JNIEnv* env, jclass clazz, jlong face, jint charCode, jint loadFlags) {
-
-
-//@line:246
-
-			return !FT_Load_Char((FT_Face)face, charCode, loadFlags);
-		
-
-}
-
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getGlyph(JNIEnv* env, jclass clazz, jlong face) {
 
 
-//@line:254
+//@line:145
 
 			return (jlong)((FT_Face)face)->glyph;
 		
@@ -222,50 +117,17 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_000
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getSize(JNIEnv* env, jclass clazz, jlong face) {
 
 
-//@line:262
+//@line:153
 
 			return (jlong)((FT_Face)face)->size;
 		
 
 }
 
-JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_hasKerning(JNIEnv* env, jclass clazz, jlong face) {
-
-
-//@line:270
-
-	   	return FT_HAS_KERNING(((FT_Face)face));
-	   
-
-}
-
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getKerning(JNIEnv* env, jclass clazz, jlong face, jint leftGlyph, jint rightGlyph, jint kernMode) {
-
-
-//@line:278
-
-	   	FT_Vector kerning;
-	   	FT_Error error = FT_Get_Kerning((FT_Face)face, leftGlyph, rightGlyph, kernMode, &kerning);
-	   	if(error) return 0;
-	   	return kerning.x;
-	   
-
-}
-
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getCharIndex(JNIEnv* env, jclass clazz, jlong face, jint charCode) {
-
-
-//@line:289
-
-	   	return FT_Get_Char_Index((FT_Face)face, charCode);
-	   
-
-}
-
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Size_getMetrics(JNIEnv* env, jclass clazz, jlong address) {
 
 
-//@line:304
+//@line:167
 
 			return (jlong)&((FT_Size)address)->metrics;
 		
@@ -275,7 +137,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_000
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024SizeMetrics_getXppem(JNIEnv* env, jclass clazz, jlong metrics) {
 
 
-//@line:318
+//@line:181
 
 			return ((FT_Size_Metrics*)metrics)->x_ppem;
 		
@@ -285,7 +147,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024SizeMetrics_getYppem(JNIEnv* env, jclass clazz, jlong metrics) {
 
 
-//@line:326
+//@line:189
 
 			return ((FT_Size_Metrics*)metrics)->y_ppem;
 		
@@ -295,7 +157,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024SizeMetrics_getXscale(JNIEnv* env, jclass clazz, jlong metrics) {
 
 
-//@line:334
+//@line:197
 
 			return ((FT_Size_Metrics*)metrics)->x_scale;
 		
@@ -305,7 +167,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024SizeMetrics_getYscale(JNIEnv* env, jclass clazz, jlong metrics) {
 
 
-//@line:342
+//@line:205
 
 			return ((FT_Size_Metrics*)metrics)->x_scale;
 		
@@ -315,7 +177,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024SizeMetrics_getAscender(JNIEnv* env, jclass clazz, jlong metrics) {
 
 
-//@line:350
+//@line:213
 
 			return ((FT_Size_Metrics*)metrics)->ascender;
 		
@@ -325,7 +187,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024SizeMetrics_getDescender(JNIEnv* env, jclass clazz, jlong metrics) {
 
 
-//@line:358
+//@line:221
 
 			return ((FT_Size_Metrics*)metrics)->descender;
 		
@@ -335,7 +197,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024SizeMetrics_getHeight(JNIEnv* env, jclass clazz, jlong metrics) {
 
 
-//@line:366
+//@line:229
 
 			return ((FT_Size_Metrics*)metrics)->height;
 		
@@ -345,7 +207,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024SizeMetrics_getMaxAdvance(JNIEnv* env, jclass clazz, jlong metrics) {
 
 
-//@line:374
+//@line:237
 
 			return ((FT_Size_Metrics*)metrics)->max_advance;
 		
@@ -355,7 +217,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphSlot_getMetrics(JNIEnv* env, jclass clazz, jlong slot) {
 
 
-//@line:388
+//@line:251
 
 			return (jlong)&((FT_GlyphSlot)slot)->metrics;
 		
@@ -365,7 +227,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_000
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphSlot_getLinearHoriAdvance(JNIEnv* env, jclass clazz, jlong slot) {
 
 
-//@line:396
+//@line:259
 
 			return ((FT_GlyphSlot)slot)->linearHoriAdvance;
 		
@@ -375,7 +237,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphSlot_getLinearVertAdvance(JNIEnv* env, jclass clazz, jlong slot) {
 
 
-//@line:404
+//@line:267
 
 			return ((FT_GlyphSlot)slot)->linearVertAdvance;
 		
@@ -385,7 +247,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphSlot_getAdvanceX(JNIEnv* env, jclass clazz, jlong slot) {
 
 
-//@line:412
+//@line:275
 
 			return ((FT_GlyphSlot)slot)->advance.x;
 		
@@ -395,7 +257,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphSlot_getAdvanceY(JNIEnv* env, jclass clazz, jlong slot) {
 
 
-//@line:420
+//@line:283
 
 			return ((FT_GlyphSlot)slot)->advance.y;
 		
@@ -405,7 +267,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphSlot_getFormat(JNIEnv* env, jclass clazz, jlong slot) {
 
 
-//@line:428
+//@line:291
 
 			return ((FT_GlyphSlot)slot)->format;
 		
@@ -415,7 +277,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphSlot_getBitmap(JNIEnv* env, jclass clazz, jlong slot) {
 
 
-//@line:436
+//@line:299
 
 			FT_GlyphSlot glyph = ((FT_GlyphSlot)slot);
 			return (jlong)&(glyph->bitmap);
@@ -426,7 +288,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_000
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphSlot_getBitmapLeft(JNIEnv* env, jclass clazz, jlong slot) {
 
 
-//@line:445
+//@line:308
 
 			return ((FT_GlyphSlot)slot)->bitmap_left;
 		
@@ -436,275 +298,298 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphSlot_getBitmapTop(JNIEnv* env, jclass clazz, jlong slot) {
 
 
-//@line:453
+//@line:316
 
 			return ((FT_GlyphSlot)slot)->bitmap_top;
 		
 
 }
 
-JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphSlot_renderGlyph(JNIEnv* env, jclass clazz, jlong slot, jint renderMode) {
-
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getRows(JNIEnv* env, jclass clazz, jlong bitmap) {
 
-//@line:461
 
-			return !FT_Render_Glyph((FT_GlyphSlot)slot, (FT_Render_Mode)renderMode);
+//@line:330
+
+			return ((FT_Bitmap*)bitmap)->rows;
 		
 
 }
 
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphSlot_getGlyph(JNIEnv* env, jclass clazz, jlong glyphSlot) {
-
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getWidth(JNIEnv* env, jclass clazz, jlong bitmap) {
 
-//@line:471
 
-			FT_Glyph glyph;
-			FT_Error error = FT_Get_Glyph((FT_GlyphSlot)glyphSlot, &glyph);
-			if(error) return 0;
-			else return (jlong)glyph;
+//@line:338
+
+			return ((FT_Bitmap*)bitmap)->width;
 		
 
 }
 
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Glyph_done(JNIEnv* env, jclass clazz, jlong glyph) {
-
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getPitch(JNIEnv* env, jclass clazz, jlong bitmap) {
 
-//@line:491
 
-			FT_Done_Glyph((FT_Glyph)glyph);
+//@line:346
+
+			return ((FT_Bitmap*)bitmap)->pitch;
 		
 
 }
 
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Glyph_strokeBorder(JNIEnv* env, jclass clazz, jlong glyph, jlong stroker, jboolean inside) {
-
+JNIEXPORT jobject JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getBuffer(JNIEnv* env, jclass clazz, jlong bitmap) {
 
-//@line:499
 
-			FT_Glyph border_glyph = (FT_Glyph)glyph;
-			FT_Glyph_StrokeBorder(&border_glyph, (FT_Stroker)stroker, inside, 1);
-			return (jlong)border_glyph;
+//@line:376
+
+			FT_Bitmap* bmp = (FT_Bitmap*)bitmap;
+			return env->NewDirectByteBuffer((void*)bmp->buffer, bmp->rows * abs(bmp->pitch));
 		
 
 }
 
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Glyph_toBitmap(JNIEnv* env, jclass clazz, jlong glyph, jint renderMode) {
-
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getNumGray(JNIEnv* env, jclass clazz, jlong bitmap) {
 
-//@line:512
 
-			FT_Glyph bitmap = (FT_Glyph)glyph;
-			FT_Error error = FT_Glyph_To_Bitmap(&bitmap, (FT_Render_Mode)renderMode, NULL, 1);
-			if(error) return 0;
-			return (jlong)bitmap;
+//@line:385
+
+			return ((FT_Bitmap*)bitmap)->num_grays;
 		
 
 }
 
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Glyph_getBitmap(JNIEnv* env, jclass clazz, jlong glyph) {
-
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getPixelMode(JNIEnv* env, jclass clazz, jlong bitmap) {
 
-//@line:526
 
-			FT_BitmapGlyph glyph_bitmap = ((FT_BitmapGlyph)glyph);
-			return (jlong)&(glyph_bitmap->bitmap);
+//@line:393
+
+			return ((FT_Bitmap*)bitmap)->pixel_mode;
 		
 
 }
 
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Glyph_getLeft(JNIEnv* env, jclass clazz, jlong glyph) {
-
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getWidth(JNIEnv* env, jclass clazz, jlong metrics) {
 
-//@line:538
 
-			FT_BitmapGlyph glyph_bitmap = ((FT_BitmapGlyph)glyph);
-			return glyph_bitmap->left;
+//@line:407
+
+			return ((FT_Glyph_Metrics*)metrics)->width;
 		
 
 }
 
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Glyph_getTop(JNIEnv* env, jclass clazz, jlong glyph) {
-
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getHeight(JNIEnv* env, jclass clazz, jlong metrics) {
 
-//@line:550
 
-			FT_BitmapGlyph glyph_bitmap = ((FT_BitmapGlyph)glyph);
-			return glyph_bitmap->top;
+//@line:415
+
+			return ((FT_Glyph_Metrics*)metrics)->height;
 		
 
 }
 
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getRows(JNIEnv* env, jclass clazz, jlong bitmap) {
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getHoriBearingX(JNIEnv* env, jclass clazz, jlong metrics) {
 
 
-//@line:566
+//@line:423
 
-			return ((FT_Bitmap*)bitmap)->rows;
+			return ((FT_Glyph_Metrics*)metrics)->horiBearingX;
 		
 
 }
 
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getWidth(JNIEnv* env, jclass clazz, jlong bitmap) {
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getHoriBearingY(JNIEnv* env, jclass clazz, jlong metrics) {
 
 
-//@line:574
+//@line:431
 
-			return ((FT_Bitmap*)bitmap)->width;
+			return ((FT_Glyph_Metrics*)metrics)->horiBearingY;
 		
 
 }
 
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getPitch(JNIEnv* env, jclass clazz, jlong bitmap) {
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getHoriAdvance(JNIEnv* env, jclass clazz, jlong metrics) {
 
 
-//@line:582
+//@line:439
 
-			return ((FT_Bitmap*)bitmap)->pitch;
+			return ((FT_Glyph_Metrics*)metrics)->horiAdvance;
 		
 
 }
 
-JNIEXPORT jobject JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getBuffer(JNIEnv* env, jclass clazz, jlong bitmap) {
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getVertBearingX(JNIEnv* env, jclass clazz, jlong metrics) {
 
 
-//@line:630
+//@line:447
 
-			FT_Bitmap* bmp = (FT_Bitmap*)bitmap;
-			return env->NewDirectByteBuffer((void*)bmp->buffer, bmp->rows * abs(bmp->pitch));
+			return ((FT_Glyph_Metrics*)metrics)->vertBearingX;
 		
 
 }
 
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getNumGray(JNIEnv* env, jclass clazz, jlong bitmap) {
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getVertBearingY(JNIEnv* env, jclass clazz, jlong metrics) {
 
 
-//@line:639
+//@line:455
 
-			return ((FT_Bitmap*)bitmap)->num_grays;
-		
+			return ((FT_Glyph_Metrics*)metrics)->vertBearingY;
+		 
 
 }
 
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getPixelMode(JNIEnv* env, jclass clazz, jlong bitmap) {
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getVertAdvance(JNIEnv* env, jclass clazz, jlong metrics) {
 
 
-//@line:647
+//@line:463
 
-			return ((FT_Bitmap*)bitmap)->pixel_mode;
+			return ((FT_Glyph_Metrics*)metrics)->vertAdvance;
 		
 
 }
 
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getWidth(JNIEnv* env, jclass clazz, jlong metrics) {
+JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_initFreeTypeJni(JNIEnv* env, jclass clazz) {
 
 
-//@line:661
+//@line:547
 
-			return ((FT_Glyph_Metrics*)metrics)->width;
-		
+		FT_Library library = 0;
+		FT_Error error = FT_Init_FreeType(&library);
+		if(error) return 0;
+		else return (jlong)library;
+	
 
 }
 
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getHeight(JNIEnv* env, jclass clazz, jlong metrics) {
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_doneFreeType(JNIEnv* env, jclass clazz, jlong library) {
 
 
-//@line:669
+//@line:561
 
-			return ((FT_Glyph_Metrics*)metrics)->height;
-		
+		FT_Done_FreeType((FT_Library)library);
+	
 
 }
 
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getHoriBearingX(JNIEnv* env, jclass clazz, jlong metrics) {
-
+static inline jlong wrapped_Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_newMemoryFace
+(JNIEnv* env, jclass clazz, jlong library, jobject obj_data, jint dataSize, jint faceIndex, char* data) {
 
-//@line:677
+//@line:584
 
-			return ((FT_Glyph_Metrics*)metrics)->horiBearingX;
-		
+		FT_Face face = 0;
+		FT_Error error = FT_New_Memory_Face((FT_Library)library, (const FT_Byte*)data, dataSize, faceIndex, &face);
+		if(error) return 0;
+		else return (jlong)face; 
+	
+}
+
+JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_newMemoryFace(JNIEnv* env, jclass clazz, jlong library, jobject obj_data, jint dataSize, jint faceIndex) {
+	char* data = (char*)(obj_data?env->GetDirectBufferAddress(obj_data):0);
+
+	jlong JNI_returnValue = wrapped_Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_newMemoryFace(env, clazz, library, obj_data, dataSize, faceIndex, data);
 
+
+	return JNI_returnValue;
 }
 
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getHoriBearingY(JNIEnv* env, jclass clazz, jlong metrics) {
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_doneFace(JNIEnv* env, jclass clazz, jlong face) {
 
 
-//@line:685
+//@line:600
 
-			return ((FT_Glyph_Metrics*)metrics)->horiBearingY;
-		
+		FT_Done_Face((FT_Face)face);
+	
 
 }
 
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getHoriAdvance(JNIEnv* env, jclass clazz, jlong metrics) {
+JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_selectSize(JNIEnv* env, jclass clazz, jlong face, jint strike_index) {
 
 
-//@line:693
+//@line:608
 
-			return ((FT_Glyph_Metrics*)metrics)->horiAdvance;
-		
+		return !FT_Select_Size((FT_Face)face, strike_index);
+	
 
 }
 
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getVertBearingX(JNIEnv* env, jclass clazz, jlong metrics) {
+JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_setCharSize(JNIEnv* env, jclass clazz, jlong face, jint charWidth, jint charHeight, jint horzResolution, jint vertResolution) {
 
 
-//@line:701
+//@line:616
 
-			return ((FT_Glyph_Metrics*)metrics)->vertBearingX;
-		
+		return !FT_Set_Char_Size((FT_Face)face, charWidth, charHeight, horzResolution, vertResolution);
+	
 
 }
 
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getVertBearingY(JNIEnv* env, jclass clazz, jlong metrics) {
+JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_setPixelSizes(JNIEnv* env, jclass clazz, jlong face, jint pixelWidth, jint pixelHeight) {
 
 
-//@line:709
+//@line:624
 
-			return ((FT_Glyph_Metrics*)metrics)->vertBearingY;
-		 
+		return !FT_Set_Pixel_Sizes((FT_Face)face, pixelWidth, pixelHeight);
+	
 
 }
 
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getVertAdvance(JNIEnv* env, jclass clazz, jlong metrics) {
+JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_loadGlyph(JNIEnv* env, jclass clazz, jlong face, jint glyphIndex, jint loadFlags) {
 
 
-//@line:717
+//@line:632
 
-			return ((FT_Glyph_Metrics*)metrics)->vertAdvance;
-		
+		return !FT_Load_Glyph((FT_Face)face, glyphIndex, loadFlags);
+	
 
 }
 
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Stroker_set(JNIEnv* env, jclass clazz, jlong stroker, jint radius, jint lineCap, jint lineJoin, jint miterLimit) {
+JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_loadChar(JNIEnv* env, jclass clazz, jlong face, jint charCode, jint loadFlags) {
 
 
-//@line:731
+//@line:640
+
+		return !FT_Load_Char((FT_Face)face, charCode, loadFlags);
+	
 
-			FT_Stroker_Set((FT_Stroker)stroker, radius, (FT_Stroker_LineCap)lineCap, (FT_Stroker_LineJoin)lineJoin, miterLimit);
-		
+}
+
+JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_renderGlyph(JNIEnv* env, jclass clazz, jlong slot, jint renderMode) {
+
+
+//@line:648
+
+		return !FT_Render_Glyph((FT_GlyphSlot)slot, (FT_Render_Mode)renderMode);
+	
 
 }
 
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Stroker_done(JNIEnv* env, jclass clazz, jlong stroker) {
+JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_hasKerning(JNIEnv* env, jclass clazz, jlong face) {
 
 
-//@line:740
+//@line:656
+
+   	return FT_HAS_KERNING(((FT_Face)face));
+   
 
-			FT_Stroker_Done((FT_Stroker)stroker);
-		
+}
+
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_getKerning(JNIEnv* env, jclass clazz, jlong face, jint leftGlyph, jint rightGlyph, jint kernMode) {
+
+
+//@line:664
+
+   	FT_Vector kerning;
+   	FT_Error error = FT_Get_Kerning((FT_Face)face, leftGlyph, rightGlyph, kernMode, &kerning);
+   	if(error) return 0;
+   	return kerning.x;
+   
 
 }
 
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_initFreeTypeJni(JNIEnv* env, jclass clazz) {
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_getCharIndex(JNIEnv* env, jclass clazz, jlong face, jint charCode) {
 
 
-//@line:834
+//@line:675
 
-		FT_Library library = 0;
-		FT_Error error = FT_Init_FreeType(&library);
-		if(error) return 0;
-		else return (jlong)library;
-	
+   	return FT_Get_Char_Index((FT_Face)face, charCode);
+   
 
 }
 
diff --git a/extensions/gdx-freetype/jni/com.badlogic.gdx.graphics.g2d.freetype.FreeType.h b/extensions/gdx-freetype/jni/com.badlogic.gdx.graphics.g2d.freetype.FreeType.h
index e385283..55e1dbc 100644
--- a/extensions/gdx-freetype/jni/com.badlogic.gdx.graphics.g2d.freetype.FreeType.h
+++ b/extensions/gdx-freetype/jni/com.badlogic.gdx.graphics.g2d.freetype.FreeType.h
@@ -1,163 +1,251 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class com_badlogic_gdx_graphics_g2d_freetype_FreeType */
-
-#ifndef _Included_com_badlogic_gdx_graphics_g2d_freetype_FreeType
-#define _Included_com_badlogic_gdx_graphics_g2d_freetype_FreeType
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType
- * Method:    initFreeTypeJni
- * Signature: ()J
- */
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_initFreeTypeJni
-  (JNIEnv *, jclass);
-
+/* DO NOT EDIT THIS FILE - it is machine generated */
+#include <jni.h>
+/* Header for class com_badlogic_gdx_graphics_g2d_freetype_FreeType */
+
+#ifndef _Included_com_badlogic_gdx_graphics_g2d_freetype_FreeType
+#define _Included_com_badlogic_gdx_graphics_g2d_freetype_FreeType
+#ifdef __cplusplus
+extern "C" {
+#endif
+/*
+ * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType
+ * Method:    initFreeTypeJni
+ * Signature: ()J
+ */
+JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_initFreeTypeJni
+  (JNIEnv *, jclass);
+
+/*
+ * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType
+ * Method:    doneFreeType
+ * Signature: (J)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_doneFreeType
+  (JNIEnv *, jclass, jlong);
+
+/*
+ * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType
+ * Method:    newMemoryFace
+ * Signature: (JLjava/nio/ByteBuffer;II)J
+ */
+JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_newMemoryFace
+  (JNIEnv *, jclass, jlong, jobject, jint, jint);
+
+/*
+ * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType
+ * Method:    doneFace
+ * Signature: (J)V
+ */
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_doneFace
+  (JNIEnv *, jclass, jlong);
+
+/*
+ * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType
+ * Method:    selectSize
+ * Signature: (JI)Z
+ */
+JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_selectSize
+  (JNIEnv *, jclass, jlong, jint);
+
+/*
+ * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType
+ * Method:    setCharSize
+ * Signature: (JIIII)Z
+ */
+JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_setCharSize
+  (JNIEnv *, jclass, jlong, jint, jint, jint, jint);
+
+/*
+ * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType
+ * Method:    setPixelSizes
+ * Signature: (JII)Z
+ */
+JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_setPixelSizes
+  (JNIEnv *, jclass, jlong, jint, jint);
+
+/*
+ * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType
+ * Method:    loadGlyph
+ * Signature: (JII)Z
+ */
+JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_loadGlyph
+  (JNIEnv *, jclass, jlong, jint, jint);
+
+/*
+ * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType
+ * Method:    loadChar
+ * Signature: (JII)Z
+ */
+JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_loadChar
+  (JNIEnv *, jclass, jlong, jint, jint);
+
+/*
+ * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType
+ * Method:    renderGlyph
+ * Signature: (JI)Z
+ */
+JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_renderGlyph
+  (JNIEnv *, jclass, jlong, jint);
+
+/*
+ * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType
+ * Method:    hasKerning
+ * Signature: (J)Z
+ */
+JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_hasKerning
+  (JNIEnv *, jclass, jlong);
+
+/*
+ * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType
+ * Method:    getKerning
+ * Signature: (JIII)I
+ */
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_getKerning
+  (JNIEnv *, jclass, jlong, jint, jint, jint);
+
+/*
+ * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType
+ * Method:    getCharIndex
+ * Signature: (JI)I
+ */
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_getCharIndex
+  (JNIEnv *, jclass, jlong, jint);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+/* Header for class com_badlogic_gdx_graphics_g2d_freetype_FreeType_Bitmap */
+
+#ifndef _Included_com_badlogic_gdx_graphics_g2d_freetype_FreeType_Bitmap
+#define _Included_com_badlogic_gdx_graphics_g2d_freetype_FreeType_Bitmap
+#ifdef __cplusplus
+extern "C" {
+#endif
+/*
+ * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Bitmap
+ * Method:    getRows
+ * Signature: (J)I
+ */
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getRows
+  (JNIEnv *, jclass, jlong);
+
+/*
+ * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Bitmap
+ * Method:    getWidth
+ * Signature: (J)I
+ */
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getWidth
+  (JNIEnv *, jclass, jlong);
+
+/*
+ * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Bitmap
+ * Method:    getPitch
+ * Signature: (J)I
+ */
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getPitch
+  (JNIEnv *, jclass, jlong);
+
+/*
+ * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Bitmap
+ * Method:    getBuffer
+ * Signature: (J)Ljava/nio/ByteBuffer;
+ */
+JNIEXPORT jobject JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getBuffer
+  (JNIEnv *, jclass, jlong);
+
+/*
+ * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Bitmap
+ * Method:    getNumGray
+ * Signature: (J)I
+ */
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getNumGray
+  (JNIEnv *, jclass, jlong);
+
+/*
+ * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Bitmap
+ * Method:    getPixelMode
+ * Signature: (J)I
+ */
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getPixelMode
+  (JNIEnv *, jclass, jlong);
+
 #ifdef __cplusplus
 }
 #endif
 #endif
-/* Header for class com_badlogic_gdx_graphics_g2d_freetype_FreeType_Bitmap */
-
-#ifndef _Included_com_badlogic_gdx_graphics_g2d_freetype_FreeType_Bitmap
-#define _Included_com_badlogic_gdx_graphics_g2d_freetype_FreeType_Bitmap
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Bitmap
- * Method:    getRows
- * Signature: (J)I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getRows
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Bitmap
- * Method:    getWidth
- * Signature: (J)I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getWidth
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Bitmap
- * Method:    getPitch
- * Signature: (J)I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getPitch
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Bitmap
- * Method:    getBuffer
- * Signature: (J)Ljava/nio/ByteBuffer;
- */
-JNIEXPORT jobject JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getBuffer
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Bitmap
- * Method:    getNumGray
- * Signature: (J)I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getNumGray
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Bitmap
- * Method:    getPixelMode
- * Signature: (J)I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Bitmap_getPixelMode
-  (JNIEnv *, jclass, jlong);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
 /* Header for class com_badlogic_gdx_graphics_g2d_freetype_FreeType_Face */
-
+
 #ifndef _Included_com_badlogic_gdx_graphics_g2d_freetype_FreeType_Face
 #define _Included_com_badlogic_gdx_graphics_g2d_freetype_FreeType_Face
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Face
- * Method:    doneFace
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_doneFace
-  (JNIEnv *, jclass, jlong);
-
-/*
+#ifdef __cplusplus
+extern "C" {
+#endif
+/*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Face
  * Method:    getFaceFlags
- * Signature: (J)I
- */
+ * Signature: (J)I
+ */
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getFaceFlags
-  (JNIEnv *, jclass, jlong);
-
-/*
+  (JNIEnv *, jclass, jlong);
+
+/*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Face
  * Method:    getStyleFlags
- * Signature: (J)I
- */
+ * Signature: (J)I
+ */
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getStyleFlags
-  (JNIEnv *, jclass, jlong);
-
-/*
+  (JNIEnv *, jclass, jlong);
+
+/*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Face
  * Method:    getNumGlyphs
- * Signature: (J)I
- */
+ * Signature: (J)I
+ */
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getNumGlyphs
-  (JNIEnv *, jclass, jlong);
-
-/*
+  (JNIEnv *, jclass, jlong);
+
+/*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Face
  * Method:    getAscender
- * Signature: (J)I
- */
+ * Signature: (J)I
+ */
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getAscender
-  (JNIEnv *, jclass, jlong);
-
-/*
+  (JNIEnv *, jclass, jlong);
+
+/*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Face
  * Method:    getDescender
- * Signature: (J)I
- */
+ * Signature: (J)I
+ */
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getDescender
-  (JNIEnv *, jclass, jlong);
-
-/*
+  (JNIEnv *, jclass, jlong);
+
+/*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Face
  * Method:    getHeight
  * Signature: (J)I
- */
+ */
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getHeight
-  (JNIEnv *, jclass, jlong);
-
-/*
+  (JNIEnv *, jclass, jlong);
+
+/*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Face
  * Method:    getMaxAdvanceWidth
- * Signature: (J)I
- */
+ * Signature: (J)I
+ */
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getMaxAdvanceWidth
-  (JNIEnv *, jclass, jlong);
-
-/*
+  (JNIEnv *, jclass, jlong);
+
+/*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Face
  * Method:    getMaxAdvanceHeight
- * Signature: (J)I
- */
+ * Signature: (J)I
+ */
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getMaxAdvanceHeight
-  (JNIEnv *, jclass, jlong);
-
-/*
+  (JNIEnv *, jclass, jlong);
+
+/*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Face
  * Method:    getUnderlinePosition
  * Signature: (J)I
@@ -175,143 +263,20 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 
 /*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Face
- * Method:    selectSize
- * Signature: (JI)Z
- */
-JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_selectSize
-  (JNIEnv *, jclass, jlong, jint);
-
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Face
- * Method:    setCharSize
- * Signature: (JIIII)Z
- */
-JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_setCharSize
-  (JNIEnv *, jclass, jlong, jint, jint, jint, jint);
-
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Face
- * Method:    setPixelSizes
- * Signature: (JII)Z
- */
-JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_setPixelSizes
-  (JNIEnv *, jclass, jlong, jint, jint);
-
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Face
- * Method:    loadGlyph
- * Signature: (JII)Z
- */
-JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_loadGlyph
-  (JNIEnv *, jclass, jlong, jint, jint);
-
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Face
- * Method:    loadChar
- * Signature: (JII)Z
- */
-JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_loadChar
-  (JNIEnv *, jclass, jlong, jint, jint);
-
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Face
  * Method:    getGlyph
  * Signature: (J)J
- */
+ */
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getGlyph
-  (JNIEnv *, jclass, jlong);
-
-/*
+  (JNIEnv *, jclass, jlong);
+
+/*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Face
  * Method:    getSize
  * Signature: (J)J
- */
+ */
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getSize
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Face
- * Method:    hasKerning
- * Signature: (J)Z
- */
-JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_hasKerning
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Face
- * Method:    getKerning
- * Signature: (JIII)I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getKerning
-  (JNIEnv *, jclass, jlong, jint, jint, jint);
-
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Face
- * Method:    getCharIndex
- * Signature: (JI)I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Face_getCharIndex
-  (JNIEnv *, jclass, jlong, jint);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
-/* Header for class com_badlogic_gdx_graphics_g2d_freetype_FreeType_Glyph */
-
-#ifndef _Included_com_badlogic_gdx_graphics_g2d_freetype_FreeType_Glyph
-#define _Included_com_badlogic_gdx_graphics_g2d_freetype_FreeType_Glyph
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Glyph
- * Method:    done
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Glyph_done
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Glyph
- * Method:    strokeBorder
- * Signature: (JJZ)J
- */
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Glyph_strokeBorder
-  (JNIEnv *, jclass, jlong, jlong, jboolean);
-
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Glyph
- * Method:    toBitmap
- * Signature: (JI)J
- */
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Glyph_toBitmap
-  (JNIEnv *, jclass, jlong, jint);
+  (JNIEnv *, jclass, jlong);
 
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Glyph
- * Method:    getBitmap
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Glyph_getBitmap
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Glyph
- * Method:    getLeft
- * Signature: (J)I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Glyph_getLeft
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Glyph
- * Method:    getTop
- * Signature: (J)I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Glyph_getTop
-  (JNIEnv *, jclass, jlong);
-
 #ifdef __cplusplus
 }
 #endif
@@ -323,70 +288,70 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 #ifdef __cplusplus
 extern "C" {
 #endif
-/*
+/*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_GlyphMetrics
  * Method:    getWidth
- * Signature: (J)I
- */
+ * Signature: (J)I
+ */
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getWidth
-  (JNIEnv *, jclass, jlong);
-
-/*
+  (JNIEnv *, jclass, jlong);
+
+/*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_GlyphMetrics
  * Method:    getHeight
- * Signature: (J)I
- */
+ * Signature: (J)I
+ */
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getHeight
-  (JNIEnv *, jclass, jlong);
-
-/*
+  (JNIEnv *, jclass, jlong);
+
+/*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_GlyphMetrics
  * Method:    getHoriBearingX
  * Signature: (J)I
- */
+ */
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getHoriBearingX
-  (JNIEnv *, jclass, jlong);
-
-/*
+  (JNIEnv *, jclass, jlong);
+
+/*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_GlyphMetrics
  * Method:    getHoriBearingY
- * Signature: (J)I
- */
+ * Signature: (J)I
+ */
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getHoriBearingY
-  (JNIEnv *, jclass, jlong);
-
-/*
+  (JNIEnv *, jclass, jlong);
+
+/*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_GlyphMetrics
  * Method:    getHoriAdvance
- * Signature: (J)I
- */
+ * Signature: (J)I
+ */
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getHoriAdvance
-  (JNIEnv *, jclass, jlong);
-
-/*
+  (JNIEnv *, jclass, jlong);
+
+/*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_GlyphMetrics
  * Method:    getVertBearingX
  * Signature: (J)I
- */
+ */
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getVertBearingX
-  (JNIEnv *, jclass, jlong);
-
-/*
+  (JNIEnv *, jclass, jlong);
+
+/*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_GlyphMetrics
  * Method:    getVertBearingY
- * Signature: (J)I
- */
+ * Signature: (J)I
+ */
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getVertBearingY
-  (JNIEnv *, jclass, jlong);
-
-/*
+  (JNIEnv *, jclass, jlong);
+
+/*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_GlyphMetrics
  * Method:    getVertAdvance
- * Signature: (J)I
- */
+ * Signature: (J)I
+ */
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphMetrics_getVertAdvance
-  (JNIEnv *, jclass, jlong);
-
+  (JNIEnv *, jclass, jlong);
+
 #ifdef __cplusplus
 }
 #endif
@@ -398,27 +363,27 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 #ifdef __cplusplus
 extern "C" {
 #endif
-/*
+/*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_GlyphSlot
  * Method:    getMetrics
  * Signature: (J)J
- */
+ */
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphSlot_getMetrics
   (JNIEnv *, jclass, jlong);
-
-/*
+
+/*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_GlyphSlot
  * Method:    getLinearHoriAdvance
  * Signature: (J)I
- */
+ */
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphSlot_getLinearHoriAdvance
   (JNIEnv *, jclass, jlong);
-
-/*
+
+/*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_GlyphSlot
  * Method:    getLinearVertAdvance
  * Signature: (J)I
- */
+ */
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphSlot_getLinearVertAdvance
   (JNIEnv *, jclass, jlong);
 
@@ -444,46 +409,30 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
  * Signature: (J)I
  */
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphSlot_getFormat
-  (JNIEnv *, jclass, jlong);
-
-/*
+  (JNIEnv *, jclass, jlong);
+
+/*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_GlyphSlot
  * Method:    getBitmap
  * Signature: (J)J
- */
+ */
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphSlot_getBitmap
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_GlyphSlot
- * Method:    getBitmapLeft
- * Signature: (J)I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphSlot_getBitmapLeft
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_GlyphSlot
- * Method:    getBitmapTop
- * Signature: (J)I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphSlot_getBitmapTop
   (JNIEnv *, jclass, jlong);
 
 /*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_GlyphSlot
- * Method:    renderGlyph
- * Signature: (JI)Z
+ * Method:    getBitmapLeft
+ * Signature: (J)I
  */
-JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphSlot_renderGlyph
-  (JNIEnv *, jclass, jlong, jint);
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphSlot_getBitmapLeft
+  (JNIEnv *, jclass, jlong);
 
 /*
  * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_GlyphSlot
- * Method:    getGlyph
- * Signature: (J)J
+ * Method:    getBitmapTop
+ * Signature: (J)I
  */
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphSlot_getGlyph
+JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024GlyphSlot_getBitmapTop
   (JNIEnv *, jclass, jlong);
 
 #ifdef __cplusplus
@@ -497,30 +446,6 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_000
 #ifdef __cplusplus
 extern "C" {
 #endif
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Library
- * Method:    doneFreeType
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Library_doneFreeType
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Library
- * Method:    newMemoryFace
- * Signature: (JLjava/nio/ByteBuffer;II)J
- */
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Library_newMemoryFace
-  (JNIEnv *, jclass, jlong, jobject, jint, jint);
-
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Library
- * Method:    strokerNew
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Library_strokerNew
-  (JNIEnv *, jclass, jlong);
-
 #ifdef __cplusplus
 }
 #endif
@@ -532,10 +457,10 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_000
 #ifdef __cplusplus
 extern "C" {
 #endif
-#ifdef __cplusplus
-}
-#endif
-#endif
+#ifdef __cplusplus
+}
+#endif
+#endif
 /* Header for class com_badlogic_gdx_graphics_g2d_freetype_FreeType_Size */
 
 #ifndef _Included_com_badlogic_gdx_graphics_g2d_freetype_FreeType_Size
@@ -630,30 +555,3 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_0002
 }
 #endif
 #endif
-/* Header for class com_badlogic_gdx_graphics_g2d_freetype_FreeType_Stroker */
-
-#ifndef _Included_com_badlogic_gdx_graphics_g2d_freetype_FreeType_Stroker
-#define _Included_com_badlogic_gdx_graphics_g2d_freetype_FreeType_Stroker
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Stroker
- * Method:    set
- * Signature: (JIIII)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Stroker_set
-  (JNIEnv *, jclass, jlong, jint, jint, jint, jint);
-
-/*
- * Class:     com_badlogic_gdx_graphics_g2d_freetype_FreeType_Stroker
- * Method:    done
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_graphics_g2d_freetype_FreeType_00024Stroker_done
-  (JNIEnv *, jclass, jlong);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/extensions/gdx-freetype/jni/maven/pom.xml b/extensions/gdx-freetype/jni/maven/pom.xml
index 6b9d8e9..3624d7e 100644
--- a/extensions/gdx-freetype/jni/maven/pom.xml
+++ b/extensions/gdx-freetype/jni/maven/pom.xml
@@ -4,7 +4,7 @@
     <parent>
         <groupId>com.badlogicgames.gdx</groupId>
         <artifactId>gdx-parent</artifactId>
-        <version>1.5.4-SNAPSHOT</version>
+        <version>1.4.2-SNAPSHOT</version>
         <relativePath>../../../../</relativePath>
     </parent>
     
diff --git a/extensions/gdx-freetype/pom.xml b/extensions/gdx-freetype/pom.xml
index a12970d..09c7e79 100644
--- a/extensions/gdx-freetype/pom.xml
+++ b/extensions/gdx-freetype/pom.xml
@@ -4,7 +4,7 @@
 	<parent>
 		<groupId>com.badlogicgames.gdx</groupId>
 		<artifactId>gdx-parent</artifactId>
-		<version>1.5.4-SNAPSHOT</version>
+		<version>1.4.2-SNAPSHOT</version>
 		<relativePath>../../pom.xml</relativePath>
 	</parent>
 
diff --git a/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeType.java b/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeType.java
index addebd4..4269c87 100644
--- a/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeType.java
+++ b/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeType.java
@@ -17,15 +17,12 @@
 package com.badlogic.gdx.graphics.g2d.freetype;
 
 import java.nio.ByteBuffer;
-import java.nio.IntBuffer;
 
 import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.Pixmap;
 import com.badlogic.gdx.graphics.Pixmap.Blending;
 import com.badlogic.gdx.graphics.Pixmap.Format;
 import com.badlogic.gdx.utils.BufferUtils;
-import com.badlogic.gdx.utils.Disposable;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 import com.badlogic.gdx.utils.LongMap;
 import com.badlogic.gdx.utils.SharedLibraryLoader;
@@ -35,9 +32,8 @@ public class FreeType {
 	/*JNI
 	#include <ft2build.h>
 	#include FT_FREETYPE_H
-	#include FT_STROKER_H
-	 */
-
+	 */	
+	
 	private static class Pointer {
 		long address;
 		
@@ -46,66 +42,15 @@ public class FreeType {
 		}
 	}
 	
-	public static class Library extends Pointer implements Disposable {
+	public static class Library extends Pointer {
 		LongMap<ByteBuffer> fontData = new LongMap<ByteBuffer>();
 		
 		Library (long address) {
 			super(address);
 		}
-
-		@Override
-		public void dispose () {
-			doneFreeType(address);
-			for(ByteBuffer buffer: fontData.values()) {
-				BufferUtils.disposeUnsafeByteBuffer(buffer);
-			}
-		}
-
-		private static native void doneFreeType(long library); /*
-			FT_Done_FreeType((FT_Library)library);
-		*/
-
-		public Face newFace(FileHandle font, int faceIndex) {
-			byte[] data = font.readBytes();
-			return newMemoryFace(data, data.length, faceIndex);
-		}
-
-		public Face newMemoryFace(byte[] data, int dataSize, int faceIndex) {
-			ByteBuffer buffer = BufferUtils.newUnsafeByteBuffer(data.length);
-			BufferUtils.copy(data, 0, buffer, data.length);
-			long face = newMemoryFace(address, buffer, dataSize, faceIndex);
-			if(face == 0) {
-				BufferUtils.disposeUnsafeByteBuffer(buffer);
-				throw new GdxRuntimeException("Couldn't load font");
-			}
-			else {
-				fontData.put(face, buffer);
-				return new Face(face, this);
-			}
-		}
-
-		private static native long newMemoryFace(long library, ByteBuffer data, int dataSize, int faceIndex); /*
-			FT_Face face = 0;
-			FT_Error error = FT_New_Memory_Face((FT_Library)library, (const FT_Byte*)data, dataSize, faceIndex, &face);
-			if(error) return 0;
-			else return (jlong)face;
-		*/
-
-		public Stroker createStroker() {
-			long stroker = strokerNew(address);
-			if(stroker == 0) throw new GdxRuntimeException("Couldn't create FreeType stroker");
-			return new Stroker(stroker);
-		}
-
-		private static native long strokerNew(long library); /*
-			FT_Stroker stroker;
-			FT_Error error = FT_Stroker_New((FT_Library)library, &stroker);
-			if(error) return 0;
-			else return (jlong)stroker;
-		*/
 	}
 	
-	public static class Face extends Pointer implements Disposable {
+	public static class Face extends Pointer {
 		Library library;
 		
 		public Face (long address, Library library) {
@@ -113,20 +58,6 @@ public class FreeType {
 			this.library = library;
 		}
 		
-		@Override
-		public void dispose() {
-			doneFace(address);
-			ByteBuffer buffer = library.fontData.get(address);
-			if(buffer != null) {
-				library.fontData.remove(address);
-				BufferUtils.disposeUnsafeByteBuffer(buffer);
-			}
-		}
-
-		private static native void doneFace(long face); /*
-			FT_Done_Face((FT_Face)face);
-		*/
-
 		public int getFaceFlags() {
 			return getFaceFlags(address);
 		}
@@ -207,46 +138,6 @@ public class FreeType {
 			return ((FT_Face)face)->underline_thickness;
 		*/
 		
-		public boolean selectSize(int strikeIndex) {
-			return selectSize(address, strikeIndex);
-		}
-
-		private static native boolean selectSize(long face, int strike_index); /*
-			return !FT_Select_Size((FT_Face)face, strike_index);
-		*/
-
-		public boolean setCharSize(int charWidth, int charHeight, int horzResolution, int vertResolution) {
-			return setCharSize(address, charWidth, charHeight, horzResolution, vertResolution);
-		}
-
-		private static native boolean setCharSize(long face, int charWidth, int charHeight, int horzResolution, int vertResolution); /*
-			return !FT_Set_Char_Size((FT_Face)face, charWidth, charHeight, horzResolution, vertResolution);
-		*/
-
-		public boolean setPixelSizes(int pixelWidth, int pixelHeight) {
-			return setPixelSizes(address, pixelWidth, pixelHeight);
-		}
-
-		private static native boolean setPixelSizes(long face, int pixelWidth, int pixelHeight); /*
-			return !FT_Set_Pixel_Sizes((FT_Face)face, pixelWidth, pixelHeight);
-		*/
-
-		public boolean loadGlyph(int glyphIndex, int loadFlags) {
-			return loadGlyph(address, glyphIndex, loadFlags);
-		}
-
-		private static native boolean loadGlyph(long face, int glyphIndex, int loadFlags); /*
-			return !FT_Load_Glyph((FT_Face)face, glyphIndex, loadFlags);
-		*/
-
-		public boolean loadChar(int charCode, int loadFlags) {
-			return loadChar(address, charCode, loadFlags);
-		}
-
-		private static native boolean loadChar(long face, int charCode, int loadFlags); /*
-			return !FT_Load_Char((FT_Face)face, charCode, loadFlags);
-		*/
-
 		public GlyphSlot getGlyph() {
 			return new GlyphSlot(getGlyph(address));
 		}
@@ -262,34 +153,6 @@ public class FreeType {
 		private static native long getSize(long face); /*
 			return (jlong)((FT_Face)face)->size;
 		*/
-
-		public boolean hasKerning() {
-			return hasKerning(address);
-		}
-
-		private static native boolean hasKerning(long face); /*
-			return FT_HAS_KERNING(((FT_Face)face));
-		*/
-
-		public int getKerning(int leftGlyph, int rightGlyph, int kernMode) {
-			return getKerning(address, leftGlyph, rightGlyph, kernMode);
-		}
-
-		private static native int getKerning(long face, int leftGlyph, int rightGlyph, int kernMode); /*
-			FT_Vector kerning;
-			FT_Error error = FT_Get_Kerning((FT_Face)face, leftGlyph, rightGlyph, kernMode, &kerning);
-			if(error) return 0;
-			return kerning.x;
-		*/
-
-		public int getCharIndex(int charCode) {
-			return getCharIndex(address, charCode);
-		}
-
-		private static native int getCharIndex(long face, int charCode); /*
-			return FT_Get_Char_Index((FT_Face)face, charCode);
-		*/
-
 	}
 	
 	public static class Size extends Pointer {
@@ -453,107 +316,8 @@ public class FreeType {
 		private static native int getBitmapTop(long slot); /*
 			return ((FT_GlyphSlot)slot)->bitmap_top;
 		*/
-
-		public boolean renderGlyph(int renderMode) {
-			return renderGlyph(address, renderMode);
-		}
-
-		private static native boolean renderGlyph(long slot, int renderMode); /*
-			return !FT_Render_Glyph((FT_GlyphSlot)slot, (FT_Render_Mode)renderMode);
-		*/
-
-		public Glyph getGlyph() {
-			long glyph = getGlyph(address);
-			if(glyph == 0) throw new GdxRuntimeException("Couldn't get glyph");
-			return new Glyph(glyph);
-		}
-
-		private static native long getGlyph(long glyphSlot); /*
-			FT_Glyph glyph;
-			FT_Error error = FT_Get_Glyph((FT_GlyphSlot)glyphSlot, &glyph);
-			if(error) return 0;
-			else return (jlong)glyph;
-		*/
 	}
 	
-	public static class Glyph extends Pointer implements Disposable {
-		private boolean rendered;
-
-		Glyph (long address) {
-			super(address);
-		}
-
-		@Override
-		public void dispose () {
-			done(address);
-		}
-
-		private static native void done(long glyph); /*
-			FT_Done_Glyph((FT_Glyph)glyph);
-		*/
-
-		public void strokeBorder(Stroker stroker, boolean inside) {
-			address = strokeBorder(address, stroker.address, inside);
-		}
-
-		private static native long strokeBorder(long glyph, long stroker, boolean inside); /*
-			FT_Glyph border_glyph = (FT_Glyph)glyph;
-			FT_Glyph_StrokeBorder(&border_glyph, (FT_Stroker)stroker, inside, 1);
-			return (jlong)border_glyph;
-		*/
-
-		public void toBitmap(int renderMode) {
-			long bitmap = toBitmap(address, renderMode);
-			if (bitmap == 0) throw new GdxRuntimeException("Couldn't render glyph");
-			address = bitmap;
-			rendered = true;
-		}
-
-		private static native long toBitmap(long glyph, int renderMode); /*
-			FT_Glyph bitmap = (FT_Glyph)glyph;
-			FT_Error error = FT_Glyph_To_Bitmap(&bitmap, (FT_Render_Mode)renderMode, NULL, 1);
-			if(error) return 0;
-			return (jlong)bitmap;
-		*/
-
-		public Bitmap getBitmap() {
-			if (!rendered) {
-				throw new GdxRuntimeException("Glyph is not yet rendered");
-			}
-			return new Bitmap(getBitmap(address));
-		}
-
-		private static native long getBitmap(long glyph); /*
-			FT_BitmapGlyph glyph_bitmap = ((FT_BitmapGlyph)glyph);
-			return (jlong)&(glyph_bitmap->bitmap);
-		*/
-
-		public int getLeft() {
-			if (!rendered) {
-				throw new GdxRuntimeException("Glyph is not yet rendered");
-			}
-			return getLeft(address);
-		}
-
-		private static native int getLeft(long glyph); /*
-			FT_BitmapGlyph glyph_bitmap = ((FT_BitmapGlyph)glyph);
-			return glyph_bitmap->left;
-		*/
-
-		public int getTop() {
-			if (!rendered) {
-				throw new GdxRuntimeException("Glyph is not yet rendered");
-			}
-			return getTop(address);
-		}
-
-		private static native int getTop(long glyph); /*
-			FT_BitmapGlyph glyph_bitmap = ((FT_BitmapGlyph)glyph);
-			return glyph_bitmap->top;
-		*/
-
-	}
-
 	public static class Bitmap extends Pointer {
 		Bitmap (long address) {
 			super(address);
@@ -598,41 +362,14 @@ public class FreeType {
 		 * @return Pixmap representing the glyph, needs to be disposed manually.
 		 */
 		public Pixmap getPixmap(Format format) {
-			return getPixmap(format, Color.WHITE);
-		}
-
-		public Pixmap getPixmap(Format format, Color color) {
-			int width = getWidth();
-			ByteBuffer src = getBuffer();
-			Pixmap pixmap;
-			if (color == Color.WHITE) {
-				pixmap = new Pixmap(width, getRows(), Format.Alpha);
-				BufferUtils.copy(src, pixmap.getPixels(), pixmap.getPixels().capacity());
-			} else {
-				pixmap = new Pixmap(width, getRows(), Format.RGBA8888);
-				int srcPitch = getPitch();
-				int srcRGBA = Color.rgba8888(color);
-				IntBuffer dst = pixmap.getPixels().asIntBuffer();
-				for (int y = 0; y < getRows(); y++) {
-					int ySrcPitch = y * srcPitch;
-					int yWidth = y * width;
-					for (int x = 0; x < width; x++) {
-						//use the color value of the foreground color, blend alpha
-						byte alpha = src.get(ySrcPitch + x);
-						dst.put(yWidth + x, (srcRGBA & 0xffffff00) | (int)((srcRGBA & 0xff) * (alpha & 0xff)/255f));
-					}
-				}
-			}
-
-			Pixmap converted = pixmap;
-			if (format != pixmap.getFormat()) {
-				converted = new Pixmap(pixmap.getWidth(), pixmap.getHeight(), format);
-				Blending blending = Pixmap.getBlending();
-				Pixmap.setBlending(Blending.None);
-				converted.drawPixmap(pixmap, 0, 0);
-				Pixmap.setBlending(blending);
-				pixmap.dispose();
-			}
+			Pixmap pixmap = new Pixmap(getWidth(), getRows(), Format.Alpha);
+			BufferUtils.copy(getBuffer(), pixmap.getPixels(), pixmap.getPixels().capacity());
+			Pixmap converted = new Pixmap(pixmap.getWidth(), pixmap.getHeight(), format);
+			Blending blending = Pixmap.getBlending();
+			Pixmap.setBlending(Blending.None);
+			converted.drawPixmap(pixmap, 0, 0);
+			Pixmap.setBlending(blending);
+			pixmap.dispose();
 			return converted;
 		}
 		
@@ -727,30 +464,7 @@ public class FreeType {
 			return ((FT_Glyph_Metrics*)metrics)->vertAdvance;
 		*/
 	}
-
-	public static class Stroker extends Pointer implements Disposable {
-		Stroker(long address) {
-			super(address);
-		}
-
-		public void set(int radius, int lineCap, int lineJoin, int miterLimit) {
-			set(address, radius, lineCap, lineJoin, miterLimit);
-		}
-
-		private static native void set(long stroker, int radius, int lineCap, int lineJoin, int miterLimit); /*
-			FT_Stroker_Set((FT_Stroker)stroker, radius, (FT_Stroker_LineCap)lineCap, (FT_Stroker_LineJoin)lineJoin, miterLimit);
-		*/
-
-		@Override
-		public void dispose() {
-			done(address);
-		}
-
-		private static native void done(long stroker); /*
-			FT_Stroker_Done((FT_Stroker)stroker);
-		*/
-	}
-
+	
    public static int FT_PIXEL_MODE_NONE = 0;
    public static int FT_PIXEL_MODE_MONO = 1;
    public static int FT_PIXEL_MODE_GRAY = 2;
@@ -823,16 +537,6 @@ public class FreeType {
    public static int FT_KERNING_UNFITTED = 1;
    public static int FT_KERNING_UNSCALED = 2;
 	
-	public static int FT_STROKER_LINECAP_BUTT = 0;
-	public static int FT_STROKER_LINECAP_ROUND = 1;
-	public static int FT_STROKER_LINECAP_SQUARE = 2;
-
-	public static int FT_STROKER_LINEJOIN_ROUND          = 0;
-	public static int FT_STROKER_LINEJOIN_BEVEL          = 1;
-	public static int FT_STROKER_LINEJOIN_MITER_VARIABLE = 2;
-	public static int FT_STROKER_LINEJOIN_MITER          = FT_STROKER_LINEJOIN_MITER_VARIABLE;
-	public static int FT_STROKER_LINEJOIN_MITER_FIXED    = 3;
-
    public static Library initFreeType() {
    	new SharedLibraryLoader().load("gdx-freetype");
    	long address = initFreeTypeJni();
@@ -846,7 +550,132 @@ public class FreeType {
 		if(error) return 0;
 		else return (jlong)library;
 	*/
+	
+	public static void doneFreeType(Library library) {
+		doneFreeType(library.address);
+		for(ByteBuffer buffer: library.fontData.values()) {
+			BufferUtils.disposeUnsafeByteBuffer(buffer);
+		}
+	}
+	
+	private static native void doneFreeType(long library); /*
+		FT_Done_FreeType((FT_Library)library);
+	*/
+	
+	public static Face newFace(Library library, FileHandle font, int faceIndex) {
+		byte[] data = font.readBytes();
+		return newMemoryFace(library, data, data.length, faceIndex);
+	}
+	
+	public static Face newMemoryFace(Library library, byte[] data, int dataSize, int faceIndex) {
+		ByteBuffer buffer = BufferUtils.newUnsafeByteBuffer(data.length);
+		BufferUtils.copy(data, 0, buffer, data.length);
+		long address = newMemoryFace(library.address, buffer, dataSize, faceIndex);
+		if(address == 0) {
+			BufferUtils.disposeUnsafeByteBuffer(buffer);
+			throw new GdxRuntimeException("Couldn't load font");
+		}
+		else {
+			library.fontData.put(address, buffer);
+			return new Face(address, library);
+		}
+	}
+	
+	private static native long newMemoryFace(long library, ByteBuffer data, int dataSize, int faceIndex); /*
+		FT_Face face = 0;
+		FT_Error error = FT_New_Memory_Face((FT_Library)library, (const FT_Byte*)data, dataSize, faceIndex, &face);
+		if(error) return 0;
+		else return (jlong)face; 
+	*/
+	
+	public static void doneFace(Face face) {
+		doneFace(face.address);
+		ByteBuffer buffer = face.library.fontData.get(face.address);
+		if(buffer != null) {
+			face.library.fontData.remove(face.address);
+			BufferUtils.disposeUnsafeByteBuffer(buffer);
+		}
+	}
+	
+	private static native void doneFace(long face); /*
+		FT_Done_Face((FT_Face)face);
+	*/
+	
+	public static boolean selectSize(Face face, int strikeIndex) {
+		return selectSize(face.address, strikeIndex);
+	}
+	
+	private static native boolean selectSize(long face, int strike_index); /*
+		return !FT_Select_Size((FT_Face)face, strike_index);
+	*/
+	
+	public static boolean setCharSize(Face face, int charWidth, int charHeight, int horzResolution, int vertResolution) {
+		return setCharSize(face.address, charWidth, charHeight, horzResolution, vertResolution);
+	}
+	
+	private static native boolean setCharSize(long face, int charWidth, int charHeight, int horzResolution, int vertResolution); /*
+		return !FT_Set_Char_Size((FT_Face)face, charWidth, charHeight, horzResolution, vertResolution);
+	*/
+	
+	public static boolean setPixelSizes(Face face, int pixelWidth, int pixelHeight) {
+		return setPixelSizes(face.address, pixelWidth, pixelHeight);
+	}
+	
+	private static native boolean setPixelSizes(long face, int pixelWidth, int pixelHeight); /*
+		return !FT_Set_Pixel_Sizes((FT_Face)face, pixelWidth, pixelHeight);
+	*/
+	
+	public static boolean loadGlyph(Face face, int glyphIndex, int loadFlags) {
+		return loadGlyph(face.address, glyphIndex, loadFlags);
+	}
+	
+	private static native boolean loadGlyph(long face, int glyphIndex, int loadFlags); /*
+		return !FT_Load_Glyph((FT_Face)face, glyphIndex, loadFlags);
+	*/
 
+	public static boolean loadChar(Face face, int charCode, int loadFlags) {
+		return loadChar(face.address, charCode, loadFlags);
+	}
+	
+	private static native boolean loadChar(long face, int charCode, int loadFlags); /*
+		return !FT_Load_Char((FT_Face)face, charCode, loadFlags);
+	*/
+	
+	public static boolean renderGlyph(GlyphSlot slot, int renderMode) {
+		return renderGlyph(slot.address, renderMode);
+	}
+	
+	private static native boolean renderGlyph(long slot, int renderMode); /*
+		return !FT_Render_Glyph((FT_GlyphSlot)slot, (FT_Render_Mode)renderMode);
+	*/
+   
+	public static boolean hasKerning(Face face) {
+		return hasKerning(face.address);
+	}
+	
+	private static native boolean hasKerning(long face); /*
+   	return FT_HAS_KERNING(((FT_Face)face));
+   */
+   
+	public static int getKerning(Face face, int leftGlyph, int rightGlyph, int kernMode) {
+		return getKerning(face.address, leftGlyph, rightGlyph, kernMode);
+	}
+	
+	private static native int getKerning(long face, int leftGlyph, int rightGlyph, int kernMode); /*
+   	FT_Vector kerning;
+   	FT_Error error = FT_Get_Kerning((FT_Face)face, leftGlyph, rightGlyph, kernMode, &kerning);
+   	if(error) return 0;
+   	return kerning.x;
+   */
+	
+	public static int getCharIndex(Face face, int charCode) {
+		return getCharIndex(face.address, charCode);
+	}
+	
+	private static native int getCharIndex(long face, int charCode); /*
+   	return FT_Get_Char_Index((FT_Face)face, charCode);
+   */
+	
 	public static int toInt (int value) {
 		if (value < 0) return (int)((value - 32) >> 6);
 		else return (int)((value + 32) >> 6);
@@ -858,8 +687,8 @@ public class FreeType {
 //		String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890\"!`?'.,;:()[]{}<>|/@\\^$-%+=#_&~*�?�?�?�?�? ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿À�?ÂÃÄÅÆÇÈÉÊËÌ�?Î�?�?ÑÒÓÔÕÖ×ØÙÚÛÜ�?Þßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ";
 //		
 //		Library library = FreeType.initFreeType();
-//		Face face = library.newFace(new FileHandle("arial.ttf"), 0);
-//		face.setPixelSizes(0, 15);
+//		Face face = FreeType.newFace(library, new FileHandle("arial.ttf"), 0);
+//		FreeType.setPixelSizes(face, 0, 15);
 //		SizeMetrics faceMetrics = face.getSize().getMetrics();
 //		System.out.println(toInt(faceMetrics.getAscender()) + ", " + toInt(faceMetrics.getDescender()) + ", " + toInt(faceMetrics.getHeight()));
 //		
@@ -879,7 +708,7 @@ public class FreeType {
 //			}
 //		}
 //	
-//		face.dispose();
-//		library.dispose();
+//		FreeType.doneFace(face);
+//		FreeType.doneFreeType(library);
 //	}
 }
\ No newline at end of file
diff --git a/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGenerator.java b/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGenerator.java
index 1f79525..cbccac2 100644
--- a/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGenerator.java
+++ b/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGenerator.java
@@ -16,13 +16,10 @@
 
 package com.badlogic.gdx.graphics.g2d.freetype;
 
-import java.nio.ByteBuffer;
-
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.files.FileHandle;
 import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.Pixmap;
-import com.badlogic.gdx.graphics.Pixmap.Blending;
 import com.badlogic.gdx.graphics.Pixmap.Format;
 import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.graphics.Texture.TextureFilter;
@@ -38,7 +35,6 @@ import com.badlogic.gdx.graphics.g2d.freetype.FreeType.GlyphMetrics;
 import com.badlogic.gdx.graphics.g2d.freetype.FreeType.GlyphSlot;
 import com.badlogic.gdx.graphics.g2d.freetype.FreeType.Library;
 import com.badlogic.gdx.graphics.g2d.freetype.FreeType.SizeMetrics;
-import com.badlogic.gdx.graphics.g2d.freetype.FreeType.Stroker;
 import com.badlogic.gdx.graphics.glutils.PixmapTextureData;
 import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.math.Rectangle;
@@ -46,6 +42,8 @@ import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.Disposable;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 
+import java.nio.ByteBuffer;
+
 /** Generates {@link BitmapFont} and {@link BitmapFontData} instances from TrueType font files.</p>
  * 
  * Usage example:
@@ -103,18 +101,18 @@ public class FreeTypeFontGenerator implements Disposable {
 		filePath = font.pathWithoutExtension();
 		library = FreeType.initFreeType();
 		if (library == null) throw new GdxRuntimeException("Couldn't initialize FreeType");
-		face = library.newFace(font, 0);
+		face = FreeType.newFace(library, font, 0);
 		if (face == null) throw new GdxRuntimeException("Couldn't create face for font '" + font + "'");
 		if (checkForBitmapFont()) {
 			return;
 		}
-		if (!face.setPixelSizes(0, 15)) throw new GdxRuntimeException("Couldn't set size for font '" + font + "'");
+		if (!FreeType.setPixelSizes(face, 0, 15)) throw new GdxRuntimeException("Couldn't set size for font '" + font + "'");
 	}
 
 	private boolean checkForBitmapFont () {
 		if (((face.getFaceFlags() & FreeType.FT_FACE_FLAG_FIXED_SIZES) == FreeType.FT_FACE_FLAG_FIXED_SIZES)
 			&& ((face.getFaceFlags() & FreeType.FT_FACE_FLAG_HORIZONTAL) == FreeType.FT_FACE_FLAG_HORIZONTAL)) {
-			if (face.loadChar(32, FreeType.FT_LOAD_DEFAULT)) {
+			if (FreeType.loadChar(face, 32, FreeType.FT_LOAD_DEFAULT)) {
 				GlyphSlot slot = face.getGlyph();
 				if (slot.getFormat() == 1651078259) {
 					bitmapped = true;
@@ -161,7 +159,7 @@ public class FreeTypeFontGenerator implements Disposable {
 	/** Uses ascender and descender of font to calculate real height that makes all glyphs to fit in given pixel size. Source:
 	 * http://nothings.org/stb/stb_truetype.h / stbtt_ScaleForPixelHeight */
 	public int scaleForPixelHeight (int height) {
-		if (!bitmapped && !face.setPixelSizes(0, height)) throw new GdxRuntimeException("Couldn't set size for font");
+		if (!bitmapped && !FreeType.setPixelSizes(face, 0, height)) throw new GdxRuntimeException("Couldn't set size for font");
 		SizeMetrics fontMetrics = face.getSize().getMetrics();
 		int ascent = FreeType.toInt(fontMetrics.getAscender());
 		int descent = FreeType.toInt(fontMetrics.getDescender());
@@ -178,7 +176,7 @@ public class FreeTypeFontGenerator implements Disposable {
 		int descent = FreeType.toInt(fontMetrics.getDescender());
 		int unscaledHeight = ascent - descent;
 		int height = unscaledHeight * width / (advance * numChars);
-		if (!bitmapped && !face.setPixelSizes(0, height)) throw new GdxRuntimeException("Couldn't set size for font");
+		if (!bitmapped && !FreeType.setPixelSizes(face, 0, height)) throw new GdxRuntimeException("Couldn't set size for font");
 		return height;
 	}
 	
@@ -198,19 +196,19 @@ public class FreeTypeFontGenerator implements Disposable {
 	/** Returns null if glyph was not found. If there is nothing to render, for example with various space characters, then bitmap
 	 * is null. */
 	public GlyphAndBitmap generateGlyphAndBitmap (int c, int size, boolean flip) {
-		if (!bitmapped && !face.setPixelSizes(0, size)) throw new GdxRuntimeException("Couldn't set size for font");
+		if (!bitmapped && !FreeType.setPixelSizes(face, 0, size)) throw new GdxRuntimeException("Couldn't set size for font");
 
 		SizeMetrics fontMetrics = face.getSize().getMetrics();
 		int baseline = FreeType.toInt(fontMetrics.getAscender());
 
 		// Check if character exists in this font.
 		// 0 means 'undefined character code'
-		if (face.getCharIndex(c) == 0) {
+		if (FreeType.getCharIndex(face, c) == 0) {
 			return null;
 		}
 
 		// Try to load character
-		if (!face.loadChar(c, FreeType.FT_LOAD_DEFAULT)) {
+		if (!FreeType.loadChar(face, c, FreeType.FT_LOAD_DEFAULT)) {
 			throw new GdxRuntimeException("Unable to load character!");
 		}
 
@@ -220,7 +218,7 @@ public class FreeTypeFontGenerator implements Disposable {
 		Bitmap bitmap;
 		if (bitmapped) {
 			bitmap = slot.getBitmap();
-		} else if (!slot.renderGlyph(FreeType.FT_RENDER_MODE_LIGHT)) {
+		} else if (!FreeType.renderGlyph(slot, FreeType.FT_RENDER_MODE_LIGHT)) {
 			bitmap = null;
 		} else {
 			bitmap = slot.getBitmap();
@@ -292,7 +290,7 @@ public class FreeTypeFontGenerator implements Disposable {
 		parameter = parameter == null ? new FreeTypeFontParameter() : parameter;
 
 		FreeTypeBitmapFontData data = new FreeTypeBitmapFontData();
-		if (!bitmapped && !face.setPixelSizes(0, parameter.size))
+		if (!bitmapped && !FreeType.setPixelSizes(face, 0, parameter.size))
 			throw new GdxRuntimeException("Couldn't set size for font");
 
 		// set general font data
@@ -306,7 +304,7 @@ public class FreeTypeFontGenerator implements Disposable {
 		// if bitmapped
 		if (bitmapped && (data.lineHeight == 0)) {
 			for (int c = 32; c < (32 + face.getNumGlyphs()); c++) {
-				if (face.loadChar(c, FreeType.FT_LOAD_DEFAULT)) {
+				if (FreeType.loadChar(face, c, FreeType.FT_LOAD_DEFAULT)) {
 					int lh = FreeType.toInt(face.getGlyph().getMetrics().getHeight());
 					data.lineHeight = (lh > data.lineHeight) ? lh : data.lineHeight;
 				}
@@ -314,7 +312,7 @@ public class FreeTypeFontGenerator implements Disposable {
 		}
 
 		// determine space width and set glyph
-		if (face.loadChar(' ', FreeType.FT_LOAD_DEFAULT)) {
+		if (FreeType.loadChar(face, ' ', FreeType.FT_LOAD_DEFAULT)) {
 			data.spaceWidth = FreeType.toInt(face.getGlyph().getMetrics().getHoriAdvance());
 		} else {
 			data.spaceWidth = face.getMaxAdvanceWidth(); // FIXME possibly very wrong :)
@@ -326,13 +324,13 @@ public class FreeTypeFontGenerator implements Disposable {
 
 		// determine x-height
 		for (char xChar : BitmapFont.xChars) {
-			if (!face.loadChar(xChar, FreeType.FT_LOAD_DEFAULT)) continue;
+			if (!FreeType.loadChar(face, xChar, FreeType.FT_LOAD_DEFAULT)) continue;
 			data.xHeight = FreeType.toInt(face.getGlyph().getMetrics().getHeight());
 			break;
 		}
 		if (data.xHeight == 0) throw new GdxRuntimeException("No x-height character found in font");
 		for (char capChar : BitmapFont.capChars) {
-			if (!face.loadChar(capChar, FreeType.FT_LOAD_DEFAULT)) continue;
+			if (!FreeType.loadChar(face, capChar, FreeType.FT_LOAD_DEFAULT)) continue;
 			data.capHeight = FreeType.toInt(face.getGlyph().getMetrics().getHeight());
 			break;
 		}
@@ -365,98 +363,45 @@ public class FreeTypeFontGenerator implements Disposable {
 		// to minimize collisions we'll use this format : pathWithoutExtension_size[_flip]_glyph
 		String packPrefix = ownsAtlas ? "" : (filePath + '_' + parameter.size + (parameter.flip ? "_flip_" : '_'));
 
-		Stroker stroker = null;
-		if (parameter.borderWidth > 0) {
-			stroker = library.createStroker();
-			stroker.set((int)(parameter.borderWidth * 64f),
-					parameter.borderStraight ? FreeType.FT_STROKER_LINECAP_BUTT : FreeType.FT_STROKER_LINECAP_ROUND,
-					parameter.borderStraight ? FreeType.FT_STROKER_LINEJOIN_MITER_FIXED : FreeType.FT_STROKER_LINEJOIN_ROUND, 0);
-		}
-
 		for (int i = 0; i < parameter.characters.length(); i++) {
 			char c = parameter.characters.charAt(i);
-			if (!face.loadChar(c, FreeType.FT_LOAD_DEFAULT)) {
+			if (!FreeType.loadChar(face, c, FreeType.FT_LOAD_DEFAULT)) {
 				Gdx.app.log("FreeTypeFontGenerator", "Couldn't load char '" + c + "'");
 				continue;
 			}
-			GlyphSlot slot = face.getGlyph();
-			com.badlogic.gdx.graphics.g2d.freetype.FreeType.Glyph mainGlyph = slot.getGlyph();
-			try {
-				mainGlyph.toBitmap(FreeType.FT_RENDER_MODE_NORMAL);
-			} catch (GdxRuntimeException e) {
-				mainGlyph.dispose();
+			if (!FreeType.renderGlyph(face.getGlyph(), FreeType.FT_RENDER_MODE_NORMAL)) {
 				Gdx.app.log("FreeTypeFontGenerator", "Couldn't render char '" + c + "'");
 				continue;
 			}
-			Bitmap mainBitmap = mainGlyph.getBitmap();
-			Pixmap mainPixmap = mainBitmap.getPixmap(Format.RGBA8888, parameter.color);
-
-			if (parameter.borderWidth > 0 || parameter.shadowOffsetX != 0 || parameter.shadowOffsetY != 0) {
-				com.badlogic.gdx.graphics.g2d.freetype.FreeType.Glyph borderGlyph = mainGlyph;
-				Bitmap borderBitmap = mainBitmap;
-
-				if (parameter.borderWidth > 0) {
-					//execute stroker; this generates a glyph "extended" along the outline
-					borderGlyph = slot.getGlyph();
-					borderGlyph.strokeBorder(stroker, false);
-					borderGlyph.toBitmap(FreeType.FT_RENDER_MODE_NORMAL);
-					borderBitmap = borderGlyph.getBitmap();
-
-					//render border (pixmap is bigger than main)
-					Pixmap borderPixmap = borderBitmap.getPixmap(Format.RGBA8888, parameter.borderColor);
-					//draw main glyph on top of border
-					borderPixmap.drawPixmap(mainPixmap, mainGlyph.getLeft() - borderGlyph.getLeft(),
-						-(mainGlyph.getTop() - borderGlyph.getTop()));
-					mainPixmap.dispose();
-					mainGlyph.dispose();
-					mainPixmap = borderPixmap;
-					mainGlyph = borderGlyph;
-				}
-				if (parameter.shadowOffsetX != 0 || parameter.shadowOffsetY != 0) {
-					//render the shadow
-					Pixmap shadowPixmapSrc = borderBitmap.getPixmap(Format.RGBA8888, parameter.shadowColor);
-					//create a new bigger Pixmap with shadowOffset applied, and draw shadow glyph
-					Pixmap shadowPixmap = new Pixmap(shadowPixmapSrc.getWidth() + Math.abs(parameter.shadowOffsetX),
-						shadowPixmapSrc.getHeight() + Math.abs(parameter.shadowOffsetY), Format.RGBA8888);
-					Blending blending = Pixmap.getBlending();
-					Pixmap.setBlending(Blending.None);
-					shadowPixmap.drawPixmap(shadowPixmapSrc, Math.max(parameter.shadowOffsetX, 0), Math.max(parameter.shadowOffsetY, 0));
-					Pixmap.setBlending(blending);
-					//draw main glyph (with border) on top of shadow
-					shadowPixmap.drawPixmap(mainPixmap, Math.max(-parameter.shadowOffsetX, 0), Math.max(-parameter.shadowOffsetY, 0));
-					mainPixmap.dispose();
-					mainPixmap = shadowPixmap;
-				}
-			}
-
+			GlyphSlot slot = face.getGlyph();
 			GlyphMetrics metrics = slot.getMetrics();
+			Bitmap bitmap = slot.getBitmap();
+			Pixmap pixmap = bitmap.getPixmap(Format.RGBA8888);
 			Glyph glyph = new Glyph();
-			glyph.id = c;
-			glyph.width = mainPixmap.getWidth();
-			glyph.height = mainPixmap.getHeight();
-			glyph.xoffset = mainGlyph.getLeft();
-			glyph.yoffset = parameter.flip ? -mainGlyph.getTop() + (int)baseLine : -(glyph.height - mainGlyph.getTop())
+			glyph.id = (int)c;
+			glyph.width = pixmap.getWidth();
+			glyph.height = pixmap.getHeight();
+			glyph.xoffset = slot.getBitmapLeft();
+			glyph.yoffset = parameter.flip ? -slot.getBitmapTop() + (int)baseLine : -(glyph.height - slot.getBitmapTop())
 				- (int)baseLine;
-			glyph.xadvance = FreeType.toInt(metrics.getHoriAdvance()) + (int)parameter.borderWidth;
+			glyph.xadvance = FreeType.toInt(metrics.getHoriAdvance());
 
 			if (bitmapped) {
-				mainPixmap.setColor(Color.CLEAR);
-				mainPixmap.fill();
-				ByteBuffer buf = mainBitmap.getBuffer();
-				int whiteIntBits = Color.WHITE.toIntBits();
-				int clearIntBits = Color.CLEAR.toIntBits();
+				pixmap.setColor(Color.CLEAR);
+				pixmap.fill();
+				ByteBuffer buf = bitmap.getBuffer();
 				for (int h = 0; h < glyph.height; h++) {
-					int idx = h * mainBitmap.getPitch();
+					int idx = h * bitmap.getPitch();
 					for (int w = 0; w < (glyph.width + glyph.xoffset); w++) {
 						int bit = (buf.get(idx + (w / 8)) >>> (7 - (w % 8))) & 1;
-						mainPixmap.drawPixel(w, h, ((bit == 1) ? whiteIntBits : clearIntBits));
+						pixmap.drawPixel(w, h, ((bit == 1) ? Color.WHITE.toIntBits() : Color.CLEAR.toIntBits()));
 					}
 				}
 
 			}
 
 			String name = packPrefix + c;
-			Rectangle rect = packer.pack(name, mainPixmap);
+			Rectangle rect = packer.pack(name, pixmap);
 
 			// determine which page it was packed into
 			int pIndex = packer.getPageIndex(name);
@@ -468,12 +413,7 @@ public class FreeTypeFontGenerator implements Disposable {
 			glyph.srcY = (int)rect.y;
 
 			data.setGlyph(c, glyph);
-			mainPixmap.dispose();
-			mainGlyph.dispose();
-		}
-
-		if (stroker != null) {
-			stroker.dispose();
+			pixmap.dispose();
 		}
 
 		// generate kerning
@@ -486,8 +426,8 @@ public class FreeTypeFontGenerator implements Disposable {
 					char secondChar = parameter.characters.charAt(j);
 					Glyph second = data.getGlyph(secondChar);
 					if (second == null) continue;
-					int kerning = face.getKerning(face.getCharIndex(firstChar),
-						face.getCharIndex(secondChar), 0);
+					int kerning = FreeType.getKerning(face, FreeType.getCharIndex(face, firstChar),
+						FreeType.getCharIndex(face, secondChar), 0);
 					if (kerning == 0) continue;
 					first.setKerning(secondChar, FreeType.toInt(kerning));
 				}
@@ -519,8 +459,8 @@ public class FreeTypeFontGenerator implements Disposable {
 	/** Cleans up all resources of the generator. Call this if you no longer use the generator. */
 	@Override
 	public void dispose () {
-		face.dispose();
-		library.dispose();
+		FreeType.doneFace(face);
+		FreeType.doneFreeType(library);
 	}
 
 	/** {@link BitmapFontData} used for fonts generated via the {@link FreeTypeFontGenerator}. The texture storing the glyphs is held
@@ -554,20 +494,6 @@ public class FreeTypeFontGenerator implements Disposable {
 	public static class FreeTypeFontParameter {
 		/** The size in pixels */
 		public int size = 16;
-		/** Foreground color (required for non-black borders) */
-		public Color color = Color.WHITE;
-		/** Border width in pixels, 0 to disable */
-		public float borderWidth = 0;
-		/** Border color; only used if borderWidth > 0 */
-		public Color borderColor = Color.BLACK;
-		/** true for straight (mitered), false for rounded borders */
-		public boolean borderStraight = false;
-		/** Offset of text shadow on X axis in pixels, 0 to disable */
-		public int shadowOffsetX = 0;
-		/** Offset of text shadow on Y axis in pixels, 0 to disable */
-		public int shadowOffsetY = 0;
-		/** Shadow color; only used if shadowOffset > 0 */
-		public Color shadowColor = new Color(0, 0, 0, 0.75f);
 		/** The characters the font should contain */
 		public String characters = DEFAULT_CHARS;
 		/** Whether the font should include kerning */
diff --git a/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGeneratorLoader.java b/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGeneratorLoader.java
index f3d81e1..8974a09 100644
--- a/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGeneratorLoader.java
+++ b/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGeneratorLoader.java
@@ -41,12 +41,8 @@ public class FreeTypeFontGeneratorLoader extends
 	@Override
 	public FreeTypeFontGenerator load (AssetManager assetManager, String fileName, FileHandle file,
 		FreeTypeFontGeneratorParameters parameter) {
-		FreeTypeFontGenerator generator = null;
-		if (file.extension().equals("gen")) {
-			generator = new FreeTypeFontGenerator(file.sibling(file.nameWithoutExtension()));
-		} else {
-			generator = new FreeTypeFontGenerator(file);
-		}
+		FreeTypeFontGenerator generator = new FreeTypeFontGenerator(file);
+
 		return generator;
 	}
 
diff --git a/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreetypeFontLoader.java b/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreetypeFontLoader.java
index f56f0cb..4bc1488 100644
--- a/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreetypeFontLoader.java
+++ b/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreetypeFontLoader.java
@@ -38,7 +38,7 @@ public class FreetypeFontLoader extends AsynchronousAssetLoader<BitmapFont, Free
 	@Override
 	public BitmapFont loadSync (AssetManager manager, String fileName, FileHandle file, FreeTypeFontLoaderParameter parameter) {
 		if(parameter == null) throw new RuntimeException("FreetypeFontParameter must be set in AssetManager#load to point at a TTF file!");
-		FreeTypeFontGenerator generator = manager.get(parameter.fontFileName + ".gen", FreeTypeFontGenerator.class);	
+		FreeTypeFontGenerator generator = manager.get(parameter.fontFileName, FreeTypeFontGenerator.class);	
 		FreeTypeBitmapFontData data = generator.generateData(parameter.fontParameters);
 		BitmapFont font = new BitmapFont(data, data.getTextureRegions(), false);
 		font.setOwnsTexture(true);
@@ -48,7 +48,7 @@ public class FreetypeFontLoader extends AsynchronousAssetLoader<BitmapFont, Free
 	@Override
 	public Array<AssetDescriptor> getDependencies (String fileName, FileHandle file, FreeTypeFontLoaderParameter parameter) {
 		Array<AssetDescriptor> deps = new Array<AssetDescriptor>();
-		deps.add(new AssetDescriptor<FreeTypeFontGenerator>(parameter.fontFileName + ".gen", FreeTypeFontGenerator.class));
+		deps.add(new AssetDescriptor<FreeTypeFontGenerator>(parameter.fontFileName, FreeTypeFontGenerator.class));
 		return deps;
 	}
 }
diff --git a/extensions/gdx-jnigen/pom.xml b/extensions/gdx-jnigen/pom.xml
index 8e88063..9b8030c 100644
--- a/extensions/gdx-jnigen/pom.xml
+++ b/extensions/gdx-jnigen/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.5.4-SNAPSHOT</version>
+    <version>1.4.2-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/resources/scripts/build-ios.xml.template b/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/resources/scripts/build-ios.xml.template
index ec01bd7..ad1cf44 100755
--- a/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/resources/scripts/build-ios.xml.template
+++ b/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/resources/scripts/build-ios.xml.template
@@ -67,7 +67,7 @@
 				<exclude name="*.o"/>
 			</fileset>
 		</delete>
-	</target>		
+	</target>
 
 	<!-- compiles all C and C++ files to object files in the build directory, for 386 builds-->
 	<target name="compile-386" depends="clean,create-build-dir">
@@ -121,61 +121,8 @@
 	</target>
 	
 	<!-- compiles all C and C++ files to object files in the build directory, for 386 builds-->
-	<target name="compile-x86_64" depends="create-build-dir">
-		<mkdir dir="${buildDir}"/>
-		<antcall target="clean-objfiles"/>
-		<apply failonerror="true" executable="${g++}" dest="${buildDir}" verbose="true">
-			<arg line="-isysroot ${iphonesimulator-sdk} -arch x86_64 ${g++-opts}"/>
-			<arg value="-Ijni-headers"/>
-			<arg value="-Ijni-headers/${jniPlatform}"/>
-			<arg value="-I."/>
-			%headerDirs%
-			<srcfile/>
-			<arg value="-o"/>
-			<targetfile/>
-			<fileset refid="g++-files"/>
-			<compositemapper>
-				<mapper type="glob" from="*.cpp" to="*.o"/>
-				<mapper type="glob" from="*.mm" to="*.o"/>
-			</compositemapper>
-		</apply>
-		<apply failonerror="true" executable="${gcc}" dest="${buildDir}" verbose="true">
-			<arg line="-isysroot ${iphonesimulator-sdk} -arch x86_64 ${gcc-opts}"/>
-			<arg value="-Ijni-headers"/>
-			<arg value="-Ijni-headers/${jniPlatform}"/>
-			<arg value="-I."/>
-			%headerDirs%
-			<srcfile/>
-			<arg value="-o"/>
-			<targetfile/>
-			<fileset refid="gcc-files"/>
-			<compositemapper>
-				<mapper type="glob" from="*.c" to="*.o"/>
-			</compositemapper>
-		</apply>
-	</target>	
-
-	<!-- links the shared library based on the previously compiled object files -->
-	<target name="link-x86_64" depends="compile-x86_64">
-		<fileset dir="${buildDir}" id="objFileSet">
-			<patternset>
-				<include name="**/*.o" />
-			</patternset>
-		</fileset>
-		<pathconvert pathsep=" " property="objFiles" refid="objFileSet" />
-		<mkdir dir="${libsDir}" />
-		<exec executable="${linker}" failonerror="true" dir="${buildDir}">
-			<arg line="${linker-opts}" />
-			<arg path="${libsDir}/${libName}.x86_64" />
-			<arg line="${objFiles}"/>
-			<arg line="${libraries}" />
-		</exec>
-	</target>
-	
-	<!-- compiles all C and C++ files to object files in the build directory, for 386 builds-->
-	<target name="compile-arm" depends="create-build-dir">
+	<target name="compile-arm" depends="create-build-dir,clean-objfiles">
 		<mkdir dir="${buildDir}"/>
-		<antcall target="clean-objfiles"/>
 		<apply failonerror="true" executable="${g++}" dest="${buildDir}" verbose="true">
 			<arg line="-isysroot ${iphoneos-sdk} -arch armv7 ${g++-opts}"/>
 			<arg value="-Ijni-headers"/>
@@ -223,66 +170,14 @@
 			<arg line="${libraries}" />
 		</exec>
 	</target>
-	
-		<!-- compiles all C and C++ files to object files in the build directory, for 386 builds-->
-	<target name="compile-arm64" depends="create-build-dir,clean-objfiles">
-		<mkdir dir="${buildDir}"/>
-		<antcall target="clean-objfiles"/>
-		<apply failonerror="true" executable="${g++}" dest="${buildDir}" verbose="true">
-			<arg line="-isysroot ${iphoneos-sdk} -arch arm64 ${g++-opts}"/>
-			<arg value="-Ijni-headers"/>
-			<arg value="-Ijni-headers/${jniPlatform}"/>
-			<arg value="-I."/>
-			%headerDirs%
-			<srcfile/>
-			<arg value="-o"/>
-			<targetfile/>
-			<fileset refid="g++-files"/>
-			<compositemapper>
-				<mapper type="glob" from="*.cpp" to="*.o"/>
-				<mapper type="glob" from="*.mm" to="*.o"/>
-			</compositemapper>
-		</apply>
-		<apply failonerror="true" executable="${gcc}" dest="${buildDir}" verbose="true">
-			<arg line="-isysroot ${iphoneos-sdk} -arch arm64 ${gcc-opts}"/>
-			<arg value="-Ijni-headers"/>
-			<arg value="-Ijni-headers/${jniPlatform}"/>
-			<arg value="-I."/>
-			%headerDirs%
-			<srcfile/>
-			<arg value="-o"/>
-			<targetfile/>
-			<fileset refid="gcc-files"/>
-			<compositemapper>
-				<mapper type="glob" from="*.c" to="*.o"/>
-			</compositemapper>
-		</apply>
-	</target>	
-
-	<!-- links the shared library based on the previously compiled object files -->
-	<target name="link-arm64" depends="compile-arm64">
-		<fileset dir="${buildDir}" id="objFileSet">
-			<patternset>
-				<include name="**/*.o" />
-			</patternset>
-		</fileset>
-		<pathconvert pathsep=" " property="objFiles" refid="objFileSet" />
-		<mkdir dir="${libsDir}" />
-		<exec executable="${linker}" failonerror="true" dir="${buildDir}">
-			<arg line="${linker-opts}" />
-			<arg path="${libsDir}/${libName}.arm64" />
-			<arg line="${objFiles}"/>
-			<arg line="${libraries}" />
-		</exec>
-	</target>
 
 	<target name="link-fat">
 		<exec executable="lipo" failonerror="true" dir="${libsDir}">
-			<arg line="-create -output ${libName} ${libName}.386 ${libName}.x86_64 ${libName}.armv7 ${libName}.arm64"/>
+			<arg line="-create -output ${libName} ${libName}.386 ${libName}.armv7"/>
 		</exec>
 	</target>
 
-	<target name="postcompile" depends="link-386,link-x86_64,link-arm,link-arm64,link-fat">
+	<target name="postcompile" depends="link-386,link-arm,link-fat">
 		%postcompile%
 	</target>
 </project>
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/DependencyBank.java b/extensions/gdx-setup/src/com/badlogic/gdx/setup/DependencyBank.java
index c1fee15..8544842 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/DependencyBank.java
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/DependencyBank.java
@@ -7,10 +7,10 @@ import java.util.LinkedHashMap;
 public class DependencyBank {
 
 	//Versions
-	static String libgdxVersion = "1.5.3";
+	static String libgdxVersion = "1.4.1";
 	//Temporary snapshot version, we need a more dynamic solution for pointing to the latest nightly
-	static String libgdxNightlyVersion = "1.5.4-SNAPSHOT";
-	static String roboVMVersion = "1.0.0-beta-03";
+	static String libgdxNightlyVersion = "1.4.2-SNAPSHOT";
+	static String roboVMVersion = "1.0.0-alpha-04";
 	static String buildToolsVersion = "20.0.0";
 	static String androidAPILevel = "20";
 	static String gwtVersion = "2.6.0";
@@ -22,14 +22,14 @@ public class DependencyBank {
 	static String libGDXReleaseUrl = "https://oss.sonatype.org/content/repositories/releases/";
 
 	//Project plugins
-	static String gwtPluginImport = "de.richsource.gradle.plugins:gwt-gradle-plugin:0.6";
-	static String androidPluginImport = "com.android.tools.build:gradle:1.0.0";
-	static String roboVMPluginImport = "org.robovm:robovm-gradle-plugin:" + roboVMVersion;
+	static String gwtPluginImport = "de.richsource.gradle.plugins:gwt-gradle-plugin:0.5";
+	static String androidPluginImport = "com.android.tools.build:gradle:0.13+";
+	static String roboVMPluginImport = "org.robovm:robovm-gradle-plugin:1.0.0-alpha-04";
 	
 	//Extension versions
-	static String box2DLightsVersion = "1.3";
+	static String box2DLightsVersion = "1.2";
 	static String ashleyVersion = "1.3.1";
-	static String aiVersion = "1.5.0";
+	static String aiVersion = "1.4.0";
 
 	HashMap<ProjectDependency, Dependency> gdxDependencies = new HashMap<ProjectDependency, Dependency>();
 	LinkedHashMap<ProjectDependency, String[]> gwtInheritances = new LinkedHashMap<ProjectDependency, String[]>();
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/Executor.java b/extensions/gdx-setup/src/com/badlogic/gdx/setup/Executor.java
index 062dbd6..2607bbd 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/Executor.java
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/Executor.java
@@ -30,25 +30,18 @@ public class Executor {
 	 * @return whether the Ant succeeded */
 	public static boolean execute (File workingDir, String windowsFile, String unixFile, String parameters, CharCallback callback) {
 		String exec = workingDir.getAbsolutePath() + "/" + (System.getProperty("os.name").contains("Windows") ? windowsFile : unixFile);
-		String log = "Executing '" + exec + " " + parameters + "'";
+		String command = exec + " " + parameters;
+		String log = "Executing '" + command + "'";
 		for(int i = 0; i < log.length(); i++) {
 			callback.character(log.charAt(i));
 		}
 		callback.character('\n');
-		
-		String[] params = parameters.split(" ");
-		String[] commands = new String[params.length + 1];
-		commands[0] = exec;
-		for (int i = 0; i < params.length; i++) {
-			commands[i + 1] = params[i];
-		}
-		
-		return startProcess(commands, workingDir, callback);
+		return startProcess(command, workingDir, callback);
 	}
 
-	private static boolean startProcess (String[] commands, File directory, final CharCallback callback) {
+	private static boolean startProcess (String command, File directory, final CharCallback callback) {
 		try {
-			final Process process = new ProcessBuilder(commands).redirectErrorStream(true).directory(directory).start();
+			final Process process = new ProcessBuilder(command.split(" ")).redirectErrorStream(true).directory(directory).start();
 
 			Thread t = new Thread(new Runnable() {
 				@Override
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/GdxSetupUI.java b/extensions/gdx-setup/src/com/badlogic/gdx/setup/GdxSetupUI.java
index 2e92187..e738e72 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/GdxSetupUI.java
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/GdxSetupUI.java
@@ -96,8 +96,7 @@ public class GdxSetupUI extends JFrame {
 		add(ui, BorderLayout.CENTER);
 		setSize(620, 720);
 		setLocationRelativeTo(null);
-		setUndecorated(true);		
-		pack();
+		setUndecorated(true);
 		setDefaultCloseOperation(EXIT_ON_CLOSE);
 
 		addMouseListener(new MouseAdapter() {
@@ -284,7 +283,7 @@ public class GdxSetupUI extends JFrame {
 		SetupButton generateButton = new SetupButton("Generate");
 		SetupButton advancedButton = new SetupButton("Advanced");
 		JPanel buttonPanel = new JPanel();
-		JTextArea textArea = new JTextArea(8, 40);
+		JTextArea textArea = new JTextArea();
 		JScrollPane scrollPane = new JScrollPane(textArea);
 		JPanel title = new JPanel();
 		JPanel topBar = new JPanel();
@@ -603,7 +602,7 @@ public class GdxSetupUI extends JFrame {
 			} else {
 				JFileChooser chooser = new JFileChooser();
 				chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
-				chooser.setDialogTitle("Choose destination");
+				chooser.setDialogTitle("Chose destination");
 				int result = chooser.showOpenDialog(null);
 				if (result == JFileChooser.APPROVE_OPTION) {
 					File dir = chooser.getSelectedFile();
@@ -682,11 +681,6 @@ public class GdxSetupUI extends JFrame {
 	}
 
 	public static void main (String[] args) throws Exception {
-		SwingUtilities.invokeLater(new Runnable() {
-			@Override
-			public void run() {
-				new GdxSetupUI();				
-			}			
-		});
+		new GdxSetupUI();
 	}
 }
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gitignore b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gitignore
index 47454ee..2668f00 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gitignore
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gitignore
@@ -57,7 +57,6 @@ nb-configuration.xml
 ## Gradle
 
 .gradle
-gradle-app.setting
 build/
 
 ## OS Specific
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gradle/wrapper/gradle-wrapper.properties b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gradle/wrapper/gradle-wrapper.properties
index 8e600c9..d01e74d 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gradle/wrapper/gradle-wrapper.properties
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-2.2-all.zip
+distributionUrl=http\://services.gradle.org/distributions/gradle-2.1-all.zip
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/html/GdxDefinitionSuperdev b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/html/GdxDefinitionSuperdev
index 1442d52..08822d3 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/html/GdxDefinitionSuperdev
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/html/GdxDefinitionSuperdev
@@ -2,11 +2,12 @@
 <!DOCTYPE module PUBLIC "-//Google Inc.//DTD Google Web Toolkit trunk//EN" "http://google-web-toolkit.googlecode.com/svn/trunk/distro-source/core/src/gwt-module.dtd">
 <module rename-to="html">
 %GWT_INHERITS%
-    <inherits name='%PACKAGE%.GdxDefinition' />
-    
-    <collapse-all-properties />
-    
-	<add-linker name="xsiframe"/>	
+    <inherits name='%MAIN_CLASS%' />
+	<entry-point class='%PACKAGE%.client.HtmlLauncher' />
+	
+	<add-linker name="xsiframe"/>
+	<set-configuration-property name='xsiframe.failIfScriptTag' value='FALSE'/>
 	<set-configuration-property name="devModeRedirectEnabled" value="true"/>
-	<set-configuration-property name='xsiframe.failIfScriptTag' value='FALSE'/>	
+	
+	<set-configuration-property name="gdx.assetpath" value="../%ASSET_PATH%" />
 </module>
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/html/war/index b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/html/war/index
index 9fd9580..f159de4 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/html/war/index
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/html/war/index
@@ -4,23 +4,23 @@
               <title>%APP_NAME%</title>
               <meta http-equiv="content-type" content="text/html; charset=UTF-8">
               <link href="styles.css" rel="stylesheet" type="text/css">
-              <script src="soundmanager2-setup.js"></script>
-  			  <script src="soundmanager2-jsmin.js"></script>
+              <script src="soundmanager2-setup.js"></script>  
+  			  <script src="soundmanager2-jsmin.js"></script> 
        </head>
-
-       <body>
-              <a class="superdev" href="javascript:%7B%20window.__gwt_bookmarklet_params%20%3D%20%7B'server_url'%3A'http%3A%2F%2Flocalhost%3A9876%2F'%7D%3B%20var%20s%20%3D%20document.createElement('script')%3B%20s.src%20%3D%20'http%3A%2F%2Flocalhost%3A9876%2Fdev_mode_on.js'%3B%20void(document.getElementsByTagName('head')%5B0%5D.appendChild(s))%3B%7D">&#8635;</a>
+       
+       <body>              
+              <a class="superdev" href="javascript:%7B%20window.__gwt_bookmarklet_params%20%3D%20%7B'server_url'%3A'http%3A%2F%2Flocalhost%3A9876%2F'%7D%3B%20var%20s%20%3D%20document.createElement('script')%3B%20s.src%20%3D%20'http%3A%2F%2Flocalhost%3A9876%2Fdev_mode_on.js'%3B%20void(document.getElementsByTagName('head')%5B0%5D.appendChild(s))%3B%7D">SuperDev Refresh</a>
               <div align="center" id="embed-html"></div>
               <script type="text/javascript" src="html/html.nocache.js"></script>
        </body>
-
+       
        <script>
               function handleMouseDown(evt) {
                 evt.preventDefault();
                 evt.stopPropagation();
                 evt.target.style.cursor = 'default';
               }
-
+              
               function handleMouseUp(evt) {
                 evt.preventDefault();
                 evt.stopPropagation();
@@ -29,4 +29,4 @@
               document.getElementById('embed-html').addEventListener('mousedown', handleMouseDown, false);
               document.getElementById('embed-html').addEventListener('mouseup', handleMouseUp, false);
        </script>
-</html>
+</html>
\ No newline at end of file
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/html/war/styles.css b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/html/war/styles.css
index 0abbdaa..f823a7a 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/html/war/styles.css
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/html/war/styles.css
@@ -4,40 +4,88 @@ canvas {
 }
 
 body {
-    background-color: #222222;
+    background-color: #ffffff;
 }
 
 .superdev {
-    color: rgb(37,37,37);
-    text-shadow: 0px 1px 1px rgba(250,250,250,0.1);
-    font-size: 50pt;
-    display: block;
-    position: relative;
-    text-decoration: none;
-    background-color: rgb(83,87,93);
-    box-shadow: 0px 3px 0px 0px rgb(34,34,34),
-                0px 7px 10px 0px rgb(17,17,17),
-                inset 0px 1px 1px 0px rgba(250, 250, 250, .2),
-                inset 0px -12px 35px 0px rgba(0, 0, 0, .5);
-    width: 70px;
-    height: 70px;
-    border: 0;
-    border-radius: 35px;
-    text-align: center;
-    line-height: 68px;
+	background-color:#3bb3e0;
+	font-family: 'Open Sans', sans-serif;
+	font-size:12px;
+	text-decoration:none;
+	color:#fff;
+	position:relative;
+	padding:10px 20px;
+	padding-right:50px;
+	background-image: linear-gradient(bottom, rgb(44,160,202) 0%, rgb(62,184,229) 100%);
+	background-image: -o-linear-gradient(bottom, rgb(44,160,202) 0%, rgb(62,184,229) 100%);
+	background-image: -moz-linear-gradient(bottom, rgb(44,160,202) 0%, rgb(62,184,229) 100%);
+	background-image: -webkit-linear-gradient(bottom, rgb(44,160,202) 0%, rgb(62,184,229) 100%);
+	background-image: -ms-linear-gradient(bottom, rgb(44,160,202) 0%, rgb(62,184,229) 100%);
+	background-image: -webkit-gradient(
+	linear,
+	left bottom,
+	left top,
+	color-stop(0, rgb(44,160,202)),
+	color-stop(1, rgb(62,184,229))
+	);
+	-webkit-border-radius: 5px;
+	-moz-border-radius: 5px;
+	-o-border-radius: 5px;
+	border-radius: 5px;
+	-webkit-box-shadow: inset 0px 1px 0px #2ab7ec, 0px 5px 0px 0px #156785, 0px 10px 5px #999;
+	-moz-box-shadow: inset 0px 1px 0px #2ab7ec, 0px 5px 0px 0px #156785, 0px 10px 5px #999;
+	-o-box-shadow: inset 0px 1px 0px #2ab7ec, 0px 5px 0px 0px #156785, 0px 10px 5px #999;
+	box-shadow: inset 0px 1px 0px #2ab7ec, 0px 5px 0px 0px #156785, 0px 10px 5px #999;
 }
 
 .superdev:active {
-    box-shadow: 0px 0px 0px 0px rgb(34,34,34),
-                0px 3px 7px 0px rgb(17,17,17),
-                inset 0px 1px 1px 0px rgba(250, 250, 250, .2),
-                inset 0px -10px 35px 5px rgba(0, 0, 0, .5);
-    background-color: rgb(83,87,93);
-    top: 3px;
-    color: #fff;
-    text-shadow: 0px 0px 3px rgb(250,250,250);
+	top:3px;
+	background-image: linear-gradient(bottom, rgb(62,184,229) 0%, rgb(44,160,202) 100%);
+	background-image: -o-linear-gradient(bottom, rgb(62,184,229) 0%, rgb(44,160,202) 100%);
+	background-image: -moz-linear-gradient(bottom, rgb(62,184,229) 0%, rgb(44,160,202) 100%);
+	background-image: -webkit-linear-gradient(bottom, rgb(62,184,229) 0%, rgb(44,160,202) 100%);
+	background-image: -ms-linear-gradient(bottom, rgb(62,184,229) 0%, rgb(44,160,202) 100%);
+	background-image: -webkit-gradient(
+	linear,
+	left bottom,
+	left top,
+	color-stop(0, rgb(62,184,229)),
+	color-stop(1, rgb(44,160,202))
+	);
+	-webkit-box-shadow: inset 0px 1px 0px #2ab7ec, 0px 2px 0px 0px #156785, 0px 5px 3px #999;
+	-moz-box-shadow: inset 0px 1px 0px #2ab7ec, 0px 2px 0px 0px #156785, 0px 5px 3px #999;
+	-o-box-shadow: inset 0px 1px 0px #2ab7ec, 0px 2px 0px 0px #156785, 0px 5px 3px #999;
+	box-shadow: inset 0px 1px 0px #2ab7ec, 0px 2px 0px 0px #156785, 0px 5px 3px #999;
 }
 
-.superdev:hover {
-    background-color: rgb(100,100,100);
+.superdev::before {
+	background-color:#2591b4;
+	background-image:url(refresh.png);
+    background-size: 12px;
+	background-repeat:no-repeat;
+	background-position:center center;
+	content:"";
+	width:20px;
+	height:20px;
+	position:absolute;
+	right:15px;
+	top:50%;
+	margin-top:-9px;
+	-webkit-border-radius: 50%;
+	-moz-border-radius: 50%;
+	-o-border-radius: 50%;
+	border-radius: 50%;
+	-webkit-box-shadow: inset 0px 1px 0px #052756, 0px 1px 0px #60c9f0;
+	-moz-box-shadow: inset 0px 1px 0px #052756, 0px 1px 0px #60c9f0;
+	-o-box-shadow: inset 0px 1px 0px #052756, 0px 1px 0px #60c9f0;
+	box-shadow: inset 0px 1px 0px #052756, 0px 1px 0px #60c9f0;
 }
+
+.superdev:active::before {
+	top:50%;
+	margin-top:-12px;
+	-webkit-box-shadow: inset 0px 1px 0px #60c9f0, 0px 3px 0px #0e3871, 0px 6px 3px #1a80a6;
+	-moz-box-shadow: inset 0px 1px 0px #60c9f0, 0px 3px 0px #0e3871, 0px 6px 3px #1a80a6;
+	-o-box-shadow: inset 0px 1px 0px #60c9f0, 0px 3px 0px #0e3871, 0px 6px 3px #1a80a6;
+	box-shadow: inset 0px 1px 0px #60c9f0, 0px 3px 0px #0e3871, 0px 6px 3px #1a80a6;
+}
\ No newline at end of file
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/ios/robovm.xml b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/ios/robovm.xml
index 741409e..a38af62 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/ios/robovm.xml
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/ios/robovm.xml
@@ -20,8 +20,7 @@
   <forceLinkClasses>
     <pattern>com.badlogic.gdx.scenes.scene2d.ui.*</pattern>
     <pattern>com.badlogic.gdx.physics.bullet.**</pattern>
-    <pattern>com.badlogic.gdx.graphics.g3d.particles.**</pattern>
-    <pattern>com.android.okhttp.HttpHandler</pattern>
+	<pattern>com.android.okhttp.HttpHandler</pattern>
     <pattern>com.android.okhttp.HttpsHandler</pattern>
     <pattern>com.android.org.conscrypt.**</pattern>
     <pattern>com.android.org.bouncycastle.jce.provider.BouncyCastleProvider</pattern>
diff --git a/extensions/gdx-tools/.classpath b/extensions/gdx-tools/.classpath
index 65048f9..c71cd59 100644
--- a/extensions/gdx-tools/.classpath
+++ b/extensions/gdx-tools/.classpath
@@ -1,14 +1,13 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry excluding="**/.svn/*" kind="src" path="src"/>
-	<classpathentry excluding="**/.svn/*" kind="src" path="assets"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
-	<classpathentry combineaccessrules="false" kind="src" path="/gdx"/>
-	<classpathentry combineaccessrules="false" kind="src" path="/gdx-backend-lwjgl"/>
-	<classpathentry kind="lib" path="libs/JavaFreeType.jar"/>
-	<classpathentry kind="lib" path="libs/jna.jar"/>
-	<classpathentry kind="lib" path="libs/TWLThemeEditor.jar"/>
-	<classpathentry kind="lib" path="libs/xpp3-1.1.4c.jar"/>
-	<classpathentry combineaccessrules="false" kind="src" path="/gdx-backend-headless"/>
-	<classpathentry kind="output" path="bin"/>
-</classpath>
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry excluding="**/.svn/*" kind="src" path="src"/>
+	<classpathentry excluding="**/.svn/*" kind="src" path="assets"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/gdx"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/gdx-backend-lwjgl"/>
+	<classpathentry kind="lib" path="libs/JavaFreeType.jar"/>
+	<classpathentry kind="lib" path="libs/jna.jar"/>
+	<classpathentry kind="lib" path="libs/TWLThemeEditor.jar"/>
+	<classpathentry kind="lib" path="libs/xpp3-1.1.4c.jar"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/extensions/gdx-tools/assembly.xml b/extensions/gdx-tools/assembly.xml
index d23a73d..44b4c04 100644
--- a/extensions/gdx-tools/assembly.xml
+++ b/extensions/gdx-tools/assembly.xml
@@ -15,7 +15,6 @@
       <scope>runtime</scope>
       <excludes>
         <exclude>com.badlogicgames.gdx:gdx-backend-lwjgl</exclude>
-        <exclude>com.badlogicgames.gdx:gdx-backend-headless</exclude>
       </excludes>
     </dependencySet>
     <dependencySet>
diff --git a/extensions/gdx-tools/pom.xml b/extensions/gdx-tools/pom.xml
index 24b2fe0..bfbe803 100644
--- a/extensions/gdx-tools/pom.xml
+++ b/extensions/gdx-tools/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.5.4-SNAPSHOT</version>
+    <version>1.4.2-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
@@ -22,12 +22,6 @@
       <artifactId>gdx-backend-lwjgl</artifactId>
       <version>${project.version}</version>
     </dependency>
-    
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>gdx-backend-headless</artifactId>
-      <version>${project.version}</version>
-    </dependency>
 
     <dependency>
       <groupId>de.matthiasmann</groupId>
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/hiero/Hiero.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/hiero/Hiero.java
index a3d4a51..afd3a8b 100644
--- a/extensions/gdx-tools/src/com/badlogic/gdx/tools/hiero/Hiero.java
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/hiero/Hiero.java
@@ -118,7 +118,6 @@ public class Hiero extends JFrame {
 	List<EffectPanel> effectPanels = new ArrayList<EffectPanel>();
 	Preferences prefs;
 	ColorEffect colorEffect;
-	boolean batchMode = false;
 
 	JScrollPane appliedEffectsScroll;
 	JPanel appliedEffectsPanel;
@@ -164,7 +163,7 @@ public class Hiero extends JFrame {
 	File saveBmFontFile;
 	String lastSaveFilename = "", lastSaveBMFilename = "", lastOpenFilename = "";
 
-	public Hiero(String [] args) {
+	public Hiero () {
 		super("Hiero v3.0 - Bitmap Font Tool");
 		Splash splash = new Splash(this, "/splash.jpg", 2000);
 		initialize();
@@ -192,8 +191,6 @@ public class Hiero extends JFrame {
 		effectsListModel.addElement(new DistanceFieldEffect());
 		new EffectPanel(colorEffect);
 
-		parseArgs(args);
-		
 		addWindowListener(new WindowAdapter() {
 			public void windowClosed (WindowEvent event) {
 				System.exit(0);
@@ -201,7 +198,6 @@ public class Hiero extends JFrame {
 			}
 		});
 
-		updateFontSelector();
 		setVisible(true);
 	}
 
@@ -217,70 +213,37 @@ public class Hiero extends JFrame {
 		sampleNeheButton.doClick();
 	}
 
-	private void parseArgs (String[] args) {
-		float scale = 1f;
-
-		for (int i = 0; i < args.length; i++) {
-			final String param = args[i];
-			final boolean more = i < args.length - 1;
-
-			if (param.equals("-b") || param.equals("--batch")) {
-				batchMode = true;
-			} else if (more && (param.equals("-s") || param.equals("--scale"))) {
-				scale = Float.parseFloat(args[++i]);
-			} else if (more && (param.equals("-i") || param.equals("--input"))) {
-				File f = new File(args[++i]);
-				open(f);
-				fontFileRadio.setText("");
-				updateFont();
-			} else if (more && (param.equals("-o") || param.equals("--output"))) {
-				File f = new File(args[++i]);
-				saveBm(f);
-			} else {
-				System.err.println("Unknown parameter: " + param);
-				System.exit(3);
-			}
-		}
-
-		// update scale:
-		fontSizeSpinner.setValue((int)(0.5f + Math.max(4, scale * ((Integer)fontSizeSpinner.getValue()))));
-	}
-
-	void updateFontSelector () {
-		final boolean use2 = fontFileRadio.isSelected();
-		fontList.setEnabled(!use2);
-		fontFileText.setEnabled(use2);
-		browseButton.setEnabled(use2);
+	void updateFont () {
+		updateFont(false);
 	}
 
-	void updateFont () {
-		final boolean useFont2 = fontFileRadio.isSelected();
-		UnicodeFont unicodeFont = null;
+	private void updateFont (boolean ignoreFileText) {
+		UnicodeFont unicodeFont;
 
 		int fontSize = ((Integer)fontSizeSpinner.getValue()).intValue();
 
-		
-		 
-		if (useFont2) {
-			File file = new File(fontFileText.getText());
-			if (file.exists() && file.isFile()) {
-				// Load from file.
-				try {
-					unicodeFont = new UnicodeFont(fontFileText.getText(), fontSize, boldCheckBox.isSelected(),
-						italicCheckBox.isSelected());
-				} catch (Throwable ex) {
-					ex.printStackTrace();
-					fontFileRadio.setSelected(false);
-				}
+		File file = new File(fontFileText.getText());
+		if (!ignoreFileText && file.exists() && file.isFile()) {
+			// Load from file.
+			fontFileRadio.setSelected(true);
+			fontList.setEnabled(false);
+			systemFontRadio.setEnabled(false);
+			try {
+				unicodeFont = new UnicodeFont(fontFileText.getText(), fontSize, boldCheckBox.isSelected(),
+					italicCheckBox.isSelected());
+			} catch (Throwable ex) {
+				ex.printStackTrace();
+				updateFont(true);
+				return;
 			}
-		}
-		
-		if(unicodeFont == null) {
+		} else {
 			// Load from java.awt.Font (kerning not available!).
+			fontList.setEnabled(true);
+			systemFontRadio.setEnabled(true);
+			systemFontRadio.setSelected(true);
 			unicodeFont = new UnicodeFont(Font.decode((String)fontList.getSelectedValue()), fontSize, boldCheckBox.isSelected(),
 				italicCheckBox.isSelected());
 		}
-
 		unicodeFont.setPaddingTop(((Integer)padTopSpinner.getValue()).intValue());
 		unicodeFont.setPaddingRight(((Integer)padRightSpinner.getValue()).intValue());
 		unicodeFont.setPaddingBottom(((Integer)padBottomSpinner.getValue()).intValue());
@@ -301,19 +264,12 @@ public class Hiero extends JFrame {
 		sampleTextPane.setFont(unicodeFont.getFont().deriveFont((float)size));
 
 		this.newUnicodeFont = unicodeFont;
-		updateFontSelector();
-	}
-
-	void saveBm (File file) {
-		saveBmFontFile = file;
 	}
 
 	void save (File file) throws IOException {
 		HieroSettings settings = new HieroSettings();
 		settings.setFontName((String)fontList.getSelectedValue());
 		settings.setFontSize(((Integer)fontSizeSpinner.getValue()).intValue());
-		settings.setFont2File(fontFileText.getText());
-	settings.setFont2Active(fontFileRadio.isSelected());
 		settings.setBold(boldCheckBox.isSelected());
 		settings.setItalic(italicCheckBox.isSelected());
 		settings.setPaddingTop(((Integer)padTopSpinner.getValue()).intValue());
@@ -354,16 +310,7 @@ public class Hiero extends JFrame {
 		if (gt.length() > 0) {
 			sampleTextPane.setText(settings.getGlyphText());
 		}
-		
-		final String font2 = settings.getFont2File();
-		if (font2.length() > 0)
-			fontFileText.setText(font2);
-		else
-			fontFileText.setText(prefs.get("font.file", ""));
-
-		fontFileRadio.setSelected(settings.isFont2Active());
-		systemFontRadio.setSelected(!settings.isFont2Active());
- 
+
 		for (Iterator iter = settings.getEffects().iterator(); iter.hasNext();) {
 			ConfigurableEffect settingsEffect = (ConfigurableEffect)iter.next();
 			for (int i = 0, n = effectsListModel.getSize(); i < n; i++) {
@@ -467,15 +414,11 @@ public class Hiero extends JFrame {
 			}
 		});
 
-		final ActionListener al = new ActionListener() {
+		fontFileRadio.addActionListener(new ActionListener() {
 			public void actionPerformed (ActionEvent evt) {
-				updateFontSelector();
-				updateFont();
+				if (fontList.isEnabled()) systemFontRadio.setSelected(true);
 			}
-		};
-		
-		systemFontRadio.addActionListener(al);
-		fontFileRadio.addActionListener(al);
+		});
 
 		browseButton.addActionListener(new ActionListener() {
 			public void actionPerformed (ActionEvent evt) {
@@ -603,7 +546,7 @@ public class Hiero extends JFrame {
 				String fileName = dialog.getFile();
 				if (fileName == null) return;
 				lastSaveBMFilename = fileName;
-				saveBm(new File(dialog.getDirectory(), fileName));
+				saveBmFontFile = new File(dialog.getDirectory(), fileName);
 			}
 		});
 
@@ -1354,6 +1297,18 @@ public class Hiero extends JFrame {
 				glyphsTotalLabel.setText(String.valueOf(glyphCount));
 			}
 
+			if (saveBmFontFile != null) {
+				try {
+					BMFontUtil bmFont = new BMFontUtil(unicodeFont);
+					bmFont.save(saveBmFontFile);
+				} catch (Throwable ex) {
+					System.out.println("Error saving BMFont files: " + saveBmFontFile.getAbsolutePath());
+					ex.printStackTrace();
+				} finally {
+					saveBmFontFile = null;
+				}
+			}
+
 			if (unicodeFont == null) return;
 
 			try {
@@ -1408,22 +1363,6 @@ public class Hiero extends JFrame {
 					glEnd();
 				}
 			}
-
-			if (saveBmFontFile != null) {
-				try {
-					BMFontUtil bmFont = new BMFontUtil(unicodeFont);
-					bmFont.save(saveBmFontFile);
-
-					if (batchMode) {
-						System.exit(0);
-					}
-				} catch (Throwable ex) {
-					System.out.println("Error saving BMFont files: " + saveBmFontFile.getAbsolutePath());
-					ex.printStackTrace();
-				} finally {
-					saveBmFontFile = null;
-				}
-			}
 		}
 
 		@Override
@@ -1439,7 +1378,7 @@ public class Hiero extends JFrame {
 		}
 	}
 
-	public static void main (final String[] args) throws Exception {
+	public static void main (String[] args) throws Exception {
 // LookAndFeelInfo[] lookAndFeels = UIManager.getInstalledLookAndFeels();
 // for (int i = 0, n = lookAndFeels.length; i < n; i++) {
 // if ("Nimbus".equals(lookAndFeels[i].getName())) {
@@ -1454,7 +1393,7 @@ public class Hiero extends JFrame {
 
 			@Override
 			public void run () {
-				new Hiero(args);
+				new Hiero();
 			}
 		});
 	}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/hiero/unicodefont/HieroSettings.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/hiero/unicodefont/HieroSettings.java
index e4b38f7..a50ee52 100644
--- a/extensions/gdx-tools/src/com/badlogic/gdx/tools/hiero/unicodefont/HieroSettings.java
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/hiero/unicodefont/HieroSettings.java
@@ -42,9 +42,7 @@ public class HieroSettings {
 	private String glyphText = "";
 	private final List effects = new ArrayList();
 	private boolean nativeRendering;
-	private boolean font2Active = false;
-	private String font2File = "";
-	
+
 	public HieroSettings () {
 	}
 
@@ -68,10 +66,6 @@ public class HieroSettings {
 					bold = Boolean.parseBoolean(value);
 				} else if (name.equals("font.italic")) {
 					italic = Boolean.parseBoolean(value);
-				} else if (name.equals("font2.file")) {
-					font2File = value;
-				} else if (name.equals("font2.use")) {
-					font2Active = Boolean.parseBoolean(value);
 				} else if (name.equals("pad.top")) {
 					paddingTop = Integer.parseInt(value);
 				} else if (name.equals("pad.right")) {
@@ -268,22 +262,6 @@ public class HieroSettings {
 		this.glyphText = text.replace("\n", "\\n");
 	}
 
-	public String getFont2File () {
-		return font2File;
-	}
-
-	public void setFont2File (String filename) {
-		this.font2File = filename;
-	}
-
-	public boolean isFont2Active () {
-		return font2Active;
-	}
-
-	public void setFont2Active (boolean active) {
-		this.font2Active = active;
-	}
-
 	/** Saves the settings to a file.
 	 * @throws IOException if the file could not be saved. */
 	public void save (File file) throws IOException {
@@ -293,9 +271,6 @@ public class HieroSettings {
 		out.println("font.bold=" + bold);
 		out.println("font.italic=" + italic);
 		out.println();
-		out.println("font2.file=" + font2File);
-		out.println("font2.use=" + font2Active);
-		out.println();
 		out.println("pad.top=" + paddingTop);
 		out.println("pad.right=" + paddingRight);
 		out.println("pad.bottom=" + paddingBottom);
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/ktx/KTXProcessor.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/ktx/KTXProcessor.java
deleted file mode 100644
index cfdd06a..0000000
--- a/extensions/gdx-tools/src/com/badlogic/gdx/tools/ktx/KTXProcessor.java
+++ /dev/null
@@ -1,364 +0,0 @@
-
-package com.badlogic.gdx.tools.ktx;
-
-import java.io.DataOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.nio.ByteBuffer;
-import java.util.zip.GZIPOutputStream;
-
-import com.badlogic.gdx.ApplicationAdapter;
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.backends.headless.HeadlessApplication;
-import com.badlogic.gdx.backends.lwjgl.LwjglNativesLoader;
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.Pixmap;
-import com.badlogic.gdx.graphics.Pixmap.Blending;
-import com.badlogic.gdx.graphics.Pixmap.Filter;
-import com.badlogic.gdx.graphics.Pixmap.Format;
-import com.badlogic.gdx.graphics.glutils.ETC1;
-import com.badlogic.gdx.graphics.glutils.ETC1.ETC1Data;
-import com.badlogic.gdx.graphics.glutils.KTXTextureData;
-import com.badlogic.gdx.math.MathUtils;
-import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-
-public class KTXProcessor {
-
-	final static byte[] HEADER_MAGIC = {(byte)0x0AB, (byte)0x04B, (byte)0x054, (byte)0x058, (byte)0x020, (byte)0x031,
-		(byte)0x031, (byte)0x0BB, (byte)0x00D, (byte)0x00A, (byte)0x01A, (byte)0x00A};
-
-	public static void convert (String input, String output, boolean genMipmaps, boolean packETC1, boolean genAlphaAtlas)
-		throws Exception {
-		Array<String> opts = new Array<String>(String.class);
-		opts.add(input);
-		opts.add(output);
-		if (genMipmaps) opts.add("-mipmaps");
-		if (packETC1 && !genAlphaAtlas) opts.add("-etc1");
-		if (packETC1 && genAlphaAtlas) opts.add("-etc1a");
-		main(opts.toArray());
-	}
-
-	public static void convert (String inPx, String inNx, String inPy, String inNy, String inPz, String inNz, String output,
-		boolean genMipmaps, boolean packETC1, boolean genAlphaAtlas) throws Exception {
-		Array<String> opts = new Array<String>(String.class);
-		opts.add(inPx);
-		opts.add(inNx);
-		opts.add(inPy);
-		opts.add(inNy);
-		opts.add(inPz);
-		opts.add(inNz);
-		opts.add(output);
-		if (genMipmaps) opts.add("-mipmaps");
-		if (packETC1 && !genAlphaAtlas) opts.add("-etc1");
-		if (packETC1 && genAlphaAtlas) opts.add("-etc1a");
-		main(opts.toArray());
-	}
-
-	private final static int DISPOSE_DONT = 0;
-	private final static int DISPOSE_PACK = 1;
-	private final static int DISPOSE_FACE = 2;
-	private final static int DISPOSE_LEVEL = 4;
-
-	public static void main (String[] args) {
-		new HeadlessApplication(new KTXProcessorListener(args));
-	}
-
-	public static class KTXProcessorListener extends ApplicationAdapter {
-		String[] args;
-
-		KTXProcessorListener (String[] args) {
-			this.args = args;
-		}
-
-		@Override
-		public void create () {
-			boolean isCubemap = args.length == 7 || args.length == 8 || args.length == 9;
-			boolean isTexture = args.length == 2 || args.length == 3 || args.length == 4;
-			boolean isPackETC1 = false, isAlphaAtlas = false, isGenMipMaps = false;
-			if (!isCubemap && !isTexture) {
-				System.out.println("usage : KTXProcessor input_file output_file [-etc1|-etc1a] [-mipmaps]");
-				System.out.println("  input_file  is the texture file to include in the output KTX or ZKTX file.");
-				System.out
-					.println("              for cube map, just provide 6 input files corresponding to the faces in the following order : X+, X-, Y+, Y-, Z+, Z-");
-				System.out
-					.println("  output_file is the path to the output file, its type is based on the extension which must be either KTX or ZKTX");
-				System.out.println();
-				System.out.println("  options:");
-				System.out.println("    -etc1    input file will be packed using ETC1 compression, dropping the alpha channel");
-				System.out
-					.println("    -etc1a   input file will be packed using ETC1 compression, doubling the height and placing the alpha channel in the bottom half");
-				System.out.println("    -mipmaps input file will be processed to generate mipmaps");
-				System.out.println();
-				System.out.println("  examples:");
-				System.out
-					.println("    KTXProcessor in.png out.ktx                                        Create a KTX file with the provided 2D texture");
-				System.out
-					.println("    KTXProcessor in.png out.zktx                                       Create a Zipped KTX file with the provided 2D texture");
-				System.out
-					.println("    KTXProcessor in.png out.zktx -mipmaps                              Create a Zipped KTX file with the provided 2D texture, generating all mipmap levels");
-				System.out
-					.println("    KTXProcessor px.ktx nx.ktx py.ktx ny.ktx pz.ktx nz.ktx out.zktx    Create a Zipped KTX file with the provided cubemap textures");
-				System.out
-					.println("    KTXProcessor in.ktx out.zktx                                       Convert a KTX file to a Zipped KTX file");
-				System.exit(-1);
-			}
-
-			LwjglNativesLoader.load();
-
-			// Loads other options
-			for (int i = 0; i < args.length; i++) {
-				System.out.println(i + " = " + args[i]);
-				if (isTexture && i < 2) continue;
-				if (isCubemap && i < 7) continue;
-				if ("-etc1".equals(args[i])) isPackETC1 = true;
-				if ("-etc1a".equals(args[i])) isAlphaAtlas = isPackETC1 = true;
-				if ("-mipmaps".equals(args[i])) isGenMipMaps = true;
-			}
-
-			File output = new File(args[isCubemap ? 6 : 1]);
-
-			// Check if we have a cubemapped ktx file as input
-			int ktxDispose = DISPOSE_DONT;
-			KTXTextureData ktx = null;
-			FileHandle file = new FileHandle(args[0]);
-			if (file.name().toLowerCase().endsWith(".ktx") || file.name().toLowerCase().endsWith(".zktx")) {
-				ktx = new KTXTextureData(file, false);
-				if (ktx.getNumberOfFaces() == 6) isCubemap = true;
-				ktxDispose = DISPOSE_PACK;
-			}
-
-			// Process all faces
-			int nFaces = isCubemap ? 6 : 1;
-			Image[][] images = new Image[nFaces][];
-			Pixmap.setBlending(Blending.None);
-			Pixmap.setFilter(Filter.BiLinear);
-			int texWidth = -1, texHeight = -1, texFormat = -1, nLevels = 0;
-			for (int face = 0; face < nFaces; face++) {
-				ETC1Data etc1 = null;
-				Pixmap facePixmap = null;
-				int ktxFace = 0;
-
-				// Load source image (ends up with either ktx, etc1 or facePixmap initialized)
-				if (ktx != null && ktx.getNumberOfFaces() == 6) {
-					// No loading since we have a ktx file with cubemap as input
-					nLevels = ktx.getNumberOfMipMapLevels();
-					ktxFace = face;
-				} else {
-					file = new FileHandle(args[face]);
-					System.out.println("Processing : " + file + " for face #" + face);
-					if (file.name().toLowerCase().endsWith(".ktx") || file.name().toLowerCase().endsWith(".zktx")) {
-						if (ktx == null || ktx.getNumberOfFaces() != 6) {
-							ktxDispose = DISPOSE_FACE;
-							ktx = new KTXTextureData(file, false);
-							ktx.prepare();
-						}
-						nLevels = ktx.getNumberOfMipMapLevels();
-						texWidth = ktx.getWidth();
-						texHeight = ktx.getHeight();
-					} else if (file.name().toLowerCase().endsWith(".etc1")) {
-						etc1 = new ETC1Data(file);
-						nLevels = 1;
-						texWidth = etc1.width;
-						texHeight = etc1.height;
-					} else {
-						facePixmap = new Pixmap(file);
-						nLevels = 1;
-						texWidth = facePixmap.getWidth();
-						texHeight = facePixmap.getHeight();
-					}
-					if (isGenMipMaps) {
-						if (!MathUtils.isPowerOfTwo(texWidth) || !MathUtils.isPowerOfTwo(texHeight))
-							throw new GdxRuntimeException(
-								"Invalid input : mipmap generation is only available for power of two textures : " + file);
-						nLevels = Math.max(Integer.SIZE - Integer.numberOfLeadingZeros(texWidth),
-							Integer.SIZE - Integer.numberOfLeadingZeros(texHeight));
-					}
-				}
-
-				// Process each mipmap level
-				images[face] = new Image[nLevels];
-				for (int level = 0; level < nLevels; level++) {
-					int levelWidth = Math.max(1, texWidth >> level);
-					int levelHeight = Math.max(1, texHeight >> level);
-
-					// Get pixmap for this level (ends with either levelETCData or levelPixmap being non null)
-					Pixmap levelPixmap = null;
-					ETC1Data levelETCData = null;
-					if (ktx != null) {
-						ByteBuffer ktxData = ktx.getData(level, ktxFace);
-						if (ktxData != null && ktx.getGlInternalFormat() == ETC1.ETC1_RGB8_OES)
-							levelETCData = new ETC1Data(levelWidth, levelHeight, ktxData, 0);
-					}
-					if (ktx != null && levelETCData == null && facePixmap == null) {
-						ByteBuffer ktxData = ktx.getData(0, ktxFace);
-						if (ktxData != null && ktx.getGlInternalFormat() == ETC1.ETC1_RGB8_OES)
-							facePixmap = ETC1.decodeImage(new ETC1Data(levelWidth, levelHeight, ktxData, 0), Format.RGB888);
-					}
-					if (level == 0 && etc1 != null) {
-						levelETCData = etc1;
-					}
-					if (levelETCData == null && etc1 != null && facePixmap == null) {
-						facePixmap = ETC1.decodeImage(etc1, Format.RGB888);
-					}
-					if (levelETCData == null) {
-						levelPixmap = new Pixmap(levelWidth, levelHeight, facePixmap.getFormat());
-						levelPixmap.drawPixmap(facePixmap, 0, 0, facePixmap.getWidth(), facePixmap.getHeight(), 0, 0,
-							levelPixmap.getWidth(), levelPixmap.getHeight());
-					}
-					if (levelETCData == null && levelPixmap == null)
-						throw new GdxRuntimeException("Failed to load data for face " + face + " / mipmap level " + level);
-
-					// Create alpha atlas
-					if (isAlphaAtlas) {
-						if (levelPixmap == null) levelPixmap = ETC1.decodeImage(levelETCData, Format.RGB888);
-						int w = levelPixmap.getWidth(), h = levelPixmap.getHeight();
-						Pixmap pm = new Pixmap(w, h * 2, levelPixmap.getFormat());
-						pm.drawPixmap(levelPixmap, 0, 0);
-						for (int y = 0; y < h; y++) {
-							for (int x = 0; x < w; x++) {
-								int alpha = (levelPixmap.getPixel(x, y)) & 0x0FF;
-								pm.drawPixel(x, y + h, (alpha << 24) | (alpha << 16) | (alpha << 8) | 0x0FF);
-							}
-						}
-						levelPixmap.dispose();
-						levelPixmap = pm;
-						levelETCData = null;
-					}
-
-					// Perform ETC1 compression
-					if (levelETCData == null && isPackETC1) {
-						if (levelPixmap.getFormat() != Format.RGB888 && levelPixmap.getFormat() != Format.RGB565) {
-							if (!isAlphaAtlas)
-								System.out.println("Converting from " + levelPixmap.getFormat() + " to RGB888 for ETC1 compression");
-							Pixmap tmp = new Pixmap(levelPixmap.getWidth(), levelPixmap.getHeight(), Format.RGB888);
-							tmp.drawPixmap(levelPixmap, 0, 0, 0, 0, levelPixmap.getWidth(), levelPixmap.getHeight());
-							levelPixmap.dispose();
-							levelPixmap = tmp;
-						}
-						// System.out.println("Compress : " + levelWidth + " x " + levelHeight);
-						levelETCData = ETC1.encodeImagePKM(levelPixmap);
-						levelPixmap.dispose();
-						levelPixmap = null;
-					}
-
-					// Save result to ouput ktx
-					images[face][level] = new Image();
-					images[face][level].etcData = levelETCData;
-					images[face][level].pixmap = levelPixmap;
-					if (levelPixmap != null) {
-						levelPixmap.dispose();
-						facePixmap = null;
-					}
-				}
-
-				// Dispose resources
-				if (facePixmap != null) {
-					facePixmap.dispose();
-					facePixmap = null;
-				}
-				if (etc1 != null) {
-					etc1.dispose();
-					etc1 = null;
-				}
-				if (ktx != null && ktxDispose == DISPOSE_FACE) {
-					ktx.disposePreparedData();
-					ktx = null;
-				}
-			}
-			if (ktx != null) {
-				ktx.disposePreparedData();
-				ktx = null;
-			}
-
-			int glType, glTypeSize, glFormat, glInternalFormat, glBaseInternalFormat;
-			if (isPackETC1) {
-				glType = glFormat = 0;
-				glTypeSize = 1;
-				glInternalFormat = ETC1.ETC1_RGB8_OES;
-				glBaseInternalFormat = GL20.GL_RGB;
-			} else if (images[0][0].pixmap != null) {
-				glType = images[0][0].pixmap.getGLType();
-				glTypeSize = 1;
-				glFormat = images[0][0].pixmap.getGLFormat();
-				glInternalFormat = images[0][0].pixmap.getGLInternalFormat();
-				glBaseInternalFormat = glFormat;
-			} else
-				throw new GdxRuntimeException("Unsupported output format");
-
-			int totalSize = 12 + 13 * 4;
-			for (int level = 0; level < nLevels; level++) {
-				System.out.println("Level: " + level);
-				int faceLodSize = images[0][level].getSize();
-				int faceLodSizeRounded = (faceLodSize + 3) & ~3;
-				totalSize += 4;
-				totalSize += nFaces * faceLodSizeRounded;
-			}
-
-			try {
-				DataOutputStream out;
-				if (output.getName().toLowerCase().endsWith(".zktx")) {
-					out = new DataOutputStream(new GZIPOutputStream(new FileOutputStream(output)));
-					out.writeInt(totalSize);
-				} else
-					out = new DataOutputStream(new FileOutputStream(output));
-
-				out.write(HEADER_MAGIC);
-				out.writeInt(0x04030201);
-				out.writeInt(glType);
-				out.writeInt(glTypeSize);
-				out.writeInt(glFormat);
-				out.writeInt(glInternalFormat);
-				out.writeInt(glBaseInternalFormat);
-				out.writeInt(texWidth);
-				out.writeInt(isAlphaAtlas ? (2 * texHeight) : texHeight);
-				out.writeInt(0); // depth (not supported)
-				out.writeInt(0); // n array elements (not supported)
-				out.writeInt(nFaces);
-				out.writeInt(nLevels);
-				out.writeInt(0); // No additional info (key/value pairs)
-				for (int level = 0; level < nLevels; level++) {
-					int faceLodSize = images[0][level].getSize();
-					int faceLodSizeRounded = (faceLodSize + 3) & ~3;
-					out.writeInt(faceLodSize);
-					for (int face = 0; face < nFaces; face++) {
-						byte[] bytes = images[face][level].getBytes();
-						out.write(bytes);
-						for (int j = bytes.length; j < faceLodSizeRounded; j++)
-							out.write((byte)0x00);
-					}
-				}
-
-				out.close();
-			} catch (Exception e) {
-				Gdx.app.error("KTXProcessor", "Error writing to file: " + output.getName(), e);
-			}
-		}
-	}
-
-	private static class Image {
-
-		public ETC1Data etcData;
-		public Pixmap pixmap;
-
-		public Image () {
-		}
-
-		public int getSize () {
-			if (etcData != null) return etcData.compressedData.limit() - etcData.dataOffset;
-			throw new GdxRuntimeException("Unsupported output format, try adding '-etc1' as argument");
-		}
-
-		public byte[] getBytes () {
-			if (etcData != null) {
-				byte[] result = new byte[getSize()];
-				etcData.compressedData.position(etcData.dataOffset);
-				etcData.compressedData.get(result);
-				return result;
-			}
-			throw new GdxRuntimeException("Unsupported output format, try adding '-etc1' as argument");
-		}
-
-	}
-}
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/particleeditor/EffectPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/particleeditor/EffectPanel.java
index fa3a050..7b1f638 100644
--- a/extensions/gdx-tools/src/com/badlogic/gdx/tools/particleeditor/EffectPanel.java
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/particleeditor/EffectPanel.java
@@ -16,15 +16,23 @@
 
 package com.badlogic.gdx.tools.particleeditor;
 
-import java.awt.*;
+import java.awt.FileDialog;
+import java.awt.GridBagConstraints;
+import java.awt.GridBagLayout;
+import java.awt.Insets;
 import java.awt.event.ActionEvent;
 import java.awt.event.ActionListener;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.Writer;
-import java.net.URI;
 
-import javax.swing.*;
+import javax.swing.JButton;
+import javax.swing.JOptionPane;
+import javax.swing.JPanel;
+import javax.swing.JScrollPane;
+import javax.swing.JSeparator;
+import javax.swing.JTable;
+import javax.swing.ListSelectionModel;
 import javax.swing.event.ListSelectionEvent;
 import javax.swing.event.ListSelectionListener;
 import javax.swing.event.TableModelEvent;
@@ -147,10 +155,8 @@ class EffectPanel extends JPanel {
 		lastDir = dir;
 		ParticleEffect effect = new ParticleEffect();
 		try {
-			File effectFile = new File(dir, file);
-			effect.loadEmitters(Gdx.files.absolute(effectFile.getAbsolutePath()));
+			effect.loadEmitters(Gdx.files.absolute(new File(dir, file).getAbsolutePath()));
 			editor.effect = effect;
-			editor.effectFile = effectFile;
 			emitterTableModel.getDataVector().removeAllElements();
 			editor.particleData.clear();
 		} catch (Exception ex) {
@@ -177,19 +183,8 @@ class EffectPanel extends JPanel {
 		if (dir == null || file == null || file.trim().length() == 0) return;
 		lastDir = dir;
 		int index = 0;
-		File effectFile = new File(dir, file);
-
-		// save each image path as relative path to effect file directory
-		URI effectDirUri = effectFile.getParentFile().toURI();
-		for (ParticleEmitter emitter : editor.effect.getEmitters()) {
+		for (ParticleEmitter emitter : editor.effect.getEmitters())
 			emitter.setName((String)emitterTableModel.getValueAt(index++, 0));
-			String imagePath = emitter.getImagePath();
-			if ((imagePath.contains("/") || imagePath.contains("\\")) && !imagePath.contains("..")) {
-				// it's absolute, make it relative:
-				URI imageUri = new File(emitter.getImagePath()).toURI();
-				emitter.setImagePath(effectDirUri.relativize(imageUri).getPath());
-			}
-		}
 
 		File outputFile = new File(dir, file);
 		Writer fileWriter = null;
@@ -204,13 +199,13 @@ class EffectPanel extends JPanel {
 			StreamUtils.closeQuietly(fileWriter);
 		}
 	}
-
-	void duplicateEmitter () {
+	
+	void duplicateEmitter() {
 		int row = emitterTable.getSelectedRow();
 		if (row == -1) return;
-
+		
 		String name = (String)emitterTableModel.getValueAt(row, 0);
-
+		
 		addEmitter(name, true, new ParticleEmitter(editor.effect.getEmitters().get(row)));
 	}
 
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/particleeditor/ParticleEditor.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/particleeditor/ParticleEditor.java
index 94887b0..b30c904 100644
--- a/extensions/gdx-tools/src/com/badlogic/gdx/tools/particleeditor/ParticleEditor.java
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/particleeditor/ParticleEditor.java
@@ -16,16 +16,29 @@
 
 package com.badlogic.gdx.tools.particleeditor;
 
-import java.awt.*;
+import java.awt.BorderLayout;
+import java.awt.Component;
+import java.awt.EventQueue;
+import java.awt.Graphics;
+import java.awt.GridBagConstraints;
+import java.awt.GridBagLayout;
+import java.awt.Insets;
 import java.awt.event.WindowAdapter;
 import java.awt.event.WindowEvent;
 import java.io.File;
 import java.net.MalformedURLException;
-import java.net.URI;
 import java.net.URL;
 import java.util.HashMap;
 
-import javax.swing.*;
+import javax.swing.BorderFactory;
+import javax.swing.ImageIcon;
+import javax.swing.JComponent;
+import javax.swing.JFrame;
+import javax.swing.JOptionPane;
+import javax.swing.JPanel;
+import javax.swing.JScrollPane;
+import javax.swing.JSplitPane;
+import javax.swing.UIManager;
 import javax.swing.UIManager.LookAndFeelInfo;
 import javax.swing.border.CompoundBorder;
 import javax.swing.plaf.basic.BasicSplitPaneUI;
@@ -50,10 +63,10 @@ import com.badlogic.gdx.math.Vector3;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 
 public class ParticleEditor extends JFrame {
-	public static final String DEFAULT_PARTICLE = "particle.png";
+	public static final String DEFAULT_PARTICLE = "particle.png"; 
 
 	public static final String DEFAULT_PREMULT_PARTICLE = "pre_particle.png";
-
+	
 	LwjglCanvas lwjglCanvas;
 	JPanel rowsPanel;
 	JPanel editRowsPanel;
@@ -70,7 +83,6 @@ public class ParticleEditor extends JFrame {
 	float zoomLevelPrev;
 
 	ParticleEffect effect = new ParticleEffect();
-	File effectFile;
 	final HashMap<ParticleEmitter, ParticleData> particleData = new HashMap();
 
 	public ParticleEditor () {
@@ -317,14 +329,14 @@ public class ParticleEditor extends JFrame {
 			zoomLevel = new NumericValue();
 			zoomLevel.setValue(1.0f);
 			zoomLevel.setAlwaysActive(true);
-
+			
 			deltaMultiplier = new NumericValue();
 			deltaMultiplier.setValue(1.0f);
 			deltaMultiplier.setAlwaysActive(true);
 
 			backgroundColor = new GradientColorValue();
-			backgroundColor.setColors(new float[] {0f, 0f, 0f});
-
+			backgroundColor.setColors(new float[] { 0f, 0f, 0f});
+
 			font = new BitmapFont(Gdx.files.getFileHandle("default.fnt", FileType.Internal), Gdx.files.getFileHandle("default.png",
 				FileType.Internal), true);
 			effectPanel.newExampleEmitter("Untitled", true);
@@ -370,7 +382,7 @@ public class ParticleEditor extends JFrame {
 				zoomLevelPrev = zoomLevel.getValue();
 				pixelsPerMeterPrev = pixelsPerMeter.getValue();
 			}
-
+			
 			spriteBatch.setProjectionMatrix(worldCamera.combined);
 
 			spriteBatch.begin();
@@ -426,24 +438,11 @@ public class ParticleEditor extends JFrame {
 			String imageName = new File(imagePath.replace('\\', '/')).getName();
 			try {
 				FileHandle file;
-				if (imagePath.equals(ParticleEditor.DEFAULT_PARTICLE) || imagePath.equals(ParticleEditor.DEFAULT_PREMULT_PARTICLE)) {
+				if (imagePath.equals(ParticleEditor.DEFAULT_PARTICLE) || imagePath.equals(ParticleEditor.DEFAULT_PREMULT_PARTICLE))
 					file = Gdx.files.classpath(imagePath);
-				} else {
-					if ((imagePath.contains("/") || imagePath.contains("\\")) && !imageName.contains("..")) {
-						file = Gdx.files.absolute(imagePath);
-						if (!file.exists()) {
-							// try to use image in effect directory
-							file = Gdx.files.absolute(new File(effectFile.getParentFile(), imageName).getAbsolutePath());
-						}
-					} else {
-						file = Gdx.files.absolute(new File(effectFile.getParentFile(), imagePath).getAbsolutePath());
-					}
-				}
+				else
+					file = Gdx.files.absolute(imagePath);
 				emitter.setSprite(new Sprite(new Texture(file)));
-				if (effectFile != null) {
-					URI relativeUri = effectFile.getParentFile().toURI().relativize(file.file().toURI());
-					emitter.setImagePath(relativeUri.getPath());
-				}
 			} catch (GdxRuntimeException ex) {
 				ex.printStackTrace();
 				EventQueue.invokeLater(new Runnable() {
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/TexturePacker.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/TexturePacker.java
index a83f1c9..ac3ceaa 100644
--- a/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/TexturePacker.java
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/TexturePacker.java
@@ -89,7 +89,7 @@ public class TexturePacker {
 
 	public void pack (File outputDir, String packFileName) {
 		if (packFileName.endsWith(settings.atlasExtension))
-			packFileName = packFileName.substring(0, packFileName.length() - settings.atlasExtension.length());
+			packFileName = packFileName.substring(packFileName.length() - settings.atlasExtension.length());
 		outputDir.mkdirs();
 
 		for (int i = 0, n = settings.scale.length; i < n; i++) {
@@ -575,10 +575,8 @@ public class TexturePacker {
 			useIndexes = settings.useIndexes;
 			bleed = settings.bleed;
 			limitMemory = settings.limitMemory;
-			grid = settings.grid;
 			scale = settings.scale;
 			scaleSuffix = settings.scaleSuffix;
-			atlasExtension = settings.atlasExtension;
 		}
 
 		public String getScaledPackFileName (String packFileName, int scaleIndex) {
@@ -617,7 +615,7 @@ public class TexturePacker {
 			});
 			processor.process(new File(input), new File(output));
 		} catch (Exception ex) {
-			throw new RuntimeException("Error packing images.", ex);
+			throw new RuntimeException("Error packing files.", ex);
 		}
 	}
 
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/TextureUnpacker.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/TextureUnpacker.java
index 7aca554..8602c9c 100644
--- a/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/TextureUnpacker.java
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/texturepacker/TextureUnpacker.java
@@ -105,7 +105,7 @@ public class TextureUnpacker {
 					}
 
 					// check if the parent directories of this image file exist and create them if not
-					File imgOutput = new File(outputDirFile, String.format("%s.%s", region.index == -1?region.name:region.name + "_" + region.index, extension));
+					File imgOutput = new File(outputDirFile, String.format("%s.%s", region.name, extension));
 					File imgDir = imgOutput.getParentFile();
 					if (!imgDir.exists()) {
 						System.out.println(String.format("Creating directory: %s", imgDir.getPath()));
@@ -135,7 +135,7 @@ public class TextureUnpacker {
 		// get the needed part of the page and rotate if needed
 		if (region.rotate) {
 			BufferedImage srcImage = page.getSubimage(region.left, region.top, region.height, region.width);
-			splitImage = new BufferedImage(region.width, region.height, page.getType());
+			splitImage = new BufferedImage(region.height, region.width, page.getType());
 
 			AffineTransform transform = new AffineTransform();
 			transform.rotate(Math.toRadians(90.0));
diff --git a/gdx/jni/Android.mk b/gdx/jni/Android.mk
index 85881ad..8316ab2 100644
--- a/gdx/jni/Android.mk
+++ b/gdx/jni/Android.mk
@@ -18,6 +18,7 @@ LOCAL_SRC_FILES := android/AndroidGL20.cpp\
 	gdx2d/gdx2d.c\
 	gdx2d/jpgd.cpp\
 	gdx2d/jpgd_c.cpp\
+	gdx2d/stb_image.c\
 	memcpy_wrap.c
  
 include $(BUILD_SHARED_LIBRARY)
diff --git a/gdx/jni/android/AndroidGL20.cpp b/gdx/jni/android/AndroidGL20.cpp
index 1d0dc9a..eaf4c5c 100644
--- a/gdx/jni/android/AndroidGL20.cpp
+++ b/gdx/jni/android/AndroidGL20.cpp
@@ -498,18 +498,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glDeleteBuffer
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDeleteBuffer
-  (JNIEnv *, jobject, jint buffer)
-{
-	GLuint buf =  buffer;
-	glDeleteBuffers(1, &buf);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glDeleteFramebuffers
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -522,18 +510,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glDeleteFramebuffer
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDeleteFramebuffer
-  (JNIEnv *, jobject, jint buffer)
-{
-	GLuint buf = buffer;
-	glDeleteFramebuffers(1, &buf);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glDeleteProgram
  * Signature: (I)V
  */
@@ -557,18 +533,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glDeleteRenderbuffer
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDeleteRenderbuffer
-  (JNIEnv *, jobject, jint buffer)
-{
-	GLuint buf = buffer;
-	glDeleteRenderbuffers(1, &buf);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glDeleteShader
  * Signature: (I)V
  */
@@ -592,18 +556,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glDeleteTexture
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDeleteTexture
-  (JNIEnv *, jobject, jint buffer)
-{
-	GLuint buf = buffer;
-	glDeleteTextures( 1, &buf);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glDepthFunc
  * Signature: (I)V
  */
@@ -789,19 +741,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenB
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glGenBuffer
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenBuffer
-  (JNIEnv *, jobject)
-{
-	GLuint result;
-	glGenBuffers( 1, &result);
-	return result;
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glGenerateMipmap
  * Signature: (I)V
  */
@@ -825,19 +764,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenF
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glGenFramebuffer
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenFramebuffer
-  (JNIEnv *, jobject)
-{
-	GLuint result;
-	glGenFramebuffers(1, &result);
-	return result;
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glGenRenderbuffers
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -850,19 +776,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenR
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glGenRenderbuffer
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenRenderbuffer
-  (JNIEnv *, jobject)
-{
-	GLuint result;
-	glGenRenderbuffers( 1, &result);
-	return result;
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glGenTextures
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -875,19 +788,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenT
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glGenTexture
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenTexture
-  (JNIEnv *, jobject)
-{
-	GLuint result;
-	glGenTextures(1, &result);
-	return result;
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glGetActiveAttrib
  * Signature: (IIILjava/nio/Buffer;Ljava/nio/IntBuffer;Ljava/nio/Buffer;Ljava/lang/String;)V
  */
@@ -1582,7 +1482,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform1fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1fv__IILjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1fv
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1591,19 +1491,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glUniform1fv
- * Signature: (II[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1fv__II_3FI
-  (JNIEnv *env, jobject, jint location, jint count, jfloatArray value, jint offset)
-{
-	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
-	glUniform1fv( location, count, (GLfloat*)&v[offset] );
-	env->ReleasePrimitiveArrayCritical(value, v, 0);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform1i
  * Signature: (II)V
  */
@@ -1618,7 +1505,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform1iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1iv__IILjava_nio_IntBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1iv
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1627,19 +1514,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glUniform1iv
- * Signature: (II[II)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1iv__II_3II
-  (JNIEnv *env, jobject, jint location, jint count, jintArray value, jint offset)
-{
-	int* v = (int*)env->GetPrimitiveArrayCritical(value, 0);
-	glUniform1iv( location, count, (GLint*)&v[offset] );
-	env->ReleasePrimitiveArrayCritical(value, v, 0);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform2f
  * Signature: (IFF)V
  */
@@ -1654,7 +1528,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform2fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2fv__IILjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2fv
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1663,19 +1537,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glUniform2fv
- * Signature: (II[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2fv__II_3FI
-  (JNIEnv *env, jobject, jint location, jint count, jfloatArray value, jint offset)
-{
-	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
-	glUniform2fv( location, count, (GLfloat*)&v[offset] );
-	env->ReleasePrimitiveArrayCritical(value, v, 0);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform2i
  * Signature: (III)V
  */
@@ -1690,7 +1551,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform2iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2iv__IILjava_nio_IntBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2iv
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1699,19 +1560,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glUniform2iv
- * Signature: (II[II)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2iv__II_3II
-  (JNIEnv *env, jobject, jint location, jint count, jintArray value, jint offset)
-{
-	int* v = (int*)env->GetPrimitiveArrayCritical(value, 0);
-	glUniform2iv( location, count, (GLint*)&v[offset] );
-	env->ReleasePrimitiveArrayCritical(value, v, 0);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform3f
  * Signature: (IFFF)V
  */
@@ -1726,7 +1574,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform3fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3fv__IILjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3fv
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1735,19 +1583,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glUniform3fv
- * Signature: (II[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3fv__II_3FI
-  (JNIEnv *env, jobject, jint location, jint count, jfloatArray value, jint offset)
-{
-	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
-	glUniform3fv( location, count, (GLfloat*)&v[offset] );
-	env->ReleasePrimitiveArrayCritical(value, v, 0);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform3i
  * Signature: (IIII)V
  */
@@ -1762,7 +1597,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform3iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3iv__IILjava_nio_IntBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3iv
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1771,19 +1606,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glUniform3iv
- * Signature: (II[II)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3iv__II_3II
-  (JNIEnv *env, jobject, jint location, jint count, jintArray value, jint offset)
-{
-	int* v = (int*)env->GetPrimitiveArrayCritical(value, 0);
-	glUniform3iv( location, count, (GLint*)&v[offset] );
-	env->ReleasePrimitiveArrayCritical(value, v, 0);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform4f
  * Signature: (IFFFF)V
  */
@@ -1798,7 +1620,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform4fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4fv__IILjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4fv
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1807,19 +1629,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glUniform4fv
- * Signature: (II[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4fv__II_3FI
-  (JNIEnv *env, jobject, jint location, jint count, jfloatArray value, jint offset)
-{
-	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
-	glUniform4fv( location, count, (GLfloat*)&v[offset] );
-	env->ReleasePrimitiveArrayCritical(value, v, 0);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform4i
  * Signature: (IIIII)V
  */
@@ -1834,7 +1643,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform4iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4iv__IILjava_nio_IntBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4iv
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1843,23 +1652,10 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glUniform4iv
- * Signature: (II[II)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4iv__II_3II
-  (JNIEnv *env, jobject, jint location, jint count, jintArray value, jint offset)
-{
-	int* v = (int*)env->GetPrimitiveArrayCritical(value, 0);
-	glUniform4iv( location, count, (GLint*)&v[offset] );
-	env->ReleasePrimitiveArrayCritical(value, v, 0);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniformMatrix2fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix2fv__IIZLjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix2fv
   (JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jobject value)
 {
 	void* dataPtr = getDirectBufferPointer( env, value );
@@ -1868,23 +1664,10 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glUniformMatrix2fv
- * Signature: (IIZ[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix2fv__IIZ_3FI
-  (JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jfloatArray value, jint offset)
-{
-	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
-	glUniformMatrix2fv( location, count, transpose, (GLfloat*)&v[offset] );
-	env->ReleasePrimitiveArrayCritical(value, v, 0);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniformMatrix3fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix3fv__IIZLjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix3fv
   (JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jobject value)
 {
 	void* dataPtr = getDirectBufferPointer( env, value );
@@ -1893,23 +1676,10 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glUniformMatrix3fv
- * Signature: (IIZ[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix3fv__IIZ_3FI
-  (JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jfloatArray value, jint offset)
-{
-	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
-	glUniformMatrix3fv( location, count, transpose, (GLfloat*)&v[offset] );
-	env->ReleasePrimitiveArrayCritical(value, v, 0);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniformMatrix4fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix4fv__IIZLjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix4fv
   (JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jobject value)
 {
 	void* dataPtr = getDirectBufferPointer( env, value );
@@ -1918,19 +1688,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glUniformMatrix4fv
- * Signature: (IIZ[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix4fv__IIZ_3FI
-  (JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jfloatArray value, jint offset)
-{
-	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
-	glUniformMatrix4fv( location, count, transpose, (GLfloat*)&v[offset] );
-	env->ReleasePrimitiveArrayCritical(value, v, 0);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUseProgram
  * Signature: (I)V
  */
diff --git a/gdx/jni/android/AndroidGL20.h b/gdx/jni/android/AndroidGL20.h
index 787d7bb..2a5b3d6 100644
--- a/gdx/jni/android/AndroidGL20.h
+++ b/gdx/jni/android/AndroidGL20.h
@@ -249,14 +249,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glDeleteBuffer
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDeleteBuffer
-  (JNIEnv *, jobject, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glDeleteFramebuffers
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -265,14 +257,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glDeleteFramebuffer
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDeleteFramebuffer
-  (JNIEnv *, jobject, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glDeleteProgram
  * Signature: (I)V
  */
@@ -289,14 +273,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glDeleteRenderbuffer
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDeleteRenderbuffer
-  (JNIEnv *, jobject, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glDeleteShader
  * Signature: (I)V
  */
@@ -313,14 +289,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glDeleteTexture
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glDeleteTexture
-  (JNIEnv *, jobject, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glDepthFunc
  * Signature: (I)V
  */
@@ -457,14 +425,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenB
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glGenBuffer
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenBuffer
-  (JNIEnv *, jobject);
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glGenerateMipmap
  * Signature: (I)V
  */
@@ -481,14 +441,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenF
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glGenFramebuffer
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenFramebuffer
-  (JNIEnv *, jobject);
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glGenRenderbuffers
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -497,14 +449,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenR
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glGenRenderbuffer
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenRenderbuffer
-  (JNIEnv *, jobject);
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glGenTextures
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -513,14 +457,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenT
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glGenTexture
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glGenTexture
-  (JNIEnv *, jobject);
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glGetActiveAttrib
  * Signature: (IILjava/nio/IntBuffer;Ljava/nio/Buffer;)Ljava/lang/String;
  */
@@ -988,19 +924,11 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform1fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1fv__IILjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1fv
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glUniform1fv
- * Signature: (II[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1fv__II_3FI
-  (JNIEnv *, jobject, jint, jint, jfloatArray, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform1i
  * Signature: (II)V
  */
@@ -1012,19 +940,11 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform1iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1iv__IILjava_nio_IntBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1iv
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glUniform1iv
- * Signature: (II[II)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform1iv__II_3II
-  (JNIEnv *, jobject, jint, jint, jintArray, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform2f
  * Signature: (IFF)V
  */
@@ -1036,19 +956,11 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform2fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2fv__IILjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2fv
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glUniform2fv
- * Signature: (II[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2fv__II_3FI
-  (JNIEnv *, jobject, jint, jint, jfloatArray, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform2i
  * Signature: (III)V
  */
@@ -1060,19 +972,11 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform2iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2iv__IILjava_nio_IntBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2iv
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glUniform2iv
- * Signature: (II[II)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform2iv__II_3II
-  (JNIEnv *, jobject, jint, jint, jintArray, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform3f
  * Signature: (IFFF)V
  */
@@ -1084,19 +988,11 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform3fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3fv__IILjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3fv
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glUniform3fv
- * Signature: (II[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3fv__II_3FI
-  (JNIEnv *, jobject, jint, jint, jfloatArray, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform3i
  * Signature: (IIII)V
  */
@@ -1108,19 +1004,11 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform3iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3iv__IILjava_nio_IntBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3iv
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glUniform3iv
- * Signature: (II[II)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform3iv__II_3II
-  (JNIEnv *, jobject, jint, jint, jintArray, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform4f
  * Signature: (IFFFF)V
  */
@@ -1132,19 +1020,11 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform4fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4fv__IILjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4fv
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glUniform4fv
- * Signature: (II[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4fv__II_3FI
-  (JNIEnv *, jobject, jint, jint, jfloatArray, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniform4i
  * Signature: (IIIII)V
  */
@@ -1156,67 +1036,35 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUnif
  * Method:    glUniform4iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4iv__IILjava_nio_IntBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4iv
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glUniform4iv
- * Signature: (II[II)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniform4iv__II_3II
-  (JNIEnv *, jobject, jint, jint, jintArray, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniformMatrix2fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix2fv__IIZLjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix2fv
   (JNIEnv *, jobject, jint, jint, jboolean, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glUniformMatrix2fv
- * Signature: (IIZ[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix2fv__IIZ_3FI
-  (JNIEnv *, jobject, jint, jint, jboolean, jfloatArray, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniformMatrix3fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix3fv__IIZLjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix3fv
   (JNIEnv *, jobject, jint, jint, jboolean, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glUniformMatrix3fv
- * Signature: (IIZ[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix3fv__IIZ_3FI
-  (JNIEnv *, jobject, jint, jint, jboolean, jfloatArray, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUniformMatrix4fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix4fv__IIZLjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix4fv
   (JNIEnv *, jobject, jint, jint, jboolean, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_android_AndroidGL20
- * Method:    glUniformMatrix4fv
- * Signature: (IIZ[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_android_AndroidGL20_glUniformMatrix4fv__IIZ_3FI
-  (JNIEnv *, jobject, jint, jint, jboolean, jfloatArray, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_android_AndroidGL20
  * Method:    glUseProgram
  * Signature: (I)V
  */
diff --git a/gdx/jni/build-ios32.xml b/gdx/jni/build-ios32.xml
index 13fb8d2..1377047 100755
--- a/gdx/jni/build-ios32.xml
+++ b/gdx/jni/build-ios32.xml
@@ -71,7 +71,7 @@
 				<exclude name="*.o"/>
 			</fileset>
 		</delete>
-	</target>		
+	</target>
 
 	<!-- compiles all C and C++ files to object files in the build directory, for 386 builds-->
 	<target name="compile-386" depends="clean,create-build-dir">
@@ -127,63 +127,8 @@
 	</target>
 	
 	<!-- compiles all C and C++ files to object files in the build directory, for 386 builds-->
-	<target name="compile-x86_64" depends="create-build-dir">
-		<mkdir dir="${buildDir}"/>
-		<antcall target="clean-objfiles"/>
-		<apply failonerror="true" executable="${g++}" dest="${buildDir}" verbose="true">
-			<arg line="-isysroot ${iphonesimulator-sdk} -arch x86_64 ${g++-opts}"/>
-			<arg value="-Ijni-headers"/>
-			<arg value="-Ijni-headers/${jniPlatform}"/>
-			<arg value="-I."/>
-						<arg value="-Iiosgl"/>
-
-			<srcfile/>
-			<arg value="-o"/>
-			<targetfile/>
-			<fileset refid="g++-files"/>
-			<compositemapper>
-				<mapper type="glob" from="*.cpp" to="*.o"/>
-				<mapper type="glob" from="*.mm" to="*.o"/>
-			</compositemapper>
-		</apply>
-		<apply failonerror="true" executable="${gcc}" dest="${buildDir}" verbose="true">
-			<arg line="-isysroot ${iphonesimulator-sdk} -arch x86_64 ${gcc-opts}"/>
-			<arg value="-Ijni-headers"/>
-			<arg value="-Ijni-headers/${jniPlatform}"/>
-			<arg value="-I."/>
-						<arg value="-Iiosgl"/>
-
-			<srcfile/>
-			<arg value="-o"/>
-			<targetfile/>
-			<fileset refid="gcc-files"/>
-			<compositemapper>
-				<mapper type="glob" from="*.c" to="*.o"/>
-			</compositemapper>
-		</apply>
-	</target>	
-
-	<!-- links the shared library based on the previously compiled object files -->
-	<target name="link-x86_64" depends="compile-x86_64">
-		<fileset dir="${buildDir}" id="objFileSet">
-			<patternset>
-				<include name="**/*.o" />
-			</patternset>
-		</fileset>
-		<pathconvert pathsep=" " property="objFiles" refid="objFileSet" />
-		<mkdir dir="${libsDir}" />
-		<exec executable="${linker}" failonerror="true" dir="${buildDir}">
-			<arg line="${linker-opts}" />
-			<arg path="${libsDir}/${libName}.x86_64" />
-			<arg line="${objFiles}"/>
-			<arg line="${libraries}" />
-		</exec>
-	</target>
-	
-	<!-- compiles all C and C++ files to object files in the build directory, for 386 builds-->
-	<target name="compile-arm" depends="create-build-dir">
+	<target name="compile-arm" depends="create-build-dir,clean-objfiles">
 		<mkdir dir="${buildDir}"/>
-		<antcall target="clean-objfiles"/>
 		<apply failonerror="true" executable="${g++}" dest="${buildDir}" verbose="true">
 			<arg line="-isysroot ${iphoneos-sdk} -arch armv7 ${g++-opts}"/>
 			<arg value="-Ijni-headers"/>
@@ -233,68 +178,14 @@
 			<arg line="${libraries}" />
 		</exec>
 	</target>
-	
-		<!-- compiles all C and C++ files to object files in the build directory, for 386 builds-->
-	<target name="compile-arm64" depends="create-build-dir,clean-objfiles">
-		<mkdir dir="${buildDir}"/>
-		<antcall target="clean-objfiles"/>
-		<apply failonerror="true" executable="${g++}" dest="${buildDir}" verbose="true">
-			<arg line="-isysroot ${iphoneos-sdk} -arch arm64 ${g++-opts}"/>
-			<arg value="-Ijni-headers"/>
-			<arg value="-Ijni-headers/${jniPlatform}"/>
-			<arg value="-I."/>
-						<arg value="-Iiosgl"/>
-
-			<srcfile/>
-			<arg value="-o"/>
-			<targetfile/>
-			<fileset refid="g++-files"/>
-			<compositemapper>
-				<mapper type="glob" from="*.cpp" to="*.o"/>
-				<mapper type="glob" from="*.mm" to="*.o"/>
-			</compositemapper>
-		</apply>
-		<apply failonerror="true" executable="${gcc}" dest="${buildDir}" verbose="true">
-			<arg line="-isysroot ${iphoneos-sdk} -arch arm64 ${gcc-opts}"/>
-			<arg value="-Ijni-headers"/>
-			<arg value="-Ijni-headers/${jniPlatform}"/>
-			<arg value="-I."/>
-						<arg value="-Iiosgl"/>
-
-			<srcfile/>
-			<arg value="-o"/>
-			<targetfile/>
-			<fileset refid="gcc-files"/>
-			<compositemapper>
-				<mapper type="glob" from="*.c" to="*.o"/>
-			</compositemapper>
-		</apply>
-	</target>	
-
-	<!-- links the shared library based on the previously compiled object files -->
-	<target name="link-arm64" depends="compile-arm64">
-		<fileset dir="${buildDir}" id="objFileSet">
-			<patternset>
-				<include name="**/*.o" />
-			</patternset>
-		</fileset>
-		<pathconvert pathsep=" " property="objFiles" refid="objFileSet" />
-		<mkdir dir="${libsDir}" />
-		<exec executable="${linker}" failonerror="true" dir="${buildDir}">
-			<arg line="${linker-opts}" />
-			<arg path="${libsDir}/${libName}.arm64" />
-			<arg line="${objFiles}"/>
-			<arg line="${libraries}" />
-		</exec>
-	</target>
 
 	<target name="link-fat">
 		<exec executable="lipo" failonerror="true" dir="${libsDir}">
-			<arg line="-create -output ${libName} ${libName}.386 ${libName}.x86_64 ${libName}.armv7 ${libName}.arm64"/>
+			<arg line="-create -output ${libName} ${libName}.386 ${libName}.armv7"/>
 		</exec>
 	</target>
 
-	<target name="postcompile" depends="link-386,link-x86_64,link-arm,link-arm64,link-fat">
+	<target name="postcompile" depends="link-386,link-arm,link-fat">
 		
 	</target>
 </project>
diff --git a/gdx/jni/com.badlogic.gdx.math.Matrix4.cpp b/gdx/jni/com.badlogic.gdx.math.Matrix4.cpp
index 95312c5..57cfc79 100644
--- a/gdx/jni/com.badlogic.gdx.math.Matrix4.cpp
+++ b/gdx/jni/com.badlogic.gdx.math.Matrix4.cpp
@@ -1,6 +1,6 @@
 #include <com.badlogic.gdx.math.Matrix4.h>
 
-//@line:1152
+//@line:1150
 
 	#include <memory.h>
 	#include <stdio.h>
@@ -145,7 +145,7 @@
 	float* matb = (float*)env->GetPrimitiveArrayCritical(obj_matb, 0);
 
 
-//@line:1298
+//@line:1296
 
 		matrix4_mul(mata, matb);
 	
@@ -159,7 +159,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_math_Matrix4_mulVec___3F_3F(JNIEnv*
 	float* vec = (float*)env->GetPrimitiveArrayCritical(obj_vec, 0);
 
 
-//@line:1308
+//@line:1306
 
 		matrix4_mulVec(mat, vec);
 	
@@ -173,7 +173,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_math_Matrix4_mulVec___3F_3FIII(JNIE
 	float* vecs = (float*)env->GetPrimitiveArrayCritical(obj_vecs, 0);
 
 
-//@line:1323
+//@line:1321
 
 		float* vecPtr = vecs + offset;
 		for(int i = 0; i < numVecs; i++) {
@@ -191,7 +191,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_math_Matrix4_prj___3F_3F(JNIEnv* en
 	float* vec = (float*)env->GetPrimitiveArrayCritical(obj_vec, 0);
 
 
-//@line:1337
+//@line:1335
 
 		matrix4_proj(mat, vec);
 	
@@ -205,7 +205,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_math_Matrix4_prj___3F_3FIII(JNIEnv*
 	float* vecs = (float*)env->GetPrimitiveArrayCritical(obj_vecs, 0);
 
 
-//@line:1352
+//@line:1350
 
 		float* vecPtr = vecs + offset;
 		for(int i = 0; i < numVecs; i++) {
@@ -223,7 +223,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_math_Matrix4_rot___3F_3F(JNIEnv* en
 	float* vec = (float*)env->GetPrimitiveArrayCritical(obj_vec, 0);
 
 
-//@line:1366
+//@line:1364
 
 		matrix4_rot(mat, vec);
 	
@@ -237,7 +237,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_math_Matrix4_rot___3F_3FIII(JNIEnv*
 	float* vecs = (float*)env->GetPrimitiveArrayCritical(obj_vecs, 0);
 
 
-//@line:1381
+//@line:1379
 
 		float* vecPtr = vecs + offset;
 		for(int i = 0; i < numVecs; i++) {
@@ -253,7 +253,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_math_Matrix4_rot___3F_3FIII(JNIEnv*
 static inline jboolean wrapped_Java_com_badlogic_gdx_math_Matrix4_inv
 (JNIEnv* env, jclass clazz, jfloatArray obj_values, float* values) {
 
-//@line:1393
+//@line:1391
 
 		return matrix4_inv(values);
 	
@@ -272,7 +272,7 @@ JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_math_Matrix4_inv(JNIEnv* env, j
 static inline jfloat wrapped_Java_com_badlogic_gdx_math_Matrix4_det
 (JNIEnv* env, jclass clazz, jfloatArray obj_values, float* values) {
 
-//@line:1401
+//@line:1399
 
 		return matrix4_det(values);
 	
diff --git a/gdx/jni/gdx2d/gdx2d.c b/gdx/jni/gdx2d/gdx2d.c
index 13ceba2..b0be774 100644
--- a/gdx/jni/gdx2d/gdx2d.c
+++ b/gdx/jni/gdx2d/gdx2d.c
@@ -12,9 +12,9 @@
  */
 #include "gdx2d.h"
 #include <stdlib.h>
-#define STB_IMAGE_IMPLEMENTATION
+#define STBI_HEADER_FILE_ONLY
 #define STBI_NO_FAILURE_STRINGS
-#include "stb_image.h"
+#include "stb_image.c"
 #include "jpgd_c.h"
 
 static uint32_t gdx2d_blend = GDX2D_BLEND_NONE;
@@ -224,7 +224,7 @@ gdx2d_pixmap* gdx2d_load(const unsigned char *buffer, uint32_t len) {
 	int32_t width, height, format;
     
 	const unsigned char* pixels = stbi_load_from_memory(buffer, len, &width, &height, &format, 0);
-	if (pixels == NULL) {
+	if (pixels == NULL && stbi_unsupported_format() == 1) {
 		pixels = jpgd_decompress_jpeg_image_from_memory(buffer, len, &width, &height, &format, 3);
 	}
 	if (pixels == NULL)
diff --git a/gdx/jni/gdx2d/stb_image.c b/gdx/jni/gdx2d/stb_image.c
new file mode 100644
index 0000000..d3abcd8
--- /dev/null
+++ b/gdx/jni/gdx2d/stb_image.c
@@ -0,0 +1,4686 @@
+/* stbi-1.33 - public domain JPEG/PNG reader - http://nothings.org/stb_image.c
+   when you control the images you're loading
+                                     no warranty implied; use at your own risk
+
+   QUICK NOTES:
+      Primarily of interest to game developers and other people who can
+          avoid problematic images and only need the trivial interface
+
+      JPEG baseline (no JPEG progressive)
+      PNG 8-bit only
+
+      TGA (not sure what subset, if a subset)
+      BMP non-1bpp, non-RLE
+      PSD (composited view only, no extra channels)
+
+      GIF (*comp always reports as 4-channel)
+      HDR (radiance rgbE format)
+      PIC (Softimage PIC)
+
+      - decode from memory or through FILE (define STBI_NO_STDIO to remove code)
+      - decode from arbitrary I/O callbacks
+      - overridable dequantizing-IDCT, YCbCr-to-RGB conversion (define STBI_SIMD)
+
+   Latest revisions:
+      1.33 (2011-07-14) minor fixes suggested by Dave Moore
+      1.32 (2011-07-13) info support for all filetypes (SpartanJ)
+      1.31 (2011-06-19) a few more leak fixes, bug in PNG handling (SpartanJ)
+      1.30 (2011-06-11) added ability to load files via io callbacks (Ben Wenger)
+      1.29 (2010-08-16) various warning fixes from Aurelien Pocheville 
+      1.28 (2010-08-01) fix bug in GIF palette transparency (SpartanJ)
+      1.27 (2010-08-01) cast-to-uint8 to fix warnings (Laurent Gomila)
+                        allow trailing 0s at end of image data (Laurent Gomila)
+      1.26 (2010-07-24) fix bug in file buffering for PNG reported by SpartanJ
+
+   See end of file for full revision history.
+
+   TODO:
+      stbi_info support for BMP,PSD,HDR,PIC
+
+
+ ============================    Contributors    =========================
+              
+ Image formats                                Optimizations & bugfixes
+    Sean Barrett (jpeg, png, bmp)                Fabian "ryg" Giesen
+    Nicolas Schulz (hdr, psd)                                                 
+    Jonathan Dummer (tga)                     Bug fixes & warning fixes           
+    Jean-Marc Lienher (gif)                      Marc LeBlanc               
+    Tom Seddon (pic)                             Christpher Lloyd           
+    Thatcher Ulrich (psd)                        Dave Moore                 
+                                                 Won Chun                   
+                                                 the Horde3D community      
+ Extensions, features                            Janez Zemva                
+    Jetro Lauha (stbi_info)                      Jonathan Blow              
+    James "moose2000" Brown (iPhone PNG)         Laurent Gomila                             
+    Ben "Disch" Wenger (io callbacks)            Aruelien Pocheville
+    Martin "SpartanJ" Golini                     Ryamond Barbiero
+                                                 David Woo
+                                                 
+
+ If your name should be here but isn't, let Sean know.
+
+*/
+
+#ifndef STBI_INCLUDE_STB_IMAGE_H
+#define STBI_INCLUDE_STB_IMAGE_H
+
+// To get a header file for this, either cut and paste the header,
+// or create stb_image.h, #define STBI_HEADER_FILE_ONLY, and
+// then include stb_image.c from it.
+
+////   begin header file  ////////////////////////////////////////////////////
+//
+// Limitations:
+//    - no jpeg progressive support
+//    - non-HDR formats support 8-bit samples only (jpeg, png)
+//    - no delayed line count (jpeg) -- IJG doesn't support either
+//    - no 1-bit BMP
+//    - GIF always returns *comp=4
+//
+// Basic usage (see HDR discussion below):
+//    int x,y,n;
+//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);
+//    // ... process data if not NULL ... 
+//    // ... x = width, y = height, n = # 8-bit components per pixel ...
+//    // ... replace '0' with '1'..'4' to force that many components per pixel
+//    // ... but 'n' will always be the number that it would have been if you said 0
+//    stbi_image_free(data)
+//
+// Standard parameters:
+//    int *x       -- outputs image width in pixels
+//    int *y       -- outputs image height in pixels
+//    int *comp    -- outputs # of image components in image file
+//    int req_comp -- if non-zero, # of image components requested in result
+//
+// The return value from an image loader is an 'unsigned char *' which points
+// to the pixel data. The pixel data consists of *y scanlines of *x pixels,
+// with each pixel consisting of N interleaved 8-bit components; the first
+// pixel pointed to is top-left-most in the image. There is no padding between
+// image scanlines or between pixels, regardless of format. The number of
+// components N is 'req_comp' if req_comp is non-zero, or *comp otherwise.
+// If req_comp is non-zero, *comp has the number of components that _would_
+// have been output otherwise. E.g. if you set req_comp to 4, you will always
+// get RGBA output, but you can check *comp to easily see if it's opaque.
+//
+// An output image with N components has the following components interleaved
+// in this order in each pixel:
+//
+//     N=#comp     components
+//       1           grey
+//       2           grey, alpha
+//       3           red, green, blue
+//       4           red, green, blue, alpha
+//
+// If image loading fails for any reason, the return value will be NULL,
+// and *x, *y, *comp will be unchanged. The function stbi_failure_reason()
+// can be queried for an extremely brief, end-user unfriendly explanation
+// of why the load failed. Define STBI_NO_FAILURE_STRINGS to avoid
+// compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly
+// more user-friendly ones.
+//
+// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.
+//
+// ===========================================================================
+//
+// iPhone PNG support:
+//
+// By default we convert iphone-formatted PNGs back to RGB; nominally they
+// would silently load as BGR, except the existing code should have just
+// failed on such iPhone PNGs. But you can disable this conversion by
+// by calling stbi_convert_iphone_png_to_rgb(0), in which case
+// you will always just get the native iphone "format" through.
+//
+// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per
+// pixel to remove any premultiplied alpha *only* if the image file explicitly
+// says there's premultiplied data (currently only happens in iPhone images,
+// and only if iPhone convert-to-rgb processing is on).
+//
+// ===========================================================================
+//
+// HDR image support   (disable by defining STBI_NO_HDR)
+//
+// stb_image now supports loading HDR images in general, and currently
+// the Radiance .HDR file format, although the support is provided
+// generically. You can still load any file through the existing interface;
+// if you attempt to load an HDR file, it will be automatically remapped to
+// LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;
+// both of these constants can be reconfigured through this interface:
+//
+//     stbi_hdr_to_ldr_gamma(2.2f);
+//     stbi_hdr_to_ldr_scale(1.0f);
+//
+// (note, do not use _inverse_ constants; stbi_image will invert them
+// appropriately).
+//
+// Additionally, there is a new, parallel interface for loading files as
+// (linear) floats to preserve the full dynamic range:
+//
+//    float *data = stbi_loadf(filename, &x, &y, &n, 0);
+// 
+// If you load LDR images through this interface, those images will
+// be promoted to floating point values, run through the inverse of
+// constants corresponding to the above:
+//
+//     stbi_ldr_to_hdr_scale(1.0f);
+//     stbi_ldr_to_hdr_gamma(2.2f);
+//
+// Finally, given a filename (or an open file or memory block--see header
+// file for details) containing image data, you can query for the "most
+// appropriate" interface to use (that is, whether the image is HDR or
+// not), using:
+//
+//     stbi_is_hdr(char *filename);
+//
+// ===========================================================================
+//
+// I/O callbacks
+//
+// I/O callbacks allow you to read from arbitrary sources, like packaged
+// files or some other source. Data read from callbacks are processed
+// through a small internal buffer (currently 128 bytes) to try to reduce
+// overhead. 
+//
+// The three functions you must define are "read" (reads some bytes of data),
+// "skip" (skips some bytes of data), "eof" (reports if the stream is at the end).
+
+
+#ifndef STBI_NO_STDIO
+
+#if defined(_MSC_VER) && _MSC_VER >= 0x1400
+#define _CRT_SECURE_NO_WARNINGS // suppress bogus warnings about fopen()
+#endif
+
+#include <stdio.h>
+#endif
+
+#define STBI_VERSION 1
+
+enum
+{
+   STBI_default = 0, // only used for req_comp
+
+   STBI_grey       = 1,
+   STBI_grey_alpha = 2,
+   STBI_rgb        = 3,
+   STBI_rgb_alpha  = 4
+};
+
+typedef unsigned char stbi_uc;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// PRIMARY API - works on images of any type
+//
+
+//
+// load image by filename, open file, or memory buffer
+//
+
+extern stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
+
+#ifndef STBI_NO_STDIO
+extern stbi_uc *stbi_load            (char const *filename,     int *x, int *y, int *comp, int req_comp);
+extern stbi_uc *stbi_load_from_file  (FILE *f,                  int *x, int *y, int *comp, int req_comp);
+// for stbi_load_from_file, file pointer is left pointing immediately after image
+#endif
+
+typedef struct
+{
+   int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read 
+   void     (*skip)  (void *user,unsigned n);            // skip the next 'n' bytes
+   int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data
+} stbi_io_callbacks;
+
+extern stbi_uc *stbi_load_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp);
+
+#ifndef STBI_NO_HDR
+   extern float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
+
+   #ifndef STBI_NO_STDIO
+   extern float *stbi_loadf            (char const *filename,   int *x, int *y, int *comp, int req_comp);
+   extern float *stbi_loadf_from_file  (FILE *f,                int *x, int *y, int *comp, int req_comp);
+   #endif
+   
+   extern float *stbi_loadf_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp);
+
+   extern void   stbi_hdr_to_ldr_gamma(float gamma);
+   extern void   stbi_hdr_to_ldr_scale(float scale);
+
+   extern void   stbi_ldr_to_hdr_gamma(float gamma);
+   extern void   stbi_ldr_to_hdr_scale(float scale);
+#endif // STBI_NO_HDR
+
+// stbi_is_hdr is always defined
+extern int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);
+extern int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);
+#ifndef STBI_NO_STDIO
+extern int      stbi_is_hdr          (char const *filename);
+extern int      stbi_is_hdr_from_file(FILE *f);
+#endif // STBI_NO_STDIO
+
+
+// get a VERY brief reason for failure
+// NOT THREADSAFE
+extern const char *stbi_failure_reason  (void); 
+
+// if stb_image fails because of an unsupported format, this will return which format
+extern int stbi_unsupported_format (void);
+
+// free the loaded image -- this is just free()
+extern void     stbi_image_free      (void *retval_from_stbi_load);
+
+// get image dimensions & components without fully decoding
+extern int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
+extern int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);
+
+#ifndef STBI_NO_STDIO
+extern int      stbi_info            (char const *filename,     int *x, int *y, int *comp);
+extern int      stbi_info_from_file  (FILE *f,                  int *x, int *y, int *comp);
+
+#endif
+
+
+
+// for image formats that explicitly notate that they have premultiplied alpha,
+// we just return the colors as stored in the file. set this flag to force
+// unpremultiplication. results are undefined if the unpremultiply overflow.
+extern void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);
+
+// indicate whether we should process iphone images back to canonical format,
+// or just pass them through "as-is"
+extern void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);
+
+
+// ZLIB client - used by PNG, available for other purposes
+
+extern char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
+extern char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
+extern int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);
+
+extern char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);
+extern int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);
+
+
+// define faster low-level operations (typically SIMD support)
+#ifdef STBI_SIMD
+typedef void (*stbi_idct_8x8)(stbi_uc *out, int out_stride, short data[64], unsigned short *dequantize);
+// compute an integer IDCT on "input"
+//     input[x] = data[x] * dequantize[x]
+//     write results to 'out': 64 samples, each run of 8 spaced by 'out_stride'
+//                             CLAMP results to 0..255
+typedef void (*stbi_YCbCr_to_RGB_run)(stbi_uc *output, stbi_uc const  *y, stbi_uc const *cb, stbi_uc const *cr, int count, int step);
+// compute a conversion from YCbCr to RGB
+//     'count' pixels
+//     write pixels to 'output'; each pixel is 'step' bytes (either 3 or 4; if 4, write '255' as 4th), order R,G,B
+//     y: Y input channel
+//     cb: Cb input channel; scale/biased to be 0..255
+//     cr: Cr input channel; scale/biased to be 0..255
+
+extern void stbi_install_idct(stbi_idct_8x8 func);
+extern void stbi_install_YCbCr_to_RGB(stbi_YCbCr_to_RGB_run func);
+#endif // STBI_SIMD
+
+
+#ifdef __cplusplus
+}
+#endif
+
+//
+//
+////   end header file   /////////////////////////////////////////////////////
+#endif // STBI_INCLUDE_STB_IMAGE_H
+
+#ifndef STBI_HEADER_FILE_ONLY
+
+#ifndef STBI_NO_HDR
+#include <math.h>  // ldexp
+#include <string.h> // strcmp, strtok
+#endif
+
+#ifndef STBI_NO_STDIO
+#include <stdio.h>
+#endif
+#include <stdlib.h>
+#include <memory.h>
+#include <assert.h>
+#include <stdarg.h>
+
+#ifndef _MSC_VER
+   #ifdef __cplusplus
+   #define stbi_inline inline
+   #else
+   #define stbi_inline
+   #endif
+#else
+   #define stbi_inline __forceinline
+#endif
+
+
+// implementation:
+typedef unsigned char  uint8;
+typedef unsigned short uint16;
+typedef   signed short  int16;
+typedef unsigned int   uint32;
+typedef   signed int    int32;
+//typedef unsigned int   uint;
+
+// should produce compiler error if size is wrong
+typedef unsigned char validate_uint32[sizeof(uint32)==4 ? 1 : -1];
+
+#if defined(STBI_NO_STDIO) && !defined(STBI_NO_WRITE)
+#define STBI_NO_WRITE
+#endif
+
+#define STBI_NOTUSED(v)  (void)sizeof(v)
+
+#ifdef _MSC_VER
+#define STBI_HAS_LROTL
+#endif
+
+#ifdef STBI_HAS_LROTL
+   #define stbi_lrot(x,y)  _lrotl(x,y)
+#else
+   #define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (32 - (y))))
+#endif
+
+///////////////////////////////////////////////
+//
+//  stbi struct and start_xxx functions
+
+// stbi structure is our basic context used by all images, so it
+// contains all the IO context, plus some basic image information
+typedef struct
+{
+   uint32 img_x, img_y;
+   int img_n, img_out_n;
+   
+   stbi_io_callbacks io;
+   void *io_user_data;
+
+   int read_from_callbacks;
+   int buflen;
+   uint8 buffer_start[128];
+
+   uint8 *img_buffer, *img_buffer_end;
+   uint8 *img_buffer_original;
+} stbi;
+
+
+static void refill_buffer(stbi *s);
+
+// initialize a memory-decode context
+static void start_mem(stbi *s, uint8 const *buffer, int len)
+{
+   s->io.read = NULL;
+   s->read_from_callbacks = 0;
+   s->img_buffer = s->img_buffer_original = (uint8 *) buffer;
+   s->img_buffer_end = (uint8 *) buffer+len;
+}
+
+// initialize a callback-based context
+static void start_callbacks(stbi *s, stbi_io_callbacks *c, void *user)
+{
+   s->io = *c;
+   s->io_user_data = user;
+   s->buflen = sizeof(s->buffer_start);
+   s->read_from_callbacks = 1;
+   s->img_buffer_original = s->buffer_start;
+   refill_buffer(s);
+}
+
+#ifndef STBI_NO_STDIO
+
+static int stdio_read(void *user, char *data, int size)
+{
+   return (int) fread(data,1,size,(FILE*) user);
+}
+
+static void stdio_skip(void *user, unsigned n)
+{
+   fseek((FILE*) user, n, SEEK_CUR);
+}
+
+static int stdio_eof(void *user)
+{
+   return feof((FILE*) user);
+}
+
+static stbi_io_callbacks stbi_stdio_callbacks =
+{
+   stdio_read,
+   stdio_skip,
+   stdio_eof,
+};
+
+static void start_file(stbi *s, FILE *f)
+{
+   start_callbacks(s, &stbi_stdio_callbacks, (void *) f);
+}
+
+//static void stop_file(stbi *s) { }
+
+#endif // !STBI_NO_STDIO
+
+static void stbi_rewind(stbi *s)
+{
+   // conceptually rewind SHOULD rewind to the beginning of the stream,
+   // but we just rewind to the beginning of the initial buffer, because
+   // we only use it after doing 'test', which only ever looks at at most 92 bytes
+   s->img_buffer = s->img_buffer_original;
+}
+
+static int      stbi_jpeg_test(stbi *s);
+static stbi_uc *stbi_jpeg_load(stbi *s, int *x, int *y, int *comp, int req_comp);
+static int      stbi_jpeg_info(stbi *s, int *x, int *y, int *comp);
+static int      stbi_png_test(stbi *s);
+static stbi_uc *stbi_png_load(stbi *s, int *x, int *y, int *comp, int req_comp);
+static int      stbi_png_info(stbi *s, int *x, int *y, int *comp);
+static int      stbi_bmp_test(stbi *s);
+static stbi_uc *stbi_bmp_load(stbi *s, int *x, int *y, int *comp, int req_comp);
+static int      stbi_tga_test(stbi *s);
+static stbi_uc *stbi_tga_load(stbi *s, int *x, int *y, int *comp, int req_comp);
+static int      stbi_tga_info(stbi *s, int *x, int *y, int *comp);
+static int      stbi_psd_test(stbi *s);
+static stbi_uc *stbi_psd_load(stbi *s, int *x, int *y, int *comp, int req_comp);
+static int      stbi_hdr_test(stbi *s);
+static float   *stbi_hdr_load(stbi *s, int *x, int *y, int *comp, int req_comp);
+static int      stbi_pic_test(stbi *s);
+static stbi_uc *stbi_pic_load(stbi *s, int *x, int *y, int *comp, int req_comp);
+static int      stbi_gif_test(stbi *s);
+static stbi_uc *stbi_gif_load(stbi *s, int *x, int *y, int *comp, int req_comp);
+static int      stbi_gif_info(stbi *s, int *x, int *y, int *comp);
+
+
+// this is not threadsafe
+static const char *failure_reason;
+
+const char *stbi_failure_reason(void)
+{
+   return failure_reason;
+}
+
+#define FORMAT_PROGRESSIVE_JPEG 1
+
+static int unsupported_format;
+
+int stbi_unsupported_format(void)
+{
+	return unsupported_format;
+}
+
+static int e(const char *str)
+{
+   failure_reason = str;
+   return 0;
+}
+
+// e - error
+// epf - error returning pointer to float
+// epuc - error returning pointer to unsigned char
+
+#ifdef STBI_NO_FAILURE_STRINGS
+   #define e(x,y)  0
+#elif defined(STBI_FAILURE_USERMSG)
+   #define e(x,y)  e(y)
+#else
+   #define e(x,y)  e(x)
+#endif
+
+#define epf(x,y)   ((float *) (e(x,y)?NULL:NULL))
+#define epuc(x,y)  ((unsigned char *) (e(x,y)?NULL:NULL))
+
+void stbi_image_free(void *retval_from_stbi_load)
+{
+   free(retval_from_stbi_load);
+}
+
+#ifndef STBI_NO_HDR
+static float   *ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
+static stbi_uc *hdr_to_ldr(float   *data, int x, int y, int comp);
+#endif
+
+static unsigned char *stbi_load_main(stbi *s, int *x, int *y, int *comp, int req_comp)
+{
+   if (stbi_jpeg_test(s)) return stbi_jpeg_load(s,x,y,comp,req_comp);
+   if (stbi_png_test(s))  return stbi_png_load(s,x,y,comp,req_comp);
+   if (stbi_bmp_test(s))  return stbi_bmp_load(s,x,y,comp,req_comp);
+   if (stbi_gif_test(s))  return stbi_gif_load(s,x,y,comp,req_comp);
+   if (stbi_psd_test(s))  return stbi_psd_load(s,x,y,comp,req_comp);
+   if (stbi_pic_test(s))  return stbi_pic_load(s,x,y,comp,req_comp);
+
+   #ifndef STBI_NO_HDR
+   if (stbi_hdr_test(s)) {
+      float *hdr = stbi_hdr_load(s, x,y,comp,req_comp);
+      return hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
+   }
+   #endif
+
+   // test tga last because it's a crappy test!
+   if (stbi_tga_test(s))
+      return stbi_tga_load(s,x,y,comp,req_comp);
+   return epuc("unknown image type", "Image not of any known type, or corrupt");
+}
+
+#ifndef STBI_NO_STDIO
+unsigned char *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
+{
+   FILE *f = fopen(filename, "rb");
+   unsigned char *result;
+   if (!f) return epuc("can't fopen", "Unable to open file");
+   result = stbi_load_from_file(f,x,y,comp,req_comp);
+   fclose(f);
+   return result;
+}
+
+unsigned char *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
+{
+   stbi s;
+   start_file(&s,f);
+   return stbi_load_main(&s,x,y,comp,req_comp);
+}
+#endif //!STBI_NO_STDIO
+
+unsigned char *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
+{
+   stbi s;
+   start_mem(&s,buffer,len);
+   return stbi_load_main(&s,x,y,comp,req_comp);
+}
+
+unsigned char *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
+{
+   stbi s;
+   start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
+   return stbi_load_main(&s,x,y,comp,req_comp);
+}
+
+#ifndef STBI_NO_HDR
+
+float *stbi_loadf_main(stbi *s, int *x, int *y, int *comp, int req_comp)
+{
+   unsigned char *data;
+   #ifndef STBI_NO_HDR
+   if (stbi_hdr_test(s))
+      return stbi_hdr_load(s,x,y,comp,req_comp);
+   #endif
+   data = stbi_load_main(s, x, y, comp, req_comp);
+   if (data)
+      return ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
+   return epf("unknown image type", "Image not of any known type, or corrupt");
+}
+
+float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
+{
+   stbi s;
+   start_mem(&s,buffer,len);
+   return stbi_loadf_main(&s,x,y,comp,req_comp);
+}
+
+float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
+{
+   stbi s;
+   start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
+   return stbi_loadf_main(&s,x,y,comp,req_comp);
+}
+
+#ifndef STBI_NO_STDIO
+float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
+{
+   FILE *f = fopen(filename, "rb");
+   float *result;
+   if (!f) return epf("can't fopen", "Unable to open file");
+   result = stbi_loadf_from_file(f,x,y,comp,req_comp);
+   fclose(f);
+   return result;
+}
+
+float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
+{
+   stbi s;
+   start_file(&s,f);
+   return stbi_loadf_main(&s,x,y,comp,req_comp);
+}
+#endif // !STBI_NO_STDIO
+
+#endif // !STBI_NO_HDR
+
+// these is-hdr-or-not is defined independent of whether STBI_NO_HDR is
+// defined, for API simplicity; if STBI_NO_HDR is defined, it always
+// reports false!
+
+int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
+{
+   #ifndef STBI_NO_HDR
+   stbi s;
+   start_mem(&s,buffer,len);
+   return stbi_hdr_test(&s);
+   #else
+   STBI_NOTUSED(buffer);
+   STBI_NOTUSED(len);
+   return 0;
+   #endif
+}
+
+#ifndef STBI_NO_STDIO
+extern int      stbi_is_hdr          (char const *filename)
+{
+   FILE *f = fopen(filename, "rb");
+   int result=0;
+   if (f) {
+      result = stbi_is_hdr_from_file(f);
+      fclose(f);
+   }
+   return result;
+}
+
+extern int      stbi_is_hdr_from_file(FILE *f)
+{
+   #ifndef STBI_NO_HDR
+   stbi s;
+   start_file(&s,f);
+   return stbi_hdr_test(&s);
+   #else
+   return 0;
+   #endif
+}
+#endif // !STBI_NO_STDIO
+
+extern int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
+{
+   #ifndef STBI_NO_HDR
+   stbi s;
+   start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
+   return stbi_hdr_test(&s);
+   #else
+   return 0;
+   #endif
+}
+
+#ifndef STBI_NO_HDR
+static float h2l_gamma_i=1.0f/2.2f, h2l_scale_i=1.0f;
+static float l2h_gamma=2.2f, l2h_scale=1.0f;
+
+void   stbi_hdr_to_ldr_gamma(float gamma) { h2l_gamma_i = 1/gamma; }
+void   stbi_hdr_to_ldr_scale(float scale) { h2l_scale_i = 1/scale; }
+
+void   stbi_ldr_to_hdr_gamma(float gamma) { l2h_gamma = gamma; }
+void   stbi_ldr_to_hdr_scale(float scale) { l2h_scale = scale; }
+#endif
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// Common code used by all image loaders
+//
+
+enum
+{
+   SCAN_load=0,
+   SCAN_type,
+   SCAN_header
+};
+
+static void refill_buffer(stbi *s)
+{
+   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
+   if (n == 0) {
+      // at end of file, treat same as if from memory
+      s->read_from_callbacks = 0;
+      s->img_buffer = s->img_buffer_end-1;
+      *s->img_buffer = 0;
+   } else {
+      s->img_buffer = s->buffer_start;
+      s->img_buffer_end = s->buffer_start + n;
+   }
+}
+
+stbi_inline static int get8(stbi *s)
+{
+   if (s->img_buffer < s->img_buffer_end)
+      return *s->img_buffer++;
+   if (s->read_from_callbacks) {
+      refill_buffer(s);
+      return *s->img_buffer++;
+   }
+   return 0;
+}
+
+stbi_inline static int at_eof(stbi *s)
+{
+   if (s->io.read) {
+      if (!(s->io.eof)(s->io_user_data)) return 0;
+      // if feof() is true, check if buffer = end
+      // special case: we've only got the special 0 character at the end
+      if (s->read_from_callbacks == 0) return 1;
+   }
+
+   return s->img_buffer >= s->img_buffer_end;   
+}
+
+stbi_inline static uint8 get8u(stbi *s)
+{
+   return (uint8) get8(s);
+}
+
+static void skip(stbi *s, int n)
+{
+   if (s->io.read) {
+      int blen = s->img_buffer_end - s->img_buffer;
+      if (blen < n) {
+         s->img_buffer = s->img_buffer_end;
+         (s->io.skip)(s->io_user_data, n - blen);
+         return;
+      }
+   }
+   s->img_buffer += n;
+}
+
+static int getn(stbi *s, stbi_uc *buffer, int n)
+{
+   if (s->io.read) {
+      int blen = s->img_buffer_end - s->img_buffer;
+      if (blen < n) {
+         int res, count;
+
+         memcpy(buffer, s->img_buffer, blen);
+         
+         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
+         res = (count == (n-blen));
+         s->img_buffer = s->img_buffer_end;
+         return res;
+      }
+   }
+
+   if (s->img_buffer+n <= s->img_buffer_end) {
+      memcpy(buffer, s->img_buffer, n);
+      s->img_buffer += n;
+      return 1;
+   } else
+      return 0;
+}
+
+static int get16(stbi *s)
+{
+   int z = get8(s);
+   return (z << 8) + get8(s);
+}
+
+static uint32 get32(stbi *s)
+{
+   uint32 z = get16(s);
+   return (z << 16) + get16(s);
+}
+
+static int get16le(stbi *s)
+{
+   int z = get8(s);
+   return z + (get8(s) << 8);
+}
+
+static uint32 get32le(stbi *s)
+{
+   uint32 z = get16le(s);
+   return z + (get16le(s) << 16);
+}
+
+//////////////////////////////////////////////////////////////////////////////
+//
+//  generic converter from built-in img_n to req_comp
+//    individual types do this automatically as much as possible (e.g. jpeg
+//    does all cases internally since it needs to colorspace convert anyway,
+//    and it never has alpha, so very few cases ). png can automatically
+//    interleave an alpha=255 channel, but falls back to this for other cases
+//
+//  assume data buffer is malloced, so malloc a new one and free that one
+//  only failure mode is malloc failing
+
+static uint8 compute_y(int r, int g, int b)
+{
+   return (uint8) (((r*77) + (g*150) +  (29*b)) >> 8);
+}
+
+static unsigned char *convert_format(unsigned char *data, int img_n, int req_comp, uint32 x, uint32 y)
+{
+   int i,j;
+   unsigned char *good;
+
+   if (req_comp == img_n) return data;
+   assert(req_comp >= 1 && req_comp <= 4);
+
+   good = (unsigned char *) malloc(req_comp * x * y);
+   if (good == NULL) {
+      free(data);
+      return epuc("outofmem", "Out of memory");
+   }
+
+   for (j=0; j < (int) y; ++j) {
+      unsigned char *src  = data + j * x * img_n   ;
+      unsigned char *dest = good + j * x * req_comp;
+
+      #define COMBO(a,b)  ((a)*8+(b))
+      #define CASE(a,b)   case COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
+      // convert source image with img_n components to one with req_comp components;
+      // avoid switch per pixel, so use switch per scanline and massive macros
+      switch (COMBO(img_n, req_comp)) {
+         CASE(1,2) dest[0]=src[0], dest[1]=255; break;
+         CASE(1,3) dest[0]=dest[1]=dest[2]=src[0]; break;
+         CASE(1,4) dest[0]=dest[1]=dest[2]=src[0], dest[3]=255; break;
+         CASE(2,1) dest[0]=src[0]; break;
+         CASE(2,3) dest[0]=dest[1]=dest[2]=src[0]; break;
+         CASE(2,4) dest[0]=dest[1]=dest[2]=src[0], dest[3]=src[1]; break;
+         CASE(3,4) dest[0]=src[0],dest[1]=src[1],dest[2]=src[2],dest[3]=255; break;
+         CASE(3,1) dest[0]=compute_y(src[0],src[1],src[2]); break;
+         CASE(3,2) dest[0]=compute_y(src[0],src[1],src[2]), dest[1] = 255; break;
+         CASE(4,1) dest[0]=compute_y(src[0],src[1],src[2]); break;
+         CASE(4,2) dest[0]=compute_y(src[0],src[1],src[2]), dest[1] = src[3]; break;
+         CASE(4,3) dest[0]=src[0],dest[1]=src[1],dest[2]=src[2]; break;
+         default: assert(0);
+      }
+      #undef CASE
+   }
+
+   free(data);
+   return good;
+}
+
+#ifndef STBI_NO_HDR
+static float   *ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
+{
+   int i,k,n;
+   float *output = (float *) malloc(x * y * comp * sizeof(float));
+   if (output == NULL) { free(data); return epf("outofmem", "Out of memory"); }
+   // compute number of non-alpha components
+   if (comp & 1) n = comp; else n = comp-1;
+   for (i=0; i < x*y; ++i) {
+      for (k=0; k < n; ++k) {
+         output[i*comp + k] = (float) pow(data[i*comp+k]/255.0f, l2h_gamma) * l2h_scale;
+      }
+      if (k < comp) output[i*comp + k] = data[i*comp+k]/255.0f;
+   }
+   free(data);
+   return output;
+}
+
+#define float2int(x)   ((int) (x))
+static stbi_uc *hdr_to_ldr(float   *data, int x, int y, int comp)
+{
+   int i,k,n;
+   stbi_uc *output = (stbi_uc *) malloc(x * y * comp);
+   if (output == NULL) { free(data); return epuc("outofmem", "Out of memory"); }
+   // compute number of non-alpha components
+   if (comp & 1) n = comp; else n = comp-1;
+   for (i=0; i < x*y; ++i) {
+      for (k=0; k < n; ++k) {
+         float z = (float) pow(data[i*comp+k]*h2l_scale_i, h2l_gamma_i) * 255 + 0.5f;
+         if (z < 0) z = 0;
+         if (z > 255) z = 255;
+         output[i*comp + k] = (uint8) float2int(z);
+      }
+      if (k < comp) {
+         float z = data[i*comp+k] * 255 + 0.5f;
+         if (z < 0) z = 0;
+         if (z > 255) z = 255;
+         output[i*comp + k] = (uint8) float2int(z);
+      }
+   }
+   free(data);
+   return output;
+}
+#endif
+
+//////////////////////////////////////////////////////////////////////////////
+//
+//  "baseline" JPEG/JFIF decoder (not actually fully baseline implementation)
+//
+//    simple implementation
+//      - channel subsampling of at most 2 in each dimension
+//      - doesn't support delayed output of y-dimension
+//      - simple interface (only one output format: 8-bit interleaved RGB)
+//      - doesn't try to recover corrupt jpegs
+//      - doesn't allow partial loading, loading multiple at once
+//      - still fast on x86 (copying globals into locals doesn't help x86)
+//      - allocates lots of intermediate memory (full size of all components)
+//        - non-interleaved case requires this anyway
+//        - allows good upsampling (see next)
+//    high-quality
+//      - upsampled channels are bilinearly interpolated, even across blocks
+//      - quality integer IDCT derived from IJG's 'slow'
+//    performance
+//      - fast huffman; reasonable integer IDCT
+//      - uses a lot of intermediate memory, could cache poorly
+//      - load http://nothings.org/remote/anemones.jpg 3 times on 2.8Ghz P4
+//          stb_jpeg:   1.34 seconds (MSVC6, default release build)
+//          stb_jpeg:   1.06 seconds (MSVC6, processor = Pentium Pro)
+//          IJL11.dll:  1.08 seconds (compiled by intel)
+//          IJG 1998:   0.98 seconds (MSVC6, makefile provided by IJG)
+//          IJG 1998:   0.95 seconds (MSVC6, makefile + proc=PPro)
+
+// huffman decoding acceleration
+#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache
+
+typedef struct
+{
+   uint8  fast[1 << FAST_BITS];
+   // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
+   uint16 code[256];
+   uint8  values[256];
+   uint8  size[257];
+   unsigned int maxcode[18];
+   int    delta[17];   // old 'firstsymbol' - old 'firstcode'
+} huffman;
+
+typedef struct
+{
+   #ifdef STBI_SIMD
+   unsigned short dequant2[4][64];
+   #endif
+   stbi *s;
+   huffman huff_dc[4];
+   huffman huff_ac[4];
+   uint8 dequant[4][64];
+
+// sizes for components, interleaved MCUs
+   int img_h_max, img_v_max;
+   int img_mcu_x, img_mcu_y;
+   int img_mcu_w, img_mcu_h;
+
+// definition of jpeg image component
+   struct
+   {
+      int id;
+      int h,v;
+      int tq;
+      int hd,ha;
+      int dc_pred;
+
+      int x,y,w2,h2;
+      uint8 *data;
+      void *raw_data;
+      uint8 *linebuf;
+   } img_comp[4];
+
+   uint32         code_buffer; // jpeg entropy-coded buffer
+   int            code_bits;   // number of valid bits
+   unsigned char  marker;      // marker seen while filling entropy buffer
+   int            nomore;      // flag if we saw a marker so must stop
+
+   int scan_n, order[4];
+   int restart_interval, todo;
+} jpeg;
+
+static int build_huffman(huffman *h, int *count)
+{
+   int i,j,k=0,code;
+   // build size list for each symbol (from JPEG spec)
+   for (i=0; i < 16; ++i)
+      for (j=0; j < count[i]; ++j)
+         h->size[k++] = (uint8) (i+1);
+   h->size[k] = 0;
+
+   // compute actual symbols (from jpeg spec)
+   code = 0;
+   k = 0;
+   for(j=1; j <= 16; ++j) {
+      // compute delta to add to code to compute symbol id
+      h->delta[j] = k - code;
+      if (h->size[k] == j) {
+         while (h->size[k] == j)
+            h->code[k++] = (uint16) (code++);
+         if (code-1 >= (1 << j)) return e("bad code lengths","Corrupt JPEG");
+      }
+      // compute largest code + 1 for this size, preshifted as needed later
+      h->maxcode[j] = code << (16-j);
+      code <<= 1;
+   }
+   h->maxcode[j] = 0xffffffff;
+
+   // build non-spec acceleration table; 255 is flag for not-accelerated
+   memset(h->fast, 255, 1 << FAST_BITS);
+   for (i=0; i < k; ++i) {
+      int s = h->size[i];
+      if (s <= FAST_BITS) {
+         int c = h->code[i] << (FAST_BITS-s);
+         int m = 1 << (FAST_BITS-s);
+         for (j=0; j < m; ++j) {
+            h->fast[c+j] = (uint8) i;
+         }
+      }
+   }
+   return 1;
+}
+
+static void grow_buffer_unsafe(jpeg *j)
+{
+   do {
+      int b = j->nomore ? 0 : get8(j->s);
+      if (b == 0xff) {
+         int c = get8(j->s);
+         if (c != 0) {
+            j->marker = (unsigned char) c;
+            j->nomore = 1;
+            return;
+         }
+      }
+      j->code_buffer |= b << (24 - j->code_bits);
+      j->code_bits += 8;
+   } while (j->code_bits <= 24);
+}
+
+// (1 << n) - 1
+static uint32 bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};
+
+// decode a jpeg huffman value from the bitstream
+stbi_inline static int decode(jpeg *j, huffman *h)
+{
+   unsigned int temp;
+   int c,k;
+
+   if (j->code_bits < 16) grow_buffer_unsafe(j);
+
+   // look at the top FAST_BITS and determine what symbol ID it is,
+   // if the code is <= FAST_BITS
+   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
+   k = h->fast[c];
+   if (k < 255) {
+      int s = h->size[k];
+      if (s > j->code_bits)
+         return -1;
+      j->code_buffer <<= s;
+      j->code_bits -= s;
+      return h->values[k];
+   }
+
+   // naive test is to shift the code_buffer down so k bits are
+   // valid, then test against maxcode. To speed this up, we've
+   // preshifted maxcode left so that it has (16-k) 0s at the
+   // end; in other words, regardless of the number of bits, it
+   // wants to be compared against something shifted to have 16;
+   // that way we don't need to shift inside the loop.
+   temp = j->code_buffer >> 16;
+   for (k=FAST_BITS+1 ; ; ++k)
+      if (temp < h->maxcode[k])
+         break;
+   if (k == 17) {
+      // error! code not found
+      j->code_bits -= 16;
+      return -1;
+   }
+
+   if (k > j->code_bits)
+      return -1;
+
+   // convert the huffman code to the symbol id
+   c = ((j->code_buffer >> (32 - k)) & bmask[k]) + h->delta[k];
+   assert((((j->code_buffer) >> (32 - h->size[c])) & bmask[h->size[c]]) == h->code[c]);
+
+   // convert the id to a symbol
+   j->code_bits -= k;
+   j->code_buffer <<= k;
+   return h->values[c];
+}
+
+// combined JPEG 'receive' and JPEG 'extend', since baseline
+// always extends everything it receives.
+stbi_inline static int extend_receive(jpeg *j, int n)
+{
+   unsigned int m = 1 << (n-1);
+   unsigned int k;
+   if (j->code_bits < n) grow_buffer_unsafe(j);
+
+   #if 1
+   k = stbi_lrot(j->code_buffer, n);
+   j->code_buffer = k & ~bmask[n];
+   k &= bmask[n];
+   j->code_bits -= n;
+   #else
+   k = (j->code_buffer >> (32 - n)) & bmask[n];
+   j->code_bits -= n;
+   j->code_buffer <<= n;
+   #endif
+   // the following test is probably a random branch that won't
+   // predict well. I tried to table accelerate it but failed.
+   // maybe it's compiling as a conditional move?
+   if (k < m)
+      return (-1 << n) + k + 1;
+   else
+      return k;
+}
+
+// given a value that's at position X in the zigzag stream,
+// where does it appear in the 8x8 matrix coded as row-major?
+static uint8 dezigzag[64+15] =
+{
+    0,  1,  8, 16,  9,  2,  3, 10,
+   17, 24, 32, 25, 18, 11,  4,  5,
+   12, 19, 26, 33, 40, 48, 41, 34,
+   27, 20, 13,  6,  7, 14, 21, 28,
+   35, 42, 49, 56, 57, 50, 43, 36,
+   29, 22, 15, 23, 30, 37, 44, 51,
+   58, 59, 52, 45, 38, 31, 39, 46,
+   53, 60, 61, 54, 47, 55, 62, 63,
+   // let corrupt input sample past end
+   63, 63, 63, 63, 63, 63, 63, 63,
+   63, 63, 63, 63, 63, 63, 63
+};
+
+// decode one 64-entry block--
+static int decode_block(jpeg *j, short data[64], huffman *hdc, huffman *hac, int b)
+{
+   int diff,dc,k;
+   int t = decode(j, hdc);
+   if (t < 0) return e("bad huffman code","Corrupt JPEG");
+
+   // 0 all the ac values now so we can do it 32-bits at a time
+   memset(data,0,64*sizeof(data[0]));
+
+   diff = t ? extend_receive(j, t) : 0;
+   dc = j->img_comp[b].dc_pred + diff;
+   j->img_comp[b].dc_pred = dc;
+   data[0] = (short) dc;
+
+   // decode AC components, see JPEG spec
+   k = 1;
+   do {
+      int r,s;
+      int rs = decode(j, hac);
+      if (rs < 0) return e("bad huffman code","Corrupt JPEG");
+      s = rs & 15;
+      r = rs >> 4;
+      if (s == 0) {
+         if (rs != 0xf0) break; // end block
+         k += 16;
+      } else {
+         k += r;
+         // decode into unzigzag'd location
+         data[dezigzag[k++]] = (short) extend_receive(j,s);
+      }
+   } while (k < 64);
+   return 1;
+}
+
+// take a -128..127 value and clamp it and convert to 0..255
+stbi_inline static uint8 clamp(int x)
+{
+   // trick to use a single test to catch both cases
+   if ((unsigned int) x > 255) {
+      if (x < 0) return 0;
+      if (x > 255) return 255;
+   }
+   return (uint8) x;
+}
+
+#define f2f(x)  (int) (((x) * 4096 + 0.5))
+#define fsh(x)  ((x) << 12)
+
+// derived from jidctint -- DCT_ISLOW
+#define IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7)       \
+   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
+   p2 = s2;                                    \
+   p3 = s6;                                    \
+   p1 = (p2+p3) * f2f(0.5411961f);             \
+   t2 = p1 + p3*f2f(-1.847759065f);            \
+   t3 = p1 + p2*f2f( 0.765366865f);            \
+   p2 = s0;                                    \
+   p3 = s4;                                    \
+   t0 = fsh(p2+p3);                            \
+   t1 = fsh(p2-p3);                            \
+   x0 = t0+t3;                                 \
+   x3 = t0-t3;                                 \
+   x1 = t1+t2;                                 \
+   x2 = t1-t2;                                 \
+   t0 = s7;                                    \
+   t1 = s5;                                    \
+   t2 = s3;                                    \
+   t3 = s1;                                    \
+   p3 = t0+t2;                                 \
+   p4 = t1+t3;                                 \
+   p1 = t0+t3;                                 \
+   p2 = t1+t2;                                 \
+   p5 = (p3+p4)*f2f( 1.175875602f);            \
+   t0 = t0*f2f( 0.298631336f);                 \
+   t1 = t1*f2f( 2.053119869f);                 \
+   t2 = t2*f2f( 3.072711026f);                 \
+   t3 = t3*f2f( 1.501321110f);                 \
+   p1 = p5 + p1*f2f(-0.899976223f);            \
+   p2 = p5 + p2*f2f(-2.562915447f);            \
+   p3 = p3*f2f(-1.961570560f);                 \
+   p4 = p4*f2f(-0.390180644f);                 \
+   t3 += p1+p4;                                \
+   t2 += p2+p3;                                \
+   t1 += p2+p4;                                \
+   t0 += p1+p3;
+
+#ifdef STBI_SIMD
+typedef unsigned short stbi_dequantize_t;
+#else
+typedef uint8 stbi_dequantize_t;
+#endif
+
+// .344 seconds on 3*anemones.jpg
+static void idct_block(uint8 *out, int out_stride, short data[64], stbi_dequantize_t *dequantize)
+{
+   int i,val[64],*v=val;
+   stbi_dequantize_t *dq = dequantize;
+   uint8 *o;
+   short *d = data;
+
+   // columns
+   for (i=0; i < 8; ++i,++d,++dq, ++v) {
+      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
+      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
+           && d[40]==0 && d[48]==0 && d[56]==0) {
+         //    no shortcut                 0     seconds
+         //    (1|2|3|4|5|6|7)==0          0     seconds
+         //    all separate               -0.047 seconds
+         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
+         int dcterm = d[0] * dq[0] << 2;
+         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
+      } else {
+         IDCT_1D(d[ 0]*dq[ 0],d[ 8]*dq[ 8],d[16]*dq[16],d[24]*dq[24],
+                 d[32]*dq[32],d[40]*dq[40],d[48]*dq[48],d[56]*dq[56])
+         // constants scaled things up by 1<<12; let's bring them back
+         // down, but keep 2 extra bits of precision
+         x0 += 512; x1 += 512; x2 += 512; x3 += 512;
+         v[ 0] = (x0+t3) >> 10;
+         v[56] = (x0-t3) >> 10;
+         v[ 8] = (x1+t2) >> 10;
+         v[48] = (x1-t2) >> 10;
+         v[16] = (x2+t1) >> 10;
+         v[40] = (x2-t1) >> 10;
+         v[24] = (x3+t0) >> 10;
+         v[32] = (x3-t0) >> 10;
+      }
+   }
+
+   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
+      // no fast case since the first 1D IDCT spread components out
+      IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
+      // constants scaled things up by 1<<12, plus we had 1<<2 from first
+      // loop, plus horizontal and vertical each scale by sqrt(8) so together
+      // we've got an extra 1<<3, so 1<<17 total we need to remove.
+      // so we want to round that, which means adding 0.5 * 1<<17,
+      // aka 65536. Also, we'll end up with -128 to 127 that we want
+      // to encode as 0..255 by adding 128, so we'll add that before the shift
+      x0 += 65536 + (128<<17);
+      x1 += 65536 + (128<<17);
+      x2 += 65536 + (128<<17);
+      x3 += 65536 + (128<<17);
+      // tried computing the shifts into temps, or'ing the temps to see
+      // if any were out of range, but that was slower
+      o[0] = clamp((x0+t3) >> 17);
+      o[7] = clamp((x0-t3) >> 17);
+      o[1] = clamp((x1+t2) >> 17);
+      o[6] = clamp((x1-t2) >> 17);
+      o[2] = clamp((x2+t1) >> 17);
+      o[5] = clamp((x2-t1) >> 17);
+      o[3] = clamp((x3+t0) >> 17);
+      o[4] = clamp((x3-t0) >> 17);
+   }
+}
+
+#ifdef STBI_SIMD
+static stbi_idct_8x8 stbi_idct_installed = idct_block;
+
+void stbi_install_idct(stbi_idct_8x8 func)
+{
+   stbi_idct_installed = func;
+}
+#endif
+
+#define MARKER_none  0xff
+// if there's a pending marker from the entropy stream, return that
+// otherwise, fetch from the stream and get a marker. if there's no
+// marker, return 0xff, which is never a valid marker value
+static uint8 get_marker(jpeg *j)
+{
+   uint8 x;
+   if (j->marker != MARKER_none) { x = j->marker; j->marker = MARKER_none; return x; }
+   x = get8u(j->s);
+   if (x != 0xff) return MARKER_none;
+   while (x == 0xff)
+      x = get8u(j->s);
+   return x;
+}
+
+// in each scan, we'll have scan_n components, and the order
+// of the components is specified by order[]
+#define RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)
+
+// after a restart interval, reset the entropy decoder and
+// the dc prediction
+static void reset(jpeg *j)
+{
+   j->code_bits = 0;
+   j->code_buffer = 0;
+   j->nomore = 0;
+   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = 0;
+   j->marker = MARKER_none;
+   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
+   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
+   // since we don't even allow 1<<30 pixels
+}
+
+static int parse_entropy_coded_data(jpeg *z)
+{
+   reset(z);
+   if (z->scan_n == 1) {
+      int i,j;
+      #ifdef STBI_SIMD
+      __declspec(align(16))
+      #endif
+      short data[64];
+      int n = z->order[0];
+      // non-interleaved data, we just need to process one block at a time,
+      // in trivial scanline order
+      // number of blocks to do just depends on how many actual "pixels" this
+      // component has, independent of interleaved MCU blocking and such
+      int w = (z->img_comp[n].x+7) >> 3;
+      int h = (z->img_comp[n].y+7) >> 3;
+      for (j=0; j < h; ++j) {
+         for (i=0; i < w; ++i) {
+            if (!decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+z->img_comp[n].ha, n)) return 0;
+            #ifdef STBI_SIMD
+            stbi_idct_installed(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data, z->dequant2[z->img_comp[n].tq]);
+            #else
+            idct_block(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data, z->dequant[z->img_comp[n].tq]);
+            #endif
+            // every data block is an MCU, so countdown the restart interval
+            if (--z->todo <= 0) {
+               if (z->code_bits < 24) grow_buffer_unsafe(z);
+               // if it's NOT a restart, then just bail, so we get corrupt data
+               // rather than no data
+               if (!RESTART(z->marker)) return 1;
+               reset(z);
+            }
+         }
+      }
+   } else { // interleaved!
+      int i,j,k,x,y;
+      short data[64];
+      for (j=0; j < z->img_mcu_y; ++j) {
+         for (i=0; i < z->img_mcu_x; ++i) {
+            // scan an interleaved mcu... process scan_n components in order
+            for (k=0; k < z->scan_n; ++k) {
+               int n = z->order[k];
+               // scan out an mcu's worth of this component; that's just determined
+               // by the basic H and V specified for the component
+               for (y=0; y < z->img_comp[n].v; ++y) {
+                  for (x=0; x < z->img_comp[n].h; ++x) {
+                     int x2 = (i*z->img_comp[n].h + x)*8;
+                     int y2 = (j*z->img_comp[n].v + y)*8;
+                     if (!decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+z->img_comp[n].ha, n)) return 0;
+                     #ifdef STBI_SIMD
+                     stbi_idct_installed(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data, z->dequant2[z->img_comp[n].tq]);
+                     #else
+                     idct_block(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data, z->dequant[z->img_comp[n].tq]);
+                     #endif
+                  }
+               }
+            }
+            // after all interleaved components, that's an interleaved MCU,
+            // so now count down the restart interval
+            if (--z->todo <= 0) {
+               if (z->code_bits < 24) grow_buffer_unsafe(z);
+               // if it's NOT a restart, then just bail, so we get corrupt data
+               // rather than no data
+               if (!RESTART(z->marker)) return 1;
+               reset(z);
+            }
+         }
+      }
+   }
+   return 1;
+}
+
+static int process_marker(jpeg *z, int m)
+{
+   int L;
+   switch (m) {
+      case MARKER_none: // no marker found
+         return e("expected marker","Corrupt JPEG");
+
+      case 0xC2: // SOF - progressive
+         unsupported_format = FORMAT_PROGRESSIVE_JPEG;
+         return e("progressive jpeg","JPEG format not supported (progressive)");
+
+      case 0xDD: // DRI - specify restart interval
+         if (get16(z->s) != 4) return e("bad DRI len","Corrupt JPEG");
+         z->restart_interval = get16(z->s);
+         return 1;
+
+      case 0xDB: // DQT - define quantization table
+         L = get16(z->s)-2;
+         while (L > 0) {
+            int q = get8(z->s);
+            int p = q >> 4;
+            int t = q & 15,i;
+            if (p != 0) return e("bad DQT type","Corrupt JPEG");
+            if (t > 3) return e("bad DQT table","Corrupt JPEG");
+            for (i=0; i < 64; ++i)
+               z->dequant[t][dezigzag[i]] = get8u(z->s);
+            #ifdef STBI_SIMD
+            for (i=0; i < 64; ++i)
+               z->dequant2[t][i] = z->dequant[t][i];
+            #endif
+            L -= 65;
+         }
+         return L==0;
+
+      case 0xC4: // DHT - define huffman table
+         L = get16(z->s)-2;
+         while (L > 0) {
+            uint8 *v;
+            int sizes[16],i,m=0;
+            int q = get8(z->s);
+            int tc = q >> 4;
+            int th = q & 15;
+            if (tc > 1 || th > 3) return e("bad DHT header","Corrupt JPEG");
+            for (i=0; i < 16; ++i) {
+               sizes[i] = get8(z->s);
+               m += sizes[i];
+            }
+            L -= 17;
+            if (tc == 0) {
+               if (!build_huffman(z->huff_dc+th, sizes)) return 0;
+               v = z->huff_dc[th].values;
+            } else {
+               if (!build_huffman(z->huff_ac+th, sizes)) return 0;
+               v = z->huff_ac[th].values;
+            }
+            for (i=0; i < m; ++i)
+               v[i] = get8u(z->s);
+            L -= m;
+         }
+         return L==0;
+   }
+   // check for comment block or APP blocks
+   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
+      skip(z->s, get16(z->s)-2);
+      return 1;
+   }
+   return 0;
+}
+
+// after we see SOS
+static int process_scan_header(jpeg *z)
+{
+   int i;
+   int Ls = get16(z->s);
+   z->scan_n = get8(z->s);
+   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return e("bad SOS component count","Corrupt JPEG");
+   if (Ls != 6+2*z->scan_n) return e("bad SOS len","Corrupt JPEG");
+   for (i=0; i < z->scan_n; ++i) {
+      int id = get8(z->s), which;
+      int q = get8(z->s);
+      for (which = 0; which < z->s->img_n; ++which)
+         if (z->img_comp[which].id == id)
+            break;
+      if (which == z->s->img_n) return 0;
+      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return e("bad DC huff","Corrupt JPEG");
+      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return e("bad AC huff","Corrupt JPEG");
+      z->order[i] = which;
+   }
+   if (get8(z->s) != 0) return e("bad SOS","Corrupt JPEG");
+   get8(z->s); // should be 63, but might be 0
+   if (get8(z->s) != 0) return e("bad SOS","Corrupt JPEG");
+
+   return 1;
+}
+
+static int process_frame_header(jpeg *z, int scan)
+{
+   stbi *s = z->s;
+   int Lf,p,i,q, h_max=1,v_max=1,c;
+   Lf = get16(s);         if (Lf < 11) return e("bad SOF len","Corrupt JPEG"); // JPEG
+   p  = get8(s);          if (p != 8) return e("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
+   s->img_y = get16(s);   if (s->img_y == 0) return e("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
+   s->img_x = get16(s);   if (s->img_x == 0) return e("0 width","Corrupt JPEG"); // JPEG requires
+   c = get8(s);
+   if (c != 3 && c != 1) return e("bad component count","Corrupt JPEG");    // JFIF requires
+   s->img_n = c;
+   for (i=0; i < c; ++i) {
+      z->img_comp[i].data = NULL;
+      z->img_comp[i].linebuf = NULL;
+   }
+
+   if (Lf != 8+3*s->img_n) return e("bad SOF len","Corrupt JPEG");
+
+   for (i=0; i < s->img_n; ++i) {
+      z->img_comp[i].id = get8(s);
+      if (z->img_comp[i].id != i+1)   // JFIF requires
+         if (z->img_comp[i].id != i)  // some version of jpegtran outputs non-JFIF-compliant files!
+            return e("bad component ID","Corrupt JPEG");
+      q = get8(s);
+      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return e("bad H","Corrupt JPEG");
+      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return e("bad V","Corrupt JPEG");
+      z->img_comp[i].tq = get8(s);  if (z->img_comp[i].tq > 3) return e("bad TQ","Corrupt JPEG");
+   }
+
+   if (scan != SCAN_load) return 1;
+
+   if ((1 << 30) / s->img_x / s->img_n < s->img_y) return e("too large", "Image too large to decode");
+
+   for (i=0; i < s->img_n; ++i) {
+      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
+      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
+   }
+
+   // compute interleaved mcu info
+   z->img_h_max = h_max;
+   z->img_v_max = v_max;
+   z->img_mcu_w = h_max * 8;
+   z->img_mcu_h = v_max * 8;
+   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
+   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;
+
+   for (i=0; i < s->img_n; ++i) {
+      // number of effective pixels (e.g. for non-interleaved MCU)
+      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
+      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
+      // to simplify generation, we'll allocate enough memory to decode
+      // the bogus oversized data from using interleaved MCUs and their
+      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
+      // discard the extra data until colorspace conversion
+      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
+      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
+      z->img_comp[i].raw_data = malloc(z->img_comp[i].w2 * z->img_comp[i].h2+15);
+      if (z->img_comp[i].raw_data == NULL) {
+         for(--i; i >= 0; --i) {
+            free(z->img_comp[i].raw_data);
+            z->img_comp[i].data = NULL;
+         }
+         return e("outofmem", "Out of memory");
+      }
+      // align blocks for installable-idct using mmx/sse
+      z->img_comp[i].data = (uint8*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
+      z->img_comp[i].linebuf = NULL;
+   }
+
+   return 1;
+}
+
+// use comparisons since in some cases we handle more than one case (e.g. SOF)
+#define DNL(x)         ((x) == 0xdc)
+#define SOI(x)         ((x) == 0xd8)
+#define EOI(x)         ((x) == 0xd9)
+#define SOF(x)         ((x) == 0xc0 || (x) == 0xc1)
+#define SOS(x)         ((x) == 0xda)
+
+static int decode_jpeg_header(jpeg *z, int scan)
+{
+   int m;
+   z->marker = MARKER_none; // initialize cached marker to empty
+   m = get_marker(z);
+   if (!SOI(m)) return e("no SOI","Corrupt JPEG");
+   if (scan == SCAN_type) return 1;
+   m = get_marker(z);
+   while (!SOF(m)) {
+      if (!process_marker(z,m)) return 0;
+      m = get_marker(z);
+      while (m == MARKER_none) {
+         // some files have extra padding after their blocks, so ok, we'll scan
+         if (at_eof(z->s)) return e("no SOF", "Corrupt JPEG");
+         m = get_marker(z);
+      }
+   }
+   if (!process_frame_header(z, scan)) return 0;
+   return 1;
+}
+
+static int decode_jpeg_image(jpeg *j)
+{
+   int m;
+   j->restart_interval = 0;
+   if (!decode_jpeg_header(j, SCAN_load)) return 0;
+   m = get_marker(j);
+   while (!EOI(m)) {
+      if (SOS(m)) {
+         if (!process_scan_header(j)) return 0;
+         if (!parse_entropy_coded_data(j)) return 0;
+         if (j->marker == MARKER_none ) {
+            // handle 0s at the end of image data from IP Kamera 9060
+            while (!at_eof(j->s)) {
+               int x = get8(j->s);
+               if (x == 255) {
+                  j->marker = get8u(j->s);
+                  break;
+               } else if (x != 0) {
+                  return 0;
+               }
+            }
+            // if we reach eof without hitting a marker, get_marker() below will fail and we'll eventually return 0
+         }
+      } else {
+         if (!process_marker(j, m)) return 0;
+      }
+      m = get_marker(j);
+   }
+   return 1;
+}
+
+// static jfif-centered resampling (across block boundaries)
+
+typedef uint8 *(*resample_row_func)(uint8 *out, uint8 *in0, uint8 *in1,
+                                    int w, int hs);
+
+#define div4(x) ((uint8) ((x) >> 2))
+
+static uint8 *resample_row_1(uint8 *out, uint8 *in_near, uint8 *in_far, int w, int hs)
+{
+   STBI_NOTUSED(out);
+   STBI_NOTUSED(in_far);
+   STBI_NOTUSED(w);
+   STBI_NOTUSED(hs);
+   return in_near;
+}
+
+static uint8* resample_row_v_2(uint8 *out, uint8 *in_near, uint8 *in_far, int w, int hs)
+{
+   // need to generate two samples vertically for every one in input
+   int i;
+   STBI_NOTUSED(hs);
+   for (i=0; i < w; ++i)
+      out[i] = div4(3*in_near[i] + in_far[i] + 2);
+   return out;
+}
+
+static uint8*  resample_row_h_2(uint8 *out, uint8 *in_near, uint8 *in_far, int w, int hs)
+{
+   // need to generate two samples horizontally for every one in input
+   int i;
+   uint8 *input = in_near;
+
+   if (w == 1) {
+      // if only one sample, can't do any interpolation
+      out[0] = out[1] = input[0];
+      return out;
+   }
+
+   out[0] = input[0];
+   out[1] = div4(input[0]*3 + input[1] + 2);
+   for (i=1; i < w-1; ++i) {
+      int n = 3*input[i]+2;
+      out[i*2+0] = div4(n+input[i-1]);
+      out[i*2+1] = div4(n+input[i+1]);
+   }
+   out[i*2+0] = div4(input[w-2]*3 + input[w-1] + 2);
+   out[i*2+1] = input[w-1];
+
+   STBI_NOTUSED(in_far);
+   STBI_NOTUSED(hs);
+
+   return out;
+}
+
+#define div16(x) ((uint8) ((x) >> 4))
+
+static uint8 *resample_row_hv_2(uint8 *out, uint8 *in_near, uint8 *in_far, int w, int hs)
+{
+   // need to generate 2x2 samples for every one in input
+   int i,t0,t1;
+   if (w == 1) {
+      out[0] = out[1] = div4(3*in_near[0] + in_far[0] + 2);
+      return out;
+   }
+
+   t1 = 3*in_near[0] + in_far[0];
+   out[0] = div4(t1+2);
+   for (i=1; i < w; ++i) {
+      t0 = t1;
+      t1 = 3*in_near[i]+in_far[i];
+      out[i*2-1] = div16(3*t0 + t1 + 8);
+      out[i*2  ] = div16(3*t1 + t0 + 8);
+   }
+   out[w*2-1] = div4(t1+2);
+
+   STBI_NOTUSED(hs);
+
+   return out;
+}
+
+static uint8 *resample_row_generic(uint8 *out, uint8 *in_near, uint8 *in_far, int w, int hs)
+{
+   // resample with nearest-neighbor
+   int i,j;
+   in_far = in_far;
+   for (i=0; i < w; ++i)
+      for (j=0; j < hs; ++j)
+         out[i*hs+j] = in_near[i];
+   return out;
+}
+
+#define float2fixed(x)  ((int) ((x) * 65536 + 0.5))
+
+// 0.38 seconds on 3*anemones.jpg   (0.25 with processor = Pro)
+// VC6 without processor=Pro is generating multiple LEAs per multiply!
+static void YCbCr_to_RGB_row(uint8 *out, const uint8 *y, const uint8 *pcb, const uint8 *pcr, int count, int step)
+{
+   int i;
+   for (i=0; i < count; ++i) {
+      int y_fixed = (y[i] << 16) + 32768; // rounding
+      int r,g,b;
+      int cr = pcr[i] - 128;
+      int cb = pcb[i] - 128;
+      r = y_fixed + cr*float2fixed(1.40200f);
+      g = y_fixed - cr*float2fixed(0.71414f) - cb*float2fixed(0.34414f);
+      b = y_fixed                            + cb*float2fixed(1.77200f);
+      r >>= 16;
+      g >>= 16;
+      b >>= 16;
+      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
+      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
+      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
+      out[0] = (uint8)r;
+      out[1] = (uint8)g;
+      out[2] = (uint8)b;
+      out[3] = 255;
+      out += step;
+   }
+}
+
+#ifdef STBI_SIMD
+static stbi_YCbCr_to_RGB_run stbi_YCbCr_installed = YCbCr_to_RGB_row;
+
+void stbi_install_YCbCr_to_RGB(stbi_YCbCr_to_RGB_run func)
+{
+   stbi_YCbCr_installed = func;
+}
+#endif
+
+
+// clean up the temporary component buffers
+static void cleanup_jpeg(jpeg *j)
+{
+   int i;
+   for (i=0; i < j->s->img_n; ++i) {
+      if (j->img_comp[i].data) {
+         free(j->img_comp[i].raw_data);
+         j->img_comp[i].data = NULL;
+      }
+      if (j->img_comp[i].linebuf) {
+         free(j->img_comp[i].linebuf);
+         j->img_comp[i].linebuf = NULL;
+      }
+   }
+}
+
+typedef struct
+{
+   resample_row_func resample;
+   uint8 *line0,*line1;
+   int hs,vs;   // expansion factor in each axis
+   int w_lores; // horizontal pixels pre-expansion 
+   int ystep;   // how far through vertical expansion we are
+   int ypos;    // which pre-expansion row we're on
+} stbi_resample;
+
+static uint8 *load_jpeg_image(jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
+{
+   int n, decode_n;
+   // validate req_comp
+   if (req_comp < 0 || req_comp > 4) return epuc("bad req_comp", "Internal error");
+   z->s->img_n = 0;
+
+   // load a jpeg image from whichever source
+   if (!decode_jpeg_image(z)) { cleanup_jpeg(z); return NULL; }
+
+   // determine actual number of components to generate
+   n = req_comp ? req_comp : z->s->img_n;
+
+   if (z->s->img_n == 3 && n < 3)
+      decode_n = 1;
+   else
+      decode_n = z->s->img_n;
+
+   // resample and color-convert
+   {
+      int k;
+      uint32 i,j;
+      uint8 *output;
+      uint8 *coutput[4];
+
+      stbi_resample res_comp[4];
+
+      for (k=0; k < decode_n; ++k) {
+         stbi_resample *r = &res_comp[k];
+
+         // allocate line buffer big enough for upsampling off the edges
+         // with upsample factor of 4
+         z->img_comp[k].linebuf = (uint8 *) malloc(z->s->img_x + 3);
+         if (!z->img_comp[k].linebuf) { cleanup_jpeg(z); return epuc("outofmem", "Out of memory"); }
+
+         r->hs      = z->img_h_max / z->img_comp[k].h;
+         r->vs      = z->img_v_max / z->img_comp[k].v;
+         r->ystep   = r->vs >> 1;
+         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
+         r->ypos    = 0;
+         r->line0   = r->line1 = z->img_comp[k].data;
+
+         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
+         else if (r->hs == 1 && r->vs == 2) r->resample = resample_row_v_2;
+         else if (r->hs == 2 && r->vs == 1) r->resample = resample_row_h_2;
+         else if (r->hs == 2 && r->vs == 2) r->resample = resample_row_hv_2;
+         else                               r->resample = resample_row_generic;
+      }
+
+      // can't error after this so, this is safe
+      output = (uint8 *) malloc(n * z->s->img_x * z->s->img_y + 1);
+      if (!output) { cleanup_jpeg(z); return epuc("outofmem", "Out of memory"); }
+
+      // now go ahead and resample
+      for (j=0; j < z->s->img_y; ++j) {
+         uint8 *out = output + n * z->s->img_x * j;
+         for (k=0; k < decode_n; ++k) {
+            stbi_resample *r = &res_comp[k];
+            int y_bot = r->ystep >= (r->vs >> 1);
+            coutput[k] = r->resample(z->img_comp[k].linebuf,
+                                     y_bot ? r->line1 : r->line0,
+                                     y_bot ? r->line0 : r->line1,
+                                     r->w_lores, r->hs);
+            if (++r->ystep >= r->vs) {
+               r->ystep = 0;
+               r->line0 = r->line1;
+               if (++r->ypos < z->img_comp[k].y)
+                  r->line1 += z->img_comp[k].w2;
+            }
+         }
+         if (n >= 3) {
+            uint8 *y = coutput[0];
+            if (z->s->img_n == 3) {
+               #ifdef STBI_SIMD
+               stbi_YCbCr_installed(out, y, coutput[1], coutput[2], z->s.img_x, n);
+               #else
+               YCbCr_to_RGB_row(out, y, coutput[1], coutput[2], z->s->img_x, n);
+               #endif
+            } else
+               for (i=0; i < z->s->img_x; ++i) {
+                  out[0] = out[1] = out[2] = y[i];
+                  out[3] = 255; // not used if n==3
+                  out += n;
+               }
+         } else {
+            uint8 *y = coutput[0];
+            if (n == 1)
+               for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
+            else
+               for (i=0; i < z->s->img_x; ++i) *out++ = y[i], *out++ = 255;
+         }
+      }
+      cleanup_jpeg(z);
+      *out_x = z->s->img_x;
+      *out_y = z->s->img_y;
+      if (comp) *comp  = z->s->img_n; // report original components, not output
+      return output;
+   }
+}
+
+static unsigned char *stbi_jpeg_load(stbi *s, int *x, int *y, int *comp, int req_comp)
+{
+   jpeg j;
+   j.s = s;
+   return load_jpeg_image(&j, x,y,comp,req_comp);
+}
+
+static int stbi_jpeg_test(stbi *s)
+{
+   int r;
+   jpeg j;
+   j.s = s;
+   r = decode_jpeg_header(&j, SCAN_type);
+   stbi_rewind(s);
+   return r;
+}
+
+static int stbi_jpeg_info_raw(jpeg *j, int *x, int *y, int *comp)
+{
+   if (!decode_jpeg_header(j, SCAN_header)) {
+      stbi_rewind( j->s );
+      return 0;
+   }
+   if (x) *x = j->s->img_x;
+   if (y) *y = j->s->img_y;
+   if (comp) *comp = j->s->img_n;
+   return 1;
+}
+
+static int stbi_jpeg_info(stbi *s, int *x, int *y, int *comp)
+{
+   jpeg j;
+   j.s = s;
+   return stbi_jpeg_info_raw(&j, x, y, comp);
+}
+
+// public domain zlib decode    v0.2  Sean Barrett 2006-11-18
+//    simple implementation
+//      - all input must be provided in an upfront buffer
+//      - all output is written to a single output buffer (can malloc/realloc)
+//    performance
+//      - fast huffman
+
+// fast-way is faster to check than jpeg huffman, but slow way is slower
+#define ZFAST_BITS  9 // accelerate all cases in default tables
+#define ZFAST_MASK  ((1 << ZFAST_BITS) - 1)
+
+// zlib-style huffman encoding
+// (jpegs packs from left, zlib from right, so can't share code)
+typedef struct
+{
+   uint16 fast[1 << ZFAST_BITS];
+   uint16 firstcode[16];
+   int maxcode[17];
+   uint16 firstsymbol[16];
+   uint8  size[288];
+   uint16 value[288]; 
+} zhuffman;
+
+stbi_inline static int bitreverse16(int n)
+{
+  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
+  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
+  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
+  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
+  return n;
+}
+
+stbi_inline static int bit_reverse(int v, int bits)
+{
+   assert(bits <= 16);
+   // to bit reverse n bits, reverse 16 and shift
+   // e.g. 11 bits, bit reverse and shift away 5
+   return bitreverse16(v) >> (16-bits);
+}
+
+static int zbuild_huffman(zhuffman *z, uint8 *sizelist, int num)
+{
+   int i,k=0;
+   int code, next_code[16], sizes[17];
+
+   // DEFLATE spec for generating codes
+   memset(sizes, 0, sizeof(sizes));
+   memset(z->fast, 255, sizeof(z->fast));
+   for (i=0; i < num; ++i) 
+      ++sizes[sizelist[i]];
+   sizes[0] = 0;
+   for (i=1; i < 16; ++i)
+      assert(sizes[i] <= (1 << i));
+   code = 0;
+   for (i=1; i < 16; ++i) {
+      next_code[i] = code;
+      z->firstcode[i] = (uint16) code;
+      z->firstsymbol[i] = (uint16) k;
+      code = (code + sizes[i]);
+      if (sizes[i])
+         if (code-1 >= (1 << i)) return e("bad codelengths","Corrupt JPEG");
+      z->maxcode[i] = code << (16-i); // preshift for inner loop
+      code <<= 1;
+      k += sizes[i];
+   }
+   z->maxcode[16] = 0x10000; // sentinel
+   for (i=0; i < num; ++i) {
+      int s = sizelist[i];
+      if (s) {
+         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
+         z->size[c] = (uint8)s;
+         z->value[c] = (uint16)i;
+         if (s <= ZFAST_BITS) {
+            int k = bit_reverse(next_code[s],s);
+            while (k < (1 << ZFAST_BITS)) {
+               z->fast[k] = (uint16) c;
+               k += (1 << s);
+            }
+         }
+         ++next_code[s];
+      }
+   }
+   return 1;
+}
+
+// zlib-from-memory implementation for PNG reading
+//    because PNG allows splitting the zlib stream arbitrarily,
+//    and it's annoying structurally to have PNG call ZLIB call PNG,
+//    we require PNG read all the IDATs and combine them into a single
+//    memory buffer
+
+typedef struct
+{
+   uint8 *zbuffer, *zbuffer_end;
+   int num_bits;
+   uint32 code_buffer;
+
+   char *zout;
+   char *zout_start;
+   char *zout_end;
+   int   z_expandable;
+
+   zhuffman z_length, z_distance;
+} zbuf;
+
+stbi_inline static int zget8(zbuf *z)
+{
+   if (z->zbuffer >= z->zbuffer_end) return 0;
+   return *z->zbuffer++;
+}
+
+static void fill_bits(zbuf *z)
+{
+   do {
+      assert(z->code_buffer < (1U << z->num_bits));
+      z->code_buffer |= zget8(z) << z->num_bits;
+      z->num_bits += 8;
+   } while (z->num_bits <= 24);
+}
+
+stbi_inline static unsigned int zreceive(zbuf *z, int n)
+{
+   unsigned int k;
+   if (z->num_bits < n) fill_bits(z);
+   k = z->code_buffer & ((1 << n) - 1);
+   z->code_buffer >>= n;
+   z->num_bits -= n;
+   return k;   
+}
+
+stbi_inline static int zhuffman_decode(zbuf *a, zhuffman *z)
+{
+   int b,s,k;
+   if (a->num_bits < 16) fill_bits(a);
+   b = z->fast[a->code_buffer & ZFAST_MASK];
+   if (b < 0xffff) {
+      s = z->size[b];
+      a->code_buffer >>= s;
+      a->num_bits -= s;
+      return z->value[b];
+   }
+
+   // not resolved by fast table, so compute it the slow way
+   // use jpeg approach, which requires MSbits at top
+   k = bit_reverse(a->code_buffer, 16);
+   for (s=ZFAST_BITS+1; ; ++s)
+      if (k < z->maxcode[s])
+         break;
+   if (s == 16) return -1; // invalid code!
+   // code size is s, so:
+   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
+   assert(z->size[b] == s);
+   a->code_buffer >>= s;
+   a->num_bits -= s;
+   return z->value[b];
+}
+
+static int expand(zbuf *z, int n)  // need to make room for n bytes
+{
+   char *q;
+   int cur, limit;
+   if (!z->z_expandable) return e("output buffer limit","Corrupt PNG");
+   cur   = (int) (z->zout     - z->zout_start);
+   limit = (int) (z->zout_end - z->zout_start);
+   while (cur + n > limit)
+      limit *= 2;
+   q = (char *) realloc(z->zout_start, limit);
+   if (q == NULL) return e("outofmem", "Out of memory");
+   z->zout_start = q;
+   z->zout       = q + cur;
+   z->zout_end   = q + limit;
+   return 1;
+}
+
+static int length_base[31] = {
+   3,4,5,6,7,8,9,10,11,13,
+   15,17,19,23,27,31,35,43,51,59,
+   67,83,99,115,131,163,195,227,258,0,0 };
+
+static int length_extra[31]= 
+{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };
+
+static int dist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
+257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};
+
+static int dist_extra[32] =
+{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
+
+static int parse_huffman_block(zbuf *a)
+{
+   for(;;) {
+      int z = zhuffman_decode(a, &a->z_length);
+      if (z < 256) {
+         if (z < 0) return e("bad huffman code","Corrupt PNG"); // error in huffman codes
+         if (a->zout >= a->zout_end) if (!expand(a, 1)) return 0;
+         *a->zout++ = (char) z;
+      } else {
+         uint8 *p;
+         int len,dist;
+         if (z == 256) return 1;
+         z -= 257;
+         len = length_base[z];
+         if (length_extra[z]) len += zreceive(a, length_extra[z]);
+         z = zhuffman_decode(a, &a->z_distance);
+         if (z < 0) return e("bad huffman code","Corrupt PNG");
+         dist = dist_base[z];
+         if (dist_extra[z]) dist += zreceive(a, dist_extra[z]);
+         if (a->zout - a->zout_start < dist) return e("bad dist","Corrupt PNG");
+         if (a->zout + len > a->zout_end) if (!expand(a, len)) return 0;
+         p = (uint8 *) (a->zout - dist);
+         while (len--)
+            *a->zout++ = *p++;
+      }
+   }
+}
+
+static int compute_huffman_codes(zbuf *a)
+{
+   static uint8 length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
+   zhuffman z_codelength;
+   uint8 lencodes[286+32+137];//padding for maximum single op
+   uint8 codelength_sizes[19];
+   int i,n;
+
+   int hlit  = zreceive(a,5) + 257;
+   int hdist = zreceive(a,5) + 1;
+   int hclen = zreceive(a,4) + 4;
+
+   memset(codelength_sizes, 0, sizeof(codelength_sizes));
+   for (i=0; i < hclen; ++i) {
+      int s = zreceive(a,3);
+      codelength_sizes[length_dezigzag[i]] = (uint8) s;
+   }
+   if (!zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;
+
+   n = 0;
+   while (n < hlit + hdist) {
+      int c = zhuffman_decode(a, &z_codelength);
+      assert(c >= 0 && c < 19);
+      if (c < 16)
+         lencodes[n++] = (uint8) c;
+      else if (c == 16) {
+         c = zreceive(a,2)+3;
+         memset(lencodes+n, lencodes[n-1], c);
+         n += c;
+      } else if (c == 17) {
+         c = zreceive(a,3)+3;
+         memset(lencodes+n, 0, c);
+         n += c;
+      } else {
+         assert(c == 18);
+         c = zreceive(a,7)+11;
+         memset(lencodes+n, 0, c);
+         n += c;
+      }
+   }
+   if (n != hlit+hdist) return e("bad codelengths","Corrupt PNG");
+   if (!zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
+   if (!zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
+   return 1;
+}
+
+static int parse_uncompressed_block(zbuf *a)
+{
+   uint8 header[4];
+   int len,nlen,k;
+   if (a->num_bits & 7)
+      zreceive(a, a->num_bits & 7); // discard
+   // drain the bit-packed data into header
+   k = 0;
+   while (a->num_bits > 0) {
+      header[k++] = (uint8) (a->code_buffer & 255); // wtf this warns?
+      a->code_buffer >>= 8;
+      a->num_bits -= 8;
+   }
+   assert(a->num_bits == 0);
+   // now fill header the normal way
+   while (k < 4)
+      header[k++] = (uint8) zget8(a);
+   len  = header[1] * 256 + header[0];
+   nlen = header[3] * 256 + header[2];
+   if (nlen != (len ^ 0xffff)) return e("zlib corrupt","Corrupt PNG");
+   if (a->zbuffer + len > a->zbuffer_end) return e("read past buffer","Corrupt PNG");
+   if (a->zout + len > a->zout_end)
+      if (!expand(a, len)) return 0;
+   memcpy(a->zout, a->zbuffer, len);
+   a->zbuffer += len;
+   a->zout += len;
+   return 1;
+}
+
+static int parse_zlib_header(zbuf *a)
+{
+   int cmf   = zget8(a);
+   int cm    = cmf & 15;
+   /* int cinfo = cmf >> 4; */
+   int flg   = zget8(a);
+   if ((cmf*256+flg) % 31 != 0) return e("bad zlib header","Corrupt PNG"); // zlib spec
+   if (flg & 32) return e("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
+   if (cm != 8) return e("bad compression","Corrupt PNG"); // DEFLATE required for png
+   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
+   return 1;
+}
+
+// @TODO: should statically initialize these for optimal thread safety
+static uint8 default_length[288], default_distance[32];
+static void init_defaults(void)
+{
+   int i;   // use <= to match clearly with spec
+   for (i=0; i <= 143; ++i)     default_length[i]   = 8;
+   for (   ; i <= 255; ++i)     default_length[i]   = 9;
+   for (   ; i <= 279; ++i)     default_length[i]   = 7;
+   for (   ; i <= 287; ++i)     default_length[i]   = 8;
+
+   for (i=0; i <=  31; ++i)     default_distance[i] = 5;
+}
+
+int stbi_png_partial; // a quick hack to only allow decoding some of a PNG... I should implement real streaming support instead
+static int parse_zlib(zbuf *a, int parse_header)
+{
+   int final, type;
+   if (parse_header)
+      if (!parse_zlib_header(a)) return 0;
+   a->num_bits = 0;
+   a->code_buffer = 0;
+   do {
+      final = zreceive(a,1);
+      type = zreceive(a,2);
+      if (type == 0) {
+         if (!parse_uncompressed_block(a)) return 0;
+      } else if (type == 3) {
+         return 0;
+      } else {
+         if (type == 1) {
+            // use fixed code lengths
+            if (!default_distance[31]) init_defaults();
+            if (!zbuild_huffman(&a->z_length  , default_length  , 288)) return 0;
+            if (!zbuild_huffman(&a->z_distance, default_distance,  32)) return 0;
+         } else {
+            if (!compute_huffman_codes(a)) return 0;
+         }
+         if (!parse_huffman_block(a)) return 0;
+      }
+      if (stbi_png_partial && a->zout - a->zout_start > 65536)
+         break;
+   } while (!final);
+   return 1;
+}
+
+static int do_zlib(zbuf *a, char *obuf, int olen, int exp, int parse_header)
+{
+   a->zout_start = obuf;
+   a->zout       = obuf;
+   a->zout_end   = obuf + olen;
+   a->z_expandable = exp;
+
+   return parse_zlib(a, parse_header);
+}
+
+char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
+{
+   zbuf a;
+   char *p = (char *) malloc(initial_size);
+   if (p == NULL) return NULL;
+   a.zbuffer = (uint8 *) buffer;
+   a.zbuffer_end = (uint8 *) buffer + len;
+   if (do_zlib(&a, p, initial_size, 1, 1)) {
+      if (outlen) *outlen = (int) (a.zout - a.zout_start);
+      return a.zout_start;
+   } else {
+      free(a.zout_start);
+      return NULL;
+   }
+}
+
+char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
+{
+   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
+}
+
+char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
+{
+   zbuf a;
+   char *p = (char *) malloc(initial_size);
+   if (p == NULL) return NULL;
+   a.zbuffer = (uint8 *) buffer;
+   a.zbuffer_end = (uint8 *) buffer + len;
+   if (do_zlib(&a, p, initial_size, 1, parse_header)) {
+      if (outlen) *outlen = (int) (a.zout - a.zout_start);
+      return a.zout_start;
+   } else {
+      free(a.zout_start);
+      return NULL;
+   }
+}
+
+int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
+{
+   zbuf a;
+   a.zbuffer = (uint8 *) ibuffer;
+   a.zbuffer_end = (uint8 *) ibuffer + ilen;
+   if (do_zlib(&a, obuffer, olen, 0, 1))
+      return (int) (a.zout - a.zout_start);
+   else
+      return -1;
+}
+
+char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
+{
+   zbuf a;
+   char *p = (char *) malloc(16384);
+   if (p == NULL) return NULL;
+   a.zbuffer = (uint8 *) buffer;
+   a.zbuffer_end = (uint8 *) buffer+len;
+   if (do_zlib(&a, p, 16384, 1, 0)) {
+      if (outlen) *outlen = (int) (a.zout - a.zout_start);
+      return a.zout_start;
+   } else {
+      free(a.zout_start);
+      return NULL;
+   }
+}
+
+int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
+{
+   zbuf a;
+   a.zbuffer = (uint8 *) ibuffer;
+   a.zbuffer_end = (uint8 *) ibuffer + ilen;
+   if (do_zlib(&a, obuffer, olen, 0, 0))
+      return (int) (a.zout - a.zout_start);
+   else
+      return -1;
+}
+
+// public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
+//    simple implementation
+//      - only 8-bit samples
+//      - no CRC checking
+//      - allocates lots of intermediate memory
+//        - avoids problem of streaming data between subsystems
+//        - avoids explicit window management
+//    performance
+//      - uses stb_zlib, a PD zlib implementation with fast huffman decoding
+
+
+typedef struct
+{
+   uint32 length;
+   uint32 type;
+} chunk;
+
+#define PNG_TYPE(a,b,c,d)  (((a) << 24) + ((b) << 16) + ((c) << 8) + (d))
+
+static chunk get_chunk_header(stbi *s)
+{
+   chunk c;
+   c.length = get32(s);
+   c.type   = get32(s);
+   return c;
+}
+
+static int check_png_header(stbi *s)
+{
+   static uint8 png_sig[8] = { 137,80,78,71,13,10,26,10 };
+   int i;
+   for (i=0; i < 8; ++i)
+      if (get8u(s) != png_sig[i]) return e("bad png sig","Not a PNG");
+   return 1;
+}
+
+typedef struct
+{
+   stbi *s;
+   uint8 *idata, *expanded, *out;
+} png;
+
+
+enum {
+   F_none=0, F_sub=1, F_up=2, F_avg=3, F_paeth=4,
+   F_avg_first, F_paeth_first
+};
+
+static uint8 first_row_filter[5] =
+{
+   F_none, F_sub, F_none, F_avg_first, F_paeth_first
+};
+
+static int paeth(int a, int b, int c)
+{
+   int p = a + b - c;
+   int pa = abs(p-a);
+   int pb = abs(p-b);
+   int pc = abs(p-c);
+   if (pa <= pb && pa <= pc) return a;
+   if (pb <= pc) return b;
+   return c;
+}
+
+// create the png data from post-deflated data
+static int create_png_image_raw(png *a, uint8 *raw, uint32 raw_len, int out_n, uint32 x, uint32 y)
+{
+   stbi *s = a->s;
+   uint32 i,j,stride = x*out_n;
+   int k;
+   int img_n = s->img_n; // copy it into a local for later
+   assert(out_n == s->img_n || out_n == s->img_n+1);
+   if (stbi_png_partial) y = 1;
+   a->out = (uint8 *) malloc(x * y * out_n);
+   if (!a->out) return e("outofmem", "Out of memory");
+   if (!stbi_png_partial) {
+      if (s->img_x == x && s->img_y == y) {
+         if (raw_len != (img_n * x + 1) * y) return e("not enough pixels","Corrupt PNG");
+      } else { // interlaced:
+         if (raw_len < (img_n * x + 1) * y) return e("not enough pixels","Corrupt PNG");
+      }
+   }
+   for (j=0; j < y; ++j) {
+      uint8 *cur = a->out + stride*j;
+      uint8 *prior = cur - stride;
+      int filter = *raw++;
+      if (filter > 4) return e("invalid filter","Corrupt PNG");
+      // if first row, use special filter that doesn't sample previous row
+      if (j == 0) filter = first_row_filter[filter];
+      // handle first pixel explicitly
+      for (k=0; k < img_n; ++k) {
+         switch (filter) {
+            case F_none       : cur[k] = raw[k]; break;
+            case F_sub        : cur[k] = raw[k]; break;
+            case F_up         : cur[k] = raw[k] + prior[k]; break;
+            case F_avg        : cur[k] = raw[k] + (prior[k]>>1); break;
+            case F_paeth      : cur[k] = (uint8) (raw[k] + paeth(0,prior[k],0)); break;
+            case F_avg_first  : cur[k] = raw[k]; break;
+            case F_paeth_first: cur[k] = raw[k]; break;
+         }
+      }
+      if (img_n != out_n) cur[img_n] = 255;
+      raw += img_n;
+      cur += out_n;
+      prior += out_n;
+      // this is a little gross, so that we don't switch per-pixel or per-component
+      if (img_n == out_n) {
+         #define CASE(f) \
+             case f:     \
+                for (i=x-1; i >= 1; --i, raw+=img_n,cur+=img_n,prior+=img_n) \
+                   for (k=0; k < img_n; ++k)
+         switch (filter) {
+            CASE(F_none)  cur[k] = raw[k]; break;
+            CASE(F_sub)   cur[k] = raw[k] + cur[k-img_n]; break;
+            CASE(F_up)    cur[k] = raw[k] + prior[k]; break;
+            CASE(F_avg)   cur[k] = raw[k] + ((prior[k] + cur[k-img_n])>>1); break;
+            CASE(F_paeth)  cur[k] = (uint8) (raw[k] + paeth(cur[k-img_n],prior[k],prior[k-img_n])); break;
+            CASE(F_avg_first)    cur[k] = raw[k] + (cur[k-img_n] >> 1); break;
+            CASE(F_paeth_first)  cur[k] = (uint8) (raw[k] + paeth(cur[k-img_n],0,0)); break;
+         }
+         #undef CASE
+      } else {
+         assert(img_n+1 == out_n);
+         #define CASE(f) \
+             case f:     \
+                for (i=x-1; i >= 1; --i, cur[img_n]=255,raw+=img_n,cur+=out_n,prior+=out_n) \
+                   for (k=0; k < img_n; ++k)
+         switch (filter) {
+            CASE(F_none)  cur[k] = raw[k]; break;
+            CASE(F_sub)   cur[k] = raw[k] + cur[k-out_n]; break;
+            CASE(F_up)    cur[k] = raw[k] + prior[k]; break;
+            CASE(F_avg)   cur[k] = raw[k] + ((prior[k] + cur[k-out_n])>>1); break;
+            CASE(F_paeth)  cur[k] = (uint8) (raw[k] + paeth(cur[k-out_n],prior[k],prior[k-out_n])); break;
+            CASE(F_avg_first)    cur[k] = raw[k] + (cur[k-out_n] >> 1); break;
+            CASE(F_paeth_first)  cur[k] = (uint8) (raw[k] + paeth(cur[k-out_n],0,0)); break;
+         }
+         #undef CASE
+      }
+   }
+   return 1;
+}
+
+static int create_png_image(png *a, uint8 *raw, uint32 raw_len, int out_n, int interlaced)
+{
+   uint8 *final;
+   int p;
+   int save;
+   if (!interlaced)
+      return create_png_image_raw(a, raw, raw_len, out_n, a->s->img_x, a->s->img_y);
+   save = stbi_png_partial;
+   stbi_png_partial = 0;
+
+   // de-interlacing
+   final = (uint8 *) malloc(a->s->img_x * a->s->img_y * out_n);
+   for (p=0; p < 7; ++p) {
+      int xorig[] = { 0,4,0,2,0,1,0 };
+      int yorig[] = { 0,0,4,0,2,0,1 };
+      int xspc[]  = { 8,8,4,4,2,2,1 };
+      int yspc[]  = { 8,8,8,4,4,2,2 };
+      int i,j,x,y;
+      // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
+      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
+      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
+      if (x && y) {
+         if (!create_png_image_raw(a, raw, raw_len, out_n, x, y)) {
+            free(final);
+            return 0;
+         }
+         for (j=0; j < y; ++j)
+            for (i=0; i < x; ++i)
+               memcpy(final + (j*yspc[p]+yorig[p])*a->s->img_x*out_n + (i*xspc[p]+xorig[p])*out_n,
+                      a->out + (j*x+i)*out_n, out_n);
+         free(a->out);
+         raw += (x*out_n+1)*y;
+         raw_len -= (x*out_n+1)*y;
+      }
+   }
+   a->out = final;
+
+   stbi_png_partial = save;
+   return 1;
+}
+
+static int compute_transparency(png *z, uint8 tc[3], int out_n)
+{
+   stbi *s = z->s;
+   uint32 i, pixel_count = s->img_x * s->img_y;
+   uint8 *p = z->out;
+
+   // compute color-based transparency, assuming we've
+   // already got 255 as the alpha value in the output
+   assert(out_n == 2 || out_n == 4);
+
+   if (out_n == 2) {
+      for (i=0; i < pixel_count; ++i) {
+         p[1] = (p[0] == tc[0] ? 0 : 255);
+         p += 2;
+      }
+   } else {
+      for (i=0; i < pixel_count; ++i) {
+         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
+            p[3] = 0;
+         p += 4;
+      }
+   }
+   return 1;
+}
+
+static int expand_palette(png *a, uint8 *palette, int len, int pal_img_n)
+{
+   uint32 i, pixel_count = a->s->img_x * a->s->img_y;
+   uint8 *p, *temp_out, *orig = a->out;
+
+   p = (uint8 *) malloc(pixel_count * pal_img_n);
+   if (p == NULL) return e("outofmem", "Out of memory");
+
+   // between here and free(out) below, exitting would leak
+   temp_out = p;
+
+   if (pal_img_n == 3) {
+      for (i=0; i < pixel_count; ++i) {
+         int n = orig[i]*4;
+         p[0] = palette[n  ];
+         p[1] = palette[n+1];
+         p[2] = palette[n+2];
+         p += 3;
+      }
+   } else {
+      for (i=0; i < pixel_count; ++i) {
+         int n = orig[i]*4;
+         p[0] = palette[n  ];
+         p[1] = palette[n+1];
+         p[2] = palette[n+2];
+         p[3] = palette[n+3];
+         p += 4;
+      }
+   }
+   free(a->out);
+   a->out = temp_out;
+
+   STBI_NOTUSED(len);
+
+   return 1;
+}
+
+static int stbi_unpremultiply_on_load = 0;
+static int stbi_de_iphone_flag = 0;
+
+void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
+{
+   stbi_unpremultiply_on_load = flag_true_if_should_unpremultiply;
+}
+void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
+{
+   stbi_de_iphone_flag = flag_true_if_should_convert;
+}
+
+static void stbi_de_iphone(png *z)
+{
+   stbi *s = z->s;
+   uint32 i, pixel_count = s->img_x * s->img_y;
+   uint8 *p = z->out;
+
+   if (s->img_out_n == 3) {  // convert bgr to rgb
+      for (i=0; i < pixel_count; ++i) {
+         uint8 t = p[0];
+         p[0] = p[2];
+         p[2] = t;
+         p += 3;
+      }
+   } else {
+      assert(s->img_out_n == 4);
+      if (stbi_unpremultiply_on_load) {
+         // convert bgr to rgb and unpremultiply
+         for (i=0; i < pixel_count; ++i) {
+            uint8 a = p[3];
+            uint8 t = p[0];
+            if (a) {
+               p[0] = p[2] * 255 / a;
+               p[1] = p[1] * 255 / a;
+               p[2] =  t   * 255 / a;
+            } else {
+               p[0] = p[2];
+               p[2] = t;
+            } 
+            p += 4;
+         }
+      } else {
+         // convert bgr to rgb
+         for (i=0; i < pixel_count; ++i) {
+            uint8 t = p[0];
+            p[0] = p[2];
+            p[2] = t;
+            p += 4;
+         }
+      }
+   }
+}
+
+static int parse_png_file(png *z, int scan, int req_comp)
+{
+   uint8 palette[1024], pal_img_n=0;
+   uint8 has_trans=0, tc[3];
+   uint32 ioff=0, idata_limit=0, i, pal_len=0;
+   int first=1,k,interlace=0, iphone=0;
+   stbi *s = z->s;
+
+   z->expanded = NULL;
+   z->idata = NULL;
+   z->out = NULL;
+
+   if (!check_png_header(s)) return 0;
+
+   if (scan == SCAN_type) return 1;
+
+   for (;;) {
+      chunk c = get_chunk_header(s);
+      switch (c.type) {
+         case PNG_TYPE('C','g','B','I'):
+            iphone = stbi_de_iphone_flag;
+            skip(s, c.length);
+            break;
+         case PNG_TYPE('I','H','D','R'): {
+            int depth,color,comp,filter;
+            if (!first) return e("multiple IHDR","Corrupt PNG");
+            first = 0;
+            if (c.length != 13) return e("bad IHDR len","Corrupt PNG");
+            s->img_x = get32(s); if (s->img_x > (1 << 24)) return e("too large","Very large image (corrupt?)");
+            s->img_y = get32(s); if (s->img_y > (1 << 24)) return e("too large","Very large image (corrupt?)");
+            depth = get8(s);  if (depth != 8)        return e("8bit only","PNG not supported: 8-bit only");
+            color = get8(s);  if (color > 6)         return e("bad ctype","Corrupt PNG");
+            if (color == 3) pal_img_n = 3; else if (color & 1) return e("bad ctype","Corrupt PNG");
+            comp  = get8(s);  if (comp) return e("bad comp method","Corrupt PNG");
+            filter= get8(s);  if (filter) return e("bad filter method","Corrupt PNG");
+            interlace = get8(s); if (interlace>1) return e("bad interlace method","Corrupt PNG");
+            if (!s->img_x || !s->img_y) return e("0-pixel image","Corrupt PNG");
+            if (!pal_img_n) {
+               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
+               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return e("too large", "Image too large to decode");
+               if (scan == SCAN_header) return 1;
+            } else {
+               // if paletted, then pal_n is our final components, and
+               // img_n is # components to decompress/filter.
+               s->img_n = 1;
+               if ((1 << 30) / s->img_x / 4 < s->img_y) return e("too large","Corrupt PNG");
+               // if SCAN_header, have to scan to see if we have a tRNS
+            }
+            break;
+         }
+
+         case PNG_TYPE('P','L','T','E'):  {
+            if (first) return e("first not IHDR", "Corrupt PNG");
+            if (c.length > 256*3) return e("invalid PLTE","Corrupt PNG");
+            pal_len = c.length / 3;
+            if (pal_len * 3 != c.length) return e("invalid PLTE","Corrupt PNG");
+            for (i=0; i < pal_len; ++i) {
+               palette[i*4+0] = get8u(s);
+               palette[i*4+1] = get8u(s);
+               palette[i*4+2] = get8u(s);
+               palette[i*4+3] = 255;
+            }
+            break;
+         }
+
+         case PNG_TYPE('t','R','N','S'): {
+            if (first) return e("first not IHDR", "Corrupt PNG");
+            if (z->idata) return e("tRNS after IDAT","Corrupt PNG");
+            if (pal_img_n) {
+               if (scan == SCAN_header) { s->img_n = 4; return 1; }
+               if (pal_len == 0) return e("tRNS before PLTE","Corrupt PNG");
+               if (c.length > pal_len) return e("bad tRNS len","Corrupt PNG");
+               pal_img_n = 4;
+               for (i=0; i < c.length; ++i)
+                  palette[i*4+3] = get8u(s);
+            } else {
+               if (!(s->img_n & 1)) return e("tRNS with alpha","Corrupt PNG");
+               if (c.length != (uint32) s->img_n*2) return e("bad tRNS len","Corrupt PNG");
+               has_trans = 1;
+               for (k=0; k < s->img_n; ++k)
+                  tc[k] = (uint8) get16(s); // non 8-bit images will be larger
+            }
+            break;
+         }
+
+         case PNG_TYPE('I','D','A','T'): {
+            if (first) return e("first not IHDR", "Corrupt PNG");
+            if (pal_img_n && !pal_len) return e("no PLTE","Corrupt PNG");
+            if (scan == SCAN_header) { s->img_n = pal_img_n; return 1; }
+            if (ioff + c.length > idata_limit) {
+               uint8 *p;
+               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
+               while (ioff + c.length > idata_limit)
+                  idata_limit *= 2;
+               p = (uint8 *) realloc(z->idata, idata_limit); if (p == NULL) return e("outofmem", "Out of memory");
+               z->idata = p;
+            }
+            if (!getn(s, z->idata+ioff,c.length)) return e("outofdata","Corrupt PNG");
+            ioff += c.length;
+            break;
+         }
+
+         case PNG_TYPE('I','E','N','D'): {
+            uint32 raw_len;
+            if (first) return e("first not IHDR", "Corrupt PNG");
+            if (scan != SCAN_load) return 1;
+            if (z->idata == NULL) return e("no IDAT","Corrupt PNG");
+            z->expanded = (uint8 *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, 16384, (int *) &raw_len, !iphone);
+            if (z->expanded == NULL) return 0; // zlib should set error
+            free(z->idata); z->idata = NULL;
+            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
+               s->img_out_n = s->img_n+1;
+            else
+               s->img_out_n = s->img_n;
+            if (!create_png_image(z, z->expanded, raw_len, s->img_out_n, interlace)) return 0;
+            if (has_trans)
+               if (!compute_transparency(z, tc, s->img_out_n)) return 0;
+            if (iphone && s->img_out_n > 2)
+               stbi_de_iphone(z);
+            if (pal_img_n) {
+               // pal_img_n == 3 or 4
+               s->img_n = pal_img_n; // record the actual colors we had
+               s->img_out_n = pal_img_n;
+               if (req_comp >= 3) s->img_out_n = req_comp;
+               if (!expand_palette(z, palette, pal_len, s->img_out_n))
+                  return 0;
+            }
+            free(z->expanded); z->expanded = NULL;
+            return 1;
+         }
+
+         default:
+            // if critical, fail
+            if (first) return e("first not IHDR", "Corrupt PNG");
+            if ((c.type & (1 << 29)) == 0) {
+               #ifndef STBI_NO_FAILURE_STRINGS
+               // not threadsafe
+               static char invalid_chunk[] = "XXXX chunk not known";
+               invalid_chunk[0] = (uint8) (c.type >> 24);
+               invalid_chunk[1] = (uint8) (c.type >> 16);
+               invalid_chunk[2] = (uint8) (c.type >>  8);
+               invalid_chunk[3] = (uint8) (c.type >>  0);
+               #endif
+               return e(invalid_chunk, "PNG not supported: unknown chunk type");
+            }
+            skip(s, c.length);
+            break;
+      }
+      // end of chunk, read and skip CRC
+      get32(s);
+   }
+}
+
+static unsigned char *do_png(png *p, int *x, int *y, int *n, int req_comp)
+{
+   unsigned char *result=NULL;
+   if (req_comp < 0 || req_comp > 4) return epuc("bad req_comp", "Internal error");
+   if (parse_png_file(p, SCAN_load, req_comp)) {
+      result = p->out;
+      p->out = NULL;
+      if (req_comp && req_comp != p->s->img_out_n) {
+         result = convert_format(result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
+         p->s->img_out_n = req_comp;
+         if (result == NULL) return result;
+      }
+      *x = p->s->img_x;
+      *y = p->s->img_y;
+      if (n) *n = p->s->img_n;
+   }
+   free(p->out);      p->out      = NULL;
+   free(p->expanded); p->expanded = NULL;
+   free(p->idata);    p->idata    = NULL;
+
+   return result;
+}
+
+static unsigned char *stbi_png_load(stbi *s, int *x, int *y, int *comp, int req_comp)
+{
+   png p;
+   p.s = s;
+   return do_png(&p, x,y,comp,req_comp);
+}
+
+static int stbi_png_test(stbi *s)
+{
+   int r;
+   r = check_png_header(s);
+   stbi_rewind(s);
+   return r;
+}
+
+static int stbi_png_info_raw(png *p, int *x, int *y, int *comp)
+{
+   if (!parse_png_file(p, SCAN_header, 0)) {
+      stbi_rewind( p->s );
+      return 0;
+   }
+   if (x) *x = p->s->img_x;
+   if (y) *y = p->s->img_y;
+   if (comp) *comp = p->s->img_n;
+   return 1;
+}
+
+static int      stbi_png_info(stbi *s, int *x, int *y, int *comp)
+{
+   png p;
+   p.s = s;
+   return stbi_png_info_raw(&p, x, y, comp);
+}
+
+// Microsoft/Windows BMP image
+
+static int bmp_test(stbi *s)
+{
+   int sz;
+   if (get8(s) != 'B') return 0;
+   if (get8(s) != 'M') return 0;
+   get32le(s); // discard filesize
+   get16le(s); // discard reserved
+   get16le(s); // discard reserved
+   get32le(s); // discard data offset
+   sz = get32le(s);
+   if (sz == 12 || sz == 40 || sz == 56 || sz == 108) return 1;
+   return 0;
+}
+
+static int stbi_bmp_test(stbi *s)
+{
+   int r = bmp_test(s);
+   stbi_rewind(s);
+   return r;
+}
+
+
+// returns 0..31 for the highest set bit
+static int high_bit(unsigned int z)
+{
+   int n=0;
+   if (z == 0) return -1;
+   if (z >= 0x10000) n += 16, z >>= 16;
+   if (z >= 0x00100) n +=  8, z >>=  8;
+   if (z >= 0x00010) n +=  4, z >>=  4;
+   if (z >= 0x00004) n +=  2, z >>=  2;
+   if (z >= 0x00002) n +=  1, z >>=  1;
+   return n;
+}
+
+static int bitcount(unsigned int a)
+{
+   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
+   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
+   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
+   a = (a + (a >> 8)); // max 16 per 8 bits
+   a = (a + (a >> 16)); // max 32 per 8 bits
+   return a & 0xff;
+}
+
+static int shiftsigned(int v, int shift, int bits)
+{
+   int result;
+   int z=0;
+
+   if (shift < 0) v <<= -shift;
+   else v >>= shift;
+   result = v;
+
+   z = bits;
+   while (z < 8) {
+      result += v >> z;
+      z += bits;
+   }
+   return result;
+}
+
+static stbi_uc *bmp_load(stbi *s, int *x, int *y, int *comp, int req_comp)
+{
+   uint8 *out;
+   unsigned int mr=0,mg=0,mb=0,ma=0, fake_a=0;
+   stbi_uc pal[256][4];
+   int psize=0,i,j,compress=0,width;
+   int bpp, flip_vertically, pad, target, offset, hsz;
+   if (get8(s) != 'B' || get8(s) != 'M') return epuc("not BMP", "Corrupt BMP");
+   get32le(s); // discard filesize
+   get16le(s); // discard reserved
+   get16le(s); // discard reserved
+   offset = get32le(s);
+   hsz = get32le(s);
+   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108) return epuc("unknown BMP", "BMP type not supported: unknown");
+   if (hsz == 12) {
+      s->img_x = get16le(s);
+      s->img_y = get16le(s);
+   } else {
+      s->img_x = get32le(s);
+      s->img_y = get32le(s);
+   }
+   if (get16le(s) != 1) return epuc("bad BMP", "bad BMP");
+   bpp = get16le(s);
+   if (bpp == 1) return epuc("monochrome", "BMP type not supported: 1-bit");
+   flip_vertically = ((int) s->img_y) > 0;
+   s->img_y = abs((int) s->img_y);
+   if (hsz == 12) {
+      if (bpp < 24)
+         psize = (offset - 14 - 24) / 3;
+   } else {
+      compress = get32le(s);
+      if (compress == 1 || compress == 2) return epuc("BMP RLE", "BMP type not supported: RLE");
+      get32le(s); // discard sizeof
+      get32le(s); // discard hres
+      get32le(s); // discard vres
+      get32le(s); // discard colorsused
+      get32le(s); // discard max important
+      if (hsz == 40 || hsz == 56) {
+         if (hsz == 56) {
+            get32le(s);
+            get32le(s);
+            get32le(s);
+            get32le(s);
+         }
+         if (bpp == 16 || bpp == 32) {
+            mr = mg = mb = 0;
+            if (compress == 0) {
+               if (bpp == 32) {
+                  mr = 0xffu << 16;
+                  mg = 0xffu <<  8;
+                  mb = 0xffu <<  0;
+                  ma = 0xffu << 24;
+                  fake_a = 1; // @TODO: check for cases like alpha value is all 0 and switch it to 255
+               } else {
+                  mr = 31u << 10;
+                  mg = 31u <<  5;
+                  mb = 31u <<  0;
+               }
+            } else if (compress == 3) {
+               mr = get32le(s);
+               mg = get32le(s);
+               mb = get32le(s);
+               // not documented, but generated by photoshop and handled by mspaint
+               if (mr == mg && mg == mb) {
+                  // ?!?!?
+                  return epuc("bad BMP", "bad BMP");
+               }
+            } else
+               return epuc("bad BMP", "bad BMP");
+         }
+      } else {
+         assert(hsz == 108);
+         mr = get32le(s);
+         mg = get32le(s);
+         mb = get32le(s);
+         ma = get32le(s);
+         get32le(s); // discard color space
+         for (i=0; i < 12; ++i)
+            get32le(s); // discard color space parameters
+      }
+      if (bpp < 16)
+         psize = (offset - 14 - hsz) >> 2;
+   }
+   s->img_n = ma ? 4 : 3;
+   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
+      target = req_comp;
+   else
+      target = s->img_n; // if they want monochrome, we'll post-convert
+   out = (stbi_uc *) malloc(target * s->img_x * s->img_y);
+   if (!out) return epuc("outofmem", "Out of memory");
+   if (bpp < 16) {
+      int z=0;
+      if (psize == 0 || psize > 256) { free(out); return epuc("invalid", "Corrupt BMP"); }
+      for (i=0; i < psize; ++i) {
+         pal[i][2] = get8u(s);
+         pal[i][1] = get8u(s);
+         pal[i][0] = get8u(s);
+         if (hsz != 12) get8(s);
+         pal[i][3] = 255;
+      }
+      skip(s, offset - 14 - hsz - psize * (hsz == 12 ? 3 : 4));
+      if (bpp == 4) width = (s->img_x + 1) >> 1;
+      else if (bpp == 8) width = s->img_x;
+      else { free(out); return epuc("bad bpp", "Corrupt BMP"); }
+      pad = (-width)&3;
+      for (j=0; j < (int) s->img_y; ++j) {
+         for (i=0; i < (int) s->img_x; i += 2) {
+            int v=get8(s),v2=0;
+            if (bpp == 4) {
+               v2 = v & 15;
+               v >>= 4;
+            }
+            out[z++] = pal[v][0];
+            out[z++] = pal[v][1];
+            out[z++] = pal[v][2];
+            if (target == 4) out[z++] = 255;
+            if (i+1 == (int) s->img_x) break;
+            v = (bpp == 8) ? get8(s) : v2;
+            out[z++] = pal[v][0];
+            out[z++] = pal[v][1];
+            out[z++] = pal[v][2];
+            if (target == 4) out[z++] = 255;
+         }
+         skip(s, pad);
+      }
+   } else {
+      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
+      int z = 0;
+      int easy=0;
+      skip(s, offset - 14 - hsz);
+      if (bpp == 24) width = 3 * s->img_x;
+      else if (bpp == 16) width = 2*s->img_x;
+      else /* bpp = 32 and pad = 0 */ width=0;
+      pad = (-width) & 3;
+      if (bpp == 24) {
+         easy = 1;
+      } else if (bpp == 32) {
+         if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
+            easy = 2;
+      }
+      if (!easy) {
+         if (!mr || !mg || !mb) { free(out); return epuc("bad masks", "Corrupt BMP"); }
+         // right shift amt to put high bit in position #7
+         rshift = high_bit(mr)-7; rcount = bitcount(mr);
+         gshift = high_bit(mg)-7; gcount = bitcount(mr);
+         bshift = high_bit(mb)-7; bcount = bitcount(mr);
+         ashift = high_bit(ma)-7; acount = bitcount(mr);
+      }
+      for (j=0; j < (int) s->img_y; ++j) {
+         if (easy) {
+            for (i=0; i < (int) s->img_x; ++i) {
+               int a;
+               out[z+2] = get8u(s);
+               out[z+1] = get8u(s);
+               out[z+0] = get8u(s);
+               z += 3;
+               a = (easy == 2 ? get8(s) : 255);
+               if (target == 4) out[z++] = (uint8) a;
+            }
+         } else {
+            for (i=0; i < (int) s->img_x; ++i) {
+               uint32 v = (bpp == 16 ? get16le(s) : get32le(s));
+               int a;
+               out[z++] = (uint8) shiftsigned(v & mr, rshift, rcount);
+               out[z++] = (uint8) shiftsigned(v & mg, gshift, gcount);
+               out[z++] = (uint8) shiftsigned(v & mb, bshift, bcount);
+               a = (ma ? shiftsigned(v & ma, ashift, acount) : 255);
+               if (target == 4) out[z++] = (uint8) a; 
+            }
+         }
+         skip(s, pad);
+      }
+   }
+   if (flip_vertically) {
+      stbi_uc t;
+      for (j=0; j < (int) s->img_y>>1; ++j) {
+         stbi_uc *p1 = out +      j     *s->img_x*target;
+         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
+         for (i=0; i < (int) s->img_x*target; ++i) {
+            t = p1[i], p1[i] = p2[i], p2[i] = t;
+         }
+      }
+   }
+
+   if (req_comp && req_comp != target) {
+      out = convert_format(out, target, req_comp, s->img_x, s->img_y);
+      if (out == NULL) return out; // convert_format frees input on failure
+   }
+
+   *x = s->img_x;
+   *y = s->img_y;
+   if (comp) *comp = s->img_n;
+   return out;
+}
+
+static stbi_uc *stbi_bmp_load(stbi *s,int *x, int *y, int *comp, int req_comp)
+{
+   return bmp_load(s, x,y,comp,req_comp);
+}
+
+
+// Targa Truevision - TGA
+// by Jonathan Dummer
+
+static int tga_info(stbi *s, int *x, int *y, int *comp)
+{
+    int tga_w, tga_h, tga_comp;
+    int sz;
+    get8u(s);                   // discard Offset
+    sz = get8u(s);              // color type
+    if( sz > 1 ) {
+        stbi_rewind(s);
+        return 0;      // only RGB or indexed allowed
+    }
+    sz = get8u(s);              // image type
+    // only RGB or grey allowed, +/- RLE
+    if ((sz != 1) && (sz != 2) && (sz != 3) && (sz != 9) && (sz != 10) && (sz != 11)) return 0;
+    skip(s,9);
+    tga_w = get16le(s);
+    if( tga_w < 1 ) {
+        stbi_rewind(s);
+        return 0;   // test width
+    }
+    tga_h = get16le(s);
+    if( tga_h < 1 ) {
+        stbi_rewind(s);
+        return 0;   // test height
+    }
+    sz = get8(s);               // bits per pixel
+    // only RGB or RGBA or grey allowed
+    if ((sz != 8) && (sz != 16) && (sz != 24) && (sz != 32)) {
+        stbi_rewind(s);
+        return 0;
+    }
+    tga_comp = sz;
+    if (x) *x = tga_w;
+    if (y) *y = tga_h;
+    if (comp) *comp = tga_comp / 8;
+    return 1;                   // seems to have passed everything
+}
+
+int stbi_tga_info(stbi *s, int *x, int *y, int *comp)
+{
+    return tga_info(s, x, y, comp);
+}
+
+static int tga_test(stbi *s)
+{
+   int sz;
+   get8u(s);      //   discard Offset
+   sz = get8u(s);   //   color type
+   if ( sz > 1 ) return 0;   //   only RGB or indexed allowed
+   sz = get8u(s);   //   image type
+   if ( (sz != 1) && (sz != 2) && (sz != 3) && (sz != 9) && (sz != 10) && (sz != 11) ) return 0;   //   only RGB or grey allowed, +/- RLE
+   get16(s);      //   discard palette start
+   get16(s);      //   discard palette length
+   get8(s);         //   discard bits per palette color entry
+   get16(s);      //   discard x origin
+   get16(s);      //   discard y origin
+   if ( get16(s) < 1 ) return 0;      //   test width
+   if ( get16(s) < 1 ) return 0;      //   test height
+   sz = get8(s);   //   bits per pixel
+   if ( (sz != 8) && (sz != 16) && (sz != 24) && (sz != 32) ) return 0;   //   only RGB or RGBA or grey allowed
+   return 1;      //   seems to have passed everything
+}
+
+static int stbi_tga_test(stbi *s)
+{
+   int res = tga_test(s);
+   stbi_rewind(s);
+   return res;
+}
+
+static stbi_uc *tga_load(stbi *s, int *x, int *y, int *comp, int req_comp)
+{
+   //   read in the TGA header stuff
+   int tga_offset = get8u(s);
+   int tga_indexed = get8u(s);
+   int tga_image_type = get8u(s);
+   int tga_is_RLE = 0;
+   int tga_palette_start = get16le(s);
+   int tga_palette_len = get16le(s);
+   int tga_palette_bits = get8u(s);
+   int tga_x_origin = get16le(s);
+   int tga_y_origin = get16le(s);
+   int tga_width = get16le(s);
+   int tga_height = get16le(s);
+   int tga_bits_per_pixel = get8u(s);
+   int tga_inverted = get8u(s);
+   //   image data
+   unsigned char *tga_data;
+   unsigned char *tga_palette = NULL;
+   int i, j;
+   unsigned char raw_data[4];
+   unsigned char trans_data[4];
+   int RLE_count = 0;
+   int RLE_repeating = 0;
+   int read_next_pixel = 1;
+
+   //   do a tiny bit of precessing
+   if ( tga_image_type >= 8 )
+   {
+      tga_image_type -= 8;
+      tga_is_RLE = 1;
+   }
+   /* int tga_alpha_bits = tga_inverted & 15; */
+   tga_inverted = 1 - ((tga_inverted >> 5) & 1);
+
+   //   error check
+   if ( //(tga_indexed) ||
+      (tga_width < 1) || (tga_height < 1) ||
+      (tga_image_type < 1) || (tga_image_type > 3) ||
+      ((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16) &&
+      (tga_bits_per_pixel != 24) && (tga_bits_per_pixel != 32))
+      )
+   {
+      return NULL; // we don't report this as a bad TGA because we don't even know if it's TGA
+   }
+
+   //   If I'm paletted, then I'll use the number of bits from the palette
+   if ( tga_indexed )
+   {
+      tga_bits_per_pixel = tga_palette_bits;
+   }
+
+   //   tga info
+   *x = tga_width;
+   *y = tga_height;
+   if ( (req_comp < 1) || (req_comp > 4) )
+   {
+      //   just use whatever the file was
+      req_comp = tga_bits_per_pixel / 8;
+      *comp = req_comp;
+   } else
+   {
+      //   force a new number of components
+      *comp = tga_bits_per_pixel/8;
+   }
+   tga_data = (unsigned char*)malloc( tga_width * tga_height * req_comp );
+   if (!tga_data) return epuc("outofmem", "Out of memory");
+
+   //   skip to the data's starting position (offset usually = 0)
+   skip(s, tga_offset );
+   //   do I need to load a palette?
+   if ( tga_indexed )
+   {
+      //   any data to skip? (offset usually = 0)
+      skip(s, tga_palette_start );
+      //   load the palette
+      tga_palette = (unsigned char*)malloc( tga_palette_len * tga_palette_bits / 8 );
+      if (!tga_palette) return epuc("outofmem", "Out of memory");
+      if (!getn(s, tga_palette, tga_palette_len * tga_palette_bits / 8 )) {
+         free(tga_data);
+         free(tga_palette);
+         return epuc("bad palette", "Corrupt TGA");
+      }
+   }
+   //   load the data
+   trans_data[0] = trans_data[1] = trans_data[2] = trans_data[3] = 0;
+   for (i=0; i < tga_width * tga_height; ++i)
+   {
+      //   if I'm in RLE mode, do I need to get a RLE chunk?
+      if ( tga_is_RLE )
+      {
+         if ( RLE_count == 0 )
+         {
+            //   yep, get the next byte as a RLE command
+            int RLE_cmd = get8u(s);
+            RLE_count = 1 + (RLE_cmd & 127);
+            RLE_repeating = RLE_cmd >> 7;
+            read_next_pixel = 1;
+         } else if ( !RLE_repeating )
+         {
+            read_next_pixel = 1;
+         }
+      } else
+      {
+         read_next_pixel = 1;
+      }
+      //   OK, if I need to read a pixel, do it now
+      if ( read_next_pixel )
+      {
+         //   load however much data we did have
+         if ( tga_indexed )
+         {
+            //   read in 1 byte, then perform the lookup
+            int pal_idx = get8u(s);
+            if ( pal_idx >= tga_palette_len )
+            {
+               //   invalid index
+               pal_idx = 0;
+            }
+            pal_idx *= tga_bits_per_pixel / 8;
+            for (j = 0; j*8 < tga_bits_per_pixel; ++j)
+            {
+               raw_data[j] = tga_palette[pal_idx+j];
+            }
+         } else
+         {
+            //   read in the data raw
+            for (j = 0; j*8 < tga_bits_per_pixel; ++j)
+            {
+               raw_data[j] = get8u(s);
+            }
+         }
+         //   convert raw to the intermediate format
+         switch (tga_bits_per_pixel)
+         {
+         case 8:
+            //   Luminous => RGBA
+            trans_data[0] = raw_data[0];
+            trans_data[1] = raw_data[0];
+            trans_data[2] = raw_data[0];
+            trans_data[3] = 255;
+            break;
+         case 16:
+            //   Luminous,Alpha => RGBA
+            trans_data[0] = raw_data[0];
+            trans_data[1] = raw_data[0];
+            trans_data[2] = raw_data[0];
+            trans_data[3] = raw_data[1];
+            break;
+         case 24:
+            //   BGR => RGBA
+            trans_data[0] = raw_data[2];
+            trans_data[1] = raw_data[1];
+            trans_data[2] = raw_data[0];
+            trans_data[3] = 255;
+            break;
+         case 32:
+            //   BGRA => RGBA
+            trans_data[0] = raw_data[2];
+            trans_data[1] = raw_data[1];
+            trans_data[2] = raw_data[0];
+            trans_data[3] = raw_data[3];
+            break;
+         }
+         //   clear the reading flag for the next pixel
+         read_next_pixel = 0;
+      } // end of reading a pixel
+      //   convert to final format
+      switch (req_comp)
+      {
+      case 1:
+         //   RGBA => Luminance
+         tga_data[i*req_comp+0] = compute_y(trans_data[0],trans_data[1],trans_data[2]);
+         break;
+      case 2:
+         //   RGBA => Luminance,Alpha
+         tga_data[i*req_comp+0] = compute_y(trans_data[0],trans_data[1],trans_data[2]);
+         tga_data[i*req_comp+1] = trans_data[3];
+         break;
+      case 3:
+         //   RGBA => RGB
+         tga_data[i*req_comp+0] = trans_data[0];
+         tga_data[i*req_comp+1] = trans_data[1];
+         tga_data[i*req_comp+2] = trans_data[2];
+         break;
+      case 4:
+         //   RGBA => RGBA
+         tga_data[i*req_comp+0] = trans_data[0];
+         tga_data[i*req_comp+1] = trans_data[1];
+         tga_data[i*req_comp+2] = trans_data[2];
+         tga_data[i*req_comp+3] = trans_data[3];
+         break;
+      }
+      //   in case we're in RLE mode, keep counting down
+      --RLE_count;
+   }
+   //   do I need to invert the image?
+   if ( tga_inverted )
+   {
+      for (j = 0; j*2 < tga_height; ++j)
+      {
+         int index1 = j * tga_width * req_comp;
+         int index2 = (tga_height - 1 - j) * tga_width * req_comp;
+         for (i = tga_width * req_comp; i > 0; --i)
+         {
+            unsigned char temp = tga_data[index1];
+            tga_data[index1] = tga_data[index2];
+            tga_data[index2] = temp;
+            ++index1;
+            ++index2;
+         }
+      }
+   }
+   //   clear my palette, if I had one
+   if ( tga_palette != NULL )
+   {
+      free( tga_palette );
+   }
+   //   the things I do to get rid of an error message, and yet keep
+   //   Microsoft's C compilers happy... [8^(
+   tga_palette_start = tga_palette_len = tga_palette_bits =
+         tga_x_origin = tga_y_origin = 0;
+   //   OK, done
+   return tga_data;
+}
+
+static stbi_uc *stbi_tga_load(stbi *s, int *x, int *y, int *comp, int req_comp)
+{
+   return tga_load(s,x,y,comp,req_comp);
+}
+
+
+// *************************************************************************************************
+// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB
+
+static int psd_test(stbi *s)
+{
+   if (get32(s) != 0x38425053) return 0;   // "8BPS"
+   else return 1;
+}
+
+static int stbi_psd_test(stbi *s)
+{
+   int r = psd_test(s);
+   stbi_rewind(s);
+   return r;
+}
+
+static stbi_uc *psd_load(stbi *s, int *x, int *y, int *comp, int req_comp)
+{
+   int   pixelCount;
+   int channelCount, compression;
+   int channel, i, count, len;
+   int w,h;
+   uint8 *out;
+
+   // Check identifier
+   if (get32(s) != 0x38425053)   // "8BPS"
+      return epuc("not PSD", "Corrupt PSD image");
+
+   // Check file type version.
+   if (get16(s) != 1)
+      return epuc("wrong version", "Unsupported version of PSD image");
+
+   // Skip 6 reserved bytes.
+   skip(s, 6 );
+
+   // Read the number of channels (R, G, B, A, etc).
+   channelCount = get16(s);
+   if (channelCount < 0 || channelCount > 16)
+      return epuc("wrong channel count", "Unsupported number of channels in PSD image");
+
+   // Read the rows and columns of the image.
+   h = get32(s);
+   w = get32(s);
+   
+   // Make sure the depth is 8 bits.
+   if (get16(s) != 8)
+      return epuc("unsupported bit depth", "PSD bit depth is not 8 bit");
+
+   // Make sure the color mode is RGB.
+   // Valid options are:
+   //   0: Bitmap
+   //   1: Grayscale
+   //   2: Indexed color
+   //   3: RGB color
+   //   4: CMYK color
+   //   7: Multichannel
+   //   8: Duotone
+   //   9: Lab color
+   if (get16(s) != 3)
+      return epuc("wrong color format", "PSD is not in RGB color format");
+
+   // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
+   skip(s,get32(s) );
+
+   // Skip the image resources.  (resolution, pen tool paths, etc)
+   skip(s, get32(s) );
+
+   // Skip the reserved data.
+   skip(s, get32(s) );
+
+   // Find out if the data is compressed.
+   // Known values:
+   //   0: no compression
+   //   1: RLE compressed
+   compression = get16(s);
+   if (compression > 1)
+      return epuc("bad compression", "PSD has an unknown compression format");
+
+   // Create the destination image.
+   out = (stbi_uc *) malloc(4 * w*h);
+   if (!out) return epuc("outofmem", "Out of memory");
+   pixelCount = w*h;
+
+   // Initialize the data to zero.
+   //memset( out, 0, pixelCount * 4 );
+   
+   // Finally, the image data.
+   if (compression) {
+      // RLE as used by .PSD and .TIFF
+      // Loop until you get the number of unpacked bytes you are expecting:
+      //     Read the next source byte into n.
+      //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
+      //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
+      //     Else if n is 128, noop.
+      // Endloop
+
+      // The RLE-compressed data is preceeded by a 2-byte data count for each row in the data,
+      // which we're going to just skip.
+      skip(s, h * channelCount * 2 );
+
+      // Read the RLE data by channel.
+      for (channel = 0; channel < 4; channel++) {
+         uint8 *p;
+         
+         p = out+channel;
+         if (channel >= channelCount) {
+            // Fill this channel with default data.
+            for (i = 0; i < pixelCount; i++) *p = (channel == 3 ? 255 : 0), p += 4;
+         } else {
+            // Read the RLE data.
+            count = 0;
+            while (count < pixelCount) {
+               len = get8(s);
+               if (len == 128) {
+                  // No-op.
+               } else if (len < 128) {
+                  // Copy next len+1 bytes literally.
+                  len++;
+                  count += len;
+                  while (len) {
+                     *p = get8u(s);
+                     p += 4;
+                     len--;
+                  }
+               } else if (len > 128) {
+                  uint8   val;
+                  // Next -len+1 bytes in the dest are replicated from next source byte.
+                  // (Interpret len as a negative 8-bit int.)
+                  len ^= 0x0FF;
+                  len += 2;
+                  val = get8u(s);
+                  count += len;
+                  while (len) {
+                     *p = val;
+                     p += 4;
+                     len--;
+                  }
+               }
+            }
+         }
+      }
+      
+   } else {
+      // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
+      // where each channel consists of an 8-bit value for each pixel in the image.
+      
+      // Read the data by channel.
+      for (channel = 0; channel < 4; channel++) {
+         uint8 *p;
+         
+         p = out + channel;
+         if (channel > channelCount) {
+            // Fill this channel with default data.
+            for (i = 0; i < pixelCount; i++) *p = channel == 3 ? 255 : 0, p += 4;
+         } else {
+            // Read the data.
+            for (i = 0; i < pixelCount; i++)
+               *p = get8u(s), p += 4;
+         }
+      }
+   }
+
+   if (req_comp && req_comp != 4) {
+      out = convert_format(out, 4, req_comp, w, h);
+      if (out == NULL) return out; // convert_format frees input on failure
+   }
+
+   if (comp) *comp = channelCount;
+   *y = h;
+   *x = w;
+   
+   return out;
+}
+
+static stbi_uc *stbi_psd_load(stbi *s, int *x, int *y, int *comp, int req_comp)
+{
+   return psd_load(s,x,y,comp,req_comp);
+}
+
+// *************************************************************************************************
+// Softimage PIC loader
+// by Tom Seddon
+//
+// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
+// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/
+
+static int pic_is4(stbi *s,const char *str)
+{
+   int i;
+   for (i=0; i<4; ++i)
+      if (get8(s) != (stbi_uc)str[i])
+         return 0;
+
+   return 1;
+}
+
+static int pic_test(stbi *s)
+{
+   int i;
+
+   if (!pic_is4(s,"\x53\x80\xF6\x34"))
+      return 0;
+
+   for(i=0;i<84;++i)
+      get8(s);
+
+   if (!pic_is4(s,"PICT"))
+      return 0;
+
+   return 1;
+}
+
+typedef struct
+{
+   stbi_uc size,type,channel;
+} pic_packet_t;
+
+static stbi_uc *pic_readval(stbi *s, int channel, stbi_uc *dest)
+{
+   int mask=0x80, i;
+
+   for (i=0; i<4; ++i, mask>>=1) {
+      if (channel & mask) {
+         if (at_eof(s)) return epuc("bad file","PIC file too short");
+         dest[i]=get8u(s);
+      }
+   }
+
+   return dest;
+}
+
+static void pic_copyval(int channel,stbi_uc *dest,const stbi_uc *src)
+{
+   int mask=0x80,i;
+
+   for (i=0;i<4; ++i, mask>>=1)
+      if (channel&mask)
+         dest[i]=src[i];
+}
+
+static stbi_uc *pic_load2(stbi *s,int width,int height,int *comp, stbi_uc *result)
+{
+   int act_comp=0,num_packets=0,y,chained;
+   pic_packet_t packets[10];
+
+   // this will (should...) cater for even some bizarre stuff like having data
+    // for the same channel in multiple packets.
+   do {
+      pic_packet_t *packet;
+
+      if (num_packets==sizeof(packets)/sizeof(packets[0]))
+         return epuc("bad format","too many packets");
+
+      packet = &packets[num_packets++];
+
+      chained = get8(s);
+      packet->size    = get8u(s);
+      packet->type    = get8u(s);
+      packet->channel = get8u(s);
+
+      act_comp |= packet->channel;
+
+      if (at_eof(s))          return epuc("bad file","file too short (reading packets)");
+      if (packet->size != 8)  return epuc("bad format","packet isn't 8bpp");
+   } while (chained);
+
+   *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?
+
+   for(y=0; y<height; ++y) {
+      int packet_idx;
+
+      for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {
+         pic_packet_t *packet = &packets[packet_idx];
+         stbi_uc *dest = result+y*width*4;
+
+         switch (packet->type) {
+            default:
+               return epuc("bad format","packet has bad compression type");
+
+            case 0: {//uncompressed
+               int x;
+
+               for(x=0;x<width;++x, dest+=4)
+                  if (!pic_readval(s,packet->channel,dest))
+                     return 0;
+               break;
+            }
+
+            case 1://Pure RLE
+               {
+                  int left=width, i;
+
+                  while (left>0) {
+                     stbi_uc count,value[4];
+
+                     count=get8u(s);
+                     if (at_eof(s))   return epuc("bad file","file too short (pure read count)");
+
+                     if (count > left)
+                        count = (uint8) left;
+
+                     if (!pic_readval(s,packet->channel,value))  return 0;
+
+                     for(i=0; i<count; ++i,dest+=4)
+                        pic_copyval(packet->channel,dest,value);
+                     left -= count;
+                  }
+               }
+               break;
+
+            case 2: {//Mixed RLE
+               int left=width;
+               while (left>0) {
+                  int count = get8(s), i;
+                  if (at_eof(s))  return epuc("bad file","file too short (mixed read count)");
+
+                  if (count >= 128) { // Repeated
+                     stbi_uc value[4];
+                     int i;
+
+                     if (count==128)
+                        count = get16(s);
+                     else
+                        count -= 127;
+                     if (count > left)
+                        return epuc("bad file","scanline overrun");
+
+                     if (!pic_readval(s,packet->channel,value))
+                        return 0;
+
+                     for(i=0;i<count;++i, dest += 4)
+                        pic_copyval(packet->channel,dest,value);
+                  } else { // Raw
+                     ++count;
+                     if (count>left) return epuc("bad file","scanline overrun");
+
+                     for(i=0;i<count;++i, dest+=4)
+                        if (!pic_readval(s,packet->channel,dest))
+                           return 0;
+                  }
+                  left-=count;
+               }
+               break;
+            }
+         }
+      }
+   }
+
+   return result;
+}
+
+static stbi_uc *pic_load(stbi *s,int *px,int *py,int *comp,int req_comp)
+{
+   stbi_uc *result;
+   int i, x,y;
+
+   for (i=0; i<92; ++i)
+      get8(s);
+
+   x = get16(s);
+   y = get16(s);
+   if (at_eof(s))  return epuc("bad file","file too short (pic header)");
+   if ((1 << 28) / x < y) return epuc("too large", "Image too large to decode");
+
+   get32(s); //skip `ratio'
+   get16(s); //skip `fields'
+   get16(s); //skip `pad'
+
+   // intermediate buffer is RGBA
+   result = (stbi_uc *) malloc(x*y*4);
+   memset(result, 0xff, x*y*4);
+
+   if (!pic_load2(s,x,y,comp, result)) {
+      free(result);
+      result=0;
+   }
+   *px = x;
+   *py = y;
+   if (req_comp == 0) req_comp = *comp;
+   result=convert_format(result,4,req_comp,x,y);
+
+   return result;
+}
+
+static int stbi_pic_test(stbi *s)
+{
+   int r = pic_test(s);
+   stbi_rewind(s);
+   return r;
+}
+
+static stbi_uc *stbi_pic_load(stbi *s, int *x, int *y, int *comp, int req_comp)
+{
+   return pic_load(s,x,y,comp,req_comp);
+}
+
+// *************************************************************************************************
+// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb
+typedef struct stbi_gif_lzw_struct {
+   int16 prefix;
+   uint8 first;
+   uint8 suffix;
+} stbi_gif_lzw;
+
+typedef struct stbi_gif_struct
+{
+   int w,h;
+   stbi_uc *out;                 // output buffer (always 4 components)
+   int flags, bgindex, ratio, transparent, eflags;
+   uint8  pal[256][4];
+   uint8 lpal[256][4];
+   stbi_gif_lzw codes[4096];
+   uint8 *color_table;
+   int parse, step;
+   int lflags;
+   int start_x, start_y;
+   int max_x, max_y;
+   int cur_x, cur_y;
+   int line_size;
+} stbi_gif;
+
+static int gif_test(stbi *s)
+{
+   int sz;
+   if (get8(s) != 'G' || get8(s) != 'I' || get8(s) != 'F' || get8(s) != '8') return 0;
+   sz = get8(s);
+   if (sz != '9' && sz != '7') return 0;
+   if (get8(s) != 'a') return 0;
+   return 1;
+}
+
+static int stbi_gif_test(stbi *s)
+{
+   int r = gif_test(s);
+   stbi_rewind(s);
+   return r;
+}
+
+static void stbi_gif_parse_colortable(stbi *s, uint8 pal[256][4], int num_entries, int transp)
+{
+   int i;
+   for (i=0; i < num_entries; ++i) {
+      pal[i][2] = get8u(s);
+      pal[i][1] = get8u(s);
+      pal[i][0] = get8u(s);
+      pal[i][3] = transp ? 0 : 255;
+   }   
+}
+
+static int stbi_gif_header(stbi *s, stbi_gif *g, int *comp, int is_info)
+{
+   uint8 version;
+   if (get8(s) != 'G' || get8(s) != 'I' || get8(s) != 'F' || get8(s) != '8')
+      return e("not GIF", "Corrupt GIF");
+
+   version = get8u(s);
+   if (version != '7' && version != '9')    return e("not GIF", "Corrupt GIF");
+   if (get8(s) != 'a')                      return e("not GIF", "Corrupt GIF");
+ 
+   failure_reason = "";
+   g->w = get16le(s);
+   g->h = get16le(s);
+   g->flags = get8(s);
+   g->bgindex = get8(s);
+   g->ratio = get8(s);
+   g->transparent = -1;
+
+   if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments
+
+   if (is_info) return 1;
+
+   if (g->flags & 0x80)
+      stbi_gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);
+
+   return 1;
+}
+
+static int stbi_gif_info_raw(stbi *s, int *x, int *y, int *comp)
+{
+   stbi_gif g;   
+   if (!stbi_gif_header(s, &g, comp, 1)) {
+      stbi_rewind( s );
+      return 0;
+   }
+   if (x) *x = g.w;
+   if (y) *y = g.h;
+   return 1;
+}
+
+static void stbi_out_gif_code(stbi_gif *g, uint16 code)
+{
+   uint8 *p, *c;
+
+   // recurse to decode the prefixes, since the linked-list is backwards,
+   // and working backwards through an interleaved image would be nasty
+   if (g->codes[code].prefix >= 0)
+      stbi_out_gif_code(g, g->codes[code].prefix);
+
+   if (g->cur_y >= g->max_y) return;
+  
+   p = &g->out[g->cur_x + g->cur_y];
+   c = &g->color_table[g->codes[code].suffix * 4];
+
+   if (c[3] >= 128) {
+      p[0] = c[2];
+      p[1] = c[1];
+      p[2] = c[0];
+      p[3] = c[3];
+   }
+   g->cur_x += 4;
+
+   if (g->cur_x >= g->max_x) {
+      g->cur_x = g->start_x;
+      g->cur_y += g->step;
+
+      while (g->cur_y >= g->max_y && g->parse > 0) {
+         g->step = (1 << g->parse) * g->line_size;
+         g->cur_y = g->start_y + (g->step >> 1);
+         --g->parse;
+      }
+   }
+}
+
+static uint8 *stbi_process_gif_raster(stbi *s, stbi_gif *g)
+{
+   uint8 lzw_cs;
+   int32 len, code;
+   uint32 first;
+   int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
+   stbi_gif_lzw *p;
+
+   lzw_cs = get8u(s);
+   clear = 1 << lzw_cs;
+   first = 1;
+   codesize = lzw_cs + 1;
+   codemask = (1 << codesize) - 1;
+   bits = 0;
+   valid_bits = 0;
+   for (code = 0; code < clear; code++) {
+      g->codes[code].prefix = -1;
+      g->codes[code].first = (uint8) code;
+      g->codes[code].suffix = (uint8) code;
+   }
+
+   // support no starting clear code
+   avail = clear+2;
+   oldcode = -1;
+
+   len = 0;
+   for(;;) {
+      if (valid_bits < codesize) {
+         if (len == 0) {
+            len = get8(s); // start new block
+            if (len == 0) 
+               return g->out;
+         }
+         --len;
+         bits |= (int32) get8(s) << valid_bits;
+         valid_bits += 8;
+      } else {
+         int32 code = bits & codemask;
+         bits >>= codesize;
+         valid_bits -= codesize;
+         // @OPTIMIZE: is there some way we can accelerate the non-clear path?
+         if (code == clear) {  // clear code
+            codesize = lzw_cs + 1;
+            codemask = (1 << codesize) - 1;
+            avail = clear + 2;
+            oldcode = -1;
+            first = 0;
+         } else if (code == clear + 1) { // end of stream code
+            skip(s, len);
+            while ((len = get8(s)) > 0)
+               skip(s,len);
+            return g->out;
+         } else if (code <= avail) {
+            if (first) return epuc("no clear code", "Corrupt GIF");
+
+            if (oldcode >= 0) {
+               p = &g->codes[avail++];
+               if (avail > 4096)        return epuc("too many codes", "Corrupt GIF");
+               p->prefix = (int16) oldcode;
+               p->first = g->codes[oldcode].first;
+               p->suffix = (code == avail) ? p->first : g->codes[code].first;
+            } else if (code == avail)
+               return epuc("illegal code in raster", "Corrupt GIF");
+
+            stbi_out_gif_code(g, (uint16) code);
+
+            if ((avail & codemask) == 0 && avail <= 0x0FFF) {
+               codesize++;
+               codemask = (1 << codesize) - 1;
+            }
+
+            oldcode = code;
+         } else {
+            return epuc("illegal code in raster", "Corrupt GIF");
+         }
+      } 
+   }
+}
+
+static void stbi_fill_gif_background(stbi_gif *g)
+{
+   int i;
+   uint8 *c = g->pal[g->bgindex];
+   // @OPTIMIZE: write a dword at a time
+   for (i = 0; i < g->w * g->h * 4; i += 4) {
+      uint8 *p  = &g->out[i];
+      p[0] = c[2];
+      p[1] = c[1];
+      p[2] = c[0];
+      p[3] = c[3];
+   }
+}
+
+// this function is designed to support animated gifs, although stb_image doesn't support it
+static uint8 *stbi_gif_load_next(stbi *s, stbi_gif *g, int *comp, int req_comp)
+{
+   int i;
+   uint8 *old_out = 0;
+
+   if (g->out == 0) {
+      if (!stbi_gif_header(s, g, comp,0))     return 0; // failure_reason set by stbi_gif_header
+      g->out = (uint8 *) malloc(4 * g->w * g->h);
+      if (g->out == 0)                      return epuc("outofmem", "Out of memory");
+      stbi_fill_gif_background(g);
+   } else {
+      // animated-gif-only path
+      if (((g->eflags & 0x1C) >> 2) == 3) {
+         old_out = g->out;
+         g->out = (uint8 *) malloc(4 * g->w * g->h);
+         if (g->out == 0)                   return epuc("outofmem", "Out of memory");
+         memcpy(g->out, old_out, g->w*g->h*4);
+      }
+   }
+    
+   for (;;) {
+      switch (get8(s)) {
+         case 0x2C: /* Image Descriptor */
+         {
+            int32 x, y, w, h;
+            uint8 *o;
+
+            x = get16le(s);
+            y = get16le(s);
+            w = get16le(s);
+            h = get16le(s);
+            if (((x + w) > (g->w)) || ((y + h) > (g->h)))
+               return epuc("bad Image Descriptor", "Corrupt GIF");
+
+            g->line_size = g->w * 4;
+            g->start_x = x * 4;
+            g->start_y = y * g->line_size;
+            g->max_x   = g->start_x + w * 4;
+            g->max_y   = g->start_y + h * g->line_size;
+            g->cur_x   = g->start_x;
+            g->cur_y   = g->start_y;
+
+            g->lflags = get8(s);
+
+            if (g->lflags & 0x40) {
+               g->step = 8 * g->line_size; // first interlaced spacing
+               g->parse = 3;
+            } else {
+               g->step = g->line_size;
+               g->parse = 0;
+            }
+
+            if (g->lflags & 0x80) {
+               stbi_gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
+               g->color_table = (uint8 *) g->lpal;       
+            } else if (g->flags & 0x80) {
+               for (i=0; i < 256; ++i)  // @OPTIMIZE: reset only the previous transparent
+                  g->pal[i][3] = 255; 
+               if (g->transparent >= 0 && (g->eflags & 0x01))
+                  g->pal[g->transparent][3] = 0;
+               g->color_table = (uint8 *) g->pal;
+            } else
+               return epuc("missing color table", "Corrupt GIF");
+   
+            o = stbi_process_gif_raster(s, g);
+            if (o == NULL) return NULL;
+
+            if (req_comp && req_comp != 4)
+               o = convert_format(o, 4, req_comp, g->w, g->h);
+            return o;
+         }
+
+         case 0x21: // Comment Extension.
+         {
+            int len;
+            if (get8(s) == 0xF9) { // Graphic Control Extension.
+               len = get8(s);
+               if (len == 4) {
+                  g->eflags = get8(s);
+                  get16le(s); // delay
+                  g->transparent = get8(s);
+               } else {
+                  skip(s, len);
+                  break;
+               }
+            }
+            while ((len = get8(s)) != 0)
+               skip(s, len);
+            break;
+         }
+
+         case 0x3B: // gif stream termination code
+            return (uint8 *) 1;
+
+         default:
+            return epuc("unknown code", "Corrupt GIF");
+      }
+   }
+}
+
+static stbi_uc *stbi_gif_load(stbi *s, int *x, int *y, int *comp, int req_comp)
+{
+   uint8 *u = 0;
+   stbi_gif g={0};
+
+   u = stbi_gif_load_next(s, &g, comp, req_comp);
+   if (u == (void *) 1) u = 0;  // end of animated gif marker
+   if (u) {
+      *x = g.w;
+      *y = g.h;
+   }
+
+   return u;
+}
+
+static int stbi_gif_info(stbi *s, int *x, int *y, int *comp)
+{
+   return stbi_gif_info_raw(s,x,y,comp);
+}
+
+
+// *************************************************************************************************
+// Radiance RGBE HDR loader
+// originally by Nicolas Schulz
+#ifndef STBI_NO_HDR
+static int hdr_test(stbi *s)
+{
+   const char *signature = "#?RADIANCE\n";
+   int i;
+   for (i=0; signature[i]; ++i)
+      if (get8(s) != signature[i])
+         return 0;
+   return 1;
+}
+
+static int stbi_hdr_test(stbi* s)
+{
+   int r = hdr_test(s);
+   stbi_rewind(s);
+   return r;
+}
+
+#define HDR_BUFLEN  1024
+static char *hdr_gettoken(stbi *z, char *buffer)
+{
+   int len=0;
+   char c = '\0';
+
+   c = (char) get8(z);
+
+   while (!at_eof(z) && c != '\n') {
+      buffer[len++] = c;
+      if (len == HDR_BUFLEN-1) {
+         // flush to end of line
+         while (!at_eof(z) && get8(z) != '\n')
+            ;
+         break;
+      }
+      c = (char) get8(z);
+   }
+
+   buffer[len] = 0;
+   return buffer;
+}
+
+static void hdr_convert(float *output, stbi_uc *input, int req_comp)
+{
+   if ( input[3] != 0 ) {
+      float f1;
+      // Exponent
+      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
+      if (req_comp <= 2)
+         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
+      else {
+         output[0] = input[0] * f1;
+         output[1] = input[1] * f1;
+         output[2] = input[2] * f1;
+      }
+      if (req_comp == 2) output[1] = 1;
+      if (req_comp == 4) output[3] = 1;
+   } else {
+      switch (req_comp) {
+         case 4: output[3] = 1; /* fallthrough */
+         case 3: output[0] = output[1] = output[2] = 0;
+                 break;
+         case 2: output[1] = 1; /* fallthrough */
+         case 1: output[0] = 0;
+                 break;
+      }
+   }
+}
+
+static float *hdr_load(stbi *s, int *x, int *y, int *comp, int req_comp)
+{
+   char buffer[HDR_BUFLEN];
+   char *token;
+   int valid = 0;
+   int width, height;
+   stbi_uc *scanline;
+   float *hdr_data;
+   int len;
+   unsigned char count, value;
+   int i, j, k, c1,c2, z;
+
+
+   // Check identifier
+   if (strcmp(hdr_gettoken(s,buffer), "#?RADIANCE") != 0)
+      return epf("not HDR", "Corrupt HDR image");
+   
+   // Parse header
+   for(;;) {
+      token = hdr_gettoken(s,buffer);
+      if (token[0] == 0) break;
+      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
+   }
+
+   if (!valid)    return epf("unsupported format", "Unsupported HDR format");
+
+   // Parse width and height
+   // can't use sscanf() if we're not using stdio!
+   token = hdr_gettoken(s,buffer);
+   if (strncmp(token, "-Y ", 3))  return epf("unsupported data layout", "Unsupported HDR format");
+   token += 3;
+   height = strtol(token, &token, 10);
+   while (*token == ' ') ++token;
+   if (strncmp(token, "+X ", 3))  return epf("unsupported data layout", "Unsupported HDR format");
+   token += 3;
+   width = strtol(token, NULL, 10);
+
+   *x = width;
+   *y = height;
+
+   *comp = 3;
+   if (req_comp == 0) req_comp = 3;
+
+   // Read data
+   hdr_data = (float *) malloc(height * width * req_comp * sizeof(float));
+
+   // Load image data
+   // image data is stored as some number of sca
+   if ( width < 8 || width >= 32768) {
+      // Read flat data
+      for (j=0; j < height; ++j) {
+         for (i=0; i < width; ++i) {
+            stbi_uc rgbe[4];
+           main_decode_loop:
+            getn(s, rgbe, 4);
+            hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
+         }
+      }
+   } else {
+      // Read RLE-encoded data
+      scanline = NULL;
+
+      for (j = 0; j < height; ++j) {
+         c1 = get8(s);
+         c2 = get8(s);
+         len = get8(s);
+         if (c1 != 2 || c2 != 2 || (len & 0x80)) {
+            // not run-length encoded, so we have to actually use THIS data as a decoded
+            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
+            uint8 rgbe[4];
+            rgbe[0] = (uint8) c1;
+            rgbe[1] = (uint8) c2;
+            rgbe[2] = (uint8) len;
+            rgbe[3] = (uint8) get8u(s);
+            hdr_convert(hdr_data, rgbe, req_comp);
+            i = 1;
+            j = 0;
+            free(scanline);
+            goto main_decode_loop; // yes, this makes no sense
+         }
+         len <<= 8;
+         len |= get8(s);
+         if (len != width) { free(hdr_data); free(scanline); return epf("invalid decoded scanline length", "corrupt HDR"); }
+         if (scanline == NULL) scanline = (stbi_uc *) malloc(width * 4);
+            
+         for (k = 0; k < 4; ++k) {
+            i = 0;
+            while (i < width) {
+               count = get8u(s);
+               if (count > 128) {
+                  // Run
+                  value = get8u(s);
+                  count -= 128;
+                  for (z = 0; z < count; ++z)
+                     scanline[i++ * 4 + k] = value;
+               } else {
+                  // Dump
+                  for (z = 0; z < count; ++z)
+                     scanline[i++ * 4 + k] = get8u(s);
+               }
+            }
+         }
+         for (i=0; i < width; ++i)
+            hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);
+      }
+      free(scanline);
+   }
+
+   return hdr_data;
+}
+
+static float *stbi_hdr_load(stbi *s, int *x, int *y, int *comp, int req_comp)
+{
+   return hdr_load(s,x,y,comp,req_comp);
+}
+
+static int stbi_hdr_info(stbi *s, int *x, int *y, int *comp)
+{
+   char buffer[HDR_BUFLEN];
+   char *token;
+   int valid = 0;
+
+   if (strcmp(hdr_gettoken(s,buffer), "#?RADIANCE") != 0) {
+       stbi_rewind( s );
+       return 0;
+   }
+
+   for(;;) {
+      token = hdr_gettoken(s,buffer);
+      if (token[0] == 0) break;
+      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
+   }
+
+   if (!valid) {
+       stbi_rewind( s );
+       return 0;
+   }
+   token = hdr_gettoken(s,buffer);
+   if (strncmp(token, "-Y ", 3)) {
+       stbi_rewind( s );
+       return 0;
+   }
+   token += 3;
+   *y = strtol(token, &token, 10);
+   while (*token == ' ') ++token;
+   if (strncmp(token, "+X ", 3)) {
+       stbi_rewind( s );
+       return 0;
+   }
+   token += 3;
+   *x = strtol(token, NULL, 10);
+   *comp = 3;
+   return 1;
+}
+#endif // STBI_NO_HDR
+
+static int stbi_bmp_info(stbi *s, int *x, int *y, int *comp)
+{
+   int hsz;
+   if (get8(s) != 'B' || get8(s) != 'M') {
+       stbi_rewind( s );
+       return 0;
+   }
+   skip(s,12);
+   hsz = get32le(s);
+   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108) {
+       stbi_rewind( s );
+       return 0;
+   }
+   if (hsz == 12) {
+      *x = get16le(s);
+      *y = get16le(s);
+   } else {
+      *x = get32le(s);
+      *y = get32le(s);
+   }
+   if (get16le(s) != 1) {
+       stbi_rewind( s );
+       return 0;
+   }
+   *comp = get16le(s) / 8;
+   return 1;
+}
+
+static int stbi_psd_info(stbi *s, int *x, int *y, int *comp)
+{
+   int channelCount;
+   if (get32(s) != 0x38425053) {
+       stbi_rewind( s );
+       return 0;
+   }
+   if (get16(s) != 1) {
+       stbi_rewind( s );
+       return 0;
+   }
+   skip(s, 6);
+   channelCount = get16(s);
+   if (channelCount < 0 || channelCount > 16) {
+       stbi_rewind( s );
+       return 0;
+   }
+   *y = get32(s);
+   *x = get32(s);
+   if (get16(s) != 8) {
+       stbi_rewind( s );
+       return 0;
+   }
+   if (get16(s) != 3) {
+       stbi_rewind( s );
+       return 0;
+   }
+   *comp = 4;
+   return 1;
+}
+
+static int stbi_pic_info(stbi *s, int *x, int *y, int *comp)
+{
+   int act_comp=0,num_packets=0,chained;
+   pic_packet_t packets[10];
+
+   skip(s, 92);
+
+   *x = get16(s);
+   *y = get16(s);
+   if (at_eof(s))  return 0;
+   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {
+       stbi_rewind( s );
+       return 0;
+   }
+
+   skip(s, 8);
+
+   do {
+      pic_packet_t *packet;
+
+      if (num_packets==sizeof(packets)/sizeof(packets[0]))
+         return 0;
+
+      packet = &packets[num_packets++];
+      chained = get8(s);
+      packet->size    = get8u(s);
+      packet->type    = get8u(s);
+      packet->channel = get8u(s);
+      act_comp |= packet->channel;
+
+      if (at_eof(s)) {
+          stbi_rewind( s );
+          return 0;
+      }
+      if (packet->size != 8) {
+          stbi_rewind( s );
+          return 0;
+      }
+   } while (chained);
+
+   *comp = (act_comp & 0x10 ? 4 : 3);
+
+   return 1;
+}
+
+static int stbi_info_main(stbi *s, int *x, int *y, int *comp)
+{
+   if (stbi_jpeg_info(s, x, y, comp))
+       return 1;
+   if (stbi_png_info(s, x, y, comp))
+       return 1;
+   if (stbi_gif_info(s, x, y, comp))
+       return 1;
+   if (stbi_bmp_info(s, x, y, comp))
+       return 1;
+   if (stbi_psd_info(s, x, y, comp))
+       return 1;
+   if (stbi_pic_info(s, x, y, comp))
+       return 1;
+   #ifndef STBI_NO_HDR
+   if (stbi_hdr_info(s, x, y, comp))
+       return 1;
+   #endif
+   // test tga last because it's a crappy test!
+   if (stbi_tga_info(s, x, y, comp))
+       return 1;
+   return e("unknown image type", "Image not of any known type, or corrupt");
+}
+
+#ifndef STBI_NO_STDIO
+int stbi_info(char const *filename, int *x, int *y, int *comp)
+{
+    FILE *f = fopen(filename, "rb");
+    int result;
+    if (!f) return e("can't fopen", "Unable to open file");
+    result = stbi_info_from_file(f, x, y, comp);
+    fclose(f);
+    return result;
+}
+
+int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)
+{
+   int r;
+   stbi s;
+   long pos = ftell(f);
+   start_file(&s, f);
+   r = stbi_info_main(&s,x,y,comp);
+   fseek(f,pos,SEEK_SET);
+   return r;
+}
+#endif // !STBI_NO_STDIO
+
+int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)
+{
+   stbi s;
+   start_mem(&s,buffer,len);
+   return stbi_info_main(&s,x,y,comp);
+}
+
+int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)
+{
+   stbi s;
+   start_callbacks(&s, (stbi_io_callbacks *) c, user);
+   return stbi_info_main(&s,x,y,comp);
+}
+
+#endif // STBI_HEADER_FILE_ONLY
+
+/*
+   revision history:
+      1.33 (2011-07-14)
+             make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements
+      1.32 (2011-07-13)
+             support for "info" function for all supported filetypes (SpartanJ)
+      1.31 (2011-06-20)
+             a few more leak fixes, bug in PNG handling (SpartanJ)
+      1.30 (2011-06-11)
+             added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)
+             removed deprecated format-specific test/load functions
+             removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway
+             error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)
+             fix inefficiency in decoding 32-bit BMP (David Woo)
+      1.29 (2010-08-16)
+             various warning fixes from Aurelien Pocheville 
+      1.28 (2010-08-01)
+             fix bug in GIF palette transparency (SpartanJ)
+      1.27 (2010-08-01)
+             cast-to-uint8 to fix warnings
+      1.26 (2010-07-24)
+             fix bug in file buffering for PNG reported by SpartanJ
+      1.25 (2010-07-17)
+             refix trans_data warning (Won Chun)
+      1.24 (2010-07-12)
+             perf improvements reading from files on platforms with lock-heavy fgetc()
+             minor perf improvements for jpeg
+             deprecated type-specific functions so we'll get feedback if they're needed
+             attempt to fix trans_data warning (Won Chun)
+      1.23   fixed bug in iPhone support
+      1.22 (2010-07-10)
+             removed image *writing* support
+             stbi_info support from Jetro Lauha
+             GIF support from Jean-Marc Lienher
+             iPhone PNG-extensions from James Brown
+             warning-fixes from Nicolas Schulz and Janez Zemva (i.e. Janez (U+017D)emva)
+      1.21   fix use of 'uint8' in header (reported by jon blow)
+      1.20   added support for Softimage PIC, by Tom Seddon
+      1.19   bug in interlaced PNG corruption check (found by ryg)
+      1.18 2008-08-02
+             fix a threading bug (local mutable static)
+      1.17   support interlaced PNG
+      1.16   major bugfix - convert_format converted one too many pixels
+      1.15   initialize some fields for thread safety
+      1.14   fix threadsafe conversion bug
+             header-file-only version (#define STBI_HEADER_FILE_ONLY before including)
+      1.13   threadsafe
+      1.12   const qualifiers in the API
+      1.11   Support installable IDCT, colorspace conversion routines
+      1.10   Fixes for 64-bit (don't use "unsigned long")
+             optimized upsampling by Fabian "ryg" Giesen
+      1.09   Fix format-conversion for PSD code (bad global variables!)
+      1.08   Thatcher Ulrich's PSD code integrated by Nicolas Schulz
+      1.07   attempt to fix C++ warning/errors again
+      1.06   attempt to fix C++ warning/errors again
+      1.05   fix TGA loading to return correct *comp and use good luminance calc
+      1.04   default float alpha is 1, not 255; use 'void *' for stbi_image_free
+      1.03   bugfixes to STBI_NO_STDIO, STBI_NO_HDR
+      1.02   support for (subset of) HDR files, float interface for preferred access to them
+      1.01   fix bug: possible bug in handling right-side up bmps... not sure
+             fix bug: the stbi_bmp_load() and stbi_tga_load() functions didn't work at all
+      1.00   interface to zlib that skips zlib header
+      0.99   correct handling of alpha in palette
+      0.98   TGA loader by lonesock; dynamically add loaders (untested)
+      0.97   jpeg errors on too large a file; also catch another malloc failure
+      0.96   fix detection of invalid v value - particleman@mollyrocket forum
+      0.95   during header scan, seek to markers in case of padding
+      0.94   STBI_NO_STDIO to disable stdio usage; rename all #defines the same
+      0.93   handle jpegtran output; verbose errors
+      0.92   read 4,8,16,24,32-bit BMP files of several formats
+      0.91   output 24-bit Windows 3.0 BMP files
+      0.90   fix a few more warnings; bump version number to approach 1.0
+      0.61   bugfixes due to Marc LeBlanc, Christopher Lloyd
+      0.60   fix compiling as c++
+      0.59   fix warnings: merge Dave Moore's -Wall fixes
+      0.58   fix bug: zlib uncompressed mode len/nlen was wrong endian
+      0.57   fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available
+      0.56   fix bug: zlib uncompressed mode len vs. nlen
+      0.55   fix bug: restart_interval not initialized to 0
+      0.54   allow NULL for 'int *comp'
+      0.53   fix bug in png 3->4; speedup png decoding
+      0.52   png handles req_comp=3,4 directly; minor cleanup; jpeg comments
+      0.51   obey req_comp requests, 1-component jpegs return as 1-component,
+             on 'test' only check type, not whether we support this variant
+      0.50   first released version
+*/
diff --git a/gdx/jni/gdx2d/stb_image.h b/gdx/jni/gdx2d/stb_image.h
deleted file mode 100644
index af6d10b..0000000
--- a/gdx/jni/gdx2d/stb_image.h
+++ /dev/null
@@ -1,4833 +0,0 @@
-/* stb_image - v1.48 - public domain JPEG/PNG reader - http://nothings.org/stb_image.c
-   when you control the images you're loading
-                                     no warranty implied; use at your own risk
-
-   Do this:
-      #define STB_IMAGE_IMPLEMENTATION
-   before you include this file in *one* C or C++ file to create the implementation.
-
-   #define STBI_ASSERT(x) to avoid using assert.h.
-
-   QUICK NOTES:
-      Primarily of interest to game developers and other people who can
-          avoid problematic images and only need the trivial interface
-
-      JPEG baseline (no JPEG progressive)
-      PNG 1/2/4/8-bit-per-channel (16 bpc not supported)
-
-      TGA (not sure what subset, if a subset)
-      BMP non-1bpp, non-RLE
-      PSD (composited view only, no extra channels)
-
-      GIF (*comp always reports as 4-channel)
-      HDR (radiance rgbE format)
-      PIC (Softimage PIC)
-
-      - decode from memory or through FILE (define STBI_NO_STDIO to remove code)
-      - decode from arbitrary I/O callbacks
-      - overridable dequantizing-IDCT, YCbCr-to-RGB conversion (define STBI_SIMD)
-
-   Latest revisions:
-      1.48 (2014-12-14) fix incorrectly-named assert()
-      1.47 (2014-12-14) 1/2/4-bit PNG support (both grayscale and paletted)
-                        optimize PNG
-                        fix bug in interlaced PNG with user-specified channel count
-      1.46 (2014-08-26) fix broken tRNS chunk in non-paletted PNG
-      1.45 (2014-08-16) workaround MSVC-ARM internal compiler error by wrapping malloc
-      1.44 (2014-08-07) warnings
-      1.43 (2014-07-15) fix MSVC-only bug in 1.42
-      1.42 (2014-07-09) no _CRT_SECURE_NO_WARNINGS; error-path fixes; STBI_ASSERT
-      1.41 (2014-06-25) fix search&replace that messed up comments/error messages
-
-   See end of file for full revision history.
-
-   TODO:
-      stbi_info support for BMP,PSD,HDR,PIC
-
-
- ============================    Contributors    =========================
-              
- Image formats                                Bug fixes & warning fixes
-    Sean Barrett (jpeg, png, bmp)                Marc LeBlanc
-    Nicolas Schulz (hdr, psd)                    Christpher Lloyd
-    Jonathan Dummer (tga)                        Dave Moore
-    Jean-Marc Lienher (gif)                      Won Chun
-    Tom Seddon (pic)                             the Horde3D community
-    Thatcher Ulrich (psd)                        Janez Zemva
-                                                 Jonathan Blow
-                                                 Laurent Gomila
- Extensions, features                            Aruelien Pocheville
-    Jetro Lauha (stbi_info)                      Ryamond Barbiero
-    James "moose2000" Brown (iPhone PNG)         David Woo
-    Ben "Disch" Wenger (io callbacks)            Roy Eltham
-    Martin "SpartanJ" Golini                     Luke Graham
-    Omar Cornut (1/2/4-bit png)                  Thomas Ruf
-                                                 John Bartholomew
- Optimizations & bugfixes                        Ken Hamada
-    Fabian "ryg" Giesen                          Cort Stratton
-    Arseny Kapoulkine                            Blazej Dariusz Roszkowski
-                                                 Thibault Reuille
-                                                 Paul Du Bois
-                                                 Guillaume George
-                                                 Jerry Jansson
-  If your name should be here but                Hayaki Saito
-  isn't, let Sean know.                          Johan Duparc
-                                                 Ronny Chevalier
-                                                 Michal Cichon
-*/
-
-#ifndef STBI_INCLUDE_STB_IMAGE_H
-#define STBI_INCLUDE_STB_IMAGE_H
-
-// Limitations:
-//    - no jpeg progressive support
-//    - non-HDR formats support 8-bit samples only (jpeg, png)
-//    - no delayed line count (jpeg) -- IJG doesn't support either
-//    - no 1-bit BMP
-//    - GIF always returns *comp=4
-//
-// Basic usage (see HDR discussion below):
-//    int x,y,n;
-//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);
-//    // ... process data if not NULL ... 
-//    // ... x = width, y = height, n = # 8-bit components per pixel ...
-//    // ... replace '0' with '1'..'4' to force that many components per pixel
-//    // ... but 'n' will always be the number that it would have been if you said 0
-//    stbi_image_free(data)
-//
-// Standard parameters:
-//    int *x       -- outputs image width in pixels
-//    int *y       -- outputs image height in pixels
-//    int *comp    -- outputs # of image components in image file
-//    int req_comp -- if non-zero, # of image components requested in result
-//
-// The return value from an image loader is an 'unsigned char *' which points
-// to the pixel data. The pixel data consists of *y scanlines of *x pixels,
-// with each pixel consisting of N interleaved 8-bit components; the first
-// pixel pointed to is top-left-most in the image. There is no padding between
-// image scanlines or between pixels, regardless of format. The number of
-// components N is 'req_comp' if req_comp is non-zero, or *comp otherwise.
-// If req_comp is non-zero, *comp has the number of components that _would_
-// have been output otherwise. E.g. if you set req_comp to 4, you will always
-// get RGBA output, but you can check *comp to easily see if it's opaque.
-//
-// An output image with N components has the following components interleaved
-// in this order in each pixel:
-//
-//     N=#comp     components
-//       1           grey
-//       2           grey, alpha
-//       3           red, green, blue
-//       4           red, green, blue, alpha
-//
-// If image loading fails for any reason, the return value will be NULL,
-// and *x, *y, *comp will be unchanged. The function stbi_failure_reason()
-// can be queried for an extremely brief, end-user unfriendly explanation
-// of why the load failed. Define STBI_NO_FAILURE_STRINGS to avoid
-// compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly
-// more user-friendly ones.
-//
-// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.
-//
-// ===========================================================================
-//
-// iPhone PNG support:
-//
-// By default we convert iphone-formatted PNGs back to RGB; nominally they
-// would silently load as BGR, except the existing code should have just
-// failed on such iPhone PNGs. But you can disable this conversion by
-// by calling stbi_convert_iphone_png_to_rgb(0), in which case
-// you will always just get the native iphone "format" through.
-//
-// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per
-// pixel to remove any premultiplied alpha *only* if the image file explicitly
-// says there's premultiplied data (currently only happens in iPhone images,
-// and only if iPhone convert-to-rgb processing is on).
-//
-// ===========================================================================
-//
-// HDR image support   (disable by defining STBI_NO_HDR)
-//
-// stb_image now supports loading HDR images in general, and currently
-// the Radiance .HDR file format, although the support is provided
-// generically. You can still load any file through the existing interface;
-// if you attempt to load an HDR file, it will be automatically remapped to
-// LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;
-// both of these constants can be reconfigured through this interface:
-//
-//     stbi_hdr_to_ldr_gamma(2.2f);
-//     stbi_hdr_to_ldr_scale(1.0f);
-//
-// (note, do not use _inverse_ constants; stbi_image will invert them
-// appropriately).
-//
-// Additionally, there is a new, parallel interface for loading files as
-// (linear) floats to preserve the full dynamic range:
-//
-//    float *data = stbi_loadf(filename, &x, &y, &n, 0);
-// 
-// If you load LDR images through this interface, those images will
-// be promoted to floating point values, run through the inverse of
-// constants corresponding to the above:
-//
-//     stbi_ldr_to_hdr_scale(1.0f);
-//     stbi_ldr_to_hdr_gamma(2.2f);
-//
-// Finally, given a filename (or an open file or memory block--see header
-// file for details) containing image data, you can query for the "most
-// appropriate" interface to use (that is, whether the image is HDR or
-// not), using:
-//
-//     stbi_is_hdr(char *filename);
-//
-// ===========================================================================
-//
-// I/O callbacks
-//
-// I/O callbacks allow you to read from arbitrary sources, like packaged
-// files or some other source. Data read from callbacks are processed
-// through a small internal buffer (currently 128 bytes) to try to reduce
-// overhead. 
-//
-// The three functions you must define are "read" (reads some bytes of data),
-// "skip" (skips some bytes of data), "eof" (reports if the stream is at the end).
-
-
-#ifndef STBI_NO_STDIO
-#include <stdio.h>
-#endif // STBI_NO_STDIO
-
-#define STBI_VERSION 1
-
-enum
-{
-   STBI_default = 0, // only used for req_comp
-
-   STBI_grey       = 1,
-   STBI_grey_alpha = 2,
-   STBI_rgb        = 3,
-   STBI_rgb_alpha  = 4
-};
-
-typedef unsigned char stbi_uc;
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifdef STB_IMAGE_STATIC
-#define STBIDEF static
-#else
-#define STBIDEF extern
-#endif
-
-//////////////////////////////////////////////////////////////////////////////
-//
-// PRIMARY API - works on images of any type
-//
-
-//
-// load image by filename, open file, or memory buffer
-//
-
-STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
-
-#ifndef STBI_NO_STDIO
-STBIDEF stbi_uc *stbi_load            (char const *filename,     int *x, int *y, int *comp, int req_comp);
-STBIDEF stbi_uc *stbi_load_from_file  (FILE *f,                  int *x, int *y, int *comp, int req_comp);
-// for stbi_load_from_file, file pointer is left pointing immediately after image
-#endif
-
-typedef struct
-{
-   int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read 
-   void     (*skip)  (void *user,int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative
-   int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data
-} stbi_io_callbacks;
-
-STBIDEF stbi_uc *stbi_load_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp);
-
-#ifndef STBI_NO_HDR
-   STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
-
-   #ifndef STBI_NO_STDIO
-   STBIDEF float *stbi_loadf            (char const *filename,   int *x, int *y, int *comp, int req_comp);
-   STBIDEF float *stbi_loadf_from_file  (FILE *f,                int *x, int *y, int *comp, int req_comp);
-   #endif
-   
-   STBIDEF float *stbi_loadf_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp);
-
-   STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma);
-   STBIDEF void   stbi_hdr_to_ldr_scale(float scale);
-
-   STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);
-   STBIDEF void   stbi_ldr_to_hdr_scale(float scale);
-#endif // STBI_NO_HDR
-
-// stbi_is_hdr is always defined
-STBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);
-STBIDEF int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);
-#ifndef STBI_NO_STDIO
-STBIDEF int      stbi_is_hdr          (char const *filename);
-STBIDEF int      stbi_is_hdr_from_file(FILE *f);
-#endif // STBI_NO_STDIO
-
-
-// get a VERY brief reason for failure
-// NOT THREADSAFE
-STBIDEF const char *stbi_failure_reason  (void);
-
-// free the loaded image -- this is just free()
-STBIDEF void     stbi_image_free      (void *retval_from_stbi_load);
-
-// get image dimensions & components without fully decoding
-STBIDEF int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
-STBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);
-
-#ifndef STBI_NO_STDIO
-STBIDEF int      stbi_info            (char const *filename,     int *x, int *y, int *comp);
-STBIDEF int      stbi_info_from_file  (FILE *f,                  int *x, int *y, int *comp);
-
-#endif
-
-
-
-// for image formats that explicitly notate that they have premultiplied alpha,
-// we just return the colors as stored in the file. set this flag to force
-// unpremultiplication. results are undefined if the unpremultiply overflow.
-STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);
-
-// indicate whether we should process iphone images back to canonical format,
-// or just pass them through "as-is"
-STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);
-
-
-// ZLIB client - used by PNG, available for other purposes
-
-STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
-STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);
-STBIDEF char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
-STBIDEF int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);
-
-STBIDEF char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);
-STBIDEF int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);
-
-
-// define faster low-level operations (typically SIMD support)
-#ifdef STBI_SIMD
-typedef void (*stbi_idct_8x8)(stbi_uc *out, int out_stride, short data[64], unsigned short *dequantize);
-// compute an integer IDCT on "input"
-//     input[x] = data[x] * dequantize[x]
-//     write results to 'out': 64 samples, each run of 8 spaced by 'out_stride'
-//                             CLAMP results to 0..255
-typedef void (*stbi_YCbCr_to_RGB_run)(stbi_uc *output, stbi_uc const  *y, stbi_uc const *cb, stbi_uc const *cr, int count, int step);
-// compute a conversion from YCbCr to RGB
-//     'count' pixels
-//     write pixels to 'output'; each pixel is 'step' bytes (either 3 or 4; if 4, write '255' as 4th), order R,G,B
-//     y: Y input channel
-//     cb: Cb input channel; scale/biased to be 0..255
-//     cr: Cr input channel; scale/biased to be 0..255
-
-STBIDEF void stbi_install_idct(stbi_idct_8x8 func);
-STBIDEF void stbi_install_YCbCr_to_RGB(stbi_YCbCr_to_RGB_run func);
-#endif // STBI_SIMD
-
-
-#ifdef __cplusplus
-}
-#endif
-
-//
-//
-////   end header file   /////////////////////////////////////////////////////
-#endif // STBI_INCLUDE_STB_IMAGE_H
-
-#ifdef STB_IMAGE_IMPLEMENTATION
-
-#ifndef STBI_NO_HDR
-#include <math.h>  // ldexp
-#include <string.h> // strcmp, strtok
-#endif
-
-#ifndef STBI_NO_STDIO
-#include <stdio.h>
-#endif
-#include <stdlib.h>
-#include <string.h>
-#ifndef STBI_ASSERT
-#include <assert.h>
-#define STBI_ASSERT(x) assert(x)
-#endif
-#include <stdarg.h>
-#include <stddef.h> // ptrdiff_t on osx
-
-#ifndef _MSC_VER
-   #ifdef __cplusplus
-   #define stbi_inline inline
-   #else
-   #define stbi_inline
-   #endif
-#else
-   #define stbi_inline __forceinline
-#endif
-
-
-#ifdef _MSC_VER
-typedef unsigned short stbi__uint16;
-typedef   signed short stbi__int16;
-typedef unsigned int   stbi__uint32;
-typedef   signed int   stbi__int32;
-#else
-#include <stdint.h>
-typedef uint16_t stbi__uint16;
-typedef int16_t  stbi__int16;
-typedef uint32_t stbi__uint32;
-typedef int32_t  stbi__int32;
-#endif
-
-// should produce compiler error if size is wrong
-typedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];
-
-#ifdef _MSC_VER
-#define STBI_NOTUSED(v)  (void)(v)
-#else
-#define STBI_NOTUSED(v)  (void)sizeof(v)
-#endif
-
-#ifdef _MSC_VER
-#define STBI_HAS_LROTL
-#endif
-
-#ifdef STBI_HAS_LROTL
-   #define stbi_lrot(x,y)  _lrotl(x,y)
-#else
-   #define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (32 - (y))))
-#endif
-
-///////////////////////////////////////////////
-//
-//  stbi__context struct and start_xxx functions
-
-// stbi__context structure is our basic context used by all images, so it
-// contains all the IO context, plus some basic image information
-typedef struct
-{
-   stbi__uint32 img_x, img_y;
-   int img_n, img_out_n;
-   
-   stbi_io_callbacks io;
-   void *io_user_data;
-
-   int read_from_callbacks;
-   int buflen;
-   stbi_uc buffer_start[128];
-
-   stbi_uc *img_buffer, *img_buffer_end;
-   stbi_uc *img_buffer_original;
-} stbi__context;
-
-
-static void stbi__refill_buffer(stbi__context *s);
-
-// initialize a memory-decode context
-static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
-{
-   s->io.read = NULL;
-   s->read_from_callbacks = 0;
-   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;
-   s->img_buffer_end = (stbi_uc *) buffer+len;
-}
-
-// initialize a callback-based context
-static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
-{
-   s->io = *c;
-   s->io_user_data = user;
-   s->buflen = sizeof(s->buffer_start);
-   s->read_from_callbacks = 1;
-   s->img_buffer_original = s->buffer_start;
-   stbi__refill_buffer(s);
-}
-
-#ifndef STBI_NO_STDIO
-
-static int stbi__stdio_read(void *user, char *data, int size)
-{
-   return (int) fread(data,1,size,(FILE*) user);
-}
-
-static void stbi__stdio_skip(void *user, int n)
-{
-   fseek((FILE*) user, n, SEEK_CUR);
-}
-
-static int stbi__stdio_eof(void *user)
-{
-   return feof((FILE*) user);
-}
-
-static stbi_io_callbacks stbi__stdio_callbacks =
-{
-   stbi__stdio_read,
-   stbi__stdio_skip,
-   stbi__stdio_eof,
-};
-
-static void stbi__start_file(stbi__context *s, FILE *f)
-{
-   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);
-}
-
-//static void stop_file(stbi__context *s) { }
-
-#endif // !STBI_NO_STDIO
-
-static void stbi__rewind(stbi__context *s)
-{
-   // conceptually rewind SHOULD rewind to the beginning of the stream,
-   // but we just rewind to the beginning of the initial buffer, because
-   // we only use it after doing 'test', which only ever looks at at most 92 bytes
-   s->img_buffer = s->img_buffer_original;
-}
-
-static int      stbi__jpeg_test(stbi__context *s);
-static stbi_uc *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
-static int      stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp);
-static int      stbi__png_test(stbi__context *s);
-static stbi_uc *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
-static int      stbi__png_info(stbi__context *s, int *x, int *y, int *comp);
-static int      stbi__bmp_test(stbi__context *s);
-static stbi_uc *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
-static int      stbi__tga_test(stbi__context *s);
-static stbi_uc *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
-static int      stbi__tga_info(stbi__context *s, int *x, int *y, int *comp);
-static int      stbi__psd_test(stbi__context *s);
-static stbi_uc *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
-#ifndef STBI_NO_HDR
-static int      stbi__hdr_test(stbi__context *s);
-static float   *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
-#endif
-static int      stbi__pic_test(stbi__context *s);
-static stbi_uc *stbi__pic_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
-static int      stbi__gif_test(stbi__context *s);
-static stbi_uc *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
-static int      stbi__gif_info(stbi__context *s, int *x, int *y, int *comp);
-
-
-// this is not threadsafe
-static const char *stbi__g_failure_reason;
-
-STBIDEF const char *stbi_failure_reason(void)
-{
-   return stbi__g_failure_reason;
-}
-
-static int stbi__err(const char *str)
-{
-   stbi__g_failure_reason = str;
-   return 0;
-}
-
-static void *stbi__malloc(size_t size)
-{
-    return malloc(size);
-}
-
-// stbi__err - error
-// stbi__errpf - error returning pointer to float
-// stbi__errpuc - error returning pointer to unsigned char
-
-#ifdef STBI_NO_FAILURE_STRINGS
-   #define stbi__err(x,y)  0
-#elif defined(STBI_FAILURE_USERMSG)
-   #define stbi__err(x,y)  stbi__err(y)
-#else
-   #define stbi__err(x,y)  stbi__err(x)
-#endif
-
-#define stbi__errpf(x,y)   ((float *) (stbi__err(x,y)?NULL:NULL))
-#define stbi__errpuc(x,y)  ((unsigned char *) (stbi__err(x,y)?NULL:NULL))
-
-STBIDEF void stbi_image_free(void *retval_from_stbi_load)
-{
-   free(retval_from_stbi_load);
-}
-
-#ifndef STBI_NO_HDR
-static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
-static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);
-#endif
-
-static unsigned char *stbi_load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
-{
-   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp);
-   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp);
-   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp);
-   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp);
-   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp);
-   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp);
-
-   #ifndef STBI_NO_HDR
-   if (stbi__hdr_test(s)) {
-      float *hdr = stbi__hdr_load(s, x,y,comp,req_comp);
-      return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
-   }
-   #endif
-
-   // test tga last because it's a crappy test!
-   if (stbi__tga_test(s))
-      return stbi__tga_load(s,x,y,comp,req_comp);
-   return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");
-}
-
-#ifndef STBI_NO_STDIO
-
-static FILE *stbi__fopen(char const *filename, char const *mode)
-{
-   FILE *f;
-#if defined(_MSC_VER) && _MSC_VER >= 1400
-   if (0 != fopen_s(&f, filename, mode))
-      f=0;
-#else
-   f = fopen(filename, mode);
-#endif
-   return f;
-}
-
-
-STBIDEF unsigned char *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
-{
-   FILE *f = stbi__fopen(filename, "rb");
-   unsigned char *result;
-   if (!f) return stbi__errpuc("can't fopen", "Unable to open file");
-   result = stbi_load_from_file(f,x,y,comp,req_comp);
-   fclose(f);
-   return result;
-}
-
-STBIDEF unsigned char *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
-{
-   unsigned char *result;
-   stbi__context s;
-   stbi__start_file(&s,f);
-   result = stbi_load_main(&s,x,y,comp,req_comp);
-   if (result) {
-      // need to 'unget' all the characters in the IO buffer
-      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
-   }
-   return result;
-}
-#endif //!STBI_NO_STDIO
-
-STBIDEF unsigned char *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
-{
-   stbi__context s;
-   stbi__start_mem(&s,buffer,len);
-   return stbi_load_main(&s,x,y,comp,req_comp);
-}
-
-STBIDEF unsigned char *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
-{
-   stbi__context s;
-   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
-   return stbi_load_main(&s,x,y,comp,req_comp);
-}
-
-#ifndef STBI_NO_HDR
-
-static float *stbi_loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
-{
-   unsigned char *data;
-   #ifndef STBI_NO_HDR
-   if (stbi__hdr_test(s))
-      return stbi__hdr_load(s,x,y,comp,req_comp);
-   #endif
-   data = stbi_load_main(s, x, y, comp, req_comp);
-   if (data)
-      return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
-   return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");
-}
-
-STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
-{
-   stbi__context s;
-   stbi__start_mem(&s,buffer,len);
-   return stbi_loadf_main(&s,x,y,comp,req_comp);
-}
-
-STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
-{
-   stbi__context s;
-   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
-   return stbi_loadf_main(&s,x,y,comp,req_comp);
-}
-
-#ifndef STBI_NO_STDIO
-STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
-{
-   float *result;
-   FILE *f = stbi__fopen(filename, "rb");
-   if (!f) return stbi__errpf("can't fopen", "Unable to open file");
-   result = stbi_loadf_from_file(f,x,y,comp,req_comp);
-   fclose(f);
-   return result;
-}
-
-STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
-{
-   stbi__context s;
-   stbi__start_file(&s,f);
-   return stbi_loadf_main(&s,x,y,comp,req_comp);
-}
-#endif // !STBI_NO_STDIO
-
-#endif // !STBI_NO_HDR
-
-// these is-hdr-or-not is defined independent of whether STBI_NO_HDR is
-// defined, for API simplicity; if STBI_NO_HDR is defined, it always
-// reports false!
-
-int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
-{
-   #ifndef STBI_NO_HDR
-   stbi__context s;
-   stbi__start_mem(&s,buffer,len);
-   return stbi__hdr_test(&s);
-   #else
-   STBI_NOTUSED(buffer);
-   STBI_NOTUSED(len);
-   return 0;
-   #endif
-}
-
-#ifndef STBI_NO_STDIO
-STBIDEF int      stbi_is_hdr          (char const *filename)
-{
-   FILE *f = stbi__fopen(filename, "rb");
-   int result=0;
-   if (f) {
-      result = stbi_is_hdr_from_file(f);
-      fclose(f);
-   }
-   return result;
-}
-
-STBIDEF int      stbi_is_hdr_from_file(FILE *f)
-{
-   #ifndef STBI_NO_HDR
-   stbi__context s;
-   stbi__start_file(&s,f);
-   return stbi__hdr_test(&s);
-   #else
-   return 0;
-   #endif
-}
-#endif // !STBI_NO_STDIO
-
-STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
-{
-   #ifndef STBI_NO_HDR
-   stbi__context s;
-   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
-   return stbi__hdr_test(&s);
-   #else
-   return 0;
-   #endif
-}
-
-#ifndef STBI_NO_HDR
-static float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;
-static float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;
-
-void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }
-void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }
-
-void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
-void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
-#endif
-
-
-//////////////////////////////////////////////////////////////////////////////
-//
-// Common code used by all image loaders
-//
-
-enum
-{
-   SCAN_load=0,
-   SCAN_type,
-   SCAN_header
-};
-
-static void stbi__refill_buffer(stbi__context *s)
-{
-   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
-   if (n == 0) {
-      // at end of file, treat same as if from memory, but need to handle case
-      // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
-      s->read_from_callbacks = 0;
-      s->img_buffer = s->buffer_start;
-      s->img_buffer_end = s->buffer_start+1;
-      *s->img_buffer = 0;
-   } else {
-      s->img_buffer = s->buffer_start;
-      s->img_buffer_end = s->buffer_start + n;
-   }
-}
-
-stbi_inline static stbi_uc stbi__get8(stbi__context *s)
-{
-   if (s->img_buffer < s->img_buffer_end)
-      return *s->img_buffer++;
-   if (s->read_from_callbacks) {
-      stbi__refill_buffer(s);
-      return *s->img_buffer++;
-   }
-   return 0;
-}
-
-stbi_inline static int stbi__at_eof(stbi__context *s)
-{
-   if (s->io.read) {
-      if (!(s->io.eof)(s->io_user_data)) return 0;
-      // if feof() is true, check if buffer = end
-      // special case: we've only got the special 0 character at the end
-      if (s->read_from_callbacks == 0) return 1;
-   }
-
-   return s->img_buffer >= s->img_buffer_end;   
-}
-
-static void stbi__skip(stbi__context *s, int n)
-{
-   if (s->io.read) {
-      int blen = (int) (s->img_buffer_end - s->img_buffer);
-      if (blen < n) {
-         s->img_buffer = s->img_buffer_end;
-         (s->io.skip)(s->io_user_data, n - blen);
-         return;
-      }
-   }
-   s->img_buffer += n;
-}
-
-static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
-{
-   if (s->io.read) {
-      int blen = (int) (s->img_buffer_end - s->img_buffer);
-      if (blen < n) {
-         int res, count;
-
-         memcpy(buffer, s->img_buffer, blen);
-         
-         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
-         res = (count == (n-blen));
-         s->img_buffer = s->img_buffer_end;
-         return res;
-      }
-   }
-
-   if (s->img_buffer+n <= s->img_buffer_end) {
-      memcpy(buffer, s->img_buffer, n);
-      s->img_buffer += n;
-      return 1;
-   } else
-      return 0;
-}
-
-static int stbi__get16be(stbi__context *s)
-{
-   int z = stbi__get8(s);
-   return (z << 8) + stbi__get8(s);
-}
-
-static stbi__uint32 stbi__get32be(stbi__context *s)
-{
-   stbi__uint32 z = stbi__get16be(s);
-   return (z << 16) + stbi__get16be(s);
-}
-
-static int stbi__get16le(stbi__context *s)
-{
-   int z = stbi__get8(s);
-   return z + (stbi__get8(s) << 8);
-}
-
-static stbi__uint32 stbi__get32le(stbi__context *s)
-{
-   stbi__uint32 z = stbi__get16le(s);
-   return z + (stbi__get16le(s) << 16);
-}
-
-//////////////////////////////////////////////////////////////////////////////
-//
-//  generic converter from built-in img_n to req_comp
-//    individual types do this automatically as much as possible (e.g. jpeg
-//    does all cases internally since it needs to colorspace convert anyway,
-//    and it never has alpha, so very few cases ). png can automatically
-//    interleave an alpha=255 channel, but falls back to this for other cases
-//
-//  assume data buffer is malloced, so malloc a new one and free that one
-//  only failure mode is malloc failing
-
-static stbi_uc stbi__compute_y(int r, int g, int b)
-{
-   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
-}
-
-static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
-{
-   int i,j;
-   unsigned char *good;
-
-   if (req_comp == img_n) return data;
-   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);
-
-   good = (unsigned char *) stbi__malloc(req_comp * x * y);
-   if (good == NULL) {
-      free(data);
-      return stbi__errpuc("outofmem", "Out of memory");
-   }
-
-   for (j=0; j < (int) y; ++j) {
-      unsigned char *src  = data + j * x * img_n   ;
-      unsigned char *dest = good + j * x * req_comp;
-
-      #define COMBO(a,b)  ((a)*8+(b))
-      #define CASE(a,b)   case COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
-      // convert source image with img_n components to one with req_comp components;
-      // avoid switch per pixel, so use switch per scanline and massive macros
-      switch (COMBO(img_n, req_comp)) {
-         CASE(1,2) dest[0]=src[0], dest[1]=255; break;
-         CASE(1,3) dest[0]=dest[1]=dest[2]=src[0]; break;
-         CASE(1,4) dest[0]=dest[1]=dest[2]=src[0], dest[3]=255; break;
-         CASE(2,1) dest[0]=src[0]; break;
-         CASE(2,3) dest[0]=dest[1]=dest[2]=src[0]; break;
-         CASE(2,4) dest[0]=dest[1]=dest[2]=src[0], dest[3]=src[1]; break;
-         CASE(3,4) dest[0]=src[0],dest[1]=src[1],dest[2]=src[2],dest[3]=255; break;
-         CASE(3,1) dest[0]=stbi__compute_y(src[0],src[1],src[2]); break;
-         CASE(3,2) dest[0]=stbi__compute_y(src[0],src[1],src[2]), dest[1] = 255; break;
-         CASE(4,1) dest[0]=stbi__compute_y(src[0],src[1],src[2]); break;
-         CASE(4,2) dest[0]=stbi__compute_y(src[0],src[1],src[2]), dest[1] = src[3]; break;
-         CASE(4,3) dest[0]=src[0],dest[1]=src[1],dest[2]=src[2]; break;
-         default: STBI_ASSERT(0);
-      }
-      #undef CASE
-   }
-
-   free(data);
-   return good;
-}
-
-#ifndef STBI_NO_HDR
-static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
-{
-   int i,k,n;
-   float *output = (float *) stbi__malloc(x * y * comp * sizeof(float));
-   if (output == NULL) { free(data); return stbi__errpf("outofmem", "Out of memory"); }
-   // compute number of non-alpha components
-   if (comp & 1) n = comp; else n = comp-1;
-   for (i=0; i < x*y; ++i) {
-      for (k=0; k < n; ++k) {
-         output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
-      }
-      if (k < comp) output[i*comp + k] = data[i*comp+k]/255.0f;
-   }
-   free(data);
-   return output;
-}
-
-#define stbi__float2int(x)   ((int) (x))
-static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
-{
-   int i,k,n;
-   stbi_uc *output = (stbi_uc *) stbi__malloc(x * y * comp);
-   if (output == NULL) { free(data); return stbi__errpuc("outofmem", "Out of memory"); }
-   // compute number of non-alpha components
-   if (comp & 1) n = comp; else n = comp-1;
-   for (i=0; i < x*y; ++i) {
-      for (k=0; k < n; ++k) {
-         float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
-         if (z < 0) z = 0;
-         if (z > 255) z = 255;
-         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
-      }
-      if (k < comp) {
-         float z = data[i*comp+k] * 255 + 0.5f;
-         if (z < 0) z = 0;
-         if (z > 255) z = 255;
-         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
-      }
-   }
-   free(data);
-   return output;
-}
-#endif
-
-//////////////////////////////////////////////////////////////////////////////
-//
-//  "baseline" JPEG/JFIF decoder (not actually fully baseline implementation)
-//
-//    simple implementation
-//      - channel subsampling of at most 2 in each dimension
-//      - doesn't support delayed output of y-dimension
-//      - simple interface (only one output format: 8-bit interleaved RGB)
-//      - doesn't try to recover corrupt jpegs
-//      - doesn't allow partial loading, loading multiple at once
-//      - still fast on x86 (copying globals into locals doesn't help x86)
-//      - allocates lots of intermediate memory (full size of all components)
-//        - non-interleaved case requires this anyway
-//        - allows good upsampling (see next)
-//    high-quality
-//      - upsampled channels are bilinearly interpolated, even across blocks
-//      - quality integer IDCT derived from IJG's 'slow'
-//    performance
-//      - fast huffman; reasonable integer IDCT
-//      - uses a lot of intermediate memory, could cache poorly
-//      - load http://nothings.org/remote/anemones.jpg 3 times on 2.8Ghz P4
-//          stb_jpeg:   1.34 seconds (MSVC6, default release build)
-//          stb_jpeg:   1.06 seconds (MSVC6, processor = Pentium Pro)
-//          IJL11.dll:  1.08 seconds (compiled by intel)
-//          IJG 1998:   0.98 seconds (MSVC6, makefile provided by IJG)
-//          IJG 1998:   0.95 seconds (MSVC6, makefile + proc=PPro)
-
-// huffman decoding acceleration
-#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache
-
-typedef struct
-{
-   stbi_uc  fast[1 << FAST_BITS];
-   // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
-   stbi__uint16 code[256];
-   stbi_uc  values[256];
-   stbi_uc  size[257];
-   unsigned int maxcode[18];
-   int    delta[17];   // old 'firstsymbol' - old 'firstcode'
-} stbi__huffman;
-
-typedef struct
-{
-   #ifdef STBI_SIMD
-   unsigned short dequant2[4][64];
-   #endif
-   stbi__context *s;
-   stbi__huffman huff_dc[4];
-   stbi__huffman huff_ac[4];
-   stbi_uc dequant[4][64];
-
-// sizes for components, interleaved MCUs
-   int img_h_max, img_v_max;
-   int img_mcu_x, img_mcu_y;
-   int img_mcu_w, img_mcu_h;
-
-// definition of jpeg image component
-   struct
-   {
-      int id;
-      int h,v;
-      int tq;
-      int hd,ha;
-      int dc_pred;
-
-      int x,y,w2,h2;
-      stbi_uc *data;
-      void *raw_data;
-      stbi_uc *linebuf;
-   } img_comp[4];
-
-   stbi__uint32         code_buffer; // jpeg entropy-coded buffer
-   int            code_bits;   // number of valid bits
-   unsigned char  marker;      // marker seen while filling entropy buffer
-   int            nomore;      // flag if we saw a marker so must stop
-
-   int scan_n, order[4];
-   int restart_interval, todo;
-} stbi__jpeg;
-
-static int stbi__build_huffman(stbi__huffman *h, int *count)
-{
-   int i,j,k=0,code;
-   // build size list for each symbol (from JPEG spec)
-   for (i=0; i < 16; ++i)
-      for (j=0; j < count[i]; ++j)
-         h->size[k++] = (stbi_uc) (i+1);
-   h->size[k] = 0;
-
-   // compute actual symbols (from jpeg spec)
-   code = 0;
-   k = 0;
-   for(j=1; j <= 16; ++j) {
-      // compute delta to add to code to compute symbol id
-      h->delta[j] = k - code;
-      if (h->size[k] == j) {
-         while (h->size[k] == j)
-            h->code[k++] = (stbi__uint16) (code++);
-         if (code-1 >= (1 << j)) return stbi__err("bad code lengths","Corrupt JPEG");
-      }
-      // compute largest code + 1 for this size, preshifted as needed later
-      h->maxcode[j] = code << (16-j);
-      code <<= 1;
-   }
-   h->maxcode[j] = 0xffffffff;
-
-   // build non-spec acceleration table; 255 is flag for not-accelerated
-   memset(h->fast, 255, 1 << FAST_BITS);
-   for (i=0; i < k; ++i) {
-      int s = h->size[i];
-      if (s <= FAST_BITS) {
-         int c = h->code[i] << (FAST_BITS-s);
-         int m = 1 << (FAST_BITS-s);
-         for (j=0; j < m; ++j) {
-            h->fast[c+j] = (stbi_uc) i;
-         }
-      }
-   }
-   return 1;
-}
-
-static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
-{
-   do {
-      int b = j->nomore ? 0 : stbi__get8(j->s);
-      if (b == 0xff) {
-         int c = stbi__get8(j->s);
-         if (c != 0) {
-            j->marker = (unsigned char) c;
-            j->nomore = 1;
-            return;
-         }
-      }
-      j->code_buffer |= b << (24 - j->code_bits);
-      j->code_bits += 8;
-   } while (j->code_bits <= 24);
-}
-
-// (1 << n) - 1
-static stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};
-
-// decode a jpeg huffman value from the bitstream
-stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
-{
-   unsigned int temp;
-   int c,k;
-
-   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
-
-   // look at the top FAST_BITS and determine what symbol ID it is,
-   // if the code is <= FAST_BITS
-   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
-   k = h->fast[c];
-   if (k < 255) {
-      int s = h->size[k];
-      if (s > j->code_bits)
-         return -1;
-      j->code_buffer <<= s;
-      j->code_bits -= s;
-      return h->values[k];
-   }
-
-   // naive test is to shift the code_buffer down so k bits are
-   // valid, then test against maxcode. To speed this up, we've
-   // preshifted maxcode left so that it has (16-k) 0s at the
-   // end; in other words, regardless of the number of bits, it
-   // wants to be compared against something shifted to have 16;
-   // that way we don't need to shift inside the loop.
-   temp = j->code_buffer >> 16;
-   for (k=FAST_BITS+1 ; ; ++k)
-      if (temp < h->maxcode[k])
-         break;
-   if (k == 17) {
-      // error! code not found
-      j->code_bits -= 16;
-      return -1;
-   }
-
-   if (k > j->code_bits)
-      return -1;
-
-   // convert the huffman code to the symbol id
-   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
-   STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
-
-   // convert the id to a symbol
-   j->code_bits -= k;
-   j->code_buffer <<= k;
-   return h->values[c];
-}
-
-// combined JPEG 'receive' and JPEG 'extend', since baseline
-// always extends everything it receives.
-stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
-{
-   unsigned int m = 1 << (n-1);
-   unsigned int k;
-   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
-
-   #if 1
-   k = stbi_lrot(j->code_buffer, n);
-   j->code_buffer = k & ~stbi__bmask[n];
-   k &= stbi__bmask[n];
-   j->code_bits -= n;
-   #else
-   k = (j->code_buffer >> (32 - n)) & stbi__bmask[n];
-   j->code_bits -= n;
-   j->code_buffer <<= n;
-   #endif
-   // the following test is probably a random branch that won't
-   // predict well. I tried to table accelerate it but failed.
-   // maybe it's compiling as a conditional move?
-   if (k < m)
-      return (-1 << n) + k + 1;
-   else
-      return k;
-}
-
-// given a value that's at position X in the zigzag stream,
-// where does it appear in the 8x8 matrix coded as row-major?
-static stbi_uc stbi__jpeg_dezigzag[64+15] =
-{
-    0,  1,  8, 16,  9,  2,  3, 10,
-   17, 24, 32, 25, 18, 11,  4,  5,
-   12, 19, 26, 33, 40, 48, 41, 34,
-   27, 20, 13,  6,  7, 14, 21, 28,
-   35, 42, 49, 56, 57, 50, 43, 36,
-   29, 22, 15, 23, 30, 37, 44, 51,
-   58, 59, 52, 45, 38, 31, 39, 46,
-   53, 60, 61, 54, 47, 55, 62, 63,
-   // let corrupt input sample past end
-   63, 63, 63, 63, 63, 63, 63, 63,
-   63, 63, 63, 63, 63, 63, 63
-};
-
-// decode one 64-entry block--
-static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, int b)
-{
-   int diff,dc,k;
-   int t = stbi__jpeg_huff_decode(j, hdc);
-   if (t < 0) return stbi__err("bad huffman code","Corrupt JPEG");
-
-   // 0 all the ac values now so we can do it 32-bits at a time
-   memset(data,0,64*sizeof(data[0]));
-
-   diff = t ? stbi__extend_receive(j, t) : 0;
-   dc = j->img_comp[b].dc_pred + diff;
-   j->img_comp[b].dc_pred = dc;
-   data[0] = (short) dc;
-
-   // decode AC components, see JPEG spec
-   k = 1;
-   do {
-      int r,s;
-      int rs = stbi__jpeg_huff_decode(j, hac);
-      if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
-      s = rs & 15;
-      r = rs >> 4;
-      if (s == 0) {
-         if (rs != 0xf0) break; // end block
-         k += 16;
-      } else {
-         k += r;
-         // decode into unzigzag'd location
-         data[stbi__jpeg_dezigzag[k++]] = (short) stbi__extend_receive(j,s);
-      }
-   } while (k < 64);
-   return 1;
-}
-
-// take a -128..127 value and stbi__clamp it and convert to 0..255
-stbi_inline static stbi_uc stbi__clamp(int x)
-{
-   // trick to use a single test to catch both cases
-   if ((unsigned int) x > 255) {
-      if (x < 0) return 0;
-      if (x > 255) return 255;
-   }
-   return (stbi_uc) x;
-}
-
-#define stbi__f2f(x)  (int) (((x) * 4096 + 0.5))
-#define stbi__fsh(x)  ((x) << 12)
-
-// derived from jidctint -- DCT_ISLOW
-#define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7)       \
-   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
-   p2 = s2;                                    \
-   p3 = s6;                                    \
-   p1 = (p2+p3) * stbi__f2f(0.5411961f);             \
-   t2 = p1 + p3*stbi__f2f(-1.847759065f);            \
-   t3 = p1 + p2*stbi__f2f( 0.765366865f);            \
-   p2 = s0;                                    \
-   p3 = s4;                                    \
-   t0 = stbi__fsh(p2+p3);                            \
-   t1 = stbi__fsh(p2-p3);                            \
-   x0 = t0+t3;                                 \
-   x3 = t0-t3;                                 \
-   x1 = t1+t2;                                 \
-   x2 = t1-t2;                                 \
-   t0 = s7;                                    \
-   t1 = s5;                                    \
-   t2 = s3;                                    \
-   t3 = s1;                                    \
-   p3 = t0+t2;                                 \
-   p4 = t1+t3;                                 \
-   p1 = t0+t3;                                 \
-   p2 = t1+t2;                                 \
-   p5 = (p3+p4)*stbi__f2f( 1.175875602f);            \
-   t0 = t0*stbi__f2f( 0.298631336f);                 \
-   t1 = t1*stbi__f2f( 2.053119869f);                 \
-   t2 = t2*stbi__f2f( 3.072711026f);                 \
-   t3 = t3*stbi__f2f( 1.501321110f);                 \
-   p1 = p5 + p1*stbi__f2f(-0.899976223f);            \
-   p2 = p5 + p2*stbi__f2f(-2.562915447f);            \
-   p3 = p3*stbi__f2f(-1.961570560f);                 \
-   p4 = p4*stbi__f2f(-0.390180644f);                 \
-   t3 += p1+p4;                                \
-   t2 += p2+p3;                                \
-   t1 += p2+p4;                                \
-   t0 += p1+p3;
-
-#ifdef STBI_SIMD
-typedef unsigned short stbi_dequantize_t;
-#else
-typedef stbi_uc stbi_dequantize_t;
-#endif
-
-// .344 seconds on 3*anemones.jpg
-static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64], stbi_dequantize_t *dequantize)
-{
-   int i,val[64],*v=val;
-   stbi_dequantize_t *dq = dequantize;
-   stbi_uc *o;
-   short *d = data;
-
-   // columns
-   for (i=0; i < 8; ++i,++d,++dq, ++v) {
-      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
-      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
-           && d[40]==0 && d[48]==0 && d[56]==0) {
-         //    no shortcut                 0     seconds
-         //    (1|2|3|4|5|6|7)==0          0     seconds
-         //    all separate               -0.047 seconds
-         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
-         int dcterm = d[0] * dq[0] << 2;
-         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
-      } else {
-         STBI__IDCT_1D(d[ 0]*dq[ 0],d[ 8]*dq[ 8],d[16]*dq[16],d[24]*dq[24],
-                 d[32]*dq[32],d[40]*dq[40],d[48]*dq[48],d[56]*dq[56])
-         // constants scaled things up by 1<<12; let's bring them back
-         // down, but keep 2 extra bits of precision
-         x0 += 512; x1 += 512; x2 += 512; x3 += 512;
-         v[ 0] = (x0+t3) >> 10;
-         v[56] = (x0-t3) >> 10;
-         v[ 8] = (x1+t2) >> 10;
-         v[48] = (x1-t2) >> 10;
-         v[16] = (x2+t1) >> 10;
-         v[40] = (x2-t1) >> 10;
-         v[24] = (x3+t0) >> 10;
-         v[32] = (x3-t0) >> 10;
-      }
-   }
-
-   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
-      // no fast case since the first 1D IDCT spread components out
-      STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
-      // constants scaled things up by 1<<12, plus we had 1<<2 from first
-      // loop, plus horizontal and vertical each scale by sqrt(8) so together
-      // we've got an extra 1<<3, so 1<<17 total we need to remove.
-      // so we want to round that, which means adding 0.5 * 1<<17,
-      // aka 65536. Also, we'll end up with -128 to 127 that we want
-      // to encode as 0..255 by adding 128, so we'll add that before the shift
-      x0 += 65536 + (128<<17);
-      x1 += 65536 + (128<<17);
-      x2 += 65536 + (128<<17);
-      x3 += 65536 + (128<<17);
-      // tried computing the shifts into temps, or'ing the temps to see
-      // if any were out of range, but that was slower
-      o[0] = stbi__clamp((x0+t3) >> 17);
-      o[7] = stbi__clamp((x0-t3) >> 17);
-      o[1] = stbi__clamp((x1+t2) >> 17);
-      o[6] = stbi__clamp((x1-t2) >> 17);
-      o[2] = stbi__clamp((x2+t1) >> 17);
-      o[5] = stbi__clamp((x2-t1) >> 17);
-      o[3] = stbi__clamp((x3+t0) >> 17);
-      o[4] = stbi__clamp((x3-t0) >> 17);
-   }
-}
-
-#ifdef STBI_SIMD
-static stbi_idct_8x8 stbi__idct_installed = stbi__idct_block;
-
-STBIDEF void stbi_install_idct(stbi_idct_8x8 func)
-{
-   stbi__idct_installed = func;
-}
-#endif
-
-#define STBI__MARKER_none  0xff
-// if there's a pending marker from the entropy stream, return that
-// otherwise, fetch from the stream and get a marker. if there's no
-// marker, return 0xff, which is never a valid marker value
-static stbi_uc stbi__get_marker(stbi__jpeg *j)
-{
-   stbi_uc x;
-   if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
-   x = stbi__get8(j->s);
-   if (x != 0xff) return STBI__MARKER_none;
-   while (x == 0xff)
-      x = stbi__get8(j->s);
-   return x;
-}
-
-// in each scan, we'll have scan_n components, and the order
-// of the components is specified by order[]
-#define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)
-
-// after a restart interval, stbi__jpeg_reset the entropy decoder and
-// the dc prediction
-static void stbi__jpeg_reset(stbi__jpeg *j)
-{
-   j->code_bits = 0;
-   j->code_buffer = 0;
-   j->nomore = 0;
-   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = 0;
-   j->marker = STBI__MARKER_none;
-   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
-   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
-   // since we don't even allow 1<<30 pixels
-}
-
-static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
-{
-   stbi__jpeg_reset(z);
-   if (z->scan_n == 1) {
-      int i,j;
-      #ifdef STBI_SIMD
-      __declspec(align(16))
-      #endif
-      short data[64];
-      int n = z->order[0];
-      // non-interleaved data, we just need to process one block at a time,
-      // in trivial scanline order
-      // number of blocks to do just depends on how many actual "pixels" this
-      // component has, independent of interleaved MCU blocking and such
-      int w = (z->img_comp[n].x+7) >> 3;
-      int h = (z->img_comp[n].y+7) >> 3;
-      for (j=0; j < h; ++j) {
-         for (i=0; i < w; ++i) {
-            if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+z->img_comp[n].ha, n)) return 0;
-            #ifdef STBI_SIMD
-            stbi__idct_installed(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data, z->dequant2[z->img_comp[n].tq]);
-            #else
-            stbi__idct_block(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data, z->dequant[z->img_comp[n].tq]);
-            #endif
-            // every data block is an MCU, so countdown the restart interval
-            if (--z->todo <= 0) {
-               if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
-               // if it's NOT a restart, then just bail, so we get corrupt data
-               // rather than no data
-               if (!STBI__RESTART(z->marker)) return 1;
-               stbi__jpeg_reset(z);
-            }
-         }
-      }
-   } else { // interleaved!
-      int i,j,k,x,y;
-      short data[64];
-      for (j=0; j < z->img_mcu_y; ++j) {
-         for (i=0; i < z->img_mcu_x; ++i) {
-            // scan an interleaved mcu... process scan_n components in order
-            for (k=0; k < z->scan_n; ++k) {
-               int n = z->order[k];
-               // scan out an mcu's worth of this component; that's just determined
-               // by the basic H and V specified for the component
-               for (y=0; y < z->img_comp[n].v; ++y) {
-                  for (x=0; x < z->img_comp[n].h; ++x) {
-                     int x2 = (i*z->img_comp[n].h + x)*8;
-                     int y2 = (j*z->img_comp[n].v + y)*8;
-                     if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+z->img_comp[n].ha, n)) return 0;
-                     #ifdef STBI_SIMD
-                     stbi__idct_installed(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data, z->dequant2[z->img_comp[n].tq]);
-                     #else
-                     stbi__idct_block(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data, z->dequant[z->img_comp[n].tq]);
-                     #endif
-                  }
-               }
-            }
-            // after all interleaved components, that's an interleaved MCU,
-            // so now count down the restart interval
-            if (--z->todo <= 0) {
-               if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
-               // if it's NOT a restart, then just bail, so we get corrupt data
-               // rather than no data
-               if (!STBI__RESTART(z->marker)) return 1;
-               stbi__jpeg_reset(z);
-            }
-         }
-      }
-   }
-   return 1;
-}
-
-static int stbi__process_marker(stbi__jpeg *z, int m)
-{
-   int L;
-   switch (m) {
-      case STBI__MARKER_none: // no marker found
-         return stbi__err("expected marker","Corrupt JPEG");
-
-      case 0xC2: // stbi__SOF - progressive
-         return stbi__err("progressive jpeg","JPEG format not supported (progressive)");
-
-      case 0xDD: // DRI - specify restart interval
-         if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
-         z->restart_interval = stbi__get16be(z->s);
-         return 1;
-
-      case 0xDB: // DQT - define quantization table
-         L = stbi__get16be(z->s)-2;
-         while (L > 0) {
-            int q = stbi__get8(z->s);
-            int p = q >> 4;
-            int t = q & 15,i;
-            if (p != 0) return stbi__err("bad DQT type","Corrupt JPEG");
-            if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");
-            for (i=0; i < 64; ++i)
-               z->dequant[t][stbi__jpeg_dezigzag[i]] = stbi__get8(z->s);
-            #ifdef STBI_SIMD
-            for (i=0; i < 64; ++i)
-               z->dequant2[t][i] = z->dequant[t][i];
-            #endif
-            L -= 65;
-         }
-         return L==0;
-
-      case 0xC4: // DHT - define huffman table
-         L = stbi__get16be(z->s)-2;
-         while (L > 0) {
-            stbi_uc *v;
-            int sizes[16],i,n=0;
-            int q = stbi__get8(z->s);
-            int tc = q >> 4;
-            int th = q & 15;
-            if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
-            for (i=0; i < 16; ++i) {
-               sizes[i] = stbi__get8(z->s);
-               n += sizes[i];
-            }
-            L -= 17;
-            if (tc == 0) {
-               if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
-               v = z->huff_dc[th].values;
-            } else {
-               if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
-               v = z->huff_ac[th].values;
-            }
-            for (i=0; i < n; ++i)
-               v[i] = stbi__get8(z->s);
-            L -= n;
-         }
-         return L==0;
-   }
-   // check for comment block or APP blocks
-   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
-      stbi__skip(z->s, stbi__get16be(z->s)-2);
-      return 1;
-   }
-   return 0;
-}
-
-// after we see stbi__SOS
-static int stbi__process_scan_header(stbi__jpeg *z)
-{
-   int i;
-   int Ls = stbi__get16be(z->s);
-   z->scan_n = stbi__get8(z->s);
-   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad stbi__SOS component count","Corrupt JPEG");
-   if (Ls != 6+2*z->scan_n) return stbi__err("bad stbi__SOS len","Corrupt JPEG");
-   for (i=0; i < z->scan_n; ++i) {
-      int id = stbi__get8(z->s), which;
-      int q = stbi__get8(z->s);
-      for (which = 0; which < z->s->img_n; ++which)
-         if (z->img_comp[which].id == id)
-            break;
-      if (which == z->s->img_n) return 0;
-      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
-      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
-      z->order[i] = which;
-   }
-   if (stbi__get8(z->s) != 0) return stbi__err("bad stbi__SOS","Corrupt JPEG");
-   stbi__get8(z->s); // should be 63, but might be 0
-   if (stbi__get8(z->s) != 0) return stbi__err("bad stbi__SOS","Corrupt JPEG");
-
-   return 1;
-}
-
-static int stbi__process_frame_header(stbi__jpeg *z, int scan)
-{
-   stbi__context *s = z->s;
-   int Lf,p,i,q, h_max=1,v_max=1,c;
-   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad stbi__SOF len","Corrupt JPEG"); // JPEG
-   p  = stbi__get8(s);          if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
-   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
-   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires
-   c = stbi__get8(s);
-   if (c != 3 && c != 1) return stbi__err("bad component count","Corrupt JPEG");    // JFIF requires
-   s->img_n = c;
-   for (i=0; i < c; ++i) {
-      z->img_comp[i].data = NULL;
-      z->img_comp[i].linebuf = NULL;
-   }
-
-   if (Lf != 8+3*s->img_n) return stbi__err("bad stbi__SOF len","Corrupt JPEG");
-
-   for (i=0; i < s->img_n; ++i) {
-      z->img_comp[i].id = stbi__get8(s);
-      if (z->img_comp[i].id != i+1)   // JFIF requires
-         if (z->img_comp[i].id != i)  // some version of jpegtran outputs non-JFIF-compliant files!
-            return stbi__err("bad component ID","Corrupt JPEG");
-      q = stbi__get8(s);
-      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");
-      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");
-      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");
-   }
-
-   if (scan != SCAN_load) return 1;
-
-   if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
-
-   for (i=0; i < s->img_n; ++i) {
-      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
-      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
-   }
-
-   // compute interleaved mcu info
-   z->img_h_max = h_max;
-   z->img_v_max = v_max;
-   z->img_mcu_w = h_max * 8;
-   z->img_mcu_h = v_max * 8;
-   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
-   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;
-
-   for (i=0; i < s->img_n; ++i) {
-      // number of effective pixels (e.g. for non-interleaved MCU)
-      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
-      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
-      // to simplify generation, we'll allocate enough memory to decode
-      // the bogus oversized data from using interleaved MCUs and their
-      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
-      // discard the extra data until colorspace conversion
-      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
-      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
-      z->img_comp[i].raw_data = stbi__malloc(z->img_comp[i].w2 * z->img_comp[i].h2+15);
-      if (z->img_comp[i].raw_data == NULL) {
-         for(--i; i >= 0; --i) {
-            free(z->img_comp[i].raw_data);
-            z->img_comp[i].data = NULL;
-         }
-         return stbi__err("outofmem", "Out of memory");
-      }
-      // align blocks for installable-idct using mmx/sse
-      z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
-      z->img_comp[i].linebuf = NULL;
-   }
-
-   return 1;
-}
-
-// use comparisons since in some cases we handle more than one case (e.g. stbi__SOF)
-#define stbi__DNL(x)         ((x) == 0xdc)
-#define stbi__SOI(x)         ((x) == 0xd8)
-#define stbi__EOI(x)         ((x) == 0xd9)
-#define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1)
-#define stbi__SOS(x)         ((x) == 0xda)
-
-static int decode_jpeg_header(stbi__jpeg *z, int scan)
-{
-   int m;
-   z->marker = STBI__MARKER_none; // initialize cached marker to empty
-   m = stbi__get_marker(z);
-   if (!stbi__SOI(m)) return stbi__err("no stbi__SOI","Corrupt JPEG");
-   if (scan == SCAN_type) return 1;
-   m = stbi__get_marker(z);
-   while (!stbi__SOF(m)) {
-      if (!stbi__process_marker(z,m)) return 0;
-      m = stbi__get_marker(z);
-      while (m == STBI__MARKER_none) {
-         // some files have extra padding after their blocks, so ok, we'll scan
-         if (stbi__at_eof(z->s)) return stbi__err("no stbi__SOF", "Corrupt JPEG");
-         m = stbi__get_marker(z);
-      }
-   }
-   if (!stbi__process_frame_header(z, scan)) return 0;
-   return 1;
-}
-
-static int decode_jpeg_image(stbi__jpeg *j)
-{
-   int m;
-   j->restart_interval = 0;
-   if (!decode_jpeg_header(j, SCAN_load)) return 0;
-   m = stbi__get_marker(j);
-   while (!stbi__EOI(m)) {
-      if (stbi__SOS(m)) {
-         if (!stbi__process_scan_header(j)) return 0;
-         if (!stbi__parse_entropy_coded_data(j)) return 0;
-         if (j->marker == STBI__MARKER_none ) {
-            // handle 0s at the end of image data from IP Kamera 9060
-            while (!stbi__at_eof(j->s)) {
-               int x = stbi__get8(j->s);
-               if (x == 255) {
-                  j->marker = stbi__get8(j->s);
-                  break;
-               } else if (x != 0) {
-                  return 0;
-               }
-            }
-            // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
-         }
-      } else {
-         if (!stbi__process_marker(j, m)) return 0;
-      }
-      m = stbi__get_marker(j);
-   }
-   return 1;
-}
-
-// static jfif-centered resampling (across block boundaries)
-
-typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
-                                    int w, int hs);
-
-#define stbi__div4(x) ((stbi_uc) ((x) >> 2))
-
-static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
-{
-   STBI_NOTUSED(out);
-   STBI_NOTUSED(in_far);
-   STBI_NOTUSED(w);
-   STBI_NOTUSED(hs);
-   return in_near;
-}
-
-static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
-{
-   // need to generate two samples vertically for every one in input
-   int i;
-   STBI_NOTUSED(hs);
-   for (i=0; i < w; ++i)
-      out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);
-   return out;
-}
-
-static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
-{
-   // need to generate two samples horizontally for every one in input
-   int i;
-   stbi_uc *input = in_near;
-
-   if (w == 1) {
-      // if only one sample, can't do any interpolation
-      out[0] = out[1] = input[0];
-      return out;
-   }
-
-   out[0] = input[0];
-   out[1] = stbi__div4(input[0]*3 + input[1] + 2);
-   for (i=1; i < w-1; ++i) {
-      int n = 3*input[i]+2;
-      out[i*2+0] = stbi__div4(n+input[i-1]);
-      out[i*2+1] = stbi__div4(n+input[i+1]);
-   }
-   out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
-   out[i*2+1] = input[w-1];
-
-   STBI_NOTUSED(in_far);
-   STBI_NOTUSED(hs);
-
-   return out;
-}
-
-#define stbi__div16(x) ((stbi_uc) ((x) >> 4))
-
-static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
-{
-   // need to generate 2x2 samples for every one in input
-   int i,t0,t1;
-   if (w == 1) {
-      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
-      return out;
-   }
-
-   t1 = 3*in_near[0] + in_far[0];
-   out[0] = stbi__div4(t1+2);
-   for (i=1; i < w; ++i) {
-      t0 = t1;
-      t1 = 3*in_near[i]+in_far[i];
-      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
-      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
-   }
-   out[w*2-1] = stbi__div4(t1+2);
-
-   STBI_NOTUSED(hs);
-
-   return out;
-}
-
-static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
-{
-   // resample with nearest-neighbor
-   int i,j;
-   STBI_NOTUSED(in_far);
-   for (i=0; i < w; ++i)
-      for (j=0; j < hs; ++j)
-         out[i*hs+j] = in_near[i];
-   return out;
-}
-
-#define float2fixed(x)  ((int) ((x) * 65536 + 0.5))
-
-// 0.38 seconds on 3*anemones.jpg   (0.25 with processor = Pro)
-// VC6 without processor=Pro is generating multiple LEAs per multiply!
-static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
-{
-   int i;
-   for (i=0; i < count; ++i) {
-      int y_fixed = (y[i] << 16) + 32768; // rounding
-      int r,g,b;
-      int cr = pcr[i] - 128;
-      int cb = pcb[i] - 128;
-      r = y_fixed + cr*float2fixed(1.40200f);
-      g = y_fixed - cr*float2fixed(0.71414f) - cb*float2fixed(0.34414f);
-      b = y_fixed                            + cb*float2fixed(1.77200f);
-      r >>= 16;
-      g >>= 16;
-      b >>= 16;
-      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
-      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
-      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
-      out[0] = (stbi_uc)r;
-      out[1] = (stbi_uc)g;
-      out[2] = (stbi_uc)b;
-      out[3] = 255;
-      out += step;
-   }
-}
-
-#ifdef STBI_SIMD
-static stbi_YCbCr_to_RGB_run stbi__YCbCr_installed = stbi__YCbCr_to_RGB_row;
-
-STBIDEF void stbi_install_YCbCr_to_RGB(stbi_YCbCr_to_RGB_run func)
-{
-   stbi__YCbCr_installed = func;
-}
-#endif
-
-
-// clean up the temporary component buffers
-static void stbi__cleanup_jpeg(stbi__jpeg *j)
-{
-   int i;
-   for (i=0; i < j->s->img_n; ++i) {
-      if (j->img_comp[i].raw_data) {
-         free(j->img_comp[i].raw_data);
-         j->img_comp[i].raw_data = NULL;
-         j->img_comp[i].data = NULL;
-      }
-      if (j->img_comp[i].linebuf) {
-         free(j->img_comp[i].linebuf);
-         j->img_comp[i].linebuf = NULL;
-      }
-   }
-}
-
-typedef struct
-{
-   resample_row_func resample;
-   stbi_uc *line0,*line1;
-   int hs,vs;   // expansion factor in each axis
-   int w_lores; // horizontal pixels pre-expansion 
-   int ystep;   // how far through vertical expansion we are
-   int ypos;    // which pre-expansion row we're on
-} stbi__resample;
-
-static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
-{
-   int n, decode_n;
-   z->s->img_n = 0; // make stbi__cleanup_jpeg safe
-
-   // validate req_comp
-   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
-
-   // load a jpeg image from whichever source
-   if (!decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }
-
-   // determine actual number of components to generate
-   n = req_comp ? req_comp : z->s->img_n;
-
-   if (z->s->img_n == 3 && n < 3)
-      decode_n = 1;
-   else
-      decode_n = z->s->img_n;
-
-   // resample and color-convert
-   {
-      int k;
-      unsigned int i,j;
-      stbi_uc *output;
-      stbi_uc *coutput[4];
-
-      stbi__resample res_comp[4];
-
-      for (k=0; k < decode_n; ++k) {
-         stbi__resample *r = &res_comp[k];
-
-         // allocate line buffer big enough for upsampling off the edges
-         // with upsample factor of 4
-         z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
-         if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
-
-         r->hs      = z->img_h_max / z->img_comp[k].h;
-         r->vs      = z->img_v_max / z->img_comp[k].v;
-         r->ystep   = r->vs >> 1;
-         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
-         r->ypos    = 0;
-         r->line0   = r->line1 = z->img_comp[k].data;
-
-         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
-         else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
-         else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
-         else if (r->hs == 2 && r->vs == 2) r->resample = stbi__resample_row_hv_2;
-         else                               r->resample = stbi__resample_row_generic;
-      }
-
-      // can't error after this so, this is safe
-      output = (stbi_uc *) stbi__malloc(n * z->s->img_x * z->s->img_y + 1);
-      if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }
-
-      // now go ahead and resample
-      for (j=0; j < z->s->img_y; ++j) {
-         stbi_uc *out = output + n * z->s->img_x * j;
-         for (k=0; k < decode_n; ++k) {
-            stbi__resample *r = &res_comp[k];
-            int y_bot = r->ystep >= (r->vs >> 1);
-            coutput[k] = r->resample(z->img_comp[k].linebuf,
-                                     y_bot ? r->line1 : r->line0,
-                                     y_bot ? r->line0 : r->line1,
-                                     r->w_lores, r->hs);
-            if (++r->ystep >= r->vs) {
-               r->ystep = 0;
-               r->line0 = r->line1;
-               if (++r->ypos < z->img_comp[k].y)
-                  r->line1 += z->img_comp[k].w2;
-            }
-         }
-         if (n >= 3) {
-            stbi_uc *y = coutput[0];
-            if (z->s->img_n == 3) {
-               #ifdef STBI_SIMD
-               stbi__YCbCr_installed(out, y, coutput[1], coutput[2], z->s->img_x, n);
-               #else
-               stbi__YCbCr_to_RGB_row(out, y, coutput[1], coutput[2], z->s->img_x, n);
-               #endif
-            } else
-               for (i=0; i < z->s->img_x; ++i) {
-                  out[0] = out[1] = out[2] = y[i];
-                  out[3] = 255; // not used if n==3
-                  out += n;
-               }
-         } else {
-            stbi_uc *y = coutput[0];
-            if (n == 1)
-               for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
-            else
-               for (i=0; i < z->s->img_x; ++i) *out++ = y[i], *out++ = 255;
-         }
-      }
-      stbi__cleanup_jpeg(z);
-      *out_x = z->s->img_x;
-      *out_y = z->s->img_y;
-      if (comp) *comp  = z->s->img_n; // report original components, not output
-      return output;
-   }
-}
-
-static unsigned char *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
-{
-   stbi__jpeg j;
-   j.s = s;
-   return load_jpeg_image(&j, x,y,comp,req_comp);
-}
-
-static int stbi__jpeg_test(stbi__context *s)
-{
-   int r;
-   stbi__jpeg j;
-   j.s = s;
-   r = decode_jpeg_header(&j, SCAN_type);
-   stbi__rewind(s);
-   return r;
-}
-
-static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
-{
-   if (!decode_jpeg_header(j, SCAN_header)) {
-      stbi__rewind( j->s );
-      return 0;
-   }
-   if (x) *x = j->s->img_x;
-   if (y) *y = j->s->img_y;
-   if (comp) *comp = j->s->img_n;
-   return 1;
-}
-
-static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
-{
-   stbi__jpeg j;
-   j.s = s;
-   return stbi__jpeg_info_raw(&j, x, y, comp);
-}
-
-// public domain zlib decode    v0.2  Sean Barrett 2006-11-18
-//    simple implementation
-//      - all input must be provided in an upfront buffer
-//      - all output is written to a single output buffer (can malloc/realloc)
-//    performance
-//      - fast huffman
-
-// fast-way is faster to check than jpeg huffman, but slow way is slower
-#define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
-#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)
-
-// zlib-style huffman encoding
-// (jpegs packs from left, zlib from right, so can't share code)
-typedef struct
-{
-   stbi__uint16 fast[1 << STBI__ZFAST_BITS];
-   stbi__uint16 firstcode[16];
-   int maxcode[17];
-   stbi__uint16 firstsymbol[16];
-   stbi_uc  size[288];
-   stbi__uint16 value[288];
-} stbi__zhuffman;
-
-stbi_inline static int stbi__bitreverse16(int n)
-{
-  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
-  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
-  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
-  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
-  return n;
-}
-
-stbi_inline static int stbi__bit_reverse(int v, int bits)
-{
-   STBI_ASSERT(bits <= 16);
-   // to bit reverse n bits, reverse 16 and shift
-   // e.g. 11 bits, bit reverse and shift away 5
-   return stbi__bitreverse16(v) >> (16-bits);
-}
-
-static int stbi__zbuild_huffman(stbi__zhuffman *z, stbi_uc *sizelist, int num)
-{
-   int i,k=0;
-   int code, next_code[16], sizes[17];
-
-   // DEFLATE spec for generating codes
-   memset(sizes, 0, sizeof(sizes));
-   memset(z->fast, 0, sizeof(z->fast));
-   for (i=0; i < num; ++i) 
-      ++sizes[sizelist[i]];
-   sizes[0] = 0;
-   for (i=1; i < 16; ++i)
-      STBI_ASSERT(sizes[i] <= (1 << i));
-   code = 0;
-   for (i=1; i < 16; ++i) {
-      next_code[i] = code;
-      z->firstcode[i] = (stbi__uint16) code;
-      z->firstsymbol[i] = (stbi__uint16) k;
-      code = (code + sizes[i]);
-      if (sizes[i])
-         if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt JPEG");
-      z->maxcode[i] = code << (16-i); // preshift for inner loop
-      code <<= 1;
-      k += sizes[i];
-   }
-   z->maxcode[16] = 0x10000; // sentinel
-   for (i=0; i < num; ++i) {
-      int s = sizelist[i];
-      if (s) {
-         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
-         stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
-         z->size [c] = (stbi_uc     ) s;
-         z->value[c] = (stbi__uint16) i;
-         if (s <= STBI__ZFAST_BITS) {
-            int k = stbi__bit_reverse(next_code[s],s);
-            while (k < (1 << STBI__ZFAST_BITS)) {
-               z->fast[k] = fastv;
-               k += (1 << s);
-            }
-         }
-         ++next_code[s];
-      }
-   }
-   return 1;
-}
-
-// zlib-from-memory implementation for PNG reading
-//    because PNG allows splitting the zlib stream arbitrarily,
-//    and it's annoying structurally to have PNG call ZLIB call PNG,
-//    we require PNG read all the IDATs and combine them into a single
-//    memory buffer
-
-typedef struct
-{
-   stbi_uc *zbuffer, *zbuffer_end;
-   int num_bits;
-   stbi__uint32 code_buffer;
-
-   char *zout;
-   char *zout_start;
-   char *zout_end;
-   int   z_expandable;
-
-   stbi__zhuffman z_length, z_distance;
-} stbi__zbuf;
-
-stbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)
-{
-   if (z->zbuffer >= z->zbuffer_end) return 0;
-   return *z->zbuffer++;
-}
-
-static void stbi__fill_bits(stbi__zbuf *z)
-{
-   do {
-      STBI_ASSERT(z->code_buffer < (1U << z->num_bits));
-      z->code_buffer |= stbi__zget8(z) << z->num_bits;
-      z->num_bits += 8;
-   } while (z->num_bits <= 24);
-}
-
-stbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
-{
-   unsigned int k;
-   if (z->num_bits < n) stbi__fill_bits(z);
-   k = z->code_buffer & ((1 << n) - 1);
-   z->code_buffer >>= n;
-   z->num_bits -= n;
-   return k;   
-}
-
-static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
-{
-   int b,s,k;
-   // not resolved by fast table, so compute it the slow way
-   // use jpeg approach, which requires MSbits at top
-   k = stbi__bit_reverse(a->code_buffer, 16);
-   for (s=STBI__ZFAST_BITS+1; ; ++s)
-      if (k < z->maxcode[s])
-         break;
-   if (s == 16) return -1; // invalid code!
-   // code size is s, so:
-   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
-   STBI_ASSERT(z->size[b] == s);
-   a->code_buffer >>= s;
-   a->num_bits -= s;
-   return z->value[b];
-}
-
-stbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
-{
-   int b,s;
-   if (a->num_bits < 16) stbi__fill_bits(a);
-   b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
-   if (b) {
-      s = b >> 9;
-      a->code_buffer >>= s;
-      a->num_bits -= s;
-      return b & 511;
-   }
-   return stbi__zhuffman_decode_slowpath(a, z);
-}
-
-static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
-{
-   char *q;
-   int cur, limit;
-   z->zout = zout;
-   if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");
-   cur   = (int) (z->zout     - z->zout_start);
-   limit = (int) (z->zout_end - z->zout_start);
-   while (cur + n > limit)
-      limit *= 2;
-   q = (char *) realloc(z->zout_start, limit);
-   if (q == NULL) return stbi__err("outofmem", "Out of memory");
-   z->zout_start = q;
-   z->zout       = q + cur;
-   z->zout_end   = q + limit;
-   return 1;
-}
-
-static int stbi__zlength_base[31] = {
-   3,4,5,6,7,8,9,10,11,13,
-   15,17,19,23,27,31,35,43,51,59,
-   67,83,99,115,131,163,195,227,258,0,0 };
-
-static int stbi__zlength_extra[31]=
-{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };
-
-static int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
-257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};
-
-static int stbi__zdist_extra[32] =
-{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
-
-static int stbi__parse_huffman_block(stbi__zbuf *a)
-{
-   char *zout = a->zout;
-   for(;;) {
-      int z = stbi__zhuffman_decode(a, &a->z_length);
-      if (z < 256) {
-         if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes
-         if (zout >= a->zout_end) {
-            if (!stbi__zexpand(a, zout, 1)) return 0;
-            zout = a->zout;
-         }
-         *zout++ = (char) z;
-      } else {
-         stbi_uc *p;
-         int len,dist;
-         if (z == 256) {
-            a->zout = zout;
-            return 1;
-         }
-         z -= 257;
-         len = stbi__zlength_base[z];
-         if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
-         z = stbi__zhuffman_decode(a, &a->z_distance);
-         if (z < 0) return stbi__err("bad huffman code","Corrupt PNG");
-         dist = stbi__zdist_base[z];
-         if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
-         if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");
-         if (zout + len > a->zout_end) {
-            if (!stbi__zexpand(a, zout, len)) return 0;
-            zout = a->zout;
-         }
-         p = (stbi_uc *) (zout - dist);
-         if (dist == 1) { // run of one byte; common in images.
-            stbi_uc v = *p;
-            do *zout++ = v; while (--len);
-         } else {
-            do *zout++ = *p++; while (--len);
-         }
-      }
-   }
-}
-
-static int stbi__compute_huffman_codes(stbi__zbuf *a)
-{
-   static stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
-   stbi__zhuffman z_codelength;
-   stbi_uc lencodes[286+32+137];//padding for maximum single op
-   stbi_uc codelength_sizes[19];
-   int i,n;
-
-   int hlit  = stbi__zreceive(a,5) + 257;
-   int hdist = stbi__zreceive(a,5) + 1;
-   int hclen = stbi__zreceive(a,4) + 4;
-
-   memset(codelength_sizes, 0, sizeof(codelength_sizes));
-   for (i=0; i < hclen; ++i) {
-      int s = stbi__zreceive(a,3);
-      codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
-   }
-   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;
-
-   n = 0;
-   while (n < hlit + hdist) {
-      int c = stbi__zhuffman_decode(a, &z_codelength);
-      STBI_ASSERT(c >= 0 && c < 19);
-      if (c < 16)
-         lencodes[n++] = (stbi_uc) c;
-      else if (c == 16) {
-         c = stbi__zreceive(a,2)+3;
-         memset(lencodes+n, lencodes[n-1], c);
-         n += c;
-      } else if (c == 17) {
-         c = stbi__zreceive(a,3)+3;
-         memset(lencodes+n, 0, c);
-         n += c;
-      } else {
-         STBI_ASSERT(c == 18);
-         c = stbi__zreceive(a,7)+11;
-         memset(lencodes+n, 0, c);
-         n += c;
-      }
-   }
-   if (n != hlit+hdist) return stbi__err("bad codelengths","Corrupt PNG");
-   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
-   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
-   return 1;
-}
-
-static int stbi__parse_uncomperssed_block(stbi__zbuf *a)
-{
-   stbi_uc header[4];
-   int len,nlen,k;
-   if (a->num_bits & 7)
-      stbi__zreceive(a, a->num_bits & 7); // discard
-   // drain the bit-packed data into header
-   k = 0;
-   while (a->num_bits > 0) {
-      header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
-      a->code_buffer >>= 8;
-      a->num_bits -= 8;
-   }
-   STBI_ASSERT(a->num_bits == 0);
-   // now fill header the normal way
-   while (k < 4)
-      header[k++] = stbi__zget8(a);
-   len  = header[1] * 256 + header[0];
-   nlen = header[3] * 256 + header[2];
-   if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");
-   if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");
-   if (a->zout + len > a->zout_end)
-      if (!stbi__zexpand(a, a->zout, len)) return 0;
-   memcpy(a->zout, a->zbuffer, len);
-   a->zbuffer += len;
-   a->zout += len;
-   return 1;
-}
-
-static int stbi__parse_zlib_header(stbi__zbuf *a)
-{
-   int cmf   = stbi__zget8(a);
-   int cm    = cmf & 15;
-   /* int cinfo = cmf >> 4; */
-   int flg   = stbi__zget8(a);
-   if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
-   if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
-   if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png
-   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
-   return 1;
-}
-
-// @TODO: should statically initialize these for optimal thread safety
-static stbi_uc stbi__zdefault_length[288], stbi__zdefault_distance[32];
-static void stbi__init_zdefaults(void)
-{
-   int i;   // use <= to match clearly with spec
-   for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;
-   for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;
-   for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;
-   for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;
-
-   for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;
-}
-
-static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
-{
-   int final, type;
-   if (parse_header)
-      if (!stbi__parse_zlib_header(a)) return 0;
-   a->num_bits = 0;
-   a->code_buffer = 0;
-   do {
-      final = stbi__zreceive(a,1);
-      type = stbi__zreceive(a,2);
-      if (type == 0) {
-         if (!stbi__parse_uncomperssed_block(a)) return 0;
-      } else if (type == 3) {
-         return 0;
-      } else {
-         if (type == 1) {
-            // use fixed code lengths
-            if (!stbi__zdefault_distance[31]) stbi__init_zdefaults();
-            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , 288)) return 0;
-            if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
-         } else {
-            if (!stbi__compute_huffman_codes(a)) return 0;
-         }
-         if (!stbi__parse_huffman_block(a)) return 0;
-      }
-   } while (!final);
-   return 1;
-}
-
-static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
-{
-   a->zout_start = obuf;
-   a->zout       = obuf;
-   a->zout_end   = obuf + olen;
-   a->z_expandable = exp;
-
-   return stbi__parse_zlib(a, parse_header);
-}
-
-STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
-{
-   stbi__zbuf a;
-   char *p = (char *) stbi__malloc(initial_size);
-   if (p == NULL) return NULL;
-   a.zbuffer = (stbi_uc *) buffer;
-   a.zbuffer_end = (stbi_uc *) buffer + len;
-   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
-      if (outlen) *outlen = (int) (a.zout - a.zout_start);
-      return a.zout_start;
-   } else {
-      free(a.zout_start);
-      return NULL;
-   }
-}
-
-STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
-{
-   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
-}
-
-STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
-{
-   stbi__zbuf a;
-   char *p = (char *) stbi__malloc(initial_size);
-   if (p == NULL) return NULL;
-   a.zbuffer = (stbi_uc *) buffer;
-   a.zbuffer_end = (stbi_uc *) buffer + len;
-   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
-      if (outlen) *outlen = (int) (a.zout - a.zout_start);
-      return a.zout_start;
-   } else {
-      free(a.zout_start);
-      return NULL;
-   }
-}
-
-STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
-{
-   stbi__zbuf a;
-   a.zbuffer = (stbi_uc *) ibuffer;
-   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
-   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
-      return (int) (a.zout - a.zout_start);
-   else
-      return -1;
-}
-
-STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
-{
-   stbi__zbuf a;
-   char *p = (char *) stbi__malloc(16384);
-   if (p == NULL) return NULL;
-   a.zbuffer = (stbi_uc *) buffer;
-   a.zbuffer_end = (stbi_uc *) buffer+len;
-   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
-      if (outlen) *outlen = (int) (a.zout - a.zout_start);
-      return a.zout_start;
-   } else {
-      free(a.zout_start);
-      return NULL;
-   }
-}
-
-STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
-{
-   stbi__zbuf a;
-   a.zbuffer = (stbi_uc *) ibuffer;
-   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
-   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
-      return (int) (a.zout - a.zout_start);
-   else
-      return -1;
-}
-
-// public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
-//    simple implementation
-//      - only 8-bit samples
-//      - no CRC checking
-//      - allocates lots of intermediate memory
-//        - avoids problem of streaming data between subsystems
-//        - avoids explicit window management
-//    performance
-//      - uses stb_zlib, a PD zlib implementation with fast huffman decoding
-
-
-typedef struct
-{
-   stbi__uint32 length;
-   stbi__uint32 type;
-} stbi__pngchunk;
-
-static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
-{
-   stbi__pngchunk c;
-   c.length = stbi__get32be(s);
-   c.type   = stbi__get32be(s);
-   return c;
-}
-
-static int stbi__check_png_header(stbi__context *s)
-{
-   static stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
-   int i;
-   for (i=0; i < 8; ++i)
-      if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");
-   return 1;
-}
-
-typedef struct
-{
-   stbi__context *s;
-   stbi_uc *idata, *expanded, *out;
-} stbi__png;
-
-
-enum {
-   STBI__F_none=0,
-   STBI__F_sub=1,
-   STBI__F_up=2,
-   STBI__F_avg=3,
-   STBI__F_paeth=4,
-   // synthetic filters used for first scanline to avoid needing a dummy row of 0s
-   STBI__F_avg_first,
-   STBI__F_paeth_first
-};
-
-static stbi_uc first_row_filter[5] =
-{
-   STBI__F_none,
-   STBI__F_sub,
-   STBI__F_none,
-   STBI__F_avg_first,
-   STBI__F_paeth_first
-};
-
-static int stbi__paeth(int a, int b, int c)
-{
-   int p = a + b - c;
-   int pa = abs(p-a);
-   int pb = abs(p-b);
-   int pc = abs(p-c);
-   if (pa <= pb && pa <= pc) return a;
-   if (pb <= pc) return b;
-   return c;
-}
-
-#define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings
-
-static stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };
-
-// create the png data from post-deflated data
-static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
-{
-   stbi__context *s = a->s;
-   stbi__uint32 i,j,stride = x*out_n;
-   stbi__uint32 img_len, img_width_bytes;
-   int k;
-   int img_n = s->img_n; // copy it into a local for later
-
-   STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
-   a->out = (stbi_uc *) stbi__malloc(x * y * out_n); // extra bytes to write off the end into
-   if (!a->out) return stbi__err("outofmem", "Out of memory");
-
-   img_width_bytes = (((img_n * x * depth) + 7) >> 3);
-   img_len = (img_width_bytes + 1) * y;
-   if (s->img_x == x && s->img_y == y) {
-      if (raw_len != img_len) return stbi__err("not enough pixels","Corrupt PNG");
-   } else { // interlaced:
-      if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");
-   }
-
-   for (j=0; j < y; ++j) {
-      stbi_uc *cur = a->out + stride*j;
-      stbi_uc *prior = cur - stride;
-      int filter = *raw++;
-      int filter_bytes = img_n;
-      int width = x;
-      if (filter > 4)
-         return stbi__err("invalid filter","Corrupt PNG");
-
-      if (depth < 8) {
-         STBI_ASSERT(img_width_bytes <= x);
-         cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
-         filter_bytes = 1;
-         width = img_width_bytes;
-      }
-
-      // if first row, use special filter that doesn't sample previous row
-      if (j == 0) filter = first_row_filter[filter];
-
-      // handle first byte explicitly
-      for (k=0; k < filter_bytes; ++k) {
-         switch (filter) {
-            case STBI__F_none       : cur[k] = raw[k]; break;
-            case STBI__F_sub        : cur[k] = raw[k]; break;
-            case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
-            case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;
-            case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;
-            case STBI__F_avg_first  : cur[k] = raw[k]; break;
-            case STBI__F_paeth_first: cur[k] = raw[k]; break;
-         }
-      }
-
-      if (depth == 8) {
-         if (img_n != out_n)
-            cur[img_n] = 255; // first pixel
-         raw += img_n;
-         cur += out_n;
-         prior += out_n;
-      } else {
-         raw += 1;
-         cur += 1;
-         prior += 1;
-      }
-
-      // this is a little gross, so that we don't switch per-pixel or per-component
-      if (depth < 8 || img_n == out_n) {
-         int nk = (width - 1)*img_n;
-         #define CASE(f) \
-             case f:     \
-                for (k=0; k < nk; ++k)
-         switch (filter) {
-            // "none" filter turns into a memcpy here; make that explicit.
-            case STBI__F_none:         memcpy(cur, raw, nk); break;
-            CASE(STBI__F_sub)          cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); break;
-            CASE(STBI__F_up)           cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
-            CASE(STBI__F_avg)          cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); break;
-            CASE(STBI__F_paeth)        cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); break;
-            CASE(STBI__F_avg_first)    cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); break;
-            CASE(STBI__F_paeth_first)  cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); break;
-         }
-         #undef CASE
-         raw += nk;
-      } else {
-         STBI_ASSERT(img_n+1 == out_n);
-         #define CASE(f) \
-             case f:     \
-                for (i=x-1; i >= 1; --i, cur[img_n]=255,raw+=img_n,cur+=out_n,prior+=out_n) \
-                   for (k=0; k < img_n; ++k)
-         switch (filter) {
-            CASE(STBI__F_none)         cur[k] = raw[k]; break;
-            CASE(STBI__F_sub)          cur[k] = STBI__BYTECAST(raw[k] + cur[k-out_n]); break;
-            CASE(STBI__F_up)           cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
-            CASE(STBI__F_avg)          cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-out_n])>>1)); break;
-            CASE(STBI__F_paeth)        cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-out_n],prior[k],prior[k-out_n])); break;
-            CASE(STBI__F_avg_first)    cur[k] = STBI__BYTECAST(raw[k] + (cur[k-out_n] >> 1)); break;
-            CASE(STBI__F_paeth_first)  cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-out_n],0,0)); break;
-         }
-         #undef CASE
-      }
-   }
-
-   // we make a separate pass to expand bits to pixels; for performance,
-   // this could run two scanlines behind the above code, so it won't
-   // intefere with filtering but will still be in the cache.
-   if (depth < 8) {
-      for (j=0; j < y; ++j) {
-         stbi_uc *cur = a->out + stride*j;
-         stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;
-         // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
-         // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
-         stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range
-
-         // note that the final byte might overshoot and write more data than desired.
-         // we can allocate enough data that this never writes out of memory, but it
-         // could also overwrite the next scanline. can it overwrite non-empty data
-         // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
-         // so we need to explicitly clamp the final ones
-
-         if (depth == 4) {
-            for (k=x*img_n; k >= 2; k-=2, ++in) {
-               *cur++ = scale * ((*in >> 4)       );
-               *cur++ = scale * ((*in     ) & 0x0f);
-            }
-            if (k > 0) *cur++ = scale * ((*in >> 4)       );
-         } else if (depth == 2) {
-            for (k=x*img_n; k >= 4; k-=4, ++in) {
-               *cur++ = scale * ((*in >> 6)       );
-               *cur++ = scale * ((*in >> 4) & 0x03);
-               *cur++ = scale * ((*in >> 2) & 0x03);
-               *cur++ = scale * ((*in     ) & 0x03);
-            }
-            if (k > 0) *cur++ = scale * ((*in >> 6)       );
-            if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);
-            if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);
-         } else if (depth == 1) {
-            for (k=x*img_n; k >= 8; k-=8, ++in) {
-               *cur++ = scale * ((*in >> 7)       );
-               *cur++ = scale * ((*in >> 6) & 0x01);
-               *cur++ = scale * ((*in >> 5) & 0x01);
-               *cur++ = scale * ((*in >> 4) & 0x01);
-               *cur++ = scale * ((*in >> 3) & 0x01);
-               *cur++ = scale * ((*in >> 2) & 0x01);
-               *cur++ = scale * ((*in >> 1) & 0x01);
-               *cur++ = scale * ((*in     ) & 0x01);
-            }
-            if (k > 0) *cur++ = scale * ((*in >> 7)       );
-            if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);
-            if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);
-            if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);
-            if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);
-            if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);
-            if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);
-         }
-         if (img_n != out_n) {
-            // insert alpha = 255
-            stbi_uc *cur = a->out + stride*j;
-            int i;
-            if (img_n == 1) {
-               for (i=x-1; i >= 0; --i) {
-                  cur[i*2+1] = 255;
-                  cur[i*2+0] = cur[i];
-               }
-            } else {
-               assert(img_n == 3);
-               for (i=x-1; i >= 0; --i) {
-                  cur[i*4+3] = 255;
-                  cur[i*4+2] = cur[i*3+2];
-                  cur[i*4+1] = cur[i*3+1];
-                  cur[i*4+0] = cur[i*3+0];
-               }
-            }
-         }
-      }
-   }
-
-   return 1;
-}
-
-static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
-{
-   stbi_uc *final;
-   int p;
-   if (!interlaced)
-      return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);
-
-   // de-interlacing
-   final = (stbi_uc *) stbi__malloc(a->s->img_x * a->s->img_y * out_n);
-   for (p=0; p < 7; ++p) {
-      int xorig[] = { 0,4,0,2,0,1,0 };
-      int yorig[] = { 0,0,4,0,2,0,1 };
-      int xspc[]  = { 8,8,4,4,2,2,1 };
-      int yspc[]  = { 8,8,8,4,4,2,2 };
-      int i,j,x,y;
-      // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
-      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
-      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
-      if (x && y) {
-         stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
-         if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
-            free(final);
-            return 0;
-         }
-         for (j=0; j < y; ++j) {
-            for (i=0; i < x; ++i) {
-               int out_y = j*yspc[p]+yorig[p];
-               int out_x = i*xspc[p]+xorig[p];
-               memcpy(final + out_y*a->s->img_x*out_n + out_x*out_n,
-                      a->out + (j*x+i)*out_n, out_n);
-            }
-         }
-         free(a->out);
-         image_data += img_len;
-         image_data_len -= img_len;
-      }
-   }
-   a->out = final;
-
-   return 1;
-}
-
-static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
-{
-   stbi__context *s = z->s;
-   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
-   stbi_uc *p = z->out;
-
-   // compute color-based transparency, assuming we've
-   // already got 255 as the alpha value in the output
-   STBI_ASSERT(out_n == 2 || out_n == 4);
-
-   if (out_n == 2) {
-      for (i=0; i < pixel_count; ++i) {
-         p[1] = (p[0] == tc[0] ? 0 : 255);
-         p += 2;
-      }
-   } else {
-      for (i=0; i < pixel_count; ++i) {
-         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
-            p[3] = 0;
-         p += 4;
-      }
-   }
-   return 1;
-}
-
-static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
-{
-   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
-   stbi_uc *p, *temp_out, *orig = a->out;
-
-   p = (stbi_uc *) stbi__malloc(pixel_count * pal_img_n);
-   if (p == NULL) return stbi__err("outofmem", "Out of memory");
-
-   // between here and free(out) below, exitting would leak
-   temp_out = p;
-
-   if (pal_img_n == 3) {
-      for (i=0; i < pixel_count; ++i) {
-         int n = orig[i]*4;
-         p[0] = palette[n  ];
-         p[1] = palette[n+1];
-         p[2] = palette[n+2];
-         p += 3;
-      }
-   } else {
-      for (i=0; i < pixel_count; ++i) {
-         int n = orig[i]*4;
-         p[0] = palette[n  ];
-         p[1] = palette[n+1];
-         p[2] = palette[n+2];
-         p[3] = palette[n+3];
-         p += 4;
-      }
-   }
-   free(a->out);
-   a->out = temp_out;
-
-   STBI_NOTUSED(len);
-
-   return 1;
-}
-
-static int stbi__unpremultiply_on_load = 0;
-static int stbi__de_iphone_flag = 0;
-
-STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
-{
-   stbi__unpremultiply_on_load = flag_true_if_should_unpremultiply;
-}
-
-STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
-{
-   stbi__de_iphone_flag = flag_true_if_should_convert;
-}
-
-static void stbi__de_iphone(stbi__png *z)
-{
-   stbi__context *s = z->s;
-   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
-   stbi_uc *p = z->out;
-
-   if (s->img_out_n == 3) {  // convert bgr to rgb
-      for (i=0; i < pixel_count; ++i) {
-         stbi_uc t = p[0];
-         p[0] = p[2];
-         p[2] = t;
-         p += 3;
-      }
-   } else {
-      STBI_ASSERT(s->img_out_n == 4);
-      if (stbi__unpremultiply_on_load) {
-         // convert bgr to rgb and unpremultiply
-         for (i=0; i < pixel_count; ++i) {
-            stbi_uc a = p[3];
-            stbi_uc t = p[0];
-            if (a) {
-               p[0] = p[2] * 255 / a;
-               p[1] = p[1] * 255 / a;
-               p[2] =  t   * 255 / a;
-            } else {
-               p[0] = p[2];
-               p[2] = t;
-            } 
-            p += 4;
-         }
-      } else {
-         // convert bgr to rgb
-         for (i=0; i < pixel_count; ++i) {
-            stbi_uc t = p[0];
-            p[0] = p[2];
-            p[2] = t;
-            p += 4;
-         }
-      }
-   }
-}
-
-#define STBI__PNG_TYPE(a,b,c,d)  (((a) << 24) + ((b) << 16) + ((c) << 8) + (d))
-
-static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
-{
-   stbi_uc palette[1024], pal_img_n=0;
-   stbi_uc has_trans=0, tc[3];
-   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
-   int first=1,k,interlace=0, color=0, depth=0, is_iphone=0;
-   stbi__context *s = z->s;
-
-   z->expanded = NULL;
-   z->idata = NULL;
-   z->out = NULL;
-
-   if (!stbi__check_png_header(s)) return 0;
-
-   if (scan == SCAN_type) return 1;
-
-   for (;;) {
-      stbi__pngchunk c = stbi__get_chunk_header(s);
-      switch (c.type) {
-         case STBI__PNG_TYPE('C','g','B','I'):
-            is_iphone = 1;
-            stbi__skip(s, c.length);
-            break;
-         case STBI__PNG_TYPE('I','H','D','R'): {
-            int comp,filter;
-            if (!first) return stbi__err("multiple IHDR","Corrupt PNG");
-            first = 0;
-            if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");
-            s->img_x = stbi__get32be(s); if (s->img_x > (1 << 24)) return stbi__err("too large","Very large image (corrupt?)");
-            s->img_y = stbi__get32be(s); if (s->img_y > (1 << 24)) return stbi__err("too large","Very large image (corrupt?)");
-            depth = stbi__get8(s);  if (depth != 1 && depth != 2 && depth != 4 && depth != 8)  return stbi__err("1/2/4/8-bit only","PNG not supported: 1/2/4/8-bit only");
-            color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");
-            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");
-            comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");
-            filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");
-            interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");
-            if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");
-            if (!pal_img_n) {
-               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
-               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
-               if (scan == SCAN_header) return 1;
-            } else {
-               // if paletted, then pal_n is our final components, and
-               // img_n is # components to decompress/filter.
-               s->img_n = 1;
-               if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");
-               // if SCAN_header, have to scan to see if we have a tRNS
-            }
-            break;
-         }
-
-         case STBI__PNG_TYPE('P','L','T','E'):  {
-            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
-            if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");
-            pal_len = c.length / 3;
-            if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");
-            for (i=0; i < pal_len; ++i) {
-               palette[i*4+0] = stbi__get8(s);
-               palette[i*4+1] = stbi__get8(s);
-               palette[i*4+2] = stbi__get8(s);
-               palette[i*4+3] = 255;
-            }
-            break;
-         }
-
-         case STBI__PNG_TYPE('t','R','N','S'): {
-            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
-            if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");
-            if (pal_img_n) {
-               if (scan == SCAN_header) { s->img_n = 4; return 1; }
-               if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");
-               if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");
-               pal_img_n = 4;
-               for (i=0; i < c.length; ++i)
-                  palette[i*4+3] = stbi__get8(s);
-            } else {
-               if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");
-               if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");
-               has_trans = 1;
-               for (k=0; k < s->img_n; ++k)
-                  tc[k] = (stbi_uc) (stbi__get16be(s) & 255) * stbi__depth_scale_table[depth]; // non 8-bit images will be larger
-            }
-            break;
-         }
-
-         case STBI__PNG_TYPE('I','D','A','T'): {
-            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
-            if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");
-            if (scan == SCAN_header) { s->img_n = pal_img_n; return 1; }
-            if (ioff + c.length > idata_limit) {
-               stbi_uc *p;
-               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
-               while (ioff + c.length > idata_limit)
-                  idata_limit *= 2;
-               p = (stbi_uc *) realloc(z->idata, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");
-               z->idata = p;
-            }
-            if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");
-            ioff += c.length;
-            break;
-         }
-
-         case STBI__PNG_TYPE('I','E','N','D'): {
-            stbi__uint32 raw_len;
-            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
-            if (scan != SCAN_load) return 1;
-            if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");
-            // initial guess for decoded data size to avoid unnecessary reallocs
-            raw_len = s->img_x * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
-            z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
-            if (z->expanded == NULL) return 0; // zlib should set error
-            free(z->idata); z->idata = NULL;
-            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
-               s->img_out_n = s->img_n+1;
-            else
-               s->img_out_n = s->img_n;
-            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, depth, color, interlace)) return 0;
-            if (has_trans)
-               if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
-            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
-               stbi__de_iphone(z);
-            if (pal_img_n) {
-               // pal_img_n == 3 or 4
-               s->img_n = pal_img_n; // record the actual colors we had
-               s->img_out_n = pal_img_n;
-               if (req_comp >= 3) s->img_out_n = req_comp;
-               if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
-                  return 0;
-            }
-            free(z->expanded); z->expanded = NULL;
-            return 1;
-         }
-
-         default:
-            // if critical, fail
-            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
-            if ((c.type & (1 << 29)) == 0) {
-               #ifndef STBI_NO_FAILURE_STRINGS
-               // not threadsafe
-               static char invalid_chunk[] = "XXXX PNG chunk not known";
-               invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
-               invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
-               invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
-               invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);
-               #endif
-               return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");
-            }
-            stbi__skip(s, c.length);
-            break;
-      }
-      // end of PNG chunk, read and skip CRC
-      stbi__get32be(s);
-   }
-}
-
-static unsigned char *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp)
-{
-   unsigned char *result=NULL;
-   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
-   if (stbi__parse_png_file(p, SCAN_load, req_comp)) {
-      result = p->out;
-      p->out = NULL;
-      if (req_comp && req_comp != p->s->img_out_n) {
-         result = stbi__convert_format(result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
-         p->s->img_out_n = req_comp;
-         if (result == NULL) return result;
-      }
-      *x = p->s->img_x;
-      *y = p->s->img_y;
-      if (n) *n = p->s->img_out_n;
-   }
-   free(p->out);      p->out      = NULL;
-   free(p->expanded); p->expanded = NULL;
-   free(p->idata);    p->idata    = NULL;
-
-   return result;
-}
-
-static unsigned char *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
-{
-   stbi__png p;
-   p.s = s;
-   return stbi__do_png(&p, x,y,comp,req_comp);
-}
-
-static int stbi__png_test(stbi__context *s)
-{
-   int r;
-   r = stbi__check_png_header(s);
-   stbi__rewind(s);
-   return r;
-}
-
-static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
-{
-   if (!stbi__parse_png_file(p, SCAN_header, 0)) {
-      stbi__rewind( p->s );
-      return 0;
-   }
-   if (x) *x = p->s->img_x;
-   if (y) *y = p->s->img_y;
-   if (comp) *comp = p->s->img_n;
-   return 1;
-}
-
-static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
-{
-   stbi__png p;
-   p.s = s;
-   return stbi__png_info_raw(&p, x, y, comp);
-}
-
-// Microsoft/Windows BMP image
-static int stbi__bmp_test_raw(stbi__context *s)
-{
-   int r;
-   int sz;
-   if (stbi__get8(s) != 'B') return 0;
-   if (stbi__get8(s) != 'M') return 0;
-   stbi__get32le(s); // discard filesize
-   stbi__get16le(s); // discard reserved
-   stbi__get16le(s); // discard reserved
-   stbi__get32le(s); // discard data offset
-   sz = stbi__get32le(s);
-   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
-   return r;
-}
-
-static int stbi__bmp_test(stbi__context *s)
-{
-   int r = stbi__bmp_test_raw(s);
-   stbi__rewind(s);
-   return r;
-}
-
-
-// returns 0..31 for the highest set bit
-static int stbi__high_bit(unsigned int z)
-{
-   int n=0;
-   if (z == 0) return -1;
-   if (z >= 0x10000) n += 16, z >>= 16;
-   if (z >= 0x00100) n +=  8, z >>=  8;
-   if (z >= 0x00010) n +=  4, z >>=  4;
-   if (z >= 0x00004) n +=  2, z >>=  2;
-   if (z >= 0x00002) n +=  1, z >>=  1;
-   return n;
-}
-
-static int stbi__bitcount(unsigned int a)
-{
-   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
-   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
-   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
-   a = (a + (a >> 8)); // max 16 per 8 bits
-   a = (a + (a >> 16)); // max 32 per 8 bits
-   return a & 0xff;
-}
-
-static int stbi__shiftsigned(int v, int shift, int bits)
-{
-   int result;
-   int z=0;
-
-   if (shift < 0) v <<= -shift;
-   else v >>= shift;
-   result = v;
-
-   z = bits;
-   while (z < 8) {
-      result += v >> z;
-      z += bits;
-   }
-   return result;
-}
-
-static stbi_uc *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
-{
-   stbi_uc *out;
-   unsigned int mr=0,mg=0,mb=0,ma=0, fake_a=0;
-   stbi_uc pal[256][4];
-   int psize=0,i,j,compress=0,width;
-   int bpp, flip_vertically, pad, target, offset, hsz;
-   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
-   stbi__get32le(s); // discard filesize
-   stbi__get16le(s); // discard reserved
-   stbi__get16le(s); // discard reserved
-   offset = stbi__get32le(s);
-   hsz = stbi__get32le(s);
-   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");
-   if (hsz == 12) {
-      s->img_x = stbi__get16le(s);
-      s->img_y = stbi__get16le(s);
-   } else {
-      s->img_x = stbi__get32le(s);
-      s->img_y = stbi__get32le(s);
-   }
-   if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");
-   bpp = stbi__get16le(s);
-   if (bpp == 1) return stbi__errpuc("monochrome", "BMP type not supported: 1-bit");
-   flip_vertically = ((int) s->img_y) > 0;
-   s->img_y = abs((int) s->img_y);
-   if (hsz == 12) {
-      if (bpp < 24)
-         psize = (offset - 14 - 24) / 3;
-   } else {
-      compress = stbi__get32le(s);
-      if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
-      stbi__get32le(s); // discard sizeof
-      stbi__get32le(s); // discard hres
-      stbi__get32le(s); // discard vres
-      stbi__get32le(s); // discard colorsused
-      stbi__get32le(s); // discard max important
-      if (hsz == 40 || hsz == 56) {
-         if (hsz == 56) {
-            stbi__get32le(s);
-            stbi__get32le(s);
-            stbi__get32le(s);
-            stbi__get32le(s);
-         }
-         if (bpp == 16 || bpp == 32) {
-            mr = mg = mb = 0;
-            if (compress == 0) {
-               if (bpp == 32) {
-                  mr = 0xffu << 16;
-                  mg = 0xffu <<  8;
-                  mb = 0xffu <<  0;
-                  ma = 0xffu << 24;
-                  fake_a = 1; // @TODO: check for cases like alpha value is all 0 and switch it to 255
-                  STBI_NOTUSED(fake_a);
-               } else {
-                  mr = 31u << 10;
-                  mg = 31u <<  5;
-                  mb = 31u <<  0;
-               }
-            } else if (compress == 3) {
-               mr = stbi__get32le(s);
-               mg = stbi__get32le(s);
-               mb = stbi__get32le(s);
-               // not documented, but generated by photoshop and handled by mspaint
-               if (mr == mg && mg == mb) {
-                  // ?!?!?
-                  return stbi__errpuc("bad BMP", "bad BMP");
-               }
-            } else
-               return stbi__errpuc("bad BMP", "bad BMP");
-         }
-      } else {
-         STBI_ASSERT(hsz == 108 || hsz == 124);
-         mr = stbi__get32le(s);
-         mg = stbi__get32le(s);
-         mb = stbi__get32le(s);
-         ma = stbi__get32le(s);
-         stbi__get32le(s); // discard color space
-         for (i=0; i < 12; ++i)
-            stbi__get32le(s); // discard color space parameters
-         if (hsz == 124) {
-            stbi__get32le(s); // discard rendering intent
-            stbi__get32le(s); // discard offset of profile data
-            stbi__get32le(s); // discard size of profile data
-            stbi__get32le(s); // discard reserved
-         }
-      }
-      if (bpp < 16)
-         psize = (offset - 14 - hsz) >> 2;
-   }
-   s->img_n = ma ? 4 : 3;
-   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
-      target = req_comp;
-   else
-      target = s->img_n; // if they want monochrome, we'll post-convert
-   out = (stbi_uc *) stbi__malloc(target * s->img_x * s->img_y);
-   if (!out) return stbi__errpuc("outofmem", "Out of memory");
-   if (bpp < 16) {
-      int z=0;
-      if (psize == 0 || psize > 256) { free(out); return stbi__errpuc("invalid", "Corrupt BMP"); }
-      for (i=0; i < psize; ++i) {
-         pal[i][2] = stbi__get8(s);
-         pal[i][1] = stbi__get8(s);
-         pal[i][0] = stbi__get8(s);
-         if (hsz != 12) stbi__get8(s);
-         pal[i][3] = 255;
-      }
-      stbi__skip(s, offset - 14 - hsz - psize * (hsz == 12 ? 3 : 4));
-      if (bpp == 4) width = (s->img_x + 1) >> 1;
-      else if (bpp == 8) width = s->img_x;
-      else { free(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }
-      pad = (-width)&3;
-      for (j=0; j < (int) s->img_y; ++j) {
-         for (i=0; i < (int) s->img_x; i += 2) {
-            int v=stbi__get8(s),v2=0;
-            if (bpp == 4) {
-               v2 = v & 15;
-               v >>= 4;
-            }
-            out[z++] = pal[v][0];
-            out[z++] = pal[v][1];
-            out[z++] = pal[v][2];
-            if (target == 4) out[z++] = 255;
-            if (i+1 == (int) s->img_x) break;
-            v = (bpp == 8) ? stbi__get8(s) : v2;
-            out[z++] = pal[v][0];
-            out[z++] = pal[v][1];
-            out[z++] = pal[v][2];
-            if (target == 4) out[z++] = 255;
-         }
-         stbi__skip(s, pad);
-      }
-   } else {
-      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
-      int z = 0;
-      int easy=0;
-      stbi__skip(s, offset - 14 - hsz);
-      if (bpp == 24) width = 3 * s->img_x;
-      else if (bpp == 16) width = 2*s->img_x;
-      else /* bpp = 32 and pad = 0 */ width=0;
-      pad = (-width) & 3;
-      if (bpp == 24) {
-         easy = 1;
-      } else if (bpp == 32) {
-         if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
-            easy = 2;
-      }
-      if (!easy) {
-         if (!mr || !mg || !mb) { free(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
-         // right shift amt to put high bit in position #7
-         rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
-         gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
-         bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
-         ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
-      }
-      for (j=0; j < (int) s->img_y; ++j) {
-         if (easy) {
-            for (i=0; i < (int) s->img_x; ++i) {
-               unsigned char a;
-               out[z+2] = stbi__get8(s);
-               out[z+1] = stbi__get8(s);
-               out[z+0] = stbi__get8(s);
-               z += 3;
-               a = (easy == 2 ? stbi__get8(s) : 255);
-               if (target == 4) out[z++] = a;
-            }
-         } else {
-            for (i=0; i < (int) s->img_x; ++i) {
-               stbi__uint32 v = (stbi__uint32) (bpp == 16 ? stbi__get16le(s) : stbi__get32le(s));
-               int a;
-               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
-               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
-               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
-               a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
-               if (target == 4) out[z++] = STBI__BYTECAST(a);
-            }
-         }
-         stbi__skip(s, pad);
-      }
-   }
-   if (flip_vertically) {
-      stbi_uc t;
-      for (j=0; j < (int) s->img_y>>1; ++j) {
-         stbi_uc *p1 = out +      j     *s->img_x*target;
-         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
-         for (i=0; i < (int) s->img_x*target; ++i) {
-            t = p1[i], p1[i] = p2[i], p2[i] = t;
-         }
-      }
-   }
-
-   if (req_comp && req_comp != target) {
-      out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
-      if (out == NULL) return out; // stbi__convert_format frees input on failure
-   }
-
-   *x = s->img_x;
-   *y = s->img_y;
-   if (comp) *comp = s->img_n;
-   return out;
-}
-
-// Targa Truevision - TGA
-// by Jonathan Dummer
-
-static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
-{
-    int tga_w, tga_h, tga_comp;
-    int sz;
-    stbi__get8(s);                   // discard Offset
-    sz = stbi__get8(s);              // color type
-    if( sz > 1 ) {
-        stbi__rewind(s);
-        return 0;      // only RGB or indexed allowed
-    }
-    sz = stbi__get8(s);              // image type
-    // only RGB or grey allowed, +/- RLE
-    if ((sz != 1) && (sz != 2) && (sz != 3) && (sz != 9) && (sz != 10) && (sz != 11)) return 0;
-    stbi__skip(s,9);
-    tga_w = stbi__get16le(s);
-    if( tga_w < 1 ) {
-        stbi__rewind(s);
-        return 0;   // test width
-    }
-    tga_h = stbi__get16le(s);
-    if( tga_h < 1 ) {
-        stbi__rewind(s);
-        return 0;   // test height
-    }
-    sz = stbi__get8(s);               // bits per pixel
-    // only RGB or RGBA or grey allowed
-    if ((sz != 8) && (sz != 16) && (sz != 24) && (sz != 32)) {
-        stbi__rewind(s);
-        return 0;
-    }
-    tga_comp = sz;
-    if (x) *x = tga_w;
-    if (y) *y = tga_h;
-    if (comp) *comp = tga_comp / 8;
-    return 1;                   // seems to have passed everything
-}
-
-static int stbi__tga_test(stbi__context *s)
-{
-   int res;
-   int sz;
-   stbi__get8(s);      //   discard Offset
-   sz = stbi__get8(s);   //   color type
-   if ( sz > 1 ) return 0;   //   only RGB or indexed allowed
-   sz = stbi__get8(s);   //   image type
-   if ( (sz != 1) && (sz != 2) && (sz != 3) && (sz != 9) && (sz != 10) && (sz != 11) ) return 0;   //   only RGB or grey allowed, +/- RLE
-   stbi__get16be(s);      //   discard palette start
-   stbi__get16be(s);      //   discard palette length
-   stbi__get8(s);         //   discard bits per palette color entry
-   stbi__get16be(s);      //   discard x origin
-   stbi__get16be(s);      //   discard y origin
-   if ( stbi__get16be(s) < 1 ) return 0;      //   test width
-   if ( stbi__get16be(s) < 1 ) return 0;      //   test height
-   sz = stbi__get8(s);   //   bits per pixel
-   if ( (sz != 8) && (sz != 16) && (sz != 24) && (sz != 32) )
-      res = 0;
-   else
-      res = 1;
-   stbi__rewind(s);
-   return res;
-}
-
-static stbi_uc *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
-{
-   //   read in the TGA header stuff
-   int tga_offset = stbi__get8(s);
-   int tga_indexed = stbi__get8(s);
-   int tga_image_type = stbi__get8(s);
-   int tga_is_RLE = 0;
-   int tga_palette_start = stbi__get16le(s);
-   int tga_palette_len = stbi__get16le(s);
-   int tga_palette_bits = stbi__get8(s);
-   int tga_x_origin = stbi__get16le(s);
-   int tga_y_origin = stbi__get16le(s);
-   int tga_width = stbi__get16le(s);
-   int tga_height = stbi__get16le(s);
-   int tga_bits_per_pixel = stbi__get8(s);
-   int tga_comp = tga_bits_per_pixel / 8;
-   int tga_inverted = stbi__get8(s);
-   //   image data
-   unsigned char *tga_data;
-   unsigned char *tga_palette = NULL;
-   int i, j;
-   unsigned char raw_data[4];
-   int RLE_count = 0;
-   int RLE_repeating = 0;
-   int read_next_pixel = 1;
-
-   //   do a tiny bit of precessing
-   if ( tga_image_type >= 8 )
-   {
-      tga_image_type -= 8;
-      tga_is_RLE = 1;
-   }
-   /* int tga_alpha_bits = tga_inverted & 15; */
-   tga_inverted = 1 - ((tga_inverted >> 5) & 1);
-
-   //   error check
-   if ( //(tga_indexed) ||
-      (tga_width < 1) || (tga_height < 1) ||
-      (tga_image_type < 1) || (tga_image_type > 3) ||
-      ((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16) &&
-      (tga_bits_per_pixel != 24) && (tga_bits_per_pixel != 32))
-      )
-   {
-      return NULL; // we don't report this as a bad TGA because we don't even know if it's TGA
-   }
-
-   //   If I'm paletted, then I'll use the number of bits from the palette
-   if ( tga_indexed )
-   {
-      tga_comp = tga_palette_bits / 8;
-   }
-
-   //   tga info
-   *x = tga_width;
-   *y = tga_height;
-   if (comp) *comp = tga_comp;
-
-   tga_data = (unsigned char*)stbi__malloc( tga_width * tga_height * tga_comp );
-   if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");
-
-   // skip to the data's starting position (offset usually = 0)
-   stbi__skip(s, tga_offset );
-
-   if ( !tga_indexed && !tga_is_RLE) {
-      for (i=0; i < tga_height; ++i) {
-         int y = tga_inverted ? tga_height -i - 1 : i;
-         stbi_uc *tga_row = tga_data + y*tga_width*tga_comp;
-         stbi__getn(s, tga_row, tga_width * tga_comp);
-      }
-   } else  {
-      //   do I need to load a palette?
-      if ( tga_indexed)
-      {
-         //   any data to skip? (offset usually = 0)
-         stbi__skip(s, tga_palette_start );
-         //   load the palette
-         tga_palette = (unsigned char*)stbi__malloc( tga_palette_len * tga_palette_bits / 8 );
-         if (!tga_palette) {
-            free(tga_data);
-            return stbi__errpuc("outofmem", "Out of memory");
-         }
-         if (!stbi__getn(s, tga_palette, tga_palette_len * tga_palette_bits / 8 )) {
-            free(tga_data);
-            free(tga_palette);
-            return stbi__errpuc("bad palette", "Corrupt TGA");
-         }
-      }
-      //   load the data
-      for (i=0; i < tga_width * tga_height; ++i)
-      {
-         //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
-         if ( tga_is_RLE )
-         {
-            if ( RLE_count == 0 )
-            {
-               //   yep, get the next byte as a RLE command
-               int RLE_cmd = stbi__get8(s);
-               RLE_count = 1 + (RLE_cmd & 127);
-               RLE_repeating = RLE_cmd >> 7;
-               read_next_pixel = 1;
-            } else if ( !RLE_repeating )
-            {
-               read_next_pixel = 1;
-            }
-         } else
-         {
-            read_next_pixel = 1;
-         }
-         //   OK, if I need to read a pixel, do it now
-         if ( read_next_pixel )
-         {
-            //   load however much data we did have
-            if ( tga_indexed )
-            {
-               //   read in 1 byte, then perform the lookup
-               int pal_idx = stbi__get8(s);
-               if ( pal_idx >= tga_palette_len )
-               {
-                  //   invalid index
-                  pal_idx = 0;
-               }
-               pal_idx *= tga_bits_per_pixel / 8;
-               for (j = 0; j*8 < tga_bits_per_pixel; ++j)
-               {
-                  raw_data[j] = tga_palette[pal_idx+j];
-               }
-            } else
-            {
-               //   read in the data raw
-               for (j = 0; j*8 < tga_bits_per_pixel; ++j)
-               {
-                  raw_data[j] = stbi__get8(s);
-               }
-            }
-            //   clear the reading flag for the next pixel
-            read_next_pixel = 0;
-         } // end of reading a pixel
-
-         // copy data
-         for (j = 0; j < tga_comp; ++j)
-           tga_data[i*tga_comp+j] = raw_data[j];
-
-         //   in case we're in RLE mode, keep counting down
-         --RLE_count;
-      }
-      //   do I need to invert the image?
-      if ( tga_inverted )
-      {
-         for (j = 0; j*2 < tga_height; ++j)
-         {
-            int index1 = j * tga_width * tga_comp;
-            int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
-            for (i = tga_width * tga_comp; i > 0; --i)
-            {
-               unsigned char temp = tga_data[index1];
-               tga_data[index1] = tga_data[index2];
-               tga_data[index2] = temp;
-               ++index1;
-               ++index2;
-            }
-         }
-      }
-      //   clear my palette, if I had one
-      if ( tga_palette != NULL )
-      {
-         free( tga_palette );
-      }
-   }
-
-   // swap RGB
-   if (tga_comp >= 3)
-   {
-      unsigned char* tga_pixel = tga_data;
-      for (i=0; i < tga_width * tga_height; ++i)
-      {
-         unsigned char temp = tga_pixel[0];
-         tga_pixel[0] = tga_pixel[2];
-         tga_pixel[2] = temp;
-         tga_pixel += tga_comp;
-      }
-   }
-
-   // convert to target component count
-   if (req_comp && req_comp != tga_comp)
-      tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);
-
-   //   the things I do to get rid of an error message, and yet keep
-   //   Microsoft's C compilers happy... [8^(
-   tga_palette_start = tga_palette_len = tga_palette_bits =
-         tga_x_origin = tga_y_origin = 0;
-   //   OK, done
-   return tga_data;
-}
-
-// *************************************************************************************************
-// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB
-
-static int stbi__psd_test(stbi__context *s)
-{
-   int r = (stbi__get32be(s) == 0x38425053);
-   stbi__rewind(s);
-   return r;
-}
-
-static stbi_uc *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
-{
-   int   pixelCount;
-   int channelCount, compression;
-   int channel, i, count, len;
-   int w,h;
-   stbi_uc *out;
-
-   // Check identifier
-   if (stbi__get32be(s) != 0x38425053)   // "8BPS"
-      return stbi__errpuc("not PSD", "Corrupt PSD image");
-
-   // Check file type version.
-   if (stbi__get16be(s) != 1)
-      return stbi__errpuc("wrong version", "Unsupported version of PSD image");
-
-   // Skip 6 reserved bytes.
-   stbi__skip(s, 6 );
-
-   // Read the number of channels (R, G, B, A, etc).
-   channelCount = stbi__get16be(s);
-   if (channelCount < 0 || channelCount > 16)
-      return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");
-
-   // Read the rows and columns of the image.
-   h = stbi__get32be(s);
-   w = stbi__get32be(s);
-   
-   // Make sure the depth is 8 bits.
-   if (stbi__get16be(s) != 8)
-      return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 bit");
-
-   // Make sure the color mode is RGB.
-   // Valid options are:
-   //   0: Bitmap
-   //   1: Grayscale
-   //   2: Indexed color
-   //   3: RGB color
-   //   4: CMYK color
-   //   7: Multichannel
-   //   8: Duotone
-   //   9: Lab color
-   if (stbi__get16be(s) != 3)
-      return stbi__errpuc("wrong color format", "PSD is not in RGB color format");
-
-   // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
-   stbi__skip(s,stbi__get32be(s) );
-
-   // Skip the image resources.  (resolution, pen tool paths, etc)
-   stbi__skip(s, stbi__get32be(s) );
-
-   // Skip the reserved data.
-   stbi__skip(s, stbi__get32be(s) );
-
-   // Find out if the data is compressed.
-   // Known values:
-   //   0: no compression
-   //   1: RLE compressed
-   compression = stbi__get16be(s);
-   if (compression > 1)
-      return stbi__errpuc("bad compression", "PSD has an unknown compression format");
-
-   // Create the destination image.
-   out = (stbi_uc *) stbi__malloc(4 * w*h);
-   if (!out) return stbi__errpuc("outofmem", "Out of memory");
-   pixelCount = w*h;
-
-   // Initialize the data to zero.
-   //memset( out, 0, pixelCount * 4 );
-   
-   // Finally, the image data.
-   if (compression) {
-      // RLE as used by .PSD and .TIFF
-      // Loop until you get the number of unpacked bytes you are expecting:
-      //     Read the next source byte into n.
-      //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
-      //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
-      //     Else if n is 128, noop.
-      // Endloop
-
-      // The RLE-compressed data is preceeded by a 2-byte data count for each row in the data,
-      // which we're going to just skip.
-      stbi__skip(s, h * channelCount * 2 );
-
-      // Read the RLE data by channel.
-      for (channel = 0; channel < 4; channel++) {
-         stbi_uc *p;
-         
-         p = out+channel;
-         if (channel >= channelCount) {
-            // Fill this channel with default data.
-            for (i = 0; i < pixelCount; i++) *p = (channel == 3 ? 255 : 0), p += 4;
-         } else {
-            // Read the RLE data.
-            count = 0;
-            while (count < pixelCount) {
-               len = stbi__get8(s);
-               if (len == 128) {
-                  // No-op.
-               } else if (len < 128) {
-                  // Copy next len+1 bytes literally.
-                  len++;
-                  count += len;
-                  while (len) {
-                     *p = stbi__get8(s);
-                     p += 4;
-                     len--;
-                  }
-               } else if (len > 128) {
-                  stbi_uc   val;
-                  // Next -len+1 bytes in the dest are replicated from next source byte.
-                  // (Interpret len as a negative 8-bit int.)
-                  len ^= 0x0FF;
-                  len += 2;
-                  val = stbi__get8(s);
-                  count += len;
-                  while (len) {
-                     *p = val;
-                     p += 4;
-                     len--;
-                  }
-               }
-            }
-         }
-      }
-      
-   } else {
-      // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
-      // where each channel consists of an 8-bit value for each pixel in the image.
-      
-      // Read the data by channel.
-      for (channel = 0; channel < 4; channel++) {
-         stbi_uc *p;
-         
-         p = out + channel;
-         if (channel > channelCount) {
-            // Fill this channel with default data.
-            for (i = 0; i < pixelCount; i++) *p = channel == 3 ? 255 : 0, p += 4;
-         } else {
-            // Read the data.
-            for (i = 0; i < pixelCount; i++)
-               *p = stbi__get8(s), p += 4;
-         }
-      }
-   }
-
-   if (req_comp && req_comp != 4) {
-      out = stbi__convert_format(out, 4, req_comp, w, h);
-      if (out == NULL) return out; // stbi__convert_format frees input on failure
-   }
-
-   if (comp) *comp = channelCount;
-   *y = h;
-   *x = w;
-   
-   return out;
-}
-
-// *************************************************************************************************
-// Softimage PIC loader
-// by Tom Seddon
-//
-// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
-// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/
-
-static int stbi__pic_is4(stbi__context *s,const char *str)
-{
-   int i;
-   for (i=0; i<4; ++i)
-      if (stbi__get8(s) != (stbi_uc)str[i])
-         return 0;
-
-   return 1;
-}
-
-static int stbi__pic_test_core(stbi__context *s)
-{
-   int i;
-
-   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))
-      return 0;
-
-   for(i=0;i<84;++i)
-      stbi__get8(s);
-
-   if (!stbi__pic_is4(s,"PICT"))
-      return 0;
-
-   return 1;
-}
-
-typedef struct
-{
-   stbi_uc size,type,channel;
-} stbi__pic_packet;
-
-static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
-{
-   int mask=0x80, i;
-
-   for (i=0; i<4; ++i, mask>>=1) {
-      if (channel & mask) {
-         if (stbi__at_eof(s)) return stbi__errpuc("bad file","PIC file too short");
-         dest[i]=stbi__get8(s);
-      }
-   }
-
-   return dest;
-}
-
-static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
-{
-   int mask=0x80,i;
-
-   for (i=0;i<4; ++i, mask>>=1)
-      if (channel&mask)
-         dest[i]=src[i];
-}
-
-static stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)
-{
-   int act_comp=0,num_packets=0,y,chained;
-   stbi__pic_packet packets[10];
-
-   // this will (should...) cater for even some bizarre stuff like having data
-    // for the same channel in multiple packets.
-   do {
-      stbi__pic_packet *packet;
-
-      if (num_packets==sizeof(packets)/sizeof(packets[0]))
-         return stbi__errpuc("bad format","too many packets");
-
-      packet = &packets[num_packets++];
-
-      chained = stbi__get8(s);
-      packet->size    = stbi__get8(s);
-      packet->type    = stbi__get8(s);
-      packet->channel = stbi__get8(s);
-
-      act_comp |= packet->channel;
-
-      if (stbi__at_eof(s))          return stbi__errpuc("bad file","file too short (reading packets)");
-      if (packet->size != 8)  return stbi__errpuc("bad format","packet isn't 8bpp");
-   } while (chained);
-
-   *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?
-
-   for(y=0; y<height; ++y) {
-      int packet_idx;
-
-      for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {
-         stbi__pic_packet *packet = &packets[packet_idx];
-         stbi_uc *dest = result+y*width*4;
-
-         switch (packet->type) {
-            default:
-               return stbi__errpuc("bad format","packet has bad compression type");
-
-            case 0: {//uncompressed
-               int x;
-
-               for(x=0;x<width;++x, dest+=4)
-                  if (!stbi__readval(s,packet->channel,dest))
-                     return 0;
-               break;
-            }
-
-            case 1://Pure RLE
-               {
-                  int left=width, i;
-
-                  while (left>0) {
-                     stbi_uc count,value[4];
-
-                     count=stbi__get8(s);
-                     if (stbi__at_eof(s))   return stbi__errpuc("bad file","file too short (pure read count)");
-
-                     if (count > left)
-                        count = (stbi_uc) left;
-
-                     if (!stbi__readval(s,packet->channel,value))  return 0;
-
-                     for(i=0; i<count; ++i,dest+=4)
-                        stbi__copyval(packet->channel,dest,value);
-                     left -= count;
-                  }
-               }
-               break;
-
-            case 2: {//Mixed RLE
-               int left=width;
-               while (left>0) {
-                  int count = stbi__get8(s), i;
-                  if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (mixed read count)");
-
-                  if (count >= 128) { // Repeated
-                     stbi_uc value[4];
-                     int i;
-
-                     if (count==128)
-                        count = stbi__get16be(s);
-                     else
-                        count -= 127;
-                     if (count > left)
-                        return stbi__errpuc("bad file","scanline overrun");
-
-                     if (!stbi__readval(s,packet->channel,value))
-                        return 0;
-
-                     for(i=0;i<count;++i, dest += 4)
-                        stbi__copyval(packet->channel,dest,value);
-                  } else { // Raw
-                     ++count;
-                     if (count>left) return stbi__errpuc("bad file","scanline overrun");
-
-                     for(i=0;i<count;++i, dest+=4)
-                        if (!stbi__readval(s,packet->channel,dest))
-                           return 0;
-                  }
-                  left-=count;
-               }
-               break;
-            }
-         }
-      }
-   }
-
-   return result;
-}
-
-static stbi_uc *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp)
-{
-   stbi_uc *result;
-   int i, x,y;
-
-   for (i=0; i<92; ++i)
-      stbi__get8(s);
-
-   x = stbi__get16be(s);
-   y = stbi__get16be(s);
-   if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (pic header)");
-   if ((1 << 28) / x < y) return stbi__errpuc("too large", "Image too large to decode");
-
-   stbi__get32be(s); //skip `ratio'
-   stbi__get16be(s); //skip `fields'
-   stbi__get16be(s); //skip `pad'
-
-   // intermediate buffer is RGBA
-   result = (stbi_uc *) stbi__malloc(x*y*4);
-   memset(result, 0xff, x*y*4);
-
-   if (!stbi__pic_load_core(s,x,y,comp, result)) {
-      free(result);
-      result=0;
-   }
-   *px = x;
-   *py = y;
-   if (req_comp == 0) req_comp = *comp;
-   result=stbi__convert_format(result,4,req_comp,x,y);
-
-   return result;
-}
-
-static int stbi__pic_test(stbi__context *s)
-{
-   int r = stbi__pic_test_core(s);
-   stbi__rewind(s);
-   return r;
-}
-
-// *************************************************************************************************
-// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb
-typedef struct
-{
-   stbi__int16 prefix;
-   stbi_uc first;
-   stbi_uc suffix;
-} stbi__gif_lzw;
-
-typedef struct
-{
-   int w,h;
-   stbi_uc *out;                 // output buffer (always 4 components)
-   int flags, bgindex, ratio, transparent, eflags;
-   stbi_uc  pal[256][4];
-   stbi_uc lpal[256][4];
-   stbi__gif_lzw codes[4096];
-   stbi_uc *color_table;
-   int parse, step;
-   int lflags;
-   int start_x, start_y;
-   int max_x, max_y;
-   int cur_x, cur_y;
-   int line_size;
-} stbi__gif;
-
-static int stbi__gif_test_raw(stbi__context *s)
-{
-   int sz;
-   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;
-   sz = stbi__get8(s);
-   if (sz != '9' && sz != '7') return 0;
-   if (stbi__get8(s) != 'a') return 0;
-   return 1;
-}
-
-static int stbi__gif_test(stbi__context *s)
-{
-   int r = stbi__gif_test_raw(s);
-   stbi__rewind(s);
-   return r;
-}
-
-static void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)
-{
-   int i;
-   for (i=0; i < num_entries; ++i) {
-      pal[i][2] = stbi__get8(s);
-      pal[i][1] = stbi__get8(s);
-      pal[i][0] = stbi__get8(s);
-      pal[i][3] = transp ? 0 : 255;
-   }   
-}
-
-static int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)
-{
-   stbi_uc version;
-   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')
-      return stbi__err("not GIF", "Corrupt GIF");
-
-   version = stbi__get8(s);
-   if (version != '7' && version != '9')    return stbi__err("not GIF", "Corrupt GIF");
-   if (stbi__get8(s) != 'a')                      return stbi__err("not GIF", "Corrupt GIF");
- 
-   stbi__g_failure_reason = "";
-   g->w = stbi__get16le(s);
-   g->h = stbi__get16le(s);
-   g->flags = stbi__get8(s);
-   g->bgindex = stbi__get8(s);
-   g->ratio = stbi__get8(s);
-   g->transparent = -1;
-
-   if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments
-
-   if (is_info) return 1;
-
-   if (g->flags & 0x80)
-      stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);
-
-   return 1;
-}
-
-static int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)
-{
-   stbi__gif g;
-   if (!stbi__gif_header(s, &g, comp, 1)) {
-      stbi__rewind( s );
-      return 0;
-   }
-   if (x) *x = g.w;
-   if (y) *y = g.h;
-   return 1;
-}
-
-static void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)
-{
-   stbi_uc *p, *c;
-
-   // recurse to decode the prefixes, since the linked-list is backwards,
-   // and working backwards through an interleaved image would be nasty
-   if (g->codes[code].prefix >= 0)
-      stbi__out_gif_code(g, g->codes[code].prefix);
-
-   if (g->cur_y >= g->max_y) return;
-  
-   p = &g->out[g->cur_x + g->cur_y];
-   c = &g->color_table[g->codes[code].suffix * 4];
-
-   if (c[3] >= 128) {
-      p[0] = c[2];
-      p[1] = c[1];
-      p[2] = c[0];
-      p[3] = c[3];
-   }
-   g->cur_x += 4;
-
-   if (g->cur_x >= g->max_x) {
-      g->cur_x = g->start_x;
-      g->cur_y += g->step;
-
-      while (g->cur_y >= g->max_y && g->parse > 0) {
-         g->step = (1 << g->parse) * g->line_size;
-         g->cur_y = g->start_y + (g->step >> 1);
-         --g->parse;
-      }
-   }
-}
-
-static stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)
-{
-   stbi_uc lzw_cs;
-   stbi__int32 len, code;
-   stbi__uint32 first;
-   stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
-   stbi__gif_lzw *p;
-
-   lzw_cs = stbi__get8(s);
-   clear = 1 << lzw_cs;
-   first = 1;
-   codesize = lzw_cs + 1;
-   codemask = (1 << codesize) - 1;
-   bits = 0;
-   valid_bits = 0;
-   for (code = 0; code < clear; code++) {
-      g->codes[code].prefix = -1;
-      g->codes[code].first = (stbi_uc) code;
-      g->codes[code].suffix = (stbi_uc) code;
-   }
-
-   // support no starting clear code
-   avail = clear+2;
-   oldcode = -1;
-
-   len = 0;
-   for(;;) {
-      if (valid_bits < codesize) {
-         if (len == 0) {
-            len = stbi__get8(s); // start new block
-            if (len == 0) 
-               return g->out;
-         }
-         --len;
-         bits |= (stbi__int32) stbi__get8(s) << valid_bits;
-         valid_bits += 8;
-      } else {
-         stbi__int32 code = bits & codemask;
-         bits >>= codesize;
-         valid_bits -= codesize;
-         // @OPTIMIZE: is there some way we can accelerate the non-clear path?
-         if (code == clear) {  // clear code
-            codesize = lzw_cs + 1;
-            codemask = (1 << codesize) - 1;
-            avail = clear + 2;
-            oldcode = -1;
-            first = 0;
-         } else if (code == clear + 1) { // end of stream code
-            stbi__skip(s, len);
-            while ((len = stbi__get8(s)) > 0)
-               stbi__skip(s,len);
-            return g->out;
-         } else if (code <= avail) {
-            if (first) return stbi__errpuc("no clear code", "Corrupt GIF");
-
-            if (oldcode >= 0) {
-               p = &g->codes[avail++];
-               if (avail > 4096)        return stbi__errpuc("too many codes", "Corrupt GIF");
-               p->prefix = (stbi__int16) oldcode;
-               p->first = g->codes[oldcode].first;
-               p->suffix = (code == avail) ? p->first : g->codes[code].first;
-            } else if (code == avail)
-               return stbi__errpuc("illegal code in raster", "Corrupt GIF");
-
-            stbi__out_gif_code(g, (stbi__uint16) code);
-
-            if ((avail & codemask) == 0 && avail <= 0x0FFF) {
-               codesize++;
-               codemask = (1 << codesize) - 1;
-            }
-
-            oldcode = code;
-         } else {
-            return stbi__errpuc("illegal code in raster", "Corrupt GIF");
-         }
-      } 
-   }
-}
-
-static void stbi__fill_gif_background(stbi__gif *g)
-{
-   int i;
-   stbi_uc *c = g->pal[g->bgindex];
-   // @OPTIMIZE: write a dword at a time
-   for (i = 0; i < g->w * g->h * 4; i += 4) {
-      stbi_uc *p  = &g->out[i];
-      p[0] = c[2];
-      p[1] = c[1];
-      p[2] = c[0];
-      p[3] = c[3];
-   }
-}
-
-// this function is designed to support animated gifs, although stb_image doesn't support it
-static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp)
-{
-   int i;
-   stbi_uc *old_out = 0;
-
-   if (g->out == 0) {
-      if (!stbi__gif_header(s, g, comp,0))     return 0; // stbi__g_failure_reason set by stbi__gif_header
-      g->out = (stbi_uc *) stbi__malloc(4 * g->w * g->h);
-      if (g->out == 0)                      return stbi__errpuc("outofmem", "Out of memory");
-      stbi__fill_gif_background(g);
-   } else {
-      // animated-gif-only path
-      if (((g->eflags & 0x1C) >> 2) == 3) {
-         old_out = g->out;
-         g->out = (stbi_uc *) stbi__malloc(4 * g->w * g->h);
-         if (g->out == 0)                   return stbi__errpuc("outofmem", "Out of memory");
-         memcpy(g->out, old_out, g->w*g->h*4);
-      }
-   }
-    
-   for (;;) {
-      switch (stbi__get8(s)) {
-         case 0x2C: /* Image Descriptor */
-         {
-            stbi__int32 x, y, w, h;
-            stbi_uc *o;
-
-            x = stbi__get16le(s);
-            y = stbi__get16le(s);
-            w = stbi__get16le(s);
-            h = stbi__get16le(s);
-            if (((x + w) > (g->w)) || ((y + h) > (g->h)))
-               return stbi__errpuc("bad Image Descriptor", "Corrupt GIF");
-
-            g->line_size = g->w * 4;
-            g->start_x = x * 4;
-            g->start_y = y * g->line_size;
-            g->max_x   = g->start_x + w * 4;
-            g->max_y   = g->start_y + h * g->line_size;
-            g->cur_x   = g->start_x;
-            g->cur_y   = g->start_y;
-
-            g->lflags = stbi__get8(s);
-
-            if (g->lflags & 0x40) {
-               g->step = 8 * g->line_size; // first interlaced spacing
-               g->parse = 3;
-            } else {
-               g->step = g->line_size;
-               g->parse = 0;
-            }
-
-            if (g->lflags & 0x80) {
-               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
-               g->color_table = (stbi_uc *) g->lpal;
-            } else if (g->flags & 0x80) {
-               for (i=0; i < 256; ++i)  // @OPTIMIZE: stbi__jpeg_reset only the previous transparent
-                  g->pal[i][3] = 255; 
-               if (g->transparent >= 0 && (g->eflags & 0x01))
-                  g->pal[g->transparent][3] = 0;
-               g->color_table = (stbi_uc *) g->pal;
-            } else
-               return stbi__errpuc("missing color table", "Corrupt GIF");
-   
-            o = stbi__process_gif_raster(s, g);
-            if (o == NULL) return NULL;
-
-            if (req_comp && req_comp != 4)
-               o = stbi__convert_format(o, 4, req_comp, g->w, g->h);
-            return o;
-         }
-
-         case 0x21: // Comment Extension.
-         {
-            int len;
-            if (stbi__get8(s) == 0xF9) { // Graphic Control Extension.
-               len = stbi__get8(s);
-               if (len == 4) {
-                  g->eflags = stbi__get8(s);
-                  stbi__get16le(s); // delay
-                  g->transparent = stbi__get8(s);
-               } else {
-                  stbi__skip(s, len);
-                  break;
-               }
-            }
-            while ((len = stbi__get8(s)) != 0)
-               stbi__skip(s, len);
-            break;
-         }
-
-         case 0x3B: // gif stream termination code
-            return (stbi_uc *) s; // using '1' causes warning on some compilers
-
-         default:
-            return stbi__errpuc("unknown code", "Corrupt GIF");
-      }
-   }
-}
-
-static stbi_uc *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
-{
-   stbi_uc *u = 0;
-   stbi__gif g;
-   memset(&g, 0, sizeof(g));
-
-   u = stbi__gif_load_next(s, &g, comp, req_comp);
-   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
-   if (u) {
-      *x = g.w;
-      *y = g.h;
-   }
-
-   return u;
-}
-
-static int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)
-{
-   return stbi__gif_info_raw(s,x,y,comp);
-}
-
-
-// *************************************************************************************************
-// Radiance RGBE HDR loader
-// originally by Nicolas Schulz
-#ifndef STBI_NO_HDR
-static int stbi__hdr_test_core(stbi__context *s)
-{
-   const char *signature = "#?RADIANCE\n";
-   int i;
-   for (i=0; signature[i]; ++i)
-      if (stbi__get8(s) != signature[i])
-         return 0;
-   return 1;
-}
-
-static int stbi__hdr_test(stbi__context* s)
-{
-   int r = stbi__hdr_test_core(s);
-   stbi__rewind(s);
-   return r;
-}
-
-#define STBI__HDR_BUFLEN  1024
-static char *stbi__hdr_gettoken(stbi__context *z, char *buffer)
-{
-   int len=0;
-   char c = '\0';
-
-   c = (char) stbi__get8(z);
-
-   while (!stbi__at_eof(z) && c != '\n') {
-      buffer[len++] = c;
-      if (len == STBI__HDR_BUFLEN-1) {
-         // flush to end of line
-         while (!stbi__at_eof(z) && stbi__get8(z) != '\n')
-            ;
-         break;
-      }
-      c = (char) stbi__get8(z);
-   }
-
-   buffer[len] = 0;
-   return buffer;
-}
-
-static void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)
-{
-   if ( input[3] != 0 ) {
-      float f1;
-      // Exponent
-      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
-      if (req_comp <= 2)
-         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
-      else {
-         output[0] = input[0] * f1;
-         output[1] = input[1] * f1;
-         output[2] = input[2] * f1;
-      }
-      if (req_comp == 2) output[1] = 1;
-      if (req_comp == 4) output[3] = 1;
-   } else {
-      switch (req_comp) {
-         case 4: output[3] = 1; /* fallthrough */
-         case 3: output[0] = output[1] = output[2] = 0;
-                 break;
-         case 2: output[1] = 1; /* fallthrough */
-         case 1: output[0] = 0;
-                 break;
-      }
-   }
-}
-
-static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
-{
-   char buffer[STBI__HDR_BUFLEN];
-   char *token;
-   int valid = 0;
-   int width, height;
-   stbi_uc *scanline;
-   float *hdr_data;
-   int len;
-   unsigned char count, value;
-   int i, j, k, c1,c2, z;
-
-
-   // Check identifier
-   if (strcmp(stbi__hdr_gettoken(s,buffer), "#?RADIANCE") != 0)
-      return stbi__errpf("not HDR", "Corrupt HDR image");
-   
-   // Parse header
-   for(;;) {
-      token = stbi__hdr_gettoken(s,buffer);
-      if (token[0] == 0) break;
-      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
-   }
-
-   if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");
-
-   // Parse width and height
-   // can't use sscanf() if we're not using stdio!
-   token = stbi__hdr_gettoken(s,buffer);
-   if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
-   token += 3;
-   height = (int) strtol(token, &token, 10);
-   while (*token == ' ') ++token;
-   if (strncmp(token, "+X ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
-   token += 3;
-   width = (int) strtol(token, NULL, 10);
-
-   *x = width;
-   *y = height;
-
-   if (comp) *comp = 3;
-   if (req_comp == 0) req_comp = 3;
-
-   // Read data
-   hdr_data = (float *) stbi__malloc(height * width * req_comp * sizeof(float));
-
-   // Load image data
-   // image data is stored as some number of sca
-   if ( width < 8 || width >= 32768) {
-      // Read flat data
-      for (j=0; j < height; ++j) {
-         for (i=0; i < width; ++i) {
-            stbi_uc rgbe[4];
-           main_decode_loop:
-            stbi__getn(s, rgbe, 4);
-            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
-         }
-      }
-   } else {
-      // Read RLE-encoded data
-      scanline = NULL;
-
-      for (j = 0; j < height; ++j) {
-         c1 = stbi__get8(s);
-         c2 = stbi__get8(s);
-         len = stbi__get8(s);
-         if (c1 != 2 || c2 != 2 || (len & 0x80)) {
-            // not run-length encoded, so we have to actually use THIS data as a decoded
-            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
-            stbi_uc rgbe[4];
-            rgbe[0] = (stbi_uc) c1;
-            rgbe[1] = (stbi_uc) c2;
-            rgbe[2] = (stbi_uc) len;
-            rgbe[3] = (stbi_uc) stbi__get8(s);
-            stbi__hdr_convert(hdr_data, rgbe, req_comp);
-            i = 1;
-            j = 0;
-            free(scanline);
-            goto main_decode_loop; // yes, this makes no sense
-         }
-         len <<= 8;
-         len |= stbi__get8(s);
-         if (len != width) { free(hdr_data); free(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }
-         if (scanline == NULL) scanline = (stbi_uc *) stbi__malloc(width * 4);
-            
-         for (k = 0; k < 4; ++k) {
-            i = 0;
-            while (i < width) {
-               count = stbi__get8(s);
-               if (count > 128) {
-                  // Run
-                  value = stbi__get8(s);
-                  count -= 128;
-                  for (z = 0; z < count; ++z)
-                     scanline[i++ * 4 + k] = value;
-               } else {
-                  // Dump
-                  for (z = 0; z < count; ++z)
-                     scanline[i++ * 4 + k] = stbi__get8(s);
-               }
-            }
-         }
-         for (i=0; i < width; ++i)
-            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);
-      }
-      free(scanline);
-   }
-
-   return hdr_data;
-}
-
-static int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)
-{
-   char buffer[STBI__HDR_BUFLEN];
-   char *token;
-   int valid = 0;
-
-   if (strcmp(stbi__hdr_gettoken(s,buffer), "#?RADIANCE") != 0) {
-       stbi__rewind( s );
-       return 0;
-   }
-
-   for(;;) {
-      token = stbi__hdr_gettoken(s,buffer);
-      if (token[0] == 0) break;
-      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
-   }
-
-   if (!valid) {
-       stbi__rewind( s );
-       return 0;
-   }
-   token = stbi__hdr_gettoken(s,buffer);
-   if (strncmp(token, "-Y ", 3)) {
-       stbi__rewind( s );
-       return 0;
-   }
-   token += 3;
-   *y = (int) strtol(token, &token, 10);
-   while (*token == ' ') ++token;
-   if (strncmp(token, "+X ", 3)) {
-       stbi__rewind( s );
-       return 0;
-   }
-   token += 3;
-   *x = (int) strtol(token, NULL, 10);
-   *comp = 3;
-   return 1;
-}
-#endif // STBI_NO_HDR
-
-static int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)
-{
-   int hsz;
-   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') {
-       stbi__rewind( s );
-       return 0;
-   }
-   stbi__skip(s,12);
-   hsz = stbi__get32le(s);
-   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) {
-       stbi__rewind( s );
-       return 0;
-   }
-   if (hsz == 12) {
-      *x = stbi__get16le(s);
-      *y = stbi__get16le(s);
-   } else {
-      *x = stbi__get32le(s);
-      *y = stbi__get32le(s);
-   }
-   if (stbi__get16le(s) != 1) {
-       stbi__rewind( s );
-       return 0;
-   }
-   *comp = stbi__get16le(s) / 8;
-   return 1;
-}
-
-static int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)
-{
-   int channelCount;
-   if (stbi__get32be(s) != 0x38425053) {
-       stbi__rewind( s );
-       return 0;
-   }
-   if (stbi__get16be(s) != 1) {
-       stbi__rewind( s );
-       return 0;
-   }
-   stbi__skip(s, 6);
-   channelCount = stbi__get16be(s);
-   if (channelCount < 0 || channelCount > 16) {
-       stbi__rewind( s );
-       return 0;
-   }
-   *y = stbi__get32be(s);
-   *x = stbi__get32be(s);
-   if (stbi__get16be(s) != 8) {
-       stbi__rewind( s );
-       return 0;
-   }
-   if (stbi__get16be(s) != 3) {
-       stbi__rewind( s );
-       return 0;
-   }
-   *comp = 4;
-   return 1;
-}
-
-static int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)
-{
-   int act_comp=0,num_packets=0,chained;
-   stbi__pic_packet packets[10];
-
-   stbi__skip(s, 92);
-
-   *x = stbi__get16be(s);
-   *y = stbi__get16be(s);
-   if (stbi__at_eof(s))  return 0;
-   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {
-       stbi__rewind( s );
-       return 0;
-   }
-
-   stbi__skip(s, 8);
-
-   do {
-      stbi__pic_packet *packet;
-
-      if (num_packets==sizeof(packets)/sizeof(packets[0]))
-         return 0;
-
-      packet = &packets[num_packets++];
-      chained = stbi__get8(s);
-      packet->size    = stbi__get8(s);
-      packet->type    = stbi__get8(s);
-      packet->channel = stbi__get8(s);
-      act_comp |= packet->channel;
-
-      if (stbi__at_eof(s)) {
-          stbi__rewind( s );
-          return 0;
-      }
-      if (packet->size != 8) {
-          stbi__rewind( s );
-          return 0;
-      }
-   } while (chained);
-
-   *comp = (act_comp & 0x10 ? 4 : 3);
-
-   return 1;
-}
-
-static int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)
-{
-   if (stbi__jpeg_info(s, x, y, comp))
-       return 1;
-   if (stbi__png_info(s, x, y, comp))
-       return 1;
-   if (stbi__gif_info(s, x, y, comp))
-       return 1;
-   if (stbi__bmp_info(s, x, y, comp))
-       return 1;
-   if (stbi__psd_info(s, x, y, comp))
-       return 1;
-   if (stbi__pic_info(s, x, y, comp))
-       return 1;
-   #ifndef STBI_NO_HDR
-   if (stbi__hdr_info(s, x, y, comp))
-       return 1;
-   #endif
-   // test tga last because it's a crappy test!
-   if (stbi__tga_info(s, x, y, comp))
-       return 1;
-   return stbi__err("unknown image type", "Image not of any known type, or corrupt");
-}
-
-#ifndef STBI_NO_STDIO
-STBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)
-{
-    FILE *f = stbi__fopen(filename, "rb");
-    int result;
-    if (!f) return stbi__err("can't fopen", "Unable to open file");
-    result = stbi_info_from_file(f, x, y, comp);
-    fclose(f);
-    return result;
-}
-
-STBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)
-{
-   int r;
-   stbi__context s;
-   long pos = ftell(f);
-   stbi__start_file(&s, f);
-   r = stbi__info_main(&s,x,y,comp);
-   fseek(f,pos,SEEK_SET);
-   return r;
-}
-#endif // !STBI_NO_STDIO
-
-STBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)
-{
-   stbi__context s;
-   stbi__start_mem(&s,buffer,len);
-   return stbi__info_main(&s,x,y,comp);
-}
-
-STBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)
-{
-   stbi__context s;
-   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
-   return stbi__info_main(&s,x,y,comp);
-}
-
-#endif // STB_IMAGE_IMPLEMENTATION
-
-/*
-   revision history:
-      1.48 (2014-12-14) fix incorrectly-named assert()
-      1.47 (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)
-                        optimize PNG (ryg)
-                        fix bug in interlaced PNG with user-specified channel count (stb)
-      1.46 (2014-08-26)
-             fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG
-      1.45 (2014-08-16)
-             fix MSVC-ARM internal compiler error by wrapping malloc
-      1.44 (2014-08-07)
-               various warning fixes from Ronny Chevalier
-      1.43 (2014-07-15)
-             fix MSVC-only compiler problem in code changed in 1.42
-      1.42 (2014-07-09)
-             don't define _CRT_SECURE_NO_WARNINGS (affects user code)
-             fixes to stbi__cleanup_jpeg path
-             added STBI_ASSERT to avoid requiring assert.h
-      1.41 (2014-06-25)
-             fix search&replace from 1.36 that messed up comments/error messages
-      1.40 (2014-06-22)
-             fix gcc struct-initialization warning
-      1.39 (2014-06-15)
-             fix to TGA optimization when req_comp != number of components in TGA;
-             fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)
-             add support for BMP version 5 (more ignored fields)
-      1.38 (2014-06-06)
-             suppress MSVC warnings on integer casts truncating values
-             fix accidental rename of 'skip' field of I/O
-      1.37 (2014-06-04)
-             remove duplicate typedef
-      1.36 (2014-06-03)
-             convert to header file single-file library
-             if de-iphone isn't set, load iphone images color-swapped instead of returning NULL
-      1.35 (2014-05-27)
-             various warnings
-             fix broken STBI_SIMD path
-             fix bug where stbi_load_from_file no longer left file pointer in correct place
-             fix broken non-easy path for 32-bit BMP (possibly never used)
-             TGA optimization by Arseny Kapoulkine
-      1.34 (unknown)
-             use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case
-      1.33 (2011-07-14)
-             make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements
-      1.32 (2011-07-13)
-             support for "info" function for all supported filetypes (SpartanJ)
-      1.31 (2011-06-20)
-             a few more leak fixes, bug in PNG handling (SpartanJ)
-      1.30 (2011-06-11)
-             added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)
-             removed deprecated format-specific test/load functions
-             removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway
-             error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)
-             fix inefficiency in decoding 32-bit BMP (David Woo)
-      1.29 (2010-08-16)
-             various warning fixes from Aurelien Pocheville 
-      1.28 (2010-08-01)
-             fix bug in GIF palette transparency (SpartanJ)
-      1.27 (2010-08-01)
-             cast-to-stbi_uc to fix warnings
-      1.26 (2010-07-24)
-             fix bug in file buffering for PNG reported by SpartanJ
-      1.25 (2010-07-17)
-             refix trans_data warning (Won Chun)
-      1.24 (2010-07-12)
-             perf improvements reading from files on platforms with lock-heavy fgetc()
-             minor perf improvements for jpeg
-             deprecated type-specific functions so we'll get feedback if they're needed
-             attempt to fix trans_data warning (Won Chun)
-      1.23   fixed bug in iPhone support
-      1.22 (2010-07-10)
-             removed image *writing* support
-             stbi_info support from Jetro Lauha
-             GIF support from Jean-Marc Lienher
-             iPhone PNG-extensions from James Brown
-             warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)
-      1.21   fix use of 'stbi_uc' in header (reported by jon blow)
-      1.20   added support for Softimage PIC, by Tom Seddon
-      1.19   bug in interlaced PNG corruption check (found by ryg)
-      1.18 2008-08-02
-             fix a threading bug (local mutable static)
-      1.17   support interlaced PNG
-      1.16   major bugfix - stbi__convert_format converted one too many pixels
-      1.15   initialize some fields for thread safety
-      1.14   fix threadsafe conversion bug
-             header-file-only version (#define STBI_HEADER_FILE_ONLY before including)
-      1.13   threadsafe
-      1.12   const qualifiers in the API
-      1.11   Support installable IDCT, colorspace conversion routines
-      1.10   Fixes for 64-bit (don't use "unsigned long")
-             optimized upsampling by Fabian "ryg" Giesen
-      1.09   Fix format-conversion for PSD code (bad global variables!)
-      1.08   Thatcher Ulrich's PSD code integrated by Nicolas Schulz
-      1.07   attempt to fix C++ warning/errors again
-      1.06   attempt to fix C++ warning/errors again
-      1.05   fix TGA loading to return correct *comp and use good luminance calc
-      1.04   default float alpha is 1, not 255; use 'void *' for stbi_image_free
-      1.03   bugfixes to STBI_NO_STDIO, STBI_NO_HDR
-      1.02   support for (subset of) HDR files, float interface for preferred access to them
-      1.01   fix bug: possible bug in handling right-side up bmps... not sure
-             fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all
-      1.00   interface to zlib that skips zlib header
-      0.99   correct handling of alpha in palette
-      0.98   TGA loader by lonesock; dynamically add loaders (untested)
-      0.97   jpeg errors on too large a file; also catch another malloc failure
-      0.96   fix detection of invalid v value - particleman@mollyrocket forum
-      0.95   during header scan, seek to markers in case of padding
-      0.94   STBI_NO_STDIO to disable stdio usage; rename all #defines the same
-      0.93   handle jpegtran output; verbose errors
-      0.92   read 4,8,16,24,32-bit BMP files of several formats
-      0.91   output 24-bit Windows 3.0 BMP files
-      0.90   fix a few more warnings; bump version number to approach 1.0
-      0.61   bugfixes due to Marc LeBlanc, Christopher Lloyd
-      0.60   fix compiling as c++
-      0.59   fix warnings: merge Dave Moore's -Wall fixes
-      0.58   fix bug: zlib uncompressed mode len/nlen was wrong endian
-      0.57   fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available
-      0.56   fix bug: zlib uncompressed mode len vs. nlen
-      0.55   fix bug: restart_interval not initialized to 0
-      0.54   allow NULL for 'int *comp'
-      0.53   fix bug in png 3->4; speedup png decoding
-      0.52   png handles req_comp=3,4 directly; minor cleanup; jpeg comments
-      0.51   obey req_comp requests, 1-component jpegs return as 1-component,
-             on 'test' only check type, not whether we support this variant
-      0.50   first released version
-*/
diff --git a/gdx/jni/iosgl/iosgl20.cpp b/gdx/jni/iosgl/iosgl20.cpp
index 849078a..8acba63 100644
--- a/gdx/jni/iosgl/iosgl20.cpp
+++ b/gdx/jni/iosgl/iosgl20.cpp
@@ -437,18 +437,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glDeleteBuffer
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDeleteBuffer
-  (JNIEnv *, jobject, jint buffer)
-{
-	GLuint b = buffer;
-	glDeleteBuffers (1, &b);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glDeleteFramebuffers
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -461,18 +449,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glDeleteFramebuffer
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDeleteFramebuffer
-  (JNIEnv *, jobject, jint buffer)
-{
-	GLuint b = buffer;
-	glDeleteFramebuffers(1, &b);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glDeleteProgram
  * Signature: (I)V
  */
@@ -496,18 +472,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glDeleteRenderbuffer
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDeleteRenderbuffer
-  (JNIEnv *, jobject, jint buffer)
-{
-	GLuint b = buffer;
-	glDeleteRenderbuffers( 1, &b );
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glDeleteShader
  * Signature: (I)V
  */
@@ -531,18 +495,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glDeleteTexture
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDeleteTexture
-  (JNIEnv *, jobject, jint buffer)
-{
-	GLuint b = buffer;
-	glDeleteTextures(1, &b);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glDepthFunc
  * Signature: (I)V
  */
@@ -728,19 +680,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenB
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glGenBuffer
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenBuffer
-  (JNIEnv *, jobject)
-{
-	GLuint result;
-	glGenBuffers( 1, &result );
-	return result;
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glGenerateMipmap
  * Signature: (I)V
  */
@@ -764,19 +703,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenF
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glGenFramebuffer
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenFramebuffer
-  (JNIEnv *, jobject)
-{
-	GLuint result;
-	glGenFramebuffers( 1, &result );
-	return result;
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glGenRenderbuffers
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -789,19 +715,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenR
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glGenRenderbuffer
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenRenderbuffer
-  (JNIEnv *, jobject)
-{
-	GLuint result;
-	glGenRenderbuffers( 1, &result );
-	return result;
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glGenTextures
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -814,19 +727,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenT
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glGenTexture
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenTexture
-  (JNIEnv *, jobject)
-{
-	GLuint result;
-	glGenTextures(1, &result);
-	return result;
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glGetActiveAttrib
  * Signature: (IIILjava/nio/Buffer;Ljava/nio/IntBuffer;Ljava/nio/Buffer;Ljava/lang/String;)V
  */
@@ -1521,7 +1421,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform1fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1fv__IILjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1fv
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1530,19 +1430,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glUniform1fv
- * Signature: (II[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1fv__II_3FI
-  (JNIEnv *env, jobject, jint location, jint count, jfloatArray value, jint offset)
-{
-	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
-	glUniform1fv( location, count, (GLfloat*)&v[offset] );
-	env->ReleasePrimitiveArrayCritical(value, v, 0);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform1i
  * Signature: (II)V
  */
@@ -1557,7 +1444,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform1iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1iv__IILjava_nio_IntBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1iv
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1566,19 +1453,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glUniform1iv
- * Signature: (II[II)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1iv__II_3II
-	(JNIEnv *env, jobject, jint location, jint count, jintArray value, jint offset)
-{
-	int* v = (int*)env->GetPrimitiveArrayCritical(value, 0);
-	glUniform1iv( location, count, (GLint*)&v[offset] );
-	env->ReleasePrimitiveArrayCritical(value, v, 0);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform2f
  * Signature: (IFF)V
  */
@@ -1593,7 +1467,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform2fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2fv__IILjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2fv
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1602,19 +1476,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glUniform2fv
- * Signature: (II[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2fv__II_3FI
-	(JNIEnv *env, jobject, jint location, jint count, jfloatArray value, jint offset)
-{
-	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
-	glUniform2fv( location, count, (GLfloat*)&v[offset] );
-	env->ReleasePrimitiveArrayCritical(value, v, 0);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform2i
  * Signature: (III)V
  */
@@ -1629,7 +1490,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform2iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2iv__IILjava_nio_IntBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2iv
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1638,19 +1499,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glUniform2iv
- * Signature: (II[II)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2iv__II_3II
-	(JNIEnv *env, jobject, jint location, jint count, jintArray value, jint offset)
-{
-	int* v = (int*)env->GetPrimitiveArrayCritical(value, 0);
-	glUniform2iv( location, count, (GLint*)&v[offset] );
-	env->ReleasePrimitiveArrayCritical(value, v, 0);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform3f
  * Signature: (IFFF)V
  */
@@ -1665,7 +1513,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform3fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3fv__IILjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3fv
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1674,19 +1522,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glUniform3fv
- * Signature: (II[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3fv__II_3FI
-	(JNIEnv *env, jobject, jint location, jint count, jfloatArray value, jint offset)
-{
-	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
-	glUniform3fv( location, count, (GLfloat*)&v[offset] );
-	env->ReleasePrimitiveArrayCritical(value, v, 0);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform3i
  * Signature: (IIII)V
  */
@@ -1701,7 +1536,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform3iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3iv__IILjava_nio_IntBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3iv
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1710,19 +1545,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glUniform3iv
- * Signature: (II[II)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3iv__II_3II
-	(JNIEnv *env, jobject, jint location, jint count, jintArray value, jint offset)
-{
-	int* v = (int*)env->GetPrimitiveArrayCritical(value, 0);
-	glUniform3iv( location, count, (GLint*)&v[offset] );
-	env->ReleasePrimitiveArrayCritical(value, v, 0);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform4f
  * Signature: (IFFFF)V
  */
@@ -1737,7 +1559,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform4fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4fv__IILjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4fv
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1746,19 +1568,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glUniform4fv
- * Signature: (II[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4fv__II_3FI
-	(JNIEnv *env, jobject, jint location, jint count, jfloatArray value, jint offset)
-{
-	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
-	glUniform4fv( location, count, (GLfloat*)&v[offset] );
-	env->ReleasePrimitiveArrayCritical(value, v, 0);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform4i
  * Signature: (IIIII)V
  */
@@ -1773,7 +1582,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform4iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4iv__IILjava_nio_IntBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4iv
   (JNIEnv *env, jobject, jint location, jint count, jobject v)
 {
 	void* dataPtr = getDirectBufferPointer( env, v );
@@ -1782,23 +1591,10 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glUniform4iv
- * Signature: (II[II)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4iv__II_3II
-	(JNIEnv *env, jobject, jint location, jint count, jintArray value, jint offset)
-{
-	int* v = (int*)env->GetPrimitiveArrayCritical(value, 0);
-	glUniform4iv( location, count, (GLint*)&v[offset] );
-	env->ReleasePrimitiveArrayCritical(value, v, 0);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniformMatrix2fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix2fv__IIZLjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix2fv
   (JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jobject value)
 {
 	void* dataPtr = getDirectBufferPointer( env, value );
@@ -1807,23 +1603,10 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glUniformMatrix2fv
- * Signature: (IIZ[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix2fv__IIZ_3FI
-  (JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jfloatArray value, jint offset)
-{
-	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
-	glUniformMatrix2fv( location, count, transpose, (GLfloat*)&v[offset] );
-	env->ReleasePrimitiveArrayCritical(value, v, 0);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniformMatrix3fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix3fv__IIZLjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix3fv
   (JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jobject value)
 {
 	void* dataPtr = getDirectBufferPointer( env, value );
@@ -1832,23 +1615,10 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glUniformMatrix3fv
- * Signature: (IIZ[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix3fv__IIZ_3FI
-	(JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jfloatArray value, jint offset)
-{
-	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
-	glUniformMatrix3fv( location, count, transpose, (GLfloat*)&v[offset] );
-	env->ReleasePrimitiveArrayCritical(value, v, 0);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniformMatrix4fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix4fv__IIZLjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix4fv
   (JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jobject value)
 {
 	void* dataPtr = getDirectBufferPointer( env, value );
@@ -1857,19 +1627,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glUniformMatrix4fv
- * Signature: (IIZ[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix4fv__IIZ_3FI
-	(JNIEnv *env, jobject, jint location, jint count, jboolean transpose, jfloatArray value, jint offset)
-{
-	float* v = (float*)env->GetPrimitiveArrayCritical(value, 0);
-	glUniformMatrix4fv( location, count, transpose, (GLfloat*)&v[offset] );
-	env->ReleasePrimitiveArrayCritical(value, v, 0);
-}
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUseProgram
  * Signature: (I)V
  */
@@ -2002,7 +1759,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glVert
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glViewportJni
+ * Method:    glViewport
  * Signature: (IIII)V
  */
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glViewportJni
diff --git a/gdx/jni/iosgl/iosgl20.h b/gdx/jni/iosgl/iosgl20.h
index 3d56ba9..68e7a51 100644
--- a/gdx/jni/iosgl/iosgl20.h
+++ b/gdx/jni/iosgl/iosgl20.h
@@ -249,14 +249,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glDeleteBuffer
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDeleteBuffer
-  (JNIEnv *, jobject, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glDeleteFramebuffers
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -265,14 +257,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glDeleteFramebuffer
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDeleteFramebuffer
-  (JNIEnv *, jobject, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glDeleteProgram
  * Signature: (I)V
  */
@@ -289,14 +273,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glDeleteRenderbuffer
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDeleteRenderbuffer
-  (JNIEnv *, jobject, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glDeleteShader
  * Signature: (I)V
  */
@@ -313,14 +289,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDele
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glDeleteTexture
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glDeleteTexture
-  (JNIEnv *, jobject, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glDepthFunc
  * Signature: (I)V
  */
@@ -457,14 +425,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenB
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glGenBuffer
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenBuffer
-  (JNIEnv *, jobject);
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glGenerateMipmap
  * Signature: (I)V
  */
@@ -481,14 +441,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenF
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glGenFramebuffer
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenFramebuffer
-  (JNIEnv *, jobject);
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glGenRenderbuffers
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -497,14 +449,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenR
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glGenRenderbuffer
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenRenderbuffer
-  (JNIEnv *, jobject);
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glGenTextures
  * Signature: (ILjava/nio/IntBuffer;)V
  */
@@ -513,14 +457,6 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenT
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glGenTexture
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glGenTexture
-  (JNIEnv *, jobject);
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glGetActiveAttrib
  * Signature: (IILjava/nio/IntBuffer;Ljava/nio/Buffer;)Ljava/lang/String;
  */
@@ -988,19 +924,11 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform1fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1fv__IILjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1fv
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glUniform1fv
- * Signature: (II[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1fv__II_3FI
-  (JNIEnv *, jobject, jint, jint, jfloatArray, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform1i
  * Signature: (II)V
  */
@@ -1012,19 +940,11 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform1iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1iv__IILjava_nio_IntBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1iv
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glUniform1iv
- * Signature: (II[II)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform1iv__II_3II
-  (JNIEnv *, jobject, jint, jint, jintArray, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform2f
  * Signature: (IFF)V
  */
@@ -1036,19 +956,11 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform2fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2fv__IILjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2fv
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glUniform2fv
- * Signature: (II[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2fv__II_3FI
-  (JNIEnv *, jobject, jint, jint, jfloatArray, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform2i
  * Signature: (III)V
  */
@@ -1060,19 +972,11 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform2iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2iv__IILjava_nio_IntBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2iv
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glUniform2iv
- * Signature: (II[II)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform2iv__II_3II
-  (JNIEnv *, jobject, jint, jint, jintArray, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform3f
  * Signature: (IFFF)V
  */
@@ -1084,19 +988,11 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform3fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3fv__IILjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3fv
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glUniform3fv
- * Signature: (II[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3fv__II_3FI
-  (JNIEnv *, jobject, jint, jint, jfloatArray, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform3i
  * Signature: (IIII)V
  */
@@ -1108,19 +1004,11 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform3iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3iv__IILjava_nio_IntBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3iv
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glUniform3iv
- * Signature: (II[II)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform3iv__II_3II
-  (JNIEnv *, jobject, jint, jint, jintArray, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform4f
  * Signature: (IFFFF)V
  */
@@ -1132,19 +1020,11 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform4fv
  * Signature: (IILjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4fv__IILjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4fv
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glUniform4fv
- * Signature: (II[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4fv__II_3FI
-  (JNIEnv *, jobject, jint, jint, jfloatArray, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniform4i
  * Signature: (IIIII)V
  */
@@ -1156,67 +1036,35 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUnif
  * Method:    glUniform4iv
  * Signature: (IILjava/nio/IntBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4iv__IILjava_nio_IntBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4iv
   (JNIEnv *, jobject, jint, jint, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glUniform4iv
- * Signature: (II[II)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniform4iv__II_3II
-  (JNIEnv *, jobject, jint, jint, jintArray, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniformMatrix2fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix2fv__IIZLjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix2fv
   (JNIEnv *, jobject, jint, jint, jboolean, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glUniformMatrix2fv
- * Signature: (IIZ[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix2fv__IIZ_3FI
-  (JNIEnv *, jobject, jint, jint, jboolean, jfloatArray, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniformMatrix3fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix3fv__IIZLjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix3fv
   (JNIEnv *, jobject, jint, jint, jboolean, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glUniformMatrix3fv
- * Signature: (IIZ[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix3fv__IIZ_3FI
-  (JNIEnv *, jobject, jint, jint, jboolean, jfloatArray, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUniformMatrix4fv
  * Signature: (IIZLjava/nio/FloatBuffer;)V
  */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix4fv__IIZLjava_nio_FloatBuffer_2
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix4fv
   (JNIEnv *, jobject, jint, jint, jboolean, jobject);
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glUniformMatrix4fv
- * Signature: (IIZ[FI)V
- */
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glUniformMatrix4fv__IIZ_3FI
-  (JNIEnv *, jobject, jint, jint, jboolean, jfloatArray, jint);
-
-/*
- * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
  * Method:    glUseProgram
  * Signature: (I)V
  */
@@ -1313,7 +1161,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glVert
 
 /*
  * Class:     com_badlogic_gdx_backends_iosrobovm_IOSGLES20
- * Method:    glViewportJni
+ * Method:    glViewport
  * Signature: (IIII)V
  */
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_backends_iosrobovm_IOSGLES20_glViewportJni
diff --git a/gdx/jni/maven/pom.xml b/gdx/jni/maven/pom.xml
index c9b5684..758b0a2 100644
--- a/gdx/jni/maven/pom.xml
+++ b/gdx/jni/maven/pom.xml
@@ -4,7 +4,7 @@
     <parent>
         <groupId>com.badlogicgames.gdx</groupId>
         <artifactId>gdx-parent</artifactId>
-        <version>1.5.4-SNAPSHOT</version>
+        <version>1.4.2-SNAPSHOT</version>
         <relativePath>../../..</relativePath>
     </parent>
     
diff --git a/gdx/pom.xml b/gdx/pom.xml
index 4ccd3a1..edf99e5 100644
--- a/gdx/pom.xml
+++ b/gdx/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.5.4-SNAPSHOT</version>
+    <version>1.4.2-SNAPSHOT</version>
   </parent>
 
   <artifactId>gdx</artifactId>
diff --git a/gdx/src/com/badlogic/gdx.gwt.xml b/gdx/src/com/badlogic/gdx.gwt.xml
index 2f19010..1ebc16c 100644
--- a/gdx/src/com/badlogic/gdx.gwt.xml
+++ b/gdx/src/com/badlogic/gdx.gwt.xml
@@ -35,7 +35,6 @@
 		<include name="assets/loaders/AssetLoader.java"/>
 		<include name="assets/loaders/AsynchronousAssetLoader.java"/>
 		<include name="assets/loaders/BitmapFontLoader.java"/>
-		<exclude name="assets/loaders/CubemapLoader.java"/> <!--  relies on KTXTextureData -->
 		<include name="assets/loaders/FileHandleResolver.java"/>
 		<include name="assets/loaders/I18NBundleLoader.java"/>
 		<include name="assets/loaders/ModelLoader.java"/>
@@ -68,7 +67,6 @@
 		<include name="graphics/Color.java"/>
 		<include name="graphics/Colors.java"/>
 		<include name="graphics/Cubemap.java"/>
-		<include name="graphics/CubemapData.java"/>
 		<include name="graphics/FPSLogger.java"/>
 		<include name="graphics/GL20.java"/>
 		<include name="graphics/GL30.java"/>
@@ -80,7 +78,7 @@
 		<include name="graphics/Pixmap.java"/> <!-- Emulated -->
 		<exclude name="graphics/PixmapIO.java"/> <!-- Reason: No DeflaterOutputStream -->
 		<include name="graphics/Texture.java"/>
-		<exclude name="graphics/TextureData.java"/> <!-- emulated: TextureData.Factory requires ETC1 -->
+		<include name="graphics/TextureData.java"/>
 		<include name="graphics/VertexAttribute.java"/>
 		<include name="graphics/VertexAttributes.java"/>
 		
@@ -97,7 +95,6 @@
 		<include name="graphics/g2d/ParticleEmitter.java"/>
 		<include name="graphics/g2d/ParticleEmitterBox2D.java"/>		
 		<include name="graphics/g2d/PixmapPacker.java"/>
-		<exclude name="graphics/g2d/PixmapPackerIO.java"/>
 		<include name="graphics/g2d/PolygonRegion.java"/>
 		<include name="graphics/g2d/PolygonRegionLoader.java"/>
 		<include name="graphics/g2d/PolygonSprite.java"/>
@@ -105,7 +102,6 @@
 		<include name="graphics/g2d/Sprite.java"/>
 		<include name="graphics/g2d/SpriteBatch.java"/>
 		<include name="graphics/g2d/SpriteCache.java"/>
-		<include name="graphics/g2d/TextMarkup.java"/>
 		<include name="graphics/g2d/TextureAtlas.java"/>
 		<include name="graphics/g2d/TextureRegion.java"/>
 		
@@ -207,7 +203,6 @@
 	<!-- graphics/glutils -->
 		<exclude name="graphics/glutils/ETC1.java"/> <!-- Reason: No ETC1 Support -->
 		<include name="graphics/glutils/ETC1TextureData.java"/>  <!-- Emulated: explodes on construction -->
-		<include name="graphics/glutils/FacedCubemapData.java"/>
 		<include name="graphics/glutils/FileTextureData.java"/> <!-- Emulated: No PixmapIO -->
 		<include name="graphics/glutils/FloatFrameBuffer.java"/>
 		<include name="graphics/glutils/FloatTextureData.java"/>
@@ -219,7 +214,6 @@
 		<include name="graphics/glutils/IndexBufferObject.java"/> <!-- Emulated -->
 		<include name="graphics/glutils/IndexBufferObjectSubData.java"/>
 		<include name="graphics/glutils/IndexData.java"/>
-		<exclude name="graphics/glutils/KTXTextureData.java"/>  <!-- Rely on ETC1 -->
 		<include name="graphics/glutils/MipMapGenerator.java"/>
 		<include name="graphics/glutils/PixmapTextureData.java"/>
 		<include name="graphics/glutils/ShaderProgram.java"/>
@@ -260,7 +254,6 @@
 	
 	<!-- maps/tiled -->
 		<include name="maps/tiled/AtlasTmxMapLoader.java"/>
-		<include name="maps/tiled/BaseTmxMapLoader.java"/>
 		<include name="maps/tiled/TideMapLoader.java"/>
 		<include name="maps/tiled/TiledMap.java"/>
 		<include name="maps/tiled/TiledMapRenderer.java"/>
@@ -268,7 +261,6 @@
 		<include name="maps/tiled/TiledMapTileLayer.java"/>
 		<include name="maps/tiled/TiledMapTileSet.java"/>
 		<include name="maps/tiled/TiledMapTileSets.java"/>
-		<include name="maps/tiled/TiledMapImageLayer.java"/>
 		<include name="maps/tiled/TmxMapHelper.java"/>
 		<include name="maps/tiled/TmxMapLoader.java"/>
 		
diff --git a/gdx/src/com/badlogic/gdx/ApplicationListener.java b/gdx/src/com/badlogic/gdx/ApplicationListener.java
index da9cc8a..74939ff 100644
--- a/gdx/src/com/badlogic/gdx/ApplicationListener.java
+++ b/gdx/src/com/badlogic/gdx/ApplicationListener.java
@@ -42,11 +42,13 @@ public interface ApplicationListener {
 	/** Called when the {@link Application} should render itself. */
 	public void render ();
 
-	/** Called when the {@link Application} is paused, usually when it's not active or visible on screen. An Application is also
-	 * paused before it is destroyed. */
+	/** Called when the {@link Application} is paused. An Application is paused before it is destroyed, when a user pressed the Home
+	 * button on Android or an incoming call happened. On the desktop this will only be called immediately before {@link #dispose()}
+	 * is called. */
 	public void pause ();
 
-	/** Called when the {@link Application} is resumed from a paused state, usually when it regains focus. */
+	/** Called when the {@link Application} is resumed from a paused state. On Android this happens when the activity gets focus
+	 * again. On the desktop this method will never be called. */
 	public void resume ();
 
 	/** Called when the {@link Application} is destroyed. Preceded by a call to {@link #pause()}. */
diff --git a/gdx/src/com/badlogic/gdx/Game.java b/gdx/src/com/badlogic/gdx/Game.java
index 21f217c..f93cd5c 100644
--- a/gdx/src/com/badlogic/gdx/Game.java
+++ b/gdx/src/com/badlogic/gdx/Game.java
@@ -24,7 +24,7 @@ package com.badlogic.gdx;
  * screen is set.
  * </p> */
 public abstract class Game implements ApplicationListener {
-	protected Screen screen;
+	private Screen screen;
 
 	@Override
 	public void dispose () {
diff --git a/gdx/src/com/badlogic/gdx/Input.java b/gdx/src/com/badlogic/gdx/Input.java
index ce9e078..d131635 100644
--- a/gdx/src/com/badlogic/gdx/Input.java
+++ b/gdx/src/com/badlogic/gdx/Input.java
@@ -43,7 +43,7 @@ import com.badlogic.gdx.utils.ObjectIntMap;
  * 
  * @author mzechner */
 public interface Input {
-	/** Callback interface for {@link Input#getTextInput(TextInputListener, String, String, String)}
+	/** Callback interface for {@link Input#getTextInput(TextInputListener, String, String)}
 	 * 
 	 * @author mzechner */
 	static public interface TextInputListener {
@@ -648,7 +648,16 @@ public interface Input {
 	 * @param listener The TextInputListener.
 	 * @param title The title of the text input dialog.
 	 * @param text The message presented to the user. */
-	public void getTextInput (TextInputListener listener, String title, String text, String hint);
+	public void getTextInput (TextInputListener listener, String title, String text);
+
+	/** System dependent method to input a string of text. A dialog box will be created with the given title and the given text as a
+	 * hint message for the user. Once the dialog has been closed the provided {@link TextInputListener} will be called on the
+	 * rendering thread.
+	 * 
+	 * @param listener The TextInputListener.
+	 * @param title The title of the text input dialog.
+	 * @param placeholder The placeholder text presented to the user. */
+	public void getPlaceholderTextInput (TextInputListener listener, String title, String placeholder);
 
 	/** Sets the on-screen keyboard visible if available.
 	 * 
@@ -767,4 +776,4 @@ public interface Input {
 	 * @param xHotspot the x location of the hotspot pixel within the cursor image (origin top-left corner)
 	 * @param yHotspot the y location of the hotspot pixel within the cursor image (origin top-left corner) */
 	public void setCursorImage (Pixmap pixmap, int xHotspot, int yHotspot);
-}
\ No newline at end of file
+}
diff --git a/gdx/src/com/badlogic/gdx/Screen.java b/gdx/src/com/badlogic/gdx/Screen.java
index 3df45c9..cae2d0f 100644
--- a/gdx/src/com/badlogic/gdx/Screen.java
+++ b/gdx/src/com/badlogic/gdx/Screen.java
@@ -24,10 +24,6 @@ package com.badlogic.gdx;
  * </p>
  * @see Game */
 public interface Screen {
-	
-	/** Called when this screen becomes the current screen for a {@link Game}. */
-	public void show ();
-	
 	/** Called when the screen should render itself.
 	 * @param delta The time in seconds since the last render. */
 	public void render (float delta);
@@ -35,15 +31,18 @@ public interface Screen {
 	/** @see ApplicationListener#resize(int, int) */
 	public void resize (int width, int height);
 
+	/** Called when this screen becomes the current screen for a {@link Game}. */
+	public void show ();
+
+	/** Called when this screen is no longer the current screen for a {@link Game}. */
+	public void hide ();
+
 	/** @see ApplicationListener#pause() */
 	public void pause ();
 
 	/** @see ApplicationListener#resume() */
 	public void resume ();
 
-	/** Called when this screen is no longer the current screen for a {@link Game}. */
-	public void hide ();
-
 	/** Called when this screen should release all resources. */
 	public void dispose ();
 }
diff --git a/gdx/src/com/badlogic/gdx/Version.java b/gdx/src/com/badlogic/gdx/Version.java
index 3a147f5..903c1dc 100644
--- a/gdx/src/com/badlogic/gdx/Version.java
+++ b/gdx/src/com/badlogic/gdx/Version.java
@@ -23,7 +23,7 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
  * @author mzechner */
 public class Version {
 	/** the current version of libgdx as a String in the major.minor.revision format **/
-	public static final String VERSION = "1.5.4";
+	public static final String VERSION = "1.4.2";
 
 	/** the current major version of libgdx **/
 	public static final int MAJOR;
diff --git a/gdx/src/com/badlogic/gdx/assets/AssetManager.java b/gdx/src/com/badlogic/gdx/assets/AssetManager.java
index e211464..ab27e1e 100644
--- a/gdx/src/com/badlogic/gdx/assets/AssetManager.java
+++ b/gdx/src/com/badlogic/gdx/assets/AssetManager.java
@@ -93,8 +93,6 @@ public class AssetManager implements Disposable {
 		setLoader(Texture.class, new TextureLoader(resolver));
 		setLoader(Skin.class, new SkinLoader(resolver));
 		setLoader(ParticleEffect.class, new ParticleEffectLoader(resolver));
-		setLoader(com.badlogic.gdx.graphics.g3d.particles.ParticleEffect.class,
-			new com.badlogic.gdx.graphics.g3d.particles.ParticleEffectLoader(resolver));
 		setLoader(PolygonRegion.class, new PolygonRegionLoader(resolver));
 		setLoader(I18NBundle.class, new I18NBundleLoader(resolver));
 		setLoader(Model.class, ".g3dj", new G3dModelLoader(new JsonReader(), resolver));
@@ -129,13 +127,13 @@ public class AssetManager implements Disposable {
 		if (asset == null) throw new GdxRuntimeException("Asset not loaded: " + fileName);
 		return asset;
 	}
-
+	
 	/** @param type the asset type
 	 * @return all the assets matching the specified type */
 	public synchronized <T> Array<T> getAll (Class<T> type, Array<T> out) {
 		ObjectMap<String, RefCountedContainer> assetsByType = assets.get(type);
-		if (assetsByType != null) {
-			for (ObjectMap.Entry<String, RefCountedContainer> asset : assetsByType.entries()) {
+		if (assetsByType != null){
+			for(ObjectMap.Entry<String, RefCountedContainer> asset : assetsByType.entries()){
 				out.add(asset.value.getObject(type));
 			}
 		}
@@ -339,6 +337,21 @@ public class AssetManager implements Disposable {
 		load(desc.fileName, desc.type, desc.params);
 	}
 
+	/** Disposes the given asset and all its dependencies recursively, depth first.
+	 * @param fileName */
+	private void disposeDependencies (String fileName) {
+		Array<String> dependencies = assetDependencies.get(fileName);
+		if (dependencies != null) {
+			for (String dependency : dependencies) {
+				disposeDependencies(dependency);
+			}
+		}
+
+		Class type = assetTypes.get(fileName);
+		Object asset = assets.get(type).get(fileName).getObject(Object.class);
+		if (asset instanceof Disposable) ((Disposable)asset).dispose();
+	}
+
 	/** Updates the AssetManager, keeping it loading any assets in the preload queue.
 	 * @return true if all loading is finished. */
 	public synchronized boolean update () {
@@ -371,7 +384,7 @@ public class AssetManager implements Disposable {
 		}
 	}
 
-	/** Blocks until all assets are loaded. */
+	/** blocks until all assets are loaded. */
 	public void finishLoading () {
 		log.debug("Waiting for loading to complete...");
 		while (!update())
@@ -379,17 +392,6 @@ public class AssetManager implements Disposable {
 		log.debug("Loading complete.");
 	}
 
-	/** Blocks until the specified aseet is loaded.
-	 * @param fileName the file name (interpretation depends on {@link AssetLoader}) */
-	public void finishLoadingAsset (String fileName) {
-		log.debug("Waiting for asset to be loaded: " + fileName);
-		while (!isLoaded(fileName)) {
-			update();
-			ThreadUtils.yield();
-		}
-		log.debug("Asset loaded: " + fileName);
-	}
-
 	synchronized void injectDependencies (String parentAssetFilename, Array<AssetDescriptor> dependendAssetDescs) {
 		ObjectSet<String> injected = this.injected;
 		for (AssetDescriptor desc : dependendAssetDescs) {
@@ -436,9 +438,9 @@ public class AssetManager implements Disposable {
 			RefCountedContainer assetRef = assets.get(type).get(assetDesc.fileName);
 			assetRef.incRefCount();
 			incrementRefCountedDependencies(assetDesc.fileName);
-			if (assetDesc.params != null && assetDesc.params.loadedCallback != null) {
-				assetDesc.params.loadedCallback.finishedLoading(this, assetDesc.fileName, assetDesc.type);
-			}
+            if (assetDesc.params != null && assetDesc.params.loadedCallback != null) {
+                assetDesc.params.loadedCallback.finishedLoading(this, assetDesc.fileName, assetDesc.type);
+            }
 			loaded++;
 		} else {
 			// else add a new task for the asset.
@@ -585,7 +587,6 @@ public class AssetManager implements Disposable {
 	}
 
 	/** Disposes all assets in the manager and stops all asynchronous loading. */
-	@Override
 	public synchronized void dispose () {
 		log.debug("Disposing.");
 		clear();
diff --git a/gdx/src/com/badlogic/gdx/assets/loaders/CubemapLoader.java b/gdx/src/com/badlogic/gdx/assets/loaders/CubemapLoader.java
deleted file mode 100644
index 01dab39..0000000
--- a/gdx/src/com/badlogic/gdx/assets/loaders/CubemapLoader.java
+++ /dev/null
@@ -1,112 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.assets.loaders;
-
-import com.badlogic.gdx.assets.AssetDescriptor;
-import com.badlogic.gdx.assets.AssetLoaderParameters;
-import com.badlogic.gdx.assets.AssetManager;
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.Cubemap;
-import com.badlogic.gdx.graphics.CubemapData;
-import com.badlogic.gdx.graphics.Pixmap;
-import com.badlogic.gdx.graphics.Pixmap.Format;
-import com.badlogic.gdx.graphics.PixmapIO;
-import com.badlogic.gdx.graphics.Texture;
-import com.badlogic.gdx.graphics.Texture.TextureFilter;
-import com.badlogic.gdx.graphics.Texture.TextureWrap;
-import com.badlogic.gdx.graphics.TextureData;
-import com.badlogic.gdx.graphics.glutils.ETC1TextureData;
-import com.badlogic.gdx.graphics.glutils.FileTextureData;
-import com.badlogic.gdx.graphics.glutils.KTXTextureData;
-import com.badlogic.gdx.utils.Array;
-
-/** {@link AssetLoader} for {@link Cubemap} instances. The pixel data is loaded asynchronously. The texture is then created on the
- * rendering thread, synchronously. Passing a {@link CubemapParameter} to
- * {@link AssetManager#load(String, Class, AssetLoaderParameters)} allows one to specify parameters as can be passed to the
- * various Cubemap constructors, e.g. filtering and so on.
- * @author mzechner, Vincent Bousquet */
-public class CubemapLoader extends AsynchronousAssetLoader<Cubemap, CubemapLoader.CubemapParameter> {
-	static public class CubemapLoaderInfo {
-		String filename;
-		CubemapData data;
-		Cubemap cubemap;
-	};
-
-	CubemapLoaderInfo info = new CubemapLoaderInfo();
-
-	public CubemapLoader (FileHandleResolver resolver) {
-		super(resolver);
-	}
-
-	@Override
-	public void loadAsync (AssetManager manager, String fileName, FileHandle file, CubemapParameter parameter) {
-		info.filename = fileName;
-		if (parameter == null || parameter.cubemapData == null) {
-			Pixmap pixmap = null;
-			Format format = null;
-			boolean genMipMaps = false;
-			info.cubemap = null;
-
-			if (parameter != null) {
-				format = parameter.format;
-				info.cubemap = parameter.cubemap;
-			}
-
-			if (fileName.contains(".ktx") || fileName.contains(".zktx")) {
-				info.data = new KTXTextureData(file, genMipMaps);
-			}
-		} else {
-			info.data = parameter.cubemapData;
-			info.cubemap = parameter.cubemap;
-		}
-		if (!info.data.isPrepared()) info.data.prepare();
-	}
-
-	@Override
-	public Cubemap loadSync (AssetManager manager, String fileName, FileHandle file, CubemapParameter parameter) {
-		if (info == null) return null;
-		Cubemap cubemap = info.cubemap;
-		if (cubemap != null) {
-			cubemap.load(info.data);
-		} else {
-			cubemap = new Cubemap(info.data);
-		}
-		if (parameter != null) {
-			cubemap.setFilter(parameter.minFilter, parameter.magFilter);
-			cubemap.setWrap(parameter.wrapU, parameter.wrapV);
-		}
-		return cubemap;
-	}
-
-	@Override
-	public Array<AssetDescriptor> getDependencies (String fileName, FileHandle file, CubemapParameter parameter) {
-		return null;
-	}
-
-	static public class CubemapParameter extends AssetLoaderParameters<Cubemap> {
-		/** the format of the final Texture. Uses the source images format if null **/
-		public Format format = null;
-		/** The texture to put the {@link TextureData} in, optional. **/
-		public Cubemap cubemap = null;
-		/** CubemapData for textures created on the fly, optional. When set, all format and genMipMaps are ignored */
-		public CubemapData cubemapData = null;
-		public TextureFilter minFilter = TextureFilter.Nearest;
-		public TextureFilter magFilter = TextureFilter.Nearest;
-		public TextureWrap wrapU = TextureWrap.ClampToEdge;
-		public TextureWrap wrapV = TextureWrap.ClampToEdge;
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/assets/loaders/TextureLoader.java b/gdx/src/com/badlogic/gdx/assets/loaders/TextureLoader.java
index 8118cf1..608dbc7 100644
--- a/gdx/src/com/badlogic/gdx/assets/loaders/TextureLoader.java
+++ b/gdx/src/com/badlogic/gdx/assets/loaders/TextureLoader.java
@@ -16,11 +16,11 @@
 
 package com.badlogic.gdx.assets.loaders;
 
+import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.assets.AssetDescriptor;
 import com.badlogic.gdx.assets.AssetLoaderParameters;
 import com.badlogic.gdx.assets.AssetManager;
 import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.GLTexture;
 import com.badlogic.gdx.graphics.Pixmap;
 import com.badlogic.gdx.graphics.Pixmap.Format;
 import com.badlogic.gdx.graphics.PixmapIO;
@@ -30,8 +30,8 @@ import com.badlogic.gdx.graphics.Texture.TextureWrap;
 import com.badlogic.gdx.graphics.TextureData;
 import com.badlogic.gdx.graphics.glutils.ETC1TextureData;
 import com.badlogic.gdx.graphics.glutils.FileTextureData;
-import com.badlogic.gdx.graphics.glutils.KTXTextureData;
 import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.ObjectMap;
 
 /** {@link AssetLoader} for {@link Texture} instances. The pixel data is loaded asynchronously. The texture is then created on the
  * rendering thread, synchronously. Passing a {@link TextureParameter} to
@@ -66,7 +66,15 @@ public class TextureLoader extends AsynchronousAssetLoader<Texture, TextureLoade
 				info.texture = parameter.texture;
 			}
 
-			info.data = TextureData.Factory.loadFromFile(file, format, genMipMaps);
+			if (!fileName.contains(".etc1")) {
+				if (fileName.contains(".cim"))
+					pixmap = PixmapIO.readCIM(file);
+				else
+					pixmap = new Pixmap(file);
+				info.data = new FileTextureData(file, pixmap, format, genMipMaps);
+			} else {
+				info.data = new ETC1TextureData(file, genMipMaps);
+			}
 		} else {
 			info.data = parameter.textureData;
 			info.texture = parameter.texture;
diff --git a/gdx/src/com/badlogic/gdx/files/FileHandle.java b/gdx/src/com/badlogic/gdx/files/FileHandle.java
index c32e531..7be1b67 100644
--- a/gdx/src/com/badlogic/gdx/files/FileHandle.java
+++ b/gdx/src/com/badlogic/gdx/files/FileHandle.java
@@ -339,7 +339,7 @@ public class FileHandle {
 		writeString(string, append, null);
 	}
 
-	/** Writes the specified string to the file using the specified charset. Parent directories will be created if necessary.
+	/** Writes the specified string to the file as UTF-8. Parent directories will be created if necessary.
 	 * @param append If false, this file will be overwritten if it exists, otherwise it will be appended.
 	 * @param charset May be null to use the default charset.
 	 * @throws GdxRuntimeException if this file handle represents a directory, if it is a {@link FileType#Classpath} or
diff --git a/gdx/src/com/badlogic/gdx/graphics/Cubemap.java b/gdx/src/com/badlogic/gdx/graphics/Cubemap.java
index e11ebad..65c41a0 100644
--- a/gdx/src/com/badlogic/gdx/graphics/Cubemap.java
+++ b/gdx/src/com/badlogic/gdx/graphics/Cubemap.java
@@ -16,30 +16,21 @@
 
 package com.badlogic.gdx.graphics;
 
-import java.util.HashMap;
-import java.util.Map;
-
-import com.badlogic.gdx.Application;
 import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.assets.AssetLoaderParameters.LoadedCallback;
-import com.badlogic.gdx.assets.AssetManager;
-import com.badlogic.gdx.assets.loaders.AssetLoader;
-import com.badlogic.gdx.assets.loaders.CubemapLoader.CubemapParameter;
 import com.badlogic.gdx.files.FileHandle;
 import com.badlogic.gdx.graphics.Pixmap.Format;
 import com.badlogic.gdx.graphics.Texture.TextureFilter;
 import com.badlogic.gdx.graphics.Texture.TextureWrap;
-import com.badlogic.gdx.graphics.glutils.FacedCubemapData;
+import com.badlogic.gdx.graphics.glutils.ETC1TextureData;
+import com.badlogic.gdx.graphics.glutils.FileTextureData;
+import com.badlogic.gdx.graphics.glutils.MipMapGenerator;
 import com.badlogic.gdx.graphics.glutils.PixmapTextureData;
-import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 
 /** Wraps a standard OpenGL ES Cubemap. Must be disposed when it is no longer used.
  * @author Xoppa */
 public class Cubemap extends GLTexture {
-	private static AssetManager assetManager;
-	final static Map<Application, Array<Cubemap>> managedCubemaps = new HashMap<Application, Array<Cubemap>>();
-
 	/** Enum to identify each side of a Cubemap */
 	public enum CubemapSide {
 		/** The positive X and first side of the cubemap */
@@ -71,13 +62,12 @@ public class Cubemap extends GLTexture {
 		}
 	}
 
-	protected CubemapData data;
+	protected final TextureData[] data = new TextureData[6];
 
-	/** Construct an Cubemap based on the given CubemapData. */
-	public Cubemap (CubemapData data) {
-		super(GL20.GL_TEXTURE_CUBE_MAP);
-		this.data = data;
-		load(data);
+	/** Construct an empty Cubemap. Use the load(...) methods to set the texture of each side. Every side of the cubemap must be set
+	 * before it can be used. */
+	public Cubemap () {
+		this((TextureData)null, (TextureData)null, (TextureData)null, (TextureData)null, (TextureData)null, (TextureData)null);
 	}
 
 	/** Construct a Cubemap with the specified texture files for the sides, does not generate mipmaps. */
@@ -125,155 +115,142 @@ public class Cubemap extends GLTexture {
 		magFilter = TextureFilter.Nearest;
 		uWrap = TextureWrap.ClampToEdge;
 		vWrap = TextureWrap.ClampToEdge;
-		data = new FacedCubemapData(positiveX, negativeX, positiveY, negativeY, positiveZ, negativeZ);
-		load(data);
+		load(positiveX, negativeX, positiveY, negativeY, positiveZ, negativeZ);
 	}
 
-	/** Sets the sides of this cubemap to the specified {@link CubemapData}. */
-	public void load (CubemapData data) {
-		if (!data.isPrepared()) data.prepare();
+	/** Sets the sides of this cubemap to the specified {@link TextureData}. */
+	public void load (TextureData positiveX, TextureData negativeX, TextureData positiveY, TextureData negativeY,
+		TextureData positiveZ, TextureData negativeZ) {
 		bind();
 		unsafeSetFilter(minFilter, magFilter, true);
 		unsafeSetWrap(uWrap, vWrap, true);
-		data.consumeCubemapData();
+		unsafeLoad(CubemapSide.PositiveX, positiveX);
+		unsafeLoad(CubemapSide.NegativeX, negativeX);
+		unsafeLoad(CubemapSide.PositiveY, positiveY);
+		unsafeLoad(CubemapSide.NegativeY, negativeY);
+		unsafeLoad(CubemapSide.PositiveZ, positiveZ);
+		unsafeLoad(CubemapSide.NegativeZ, negativeZ);
 		Gdx.gl.glBindTexture(glTarget, 0);
 	}
 
-	public CubemapData getCubemapData () {
-		return data;
-	}
-
 	@Override
 	public boolean isManaged () {
-		return data.isManaged();
+		for (TextureData data : this.data)
+			if (!data.isManaged()) return false;
+		return true;
 	}
 
 	@Override
 	protected void reload () {
 		if (!isManaged()) throw new GdxRuntimeException("Tried to reload an unmanaged Cubemap");
 		glHandle = createGLHandle();
-		load(data);
-	}
-
-	@Override
-	public int getWidth () {
-		return data.getWidth();
+		load(data[CubemapSide.PositiveX.index], data[CubemapSide.NegativeX.index], data[CubemapSide.PositiveY.index],
+			data[CubemapSide.NegativeY.index], data[CubemapSide.PositiveZ.index], data[CubemapSide.NegativeZ.index]);
 	}
 
-	@Override
-	public int getHeight () {
-		return data.getHeight();
+	/** Loads the texture specified using the {@link FileHandle} and sets it to specified side, overwriting any previous data set to
+	 * that side. Does not generate mipmaps. This method binds the Cubemap to the active unit!
+	 * @param side The {@link CubemapSide}
+	 * @param file The texture {@link FileHandle} */
+	public void load (CubemapSide side, FileHandle file) {
+		load(side, file, false);
 	}
 
-	@Override
-	public int getDepth () {
-		return 0;
+	/** Loads the texture specified using the {@link FileHandle} and sets it to specified side, overwriting any previous data set to
+	 * that side. This method binds the Cubemap to the active unit!
+	 * @param side The {@link CubemapSide}
+	 * @param file The texture {@link FileHandle}
+	 * @param useMipMaps True to generate mipmaps. */
+	public void load (CubemapSide side, FileHandle file, boolean useMipMaps) {
+		load(side, createTextureData(file, useMipMaps));
 	}
 
-	/** Disposes all resources associated with the cubemap */
-	public void dispose () {
-		// this is a hack. reason: we have to set the glHandle to 0 for textures that are
-		// reloaded through the asset manager as we first remove (and thus dispose) the texture
-		// and then reload it. the glHandle is set to 0 in invalidateAllTextures prior to
-		// removal from the asset manager.
-		if (glHandle == 0) return;
-		delete();
-		if (data.isManaged()) if (managedCubemaps.get(Gdx.app) != null) managedCubemaps.get(Gdx.app).removeValue(this, true);
+	/** Sets the specified side of this cubemap to the specified {@link Pixmap}, overwriting any previous data set to that side.
+	 * Does not generate mipmaps. This method binds the Cubemap to the active unit!
+	 * @param side The {@link CubemapSide}
+	 * @param pixmap The {@link Pixmap} */
+	public void load (CubemapSide side, Pixmap pixmap) {
+		load(side, pixmap == null ? null : new PixmapTextureData(pixmap, null, false, false));
 	}
 
-	private static void addManagedCubemap (Application app, Cubemap cubemap) {
-		Array<Cubemap> managedCubemapArray = managedCubemaps.get(app);
-		if (managedCubemapArray == null) managedCubemapArray = new Array<Cubemap>();
-		managedCubemapArray.add(cubemap);
-		managedCubemaps.put(app, managedCubemapArray);
+	/** Sets the specified side of this cubemap to the specified {@link Pixmap}, overwriting any previous data set to that side.
+	 * This method binds the Cubemap to the active unit!
+	 * @param side The {@link CubemapSide}
+	 * @param pixmap The {@link Pixmap}
+	 * @param useMipMaps True to generate mipmaps. */
+	public void load (CubemapSide side, Pixmap pixmap, boolean useMipMaps) {
+		load(side, pixmap == null ? null : new PixmapTextureData(pixmap, null, useMipMaps, false));
 	}
 
-	/** Clears all managed cubemaps. This is an internal method. Do not use it! */
-	public static void clearAllCubemaps (Application app) {
-		managedCubemaps.remove(app);
+	/** Sets the specified side of this cubemap to the specified {@link TextureData}, overwriting any previous data set to that
+	 * side. This method binds the Cubemap to the active unit!
+	 * @param side The {@link CubemapSide}
+	 * @param data The {@link TextureData} */
+	public void load (CubemapSide side, TextureData data) {
+		bind();
+		unsafeLoad(side, data);
+		Gdx.gl.glBindTexture(glTarget, 0);
 	}
 
-	/** Invalidate all managed cubemaps. This is an internal method. Do not use it! */
-	public static void invalidateAllCubemaps (Application app) {
-		Array<Cubemap> managedCubemapArray = managedCubemaps.get(app);
-		if (managedCubemapArray == null) return;
+	/** Sets the specified side of this cubemap to the specified {@link TextureData}, overwriting any previous data set to that
+	 * side. Assumes that the cubemap is bound and active! See also: {@link #load(CubemapSide, TextureData)}
+	 * @param side The {@link CubemapSide}
+	 * @param data The {@link TextureData} */
+	protected void unsafeLoad (CubemapSide side, TextureData data) {
+		final int idx = side.index;
+		if (this.data[idx] != null && data != null && data.isManaged() != this.data[idx].isManaged())
+			throw new GdxRuntimeException("New data must have the same managed status as the old data");
 
-		if (assetManager == null) {
-			for (int i = 0; i < managedCubemapArray.size; i++) {
-				Cubemap cubemap = managedCubemapArray.get(i);
-				cubemap.reload();
-			}
-		} else {
-			// first we have to make sure the AssetManager isn't loading anything anymore,
-			// otherwise the ref counting trick below wouldn't work (when a cubemap is
-			// currently on the task stack of the manager.)
-			assetManager.finishLoading();
+		uploadImageData(side.glEnum, data);
 
-			// next we go through each cubemap and reload either directly or via the
-			// asset manager.
-			Array<Cubemap> cubemaps = new Array<Cubemap>(managedCubemapArray);
-			for (Cubemap cubemap : cubemaps) {
-				String fileName = assetManager.getAssetFileName(cubemap);
-				if (fileName == null) {
-					cubemap.reload();
-				} else {
-					// get the ref count of the cubemap, then set it to 0 so we
-					// can actually remove it from the assetmanager. Also set the
-					// handle to zero, otherwise we might accidentially dispose
-					// already reloaded cubemaps.
-					final int refCount = assetManager.getReferenceCount(fileName);
-					assetManager.setReferenceCount(fileName, 0);
-					cubemap.glHandle = 0;
-
-					// create the parameters, passing the reference to the cubemap as
-					// well as a callback that sets the ref count.
-					CubemapParameter params = new CubemapParameter();
-					params.cubemapData = cubemap.getCubemapData();
-					params.minFilter = cubemap.getMinFilter();
-					params.magFilter = cubemap.getMagFilter();
-					params.wrapU = cubemap.getUWrap();
-					params.wrapV = cubemap.getVWrap();
-					params.cubemap = cubemap; // special parameter which will ensure that the references stay the same.
-					params.loadedCallback = new LoadedCallback() {
-						@Override
-						public void finishedLoading (AssetManager assetManager, String fileName, Class type) {
-							assetManager.setReferenceCount(fileName, refCount);
-						}
-					};
+		this.data[idx] = data;
+	}
 
-					// unload the c, create a new gl handle then reload it.
-					assetManager.unload(fileName);
-					cubemap.glHandle = GLTexture.createGLHandle();
-					assetManager.load(fileName, Cubemap.class, params);
-				}
-			}
-			managedCubemapArray.clear();
-			managedCubemapArray.addAll(cubemaps);
-		}
+	/** @return True if all sides of this cubemap are set, false otherwise. */
+	public boolean isComplete () {
+		for (int i = 0; i < data.length; i++)
+			if (data[i] == null) return false;
+		return true;
 	}
 
-	/** Sets the {@link AssetManager}. When the context is lost, cubemaps managed by the asset manager are reloaded by the manager
-	 * on a separate thread (provided that a suitable {@link AssetLoader} is registered with the manager). Cubemaps not managed by
-	 * the AssetManager are reloaded via the usual means on the rendering thread.
-	 * @param manager the asset manager. */
-	public static void setAssetManager (AssetManager manager) {
-		Cubemap.assetManager = manager;
+	/** @return The {@link TextureData} for the specified side, can be null if the cubemap is incomplete. */
+	public TextureData getTextureData (CubemapSide side) {
+		return data[side.index];
 	}
 
-	public static String getManagedStatus () {
-		StringBuilder builder = new StringBuilder();
-		builder.append("Managed cubemap/app: { ");
-		for (Application app : managedCubemaps.keySet()) {
-			builder.append(managedCubemaps.get(app).size);
-			builder.append(" ");
-		}
-		builder.append("}");
-		return builder.toString();
+	@Override
+	public int getWidth () {
+		int tmp, width = 0;
+		if (data[CubemapSide.PositiveZ.index] != null && (tmp = data[CubemapSide.PositiveZ.index].getWidth()) > width) width = tmp;
+		if (data[CubemapSide.NegativeZ.index] != null && (tmp = data[CubemapSide.NegativeZ.index].getWidth()) > width) width = tmp;
+		if (data[CubemapSide.PositiveY.index] != null && (tmp = data[CubemapSide.PositiveY.index].getWidth()) > width) width = tmp;
+		if (data[CubemapSide.NegativeY.index] != null && (tmp = data[CubemapSide.NegativeY.index].getWidth()) > width) width = tmp;
+		return width;
 	}
 
-	/** @return the number of managed cubemaps currently loaded */
-	public static int getNumManagedCubemaps () {
-		return managedCubemaps.get(Gdx.app).size;
+	@Override
+	public int getHeight () {
+		int tmp, height = 0;
+		if (data[CubemapSide.PositiveZ.index] != null && (tmp = data[CubemapSide.PositiveZ.index].getHeight()) > height)
+			height = tmp;
+		if (data[CubemapSide.NegativeZ.index] != null && (tmp = data[CubemapSide.NegativeZ.index].getHeight()) > height)
+			height = tmp;
+		if (data[CubemapSide.PositiveX.index] != null && (tmp = data[CubemapSide.PositiveX.index].getHeight()) > height)
+			height = tmp;
+		if (data[CubemapSide.NegativeX.index] != null && (tmp = data[CubemapSide.NegativeX.index].getHeight()) > height)
+			height = tmp;
+		return height;
 	}
 
+	@Override
+	public int getDepth () {
+		int tmp, depth = 0;
+		if (data[CubemapSide.PositiveX.index] != null && (tmp = data[CubemapSide.PositiveX.index].getWidth()) > depth) depth = tmp;
+		if (data[CubemapSide.NegativeX.index] != null && (tmp = data[CubemapSide.NegativeX.index].getWidth()) > depth) depth = tmp;
+		if (data[CubemapSide.PositiveY.index] != null && (tmp = data[CubemapSide.PositiveY.index].getHeight()) > depth)
+			depth = tmp;
+		if (data[CubemapSide.NegativeY.index] != null && (tmp = data[CubemapSide.NegativeY.index].getHeight()) > depth)
+			depth = tmp;
+		return depth;
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/CubemapData.java b/gdx/src/com/badlogic/gdx/graphics/CubemapData.java
deleted file mode 100644
index dfc86cc..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/CubemapData.java
+++ /dev/null
@@ -1,39 +0,0 @@
-
-package com.badlogic.gdx.graphics;
-
-import com.badlogic.gdx.graphics.Pixmap.Format;
-import com.badlogic.gdx.graphics.glutils.KTXTextureData;
-
-/** Used by a {@link Cubemap} to load the pixel data. The Cubemap will request the CubemapData to prepare itself through
- * {@link #prepare()} and upload its data using {@link #consumeCubemapData()}. These are the first methods to be called by Cubemap.
- * After that the Cubemap will invoke the other methods to find out about the size of the image data, the format, whether the
- * CubemapData is able to manage the pixel data if the OpenGL ES context is lost.</p>
- * 
- * Before a call to either {@link #consumeCubemapData()}, Cubemap will bind the OpenGL ES texture.</p>
- * 
- * Look at {@link KTXTextureData} for example implementation of this interface.
- * @author Vincent Bousquet */
-public interface CubemapData {
-
-	/** @return whether the TextureData is prepared or not. */
-	public boolean isPrepared ();
-
-	/** Prepares the TextureData for a call to {@link #consumeCubemapData()}. This method can be called from a non OpenGL thread and
-	 * should thus not interact with OpenGL. */
-	public void prepare ();
-
-	/** Uploads the pixel data for the 6 faces of the cube to the OpenGL ES texture. The caller must bind an OpenGL ES texture. A
-	 * call to {@link #prepare()} must preceed a call to this method. Any internal data structures created in {@link #prepare()}
-	 * should be disposed of here. */
-	public void consumeCubemapData ();
-
-	/** @return the width of the pixel data */
-	public int getWidth ();
-
-	/** @return the height of the pixel data */
-	public int getHeight ();
-
-	/** @return whether this implementation can cope with a EGL context loss. */
-	public boolean isManaged ();
-
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/GL20.java b/gdx/src/com/badlogic/gdx/graphics/GL20.java
index 17eb49e..073f698 100644
--- a/gdx/src/com/badlogic/gdx/graphics/GL20.java
+++ b/gdx/src/com/badlogic/gdx/graphics/GL20.java
@@ -364,8 +364,6 @@ public interface GL20 {
 	public void glCullFace (int mode);
 
 	public void glDeleteTextures (int n, IntBuffer textures);
-	
-	public void glDeleteTexture (int texture);
 
 	public void glDepthFunc (int func);
 
@@ -388,8 +386,6 @@ public interface GL20 {
 	public void glFrontFace (int mode);
 
 	public void glGenTextures (int n, IntBuffer textures);
-	
-	public int glGenTexture ();
 
 	public int glGetError ();
 
@@ -454,19 +450,13 @@ public interface GL20 {
 	public int glCreateProgram ();
 
 	public int glCreateShader (int type);
-	
-	public void glDeleteBuffer (int buffer);
 
 	public void glDeleteBuffers (int n, IntBuffer buffers);
 
-	public void glDeleteFramebuffer (int framebuffer);
-	
 	public void glDeleteFramebuffers (int n, IntBuffer framebuffers);
 
 	public void glDeleteProgram (int program);
 
-	public void glDeleteRenderbuffer (int renderbuffer);
-	
 	public void glDeleteRenderbuffers (int n, IntBuffer renderbuffers);
 
 	public void glDeleteShader (int shader);
@@ -483,18 +473,12 @@ public interface GL20 {
 
 	public void glFramebufferTexture2D (int target, int attachment, int textarget, int texture, int level);
 
-	public int glGenBuffer ();
-	
 	public void glGenBuffers (int n, IntBuffer buffers);
 
 	public void glGenerateMipmap (int target);
 
-	public int glGenFramebuffer ();
-	
 	public void glGenFramebuffers (int n, IntBuffer framebuffers);
 
-	public int glGenRenderbuffer ();
-	
 	public void glGenRenderbuffers (int n, IntBuffer renderbuffers);
 
 	// deviates
@@ -587,62 +571,40 @@ public interface GL20 {
 	public void glUniform1f (int location, float x);
 
 	public void glUniform1fv (int location, int count, FloatBuffer v);
-	
-	public void glUniform1fv (int location, int count, float v[], int offset);
 
 	public void glUniform1i (int location, int x);
 
 	public void glUniform1iv (int location, int count, IntBuffer v);
-	
-	public void glUniform1iv (int location, int count, int v[], int offset);
 
 	public void glUniform2f (int location, float x, float y);
 
 	public void glUniform2fv (int location, int count, FloatBuffer v);
-	
-	public void glUniform2fv (int location, int count, float v[], int offset);
 
 	public void glUniform2i (int location, int x, int y);
 
 	public void glUniform2iv (int location, int count, IntBuffer v);
-	
-	public void glUniform2iv (int location, int count, int[] v, int offset);
 
 	public void glUniform3f (int location, float x, float y, float z);
 
 	public void glUniform3fv (int location, int count, FloatBuffer v);
-	
-	public void glUniform3fv (int location, int count, float[] v, int offset);
 
 	public void glUniform3i (int location, int x, int y, int z);
 
 	public void glUniform3iv (int location, int count, IntBuffer v);
-	
-	public void glUniform3iv (int location, int count, int v[], int offset);
 
 	public void glUniform4f (int location, float x, float y, float z, float w);
 
 	public void glUniform4fv (int location, int count, FloatBuffer v);
-	
-	public void glUniform4fv (int location, int count, float v[], int offset);
 
 	public void glUniform4i (int location, int x, int y, int z, int w);
 
 	public void glUniform4iv (int location, int count, IntBuffer v);
-	
-	public void glUniform4iv (int location, int count, int v[], int offset);
 
 	public void glUniformMatrix2fv (int location, int count, boolean transpose, FloatBuffer value);
-	
-	public void glUniformMatrix2fv (int location, int count, boolean transpose, float value[], int offset);
 
 	public void glUniformMatrix3fv (int location, int count, boolean transpose, FloatBuffer value);
-	
-	public void glUniformMatrix3fv (int location, int count, boolean transpose, float value[], int offset);
 
 	public void glUniformMatrix4fv (int location, int count, boolean transpose, FloatBuffer value);
-	
-	public void glUniformMatrix4fv (int location, int count, boolean transpose, float value[], int offset);
 
 	public void glUseProgram (int program);
 
@@ -664,6 +626,11 @@ public interface GL20 {
 
 	public void glVertexAttrib4fv (int indx, FloatBuffer values);
 
+	/**
+	 * In OpenGl core profiles (3.1+), passing a pointer to client memory is not valid.
+	 * In 3.0 and later, use the other version of this function instead, pass a zero-based
+	 * offset which references the buffer currently bound to GL_ARRAY_BUFFER.
+	 */
 	public void glVertexAttribPointer (int indx, int size, int type, boolean normalized, int stride, Buffer ptr);
 
 	public void glVertexAttribPointer (int indx, int size, int type, boolean normalized, int stride, int ptr);
diff --git a/gdx/src/com/badlogic/gdx/graphics/GL30.java b/gdx/src/com/badlogic/gdx/graphics/GL30.java
index df17aa8..0a360ee 100644
--- a/gdx/src/com/badlogic/gdx/graphics/GL30.java
+++ b/gdx/src/com/badlogic/gdx/graphics/GL30.java
@@ -19,6 +19,8 @@
 
 package com.badlogic.gdx.graphics;
 
+import java.nio.Buffer;
+
 /** OpenGL ES 3.0 */
 public interface GL30 extends GL20 {
 	public final int GL_READ_BUFFER = 0x0C02;
@@ -1395,4 +1397,12 @@ public interface GL30 extends GL20 {
 // java.nio.IntBuffer params
 // );
 
+	@Override
+	@Deprecated
+	/**
+	 * In OpenGl core profiles (3.1+), passing a pointer to client memory is not valid.
+	 * Use the other version of this function instead, pass a zero-based offset which references
+	 * the buffer currently bound to GL_ARRAY_BUFFER.
+	 */
+	void glVertexAttribPointer(int indx, int size, int type, boolean normalized, int stride, Buffer ptr);
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/GLTexture.java b/gdx/src/com/badlogic/gdx/graphics/GLTexture.java
index 0d27d1f..b7f21b6 100644
--- a/gdx/src/com/badlogic/gdx/graphics/GLTexture.java
+++ b/gdx/src/com/badlogic/gdx/graphics/GLTexture.java
@@ -23,13 +23,22 @@ import com.badlogic.gdx.graphics.Pixmap.Format;
 import com.badlogic.gdx.graphics.Texture.TextureFilter;
 import com.badlogic.gdx.graphics.Texture.TextureWrap;
 import com.badlogic.gdx.graphics.TextureData.TextureDataType;
+import com.badlogic.gdx.graphics.glutils.ETC1TextureData;
+import com.badlogic.gdx.graphics.glutils.FileTextureData;
 import com.badlogic.gdx.graphics.glutils.MipMapGenerator;
+import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.utils.BufferUtils;
 import com.badlogic.gdx.utils.Disposable;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+import java.nio.IntBuffer;
 
 /** Class representing an OpenGL texture by its target and handle. Keeps track of its state like the TextureFilter and TextureWrap.
  * Also provides some (protected) static methods to create TextureData and upload image data.
  * @author badlogic, Xoppa */
 public abstract class GLTexture implements Disposable {
+	private static final IntBuffer buffer = BufferUtils.newIntBuffer(1);
+
 	/** The target of this texture, used when binding the texture, e.g. GL_TEXTURE_2D */
 	public final int glTarget;
 	protected int glHandle;
@@ -49,7 +58,7 @@ public abstract class GLTexture implements Disposable {
 
 	/** Generates a new OpenGL texture with the specified target. */
 	public GLTexture (int glTarget) {
-		this(glTarget, Gdx.gl.glGenTexture ());
+		this(glTarget, createGLHandle());
 	}
 
 	public GLTexture (int glTarget, int glHandle) {
@@ -169,7 +178,10 @@ public abstract class GLTexture implements Disposable {
 	/** Destroys the OpenGL Texture as specified by the glHandle. */
 	protected void delete () {
 		if (glHandle != 0) {
-			Gdx.gl.glDeleteTexture (glHandle);
+			buffer.put(0, glHandle);
+			buffer.position(0);
+			buffer.limit(1);
+			Gdx.gl.glDeleteTextures(1, buffer);
 			glHandle = 0;
 		}
 	}
@@ -179,22 +191,21 @@ public abstract class GLTexture implements Disposable {
 		delete();
 	}
 
-	/** @deprecated Use {@link TextureData.Factory#loadFromFile(FileHandle, Format, boolean)} instead. */
-	@Deprecated
 	protected static TextureData createTextureData (FileHandle file, Format format, boolean useMipMaps) {
-		return TextureData.Factory.loadFromFile(file, format, useMipMaps);
+		if (file == null) return null;
+		if (file.name().endsWith(".etc1")) return new ETC1TextureData(file, useMipMaps);
+		return new FileTextureData(file, null, format, useMipMaps);
 	}
 
-	/** @deprecated Use {@link TextureData.Factory#loadFromFile(FileHandle, boolean)} instead. */
-	@Deprecated
 	protected static TextureData createTextureData (FileHandle file, boolean useMipMaps) {
 		return createTextureData(file, null, useMipMaps);
 	}
 
-	/** @deprecated Use {@link GL20#glGenTexture()} instead. */
-	@Deprecated
 	protected static int createGLHandle () {
-		return Gdx.gl.glGenTexture ();
+		buffer.position(0);
+		buffer.limit(buffer.capacity());
+		Gdx.gl.glGenTextures(1, buffer);
+		return buffer.get(0);
 	}
 	
 	protected static void uploadImageData (int target, TextureData data) {
diff --git a/gdx/src/com/badlogic/gdx/graphics/Mesh.java b/gdx/src/com/badlogic/gdx/graphics/Mesh.java
index 6046f42..b3eec2a 100644
--- a/gdx/src/com/badlogic/gdx/graphics/Mesh.java
+++ b/gdx/src/com/badlogic/gdx/graphics/Mesh.java
@@ -24,15 +24,7 @@ import java.util.Map;
 import com.badlogic.gdx.Application;
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.VertexAttributes.Usage;
-import com.badlogic.gdx.graphics.glutils.IndexArray;
-import com.badlogic.gdx.graphics.glutils.IndexBufferObject;
-import com.badlogic.gdx.graphics.glutils.IndexBufferObjectSubData;
-import com.badlogic.gdx.graphics.glutils.IndexData;
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-import com.badlogic.gdx.graphics.glutils.VertexArray;
-import com.badlogic.gdx.graphics.glutils.VertexBufferObject;
-import com.badlogic.gdx.graphics.glutils.VertexBufferObjectSubData;
-import com.badlogic.gdx.graphics.glutils.VertexData;
+import com.badlogic.gdx.graphics.glutils.*;
 import com.badlogic.gdx.math.Matrix3;
 import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.math.Vector2;
@@ -44,8 +36,8 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
 
 /** <p>
  * A Mesh holds vertices composed of attributes specified by a {@link VertexAttributes} instance. The vertices are held either in
- * VRAM in form of vertex buffer objects or in RAM in form of vertex arrays. The former variant is more performant and is
- * preferred over vertex arrays if hardware supports it.
+ * VRAM in form of vertex buffer objects or in RAM in form of vertex arrays. The former variant is more performant and is preferred
+ * over vertex arrays if hardware supports it.
  * </p>
  * 
  * <p>
@@ -62,10 +54,10 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
  * exactly for this to work.
  * </p>
  * 
- * @author mzechner, Dave Clayton <contact@redskyforge.com>, Xoppa */
+ * @author mzechner, Dave Clayton <contact@redskyforge.com> */
 public class Mesh implements Disposable {
 	public enum VertexDataType {
-		VertexArray, VertexBufferObject, VertexBufferObjectSubData,
+		VertexArray, VertexBufferObject, VertexBufferObjectSubData, VertexBufferObjectWithVAO
 	}
 
 	/** list of all meshes **/
@@ -76,14 +68,6 @@ public class Mesh implements Disposable {
 	boolean autoBind = true;
 	final boolean isVertexArray;
 
-	protected Mesh (VertexData vertices, IndexData indices, boolean isVertexArray) {
-		this.vertices = vertices;
-		this.indices = indices;
-		this.isVertexArray = isVertexArray;
-
-		addManagedMesh(Gdx.app, this);
-	}
-
 	/** Creates a new Mesh with the given attributes.
 	 * 
 	 * @param isStatic whether this mesh is static or not. Allows for internal optimizations.
@@ -92,7 +76,7 @@ public class Mesh implements Disposable {
 	 * @param attributes the {@link VertexAttribute}s. Each vertex attribute defines one property of a vertex such as position,
 	 *           normal or texture coordinate */
 	public Mesh (boolean isStatic, int maxVertices, int maxIndices, VertexAttribute... attributes) {
-		vertices = new VertexBufferObject(isStatic, maxVertices, attributes);
+		vertices = makeVertexBuffer(isStatic, maxVertices, new VertexAttributes(attributes));
 		indices = new IndexBufferObject(isStatic, maxIndices);
 		isVertexArray = false;
 
@@ -107,7 +91,7 @@ public class Mesh implements Disposable {
 	 * @param attributes the {@link VertexAttributes}. Each vertex attribute defines one property of a vertex such as position,
 	 *           normal or texture coordinate */
 	public Mesh (boolean isStatic, int maxVertices, int maxIndices, VertexAttributes attributes) {
-		vertices = new VertexBufferObject(isStatic, maxVertices, attributes);
+		vertices = makeVertexBuffer(isStatic, maxVertices, attributes);
 		indices = new IndexBufferObject(isStatic, maxIndices);
 		isVertexArray = false;
 
@@ -125,13 +109,21 @@ public class Mesh implements Disposable {
 	 * 
 	 * @author Jaroslaw Wisniewski <j.wisniewski@appsisle.com> **/
 	public Mesh (boolean staticVertices, boolean staticIndices, int maxVertices, int maxIndices, VertexAttributes attributes) {
-		vertices = new VertexBufferObject(staticVertices, maxVertices, attributes);
+		vertices = makeVertexBuffer(staticVertices, maxVertices, attributes);
 		indices = new IndexBufferObject(staticIndices, maxIndices);
 		isVertexArray = false;
 
 		addManagedMesh(Gdx.app, this);
 	}
 
+	private VertexData makeVertexBuffer(boolean isStatic, int maxVertices, VertexAttributes vertexAttributes) {
+		if(Gdx.gl30 != null) {
+			return new VertexBufferObjectWithVAO(isStatic, maxVertices, vertexAttributes);
+		} else {
+			return new VertexBufferObject(isStatic, maxVertices, vertexAttributes);
+		}
+	}
+
 	/** Creates a new Mesh with the given attributes. This is an expert method with no error checking. Use at your own risk.
 	 * 
 	 * @param type the {@link VertexDataType} to be used, VBO or VA.
@@ -141,19 +133,30 @@ public class Mesh implements Disposable {
 	 * @param attributes the {@link VertexAttribute}s. Each vertex attribute defines one property of a vertex such as position,
 	 *           normal or texture coordinate */
 	public Mesh (VertexDataType type, boolean isStatic, int maxVertices, int maxIndices, VertexAttribute... attributes) {
-		if (type == VertexDataType.VertexBufferObject) {
-			vertices = new VertexBufferObject(isStatic, maxVertices, attributes);
-			indices = new IndexBufferObject(isStatic, maxIndices);
-			isVertexArray = false;
-		} else if (type == VertexDataType.VertexBufferObjectSubData) {
-			vertices = new VertexBufferObjectSubData(isStatic, maxVertices, attributes);
-			indices = new IndexBufferObjectSubData(isStatic, maxIndices);
-			isVertexArray = false;
-		} else {
-			vertices = new VertexArray(maxVertices, attributes);
-			indices = new IndexArray(maxIndices);
-			isVertexArray = true;
+		switch(type) {
+			case VertexBufferObject:
+				vertices = new VertexBufferObject(isStatic, maxVertices, attributes);
+				indices = new IndexBufferObject(isStatic, maxIndices);
+				isVertexArray = false;
+				break;
+			case VertexBufferObjectSubData:
+				vertices = new VertexBufferObjectSubData(isStatic, maxVertices, attributes);
+				indices = new IndexBufferObjectSubData(isStatic, maxIndices);
+				isVertexArray = false;
+				break;
+			case VertexBufferObjectWithVAO:
+				vertices = new VertexBufferObjectWithVAO(isStatic, maxVertices, attributes);
+				indices = new IndexBufferObjectSubData(isStatic, maxIndices);
+				isVertexArray = false;
+				break;
+			case VertexArray:
+			default:
+				vertices = new VertexArray(maxVertices, attributes);
+				indices = new IndexArray(maxIndices);
+				isVertexArray = true;
+				break;
 		}
+
 		addManagedMesh(Gdx.app, this);
 	}
 
@@ -228,7 +231,8 @@ public class Mesh implements Disposable {
 		meshes[0].getVertices(vertices);
 		meshes[0].getIndices(indices);
 		int vcount = meshes[0].getNumVertices();
-		if (transformations != null) transform(transformations[0], vertices, vertexSize, offset, numComponents, 0, vcount);
+		if (transformations != null)
+			transform(transformations[0], vertices, vertexSize, offset, numComponents, 0, vcount);
 		int voffset = vcount;
 		int ioffset = meshes[0].getNumIndices();
 		for (int i = 1; i < meshes.length; i++) {
@@ -370,35 +374,12 @@ public class Mesh implements Disposable {
 	 * @param indices the array to copy the indices to
 	 * @param destOffset the offset in the indices array to start copying */
 	public void getIndices (short[] indices, int destOffset) {
-		getIndices(0, indices, destOffset);
-	}
-
-	/** Copies the remaining indices from the Mesh to the short array. The short array must be large enough to hold destOffset + all
-	 * the remaining indices.
-	 * @param srcOffset the zero-based offset of the first index to fetch
-	 * @param indices the array to copy the indices to
-	 * @param destOffset the offset in the indices array to start copying */
-	public void getIndices (int srcOffset, short[] indices, int destOffset) {
-		getIndices(srcOffset, -1, indices, destOffset);
-	}
-
-	/** Copies the indices from the Mesh to the short array. The short array must be large enough to hold destOffset + count
-	 * indices.
-	 * @param srcOffset the zero-based offset of the first index to fetch
-	 * @param count the total amount of indices to copy
-	 * @param indices the array to copy the indices to
-	 * @param destOffset the offset in the indices array to start copying */
-	public void getIndices (int srcOffset, int count, short[] indices, int destOffset) {
-		int max = getNumIndices();
-		if (count < 0) count = max - srcOffset;
-		if (srcOffset < 0 || srcOffset >= max || srcOffset + count > max)
-			throw new IllegalArgumentException("Invalid range specified, offset: " + srcOffset + ", count: " + count + ", max: "
-				+ max);
-		if ((indices.length - destOffset) < count)
-			throw new IllegalArgumentException("not enough room in indices array, has " + indices.length + " shorts, needs " + count);
+		if ((indices.length - destOffset) < getNumIndices())
+			throw new IllegalArgumentException("not enough room in indices array, has " + indices.length + " floats, needs "
+				+ getNumIndices());
 		int pos = getIndicesBuffer().position();
-		getIndicesBuffer().position(srcOffset);
-		getIndicesBuffer().get(indices, destOffset, count);
+		getIndicesBuffer().position(0);
+		getIndicesBuffer().get(indices, destOffset, getNumIndices());
 		getIndicesBuffer().position(pos);
 	}
 
@@ -688,9 +669,7 @@ public class Mesh implements Disposable {
 	 * @return the value specified by out. */
 	public BoundingBox extendBoundingBox (final BoundingBox out, int offset, int count, final Matrix4 transform) {
 		int numIndices = getNumIndices();
-		if (offset < 0 || count < 1 || offset + count > numIndices)
-			throw new GdxRuntimeException("Not enough indices ( offset=" + offset + ", count=" + count + ", max=" + numIndices
-				+ " )");
+		if (offset < 0 || count < 1 || offset + count > numIndices) throw new GdxRuntimeException("Not enough indices ( offset="+offset+", count="+count+", max="+numIndices+" )");
 
 		final FloatBuffer verts = vertices.getBuffer();
 		final ShortBuffer index = indices.getBuffer();
@@ -856,7 +835,11 @@ public class Mesh implements Disposable {
 		Array<Mesh> meshesArray = meshes.get(app);
 		if (meshesArray == null) return;
 		for (int i = 0; i < meshesArray.size; i++) {
-			meshesArray.get(i).vertices.invalidate();
+			if (meshesArray.get(i).vertices instanceof VertexBufferObject) {
+				((VertexBufferObject)meshesArray.get(i).vertices).invalidate();
+			} else if(meshesArray.get(i).vertices instanceof VertexBufferObjectWithVAO) {
+				((VertexBufferObjectWithVAO) meshesArray.get(i).vertices).invalidate();
+			}
 			meshesArray.get(i).indices.invalidate();
 		}
 	}
diff --git a/gdx/src/com/badlogic/gdx/graphics/Texture.java b/gdx/src/com/badlogic/gdx/graphics/Texture.java
index aa75aad..8316d98 100644
--- a/gdx/src/com/badlogic/gdx/graphics/Texture.java
+++ b/gdx/src/com/badlogic/gdx/graphics/Texture.java
@@ -24,9 +24,6 @@ import com.badlogic.gdx.assets.loaders.AssetLoader;
 import com.badlogic.gdx.assets.loaders.TextureLoader.TextureParameter;
 import com.badlogic.gdx.files.FileHandle;
 import com.badlogic.gdx.graphics.Pixmap.Format;
-import com.badlogic.gdx.graphics.glutils.ETC1TextureData;
-import com.badlogic.gdx.graphics.glutils.FileTextureData;
-import com.badlogic.gdx.graphics.glutils.KTXTextureData;
 import com.badlogic.gdx.graphics.glutils.PixmapTextureData;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.GdxRuntimeException;
@@ -124,7 +121,7 @@ public class Texture extends GLTexture {
 		load(data);
 		if (data.isManaged()) addManagedTexture(Gdx.app, this);
 	}
-	
+
 	public void load (TextureData data) {
 		if (this.data != null && data.isManaged() != this.data.isManaged())
 			throw new GdxRuntimeException("New data must have the same managed status as the old data");
diff --git a/gdx/src/com/badlogic/gdx/graphics/TextureData.java b/gdx/src/com/badlogic/gdx/graphics/TextureData.java
index 47e04db..8f3c319 100644
--- a/gdx/src/com/badlogic/gdx/graphics/TextureData.java
+++ b/gdx/src/com/badlogic/gdx/graphics/TextureData.java
@@ -16,18 +16,16 @@
 
 package com.badlogic.gdx.graphics;
 
-import com.badlogic.gdx.files.FileHandle;
 import com.badlogic.gdx.graphics.Pixmap.Format;
 import com.badlogic.gdx.graphics.glutils.ETC1TextureData;
 import com.badlogic.gdx.graphics.glutils.FileTextureData;
-import com.badlogic.gdx.graphics.glutils.KTXTextureData;
 import com.badlogic.gdx.graphics.glutils.MipMapGenerator;
 
 /** Used by a {@link Texture} to load the pixel data. A TextureData can either return a {@link Pixmap} or upload the pixel data
  * itself. It signals it's type via {@link #getType()} to the Texture that's using it. The Texture will then either invoke
- * {@link #consumePixmap()} or {@link #consumeCustomData(int)}. These are the first methods to be called by Texture. After that
- * the Texture will invoke the other methods to find out about the size of the image data, the format, whether mipmaps should be
- * generated and whether the TextureData is able to manage the pixel data if the OpenGL ES context is lost.</p>
+ * {@link #consumePixmap()} or {@link #consumeCustomData(int)}. These are the first methods to be called by Texture. After
+ * that the Texture will invoke the other methods to find out about the size of the image data, the format, whether mipmaps should
+ * be generated and whether the TextureData is able to manage the pixel data if the OpenGL ES context is lost.</p>
  * 
  * In case the TextureData implementation has the type {@link TextureDataType#Custom}, the implementation has to generate the
  * mipmaps itself if necessary. See {@link MipMapGenerator}.</p>
@@ -64,7 +62,7 @@ public interface TextureData {
 	public boolean disposePixmap ();
 
 	/** Uploads the pixel data to the OpenGL ES texture. The caller must bind an OpenGL ES texture. A call to {@link #prepare()}
-	 * must preceed a call to this method. Any internal data structures created in {@link #prepare()} should be disposed of here. */
+	 * must preceed a call to this method. Any internal data structures created in {@link #prepare()}. */
 	public void consumeCustomData (int target);
 
 	/** @return the width of the pixel data */
@@ -81,23 +79,4 @@ public interface TextureData {
 
 	/** @return whether this implementation can cope with a EGL context loss. */
 	public boolean isManaged ();
-
-	/** Provides static method to instantiate the right implementation (Pixmap, ETC1, KTX).
-	 * @author Vincent Bousquet */
-	public static class Factory {
-
-		public static TextureData loadFromFile (FileHandle file, boolean useMipMaps) {
-			return loadFromFile(file, null, useMipMaps);
-		}
-
-		public static TextureData loadFromFile (FileHandle file, Format format, boolean useMipMaps) {
-			if (file == null) return null;
-			if (file.name().endsWith(".cim")) return new FileTextureData(file, PixmapIO.readCIM(file), format, useMipMaps);
-			if (file.name().endsWith(".etc1")) return new ETC1TextureData(file, useMipMaps);
-			if (file.name().endsWith(".ktx") || file.name().endsWith(".zktx")) return new KTXTextureData(file, useMipMaps);
-			return new FileTextureData(file, new Pixmap(file), format, useMipMaps);
-		}
-
-	}
-
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/VertexAttributes.java b/gdx/src/com/badlogic/gdx/graphics/VertexAttributes.java
index c36d907..010ea74 100644
--- a/gdx/src/com/badlogic/gdx/graphics/VertexAttributes.java
+++ b/gdx/src/com/badlogic/gdx/graphics/VertexAttributes.java
@@ -19,6 +19,7 @@ package com.badlogic.gdx.graphics;
 import java.util.Iterator;
 import java.util.NoSuchElementException;
 
+import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 
 /** Instances of this class specify the vertex attributes of a mesh. VertexAttributes are used by {@link Mesh} instances to define
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFont.java b/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFont.java
index 866aba7..2400274 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFont.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFont.java
@@ -39,15 +39,15 @@ import com.badlogic.gdx.utils.StreamUtils;
 
 /** Renders bitmap fonts. The font consists of 2 files: an image file or {@link TextureRegion} containing the glyphs and a file in
  * the AngleCode BMFont text format that describes where each glyph is on the image. Currently only a single image of glyphs is
- * supported.
- * <p>
+ * supported.<br>
+ * <br>
  * Text is drawn using a {@link Batch}. Text can be cached in a {@link BitmapFontCache} for faster rendering of static text, which
- * saves needing to compute the location of each glyph each frame.
- * <p>
+ * saves needing to compute the location of each glyph each frame.<br>
+ * <br>
  * * The texture for a BitmapFont loaded from a file is managed. {@link #dispose()} must be called to free the texture when no
  * longer needed. A BitmapFont loaded using a {@link TextureRegion} is managed if the region's texture is managed. Disposing the
- * BitmapFont disposes the region's texture, which may not be desirable if the texture is still being used elsewhere.
- * <p>
+ * BitmapFont disposes the region's texture, which may not be desirable if the texture is still being used elsewhere.<br>
+ * <br>
  * The code was originally based on Matthias Mann's TWL BitmapFont class. Thanks for sharing, Matthias! :)
  * @author Nathan Sweet
  * @author Matthias Mann */
@@ -67,17 +67,16 @@ public class BitmapFont implements Disposable {
 	private boolean integer;
 	private boolean ownsTexture;
 	boolean markupEnabled;
-	private char[] breakChars;
 
 	/** Creates a BitmapFont using the default 15pt Arial font included in the libgdx JAR file. This is convenient to easily display
-	 * text without bothering without generating a bitmap font yourself. */
+	 * text without bothering with generating a bitmap font. */
 	public BitmapFont () {
 		this(Gdx.files.classpath("com/badlogic/gdx/utils/arial-15.fnt"),
 			Gdx.files.classpath("com/badlogic/gdx/utils/arial-15.png"), false, true);
 	}
 
 	/** Creates a BitmapFont using the default 15pt Arial font included in the libgdx JAR file. This is convenient to easily display
-	 * text without bothering without generating a bitmap font yourself.
+	 * text without bothering with generating a bitmap font.
 	 * @param flip If true, the glyphs will be flipped for use with a perspective where 0,0 is the upper left corner. */
 	public BitmapFont (boolean flip) {
 		this(Gdx.files.classpath("com/badlogic/gdx/utils/arial-15.fnt"),
@@ -87,8 +86,9 @@ public class BitmapFont implements Disposable {
 	/** Creates a BitmapFont with the glyphs relative to the specified region. If the region is null, the glyph textures are loaded
 	 * from the image file given in the font file. The {@link #dispose()} method will not dispose the region's texture in this
 	 * case!
-	 * <p>
+	 * 
 	 * The font data is not flipped.
+	 * 
 	 * @param fontFile the font definition file
 	 * @param region The texture region containing the glyphs. The glyphs must be relative to the lower left corner (ie, the region
 	 *           should not be flipped). If the region is null the glyph images are loaded from the image path in the font file. */
@@ -138,10 +138,11 @@ public class BitmapFont implements Disposable {
 	/** Constructs a new BitmapFont from the given {@link BitmapFontData} and {@link TextureRegion}. If the TextureRegion is null,
 	 * the image path(s) will be read from the BitmapFontData. The dispose() method will not dispose the texture of the region(s)
 	 * if the region is != null.
-	 * <p>
+	 * 
 	 * Passing a single TextureRegion assumes that your font only needs a single texture page. If you need to support multiple
 	 * pages, either let the Font read the images themselves (by specifying null as the TextureRegion), or by specifying each page
 	 * manually with the TextureRegion[] constructor.
+	 * 
 	 * @param integer If true, rendering positions will be at integer values to avoid filtering artifacts. */
 	public BitmapFont (BitmapFontData data, TextureRegion region, boolean integer) {
 		this(data, region != null ? new TextureRegion[] {region} : null, integer);
@@ -150,10 +151,11 @@ public class BitmapFont implements Disposable {
 	/** Constructs a new BitmapFont from the given {@link BitmapFontData} and array of {@link TextureRegion}. If the TextureRegion
 	 * is null or empty, the image path(s) will be read from the BitmapFontData. The dispose() method will not dispose the texture
 	 * of the region(s) if the regions array is != null and not empty.
+	 * 
 	 * @param integer If true, rendering positions will be at integer values to avoid filtering artifacts. */
 	public BitmapFont (BitmapFontData data, TextureRegion[] regions, boolean integer) {
 		if (regions == null || regions.length == 0) {
-			// Load each path.
+			// load each path
 			this.regions = new TextureRegion[data.imagePaths.length];
 			for (int i = 0; i < this.regions.length; i++) {
 				if (data.fontFile == null) {
@@ -188,7 +190,7 @@ public class BitmapFont implements Disposable {
 
 				if (region == null) {
 					// TODO: support null regions by parsing scaleW / scaleH ?
-					throw new IllegalArgumentException("BitmapFont texture region array cannot contain null elements.");
+					throw new IllegalArgumentException("BitmapFont texture region array cannot contain null elements");
 				}
 
 				float invTexWidth = 1.0f / region.getTexture().getWidth();
@@ -418,13 +420,17 @@ public class BitmapFont implements Disposable {
 		float maxWidth = 0;
 		while (start < length) {
 			int newLine = BitmapFont.indexOf(str, '\n', start);
+			// Eat whitespace at start of line.
+			while (start < newLine) {
+				if (!BitmapFont.isWhitespace(str.charAt(start))) break;
+				start++;
+			}
 			int lineEnd = start + computeVisibleGlyphs(str, start, newLine, wrapWidth);
 			int nextStart = lineEnd + 1;
 			if (lineEnd < newLine) {
 				// Find char to break on.
 				while (lineEnd > start) {
 					if (BitmapFont.isWhitespace(str.charAt(lineEnd))) break;
-					if (isBreakChar(str.charAt(lineEnd - 1))) break;
 					lineEnd--;
 				}
 				if (lineEnd == start) {
@@ -432,13 +438,6 @@ public class BitmapFont implements Disposable {
 					lineEnd = nextStart; // If no characters to break, show all.
 				} else {
 					nextStart = lineEnd;
-					// Eat whitespace at start of wrapped line.
-					while (nextStart < length) {
-						char c = str.charAt(nextStart);
-						if (!BitmapFont.isWhitespace(c)) break;
-						nextStart++;
-						if (c == '\n') break; // Eat only the first wrapped newline.
-					}
 					// Eat whitespace at end of line.
 					while (lineEnd > start) {
 						if (!BitmapFont.isWhitespace(str.charAt(lineEnd - 1))) break;
@@ -552,14 +551,16 @@ public class BitmapFont implements Disposable {
 		return cache.getColor();
 	}
 
-	/** Scales the font by the specified amounts on both axes
-	 * <p>
+	/** Scales the font by the specified amounts on both axes <br>
+	 * <br>
 	 * Note that smoother scaling can be achieved if the texture backing the BitmapFont is using {@link TextureFilter#Linear}. The
 	 * default is Nearest, so use a BitmapFont constructor that takes a {@link TextureRegion}.
-	 * @throws IllegalArgumentException if scaleX or scaleY is zero. */
+	 * 
+	 * @throws IllegalArgumentException When scaleXY is zero */
 	public void setScale (float scaleX, float scaleY) {
-		if (scaleX == 0) throw new IllegalArgumentException("scaleX cannot be 0.");
-		if (scaleY == 0) throw new IllegalArgumentException("scaleY cannot be 0.");
+		if (scaleX == 0 || scaleY == 0) {
+			throw new IllegalArgumentException("Scale must not be zero");
+		}
 		BitmapFontData data = this.data;
 		float x = scaleX / data.scaleX;
 		float y = scaleY / data.scaleY;
@@ -576,14 +577,14 @@ public class BitmapFont implements Disposable {
 
 	/** Scales the font by the specified amount in both directions.
 	 * @see #setScale(float, float)
-	 * @throws IllegalArgumentException if scaleX or scaleY is zero. */
+	 * @throws IllegalArgumentException When scaleXY is zero */
 	public void setScale (float scaleXY) {
 		setScale(scaleXY, scaleXY);
 	}
 
 	/** Sets the font's scale relative to the current scale.
 	 * @see #setScale(float, float)
-	 * @throws IllegalArgumentException if the resulting scale is zero. */
+	 * @throws IllegalArgumentException When resulting scale is zero */
 	public void scale (float amount) {
 		setScale(data.scaleX + amount, data.scaleY + amount);
 	}
@@ -596,7 +597,7 @@ public class BitmapFont implements Disposable {
 		return data.scaleY;
 	}
 
-	/** Returns the first texture region. This is included for backwards compatibility, and for convenience since most fonts only
+	/** Returns the first texture region. This is included for backwards-compatibility, and for convenience since most fonts only
 	 * use one texture page. For multi-page fonts, use getRegions().
 	 * @return the first texture region */
 	// TODO: deprecate?
@@ -730,10 +731,7 @@ public class BitmapFont implements Disposable {
 	}
 
 	public String toString () {
-		if (data.fontFile != null) {
-			return data.fontFile.nameWithoutExtension();
-		}
-		return super.toString();
+		return data.fontFile.nameWithoutExtension();
 	}
 
 	/** Represents a single character in a font page. */
@@ -773,19 +771,6 @@ public class BitmapFont implements Disposable {
 		return n;
 	}
 
-	/** Provide any additional characters that should act as break characters when the label is wrapped. By default, only whitespace
-	 * characters act as break chars. */
-	public void setBreakChars (char[] breakChars) {
-		this.breakChars = breakChars;
-	}
-
-	public boolean isBreakChar (char c) {
-		if (breakChars == null) return false;
-		for (char br : breakChars)
-			if (c == br) return true;
-		return false;
-	}
-
 	static boolean isWhitespace (char c) {
 		switch (c) {
 		case '\n':
@@ -823,11 +808,11 @@ public class BitmapFont implements Disposable {
 
 	/** Backing data for a {@link BitmapFont}. */
 	public static class BitmapFontData {
-		/** The first image path.
-		 * @deprecated Use imagePaths[0]. */
+		/** The first discovered image path; included for backwards-compatibility This is the same as imagePaths[0].
+		 * @deprecated use imagePaths[0] instead */
 		@Deprecated public String imagePath;
 
-		/** An array of the image paths, for multiple texture pages. */
+		/** An array of the image paths, i.e. for multiple texture pages */
 		public String[] imagePaths;
 		public FileHandle fontFile;
 		public boolean flipped;
@@ -842,7 +827,7 @@ public class BitmapFont implements Disposable {
 		public float spaceWidth;
 		public float xHeight = 1;
 
-		/** Use this if you want to create BitmapFontData yourself, e.g. from stb-truetype or FreeType. */
+		/** Use this if you want to create BitmapFontData yourself, e.g. from stb-truetype of FreeType. */
 		public BitmapFontData () {
 		}
 
@@ -855,55 +840,60 @@ public class BitmapFont implements Disposable {
 				reader.readLine(); // info
 
 				String line = reader.readLine();
-				if (line == null) throw new GdxRuntimeException("File is empty.");
-				String[] common = line.split(" ", 7); // At most we want the 6th element; i.e. "page=N"
+				if (line == null) throw new GdxRuntimeException("Invalid font file: " + fontFile);
+				String[] common = line.split(" ", 7); // we want the 6th element to be in tact; i.e. "page=N"
 
-				// At least lineHeight and base are required.
-				if (common.length < 3) throw new GdxRuntimeException("Invalid header.");
+				// we only really NEED lineHeight and base
+				if (common.length < 3) throw new GdxRuntimeException("Invalid font file: " + fontFile);
 
-				if (!common[1].startsWith("lineHeight=")) throw new GdxRuntimeException("Missing: lineHeight");
+				if (!common[1].startsWith("lineHeight=")) throw new GdxRuntimeException("Invalid font file: " + fontFile);
 				lineHeight = Integer.parseInt(common[1].substring(11));
 
-				if (!common[2].startsWith("base=")) throw new GdxRuntimeException("Missing: base");
+				if (!common[2].startsWith("base=")) throw new GdxRuntimeException("Invalid font file: " + fontFile);
 				float baseLine = Integer.parseInt(common[2].substring(5));
 
-				int pageCount = 1;
+				// parse the pages count
+				int imgPageCount = 1;
 				if (common.length >= 6 && common[5] != null && common[5].startsWith("pages=")) {
 					try {
-						pageCount = Math.max(1, Integer.parseInt(common[5].substring(6)));
-					} catch (NumberFormatException ignored) { // Use one page.
+						imgPageCount = Math.max(1, Integer.parseInt(common[5].substring(6)));
+					} catch (NumberFormatException e) {
+						// just ignore and only use one page...
+						// somebody must have tampered with the page count >:(
 					}
 				}
 
-				imagePaths = new String[pageCount];
+				imagePaths = new String[imgPageCount];
 
-				// Read each page definition.
-				for (int p = 0; p < pageCount; p++) {
-					// Read each "page" info line.
+				// read each page definition
+				for (int p = 0; p < imgPageCount; p++) {
+					// read each "page" info line
 					line = reader.readLine();
-					if (line == null) throw new GdxRuntimeException("Missing additional page definitions.");
+					if (line == null) throw new GdxRuntimeException("Expected more 'page' definitions in font file " + fontFile);
 					String[] pageLine = line.split(" ", 4);
-					if (!pageLine[2].startsWith("file=")) throw new GdxRuntimeException("Missing: file");
+					if (!pageLine[2].startsWith("file=")) throw new GdxRuntimeException("Invalid font file: " + fontFile);
 
-					// Expect ID to mean "index".
+					// we will expect ID to mean "index" -- if for some reason this is not the case, it will fuck everything up
+					// so we need to warn the user that their BMFont output is bogus
 					if (pageLine[1].startsWith("id=")) {
 						try {
 							int pageID = Integer.parseInt(pageLine[1].substring(3));
 							if (pageID != p)
-								throw new GdxRuntimeException("Page IDs must be indices starting at 0: " + pageLine[1].substring(3));
-						} catch (NumberFormatException ex) {
-							throw new GdxRuntimeException("Invalid page id: " + pageLine[1].substring(3), ex);
+								throw new GdxRuntimeException("Invalid font file: " + fontFile
+									+ " -- page ids must be indices starting at 0");
+						} catch (NumberFormatException e) {
+							throw new GdxRuntimeException("NumberFormatException on 'page id' element of " + fontFile);
 						}
 					}
 
-					String fileName = null;
+					String imgFilename = null;
 					if (pageLine[2].endsWith("\"")) {
-						fileName = pageLine[2].substring(6, pageLine[2].length() - 1);
+						imgFilename = pageLine[2].substring(6, pageLine[2].length() - 1);
 					} else {
-						fileName = pageLine[2].substring(5, pageLine[2].length());
+						imgFilename = pageLine[2].substring(5, pageLine[2].length());
 					}
 
-					String path = fontFile.parent().child(fileName).path().replaceAll("\\\\", "/");
+					String path = fontFile.parent().child(imgFilename).path().replaceAll("\\\\", "/");
 					if (this.imagePath == null) this.imagePath = path;
 					imagePaths[p] = path;
 				}
@@ -912,7 +902,7 @@ public class BitmapFont implements Disposable {
 				while (true) {
 					line = reader.readLine();
 					if (line == null) break; // EOF
-					if (line.startsWith("kernings ")) break; // Starting kernings block.
+					if (line.startsWith("kernings ")) break; // Starting kernings block
 					if (!line.startsWith("char ")) continue;
 
 					Glyph glyph = new Glyph();
@@ -944,12 +934,13 @@ public class BitmapFont implements Disposable {
 					tokens.nextToken();
 					glyph.xadvance = Integer.parseInt(tokens.nextToken());
 
-					// Check for page safely, it could be omitted or invalid.
+					// also check for page.. a little safer here since we don't want to break any old functionality
+					// and since maybe some shitty BMFont tools won't bother writing page id??
 					if (tokens.hasMoreTokens()) tokens.nextToken();
 					if (tokens.hasMoreTokens()) {
 						try {
 							glyph.page = Integer.parseInt(tokens.nextToken());
-						} catch (NumberFormatException ignored) {
+						} catch (NumberFormatException e) {
 						}
 					}
 
@@ -971,7 +962,8 @@ public class BitmapFont implements Disposable {
 					Glyph glyph = getGlyph((char)first);
 					tokens.nextToken();
 					int amount = Integer.parseInt(tokens.nextToken());
-					if (glyph != null) { // Kernings may exist for glyph pairs not contained in the font.
+					if (glyph != null) { // it appears BMFont outputs kerning for glyph pairs not contained in the font, hence the null
+// check
 						glyph.setKerning(second, amount);
 					}
 				}
@@ -1024,12 +1016,6 @@ public class BitmapFont implements Disposable {
 			}
 		}
 
-		/** Sets the line height, which is the distance from one line of text to the next. */
-		public void setLineHeight (float height) {
-			lineHeight = height * scaleY;
-			down = flipped ? lineHeight : -lineHeight;
-		}
-
 		public void setGlyph (int ch, Glyph glyph) {
 			Glyph[] page = glyphs[ch / PAGE_SIZE];
 			if (page == null) glyphs[ch / PAGE_SIZE] = page = new Glyph[PAGE_SIZE];
@@ -1044,7 +1030,7 @@ public class BitmapFont implements Disposable {
 					return glyph;
 				}
 			}
-			throw new GdxRuntimeException("No glyphs found.");
+			throw new GdxRuntimeException("No glyphs found!");
 		}
 
 		/** Returns the glyph for the specified character, or null if no such glyph exists. */
@@ -1054,14 +1040,17 @@ public class BitmapFont implements Disposable {
 			return null;
 		}
 
-		/** Returns the first image path.
-		 * @deprecated Use {@link #getImagePath(int)}. */
+		/** Returns the first image path; included for backwards-compatibility. Use getImagePath(int) instead.
+		 * @return the first image path in the array
+		 * @deprecated use getImagePath(int index) instead */
 		@Deprecated
 		public String getImagePath () {
 			return imagePath;
 		}
 
-		/** Returns the image path for the texture page at the given index (the "id" in the BMFont file). */
+		/** Returns the image path for the texture page at the given index.
+		 * @param index the index of the page, AKA the "id" in the BMFont file
+		 * @return the texture page */
 		public String getImagePath (int index) {
 			return imagePaths[index];
 		}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java b/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java
index 94d6e4b..62fe276 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java
@@ -17,25 +17,38 @@
 package com.badlogic.gdx.graphics.g2d;
 
 import com.badlogic.gdx.graphics.Color;
+import com.badlogic.gdx.graphics.Colors;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.BitmapFontData;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.Glyph;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.HAlignment;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.TextBounds;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.GdxRuntimeException;
 import com.badlogic.gdx.utils.IntArray;
 import com.badlogic.gdx.utils.NumberUtils;
+import com.badlogic.gdx.utils.Pool;
+import com.badlogic.gdx.utils.Pool.Poolable;
+import com.badlogic.gdx.utils.StringBuilder;
 
 /** Caches glyph geometry for a BitmapFont, providing a fast way to render static text. This saves needing to compute the location
  * of each glyph each frame.
  * @author Nathan Sweet
  * @author Matthias Mann
- * @author davebaol
- * @author Alexander Dorokhov */
+ * @author davebaol */
 public class BitmapFontCache {
 
 	private final BitmapFont font;
 
 	private float[][] vertexData;
 
+	private static final Pool<ColorChunk> colorChunkPool = new Pool<ColorChunk>(32) {
+		protected ColorChunk newObject () {
+			return new ColorChunk();
+		}
+	};
+
+	private Array<ColorChunk> colorChunks;
+
 	private int[] idx;
 	/** Used internally to ensure a correct capacity for multi-page font vertex data. */
 	private int[] tmpGlyphCount;
@@ -43,6 +56,8 @@ public class BitmapFontCache {
 	private float x, y;
 	private float color = Color.WHITE.toFloatBits();
 	private final Color tempColor = new Color(1, 1, 1, 1);
+	private final Color hexColor = new Color();
+	private final StringBuilder colorBuffer = new StringBuilder();
 	private final TextBounds textBounds = new TextBounds();
 	private boolean integer = true;
 	private int glyphCount = 0;
@@ -53,29 +68,30 @@ public class BitmapFontCache {
 
 	private boolean textChanged;
 	private float oldTint = 0;
-
-	private TextMarkup markup = new TextMarkup();
-
-	private int charsCount;
+	private final Color currentChunkColor = new Color();
+	private int currentChunkEndIndex = 0;
 
 	public BitmapFontCache (BitmapFont font) {
 		this(font, font.usesIntegerPositions());
 	}
 
-	/** @param integer If true, rendering positions will be at integer values to avoid filtering artifacts. */
+	/** Creates a new BitmapFontCache
+	 * @param font the font to use
+	 * @param integer whether to use integer positions and sizes. */
 	public BitmapFontCache (BitmapFont font, boolean integer) {
 		this.font = font;
 		this.integer = integer;
 
 		int regionsLength = font.regions.length;
-		if (regionsLength == 0) throw new IllegalArgumentException("The specified font must contain at least one texture page.");
+		if (regionsLength == 0) throw new IllegalArgumentException("The specified font must contain at least 1 texture page");
 
 		this.vertexData = new float[regionsLength][];
+		this.colorChunks = new Array<ColorChunk>();
 
 		this.idx = new int[regionsLength];
 		int vertexDataLength = vertexData.length;
-		if (vertexDataLength > 1) { // If we have multiple pages...
-			// Contains the indices of the glyph in the Cache as they are added.
+		if (vertexDataLength > 1) { // if we have multiple pages...
+			// contains the indices of the glyph in the Cache as they are added
 			glyphIndices = new IntArray[vertexDataLength];
 			for (int i = 0, n = glyphIndices.length; i < n; i++) {
 				glyphIndices[i] = new IntArray();
@@ -122,32 +138,51 @@ public class BitmapFontCache {
 		return color;
 	}
 
+	private int updateCurrentChunk (int lastChunkIndex, Color tint) {
+		lastChunkIndex++;
+		if (colorChunks.size <= lastChunkIndex) {
+			if (colorChunks.size <= 0) currentChunkColor.set(tint);
+			currentChunkEndIndex = Integer.MAX_VALUE;
+		} else {
+			ColorChunk cc = colorChunks.get(lastChunkIndex);
+			if (currentChunkEndIndex == cc.endIndex)
+				lastChunkIndex = updateCurrentChunk(lastChunkIndex, tint);
+			else {
+				setColor(currentChunkColor, cc.color).mul(tint);
+				currentChunkEndIndex = cc.endIndex;
+			}
+		}
+		return lastChunkIndex;
+	}
+
 	/** Tints all text currently in the cache. Does not affect subsequently added text. */
 	public void tint (Color tint) {
-		final float floatTint = tint.toFloatBits();
+		float floatTint = tint.toFloatBits();
 		if (textChanged || oldTint != floatTint) {
 			textChanged = false;
 			oldTint = floatTint;
-			markup.tint(this, tint);
-		}
-	}
-
-	/** Sets the alpha component of all text currently in the cache. Does not affect subsequently added text. */
-	public void setAlphas (float alpha) {
-		int alphaBits = ((int)(254 * alpha)) << 24;
-		float prev = 0, newColor = 0;
-		for (int j = 0, length = vertexData.length; j < length; j++) {
-			float[] vertices = vertexData[j];
-			for (int i = 2, n = idx[j]; i < n; i += 5) {
-				float c = vertices[i];
-				if (c == prev && i != 2) {
-					vertices[i] = newColor;
-				} else {
-					prev = c;
-					int rgba = NumberUtils.floatToIntColor(c);
-					rgba = (rgba & 0x00FFFFFF) | alphaBits;
-					newColor = NumberUtils.intToFloatColor(rgba);
-					vertices[i] = newColor;
+			if (font.markupEnabled) {
+				int lastChunkIndex = updateCurrentChunk(-1, tint);
+				float color = currentChunkColor.toFloatBits();
+				int ci = 0; // character index
+				for (int j = 0, length = vertexData.length; j < length; j++) {
+					float[] vertices = vertexData[j];
+					for (int i = 2, n = idx[j]; i < n; i += 5) {
+						if ((i % 20) == 2) {
+							if (++ci > currentChunkEndIndex) {
+								lastChunkIndex = updateCurrentChunk(lastChunkIndex, tint);
+								color = currentChunkColor.toFloatBits();
+							}
+						}
+						vertices[i] = color;
+					}
+				}
+			} else {
+				for (int j = 0, length = vertexData.length; j < length; j++) {
+					float[] vertices = vertexData[j];
+					for (int i = 2, n = idx[j]; i < n; i += 5) {
+						vertices[i] = floatTint;
+					}
 				}
 			}
 		}
@@ -186,12 +221,8 @@ public class BitmapFontCache {
 	/** Sets the color of the specified characters. This may only be called after {@link #setText(CharSequence, float, float)} and
 	 * is reset every time setText is called. */
 	public void setColors (Color tint, int start, int end) {
-		setColors(tint.toFloatBits(), start, end);
-	}
+		final float color = tint.toFloatBits();
 
-	/** Sets the color of the specified characters. This may only be called after {@link #setText(CharSequence, float, float)} and
-	 * is reset every time setText is called. */
-	public void setColors (float color, int start, int end) {
 		if (vertexData.length == 1) { // only one page...
 			float[] vertices = vertexData[0];
 			for (int i = start * 20 + 2, n = end * 20; i < n; i += 5)
@@ -225,20 +256,17 @@ public class BitmapFontCache {
 	/** Sets the color of subsequently added text. Does not affect text currently in the cache. */
 	public void setColor (Color tint) {
 		color = tint.toFloatBits();
-		markup.setDefaultChunk(tint, charsCount);
 	}
 
 	/** Sets the color of subsequently added text. Does not affect text currently in the cache. */
 	public void setColor (float r, float g, float b, float a) {
 		int intBits = (int)(255 * a) << 24 | (int)(255 * b) << 16 | (int)(255 * g) << 8 | (int)(255 * r);
 		color = NumberUtils.intToFloatColor(intBits);
-		markup.setDefaultChunk(intBits, charsCount);
 	}
 
 	/** Sets the color of subsequently added text. Does not affect text currently in the cache. */
 	public void setColor (float color) {
 		this.color = color;
-		markup.setDefaultChunk(color, charsCount);
 	}
 
 	public Color getColor () {
@@ -325,32 +353,34 @@ public class BitmapFontCache {
 		x = 0;
 		y = 0;
 		glyphCount = 0;
-		charsCount = 0;
-		markup.clear();
 		for (int i = 0, n = idx.length; i < n; i++) {
 			if (glyphIndices != null) glyphIndices[i].clear();
 			idx[i] = 0;
 		}
+
+		// Remove all the color chunks from the list and releases them to the internal pool
+		for (int i = 0; i < colorChunks.size; i++) {
+			colorChunkPool.free(colorChunks.get(i));
+			colorChunks.set(i, null);
+		}
+		colorChunks.size = 0;
 	}
 
 	/** Counts the actual glyphs excluding characters used to markup the text. */
 	private int countGlyphs (CharSequence seq, int start, int end) {
 		int count = end - start;
-		if (font.markupEnabled) {
-			while (start < end) {
-				char ch = seq.charAt(start++);
-				if (ch == '[') {
-					if (start < end && seq.charAt(start) == '[') { // escaped '['
+		while (start < end) {
+			char ch = seq.charAt(start++);
+			if (ch == '[') {
+				count--;
+				if (!(start < end && seq.charAt(start) == '[')) { // non escaped '['
+					while (start < end && seq.charAt(start) != ']') {
 						start++;
 						count--;
-					} else { // non escaped '['
-						int colorTagLen = markup.parseColorTag(seq, -1, start, end);
-						if (colorTagLen >= 0) {
-							start += colorTagLen + 1;
-							count -= colorTagLen + 2;
-						}
 					}
+					count--;
 				}
+				start++;
 			}
 		}
 		return count;
@@ -359,7 +389,7 @@ public class BitmapFontCache {
 	private void requireSequence (CharSequence seq, int start, int end) {
 		if (vertexData.length == 1) {
 			// don't scan sequence if we just have one page and markup is disabled
-			int newGlyphCount = countGlyphs(seq, start, end);
+			int newGlyphCount = font.markupEnabled ? countGlyphs(seq, start, end) : end - start;
 			require(0, newGlyphCount);
 		} else {
 			for (int i = 0, n = tmpGlyphCount.length; i < n; i++)
@@ -370,11 +400,10 @@ public class BitmapFontCache {
 				char ch = seq.charAt(start++);
 				if (ch == '[' && font.markupEnabled) {
 					if (!(start < end && seq.charAt(start) == '[')) { // non escaped '['
-						int colorTagLen = markup.parseColorTag(seq, -1, start, end);
-						if (colorTagLen >= 0) {
-							start += colorTagLen + 1;
-							continue;
-						}
+						while (start < end && seq.charAt(start) != ']')
+							start++;
+						start++;
+						continue;
 					}
 					start++;
 				}
@@ -405,26 +434,99 @@ public class BitmapFontCache {
 		}
 	}
 
+	private int parseAndSetColor (CharSequence str, int start, int end) {
+		if (start < end) {
+			if (str.charAt(start) == '#') {
+				// Parse hex color RRGGBBAA where AA is optional and defaults to 0xFF if less than 6 chars are used
+				int colorInt = 0;
+				for (int i = start + 1; i < end; i++) {
+					char ch = str.charAt(i);
+					if (ch == ']') {
+						if (i < start + 2 || i > start + 9)
+							throw new GdxRuntimeException("Hex color cannot have " + (i - start - 1) + " digits");
+						if (i <= start + 7) { // RRGGBB
+							Color.rgb888ToColor(hexColor, colorInt);
+							hexColor.a = 1f;
+						} else { // RRGGBBAA
+							Color.rgba8888ToColor(hexColor, colorInt);
+						}
+						this.color = hexColor.toFloatBits();
+						addColorChunk(this.color, false);
+						return i - start;
+					}
+					if (ch >= '0' && ch <= '9')
+						colorInt = colorInt * 16 + (ch - '0');
+					else if (ch >= 'a' && ch <= 'f')
+						colorInt = colorInt * 16 + (ch - ('a' - 10));
+					else if (ch >= 'A' && ch <= 'F')
+						colorInt = colorInt * 16 + (ch - ('A' - 10));
+					else
+						throw new GdxRuntimeException("Unexpected '" + ch + "' in hex color");
+				}
+			} else {
+				// Parse named color
+				colorBuffer.setLength(0);
+				for (int i = start; i < end; i++) {
+					char ch = str.charAt(i);
+					if (ch == ']') {
+						if (colorBuffer.length() == 0) { // end tag []
+							int popIndex = Math.max(0, colorChunks.peek().popIndex);
+							this.color = colorChunks.get(popIndex).color;
+							addColorChunk(this.color, true);
+						} else {
+							String colorString = colorBuffer.toString();
+							Color newColor = Colors.get(colorString);
+							if (newColor == null) throw new GdxRuntimeException("Unknown color '" + colorString + "'");
+							this.color = newColor.toFloatBits();
+							addColorChunk(this.color, false);
+						}
+						return i - start;
+					} else {
+						colorBuffer.append(ch);
+					}
+				}
+			}
+		}
+		throw new GdxRuntimeException("Unclosed color tag");
+	}
+
+	private void addColorChunk (float color, boolean isPop) {
+		int popIndex = -1;
+		if (colorChunks.size > 0) {
+			ColorChunk last = colorChunks.peek();
+			last.endIndex = (glyphIndices != null ? glyphCount : this.idx[0] / 20);
+			if (isPop)
+				popIndex = colorChunks.get(Math.max(0, last.popIndex)).popIndex;
+			else
+				popIndex = colorChunks.size - 1;
+		}
+		colorChunks.add(obtainColorChunk(color, popIndex));
+	}
+
+	private ColorChunk obtainColorChunk (float color, int popIndex) {
+		// Get a color chunk from the pool
+		ColorChunk colorChunk = colorChunkPool.obtain();
+		colorChunk.color = color;
+		colorChunk.popIndex = popIndex;
+		return colorChunk;
+	}
+
 	private float addToCache (CharSequence str, float x, float y, int start, int end) {
 		float startX = x;
 		BitmapFont font = this.font;
 		Glyph lastGlyph = null;
 		BitmapFontData data = font.data;
 		textChanged = start < end;
+		if (font.markupEnabled && colorChunks.size == 0) colorChunks.add(obtainColorChunk(this.color, -1));
 		if (data.scaleX == 1 && data.scaleY == 1) {
 			while (start < end) {
 				char ch = str.charAt(start++);
 				if (ch == '[' && font.markupEnabled) {
-					if (start < end && str.charAt(start) == '[') // escaped '['
-						start++;
-					else { // non escaped '['
-						int colorTagLen = markup.parseColorTag(str, charsCount, start, end);
-						if (colorTagLen >= 0) {
-							color = markup.getLastColor().toFloatBits();
-							start += colorTagLen + 1;
-							continue;
-						}
+					if (!(start < end && str.charAt(start) == '[')) { // non escaped '['
+						start += parseAndSetColor(str, start, end) + 1;
+						continue;
 					}
+					start++;
 				}
 				lastGlyph = data.getGlyph(ch);
 				if (lastGlyph != null) {
@@ -436,16 +538,11 @@ public class BitmapFontCache {
 			while (start < end) {
 				char ch = str.charAt(start++);
 				if (ch == '[' && font.markupEnabled) {
-					if (start < end && str.charAt(start) == '[') // escaped '['
-						start++;
-					else { // non escaped '['
-						int colorTagLen = markup.parseColorTag(str, charsCount, start, end);
-						if (colorTagLen >= 0) {
-							color = markup.getLastColor().toFloatBits();
-							start += colorTagLen + 1;
-							continue;
-						}
+					if (!(start < end && str.charAt(start) == '[')) { // non escaped '['
+						start += parseAndSetColor(str, start, end) + 1;
+						continue;
 					}
+					start++;
 				}
 				Glyph g = data.getGlyph(ch);
 				if (g != null) {
@@ -460,16 +557,11 @@ public class BitmapFontCache {
 			while (start < end) {
 				char ch = str.charAt(start++);
 				if (ch == '[' && font.markupEnabled) {
-					if (start < end && str.charAt(start) == '[') // escaped '['
-						start++;
-					else { // non escaped '['
-						int colorTagLen = markup.parseColorTag(str, charsCount, start, end);
-						if (colorTagLen >= 0) {
-							color = markup.getLastColor().toFloatBits();
-							start += colorTagLen + 1;
-							continue;
-						}
+					if (!(start < end && str.charAt(start) == '[')) { // non escaped '['
+						start += parseAndSetColor(str, start, end) + 1;
+						continue;
 					}
+					start++;
 				}
 				lastGlyph = data.getGlyph(ch);
 				if (lastGlyph != null) {
@@ -485,16 +577,11 @@ public class BitmapFontCache {
 			while (start < end) {
 				char ch = str.charAt(start++);
 				if (ch == '[' && font.markupEnabled) {
-					if (start < end && str.charAt(start) == '[') // escaped '['
-						start++;
-					else { // non escaped '['
-						int colorTagLen = markup.parseColorTag(str, charsCount, start, end);
-						if (colorTagLen >= 0) {
-							color = markup.getLastColor().toFloatBits();
-							start += colorTagLen + 1;
-							continue;
-						}
+					if (!(start < end && str.charAt(start) == '[')) { // non escaped '['
+						start += parseAndSetColor(str, start, end) + 1;
+						continue;
 					}
+					start++;
 				}
 				Glyph g = data.getGlyph(ch);
 				if (g != null) {
@@ -561,8 +648,6 @@ public class BitmapFontCache {
 		vertices[idx++] = color;
 		vertices[idx++] = u2;
 		vertices[idx] = v;
-
-		charsCount++;
 	}
 
 	/** Clears any cached glyphs and adds glyphs for the specified text.
@@ -699,13 +784,17 @@ public class BitmapFontCache {
 		int numLines = 0;
 		while (start < length) {
 			int newLine = BitmapFont.indexOf(str, '\n', start);
+			// Eat whitespace at start of line.
+			while (start < newLine) {
+				if (!BitmapFont.isWhitespace(str.charAt(start))) break;
+				start++;
+			}
 			int lineEnd = start + font.computeVisibleGlyphs(str, start, newLine, wrapWidth);
 			int nextStart = lineEnd + 1;
 			if (lineEnd < newLine) {
 				// Find char to break on.
 				while (lineEnd > start) {
 					if (BitmapFont.isWhitespace(str.charAt(lineEnd))) break;
-					if (font.isBreakChar(str.charAt(lineEnd - 1))) break;
 					lineEnd--;
 				}
 				if (lineEnd == start) {
@@ -713,13 +802,6 @@ public class BitmapFontCache {
 					lineEnd = nextStart; // If no characters to break, show all.
 				} else {
 					nextStart = lineEnd;
-					// Eat whitespace at start of wrapped line.
-					while (nextStart < length) {
-						char c = str.charAt(nextStart);
-						if (!BitmapFont.isWhitespace(c)) break;
-						nextStart++;
-						if (c == '\n') break; // Eat only the first wrapped newline.
-					}
 					// Eat whitespace at end of line.
 					while (lineEnd > start) {
 						if (!BitmapFont.isWhitespace(str.charAt(lineEnd - 1))) break;
@@ -746,12 +828,6 @@ public class BitmapFontCache {
 		return textBounds;
 	}
 
-	/** Provide any additional characters that should act as break characters when the label is wrapped. By default, only whitespace
-	 * characters act as break chars. */
-	public void setBreakChars (char[] breakChars) {
-		font.setBreakChars(breakChars);
-	}
-
 	/** Returns the size of the cached string. The height is the distance from the top of most capital letters in the font (the
 	 * {@link BitmapFont#getCapHeight() cap height}) to the baseline of the last line of text. */
 	public TextBounds getBounds () {
@@ -791,8 +867,26 @@ public class BitmapFontCache {
 		return vertexData[page];
 	}
 
-	/** Count of characters currently being in cache */
-	public int getCharsCount () {
-		return charsCount;
+	private static class ColorChunk implements Poolable {
+		float color;
+		int endIndex;
+		int popIndex; // needed to emulate the color stack
+
+		ColorChunk () {
+			this.endIndex = Integer.MAX_VALUE;
+		}
+
+		ColorChunk (float color, int popIndex) {
+			this.color = color;
+			this.endIndex = Integer.MAX_VALUE;
+			this.popIndex = popIndex;
+		}
+
+		@Override
+		public void reset () {
+			this.color = 0f;
+			this.endIndex = Integer.MAX_VALUE;
+			this.popIndex = 0;
+		}
 	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/CpuSpriteBatch.java b/gdx/src/com/badlogic/gdx/graphics/g2d/CpuSpriteBatch.java
index e975289..690cf29 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/CpuSpriteBatch.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/CpuSpriteBatch.java
@@ -57,27 +57,24 @@ public class CpuSpriteBatch extends SpriteBatch {
 		super(size, defaultShader);
 	}
 
-	/** <p>
-	 * Flushes the batch and realigns the real matrix on the GPU. Subsequent draws won't need adjustment and will be slightly
+	/** Finishes off rendering and realigns the real matrix on the GPU. */
+	@Override
+	public void end () {
+		super.end();
+		flushAndSyncTransformMatrix();
+	}
+
+	/** Flushes the batch and realigns the real matrix on the GPU. Subsequent draws won't need adjustment and will be slightly
 	 * faster as long as the transform matrix is not {@link #setTransformMatrix(Matrix4) changed}.
-	 * </p>
-	 * <p>
-	 * Note: The real transform matrix <em>must</em> be invertible. If a singular matrix is detected, GdxRuntimeException will be
-	 * thrown.
-	 * </p>
 	 * @see SpriteBatch#flush() */
 	public void flushAndSyncTransformMatrix () {
 		flush();
 
 		if (adjustNeeded) {
-			// vertices flushed, safe now to replace matrix
-			haveIdentityRealMatrix = checkIdt(virtualMatrix);
-
-			if (!haveIdentityRealMatrix && virtualMatrix.det() == 0)
-				throw new GdxRuntimeException("Transform matrix is singular, can't sync");
-
+			// done rendering, safe now to replace matrix
 			adjustNeeded = false;
 			super.setTransformMatrix(virtualMatrix);
+			haveIdentityRealMatrix = checkIdt(virtualMatrix);
 		}
 	}
 
@@ -89,7 +86,7 @@ public class CpuSpriteBatch extends SpriteBatch {
 	/** Sets the transform matrix to be used by this Batch. Even if this is called inside a {@link #begin()}/{@link #end()} block,
 	 * the current batch is <em>not</em> flushed to the GPU. Instead, for every subsequent draw() the vertices will be transformed
 	 * on the CPU to match the original batch matrix. This adjustment must be performed until the matrices are realigned by
-	 * restoring the original matrix, or by calling {@link #flushAndSyncTransformMatrix()}. */
+	 * restoring the original matrix, or by calling {@link #flushAndSyncTransformMatrix()} or {@link #end()}. */
 	@Override
 	public void setTransformMatrix (Matrix4 transform) {
 		Matrix4 realMatrix = super.getTransformMatrix();
@@ -593,8 +590,6 @@ public class CpuSpriteBatch extends SpriteBatch {
 	}
 
 	private void drawAdjusted (Texture texture, float[] spriteVertices, int offset, int count) {
-		if (!drawing) throw new IllegalStateException("CpuSpriteBatch.begin must be called before draw.");
-
 		if (texture != lastTexture) switchTexture(texture);
 
 		Affine2 t = adjustAffine;
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleEmitter.java b/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleEmitter.java
index 3bd7017..7b4b012 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleEmitter.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleEmitter.java
@@ -1253,12 +1253,10 @@ public class ParticleEmitter {
 			this.timeline = timeline;
 		}
 
-		/** @return the r, g and b values for every timeline position */
 		public float[] getColors () {
 			return colors;
 		}
 
-		/** @param colors the r, g and b values for every timeline position */
 		public void setColors (float[] colors) {
 			this.colors = colors;
 		}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/PixmapPacker.java b/gdx/src/com/badlogic/gdx/graphics/g2d/PixmapPacker.java
index 14be55e..2a5ec96 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/PixmapPacker.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/PixmapPacker.java
@@ -16,15 +16,9 @@
 
 package com.badlogic.gdx.graphics.g2d;
 
-import java.io.IOException;
-import java.io.Writer;
-
-import com.badlogic.gdx.files.FileHandle;
 import com.badlogic.gdx.graphics.Pixmap;
 import com.badlogic.gdx.graphics.Pixmap.Blending;
 import com.badlogic.gdx.graphics.Pixmap.Format;
-import com.badlogic.gdx.graphics.PixmapIO;
-import com.badlogic.gdx.graphics.PixmapIO.PNG;
 import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.graphics.Texture.TextureFilter;
 import com.badlogic.gdx.graphics.glutils.PixmapTextureData;
@@ -383,6 +377,7 @@ public class PixmapPacker implements Disposable {
 						atlas.addRegion(name, region);
 					}
 					page.addedRects.clear();
+					return;
 				}
 			}
 		}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/PixmapPackerIO.java b/gdx/src/com/badlogic/gdx/graphics/g2d/PixmapPackerIO.java
deleted file mode 100644
index f5059bb..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/PixmapPackerIO.java
+++ /dev/null
@@ -1,97 +0,0 @@
-package com.badlogic.gdx.graphics.g2d;
-
-import java.io.IOException;
-import java.io.Writer;
-
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.PixmapIO;
-import com.badlogic.gdx.graphics.PixmapIO.PNG;
-import com.badlogic.gdx.graphics.Texture.TextureFilter;
-import com.badlogic.gdx.graphics.g2d.PixmapPacker.Page;
-import com.badlogic.gdx.math.Rectangle;
-
-/** Saves PixmapPackers to files.
- * @author jshapcott */
-public class PixmapPackerIO {
-
-	/** Image formats which can be used when saving a PixmapPacker. */
-	public static enum ImageFormat {
-		/** A simple compressed image format which is libgdx specific. */
-		CIM(".cim"),
-		/** A standard compressed image format which is not libgdx specific. */
-		PNG(".png");
-		
-		private final String extension;
-		
-		/** Returns the file extension for the image format. */
-		public String getExtension() {
-			return extension;
-		}
-		
-		ImageFormat(String extension) {
-			this.extension = extension;
-		}
-	}
-	
-	/** Additional parameters which will be used when writing a PixmapPacker. */
-	public static class SaveParameters {
-		ImageFormat format = ImageFormat.PNG;
-		TextureFilter minFilter = TextureFilter.Nearest;
-		TextureFilter magFilter = TextureFilter.Nearest;
-	}
-
-	/** Saves the provided PixmapPacker to the provided file. The resulting file will use the standard TextureAtlas file format and
-	 * can be loaded by TextureAtlas as if it had been created using TexturePacker. Default {@link SaveParameters} will be used.
-	 * 
-	 * @param file the file to which the atlas descriptor will be written, images will be written as siblings
-	 * @param packer the PixmapPacker to be written
-	 * @throws IOException if the atlas file can not be written */
-	public void save (FileHandle file, PixmapPacker packer) throws IOException {
-		save(file, packer, new SaveParameters());
-	}
-	
-	/** Saves the provided PixmapPacker to the provided file. The resulting file will use the standard TextureAtlas file format and
-	 * can be loaded by TextureAtlas as if it had been created using TexturePacker.
-	 * 
-	 * @param file the file to which the atlas descriptor will be written, images will be written as siblings
-	 * @param packer the PixmapPacker to be written
-	 * @param parameters the SaveParameters specifying how to save the PixmapPacker
-	 * @throws IOException if the atlas file can not be written */	
-	public void save (FileHandle file, PixmapPacker packer, SaveParameters parameters) throws IOException {
-		Writer writer = file.writer(false);
-		int index = 0;
-		for (Page page : packer.pages) {
-			if (page.rects.size > 0) {
-				FileHandle pageFile = file.sibling(file.nameWithoutExtension() + "_" + (++index) + parameters.format.getExtension());
-				switch (parameters.format) {
-					case CIM:{
-						PixmapIO.writeCIM(pageFile, page.image);
-						break;
-					}
-					case PNG: {
-						PixmapIO.writePNG(pageFile, page.image);
-						break;
-					}
-				}
-				writer.write("\n");
-				writer.write(pageFile.name() + "\n");
-				writer.write("size: " + page.image.getWidth() + "," + page.image.getHeight() + "\n");
-				writer.write("format: " + packer.pageFormat.name()  + "\n");
-				writer.write("filter: " + parameters.minFilter.name() + "," + parameters.magFilter.name() + "\n");
-				writer.write("repeat: none" + "\n");
-				for (String name : page.rects.keys()) {
-					writer.write(name + "\n");
-					Rectangle rect = page.rects.get(name);
-					writer.write("rotate: false" + "\n");
-					writer.write("xy: " + (int) rect.x + "," + (int) rect.y + "\n");
-					writer.write("size: " + (int) rect.width + "," + (int) rect.height + "\n");
-					writer.write("orig: " + (int) rect.width + "," + (int) rect.height + "\n");
-					writer.write("offset: 0, 0" + "\n");
-					writer.write("index: -1" + "\n");
-				}
-			}
-		}		
-		writer.close();
-	}
-	
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/PolygonRegionLoader.java b/gdx/src/com/badlogic/gdx/graphics/g2d/PolygonRegionLoader.java
index 4ca8d29..ec720f0 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/PolygonRegionLoader.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/PolygonRegionLoader.java
@@ -48,8 +48,7 @@ public class PolygonRegionLoader extends SynchronousAssetLoader<PolygonRegion, P
 		public int readerBuffer = 1024;
 
 		/** the possible file name extensions of the texture file */
-		public String[] textureExtensions = new String[] {"png", "PNG", "jpeg", "JPEG", "jpg", "JPG", "cim", "CIM", "etc1", "ETC1",
-			"ktx", "KTX", "zktx", "ZKTX"};
+		public String[] textureExtensions = new String[] {"png", "PNG", "jpeg", "JPEG", "jpg", "JPG", "cim", "CIM", "etc1", "ETC1"};
 
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/PolygonSpriteBatch.java b/gdx/src/com/badlogic/gdx/graphics/g2d/PolygonSpriteBatch.java
index b507332..94ed08f 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/PolygonSpriteBatch.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/PolygonSpriteBatch.java
@@ -114,7 +114,11 @@ public class PolygonSpriteBatch implements Batch {
 		// 32767 is max index, so 32767 / 3 - (32767 / 3 % 3) = 10920.
 		if (size > 10920) throw new IllegalArgumentException("Can't have more than 10920 triangles per batch: " + size);
 
-		mesh = new Mesh(VertexDataType.VertexArray, false, size, size * 3, new VertexAttribute(Usage.Position, 2,
+		Mesh.VertexDataType vertexDataType = Mesh.VertexDataType.VertexArray;
+		if (Gdx.gl30 != null) {
+			vertexDataType = VertexDataType.VertexBufferObjectWithVAO;
+		}
+		mesh = new Mesh(vertexDataType, false, size, size * 3, new VertexAttribute(Usage.Position, 2,
 			ShaderProgram.POSITION_ATTRIBUTE), new VertexAttribute(Usage.ColorPacked, 4, ShaderProgram.COLOR_ATTRIBUTE),
 			new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + "0"));
 
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/Sprite.java b/gdx/src/com/badlogic/gdx/graphics/g2d/Sprite.java
index 8f9d272..5ae4edf 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/Sprite.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/Sprite.java
@@ -207,7 +207,7 @@ public class Sprite extends TextureRegion {
 		setX(x - width / 2);
 	}
 	
-	/** Sets the y position so that it is centered on the given y parameter */
+	/** Sets the y position so that it is centered on the given x parameter */
 	public void setCenterY(float y){
 		setY(y - height / 2);
 	}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteBatch.java b/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteBatch.java
index fa945a3..ec32603 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteBatch.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteBatch.java
@@ -92,7 +92,11 @@ public class SpriteBatch implements Batch {
 		// 32767 is max index, so 32767 / 6 - (32767 / 6 % 3) = 5460.
 		if (size > 5460) throw new IllegalArgumentException("Can't have more than 5460 sprites per batch: " + size);
 
-		mesh = new Mesh(VertexDataType.VertexArray, false, size * 4, size * 6, new VertexAttribute(Usage.Position, 2,
+		Mesh.VertexDataType vertexDataType = Mesh.VertexDataType.VertexArray;
+		if (Gdx.gl30 != null) {
+			vertexDataType = Mesh.VertexDataType.VertexBufferObjectWithVAO;
+		}
+		mesh = new Mesh(vertexDataType, false, size * 4, size * 6, new VertexAttribute(Usage.Position, 2,
 			ShaderProgram.POSITION_ATTRIBUTE), new VertexAttribute(Usage.ColorPacked, 4, ShaderProgram.COLOR_ATTRIBUTE),
 			new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + "0"));
 
@@ -132,7 +136,7 @@ public class SpriteBatch implements Batch {
 			+ "void main()\n" //
 			+ "{\n" //
 			+ "   v_color = " + ShaderProgram.COLOR_ATTRIBUTE + ";\n" //
-			+ "   v_color.a = v_color.a * (255.0/254.0);\n" //
+			+ "   v_color.a = v_color.a * (256.0/255.0);\n" //
 			+ "   v_texCoords = " + ShaderProgram.TEXCOORD_ATTRIBUTE + "0;\n" //
 			+ "   gl_Position =  u_projTrans * " + ShaderProgram.POSITION_ATTRIBUTE + ";\n" //
 			+ "}\n";
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteCache.java b/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteCache.java
index 92c1252..d44b14d 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteCache.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteCache.java
@@ -983,7 +983,7 @@ public class SpriteCache implements Disposable {
 			+ "void main()\n" //
 			+ "{\n" //
 			+ "   v_color = " + ShaderProgram.COLOR_ATTRIBUTE + ";\n" //
-			+ "   v_color.a = v_color.a * (255.0/254.0);\n" //
+			+ "   v_color.a = v_color.a * (256.0/255.0);\n" //
 			+ "   v_texCoords = " + ShaderProgram.TEXCOORD_ATTRIBUTE + "0;\n" //
 			+ "   gl_Position =  u_projectionViewMatrix * " + ShaderProgram.POSITION_ATTRIBUTE + ";\n" //
 			+ "}\n";
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/TextMarkup.java b/gdx/src/com/badlogic/gdx/graphics/g2d/TextMarkup.java
deleted file mode 100644
index cdf0dae..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/TextMarkup.java
+++ /dev/null
@@ -1,202 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g2d;
-
-import com.badlogic.gdx.Application;
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.graphics.Color;
-import com.badlogic.gdx.graphics.Colors;
-import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.NumberUtils;
-import com.badlogic.gdx.utils.Pool;
-import com.badlogic.gdx.utils.StringBuilder;
-
-/** @see com.badlogic.gdx.graphics.g2d.BitmapFontCache
- *
- * @author davebaol
- * @author Alexander Dorokhov */
-class TextMarkup {
-	private static final Color tempColor = new Color();
-	private static final StringBuilder tempColorBuffer = new StringBuilder();
-
-	/** Parses a color tag.
-	 * @param str the input string
-	 * @param nomarkupStart the index of the string, excluding characters used to markup the text, where color info will be added.
-	 *           if it's negative color info is not set.
-	 * @param start the begin index
-	 * @param end the end index
-	 * @return the number of characters in the tag; {@code -1} in case of unknown color. */
-	public int parseColorTag (CharSequence str, int nomarkupStart, int start, int end) {
-		if (start < end) {
-			final Color hexColor = tempColor;
-			if (str.charAt(start) == '#') {
-				// Parse hex color RRGGBBAA where AA is optional and defaults to 0xFF if less than 6 chars are used
-				int colorInt = 0;
-				for (int i = start + 1; i < end; i++) {
-					char ch = str.charAt(i);
-					if (ch == ']') {
-						if (i < start + 2 || i > start + 9) return -1; // Illegal number of hex digits
-						if (i <= start + 7) { // RRGGBB
-							Color.rgb888ToColor(hexColor, colorInt);
-							hexColor.a = 1f;
-						} else { // RRGGBBAA
-							Color.rgba8888ToColor(hexColor, colorInt);
-						}
-						if (nomarkupStart >= 0) beginChunk(hexColor, nomarkupStart);
-						return i - start;
-					}
-					if (ch >= '0' && ch <= '9')
-						colorInt = colorInt * 16 + (ch - '0');
-					else if (ch >= 'a' && ch <= 'f')
-						colorInt = colorInt * 16 + (ch - ('a' - 10));
-					else if (ch >= 'A' && ch <= 'F')
-						colorInt = colorInt * 16 + (ch - ('A' - 10));
-					else
-						return -1; // Unexpected character in hex color
-				}
-			} else {
-				// Parse named color
-				tempColorBuffer.setLength(0);
-				for (int i = start; i < end; i++) {
-					char ch = str.charAt(i);
-					if (ch == ']') {
-						if (i == start) { // end tag []
-							if (nomarkupStart >= 0) endChunk(nomarkupStart);
-						} else {
-							String colorString = tempColorBuffer.toString();
-							Color newColor = Colors.get(colorString);
-							if (newColor == null) return -1; // Unknown color
-							if (nomarkupStart >= 0) beginChunk(newColor, nomarkupStart);
-						}
-						return i - start;
-					} else {
-						tempColorBuffer.append(ch);
-					}
-				}
-			}
-		}
-		return -1; // Unclosed color tag
-	}
-
-	private static Pool<ColorChunk> colorChunkPool;
-	private static Application app = null;
-
-	private Array<ColorChunk> colorChunks = new Array<ColorChunk>();
-	private Array<Color> currentColorStack = new Array<Color>();
-	private Color lastColor = Color.WHITE;
-	private Color defaultColor = Color.WHITE;
-
-	public TextMarkup () {
-		if (Gdx.app != app) {
-			colorChunkPool = new Pool<ColorChunk>(32) {
-				protected ColorChunk newObject () {
-					return new ColorChunk();
-				}
-			};
-			app = Gdx.app;
-		}
-	}
-
-	public void beginChunk (Color color, int start) {
-		ColorChunk newChunk = colorChunkPool.obtain();
-		newChunk.color.set(color);
-		newChunk.start = start;
-		colorChunks.add(newChunk);
-		currentColorStack.add(lastColor);
-		lastColor = newChunk.color;
-	}
-
-	public void endChunk (int start) {
-		if (currentColorStack.size > 0) {
-			lastColor = currentColorStack.pop();
-			ColorChunk newChunk = colorChunkPool.obtain();
-			newChunk.color.set(lastColor);
-			newChunk.start = start;
-			colorChunks.add(newChunk);
-		}
-	}
-
-	public void tint (BitmapFontCache cache, Color tint) {
-		int current = 0;
-		float floatColor = tempColor.set(defaultColor).mul(tint).toFloatBits();
-		for (ColorChunk chunk : colorChunks) {
-			int next = chunk.start;
-			if (current < next) {
-				cache.setColors(floatColor, current, next);
-				current = next;
-			}
-			floatColor = tempColor.set(chunk.color).mul(tint).toFloatBits();
-		}
-		int charsCount = cache.getCharsCount();
-		if (current < charsCount) {
-			cache.setColors(floatColor, current, charsCount);
-		}
-	}
-
-	/** Removes all the color chunks from the list and releases them to the internal pool */
-	public void clear () {
-		final int size = colorChunks.size;
-		for (int i = 0; i < size; i++) {
-			colorChunkPool.free(colorChunks.get(i));
-			colorChunks.set(i, null);
-		}
-		colorChunks.size = 0;
-		currentColorStack.clear();
-		setDefaultChunk(defaultColor, 0);
-	}
-
-	public Color getLastColor () {
-		return lastColor;
-	}
-
-	private void setDefaultColor (Color defaultColor) {
-		if (currentColorStack.size == 0) {
-			this.defaultColor = defaultColor;
-			this.lastColor = defaultColor;
-		}
-	}
-
-	public void setDefaultChunk (float color, int start) {
-		int abgr = NumberUtils.floatToIntColor(color);
-		setDefaultChunk(abgr, start);
-	}
-
-	public void setDefaultChunk (int abgr, int start) {
-		ColorChunk newChunk = colorChunkPool.obtain();
-		Color color = newChunk.color;
-		color.r = (abgr & 0xff) / 255f;
-		color.g = ((abgr >>> 8) & 0xff) / 255f;
-		color.b = ((abgr >>> 16) & 0xff) / 255f;
-		color.a = ((abgr >>> 24) & 0xff) / 255f;
-		newChunk.start = start;
-		colorChunks.add(newChunk);
-		setDefaultColor(newChunk.color);
-	}
-
-	public void setDefaultChunk (Color color, int start) {
-		ColorChunk newChunk = colorChunkPool.obtain();
-		newChunk.color.set(color);
-		newChunk.start = start;
-		colorChunks.add(newChunk);
-		setDefaultColor(newChunk.color);
-	}
-
-	public static class ColorChunk {
-		public int start;
-		public final Color color = new Color();
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/TextureRegion.java b/gdx/src/com/badlogic/gdx/graphics/g2d/TextureRegion.java
index 1186bdf..195b029 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/TextureRegion.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/TextureRegion.java
@@ -185,11 +185,7 @@ public class TextureRegion {
 	}
 
 	public void setRegionWidth (int width) {
-		if (isFlipX()) {
-			setU(u2 + width / (float)texture.getWidth());
-		} else {
-			setU2(u + width / (float)texture.getWidth());
-		}
+		setU2(u + width / (float)texture.getWidth());
 	}
 
 	/** Returns the region's height. */
@@ -198,11 +194,7 @@ public class TextureRegion {
 	}
 
 	public void setRegionHeight (int height) {
-		if (isFlipY()) {
-			setV(v2 + height / (float)texture.getHeight());			
-		} else {
-			setV2(v + height / (float)texture.getHeight());
-		}
+		setV2(v + height / (float)texture.getHeight());
 	}
 
 	public void flip (boolean x, boolean y) {
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/Model.java b/gdx/src/com/badlogic/gdx/graphics/g3d/Model.java
index 3a90ad1..d0db411 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/Model.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/Model.java
@@ -137,7 +137,7 @@ public class Model implements Disposable {
 	private void loadNodes (Iterable<ModelNode> modelNodes) {
 		nodePartBones.clear();
 		for (ModelNode node : modelNodes) {
-			nodes.add(loadNode(node));
+			nodes.add(loadNode(null, node));
 		}
 		for (ObjectMap.Entry<NodePart, ArrayMap<String, Matrix4>> e : nodePartBones.entries()) {
 			if (e.key.invBoneBindTransforms == null)
@@ -148,9 +148,10 @@ public class Model implements Disposable {
 		}
 	}
 
-	private Node loadNode (ModelNode modelNode) {
+	private Node loadNode (Node parent, ModelNode modelNode) {
 		Node node = new Node();
 		node.id = modelNode.id;
+		node.parent = parent;
 
 		if (modelNode.translation != null) node.translation.set(modelNode.translation);
 		if (modelNode.rotation != null) node.rotation.set(modelNode.rotation);
@@ -193,7 +194,7 @@ public class Model implements Disposable {
 
 		if (modelNode.children != null) {
 			for (ModelNode child : modelNode.children) {
-				node.addChild(loadNode(child));
+				node.children.add(loadNode(node, child));
 			}
 		}
 
@@ -272,10 +273,10 @@ public class Model implements Disposable {
 				descriptor.uWrap = texture.getUWrap();
 				descriptor.vWrap = texture.getVWrap();
 				
-				float offsetU = tex.uvTranslation == null ? 0f : tex.uvTranslation.x;
-				float offsetV = tex.uvTranslation == null ? 0f : tex.uvTranslation.y;
-				float scaleU = tex.uvScaling == null ? 1f : tex.uvScaling.x;
-				float scaleV = tex.uvScaling == null ? 1f : tex.uvScaling.y;
+				float offsetU = tex.uvTranslation.x;
+				float offsetV = tex.uvTranslation.y;
+				float scaleU = tex.uvScaling.x;
+				float scaleV = tex.uvScaling.y;
 				
 				switch (tex.usage) {
 				case ModelTexture.USAGE_DIFFUSE:
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/ModelInstance.java b/gdx/src/com/badlogic/gdx/graphics/g3d/ModelInstance.java
index 8040c89..96169ff 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/ModelInstance.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/ModelInstance.java
@@ -16,17 +16,20 @@
 
 package com.badlogic.gdx.graphics.g3d;
 
+import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.g3d.model.Animation;
 import com.badlogic.gdx.graphics.g3d.model.MeshPart;
-import com.badlogic.gdx.graphics.g3d.model.Node;
 import com.badlogic.gdx.graphics.g3d.model.NodeAnimation;
 import com.badlogic.gdx.graphics.g3d.model.NodeKeyframe;
 import com.badlogic.gdx.graphics.g3d.model.NodePart;
+import com.badlogic.gdx.graphics.g3d.model.Node;
 import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.math.Vector3;
 import com.badlogic.gdx.math.collision.BoundingBox;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.ArrayMap;
+import com.badlogic.gdx.utils.Disposable;
+import com.badlogic.gdx.utils.GdxRuntimeException;
 import com.badlogic.gdx.utils.ObjectMap;
 import com.badlogic.gdx.utils.Pool;
 
@@ -38,10 +41,6 @@ import com.badlogic.gdx.utils.Pool;
  * The ModelInstance creates a full copy of all materials, nodes and animations.
  * @author badlogic, xoppa */
 public class ModelInstance implements RenderableProvider {
-	/** Whether, by default, {@link NodeKeyframe}'s are shared amongst {@link Model} and ModelInstance. Can be overridden per
-	 * ModelInstance using the constructor argument. */
-	public static boolean defaultShareKeyframes = true;
-
 	/** the materials of the model, used by nodes that have a graphical representation FIXME not sure if superfluous, allows
 	 * modification of materials without having to traverse the nodes **/
 	public final Array<Material> materials = new Array();
@@ -115,30 +114,19 @@ public class ModelInstance implements RenderableProvider {
 	 * @param mergeTransform True to apply the source node transform to the instance transform, resetting the node transform. */
 	public ModelInstance (final Model model, final Matrix4 transform, final String nodeId, boolean recursive,
 		boolean parentTransform, boolean mergeTransform) {
-		this(model, transform, nodeId, recursive, parentTransform, mergeTransform, defaultShareKeyframes);
-	}
-	
-	/** @param model The source {@link Model}
-	 * @param transform The {@link Matrix4} instance for this ModelInstance to reference or null to create a new matrix.
-	 * @param nodeId The ID of the {@link Node} within the {@link Model} for the instance to contain
-	 * @param recursive True to recursively search the Model's node tree, false to only search for a root node
-	 * @param parentTransform True to apply the parent's node transform to the instance (only applicable if recursive is true).
-	 * @param mergeTransform True to apply the source node transform to the instance transform, resetting the node transform. */
-	public ModelInstance (final Model model, final Matrix4 transform, final String nodeId, boolean recursive,
-		boolean parentTransform, boolean mergeTransform, boolean shareKeyframes) {
 		this.model = model;
 		this.transform = transform == null ? new Matrix4() : transform;
 		nodePartBones.clear();
 		Node copy, node = model.getNode(nodeId, recursive);
-		this.nodes.add(copy = copyNode(node));
+		this.nodes.add(copy = copyNode(null, node));
 		if (mergeTransform) {
 			this.transform.mul(parentTransform ? node.globalTransform : node.localTransform);
 			copy.translation.set(0, 0, 0);
 			copy.rotation.idt();
 			copy.scale.set(1, 1, 1);
-		} else if (parentTransform && copy.hasParent()) this.transform.mul(node.getParent().globalTransform);
+		} else if (parentTransform && copy.parent != null) this.transform.mul(node.parent.globalTransform);
 		setBones();
-		copyAnimations(model.animations, shareKeyframes);
+		copyAnimations(model.animations);
 		calculateTransforms();
 	}
 
@@ -155,7 +143,7 @@ public class ModelInstance implements RenderableProvider {
 			copyNodes(model.nodes);
 		else
 			copyNodes(model.nodes, rootNodeIds);
-		copyAnimations(model.animations, defaultShareKeyframes);
+		copyAnimations(model.animations);
 		calculateTransforms();
 	}
 
@@ -166,15 +154,10 @@ public class ModelInstance implements RenderableProvider {
 
 	/** Constructs a new ModelInstance with only the specified nodes and materials of the given model. */
 	public ModelInstance (final Model model, final Matrix4 transform, final Array<String> rootNodeIds) {
-		this(model, transform, rootNodeIds, defaultShareKeyframes);
-	}
-		
-	/** Constructs a new ModelInstance with only the specified nodes and materials of the given model. */
-	public ModelInstance (final Model model, final Matrix4 transform, final Array<String> rootNodeIds, boolean shareKeyframes) {
 		this.model = model;
 		this.transform = transform == null ? new Matrix4() : transform;
 		copyNodes(model.nodes, rootNodeIds);
-		copyAnimations(model.animations, shareKeyframes);
+		copyAnimations(model.animations);
 		calculateTransforms();
 	}
 
@@ -202,15 +185,10 @@ public class ModelInstance implements RenderableProvider {
 
 	/** Constructs a new ModelInstance which is an copy of the specified ModelInstance. */
 	public ModelInstance (ModelInstance copyFrom, final Matrix4 transform) {
-		this(copyFrom, transform, defaultShareKeyframes);
-	}
-	
-	/** Constructs a new ModelInstance which is an copy of the specified ModelInstance. */
-	public ModelInstance (ModelInstance copyFrom, final Matrix4 transform, boolean shareKeyframes) {
 		this.model = copyFrom.model;
 		this.transform = transform == null ? new Matrix4() : transform;
 		copyNodes(copyFrom.nodes);
-		copyAnimations(copyFrom.animations, shareKeyframes);
+		copyAnimations(copyFrom.animations);
 		calculateTransforms();
 	}
 
@@ -225,7 +203,7 @@ public class ModelInstance implements RenderableProvider {
 		nodePartBones.clear();
 		for (int i = 0, n = nodes.size; i < n; ++i) {
 			final Node node = nodes.get(i);
-			this.nodes.add(copyNode(node));
+			this.nodes.add(copyNode(null, node));
 		}
 		setBones();
 	}
@@ -236,7 +214,7 @@ public class ModelInstance implements RenderableProvider {
 			final Node node = nodes.get(i);
 			for (final String nodeId : nodeIds) {
 				if (nodeId.equals(node.id)) {
-					this.nodes.add(copyNode(node));
+					this.nodes.add(copyNode(null, node));
 					break;
 				}
 			}
@@ -250,7 +228,7 @@ public class ModelInstance implements RenderableProvider {
 			final Node node = nodes.get(i);
 			for (final String nodeId : nodeIds) {
 				if (nodeId.equals(node.id)) {
-					this.nodes.add(copyNode(node));
+					this.nodes.add(copyNode(null, node));
 					break;
 				}
 			}
@@ -273,10 +251,11 @@ public class ModelInstance implements RenderableProvider {
 		}
 	}
 
-	private Node copyNode (Node node) {
+	private Node copyNode (Node parent, Node node) {
 		Node copy = new Node();
 		copy.id = node.id;
-		copy.inheritTransform = node.inheritTransform;
+		// copy.boneId = node.boneId;
+		copy.parent = parent;
 		copy.translation.set(node.translation);
 		copy.rotation.set(node.rotation);
 		copy.scale.set(node.scale);
@@ -285,8 +264,8 @@ public class ModelInstance implements RenderableProvider {
 		for (NodePart nodePart : node.parts) {
 			copy.parts.add(copyNodePart(nodePart));
 		}
-		for (Node child : node.getChildren()) {
-			copy.addChild(copyNode(child));
+		for (Node child : node.children) {
+			copy.children.add(copyNode(copy, child));
 		}
 		return copy;
 	}
@@ -311,7 +290,7 @@ public class ModelInstance implements RenderableProvider {
 		return copy;
 	}
 
-	private void copyAnimations (final Iterable<Animation> source, boolean shareKeyframes) {
+	private void copyAnimations (final Iterable<Animation> source) {
 		for (final Animation anim : source) {
 			Animation animation = new Animation();
 			animation.id = anim.id;
@@ -321,18 +300,13 @@ public class ModelInstance implements RenderableProvider {
 				if (node == null) continue;
 				NodeAnimation nodeAnim = new NodeAnimation();
 				nodeAnim.node = node;
-				if (shareKeyframes)
-					nodeAnim.keyframes = nanim.keyframes;
-				else {
-					for (final NodeKeyframe kf : nanim.keyframes) {
-						
-						NodeKeyframe keyframe = new NodeKeyframe();
-						keyframe.keytime = kf.keytime;
-						keyframe.rotation.set(kf.rotation);
-						keyframe.scale.set(kf.scale);
-						keyframe.translation.set(kf.translation);
-						nodeAnim.keyframes.add(keyframe);
-					}
+				for (final NodeKeyframe kf : nanim.keyframes) {
+					NodeKeyframe keyframe = new NodeKeyframe();
+					keyframe.keytime = kf.keytime;
+					keyframe.rotation.set(kf.rotation);
+					keyframe.scale.set(kf.scale);
+					keyframe.translation.set(kf.translation);
+					nodeAnim.keyframes.add(keyframe);
 				}
 				if (nodeAnim.keyframes.size > 0) animation.nodeAnimations.add(nodeAnim);
 			}
@@ -380,7 +354,7 @@ public class ModelInstance implements RenderableProvider {
 			}
 		}
 
-		for (Node child : node.getChildren()) {
+		for (Node child : node.children) {
 			getRenderables(child, renderables, pool);
 		}
 	}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/CubemapAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/CubemapAttribute.java
index 8033bf4..ab8eb09 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/CubemapAttribute.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/CubemapAttribute.java
@@ -17,7 +17,7 @@
 package com.badlogic.gdx.graphics.g3d.attributes;
 
 import com.badlogic.gdx.graphics.Cubemap;
-import com.badlogic.gdx.graphics.GLTexture;
+import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.graphics.g3d.Attribute;
 import com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor;
 import com.badlogic.gdx.utils.GdxRuntimeException;
@@ -67,6 +67,6 @@ public class CubemapAttribute extends Attribute {
 	public int hashCode () {
 		int result = super.hashCode();
 		result = 967 * result + textureDescription.hashCode();
-		return result;
+		return result; 
 	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/decals/DecalBatch.java b/gdx/src/com/badlogic/gdx/graphics/g3d/decals/DecalBatch.java
index 94df4c7..86a02b7 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/decals/DecalBatch.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/decals/DecalBatch.java
@@ -16,6 +16,7 @@
 
 package com.badlogic.gdx.graphics.g3d.decals;
 
+import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.Mesh;
 import com.badlogic.gdx.graphics.VertexAttribute;
@@ -86,10 +87,15 @@ public class DecalBatch implements Disposable {
 	 * @param size Maximum size of decal objects to hold in memory */
 	public void initialize (int size) {
 		vertices = new float[size * Decal.SIZE];
-		mesh = new Mesh(Mesh.VertexDataType.VertexArray, false, size * 4, size * 6, new VertexAttribute(
-			VertexAttributes.Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE), new VertexAttribute(
-			VertexAttributes.Usage.ColorPacked, 4, ShaderProgram.COLOR_ATTRIBUTE), new VertexAttribute(
-			VertexAttributes.Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + "0"));
+
+		Mesh.VertexDataType vertexDataType = Mesh.VertexDataType.VertexArray;
+		if(Gdx.gl30 != null) {
+			vertexDataType = Mesh.VertexDataType.VertexBufferObjectWithVAO;
+		}
+		mesh = new Mesh(vertexDataType, false, size * 4, size * 6, new VertexAttribute(
+				VertexAttributes.Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE), new VertexAttribute(
+				VertexAttributes.Usage.ColorPacked, 4, ShaderProgram.COLOR_ATTRIBUTE), new VertexAttribute(
+				VertexAttributes.Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + "0"));
 
 		short[] indices = new short[size * 6];
 		int v = 0;
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loader/G3dModelLoader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loader/G3dModelLoader.java
index 9fc0bb4..ad80991 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loader/G3dModelLoader.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/loader/G3dModelLoader.java
@@ -98,7 +98,7 @@ public class G3dModelLoader extends ModelLoader<ModelLoader.ModelParameters> {
 				for (JsonValue meshPart = meshParts.child; meshPart != null; meshPart = meshPart.next) {
 					ModelMeshPart jsonPart = new ModelMeshPart();
 					String partId = meshPart.getString("id", null);
-					if (partId == null) {
+					if (id == null) {
 						throw new GdxRuntimeException("Not id given for mesh part");
 					}
 					for (ModelMeshPart other : parts) {
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/Node.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/Node.java
index 410f489..5d51d05 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/Node.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/model/Node.java
@@ -23,7 +23,6 @@ import com.badlogic.gdx.math.Quaternion;
 import com.badlogic.gdx.math.Vector3;
 import com.badlogic.gdx.math.collision.BoundingBox;
 import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.GdxRuntimeException;
 
 /** A node is part of a hierarchy of Nodes in a {@link Model}. A Node encodes a transform relative to its parents. A Node can have
  * child nodes. Optionally a node can specify a {@link MeshPart} and a {@link Material} to be applied to the mesh part.
@@ -31,14 +30,10 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
 public class Node {
 	/** the id, may be null, FIXME is this unique? **/
 	public String id;
-	/** @deprecated Use {@link #getParent()} instead. **/
-	@Deprecated public Node parent; // TODO: Make private
-	/** @deprecated Use {@link #getChildren()} instead. **/
-	@Deprecated public final Array<Node> children = new Array<Node>(2); // TODO: Make private
-	/** Whether this node should inherit the transformation of its parent node, defaults to true. When this flag is false the value
-	 * of {@link #globalTransform} will be the same as the value of {@link #localTransform} causing the transform to be independent
-	 * of its parent transform. */
-	public boolean inheritTransform = true;
+	/** parent node, may be null **/
+	public Node parent;
+	/** child nodes **/
+	public final Array<Node> children = new Array<Node>(2);
 	/** Whether this node is currently being animated, if so the translation, rotation and scale values are not used. */
 	public boolean isAnimated;
 	/** the translation, relative to the parent, not modified by animations **/
@@ -65,10 +60,10 @@ public class Node {
 	/** Calculates the world transform; the product of local transform and the parent's world transform.
 	 * @return the world transform */
 	public Matrix4 calculateWorldTransform () {
-		if (inheritTransform && parent != null)
-			globalTransform.set(parent.globalTransform).mul(localTransform);
-		else
+		if (parent == null)
 			globalTransform.set(localTransform);
+		else
+			globalTransform.set(parent.globalTransform).mul(localTransform);
 		return globalTransform;
 	}
 
@@ -139,121 +134,12 @@ public class Node {
 		return out;
 	}
 
-	/** Adds this node as child to specified parent Node, synonym for: <code>parent.addChild(this)</code>
-	 * @param parent The Node to attach this Node to. */
-	public <T extends Node> void attachTo (T parent) {
-		parent.addChild(this);
-	}
-
-	/** Removes this node from its current parent, if any. Short for: <code>this.getParent().removeChild(this)</code> */
-	public void detach () {
-		if (parent != null) {
-			parent.removeChild(this);
-			parent = null;
-		}
-	}
-
-	/** @return whether this Node has one or more children (true) or not (false) */
-	public boolean hasChildren () {
-		return children != null && children.size > 0;
-	}
-
-	/** @return The number of child nodes that this Node current contains.
-	 * @see #getChild(int) */
-	public int getChildCount () {
-		return children.size;
-	}
-
-	/** @param index The zero-based index of the child node to get, must be: 0 <= index < {@link #getChildCount()}.
-	 * @return The child node at the specified index */
-	public Node getChild (final int index) {
-		return children.get(index);
-	}
-
 	/** @param recursive false to fetch a root child only, true to search the entire node tree for the specified node.
 	 * @return The node with the specified id, or null if not found. */
 	public Node getChild (final String id, boolean recursive, boolean ignoreCase) {
 		return getNode(children, id, recursive, ignoreCase);
 	}
 
-	/** Adds the specified node as the currently last child of this node. If the node is already a child of another node, then it is
-	 * removed from its current parent.
-	 * @param child The Node to add as child of this Node
-	 * @return the zero-based index of the child */
-	public <T extends Node> int addChild (final T child) {
-		return insertChild(-1, child);
-	}
-
-	/** Adds the specified nodes as the currently last child of this node. If the node is already a child of another node, then it
-	 * is removed from its current parent.
-	 * @param nodes The Node to add as child of this Node
-	 * @return the zero-based index of the first added child */
-	public <T extends Node> int addChildren (final Iterable<T> nodes) {
-		return insertChildren(-1, nodes);
-	}
-
-	/** Insert the specified node as child of this node at the specified index. If the node is already a child of another node, then
-	 * it is removed from its current parent. If the specified index is less than zero or equal or greater than
-	 * {@link #getChildCount()} then the Node is added as the currently last child.
-	 * @param index The zero-based index at which to add the child
-	 * @param child The Node to add as child of this Node
-	 * @return the zero-based index of the child */
-	public <T extends Node> int insertChild (int index, final T child) {
-		for (Node p = this; p != null; p = child.getParent()) {
-			if (p == child) throw new GdxRuntimeException("Cannot add a parent as a child");
-		}
-		Node p = child.getParent();
-		if (p != null && !p.removeChild(child)) throw new GdxRuntimeException("Could not remove child from its current parent");
-		if (index < 0 || index >= children.size) {
-			index = children.size;
-			children.add(child);
-		} else
-			children.insert(index, child);
-		child.parent = this;
-		return index;
-	}
-
-	/** Insert the specified nodes as children of this node at the specified index. If the node is already a child of another node,
-	 * then it is removed from its current parent. If the specified index is less than zero or equal or greater than
-	 * {@link #getChildCount()} then the Node is added as the currently last child.
-	 * @param index The zero-based index at which to add the child
-	 * @param nodes The nodes to add as child of this Node
-	 * @return the zero-based index of the first inserted child */
-	public <T extends Node> int insertChildren (int index, final Iterable<T> nodes) {
-		if (index < 0 || index > children.size)
-			index = children.size;
-		int i = index;
-		for (T child : nodes)
-			insertChild(i++, child);
-		return index;
-	}
-
-	/** Removes the specified node as child of this node. On success, the child node will be not attached to any parent node (its
-	 * {@link #getParent()} method will return null). If the specified node currently isn't a child of this node then the removal
-	 * is considered to be unsuccessful and the method will return false.
-	 * @param child The child node to remove.
-	 * @return Whether the removal was successful. */
-	public <T extends Node> boolean removeChild (final T child) {
-		if (!children.removeValue(child, true)) return false;
-		child.parent = null;
-		return true;
-	}
-
-	/** @return An {@link Iterable} to all child nodes that this node contains. */
-	public Iterable<Node> getChildren () {
-		return children;
-	}
-
-	/** @return The parent node that holds this node as child node, may be null. */
-	public Node getParent () {
-		return parent;
-	}
-
-	/** @return Whether (true) is this Node is a child node of another node or not (false). */
-	public boolean hasParent () {
-		return parent != null;
-	}
-
 	/** Helper method to recursive fetch a node from an array
 	 * @param recursive false to fetch a root node only, true to search the entire node tree for the specified node.
 	 * @return The node with the specified id, or null if not found. */
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/NodePart.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/NodePart.java
index db4d148..c28cbbb 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/NodePart.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/model/NodePart.java
@@ -21,6 +21,7 @@ import com.badlogic.gdx.graphics.g3d.Model;
 import com.badlogic.gdx.graphics.g3d.ModelInstance;
 import com.badlogic.gdx.graphics.g3d.Renderable;
 import com.badlogic.gdx.math.Matrix4;
+import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.ArrayMap;
 
 /** A combination of {@link MeshPart} and {@link Material}, used to represent a {@link Node}'s graphical properties. A NodePart is
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ResourceData.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ResourceData.java
index 1e48289..82ac7d3 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ResourceData.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ResourceData.java
@@ -4,7 +4,6 @@ import com.badlogic.gdx.assets.AssetDescriptor;
 import com.badlogic.gdx.assets.AssetManager;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.GdxRuntimeException;
-import com.badlogic.gdx.utils.IntArray;
 import com.badlogic.gdx.utils.Json;
 import com.badlogic.gdx.utils.JsonValue;
 import com.badlogic.gdx.utils.ObjectMap;
@@ -37,19 +36,19 @@ public class ResourceData<T> implements Json.Serializable{
 	 * {@link com.badlogic.gdx.graphics.g3d.particles.ResourceData.AssetData} in the {@link ResourceData} */
 	public static class SaveData implements Json.Serializable{
 		ObjectMap<String, Object> data;
-		IntArray assets;
+		Array<Integer> assets;
 		private int loadIndex;
 		protected ResourceData resources;
 		
 		public SaveData(){
 			data = new ObjectMap<String, Object>();
-			assets = new IntArray();
+			assets = new Array<Integer>();
 			loadIndex = 0;
 		}
 		
 		public SaveData(ResourceData resources){
 			data = new ObjectMap<String, Object>();
-			assets = new IntArray();
+			assets = new Array<Integer>();
 			loadIndex = 0;
 			this.resources = resources;
 		}
@@ -80,13 +79,13 @@ public class ResourceData<T> implements Json.Serializable{
 		@Override
 		public void write (Json json) {
 			json.writeValue("data", data, ObjectMap.class);
-			json.writeValue("indices", assets.toArray(), int[].class);
+			json.writeValue("indices", assets.toArray(Integer.class), Integer[].class);
 		}
 
 		@Override
 		public void read (Json json, JsonValue jsonData) {
 			data = json.readValue("data", ObjectMap.class, jsonData);
-			assets.addAll(json.readValue("indices", int[].class, jsonData));
+			assets.addAll(json.readValue("indices", Integer[].class, jsonData));
 		}
 	}
 	
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/emitters/Emitter.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/emitters/Emitter.java
index 3e28b98..76fc848 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/emitters/Emitter.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/emitters/Emitter.java
@@ -67,8 +67,8 @@ public abstract class  Emitter extends ParticleControllerComponent implements Js
 	
 	@Override
 	public void read (Json json, JsonValue jsonData) {
-		minParticleCount = json.readValue("minParticleCount", int.class, jsonData);
-		maxParticleCount = json.readValue("maxParticleCount", int.class, jsonData);
+		minParticleCount = json.readValue("minParticleCount", Integer.class, jsonData);
+		maxParticleCount = json.readValue("maxParticleCount", Integer.class, jsonData);
 	}
 
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/ParticleControllerInfluencer.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/ParticleControllerInfluencer.java
index 5eeaaa4..bcc2672 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/ParticleControllerInfluencer.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/influencers/ParticleControllerInfluencer.java
@@ -11,7 +11,6 @@ import com.badlogic.gdx.graphics.g3d.particles.ParticleEffect;
 import com.badlogic.gdx.graphics.g3d.particles.ResourceData;
 import com.badlogic.gdx.graphics.g3d.particles.ResourceData.SaveData;
 import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.IntArray;
 import com.badlogic.gdx.utils.Pool;
 
 /** It's an {@link Influencer} which controls which {@link ParticleController} will be assigned to a particle.
@@ -188,19 +187,19 @@ public abstract class ParticleControllerInfluencer extends Influencer{
 		Array<ParticleEffect> effects = manager.getAll(ParticleEffect.class, new Array<ParticleEffect>());
 		
 		Array<ParticleController> controllers = new Array<ParticleController>(templates);
-		Array<IntArray>effectsIndices = new Array<IntArray>();
+		Array<Array<Integer>>effectsIndices = new Array<Array<Integer>>();
 		
 		for(int i=0; i < effects.size && controllers.size >0; ++i){
 			ParticleEffect effect = effects.get(i);
 			Array<ParticleController> effectControllers = effect.getControllers();
 			Iterator<ParticleController> iterator = controllers.iterator();
-			IntArray indices = null;
+			Array<Integer> indices = null;
 			while(iterator.hasNext()){
 				ParticleController controller = iterator.next();
 				int index = -1;
 				if( (index = effectControllers.indexOf(controller, true)) >-1){
 					if(indices == null){
-						indices = new IntArray();
+						indices = new Array<Integer>();
 					}
 					iterator.remove();
 					indices.add(index);
@@ -218,18 +217,18 @@ public abstract class ParticleControllerInfluencer extends Influencer{
 	@Override
 	public void load (AssetManager manager, ResourceData resources) {
 		SaveData data = resources.getSaveData();
-		Array<IntArray>effectsIndices = data.load("indices");
+		Array<Array<Integer>>effectsIndices = data.load("indices");
 		AssetDescriptor descriptor;
-		Iterator<IntArray> iterator = effectsIndices.iterator();
+		Iterator<Array<Integer>> iterator = effectsIndices.iterator();
 		while((descriptor = data.loadAsset()) != null){
 			ParticleEffect effect = (ParticleEffect)manager.get(descriptor);
 			if(effect == null)
 				throw new RuntimeException("Template is null");
 			Array<ParticleController> effectControllers = effect.getControllers();
-			IntArray effectIndices = iterator.next();
+			Array<Integer> effectIndices = iterator.next();
 			
-			for (int i = 0, n = effectIndices.size; i < n; i++) {
-				templates.add(effectControllers.get(effectIndices.get(i)));
+			for(Integer index : effectIndices){
+					templates.add(effectControllers.get(index));
 			}
 		}
 	}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/utils/MeshBuilder.java b/gdx/src/com/badlogic/gdx/graphics/g3d/utils/MeshBuilder.java
index 742e03e..598dfdc 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/utils/MeshBuilder.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/utils/MeshBuilder.java
@@ -33,8 +33,6 @@ import com.badlogic.gdx.math.Vector3;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.FloatArray;
 import com.badlogic.gdx.utils.GdxRuntimeException;
-import com.badlogic.gdx.utils.IntIntMap;
-import com.badlogic.gdx.utils.NumberUtils;
 import com.badlogic.gdx.utils.Pool;
 import com.badlogic.gdx.utils.ShortArray;
 
@@ -44,9 +42,6 @@ import com.badlogic.gdx.utils.ShortArray;
  * {@link #end()}.
  * @author Xoppa */
 public class MeshBuilder implements MeshPartBuilder {
-	private final static ShortArray tmpIndices = new ShortArray();
-	private final static FloatArray tmpVertices = new FloatArray();
-
 	private final VertexInfo vertTmp1 = new VertexInfo();
 	private final VertexInfo vertTmp2 = new VertexInfo();
 	private final VertexInfo vertTmp3 = new VertexInfo();
@@ -66,7 +61,7 @@ public class MeshBuilder implements MeshPartBuilder {
 	private final Vector3 tempV6 = new Vector3();
 	private final Vector3 tempV7 = new Vector3();
 	private final Vector3 tempV8 = new Vector3();
-
+	
 	private final Color tempC1 = new Color();
 
 	/** The vertex attributes of the resulting mesh */
@@ -101,17 +96,16 @@ public class MeshBuilder implements MeshPartBuilder {
 	private Array<MeshPart> parts = new Array<MeshPart>();
 	/** The color used if no vertex color is specified. */
 	private final Color color = new Color(Color.WHITE);
-	private boolean hasColor = false;
 	/** The current primitiveType */
 	private int primitiveType;
 	/** The UV range used when building */
-	private float uOffset = 0f, uScale = 1f, vOffset = 0f, vScale = 1f;
-	private boolean hasUVTransform = false;
+	private float uMin = 0, uMax = 1, vMin = 0, vMax = 1;
 	private float[] vertex;
 
 	private boolean vertexTransformationEnabled = false;
 	private final Matrix4 positionTransform = new Matrix4();
 	private final Matrix3 normalTransform = new Matrix3();
+	private final Vector3 tempVTransformed = new Vector3();
 
 	/** @param usage bitwise mask of the {@link com.badlogic.gdx.graphics.VertexAttributes.Usage}, only Position, Color, Normal and
 	 *           TextureCoordinates is supported. */
@@ -136,12 +130,12 @@ public class MeshBuilder implements MeshPartBuilder {
 	 * @param attributes bitwise mask of the {@link com.badlogic.gdx.graphics.VertexAttributes.Usage}, only Position, Color, Normal
 	 *           and TextureCoordinates is supported. */
 	public void begin (final long attributes) {
-		begin(createAttributes(attributes), -1);
+		begin(createAttributes(attributes), 0);
 	}
 
 	/** Begin building a mesh. Call {@link #part(String, int)} to start a {@link MeshPart}. */
 	public void begin (final VertexAttributes attributes) {
-		begin(attributes, -1);
+		begin(attributes, 0);
 	}
 
 	/** Begin building a mesh.
@@ -178,7 +172,6 @@ public class MeshBuilder implements MeshPartBuilder {
 		uvOffset = a == null ? -1 : a.offset / 4;
 		setColor(null);
 		setVertexTransform(null);
-		setUVRange(null);
 		this.primitiveType = primitiveType;
 	}
 
@@ -191,8 +184,8 @@ public class MeshBuilder implements MeshPartBuilder {
 		}
 	}
 
-	/** Starts a new MeshPart. The mesh part is not usable until end() is called. This will reset the current color and vertex
-	 * transformation. */
+	/** Starts a new MeshPart. The mesh part is not usable until end() is called.
+	 * This will reset the current color and vertex transformation. */
 	public MeshPart part (final String id, int primitiveType) {
 		if (this.attributes == null) throw new RuntimeException("Call begin() first");
 		endpart();
@@ -204,25 +197,16 @@ public class MeshBuilder implements MeshPartBuilder {
 
 		setColor(null);
 		setVertexTransform(null);
-		setUVRange(null);
 
 		return part;
 	}
 
-	/** End building the mesh and returns the mesh
-	 * @param mesh The mesh to receive the built vertices and indices, must have the same attributes and must be big enough to hold
-	 *           the data, any existing data will be overwritten. */
-	public Mesh end (Mesh mesh) {
+	/** End building the mesh and returns the mesh */
+	public Mesh end () {
+		if (this.attributes == null) throw new RuntimeException("Call begin() first");
 		endpart();
 
-		if (attributes == null) throw new GdxRuntimeException("Call begin() first");
-		if (!attributes.equals(mesh.getVertexAttributes())) throw new GdxRuntimeException("Mesh attributes don't match");
-		if ((mesh.getMaxVertices() * stride) < vertices.size)
-			throw new GdxRuntimeException("Mesh can't hold enough vertices: " + mesh.getMaxVertices() + " * " + stride + " < "
-				+ vertices.size);
-		if (mesh.getMaxIndices() < indices.size)
-			throw new GdxRuntimeException("Mesh can't hold enough indices: " + mesh.getMaxIndices() + " < " + indices.size);
-
+		final Mesh mesh = new Mesh(true, vertices.size / stride, indices.size, attributes);
 		mesh.setVertices(vertices.items, 0, vertices.size);
 		mesh.setIndices(indices.items, 0, indices.size);
 
@@ -237,21 +221,6 @@ public class MeshBuilder implements MeshPartBuilder {
 		return mesh;
 	}
 
-	/** End building the mesh and returns the mesh */
-	public Mesh end () {
-		return end(new Mesh(true, vertices.size / stride, indices.size, attributes));
-	}
-
-	/** @return The number of vertices built up until now, only valid in between the call to begin() and end(). */
-	public int getNumVertices () {
-		return vertices.size / stride;
-	}
-
-	/** @return The number of indices built up until now, only valid in between the call to begin() and end(). */
-	public int getNumIndices () {
-		return indices.size;
-	}
-
 	@Override
 	public VertexAttributes getAttributes () {
 		return attributes;
@@ -309,56 +278,24 @@ public class MeshBuilder implements MeshPartBuilder {
 	@Override
 	public void setColor (float r, float g, float b, float a) {
 		color.set(r, g, b, a);
-		hasColor = !color.equals(Color.WHITE);
 	}
 
 	@Override
 	public void setColor (final Color color) {
-		this.color.set(!(hasColor = (color != null)) ? Color.WHITE : color);
+		this.color.set(color == null ? Color.WHITE : color);
 	}
 
 	@Override
 	public void setUVRange (float u1, float v1, float u2, float v2) {
-		uOffset = u1;
-		vOffset = v1;
-		uScale = u2 - u1;
-		vScale = v2 - v1;
-		hasUVTransform = !(MathUtils.isZero(u1) && MathUtils.isZero(v1) && MathUtils.isEqual(u2, 1f) && MathUtils.isEqual(v2, 1f));
+		uMin = u1;
+		vMin = v1;
+		uMax = u2;
+		vMax = v2;
 	}
 
 	@Override
 	public void setUVRange (TextureRegion region) {
-		if (!(hasUVTransform = (region != null))) {
-			uOffset = vOffset = 0f;
-			uScale = vScale = 1f;
-		} else
-			setUVRange(region.getU(), region.getV(), region.getU2(), region.getV2());
-	}
-
-	@Override
-	public Matrix4 getVertexTransform (Matrix4 out) {
-		return out.set(positionTransform);
-	}
-
-	@Override
-	public void setVertexTransform (Matrix4 transform) {
-		if ((vertexTransformationEnabled = (transform != null)) == true) {
-			positionTransform.set(transform);
-			normalTransform.set(transform).inv().transpose();
-		} else {
-			positionTransform.idt();
-			normalTransform.idt();
-		}
-	}
-
-	@Override
-	public boolean isVertexTransformationEnabled () {
-		return vertexTransformationEnabled;
-	}
-
-	@Override
-	public void setVertexTransformationEnabled (boolean enabled) {
-		vertexTransformationEnabled = enabled;
+		setUVRange(region.getU(), region.getV(), region.getU2(), region.getV2());
 	}
 
 	/** Increases the size of the backing vertices array to accommodate the specified number of additional vertices. Useful before
@@ -390,10 +327,9 @@ public class MeshBuilder implements MeshPartBuilder {
 	public void ensureTriangleIndices (int numTriangles) {
 		if (primitiveType == GL20.GL_LINES)
 			ensureIndices(6 * numTriangles);
-		else if (primitiveType == GL20.GL_TRIANGLES || primitiveType == GL20.GL_POINTS)
-			ensureIndices(3 * numTriangles);
 		else
-			throw new GdxRuntimeException("Incorrect primtive type");
+			// GL_TRIANGLES || GL_POINTS
+			ensureIndices(3 * numTriangles);
 	}
 
 	/** Increases the size of the backing vertices and indices arrays to accommodate the specified number of additional vertices and
@@ -450,97 +386,50 @@ public class MeshBuilder implements MeshPartBuilder {
 		return lastIndex;
 	}
 
-	private final static Vector3 vTmp = new Vector3();
-
-	private final static void transformPosition (final float[] values, final int offset, final int size, Matrix4 transform) {
-		if (size > 2) {
-			vTmp.set(values[offset], values[offset + 1], values[offset + 2]).mul(transform);
-			values[offset] = vTmp.x;
-			values[offset + 1] = vTmp.y;
-			values[offset + 2] = vTmp.z;
-		} else if (size > 1) {
-			vTmp.set(values[offset], values[offset + 1], 0).mul(transform);
-			values[offset] = vTmp.x;
-			values[offset + 1] = vTmp.y;
-		} else
-			values[offset] = vTmp.set(values[offset], 0, 0).mul(transform).x;
-	}
-
-	private final static void transformNormal (final float[] values, final int offset, final int size, Matrix3 transform) {
-		if (size > 2) {
-			vTmp.set(values[offset], values[offset + 1], values[offset + 2]).mul(transform).nor();
-			values[offset] = vTmp.x;
-			values[offset + 1] = vTmp.y;
-			values[offset + 2] = vTmp.z;
-		} else if (size > 1) {
-			vTmp.set(values[offset], values[offset + 1], 0).mul(transform).nor();
-			values[offset] = vTmp.x;
-			values[offset + 1] = vTmp.y;
-		} else
-			values[offset] = vTmp.set(values[offset], 0, 0).mul(transform).nor().x;
-	}
-
 	private final void addVertex (final float[] values, final int offset) {
-		final int o = vertices.size;
 		vertices.addAll(values, offset, stride);
 		lastIndex = (short)(vindex++);
-
-		if (vertexTransformationEnabled) {
-			transformPosition(vertices.items, o + posOffset, posSize, positionTransform);
-			if (norOffset >= 0) transformNormal(vertices.items, o + norOffset, 3, normalTransform);
-		}
-
-		if (hasColor) {
-			if (colOffset >= 0) {
-				vertices.items[o + colOffset] *= color.r;
-				vertices.items[o + colOffset + 1] *= color.g;
-				vertices.items[o + colOffset + 2] *= color.b;
-				if (colSize > 3) vertices.items[o + colOffset + 3] *= color.a;
-			} else if (cpOffset >= 0) {
-				vertices.items[o + cpOffset] = tempC1.set(NumberUtils.floatToIntColor(vertices.items[o + cpOffset])).mul(color)
-					.toFloatBits();
-			}
-		}
-
-		if (hasUVTransform && uvOffset >= 0) {
-			vertices.items[o + uvOffset] = uOffset + uScale * vertices.items[o + uvOffset];
-			vertices.items[o + uvOffset + 1] = vOffset + vScale * vertices.items[o + uvOffset + 1];
-		}
 	}
 
-	private final Vector3 tmpNormal = new Vector3();
-
 	@Override
 	public short vertex (Vector3 pos, Vector3 nor, Color col, Vector2 uv) {
 		if (vindex >= Short.MAX_VALUE) throw new GdxRuntimeException("Too many vertices used");
-
-		vertex[posOffset] = pos.x;
-		if (posSize > 1) vertex[posOffset + 1] = pos.y;
-		if (posSize > 2) vertex[posOffset + 2] = pos.z;
-
-		if (norOffset >= 0) {
-			if (nor == null) nor = tmpNormal.set(pos).nor();
-			vertex[norOffset] = nor.x;
-			vertex[norOffset + 1] = nor.y;
-			vertex[norOffset + 2] = nor.z;
+		tempC1.set(color);
+		if (col != null) tempC1.mul(col);
+		if (pos != null) {
+			if (vertexTransformationEnabled) {
+				tempVTransformed.set(pos).mul(positionTransform);
+				vertex[posOffset] = tempVTransformed.x;
+				if (posSize > 1) vertex[posOffset + 1] = tempVTransformed.y;
+				if (posSize > 2) vertex[posOffset + 2] = tempVTransformed.z;
+			} else {
+				vertex[posOffset] = pos.x;
+				if (posSize > 1) vertex[posOffset + 1] = pos.y;
+				if (posSize > 2) vertex[posOffset + 2] = pos.z;
+			}
 		}
-
-		if (colOffset >= 0) {
-			if (col == null) col = Color.WHITE;
-			vertex[colOffset] = col.r;
-			vertex[colOffset + 1] = col.g;
-			vertex[colOffset + 2] = col.b;
-			if (colSize > 3) vertex[colOffset + 3] = col.a;
-		} else if (cpOffset > 0) {
-			if (col == null) col = Color.WHITE;
-			vertex[cpOffset] = col.toFloatBits(); // FIXME cache packed color?
+		if (nor != null && norOffset >= 0) {
+			if (vertexTransformationEnabled) {
+				tempVTransformed.set(nor).mul(normalTransform).nor();
+				vertex[norOffset] = tempVTransformed.x;
+				vertex[norOffset + 1] = tempVTransformed.y;
+				vertex[norOffset + 2] = tempVTransformed.z;
+			} else {
+				vertex[norOffset] = nor.x;
+				vertex[norOffset + 1] = nor.y;
+				vertex[norOffset + 2] = nor.z;
+			}
 		}
-
+		if (colOffset >= 0) {
+			vertex[colOffset] = tempC1.r;
+			vertex[colOffset + 1] = tempC1.g;
+			vertex[colOffset + 2] = tempC1.b;
+			if (colSize > 3) vertex[colOffset + 3] = tempC1.a;
+		} else if (cpOffset > 0) vertex[cpOffset] = tempC1.toFloatBits(); // FIXME cache packed color?
 		if (uv != null && uvOffset >= 0) {
 			vertex[uvOffset] = uv.x;
 			vertex[uvOffset + 1] = uv.y;
 		}
-
 		addVertex(vertex, 0);
 		return lastIndex;
 	}
@@ -686,17 +575,19 @@ public class MeshBuilder implements MeshPartBuilder {
 
 	@Override
 	public void rect (Vector3 corner00, Vector3 corner10, Vector3 corner11, Vector3 corner01, Vector3 normal) {
-		rect(vertTmp1.set(corner00, normal, null, null).setUV(0f, 1f), vertTmp2.set(corner10, normal, null, null).setUV(1f, 1f),
-			vertTmp3.set(corner11, normal, null, null).setUV(1f, 0f), vertTmp4.set(corner01, normal, null, null).setUV(0f, 0f));
+		rect(vertTmp1.set(corner00, normal, null, null).setUV(uMin, vMax),
+			vertTmp2.set(corner10, normal, null, null).setUV(uMax, vMax),
+			vertTmp3.set(corner11, normal, null, null).setUV(uMax, vMin),
+			vertTmp4.set(corner01, normal, null, null).setUV(uMin, vMin));
 	}
 
 	@Override
 	public void rect (float x00, float y00, float z00, float x10, float y10, float z10, float x11, float y11, float z11,
 		float x01, float y01, float z01, float normalX, float normalY, float normalZ) {
-		rect(vertTmp1.set(null, null, null, null).setPos(x00, y00, z00).setNor(normalX, normalY, normalZ).setUV(0f, 1f), vertTmp2
-			.set(null, null, null, null).setPos(x10, y10, z10).setNor(normalX, normalY, normalZ).setUV(1f, 1f),
-			vertTmp3.set(null, null, null, null).setPos(x11, y11, z11).setNor(normalX, normalY, normalZ).setUV(1f, 0f), vertTmp4
-				.set(null, null, null, null).setPos(x01, y01, z01).setNor(normalX, normalY, normalZ).setUV(0f, 0f));
+		rect(vertTmp1.set(null, null, null, null).setPos(x00, y00, z00).setNor(normalX, normalY, normalZ).setUV(uMin, vMax),
+			vertTmp2.set(null, null, null, null).setPos(x10, y10, z10).setNor(normalX, normalY, normalZ).setUV(uMax, vMax), vertTmp3
+				.set(null, null, null, null).setPos(x11, y11, z11).setNor(normalX, normalY, normalZ).setUV(uMax, vMin),
+			vertTmp4.set(null, null, null, null).setPos(x01, y01, z01).setNor(normalX, normalY, normalZ).setUV(uMin, vMin));
 	}
 
 	@Override
@@ -720,17 +611,18 @@ public class MeshBuilder implements MeshPartBuilder {
 	@Override
 	public void patch (Vector3 corner00, Vector3 corner10, Vector3 corner11, Vector3 corner01, Vector3 normal, int divisionsU,
 		int divisionsV) {
-		patch(vertTmp1.set(corner00, normal, null, null).setUV(0f, 1f), vertTmp2.set(corner10, normal, null, null).setUV(1f, 1f),
-			vertTmp3.set(corner11, normal, null, null).setUV(1f, 0f), vertTmp4.set(corner01, normal, null, null).setUV(0f, 0f),
-			divisionsU, divisionsV);
+		patch(vertTmp1.set(corner00, normal, null, null).setUV(uMin, vMax),
+			vertTmp2.set(corner10, normal, null, null).setUV(uMax, vMax),
+			vertTmp3.set(corner11, normal, null, null).setUV(uMax, vMin),
+			vertTmp4.set(corner01, normal, null, null).setUV(uMin, vMin), divisionsU, divisionsV);
 	}
 
 	public void patch (float x00, float y00, float z00, float x10, float y10, float z10, float x11, float y11, float z11,
 		float x01, float y01, float z01, float normalX, float normalY, float normalZ, int divisionsU, int divisionsV) {
-		patch(vertTmp1.set(null).setPos(x00, y00, z00).setNor(normalX, normalY, normalZ).setUV(0f, 1f),
-			vertTmp2.set(null).setPos(x10, y10, z10).setNor(normalX, normalY, normalZ).setUV(1f, 1f),
-			vertTmp3.set(null).setPos(x11, y11, z11).setNor(normalX, normalY, normalZ).setUV(1f, 0f),
-			vertTmp4.set(null).setPos(x01, y01, z01).setNor(normalX, normalY, normalZ).setUV(0f, 0f), divisionsU, divisionsV);
+		patch(vertTmp1.set(null).setPos(x00, y00, z00).setNor(normalX, normalY, normalZ).setUV(uMin, vMax), vertTmp2.set(null)
+			.setPos(x10, y10, z10).setNor(normalX, normalY, normalZ).setUV(uMax, vMax), vertTmp3.set(null).setPos(x11, y11, z11)
+			.setNor(normalX, normalY, normalZ).setUV(uMax, vMin),
+			vertTmp4.set(null).setPos(x01, y01, z01).setNor(normalX, normalY, normalZ).setUV(uMin, vMin), divisionsU, divisionsV);
 	}
 
 	@Override
@@ -755,7 +647,7 @@ public class MeshBuilder implements MeshPartBuilder {
 			ensureRectangleIndices(2);
 			rect(i000, i100, i110, i010);
 			rect(i101, i001, i011, i111);
-		} else { // GL20.GL_TRIANGLES
+		} else { // GL10.GL_TRIANGLES
 			ensureRectangleIndices(6);
 			rect(i000, i100, i110, i010);
 			rect(i101, i001, i011, i111);
@@ -1104,6 +996,8 @@ public class MeshBuilder implements MeshPartBuilder {
 		sphere(matTmp1.idt(), width, height, depth, divisionsU, divisionsV, angleUFrom, angleUTo, angleVFrom, angleVTo);
 	}
 
+	private static ShortArray tmpIndices;
+
 	@Override
 	public void sphere (final Matrix4 transform, float width, float height, float depth, int divisionsU, int divisionsV,
 		float angleUFrom, float angleUTo, float angleVFrom, float angleVTo) {
@@ -1124,10 +1018,13 @@ public class MeshBuilder implements MeshPartBuilder {
 		VertexInfo curr1 = vertTmp3.set(null, null, null, null);
 		curr1.hasUV = curr1.hasPosition = curr1.hasNormal = true;
 
+		if (tmpIndices == null) tmpIndices = new ShortArray(divisionsU * 2);
 		final int s = divisionsU + 3;
-		tmpIndices.clear();
-		tmpIndices.ensureCapacity(divisionsU * 2);
-		tmpIndices.size = s;
+		tmpIndices.ensureCapacity(s);
+		while (tmpIndices.size > s)
+			tmpIndices.pop();
+		while (tmpIndices.size < s)
+			tmpIndices.add(-1);
 		int tempOffset = 0;
 
 		ensureRectangles((divisionsV + 1) * (divisionsU + 1), divisionsV * divisionsU);
@@ -1162,8 +1059,7 @@ public class MeshBuilder implements MeshPartBuilder {
 	}
 
 	@Override
-	public void arrow (float x1, float y1, float z1, float x2, float y2, float z2, float capLength, float stemThickness,
-		int divisions) {
+	public void arrow (float x1, float y1, float z1, float x2, float y2, float z2, float capLength, float stemThickness, int divisions) {
 		Vector3 begin = tmp(x1, y1, z1), end = tmp(x2, y2, z2);
 		float length = begin.dst(end);
 		float coneHeight = length * capLength;
@@ -1181,16 +1077,10 @@ public class MeshBuilder implements MeshPartBuilder {
 		// Matrices
 		Matrix4 userTransform = getVertexTransform(tmp());
 		Matrix4 transform = tmp();
-		float[] val = transform.val;
-		val[Matrix4.M00] = left.x;
-		val[Matrix4.M01] = up.x;
-		val[Matrix4.M02] = forward.x;
-		val[Matrix4.M10] = left.y;
-		val[Matrix4.M11] = up.y;
-		val[Matrix4.M12] = forward.y;
-		val[Matrix4.M20] = left.z;
-		val[Matrix4.M21] = up.z;
-		val[Matrix4.M22] = forward.z;
+		float[]val = transform.val;
+		val[Matrix4.M00] = left.x; val[Matrix4.M01] = up.x; val[Matrix4.M02] = forward.x;
+		val[Matrix4.M10] = left.y; val[Matrix4.M11] = up.y; val[Matrix4.M12] = forward.y;
+		val[Matrix4.M20] = left.z; val[Matrix4.M21] = up.z; val[Matrix4.M22] = forward.z;
 		Matrix4 temp = tmp();
 
 		// Stem
@@ -1208,55 +1098,28 @@ public class MeshBuilder implements MeshPartBuilder {
 	}
 
 	@Override
-	public void addMesh (Mesh mesh) {
-		addMesh(mesh, 0, mesh.getNumIndices());
+	public Matrix4 getVertexTransform (Matrix4 out) {
+		return out.set(positionTransform);
 	}
 
 	@Override
-	public void addMesh (MeshPart meshpart) {
-		if (meshpart.primitiveType != primitiveType) throw new GdxRuntimeException("Primitive type doesn't match");
-		addMesh(meshpart.mesh, meshpart.indexOffset, meshpart.numVertices);
+	public void setVertexTransform (Matrix4 transform) {
+		if ((vertexTransformationEnabled = (transform != null)) == true) {
+			positionTransform.set(transform);
+			normalTransform.set(transform).inv().transpose();
+		} else {
+			positionTransform.idt();
+			normalTransform.idt();
+		}
 	}
 
 	@Override
-	public void addMesh (Mesh mesh, int indexOffset, int numIndices) {
-		if (!attributes.equals(mesh.getVertexAttributes())) throw new GdxRuntimeException("Vertex attributes do not match");
-		if (numIndices <= 0) return; // silently ignore an empty mesh part
-
-		// FIXME don't triple copy, instead move the copy to jni
-		int numFloats = mesh.getNumVertices() * stride;
-		tmpVertices.clear();
-		tmpVertices.ensureCapacity(numFloats);
-		tmpVertices.size = numFloats;
-		mesh.getVertices(tmpVertices.items);
-
-		tmpIndices.clear();
-		tmpIndices.ensureCapacity(numIndices);
-		tmpIndices.size = numIndices;
-		mesh.getIndices(indexOffset, numIndices, tmpIndices.items, 0);
-
-		addMesh(tmpVertices.items, tmpIndices.items, 0, numIndices);
+	public boolean isVertexTransformationEnabled () {
+		return vertexTransformationEnabled;
 	}
 
-	private static IntIntMap indicesMap = null;
-
-	private void addMesh (float[] vertices, short[] indices, int indexOffset, int numIndices) {
-		if (indicesMap == null)
-			indicesMap = new IntIntMap(numIndices);
-		else {
-			indicesMap.clear();
-			indicesMap.ensureCapacity(numIndices);
-		}
-		ensureIndices(numIndices);
-		ensureVertices(vertices.length < numIndices ? vertices.length : numIndices); // a bit naive perhaps?
-		for (int i = 0; i < numIndices; i++) {
-			final int sidx = indices[i];
-			int didx = indicesMap.get(sidx, -1);
-			if (didx < 0) {
-				addVertex(vertices, sidx * stride);
-				indicesMap.put(sidx, didx = lastIndex);
-			}
-			index((short)didx);
-		}
+	@Override
+	public void setVertexTransformationEnabled (boolean enabled) {
+		vertexTransformationEnabled = enabled;
 	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/utils/MeshPartBuilder.java b/gdx/src/com/badlogic/gdx/graphics/g3d/utils/MeshPartBuilder.java
index d65376f..8ced799 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/utils/MeshPartBuilder.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/utils/MeshPartBuilder.java
@@ -17,7 +17,6 @@
 package com.badlogic.gdx.graphics.g3d.utils;
 
 import com.badlogic.gdx.graphics.Color;
-import com.badlogic.gdx.graphics.Mesh;
 import com.badlogic.gdx.graphics.VertexAttributes;
 import com.badlogic.gdx.graphics.VertexAttributes.Usage;
 import com.badlogic.gdx.graphics.g2d.TextureRegion;
@@ -48,18 +47,6 @@ public interface MeshPartBuilder {
 	/** Set range of texture coordinates from the specified TextureRegion. */
 	public void setUVRange (TextureRegion r);
 
-	/** Get the current vertex transformation matrix. */
-	public Matrix4 getVertexTransform (Matrix4 out);
-
-	/** Set the current vertex transformation matrix and enables vertex transformation. */
-	public void setVertexTransform (Matrix4 transform);
-
-	/** Indicates whether vertex transformation is enabled. */
-	public boolean isVertexTransformationEnabled ();
-
-	/** Sets whether vertex transformation is enabled. */
-	public void setVertexTransformationEnabled (boolean enabled);
-
 	/** Add one or more vertices, returns the index of the last vertex added. The length of values must a power of the vertex size. */
 	public short vertex (final float... values);
 
@@ -286,19 +273,17 @@ public interface MeshPartBuilder {
 	public void arrow (float x1, float y1, float z1, float x2, float y2, float z2, float capLength, float stemThickness,
 		int divisions);
 
-	/** Copies a mesh to the mesh (part) currently being build.
-	 * @param mesh The mesh to copy, must have the same vertex attributes and must be indexed. */
-	public void addMesh (Mesh mesh);
-	
-	/** Copies a MeshPart to the mesh (part) currently being build.
-	 * @param meshpart The MeshPart to copy, must have the same vertex attributes, primitive type and must be indexed. */
-	public void addMesh (MeshPart meshpart);
-
-	/** Copies a (part of a) mesh to the mesh (part) currently being build.
-	 * @param mesh The mesh to (partly) copy, must have the same vertex attributes and must be indexed.
-	 * @param indexOffset The zero-based offset of the first index of the part of the mesh to copy.
-	 * @param numIndices The number of indices of the part of the mesh to copy. */
-	public void addMesh (Mesh mesh, int indexOffset, int numIndices);
+	/** Get the current vertex transformation matrix. */
+	public Matrix4 getVertexTransform (Matrix4 out);
+
+	/** Set the current vertex transformation matrix and enables vertex transformation. */
+	public void setVertexTransform (Matrix4 transform);
+
+	/** Indicates whether vertex transformation is enabled. */
+	public boolean isVertexTransformationEnabled ();
+
+	/** Sets whether vertex transformation is enabled. */
+	public void setVertexTransformationEnabled (boolean enabled);
 
 	/** Class that contains all vertex information the builder can use.
 	 * @author Xoppa */
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/utils/ModelBuilder.java b/gdx/src/com/badlogic/gdx/graphics/g3d/utils/ModelBuilder.java
index f5d2026..c7633af 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/utils/ModelBuilder.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/utils/ModelBuilder.java
@@ -21,6 +21,7 @@ import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.Mesh;
 import com.badlogic.gdx.graphics.VertexAttribute;
 import com.badlogic.gdx.graphics.VertexAttributes;
+import com.badlogic.gdx.graphics.VertexAttributes.Usage;
 import com.badlogic.gdx.graphics.g3d.Material;
 import com.badlogic.gdx.graphics.g3d.Model;
 import com.badlogic.gdx.graphics.g3d.model.MeshPart;
@@ -115,7 +116,7 @@ public class ModelBuilder {
 	public Node node (final String id, final Model model) {
 		final Node node = new Node();
 		node.id = id;
-		node.addChildren(model.nodes);
+		node.children.addAll(model.nodes);
 		node(node);
 		for (final Disposable disposable : model.getManagedDisposables())
 			manage(disposable);
@@ -376,7 +377,7 @@ public class ModelBuilder {
 				model.manageDisposable(mpm.meshPart.mesh);
 			}
 		}
-		for (final Node child : node.getChildren())
+		for (final Node child : node.children)
 			rebuildReferences(model, child);
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/FacedCubemapData.java b/gdx/src/com/badlogic/gdx/graphics/glutils/FacedCubemapData.java
deleted file mode 100644
index 0e68816..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/FacedCubemapData.java
+++ /dev/null
@@ -1,182 +0,0 @@
-
-package com.badlogic.gdx.graphics.glutils;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.Cubemap;
-import com.badlogic.gdx.graphics.Cubemap.CubemapSide;
-import com.badlogic.gdx.graphics.CubemapData;
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.GLTexture;
-import com.badlogic.gdx.graphics.Pixmap;
-import com.badlogic.gdx.graphics.Pixmap.Blending;
-import com.badlogic.gdx.graphics.Pixmap.Format;
-import com.badlogic.gdx.graphics.Texture;
-import com.badlogic.gdx.graphics.TextureData;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-
-/** A FacedCubemapData holds a cubemap data definition based on a {@link TextureData} per face.
- * 
- * @author Vincent Nousquet */
-public class FacedCubemapData implements CubemapData {
-
-	protected final TextureData[] data = new TextureData[6];
-
-	/** Construct an empty Cubemap. Use the load(...) methods to set the texture of each side. Every side of the cubemap must be set
-	 * before it can be used. */
-	public FacedCubemapData () {
-		this((TextureData)null, (TextureData)null, (TextureData)null, (TextureData)null, (TextureData)null, (TextureData)null);
-	}
-
-	/** Construct a Cubemap with the specified texture files for the sides, optionally generating mipmaps. */
-	public FacedCubemapData (FileHandle positiveX, FileHandle negativeX, FileHandle positiveY, FileHandle negativeY,
-		FileHandle positiveZ, FileHandle negativeZ) {
-		this(TextureData.Factory.loadFromFile(positiveX, false), TextureData.Factory.loadFromFile(negativeX,
-			false), TextureData.Factory.loadFromFile(positiveY, false), TextureData.Factory.loadFromFile(
-			negativeY, false), TextureData.Factory.loadFromFile(positiveZ, false), TextureData.Factory
-			.loadFromFile(negativeZ, false));
-	}
-
-	/** Construct a Cubemap with the specified texture files for the sides, optionally generating mipmaps. */
-	public FacedCubemapData (FileHandle positiveX, FileHandle negativeX, FileHandle positiveY, FileHandle negativeY,
-		FileHandle positiveZ, FileHandle negativeZ, boolean useMipMaps) {
-		this(TextureData.Factory.loadFromFile(positiveX, useMipMaps), TextureData.Factory.loadFromFile(
-			negativeX, useMipMaps), TextureData.Factory.loadFromFile(positiveY, useMipMaps), TextureData.Factory
-			.loadFromFile(negativeY, useMipMaps), TextureData.Factory.loadFromFile(positiveZ, useMipMaps),
-			TextureData.Factory.loadFromFile(negativeZ, useMipMaps));
-	}
-
-	/** Construct a Cubemap with the specified {@link Pixmap}s for the sides, does not generate mipmaps. */
-	public FacedCubemapData (Pixmap positiveX, Pixmap negativeX, Pixmap positiveY, Pixmap negativeY, Pixmap positiveZ,
-		Pixmap negativeZ) {
-		this(positiveX, negativeX, positiveY, negativeY, positiveZ, negativeZ, false);
-	}
-
-	/** Construct a Cubemap with the specified {@link Pixmap}s for the sides, optionally generating mipmaps. */
-	public FacedCubemapData (Pixmap positiveX, Pixmap negativeX, Pixmap positiveY, Pixmap negativeY, Pixmap positiveZ,
-		Pixmap negativeZ, boolean useMipMaps) {
-		this(positiveX == null ? null : new PixmapTextureData(positiveX, null, useMipMaps, false), negativeX == null ? null
-			: new PixmapTextureData(negativeX, null, useMipMaps, false), positiveY == null ? null : new PixmapTextureData(positiveY,
-			null, useMipMaps, false), negativeY == null ? null : new PixmapTextureData(negativeY, null, useMipMaps, false),
-			positiveZ == null ? null : new PixmapTextureData(positiveZ, null, useMipMaps, false), negativeZ == null ? null
-				: new PixmapTextureData(negativeZ, null, useMipMaps, false));
-	}
-
-	/** Construct a Cubemap with {@link Pixmap}s for each side of the specified size. */
-	public FacedCubemapData (int width, int height, int depth, Format format) {
-		this(new PixmapTextureData(new Pixmap(depth, height, format), null, false, true), new PixmapTextureData(new Pixmap(depth,
-			height, format), null, false, true), new PixmapTextureData(new Pixmap(width, depth, format), null, false, true),
-			new PixmapTextureData(new Pixmap(width, depth, format), null, false, true), new PixmapTextureData(new Pixmap(width,
-				height, format), null, false, true), new PixmapTextureData(new Pixmap(width, height, format), null, false, true));
-	}
-
-	/** Construct a Cubemap with the specified {@link TextureData}'s for the sides */
-	public FacedCubemapData (TextureData positiveX, TextureData negativeX, TextureData positiveY, TextureData negativeY,
-		TextureData positiveZ, TextureData negativeZ) {
-		data[0] = positiveX;
-		data[1] = negativeX;
-		data[2] = positiveY;
-		data[3] = negativeY;
-		data[4] = positiveZ;
-		data[5] = negativeZ;
-	}
-
-	@Override
-	public boolean isManaged () {
-		for (TextureData data : this.data)
-			if (!data.isManaged()) return false;
-		return true;
-	}
-
-	/** Loads the texture specified using the {@link FileHandle} and sets it to specified side, overwriting any previous data set to
-	 * that side. Note that you need to reload through {@link Cubemap#load(CubemapData)} any cubemap using this data for the change
-	 * to be taken in account.
-	 * @param side The {@link CubemapSide}
-	 * @param file The texture {@link FileHandle} */
-	public void load (CubemapSide side, FileHandle file) {
-		data[side.index] = TextureData.Factory.loadFromFile(file, false);
-	}
-
-	/** Sets the specified side of this cubemap to the specified {@link Pixmap}, overwriting any previous data set to that side.
-	 * Note that you need to reload through {@link Cubemap#load(CubemapData)} any cubemap using this data for the change to be
-	 * taken in account.
-	 * @param side The {@link CubemapSide}
-	 * @param pixmap The {@link Pixmap} */
-	public void load (CubemapSide side, Pixmap pixmap) {
-		data[side.index] = pixmap == null ? null : new PixmapTextureData(pixmap, null, false, false);
-	}
-
-	/** @return True if all sides of this cubemap are set, false otherwise. */
-	public boolean isComplete () {
-		for (int i = 0; i < data.length; i++)
-			if (data[i] == null) return false;
-		return true;
-	}
-
-	/** @return The {@link TextureData} for the specified side, can be null if the cubemap is incomplete. */
-	public TextureData getTextureData (CubemapSide side) {
-		return data[side.index];
-	}
-
-	@Override
-	public int getWidth () {
-		int tmp, width = 0;
-		if (data[CubemapSide.PositiveZ.index] != null && (tmp = data[CubemapSide.PositiveZ.index].getWidth()) > width) width = tmp;
-		if (data[CubemapSide.NegativeZ.index] != null && (tmp = data[CubemapSide.NegativeZ.index].getWidth()) > width) width = tmp;
-		if (data[CubemapSide.PositiveY.index] != null && (tmp = data[CubemapSide.PositiveY.index].getWidth()) > width) width = tmp;
-		if (data[CubemapSide.NegativeY.index] != null && (tmp = data[CubemapSide.NegativeY.index].getWidth()) > width) width = tmp;
-		return width;
-	}
-
-	@Override
-	public int getHeight () {
-		int tmp, height = 0;
-		if (data[CubemapSide.PositiveZ.index] != null && (tmp = data[CubemapSide.PositiveZ.index].getHeight()) > height)
-			height = tmp;
-		if (data[CubemapSide.NegativeZ.index] != null && (tmp = data[CubemapSide.NegativeZ.index].getHeight()) > height)
-			height = tmp;
-		if (data[CubemapSide.PositiveX.index] != null && (tmp = data[CubemapSide.PositiveX.index].getHeight()) > height)
-			height = tmp;
-		if (data[CubemapSide.NegativeX.index] != null && (tmp = data[CubemapSide.NegativeX.index].getHeight()) > height)
-			height = tmp;
-		return height;
-	}
-
-	@Override
-	public boolean isPrepared () {
-		return false;
-	}
-
-	@Override
-	public void prepare () {
-		if (!isComplete()) throw new GdxRuntimeException("You need to complete your cubemap data before using it");
-		for (int i = 0; i < data.length; i++)
-			if (!data[i].isPrepared()) data[i].prepare();
-	}
-
-	@Override
-	public void consumeCubemapData () {
-		for (int i = 0; i < data.length; i++) {
-			if (data[i].getType() == TextureData.TextureDataType.Custom) {
-				data[i].consumeCustomData(GL20.GL_TEXTURE_CUBE_MAP_POSITIVE_X + i);
-			} else {
-				Pixmap pixmap = data[i].consumePixmap();
-				boolean disposePixmap = data[i].disposePixmap();
-				if (data[i].getFormat() != pixmap.getFormat()) {
-					Pixmap tmp = new Pixmap(pixmap.getWidth(), pixmap.getHeight(), data[i].getFormat());
-					Blending blend = Pixmap.getBlending();
-					Pixmap.setBlending(Blending.None);
-					tmp.drawPixmap(pixmap, 0, 0, 0, 0, pixmap.getWidth(), pixmap.getHeight());
-					Pixmap.setBlending(blend);
-					if (data[i].disposePixmap()) pixmap.dispose();
-					pixmap = tmp;
-					disposePixmap = true;
-				}
-				Gdx.gl.glPixelStorei(GL20.GL_UNPACK_ALIGNMENT, 1);
-				Gdx.gl.glTexImage2D(GL20.GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, pixmap.getGLInternalFormat(), pixmap.getWidth(),
-					pixmap.getHeight(), 0, pixmap.getGLFormat(), pixmap.getGLType(), pixmap.getPixels());
-			}
-		}
-	}
-
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/FrameBuffer.java b/gdx/src/com/badlogic/gdx/graphics/glutils/FrameBuffer.java
index feafab0..b965569 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/FrameBuffer.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/FrameBuffer.java
@@ -33,6 +33,7 @@ import com.badlogic.gdx.graphics.Texture.TextureWrap;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.BufferUtils;
 import com.badlogic.gdx.utils.Disposable;
+import com.badlogic.gdx.utils.GdxRuntimeException;
 
 /** <p>
  * Encapsulates OpenGL ES 2.0 frame buffer objects. This is a simple helper class which should cover most FBO uses. It will
@@ -142,15 +143,20 @@ public class FrameBuffer implements Disposable {
 
 		setupTexture();
 
-		
-		framebufferHandle = gl.glGenFramebuffer();
+		IntBuffer handle = BufferUtils.newIntBuffer(1);
+		gl.glGenFramebuffers(1, handle);
+		framebufferHandle = handle.get(0);
 
 		if (hasDepth) {
-			depthbufferHandle = gl.glGenRenderbuffer();
+			handle.clear();
+			gl.glGenRenderbuffers(1, handle);
+			depthbufferHandle = handle.get(0);
 		}
 
 		if (hasStencil) {
-			stencilbufferHandle = gl.glGenRenderbuffer();
+			handle.clear();
+			gl.glGenRenderbuffers(1, handle);
+			stencilbufferHandle = handle.get(0);
 		}
 
 		gl.glBindTexture(GL20.GL_TEXTURE_2D, colorTexture.getTextureObjectHandle());
@@ -185,14 +191,24 @@ public class FrameBuffer implements Disposable {
 
 		if (result != GL20.GL_FRAMEBUFFER_COMPLETE) {
 			colorTexture.dispose();
-			
-			if (hasDepth)
-				gl.glDeleteRenderbuffer(depthbufferHandle);
+			if (hasDepth) {
+				handle.clear();
+				handle.put(depthbufferHandle);
+				handle.flip();
+				gl.glDeleteRenderbuffers(1, handle);
+			}
 
-			if (hasStencil)
-				gl.glDeleteRenderbuffer(stencilbufferHandle);
+			if (hasStencil) {
+				handle.clear();
+				handle.put(stencilbufferHandle);
+				handle.flip();
+				gl.glDeleteRenderbuffers(1, handle);
+			}
 
-			gl.glDeleteFramebuffer(framebufferHandle);
+			handle.clear();
+			handle.put(framebufferHandle);
+			handle.flip();
+			gl.glDeleteFramebuffers(1, handle);
 
 			if (result == GL20.GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT)
 				throw new IllegalStateException("frame buffer couldn't be constructed: incomplete attachment");
@@ -213,13 +229,22 @@ public class FrameBuffer implements Disposable {
 		IntBuffer handle = BufferUtils.newIntBuffer(1);
 
 		colorTexture.dispose();
-		if (hasDepth)
-			gl.glDeleteRenderbuffer(depthbufferHandle);
+		if (hasDepth) {
+			handle.put(depthbufferHandle);
+			handle.flip();
+			gl.glDeleteRenderbuffers(1, handle);
+		}
 
-		if (hasStencil)
-			gl.glDeleteRenderbuffer(stencilbufferHandle);
+		if (hasStencil) {
+			handle.put(stencilbufferHandle);
+			handle.flip();
+			gl.glDeleteRenderbuffers(1, handle);
+		}
 
-		gl.glDeleteFramebuffer(framebufferHandle);
+		handle.clear();
+		handle.put(framebufferHandle);
+		handle.flip();
+		gl.glDeleteFramebuffers(1, handle);
 
 		if (buffers.get(Gdx.app) != null) buffers.get(Gdx.app).removeValue(this, true);
 	}
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/IndexArray.java b/gdx/src/com/badlogic/gdx/graphics/glutils/IndexArray.java
index 782d32c..79e048a 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/IndexArray.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/IndexArray.java
@@ -16,7 +16,6 @@
 
 package com.badlogic.gdx.graphics.glutils;
 
-import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.IntBuffer;
 import java.nio.ShortBuffer;
@@ -68,17 +67,6 @@ public class IndexArray implements IndexData {
 		byteBuffer.position(0);
 		byteBuffer.limit(count << 1);
 	}
-	
-	public void setIndices (ShortBuffer indices) {
-		int pos = indices.position();
-		buffer.clear();
-		buffer.limit(indices.remaining());
-		buffer.put(indices);
-		buffer.flip();
-		indices.position(pos);
-		byteBuffer.position(0);
-		byteBuffer.limit(buffer.limit() << 1);
-	}
 
 	/** <p>
 	 * Returns the underlying ShortBuffer. If you modify the buffer contents they wil be uploaded on the call to {@link #bind()}.
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/IndexBufferObject.java b/gdx/src/com/badlogic/gdx/graphics/glutils/IndexBufferObject.java
index dc69df4..b321afe 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/IndexBufferObject.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/IndexBufferObject.java
@@ -17,6 +17,7 @@
 package com.badlogic.gdx.graphics.glutils;
 
 import java.nio.ByteBuffer;
+import java.nio.IntBuffer;
 import java.nio.ShortBuffer;
 
 import com.badlogic.gdx.Gdx;
@@ -45,6 +46,8 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
  * 
  * @author mzechner */
 public class IndexBufferObject implements IndexData {
+	final static IntBuffer tmpHandle = BufferUtils.newIntBuffer(1);
+
 	ShortBuffer buffer;
 	ByteBuffer byteBuffer;
 	int bufferHandle;
@@ -64,7 +67,7 @@ public class IndexBufferObject implements IndexData {
 		buffer = byteBuffer.asShortBuffer();
 		buffer.flip();
 		byteBuffer.flip();
-		bufferHandle = Gdx.gl20.glGenBuffer();
+		bufferHandle = createBufferObject();
 		usage = isStatic ? GL20.GL_STATIC_DRAW : GL20.GL_DYNAMIC_DRAW;
 	}
 
@@ -78,10 +81,15 @@ public class IndexBufferObject implements IndexData {
 		buffer = byteBuffer.asShortBuffer();
 		buffer.flip();
 		byteBuffer.flip();
-		bufferHandle = Gdx.gl20.glGenBuffer();
+		bufferHandle = createBufferObject();
 		usage = GL20.GL_STATIC_DRAW;
 	}
 
+	private int createBufferObject () {
+		Gdx.gl20.glGenBuffers(1, tmpHandle);
+		return tmpHandle.get(0);
+	}
+
 	/** @return the number of indices currently stored in this buffer */
 	public int getNumIndices () {
 		return buffer.limit();
@@ -117,23 +125,6 @@ public class IndexBufferObject implements IndexData {
 			isDirty = false;
 		}
 	}
-	
-	public void setIndices (ShortBuffer indices) {
-		isDirty = true;
-		int pos = indices.position();
-		buffer.clear();
-		buffer.put(indices);
-		buffer.flip();
-		indices.position(pos);
-		byteBuffer.position(0);
-		byteBuffer.limit(buffer.limit() << 1);
-		
-		if (isBound) {
-			Gdx.gl20.glBufferData(GL20.GL_ELEMENT_ARRAY_BUFFER, byteBuffer.limit(), byteBuffer, usage);
-			isDirty = false;
-		}
-	}
-
 
 	/** <p>
 	 * Returns the underlying ShortBuffer. If you modify the buffer contents they wil be uploaded on the call to {@link #bind()}.
@@ -167,14 +158,17 @@ public class IndexBufferObject implements IndexData {
 
 	/** Invalidates the IndexBufferObject so a new OpenGL buffer handle is created. Use this in case of a context loss. */
 	public void invalidate () {
-		bufferHandle = Gdx.gl20.glGenBuffer();
+		bufferHandle = createBufferObject();
 		isDirty = true;
 	}
 
 	/** Disposes this IndexBufferObject and all its associated OpenGL resources. */
 	public void dispose () {
+		tmpHandle.clear();
+		tmpHandle.put(bufferHandle);
+		tmpHandle.flip();
 		Gdx.gl20.glBindBuffer(GL20.GL_ELEMENT_ARRAY_BUFFER, 0);
-		Gdx.gl20.glDeleteBuffer(bufferHandle);
+		Gdx.gl20.glDeleteBuffers(1, tmpHandle);
 		bufferHandle = 0;
 
 		BufferUtils.disposeUnsafeByteBuffer(byteBuffer);
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/IndexBufferObjectSubData.java b/gdx/src/com/badlogic/gdx/graphics/glutils/IndexBufferObjectSubData.java
index 6b6ac8d..072d05c 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/IndexBufferObjectSubData.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/IndexBufferObjectSubData.java
@@ -17,6 +17,7 @@
 package com.badlogic.gdx.graphics.glutils;
 
 import java.nio.ByteBuffer;
+import java.nio.IntBuffer;
 import java.nio.ShortBuffer;
 
 import com.badlogic.gdx.Gdx;
@@ -45,6 +46,8 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
  * 
  * @author mzechner */
 public class IndexBufferObjectSubData implements IndexData {
+	final static IntBuffer tmpHandle = BufferUtils.newIntBuffer(1);
+
 	ShortBuffer buffer;
 	ByteBuffer byteBuffer;
 	int bufferHandle;
@@ -83,11 +86,11 @@ public class IndexBufferObjectSubData implements IndexData {
 	}
 
 	private int createBufferObject () {
-		int result = Gdx.gl20.glGenBuffer();
-		Gdx.gl20.glBindBuffer(GL20.GL_ELEMENT_ARRAY_BUFFER, result);
+		Gdx.gl20.glGenBuffers(1, tmpHandle);
+		Gdx.gl20.glBindBuffer(GL20.GL_ELEMENT_ARRAY_BUFFER, tmpHandle.get(0));
 		Gdx.gl20.glBufferData(GL20.GL_ELEMENT_ARRAY_BUFFER, byteBuffer.capacity(), null, usage);
 		Gdx.gl20.glBindBuffer(GL20.GL_ELEMENT_ARRAY_BUFFER, 0);
-		return result;
+		return tmpHandle.get(0);
 	}
 
 	/** @return the number of indices currently stored in this buffer */
@@ -126,23 +129,6 @@ public class IndexBufferObjectSubData implements IndexData {
 		}
 	}
 
-	public void setIndices (ShortBuffer indices) {
-		int pos = indices.position();
-		isDirty = true;
-		buffer.clear();
-		buffer.put(indices);
-		buffer.flip();
-		indices.position(pos);
-		byteBuffer.position(0);
-		byteBuffer.limit(buffer.limit() << 1);
-		
-		if (isBound) {
-			Gdx.gl20.glBufferSubData(GL20.GL_ELEMENT_ARRAY_BUFFER, 0, byteBuffer.limit(), byteBuffer);
-			isDirty = false;
-		}
-	}
-
-	
 	/** <p>
 	 * Returns the underlying ShortBuffer. If you modify the buffer contents they wil be uploaded on the call to {@link #bind()}.
 	 * If you need immediate uploading use {@link #setIndices(short[], int, int)}.
@@ -181,9 +167,12 @@ public class IndexBufferObjectSubData implements IndexData {
 
 	/** Disposes this IndexBufferObject and all its associated OpenGL resources. */
 	public void dispose () {
+		tmpHandle.clear();
+		tmpHandle.put(bufferHandle);
+		tmpHandle.flip();
 		GL20 gl = Gdx.gl20;
 		gl.glBindBuffer(GL20.GL_ELEMENT_ARRAY_BUFFER, 0);
-		gl.glDeleteBuffer(bufferHandle);
+		gl.glDeleteBuffers(1, tmpHandle);
 		bufferHandle = 0;
 	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/IndexData.java b/gdx/src/com/badlogic/gdx/graphics/glutils/IndexData.java
index 3d6b57f..d1bf840 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/IndexData.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/IndexData.java
@@ -16,7 +16,6 @@
 
 package com.badlogic.gdx.graphics.glutils;
 
-import java.nio.Buffer;
 import java.nio.ShortBuffer;
 
 import com.badlogic.gdx.utils.Disposable;
@@ -39,18 +38,11 @@ public interface IndexData extends Disposable {
 	 * This can be called in between calls to {@link #bind()} and {@link #unbind()}. The index data will be updated instantly.
 	 * </p>
 	 * 
-	 * @param indices the index data
+	 * @param indices the vertex data
 	 * @param offset the offset to start copying the data from
-	 * @param count the number of shorts to copy */
+	 * @param count the number of floats to copy */
 	public void setIndices (short[] indices, int offset, int count);
 
-	/** Copies the specified indices to the indices of this IndexBufferObject, discarding the old indices. Copying start at the
-	 * current {@link ShortBuffer#position()} of the specified buffer and copied the {@link ShortBuffer#remaining()} amount of
-	 * indices. This can be called in between calls to {@link #bind()} and {@link #unbind()}. The index data will be updated
-	 * instantly.
-	 * @param indices the index data to copy */
-	public void setIndices (ShortBuffer indices);
-
 	/** <p>
 	 * Returns the underlying ShortBuffer. If you modify the buffer contents they wil be uploaded on the call to {@link #bind()}.
 	 * If you need immediate uploading use {@link #setIndices(short[], int, int)}.
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/KTXTextureData.java b/gdx/src/com/badlogic/gdx/graphics/glutils/KTXTextureData.java
deleted file mode 100644
index 0b42b47..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/KTXTextureData.java
+++ /dev/null
@@ -1,359 +0,0 @@
-
-package com.badlogic.gdx.graphics.glutils;
-
-import java.io.BufferedInputStream;
-import java.io.DataInputStream;
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.nio.IntBuffer;
-import java.util.zip.GZIPInputStream;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.Cubemap;
-import com.badlogic.gdx.graphics.CubemapData;
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.Pixmap;
-import com.badlogic.gdx.graphics.Pixmap.Format;
-import com.badlogic.gdx.graphics.Texture;
-import com.badlogic.gdx.graphics.TextureData;
-import com.badlogic.gdx.graphics.glutils.ETC1.ETC1Data;
-import com.badlogic.gdx.utils.BufferUtils;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-import com.badlogic.gdx.utils.StreamUtils;
-
-/** A KTXTextureData holds the data from a KTX (or zipped KTX file, aka ZKTX). That is to say an OpenGL ready texture data. The KTX
- * file format is just a thin wrapper around OpenGL textures and therefore is compatible with most OpenGL texture capabilities
- * like texture compression, cubemapping, mipmapping, etc.
- * 
- * For example, KTXTextureData can be used for {@link Texture} or {@link Cubemap}.
- * 
- * @author Vincent Bousquet */
-public class KTXTextureData implements TextureData, CubemapData {
-
-	// The file we are loading
-	private FileHandle file;
-
-	// KTX header (only available after preparing)
-	private int glType;
-	private int glTypeSize;
-	private int glFormat;
-	private int glInternalFormat;
-	private int glBaseInternalFormat;
-	private int pixelWidth = -1;
-	private int pixelHeight = -1;
-	private int pixelDepth = -1;
-	private int numberOfArrayElements;
-	private int numberOfFaces;
-	private int numberOfMipmapLevels;
-	private int imagePos;
-
-	// KTX image data (only available after preparing and before consuming)
-	private ByteBuffer compressedData;
-
-	// Whether to generate mipmaps if they are not included in the file
-	private boolean useMipMaps;
-
-	public KTXTextureData (FileHandle file, boolean genMipMaps) {
-		this.file = file;
-		this.useMipMaps = genMipMaps;
-	}
-
-	@Override
-	public TextureDataType getType () {
-		return TextureDataType.Custom;
-	}
-
-	@Override
-	public boolean isPrepared () {
-		return compressedData != null;
-	}
-
-	@Override
-	public void prepare () {
-		if (compressedData != null) throw new GdxRuntimeException("Already prepared");
-		if (file == null) throw new GdxRuntimeException("Need a file to load from");
-		// We support normal ktx files as well as 'zktx' which are gzip ktx file with an int length at the beginning (like ETC1).
-		if (file.name().endsWith(".zktx")) {
-			byte[] buffer = new byte[1024 * 10];
-			DataInputStream in = null;
-			try {
-				in = new DataInputStream(new BufferedInputStream(new GZIPInputStream(file.read())));
-				int fileSize = in.readInt();
-				compressedData = BufferUtils.newUnsafeByteBuffer(fileSize);
-				int readBytes = 0;
-				while ((readBytes = in.read(buffer)) != -1)
-					compressedData.put(buffer, 0, readBytes);
-				compressedData.position(0);
-				compressedData.limit(compressedData.capacity());
-			} catch (Exception e) {
-				throw new GdxRuntimeException("Couldn't load zktx file '" + file + "'", e);
-			} finally {
-				StreamUtils.closeQuietly(in);
-			}
-		} else {
-			compressedData = ByteBuffer.wrap(file.readBytes());
-		}
-		if (compressedData.get() != (byte)0x0AB) throw new GdxRuntimeException("Invalid KTX Header");
-		if (compressedData.get() != (byte)0x04B) throw new GdxRuntimeException("Invalid KTX Header");
-		if (compressedData.get() != (byte)0x054) throw new GdxRuntimeException("Invalid KTX Header");
-		if (compressedData.get() != (byte)0x058) throw new GdxRuntimeException("Invalid KTX Header");
-		if (compressedData.get() != (byte)0x020) throw new GdxRuntimeException("Invalid KTX Header");
-		if (compressedData.get() != (byte)0x031) throw new GdxRuntimeException("Invalid KTX Header");
-		if (compressedData.get() != (byte)0x031) throw new GdxRuntimeException("Invalid KTX Header");
-		if (compressedData.get() != (byte)0x0BB) throw new GdxRuntimeException("Invalid KTX Header");
-		if (compressedData.get() != (byte)0x00D) throw new GdxRuntimeException("Invalid KTX Header");
-		if (compressedData.get() != (byte)0x00A) throw new GdxRuntimeException("Invalid KTX Header");
-		if (compressedData.get() != (byte)0x01A) throw new GdxRuntimeException("Invalid KTX Header");
-		if (compressedData.get() != (byte)0x00A) throw new GdxRuntimeException("Invalid KTX Header");
-		int endianTag = compressedData.getInt();
-		if (endianTag != 0x04030201 && endianTag != 0x01020304) throw new GdxRuntimeException("Invalid KTX Header");
-		if (endianTag != 0x04030201)
-			compressedData.order(compressedData.order() == ByteOrder.BIG_ENDIAN ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);
-		glType = compressedData.getInt();
-		glTypeSize = compressedData.getInt();
-		glFormat = compressedData.getInt();
-		glInternalFormat = compressedData.getInt();
-		glBaseInternalFormat = compressedData.getInt();
-		pixelWidth = compressedData.getInt();
-		pixelHeight = compressedData.getInt();
-		pixelDepth = compressedData.getInt();
-		numberOfArrayElements = compressedData.getInt();
-		numberOfFaces = compressedData.getInt();
-		numberOfMipmapLevels = compressedData.getInt();
-		if (numberOfMipmapLevels == 0) {
-			numberOfMipmapLevels = 1;
-			useMipMaps = true;
-		}
-		int bytesOfKeyValueData = compressedData.getInt();
-		imagePos = compressedData.position() + bytesOfKeyValueData;
-		if (!compressedData.isDirect()) {
-			int pos = imagePos;
-			for (int level = 0; level < numberOfMipmapLevels; level++) {
-				int faceLodSize = compressedData.getInt(pos);
-				int faceLodSizeRounded = (faceLodSize + 3) & ~3;
-				pos += faceLodSizeRounded * numberOfFaces + 4;
-			}
-			compressedData.limit(pos);
-			compressedData.position(0);
-			ByteBuffer directBuffer = BufferUtils.newUnsafeByteBuffer(pos);
-			directBuffer.order(compressedData.order());
-			directBuffer.put(compressedData);
-			compressedData = directBuffer;
-		}
-	}
-
-	private static final int GL_TEXTURE_1D = 0x1234;
-	private static final int GL_TEXTURE_3D = 0x1234;
-	private static final int GL_TEXTURE_1D_ARRAY_EXT = 0x1234;
-	private static final int GL_TEXTURE_2D_ARRAY_EXT = 0x1234;
-
-	@Override
-	public void consumeCubemapData () {
-		consumeCustomData(GL20.GL_TEXTURE_CUBE_MAP);
-	}
-
-	@Override
-	public void consumeCustomData (int target) {
-		if (compressedData == null) throw new GdxRuntimeException("Call prepare() before calling consumeCompressedData()");
-		IntBuffer buffer = BufferUtils.newIntBuffer(16);
-
-		// Check OpenGL type and format, detect compressed data format (no type & format)
-		boolean compressed = false;
-		if (glType == 0 || glFormat == 0) {
-			if (glType + glFormat != 0) throw new GdxRuntimeException("either both or none of glType, glFormat must be zero");
-			compressed = true;
-		}
-
-		// find OpenGL texture target and dimensions
-		int textureDimensions = 1;
-		int glTarget = GL_TEXTURE_1D;
-		if (pixelHeight > 0) {
-			textureDimensions = 2;
-			glTarget = GL20.GL_TEXTURE_2D;
-		}
-		if (pixelDepth > 0) {
-			textureDimensions = 3;
-			glTarget = GL_TEXTURE_3D;
-		}
-		if (numberOfFaces == 6) {
-			if (textureDimensions == 2)
-				glTarget = GL20.GL_TEXTURE_CUBE_MAP;
-			else
-				throw new GdxRuntimeException("cube map needs 2D faces");
-		} else if (numberOfFaces != 1) {
-			throw new GdxRuntimeException("numberOfFaces must be either 1 or 6");
-		}
-		if (numberOfArrayElements > 0) {
-			if (glTarget == GL_TEXTURE_1D)
-				glTarget = GL_TEXTURE_1D_ARRAY_EXT;
-			else if (glTarget == GL20.GL_TEXTURE_2D)
-				glTarget = GL_TEXTURE_2D_ARRAY_EXT;
-			else
-				throw new GdxRuntimeException("No API for 3D and cube arrays yet");
-			textureDimensions++;
-		}
-		if (glTarget == 0x1234)
-			throw new GdxRuntimeException("Unsupported texture format (only 2D texture are supported in LibGdx for the time being)");
-
-		int singleFace = -1;
-		if (numberOfFaces == 6 && target != GL20.GL_TEXTURE_CUBE_MAP) {
-			// Load a single face of the cube (should be avoided since the data is unloaded afterwards)
-			if (!(GL20.GL_TEXTURE_CUBE_MAP_POSITIVE_X <= target && target <= GL20.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z))
-				throw new GdxRuntimeException(
-					"You must specify either GL_TEXTURE_CUBE_MAP to bind all 6 faces of the cube or the requested face GL_TEXTURE_CUBE_MAP_POSITIVE_X and followings.");
-			singleFace = target - GL20.GL_TEXTURE_CUBE_MAP_POSITIVE_X;
-			target = GL20.GL_TEXTURE_CUBE_MAP_POSITIVE_X;
-		} else if (numberOfFaces == 6 && target == GL20.GL_TEXTURE_CUBE_MAP) {
-			// Load the 6 faces
-			target = GL20.GL_TEXTURE_CUBE_MAP_POSITIVE_X;
-		} else {
-			// Load normal texture
-			if (target != glTarget
-				&& !(GL20.GL_TEXTURE_CUBE_MAP_POSITIVE_X <= target && target <= GL20.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z && target == GL20.GL_TEXTURE_2D))
-				throw new GdxRuntimeException("Invalid target requested : 0x" + Integer.toHexString(target) + ", expecting : 0x"
-					+ Integer.toHexString(glTarget));
-		}
-
-		// KTX files require an unpack alignment of 4
-		Gdx.gl.glGetIntegerv(GL20.GL_UNPACK_ALIGNMENT, buffer);
-		int previousUnpackAlignment = buffer.get(0);
-		if (previousUnpackAlignment != 4) Gdx.gl.glPixelStorei(GL20.GL_UNPACK_ALIGNMENT, 4);
-		int glInternalFormat = this.glInternalFormat;
-		int glFormat = this.glFormat;
-		int pos = imagePos;
-		for (int level = 0; level < numberOfMipmapLevels; level++) {
-			int pixelWidth = Math.max(1, this.pixelWidth >> level);
-			int pixelHeight = Math.max(1, this.pixelHeight >> level);
-			int pixelDepth = Math.max(1, this.pixelDepth >> level);
-			compressedData.position(pos);
-			int faceLodSize = compressedData.getInt();
-			int faceLodSizeRounded = (faceLodSize + 3) & ~3;
-			pos += 4;
-			for (int face = 0; face < numberOfFaces; face++) {
-				compressedData.position(pos);
-				pos += faceLodSizeRounded;
-				if (singleFace != -1 && singleFace != face) continue;
-				ByteBuffer data = compressedData.slice();
-				data.limit(faceLodSizeRounded);
-				if (textureDimensions == 1) {
-					// if (compressed)
-					// Gdx.gl.glCompressedTexImage1D(target + face, level, glInternalFormat, pixelWidth, 0, faceLodSize,
-					// data);
-					// else
-					// Gdx.gl.glTexImage1D(target + face, level, glInternalFormat, pixelWidth, 0, glFormat, glType, data);
-				} else if (textureDimensions == 2) {
-					if (numberOfArrayElements > 0) pixelHeight = numberOfArrayElements;
-					if (compressed) {
-						if (glInternalFormat == ETC1.ETC1_RGB8_OES) {
-							if (!Gdx.graphics.supportsExtension("GL_OES_compressed_ETC1_RGB8_texture")) {
-								ETC1Data etcData = new ETC1Data(pixelWidth, pixelHeight, data, 0);
-								Pixmap pixmap = ETC1.decodeImage(etcData, Format.RGB888);
-								Gdx.gl.glTexImage2D(target + face, level, pixmap.getGLInternalFormat(), pixmap.getWidth(),
-									pixmap.getHeight(), 0, pixmap.getGLFormat(), pixmap.getGLType(), pixmap.getPixels());
-								pixmap.dispose();
-							} else {
-								Gdx.gl.glCompressedTexImage2D(target + face, level, glInternalFormat, pixelWidth, pixelHeight, 0,
-									faceLodSize, data);
-							}
-						} else {
-							// Try to load (no software unpacking fallback)
-							Gdx.gl.glCompressedTexImage2D(target + face, level, glInternalFormat, pixelWidth, pixelHeight, 0,
-								faceLodSize, data);
-						}
-					} else
-						Gdx.gl.glTexImage2D(target + face, level, glInternalFormat, pixelWidth, pixelHeight, 0, glFormat, glType, data);
-				} else if (textureDimensions == 3) {
-					if (numberOfArrayElements > 0) pixelDepth = numberOfArrayElements;
-					// if (compressed)
-					// Gdx.gl.glCompressedTexImage3D(target + face, level, glInternalFormat, pixelWidth, pixelHeight, pixelDepth, 0,
-					// faceLodSize, data);
-					// else
-					// Gdx.gl.glTexImage3D(target + face, level, glInternalFormat, pixelWidth, pixelHeight, pixelDepth, 0, glFormat,
-					// glType, data);
-				}
-			}
-		}
-		if (previousUnpackAlignment != 4) Gdx.gl.glPixelStorei(GL20.GL_UNPACK_ALIGNMENT, previousUnpackAlignment);
-		if (useMipMaps()) Gdx.gl.glGenerateMipmap(target);
-
-		// dispose data once transfered to GPU
-		disposePreparedData();
-	}
-
-	public void disposePreparedData () {
-		if (compressedData != null) BufferUtils.disposeUnsafeByteBuffer(compressedData);
-		compressedData = null;
-	}
-
-	@Override
-	public Pixmap consumePixmap () {
-		throw new GdxRuntimeException("This TextureData implementation does not return a Pixmap");
-	}
-
-	@Override
-	public boolean disposePixmap () {
-		throw new GdxRuntimeException("This TextureData implementation does not return a Pixmap");
-	}
-
-	@Override
-	public int getWidth () {
-		return pixelWidth;
-	}
-
-	@Override
-	public int getHeight () {
-		return pixelHeight;
-	}
-
-	public int getNumberOfMipMapLevels () {
-		return numberOfMipmapLevels;
-	}
-
-	public int getNumberOfFaces () {
-		return numberOfFaces;
-	}
-
-	public int getGlInternalFormat () {
-		return glInternalFormat;
-	}
-
-	public ByteBuffer getData (int requestedLevel, int requestedFace) {
-		int pos = imagePos;
-		for (int level = 0; level < numberOfMipmapLevels; level++) {
-			int faceLodSize = compressedData.getInt(pos);
-			int faceLodSizeRounded = (faceLodSize + 3) & ~3;
-			pos += 4;
-			if (level == requestedLevel) {
-				for (int face = 0; face < numberOfFaces; face++) {
-					if (face == requestedFace) {
-						compressedData.position(pos);
-						ByteBuffer data = compressedData.slice();
-						data.limit(faceLodSizeRounded);
-						return data;
-					}
-					pos += faceLodSizeRounded;
-				}
-			} else {
-				pos += faceLodSizeRounded * numberOfFaces;
-			}
-		}
-		return null;
-	}
-
-	@Override
-	public Format getFormat () {
-		throw new GdxRuntimeException("This TextureData implementation directly handles texture formats.");
-	}
-
-	@Override
-	public boolean useMipMaps () {
-		return useMipMaps;
-	}
-
-	@Override
-	public boolean isManaged () {
-		return true;
-	}
-
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/ShaderProgram.java b/gdx/src/com/badlogic/gdx/graphics/glutils/ShaderProgram.java
index eeebf73..3e5211a 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/ShaderProgram.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/ShaderProgram.java
@@ -137,6 +137,11 @@ public class ShaderProgram implements Disposable {
 	/** whether this shader was invalidated **/
 	private boolean invalidated;
 
+	/** direct buffer for passing float and int uniform arrays **/
+	private ByteBuffer buffer = null;
+	private FloatBuffer floatBuffer = null;
+	private IntBuffer intBuffer = null;
+
 	/** reference count **/
 	private int refCount = 0;
 
@@ -290,7 +295,8 @@ public class ShaderProgram implements Disposable {
 		return location;
 	}
 
-	/** Sets the uniform with the given name. The {@link ShaderProgram} must be bound for this to work.
+	/** Sets the uniform with the given name. Throws an IllegalArgumentException in case it is not called in between a
+	 * {@link #begin()}/{@link #end()} block.
 	 * 
 	 * @param name the name of the uniform
 	 * @param value the value */
@@ -307,7 +313,8 @@ public class ShaderProgram implements Disposable {
 		gl.glUniform1i(location, value);
 	}
 
-	/** Sets the uniform with the given name. The {@link ShaderProgram} must be bound for this to work.
+	/** Sets the uniform with the given name. Throws an IllegalArgumentException in case it is not called in between a
+	 * {@link #begin()}/{@link #end()} block.
 	 * 
 	 * @param name the name of the uniform
 	 * @param value1 the first value
@@ -325,7 +332,8 @@ public class ShaderProgram implements Disposable {
 		gl.glUniform2i(location, value1, value2);
 	}
 
-	/** Sets the uniform with the given name. The {@link ShaderProgram} must be bound for this to work.
+	/** Sets the uniform with the given name. Throws an IllegalArgumentException in case it is not called in between a
+	 * {@link #begin()}/{@link #end()} block.
 	 * 
 	 * @param name the name of the uniform
 	 * @param value1 the first value
@@ -344,7 +352,8 @@ public class ShaderProgram implements Disposable {
 		gl.glUniform3i(location, value1, value2, value3);
 	}
 
-	/** Sets the uniform with the given name. The {@link ShaderProgram} must be bound for this to work.
+	/** Sets the uniform with the given name. Throws an IllegalArgumentException in case it is not called in between a
+	 * {@link #begin()}/{@link #end()} block.
 	 * 
 	 * @param name the name of the uniform
 	 * @param value1 the first value
@@ -364,7 +373,8 @@ public class ShaderProgram implements Disposable {
 		gl.glUniform4i(location, value1, value2, value3, value4);
 	}
 
-	/** Sets the uniform with the given name. The {@link ShaderProgram} must be bound for this to work.
+	/** Sets the uniform with the given name. Throws an IllegalArgumentException in case it is not called in between a
+	 * {@link #begin()}/{@link #end()} block.
 	 * 
 	 * @param name the name of the uniform
 	 * @param value the value */
@@ -381,7 +391,8 @@ public class ShaderProgram implements Disposable {
 		gl.glUniform1f(location, value);
 	}
 
-	/** Sets the uniform with the given name. The {@link ShaderProgram} must be bound for this to work.
+	/** Sets the uniform with the given name. Throws an IllegalArgumentException in case it is not called in between a
+	 * {@link #begin()}/{@link #end()} block.
 	 * 
 	 * @param name the name of the uniform
 	 * @param value1 the first value
@@ -399,7 +410,8 @@ public class ShaderProgram implements Disposable {
 		gl.glUniform2f(location, value1, value2);
 	}
 
-	/** Sets the uniform with the given name. The {@link ShaderProgram} must be bound for this to work.
+	/** Sets the uniform with the given name. Throws an IllegalArgumentException in case it is not called in between a
+	 * {@link #begin()}/{@link #end()} block.
 	 * 
 	 * @param name the name of the uniform
 	 * @param value1 the first value
@@ -418,7 +430,8 @@ public class ShaderProgram implements Disposable {
 		gl.glUniform3f(location, value1, value2, value3);
 	}
 
-	/** Sets the uniform with the given name. The {@link ShaderProgram} must be bound for this to work.
+	/** Sets the uniform with the given name. Throws an IllegalArgumentException in case it is not called in between a
+	 * {@link #begin()}/{@link #end()} block.
 	 * 
 	 * @param name the name of the uniform
 	 * @param value1 the first value
@@ -442,55 +455,80 @@ public class ShaderProgram implements Disposable {
 		GL20 gl = Gdx.gl20;
 		checkManaged();
 		int location = fetchUniformLocation(name);
-		gl.glUniform1fv(location, length, values, offset);
+		ensureBufferCapacity(length << 2);
+		floatBuffer.clear();
+		BufferUtils.copy(values, floatBuffer, length, offset);
+		gl.glUniform1fv(location, length, floatBuffer);
 	}
 
 	public void setUniform1fv (int location, float[] values, int offset, int length) {
 		GL20 gl = Gdx.gl20;
 		checkManaged();
-		gl.glUniform1fv(location, length, values, offset);
+		ensureBufferCapacity(length << 2);
+		floatBuffer.clear();
+		BufferUtils.copy(values, floatBuffer, length, offset);
+		gl.glUniform1fv(location, length, floatBuffer);
 	}
 
 	public void setUniform2fv (String name, float[] values, int offset, int length) {
 		GL20 gl = Gdx.gl20;
 		checkManaged();
 		int location = fetchUniformLocation(name);
-		gl.glUniform2fv(location, length / 2, values, offset);
+		ensureBufferCapacity(length << 2);
+		floatBuffer.clear();
+		BufferUtils.copy(values, floatBuffer, length, offset);
+		gl.glUniform2fv(location, length / 2, floatBuffer);
 	}
 
 	public void setUniform2fv (int location, float[] values, int offset, int length) {
 		GL20 gl = Gdx.gl20;
 		checkManaged();
-		gl.glUniform2fv(location, length / 2, values, offset);
+		ensureBufferCapacity(length << 2);
+		floatBuffer.clear();
+		BufferUtils.copy(values, floatBuffer, length, offset);
+		gl.glUniform2fv(location, length / 2, floatBuffer);
 	}
 
 	public void setUniform3fv (String name, float[] values, int offset, int length) {
 		GL20 gl = Gdx.gl20;
 		checkManaged();
 		int location = fetchUniformLocation(name);
-		gl.glUniform3fv(location, length / 3, values, offset);
+		ensureBufferCapacity(length << 2);
+		floatBuffer.clear();
+		BufferUtils.copy(values, floatBuffer, length, offset);
+		gl.glUniform3fv(location, length / 3, floatBuffer);
 	}
 
 	public void setUniform3fv (int location, float[] values, int offset, int length) {
 		GL20 gl = Gdx.gl20;
 		checkManaged();
-		gl.glUniform3fv(location, length / 3, values, offset);
+		ensureBufferCapacity(length << 2);
+		floatBuffer.clear();
+		BufferUtils.copy(values, floatBuffer, length, offset);
+		gl.glUniform3fv(location, length / 3, floatBuffer);
 	}
 
 	public void setUniform4fv (String name, float[] values, int offset, int length) {
 		GL20 gl = Gdx.gl20;
 		checkManaged();
 		int location = fetchUniformLocation(name);
-		gl.glUniform4fv(location, length / 4, values, offset);
+		ensureBufferCapacity(length << 2);
+		floatBuffer.clear();
+		BufferUtils.copy(values, floatBuffer, length, offset);
+		gl.glUniform4fv(location, length / 4, floatBuffer);
 	}
 
 	public void setUniform4fv (int location, float[] values, int offset, int length) {
 		GL20 gl = Gdx.gl20;
 		checkManaged();
-		gl.glUniform4fv(location, length / 4, values, offset);
+		ensureBufferCapacity(length << 2);
+		floatBuffer.clear();
+		BufferUtils.copy(values, floatBuffer, length, offset);
+		gl.glUniform4fv(location, length / 4, floatBuffer);
 	}
 
-	/** Sets the uniform matrix with the given name. The {@link ShaderProgram} must be bound for this to work.
+	/** Sets the uniform matrix with the given name. Throws an IllegalArgumentException in case it is not called in between a
+	 * {@link #begin()}/{@link #end()} block.
 	 * 
 	 * @param name the name of the uniform
 	 * @param matrix the matrix */
@@ -498,13 +536,19 @@ public class ShaderProgram implements Disposable {
 		setUniformMatrix(name, matrix, false);
 	}
 
-	/** Sets the uniform matrix with the given name. The {@link ShaderProgram} must be bound for this to work.
+	/** Sets the uniform matrix with the given name. Throws an IllegalArgumentException in case it is not called in between a
+	 * {@link #begin()}/{@link #end()} block.
 	 * 
 	 * @param name the name of the uniform
 	 * @param matrix the matrix
 	 * @param transpose whether the matrix should be transposed */
 	public void setUniformMatrix (String name, Matrix4 matrix, boolean transpose) {
-		setUniformMatrix(fetchUniformLocation(name), matrix, transpose); 
+		GL20 gl = Gdx.gl20;
+		checkManaged();
+		int location = fetchUniformLocation(name);
+		this.matrix.clear();
+		BufferUtils.copy(matrix.val, this.matrix, matrix.val.length, 0);
+		gl.glUniformMatrix4fv(location, 1, transpose, this.matrix);
 	}
 
 	public void setUniformMatrix (int location, Matrix4 matrix) {
@@ -514,10 +558,13 @@ public class ShaderProgram implements Disposable {
 	public void setUniformMatrix (int location, Matrix4 matrix, boolean transpose) {
 		GL20 gl = Gdx.gl20;
 		checkManaged();
-		gl.glUniformMatrix4fv(location, 1, transpose, matrix.val, 0);
+		this.matrix.clear();
+		BufferUtils.copy(matrix.val, this.matrix, matrix.val.length, 0);
+		gl.glUniformMatrix4fv(location, 1, transpose, this.matrix);
 	}
 
-	/** Sets the uniform matrix with the given name. The {@link ShaderProgram} must be bound for this to work.
+	/** Sets the uniform matrix with the given name. Throws an IllegalArgumentException in case it is not called in between a
+	 * {@link #begin()}/{@link #end()} block.
 	 * 
 	 * @param name the name of the uniform
 	 * @param matrix the matrix */
@@ -525,13 +572,20 @@ public class ShaderProgram implements Disposable {
 		setUniformMatrix(name, matrix, false);
 	}
 
-	/** Sets the uniform matrix with the given name. The {@link ShaderProgram} must be bound for this to work.
+	/** Sets the uniform matrix with the given name. Throws an IllegalArgumentException in case it is not called in between a
+	 * {@link #begin()}/{@link #end()} block.
 	 * 
 	 * @param name the name of the uniform
 	 * @param matrix the matrix
 	 * @param transpose whether the uniform matrix should be transposed */
 	public void setUniformMatrix (String name, Matrix3 matrix, boolean transpose) {
-		setUniformMatrix(fetchUniformLocation(name), matrix, transpose);
+		GL20 gl = Gdx.gl20;
+		checkManaged();
+		int location = fetchUniformLocation(name);
+		float[] vals = matrix.getValues();
+		this.matrix.clear();
+		BufferUtils.copy(vals, this.matrix, vals.length, 0);
+		gl.glUniformMatrix3fv(location, 1, transpose, this.matrix);
 	}
 
 	public void setUniformMatrix (int location, Matrix3 matrix) {
@@ -541,10 +595,14 @@ public class ShaderProgram implements Disposable {
 	public void setUniformMatrix (int location, Matrix3 matrix, boolean transpose) {
 		GL20 gl = Gdx.gl20;
 		checkManaged();
-		gl.glUniformMatrix3fv(location, 1, transpose, matrix.val, 0);
+		float[] vals = matrix.getValues();
+		this.matrix.clear();
+		BufferUtils.copy(vals, this.matrix, vals.length, 0);
+		gl.glUniformMatrix3fv(location, 1, transpose, this.matrix);
 	}
 
-	/** Sets an array of uniform matrices with the given name. The {@link ShaderProgram} must be bound for this to work.
+	/** Sets an array of uniform matrices with the given name. Throws an IllegalArgumentException in case it is not called in
+	 * between a {@link #begin()}/{@link #end()} block.
 	 * 
 	 * @param name the name of the uniform
 	 * @param buffer buffer containing the matrix data
@@ -557,7 +615,8 @@ public class ShaderProgram implements Disposable {
 		gl.glUniformMatrix3fv(location, count, transpose, buffer);
 	}
 
-	/** Sets an array of uniform matrices with the given name. The {@link ShaderProgram} must be bound for this to work.
+	/** Sets an array of uniform matrices with the given name. Throws an IllegalArgumentException in case it is not called in
+	 * between a {@link #begin()}/{@link #end()} block.
 	 * 
 	 * @param name the name of the uniform
 	 * @param buffer buffer containing the matrix data
@@ -573,14 +632,24 @@ public class ShaderProgram implements Disposable {
 	public void setUniformMatrix4fv (int location, float[] values, int offset, int length) {
 		GL20 gl = Gdx.gl20;
 		checkManaged();
-		gl.glUniformMatrix4fv(location, length / 16, false, values, offset);
+		ensureBufferCapacity(length << 2);
+		floatBuffer.clear();
+		BufferUtils.copy(values, floatBuffer, length, offset);
+		gl.glUniformMatrix4fv(location, length / 16, false, floatBuffer);
 	}
 
 	public void setUniformMatrix4fv (String name, float[] values, int offset, int length) {
-		setUniformMatrix4fv(fetchUniformLocation(name), values, offset, length);
+		GL20 gl = Gdx.gl20;
+		checkManaged();
+		ensureBufferCapacity(length << 2);
+		floatBuffer.clear();
+		BufferUtils.copy(values, floatBuffer, length, offset);
+		int location = fetchUniformLocation(name);
+		gl.glUniformMatrix4fv(location, length / 16, false, floatBuffer);
 	}
 
-	/** Sets the uniform with the given name. The {@link ShaderProgram} must be bound for this to work.
+	/** Sets the uniform with the given name. Throws an IllegalArgumentException in case it is not called in between a
+	 * {@link #begin()}/{@link #end()} block.
 	 * 
 	 * @param name the name of the uniform
 	 * @param values x and y as the first and second values respectively */
@@ -592,7 +661,8 @@ public class ShaderProgram implements Disposable {
 		setUniformf(location, values.x, values.y);
 	}
 
-	/** Sets the uniform with the given name. The {@link ShaderProgram} must be bound for this to work.
+	/** Sets the uniform with the given name. Throws an IllegalArgumentException in case it is not called in between a
+	 * {@link #begin()}/{@link #end()} block.
 	 * 
 	 * @param name the name of the uniform
 	 * @param values x, y and z as the first, second and third values respectively */
@@ -604,7 +674,8 @@ public class ShaderProgram implements Disposable {
 		setUniformf(location, values.x, values.y, values.z);
 	}
 
-	/** Sets the uniform with the given name. The {@link ShaderProgram} must be bound for this to work.
+	/** Sets the uniform with the given name. Throws an IllegalArgumentException in case it is not called in between a
+	 * {@link #begin()}/{@link #end()} block.
 	 * 
 	 * @param name the name of the uniform
 	 * @param values r, g, b and a as the first through fourth values respectively */
@@ -616,7 +687,8 @@ public class ShaderProgram implements Disposable {
 		setUniformf(location, values.r, values.g, values.b, values.a);
 	}
 
-	/** Sets the vertex attribute with the given name. The {@link ShaderProgram} must be bound for this to work.
+	/** Sets the vertex attribute with the given name. Throws an IllegalArgumentException in case it is not called in between a
+	 * {@link #begin()}/{@link #end()} block.
 	 * 
 	 * @param name the attribute name
 	 * @param size the number of components, must be >= 1 and <= 4
@@ -639,7 +711,8 @@ public class ShaderProgram implements Disposable {
 		gl.glVertexAttribPointer(location, size, type, normalize, stride, buffer);
 	}
 
-	/** Sets the vertex attribute with the given name. The {@link ShaderProgram} must be bound for this to work.
+	/** Sets the vertex attribute with the given name. Throws an IllegalArgumentException in case it is not called in between a
+	 * {@link #begin()}/{@link #end()} block.
 	 * 
 	 * @param name the attribute name
 	 * @param size the number of components, must be >= 1 and <= 4
@@ -778,6 +851,14 @@ public class ShaderProgram implements Disposable {
 		gl.glVertexAttrib4f(location, value1, value2, value3, value4);
 	}
 
+	private void ensureBufferCapacity (int numBytes) {
+		if (buffer == null || buffer.capacity() < numBytes) {
+			buffer = BufferUtils.newByteBuffer(numBytes);
+			floatBuffer = buffer.asFloatBuffer();
+			intBuffer = buffer.asIntBuffer();
+		}
+	}
+
 	IntBuffer params = BufferUtils.newIntBuffer(1);
 	IntBuffer type = BufferUtils.newIntBuffer(1);
 
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java b/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java
index 10c0e6d..ce3105e 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java
@@ -187,7 +187,7 @@ public class ShapeRenderer implements Disposable {
 	/** Begins a new batch without specifying a shape type.
 	 * @throws IllegalStateException if {@link #autoShapeType} is false. */
 	public void begin () {
-		if (!autoShapeType) throw new IllegalStateException("autoShapeType must be true to use this method.");
+		if (!autoShapeType) throw new IllegalStateException("");
 		begin(ShapeType.Line);
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexArray.java b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexArray.java
index 1e1bdcd..44b109a 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexArray.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexArray.java
@@ -19,11 +19,9 @@ package com.badlogic.gdx.graphics.glutils;
 import java.nio.ByteBuffer;
 import java.nio.FloatBuffer;
 
-import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.VertexAttribute;
 import com.badlogic.gdx.graphics.VertexAttributes;
-import com.badlogic.gdx.graphics.VertexAttributes.Usage;
 import com.badlogic.gdx.utils.BufferUtils;
 
 /** <p>
@@ -32,7 +30,7 @@ import com.badlogic.gdx.utils.BufferUtils;
  * </p>
  * 
  * <p>
- * This class does not support shaders and for that matter OpenGL ES 2.0. For this {@link VertexBufferObject}s are needed.
+ * This class is not compatible with OpenGL 3+ core profiles. For this {@link VertexBufferObject}s are needed.
  * </p>
  * 
  * @author mzechner, Dave Clayton <contact@redskyforge.com> */
@@ -103,7 +101,6 @@ public class VertexArray implements VertexData {
 
 	@Override
 	public void bind (final ShaderProgram shader, final int[] locations) {
-		final GL20 gl = Gdx.gl20;
 		final int numAttributes = attributes.size();
 		byteBuffer.limit(buffer.limit() * 4);
 		if (locations == null) {
@@ -154,7 +151,6 @@ public class VertexArray implements VertexData {
 
 	@Override
 	public void unbind (ShaderProgram shader, int[] locations) {
-		final GL20 gl = Gdx.gl20;
 		final int numAttributes = attributes.size();
 		if (locations == null) {
 			for (int i = 0; i < numAttributes; i++) {
@@ -173,8 +169,4 @@ public class VertexArray implements VertexData {
 	public VertexAttributes getAttributes () {
 		return attributes;
 	}
-	
-	@Override
-	public void invalidate () {
-	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java
index 6e0aff3..8753db4 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java
@@ -18,11 +18,13 @@ package com.badlogic.gdx.graphics.glutils;
 
 import java.nio.ByteBuffer;
 import java.nio.FloatBuffer;
+import java.nio.IntBuffer;
 
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.VertexAttribute;
 import com.badlogic.gdx.graphics.VertexAttributes;
+import com.badlogic.gdx.graphics.VertexAttributes.Usage;
 import com.badlogic.gdx.utils.BufferUtils;
 
 /** <p>
@@ -49,6 +51,8 @@ import com.badlogic.gdx.utils.BufferUtils;
  * 
  * @author mzechner, Dave Clayton <contact@redskyforge.com> */
 public class VertexBufferObject implements VertexData {
+	final static IntBuffer tmpHandle = BufferUtils.newIntBuffer(1);
+
 	final VertexAttributes attributes;
 	final FloatBuffer buffer;
 	final ByteBuffer byteBuffer;
@@ -80,10 +84,15 @@ public class VertexBufferObject implements VertexData {
 		buffer = byteBuffer.asFloatBuffer();
 		buffer.flip();
 		byteBuffer.flip();
-		bufferHandle = Gdx.gl20.glGenBuffer();
+		bufferHandle = createBufferObject();
 		usage = isStatic ? GL20.GL_STATIC_DRAW : GL20.GL_DYNAMIC_DRAW;
 	}
 
+	private int createBufferObject () {
+		Gdx.gl20.glGenBuffers(1, tmpHandle);
+		return tmpHandle.get(0);
+	}
+
 	@Override
 	public VertexAttributes getAttributes () {
 		return attributes;
@@ -205,16 +214,19 @@ public class VertexBufferObject implements VertexData {
 
 	/** Invalidates the VertexBufferObject so a new OpenGL buffer handle is created. Use this in case of a context loss. */
 	public void invalidate () {
-		bufferHandle = Gdx.gl20.glGenBuffer();
+		bufferHandle = createBufferObject();
 		isDirty = true;
 	}
 
 	/** Disposes of all resources this VertexBufferObject uses. */
 	@Override
 	public void dispose () {
+		tmpHandle.clear();
+		tmpHandle.put(bufferHandle);
+		tmpHandle.flip();
 		GL20 gl = Gdx.gl20;
 		gl.glBindBuffer(GL20.GL_ARRAY_BUFFER, 0);
-		gl.glDeleteBuffer(bufferHandle);
+		gl.glDeleteBuffers(1, tmpHandle);
 		bufferHandle = 0;
 		BufferUtils.disposeUnsafeByteBuffer(byteBuffer);
 	}
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObjectSubData.java b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObjectSubData.java
index 493d7a7..be275f2 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObjectSubData.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObjectSubData.java
@@ -18,11 +18,13 @@ package com.badlogic.gdx.graphics.glutils;
 
 import java.nio.ByteBuffer;
 import java.nio.FloatBuffer;
+import java.nio.IntBuffer;
 
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.VertexAttribute;
 import com.badlogic.gdx.graphics.VertexAttributes;
+import com.badlogic.gdx.graphics.VertexAttributes.Usage;
 import com.badlogic.gdx.utils.BufferUtils;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 
@@ -50,6 +52,8 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
  * 
  * @author mzechner */
 public class VertexBufferObjectSubData implements VertexData {
+	final static IntBuffer tmpHandle = BufferUtils.newIntBuffer(1);
+
 	final VertexAttributes attributes;
 	final FloatBuffer buffer;
 	final ByteBuffer byteBuffer;
@@ -79,11 +83,11 @@ public class VertexBufferObjectSubData implements VertexData {
 	}
 
 	private int createBufferObject () {
-		int result = Gdx.gl20.glGenBuffer();
-		Gdx.gl20.glBindBuffer(GL20.GL_ARRAY_BUFFER, result);
+		Gdx.gl20.glGenBuffers(1, tmpHandle);
+		Gdx.gl20.glBindBuffer(GL20.GL_ARRAY_BUFFER, tmpHandle.get(0));
 		Gdx.gl20.glBufferData(GL20.GL_ARRAY_BUFFER, byteBuffer.capacity(), null, usage);
 		Gdx.gl20.glBindBuffer(GL20.GL_ARRAY_BUFFER, 0);
-		return result;
+		return tmpHandle.get(0);
 	}
 
 	@Override
@@ -225,9 +229,12 @@ public class VertexBufferObjectSubData implements VertexData {
 	/** Disposes of all resources this VertexBufferObject uses. */
 	@Override
 	public void dispose () {
+		tmpHandle.clear();
+		tmpHandle.put(bufferHandle);
+		tmpHandle.flip();
 		GL20 gl = Gdx.gl20;
 		gl.glBindBuffer(GL20.GL_ARRAY_BUFFER, 0);
-		gl.glDeleteBuffer(bufferHandle);
+		gl.glDeleteBuffers(1, tmpHandle);
 		bufferHandle = 0;
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObjectWithVAO.java b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObjectWithVAO.java
new file mode 100644
index 0000000..79e25db
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObjectWithVAO.java
@@ -0,0 +1,251 @@
+package com.badlogic.gdx.graphics.glutils;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.gdx.graphics.GL30;
+import com.badlogic.gdx.graphics.VertexAttribute;
+import com.badlogic.gdx.graphics.VertexAttributes;
+import com.badlogic.gdx.utils.BufferUtils;
+
+import java.nio.ByteBuffer;
+import java.nio.FloatBuffer;
+import java.nio.IntBuffer;
+
+/**
+ * <p>
+ * A {@link VertexData} implementation that uses vertex buffer objects and vertex array objects.
+ * (This is required for OpenGL 3.0+ core profiles. In particular, the default VAO has been
+ * deprecated, as has the use of client memory for passing vertex attributes.) Use of VAOs should
+ * give a slight performance benefit since you don't have to bind the attributes on every draw
+ * anymore.
+ * </p>
+ *
+ * <p>
+ * If the OpenGL ES context was lost you can call {@link #invalidate()} to recreate a new OpenGL vertex buffer object.
+ * </p>
+ *
+ * <p>
+ * VertexBufferObjectWithVAO objects must be disposed via the {@link #dispose()} method when no longer needed
+ * </p>
+ *
+ * Code adapted from {@link VertexBufferObject}.
+ * @author mzechner, Dave Clayton <contact@redskyforge.com>, Nate Austin <nate.austin gmail>
+ */
+public class VertexBufferObjectWithVAO implements VertexData {
+	final static IntBuffer tmpHandle = BufferUtils.newIntBuffer(1);
+
+	final VertexAttributes attributes;
+	final FloatBuffer buffer;
+	final ByteBuffer byteBuffer;
+	int bufferHandle;
+	final boolean isStatic;
+	final int usage;
+	boolean isDirty = false;
+	boolean isBound = false;
+	boolean vaoDirty = true;
+	int vaoHandle = -1;
+
+
+	/**
+	 * Constructs a new interleaved VertexBufferObjectWithVAO.
+	 *
+	 * @param isStatic    whether the vertex data is static.
+	 * @param numVertices the maximum number of vertices
+	 * @param attributes  the {@link com.badlogic.gdx.graphics.VertexAttribute}s.
+	 */
+	public VertexBufferObjectWithVAO(boolean isStatic, int numVertices, VertexAttribute... attributes) {
+		this(isStatic, numVertices, new VertexAttributes(attributes));
+	}
+
+	/**
+	 * Constructs a new interleaved VertexBufferObjectWithVAO.
+	 *
+	 * @param isStatic    whether the vertex data is static.
+	 * @param numVertices the maximum number of vertices
+	 * @param attributes  the {@link VertexAttributes}.
+	 */
+	public VertexBufferObjectWithVAO(boolean isStatic, int numVertices, VertexAttributes attributes) {
+		this.isStatic = isStatic;
+		this.attributes = attributes;
+
+		byteBuffer = BufferUtils.newUnsafeByteBuffer(this.attributes.vertexSize * numVertices);
+		buffer = byteBuffer.asFloatBuffer();
+		buffer.flip();
+		byteBuffer.flip();
+		bufferHandle = createBufferObject();
+		usage = isStatic ? GL20.GL_STATIC_DRAW : GL20.GL_DYNAMIC_DRAW;
+	}
+
+	private int createBufferObject() {
+		Gdx.gl20.glGenBuffers(1, tmpHandle);
+		return tmpHandle.get(0);
+	}
+
+	@Override
+	public VertexAttributes getAttributes() {
+		return attributes;
+	}
+
+	@Override
+	public int getNumVertices() {
+		return buffer.limit() * 4 / attributes.vertexSize;
+	}
+
+	@Override
+	public int getNumMaxVertices() {
+		return byteBuffer.capacity() / attributes.vertexSize;
+	}
+
+	@Override
+	public FloatBuffer getBuffer() {
+		isDirty = true;
+		return buffer;
+	}
+
+	private void bufferChanged() {
+		if (isBound) {
+			Gdx.gl20.glBufferData(GL20.GL_ARRAY_BUFFER, byteBuffer.limit(), byteBuffer, usage);
+			isDirty = false;
+		}
+	}
+
+	@Override
+	public void setVertices(float[] vertices, int offset, int count) {
+		isDirty = true;
+		BufferUtils.copy(vertices, byteBuffer, count, offset);
+		buffer.position(0);
+		buffer.limit(count);
+		bufferChanged();
+	}
+
+	@Override
+	public void updateVertices(int targetOffset, float[] vertices, int sourceOffset, int count) {
+		isDirty = true;
+		final int pos = byteBuffer.position();
+		byteBuffer.position(targetOffset * 4);
+		BufferUtils.copy(vertices, sourceOffset, count, byteBuffer);
+		byteBuffer.position(pos);
+		buffer.position(0);
+		bufferChanged();
+	}
+
+	/**
+	 * Binds this VertexBufferObject for rendering via glDrawArrays or glDrawElements
+	 *
+	 * @param shader the shader
+	 */
+	@Override
+	public void bind(ShaderProgram shader) {
+		bind(shader, null);
+	}
+
+	@Override
+	public void bind(ShaderProgram shader, int[] locations) {
+		GL30 gl = Gdx.gl30;
+		if (vaoDirty || !gl.glIsVertexArray(vaoHandle)) {
+			tmpHandle.clear();
+			gl.glGenVertexArrays(1, tmpHandle);
+			vaoHandle = tmpHandle.get(0);
+			gl.glBindVertexArray(vaoHandle);
+
+			//initialize the VAO with our vertex attributes and buffer:
+			bindAttributes(shader, locations);
+			vaoDirty = false;
+
+		} else {
+			//else simply bind the VAO.
+			gl.glBindVertexArray(vaoHandle);
+		}
+		//if our data has changed upload it:
+		bindData(gl);
+
+		isBound = true;
+	}
+
+	private void bindAttributes(ShaderProgram shader, int[] locations) {
+		final GL20 gl = Gdx.gl20;
+		gl.glBindBuffer(GL20.GL_ARRAY_BUFFER, bufferHandle);
+		final int numAttributes = attributes.size();
+		if (locations == null) {
+			for (int i = 0; i < numAttributes; i++) {
+				final VertexAttribute attribute = attributes.get(i);
+				final int location = shader.getAttributeLocation(attribute.alias);
+				if (location < 0) continue;
+				shader.enableVertexAttribute(location);
+
+				shader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,
+						attribute.offset);
+			}
+
+		} else {
+			for (int i = 0; i < numAttributes; i++) {
+				final VertexAttribute attribute = attributes.get(i);
+				final int location = locations[i];
+				if (location < 0) continue;
+				shader.enableVertexAttribute(location);
+
+				shader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,
+						attribute.offset);
+			}
+		}
+	}
+
+	private void bindData(GL20 gl) {
+		if (isDirty) {
+			gl.glBindBuffer(GL20.GL_ARRAY_BUFFER, bufferHandle);
+			byteBuffer.limit(buffer.limit() * 4);
+			gl.glBufferData(GL20.GL_ARRAY_BUFFER, byteBuffer.limit(), byteBuffer, usage);
+			isDirty = false;
+		}
+	}
+
+	/**
+	 * Unbinds this VertexBufferObject.
+	 *
+	 * @param shader the shader
+	 */
+	@Override
+	public void unbind(final ShaderProgram shader) {
+		unbind(shader, null);
+	}
+
+	@Override
+	public void unbind(final ShaderProgram shader, final int[] locations) {
+		GL30 gl = Gdx.gl30;
+		gl.glBindVertexArray(0);
+		isBound = false;
+	}
+
+	//TODO: should invalidate be added to the VertexData interface?
+	/**
+	 * Invalidates the VertexBufferObject so a new OpenGL buffer handle is created. Use this in case of a context loss.
+	 */
+	public void invalidate() {
+		bufferHandle = createBufferObject();
+		isDirty = true;
+		vaoDirty = true;
+	}
+
+	/**
+	 * Disposes of all resources this VertexBufferObject uses.
+	 */
+	@Override
+	public void dispose() {
+		GL30 gl = Gdx.gl30;
+		tmpHandle.clear();
+		tmpHandle.put(bufferHandle);
+		tmpHandle.flip();
+
+		gl.glBindBuffer(GL20.GL_ARRAY_BUFFER, 0);
+		gl.glDeleteBuffers(1, tmpHandle);
+		bufferHandle = 0;
+		BufferUtils.disposeUnsafeByteBuffer(byteBuffer);
+
+		if (gl.glIsVertexArray(vaoHandle)) {
+			tmpHandle.clear();
+			tmpHandle.put(vaoHandle);
+			tmpHandle.flip();
+			gl.glDeleteVertexArrays(1, tmpHandle);
+		}
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexData.java b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexData.java
index 34f0f0a..d547b22 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexData.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexData.java
@@ -70,9 +70,6 @@ public interface VertexData extends Disposable {
 	/** Unbinds this VertexData.
 	 * @param locations array containing the attribute locations. */
 	public void unbind (ShaderProgram shader, int[] locations);
-	
-	/** Invalidates the VertexData if applicable. Use this in case of a context loss. */
-	public void invalidate ();
 
 	/** Disposes this VertexData and all its associated OpenGL resources. */
 	public void dispose ();
diff --git a/gdx/src/com/badlogic/gdx/graphics/profiling/GL20Profiler.java b/gdx/src/com/badlogic/gdx/graphics/profiling/GL20Profiler.java
index 99c9d3a..2d6a842 100644
--- a/gdx/src/com/badlogic/gdx/graphics/profiling/GL20Profiler.java
+++ b/gdx/src/com/badlogic/gdx/graphics/profiling/GL20Profiler.java
@@ -901,117 +901,4 @@ public class GL20Profiler extends GLProfiler implements GL20 {
 		gl20.glVertexAttribPointer(indx, size, type, normalized, stride, ptr);
 	}
 
-	@Override
-	public void glDeleteTexture (int texture) {
-		calls++;
-		gl20.glDeleteTexture(texture);
-	}
-
-	@Override
-	public int glGenTexture () {
-		calls++;
-		return gl20.glGenTexture();
-	}
-
-	@Override
-	public void glDeleteBuffer (int buffer) {
-		calls++;
-		gl20.glDeleteBuffer(buffer);
-	}
-
-	@Override
-	public void glDeleteFramebuffer (int framebuffer) {
-		calls++;
-		gl20.glDeleteFramebuffer(framebuffer);
-	}
-
-	@Override
-	public void glDeleteRenderbuffer (int renderbuffer) {
-		calls++;
-		gl20.glDeleteRenderbuffer(renderbuffer);
-	}
-
-	@Override
-	public int glGenBuffer () {
-		calls++;
-		return gl20.glGenBuffer();
-	}
-
-	@Override
-	public int glGenFramebuffer () {
-		calls++;
-		return gl20.glGenFramebuffer();
-	}
-
-	@Override
-	public int glGenRenderbuffer () {
-		calls++;
-		return gl20.glGenRenderbuffer();
-	}
-
-	@Override
-	public void glUniform1fv (int location, int count, float[] v, int offset) {
-		calls++;
-		gl20.glUniform1fv(location, count, v, offset);
-	}
-
-	@Override
-	public void glUniform1iv (int location, int count, int[] v, int offset) {
-		calls++;
-		gl20.glUniform1iv(location, count, v, offset);
-	}
-
-	@Override
-	public void glUniform2fv (int location, int count, float[] v, int offset) {
-		calls++;
-		gl20.glUniform2fv(location, count, v, offset);	
-	}
-
-	@Override
-	public void glUniform2iv (int location, int count, int[] v, int offset) {
-		calls++;
-		gl20.glUniform2iv(location, count, v, offset);
-	}
-
-	@Override
-	public void glUniform3fv (int location, int count, float[] v, int offset) {
-		calls++;
-		gl20.glUniform3fv(location, count, v, offset);
-	}
-
-	@Override
-	public void glUniform3iv (int location, int count, int[] v, int offset) {
-		calls++;
-		gl20.glUniform3iv(location, count, v, offset);
-	}
-
-	@Override
-	public void glUniform4fv (int location, int count, float[] v, int offset) {
-		calls++;
-		gl20.glUniform4fv(location, count, v, offset);
-	}
-
-	@Override
-	public void glUniform4iv (int location, int count, int[] v, int offset) {
-		calls++;
-		gl20.glUniform4iv(location, count, v, offset);
-	}
-
-	@Override
-	public void glUniformMatrix2fv (int location, int count, boolean transpose, float[] value, int offset) {
-		calls++;
-		gl20.glUniformMatrix2fv(location, count, transpose, value, offset);
-	}
-
-	@Override
-	public void glUniformMatrix3fv (int location, int count, boolean transpose, float[] value, int offset) {
-		calls++;
-		gl20.glUniformMatrix3fv(location, count, transpose, value, offset);
-	}
-
-	@Override
-	public void glUniformMatrix4fv (int location, int count, boolean transpose, float[] value, int offset) {
-		calls++;
-		gl20.glUniformMatrix4fv(location, count, transpose, value, offset);
-	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/profiling/GL30Profiler.java b/gdx/src/com/badlogic/gdx/graphics/profiling/GL30Profiler.java
index fc040db..dcaf62b 100644
--- a/gdx/src/com/badlogic/gdx/graphics/profiling/GL30Profiler.java
+++ b/gdx/src/com/badlogic/gdx/graphics/profiling/GL30Profiler.java
@@ -1469,118 +1469,4 @@ public class GL30Profiler extends GLProfiler implements GL30 {
 		calls++;
 		gl30.glInvalidateSubFramebuffer(target, numAttachments, attachments, x, y, width, height);
 	}
-	
-	@Override
-	public void glDeleteTexture (int texture) {
-		calls++;
-		gl30.glDeleteTexture(texture);
-	}
-
-	@Override
-	public int glGenTexture () {
-		calls++;
-		return gl30.glGenTexture();
-	}
-
-	@Override
-	public void glDeleteBuffer (int buffer) {
-		calls++;
-		gl30.glDeleteBuffer(buffer);
-	}
-
-	@Override
-	public void glDeleteFramebuffer (int framebuffer) {
-		calls++;
-		gl30.glDeleteFramebuffer(framebuffer);
-	}
-
-	@Override
-	public void glDeleteRenderbuffer (int renderbuffer) {
-		calls++;
-		gl30.glDeleteRenderbuffer(renderbuffer);
-	}
-
-	@Override
-	public int glGenBuffer () {
-		calls++;
-		return gl30.glGenBuffer();
-	}
-
-	@Override
-	public int glGenFramebuffer () {
-		calls++;
-		return gl30.glGenFramebuffer();
-	}
-
-	@Override
-	public int glGenRenderbuffer () {
-		calls++;
-		return gl30.glGenRenderbuffer();
-	}
-
-	@Override
-	public void glUniform1fv (int location, int count, float[] v, int offset) {
-		calls++;
-		gl30.glUniform1fv(location, count, v, offset);
-	}
-
-	@Override
-	public void glUniform1iv (int location, int count, int[] v, int offset) {
-		calls++;
-		gl30.glUniform1iv(location, count, v, offset);
-	}
-
-	@Override
-	public void glUniform2fv (int location, int count, float[] v, int offset) {
-		calls++;
-		gl30.glUniform2fv(location, count, v, offset);	
-	}
-
-	@Override
-	public void glUniform2iv (int location, int count, int[] v, int offset) {
-		calls++;
-		gl30.glUniform2iv(location, count, v, offset);
-	}
-
-	@Override
-	public void glUniform3fv (int location, int count, float[] v, int offset) {
-		calls++;
-		gl30.glUniform3fv(location, count, v, offset);
-	}
-
-	@Override
-	public void glUniform3iv (int location, int count, int[] v, int offset) {
-		calls++;
-		gl30.glUniform3iv(location, count, v, offset);
-	}
-
-	@Override
-	public void glUniform4fv (int location, int count, float[] v, int offset) {
-		calls++;
-		gl30.glUniform4fv(location, count, v, offset);
-	}
-
-	@Override
-	public void glUniform4iv (int location, int count, int[] v, int offset) {
-		calls++;
-		gl30.glUniform4iv(location, count, v, offset);
-	}
-
-	@Override
-	public void glUniformMatrix2fv (int location, int count, boolean transpose, float[] value, int offset) {
-		calls++;
-		gl30.glUniformMatrix2fv(location, count, transpose, value, offset);
-	}
-
-	@Override
-	public void glUniformMatrix3fv (int location, int count, boolean transpose, float[] value, int offset) {
-		calls++;
-		gl30.glUniformMatrix3fv(location, count, transpose, value, offset);
-	}
-
-	@Override
-	public void glUniformMatrix4fv (int location, int count, boolean transpose, float[] value, int offset) {
-		calls++;
-		gl30.glUniformMatrix4fv(location, count, transpose, value, offset);
-	}
 }
diff --git a/gdx/src/com/badlogic/gdx/input/RemoteInput.java b/gdx/src/com/badlogic/gdx/input/RemoteInput.java
index 9219e86..9ee892a 100644
--- a/gdx/src/com/badlogic/gdx/input/RemoteInput.java
+++ b/gdx/src/com/badlogic/gdx/input/RemoteInput.java
@@ -24,7 +24,6 @@ import java.net.Socket;
 
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.Input;
-import com.badlogic.gdx.Input.TextInputListener;
 import com.badlogic.gdx.InputProcessor;
 import com.badlogic.gdx.graphics.Pixmap;
 import com.badlogic.gdx.utils.GdxRuntimeException;
@@ -389,8 +388,13 @@ public class RemoteInput implements Runnable, Input {
 	}
 
 	@Override
-	public void getTextInput (TextInputListener listener, String title, String text, String hint) {
-		Gdx.app.getInput().getTextInput(listener, title, text, hint);
+	public void getTextInput (TextInputListener listener, String title, String text) {
+		Gdx.app.getInput().getTextInput(listener, title, text);
+	}
+
+	@Override
+	public void getPlaceholderTextInput (TextInputListener listener, String title, String placeholder) {
+		Gdx.app.getInput().getPlaceholderTextInput(listener, title, placeholder);
 	}
 
 	@Override
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/AtlasTmxMapLoader.java b/gdx/src/com/badlogic/gdx/maps/tiled/AtlasTmxMapLoader.java
index f443eff..5446c5f 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/AtlasTmxMapLoader.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/AtlasTmxMapLoader.java
@@ -38,14 +38,11 @@ import com.badlogic.gdx.maps.objects.PolygonMapObject;
 import com.badlogic.gdx.maps.objects.PolylineMapObject;
 import com.badlogic.gdx.maps.objects.RectangleMapObject;
 import com.badlogic.gdx.maps.tiled.TiledMapTileLayer.Cell;
-import com.badlogic.gdx.maps.tiled.tiles.AnimatedTiledMapTile;
 import com.badlogic.gdx.maps.tiled.tiles.StaticTiledMapTile;
 import com.badlogic.gdx.math.Polygon;
 import com.badlogic.gdx.math.Polyline;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.GdxRuntimeException;
-import com.badlogic.gdx.utils.IntArray;
-import com.badlogic.gdx.utils.LongArray;
 import com.badlogic.gdx.utils.ObjectMap;
 import com.badlogic.gdx.utils.XmlReader;
 import com.badlogic.gdx.utils.XmlReader.Element;
@@ -58,13 +55,34 @@ import com.badlogic.gdx.utils.XmlReader.Element;
  * 
  * @author Justin Shapcott
  * @author Manuel Bua */
-public class AtlasTmxMapLoader extends BaseTmxMapLoader<AtlasTmxMapLoader.AtlasTiledMapLoaderParameters> {
+public class AtlasTmxMapLoader extends AsynchronousAssetLoader<TiledMap, AtlasTmxMapLoader.AtlasTiledMapLoaderParameters> {
 
-	public static class AtlasTiledMapLoaderParameters extends BaseTmxMapLoader.Parameters {
+	public static class AtlasTiledMapLoaderParameters extends AssetLoaderParameters<TiledMap> {
 		/** force texture filters? **/
 		public boolean forceTextureFilters = false;
+		/** The TextureFilter to use for minification, if forceTextureFilter is enabled **/
+		public TextureFilter textureMinFilter = TextureFilter.Nearest;
+		/** The TextureFilter to use for magnification, if forceTextureFilter is enabled **/
+		public TextureFilter textureMagFilter = TextureFilter.Nearest;
+		/** Whether to convert the objects' pixel position and size to the equivalent in tile space. **/
+		public boolean convertObjectToTileSpace = false;
 	}
 
+	protected static final int FLAG_FLIP_HORIZONTALLY = 0x80000000;
+	protected static final int FLAG_FLIP_VERTICALLY = 0x40000000;
+	protected static final int FLAG_FLIP_DIAGONALLY = 0x20000000;
+	protected static final int MASK_CLEAR = 0xE0000000;
+
+	protected XmlReader xml = new XmlReader();
+	protected Element root;
+	protected boolean convertObjectToTileSpace;
+
+	protected int mapTileWidth;
+	protected int mapTileHeight;
+	protected int mapWidthInPixels;
+	protected int mapHeightInPixels;
+
+	protected TiledMap map;
 	protected Array<Texture> trackedTextures = new Array<Texture>();
 
 	private interface AtlasResolver {
@@ -155,9 +173,10 @@ public class AtlasTmxMapLoader extends BaseTmxMapLoader<AtlasTmxMapLoader.AtlasT
 			atlases.put(atlasFile.path(), atlas);
 
 			AtlasResolver.DirectAtlasResolver atlasResolver = new AtlasResolver.DirectAtlasResolver(atlases);
-			TiledMap map = loadMap(root, tmxFile, atlasResolver);
+			TiledMap map = loadMap(root, tmxFile, atlasResolver, parameter);
 			map.setOwnedResources(atlases.values().toArray());
 			setTextureFilters(parameter.textureMinFilter, parameter.textureMagFilter);
+
 			return map;
 		} catch (IOException e) {
 			throw new GdxRuntimeException("Couldn't load tilemap '" + fileName + "'", e);
@@ -185,16 +204,18 @@ public class AtlasTmxMapLoader extends BaseTmxMapLoader<AtlasTmxMapLoader.AtlasT
 					return getRelativeFileHandle(tmxFile, value);
 				}
 			}
+		} else {
+			FileHandle atlasFile = tmxFile.sibling(tmxFile.nameWithoutExtension() + ".atlas");
+			return atlasFile.exists() ? atlasFile : null;
 		}
-		FileHandle atlasFile = tmxFile.sibling(tmxFile.nameWithoutExtension() + ".atlas");
-		return atlasFile.exists() ? atlasFile : null;
+
+		return null;
 	}
 
 	private void setTextureFilters (TextureFilter min, TextureFilter mag) {
 		for (Texture texture : trackedTextures) {
 			texture.setFilter(min, mag);
 		}
-		trackedTextures.clear();
 	}
 
 	@Override
@@ -208,7 +229,7 @@ public class AtlasTmxMapLoader extends BaseTmxMapLoader<AtlasTmxMapLoader.AtlasT
 		}
 
 		try {
-			map = loadMap(root, tmxFile, new AtlasResolver.AssetManagerAtlasResolver(manager));
+			map = loadMap(root, tmxFile, new AtlasResolver.AssetManagerAtlasResolver(manager), parameter);
 		} catch (Exception e) {
 			throw new GdxRuntimeException("Couldn't load tilemap '" + fileName + "'", e);
 		}
@@ -223,7 +244,7 @@ public class AtlasTmxMapLoader extends BaseTmxMapLoader<AtlasTmxMapLoader.AtlasT
 		return map;
 	}
 
-	protected TiledMap loadMap (Element root, FileHandle tmxFile, AtlasResolver resolver) {
+	protected TiledMap loadMap (Element root, FileHandle tmxFile, AtlasResolver resolver, AtlasTiledMapLoaderParameters parameter) {
 		TiledMap map = new TiledMap();
 
 		String mapOrientation = root.getAttribute("orientation", null);
@@ -250,22 +271,13 @@ public class AtlasTmxMapLoader extends BaseTmxMapLoader<AtlasTmxMapLoader.AtlasT
 		mapWidthInPixels = mapWidth * tileWidth;
 		mapHeightInPixels = mapHeight * tileHeight;
 
-		if (mapOrientation != null) {
-			if ("staggered".equals(mapOrientation)) {
-				if (mapHeight > 1) {
-					mapWidthInPixels += tileWidth / 2;
-					mapHeightInPixels = mapHeightInPixels / 2 + tileHeight / 2;
-				}
-			}
-		}
-
 		for (int i = 0, j = root.getChildCount(); i < j; i++) {
 			Element element = root.getChild(i);
 			String elementName = element.getName();
 			if (elementName.equals("properties")) {
 				loadProperties(map.getProperties(), element);
 			} else if (elementName.equals("tileset")) {
-				loadTileset(map, element, tmxFile, resolver);
+				loadTileset(map, element, tmxFile, resolver, parameter);
 			} else if (elementName.equals("layer")) {
 				loadTileLayer(map, element);
 			} else if (elementName.equals("objectgroup")) {
@@ -275,7 +287,8 @@ public class AtlasTmxMapLoader extends BaseTmxMapLoader<AtlasTmxMapLoader.AtlasT
 		return map;
 	}
 
-	protected void loadTileset (TiledMap map, Element element, FileHandle tmxFile, AtlasResolver resolver) {
+	protected void loadTileset (TiledMap map, Element element, FileHandle tmxFile, AtlasResolver resolver,
+		AtlasTiledMapLoaderParameters parameter) {
 		if (element.getName().equals("tileset")) {
 			String name = element.get("name", null);
 			int firstgid = element.getIntAttribute("firstgid", 1);
@@ -307,12 +320,9 @@ public class AtlasTmxMapLoader extends BaseTmxMapLoader<AtlasTmxMapLoader.AtlasT
 						offsetY = offset.getIntAttribute("y", 0);
 					}
 					Element imageElement = element.getChildByName("image");
-					if (imageElement != null) {
-						imageSource = imageElement.getAttribute("source");
-						imageWidth = imageElement.getIntAttribute("width", 0);
-						imageHeight = imageElement.getIntAttribute("height", 0);
-						image = getRelativeFileHandle(tsx, imageSource);
-					}
+					imageSource = imageElement.getAttribute("source");
+					imageWidth = imageElement.getIntAttribute("width", 0);
+					imageHeight = imageElement.getIntAttribute("height", 0);
 				} catch (IOException e) {
 					throw new GdxRuntimeException("Error parsing external tileset.");
 				}
@@ -327,7 +337,6 @@ public class AtlasTmxMapLoader extends BaseTmxMapLoader<AtlasTmxMapLoader.AtlasT
 					imageSource = imageElement.getAttribute("source");
 					imageWidth = imageElement.getIntAttribute("width", 0);
 					imageHeight = imageElement.getIntAttribute("height", 0);
-					image = getRelativeFileHandle(tmxFile, imageSource);
 				}
 			}
 
@@ -346,8 +355,10 @@ public class AtlasTmxMapLoader extends BaseTmxMapLoader<AtlasTmxMapLoader.AtlasT
 			TextureAtlas atlas = resolver.getAtlas(atlasHandle.path());
 			String regionsName = atlasHandle.nameWithoutExtension();
 
-			for (Texture texture : atlas.getTextures()) {
-				trackedTextures.add(texture);
+			if (parameter != null && parameter.forceTextureFilters) {
+				for (Texture texture : atlas.getTextures()) {
+					trackedTextures.add(texture);
+				}
 			}
 
 			TiledMapTileSet tileset = new TiledMapTileSet();
@@ -408,55 +419,185 @@ public class AtlasTmxMapLoader extends BaseTmxMapLoader<AtlasTmxMapLoader.AtlasT
 				}
 			}
 
-			Array<Element> tileElements = element.getChildrenByName("tile");
-
-			Array<AnimatedTiledMapTile> animatedTiles = new Array<AnimatedTiledMapTile>();
+			Element properties = element.getChildByName("properties");
+			if (properties != null) {
+				loadProperties(tileset.getProperties(), properties);
+			}
+			map.getTileSets().addTileSet(tileset);
+		}
+	}
 
-			for (Element tileElement : tileElements) {
-				int localtid = tileElement.getIntAttribute("id", 0);
-				TiledMapTile tile = tileset.getTile(firstgid + localtid);
-				if (tile != null) {
-					Element animationElement = tileElement.getChildByName("animation");
-					if (animationElement != null) {
-
-						Array<StaticTiledMapTile> staticTiles = new Array<StaticTiledMapTile>();
-						IntArray intervals = new IntArray();
-						for (Element frameElement: animationElement.getChildrenByName("frame")) {
-							staticTiles.add((StaticTiledMapTile) tileset.getTile(firstgid + frameElement.getIntAttribute("tileid")));
-							intervals.add(frameElement.getIntAttribute("duration"));
-						}
-
-						AnimatedTiledMapTile animatedTile = new AnimatedTiledMapTile(intervals, staticTiles);
-						animatedTile.setId(tile.getId());
-						animatedTiles.add(animatedTile);
-						tile = animatedTile;
+	protected void loadTileLayer (TiledMap map, Element element) {
+		if (element.getName().equals("layer")) {
+			String name = element.getAttribute("name", null);
+			int width = element.getIntAttribute("width", 0);
+			int height = element.getIntAttribute("height", 0);
+			int tileWidth = element.getParent().getIntAttribute("tilewidth", 0);
+			int tileHeight = element.getParent().getIntAttribute("tileheight", 0);
+			boolean visible = element.getIntAttribute("visible", 1) == 1;
+			float opacity = element.getFloatAttribute("opacity", 1.0f);
+			TiledMapTileLayer layer = new TiledMapTileLayer(width, height, tileWidth, tileHeight);
+			layer.setVisible(visible);
+			layer.setOpacity(opacity);
+			layer.setName(name);
+
+			int[] ids = TmxMapHelper.getTileIds(element, width, height);
+			TiledMapTileSets tilesets = map.getTileSets();
+			for (int y = 0; y < height; y++) {
+				for (int x = 0; x < width; x++) {
+					int id = ids[y * width + x];
+					boolean flipHorizontally = ((id & FLAG_FLIP_HORIZONTALLY) != 0);
+					boolean flipVertically = ((id & FLAG_FLIP_VERTICALLY) != 0);
+					boolean flipDiagonally = ((id & FLAG_FLIP_DIAGONALLY) != 0);
+
+					TiledMapTile tile = tilesets.getTile(id & ~MASK_CLEAR);
+					if (tile != null) {
+						Cell cell = createTileLayerCell(flipHorizontally, flipVertically, flipDiagonally);
+						cell.setTile(tile);
+						layer.setCell(x, height - 1 - y, cell);
 					}
+				}
+			}
 
-					String terrain = tileElement.getAttribute("terrain", null);
-					if (terrain != null) {
-						tile.getProperties().put("terrain", terrain);
-					}
-					String probability = tileElement.getAttribute("probability", null);
-					if (probability != null) {
-						tile.getProperties().put("probability", probability);
+			Element properties = element.getChildByName("properties");
+			if (properties != null) {
+				loadProperties(layer.getProperties(), properties);
+			}
+			map.getLayers().add(layer);
+		}
+	}
+
+	protected void loadObjectGroup (TiledMap map, Element element) {
+		if (element.getName().equals("objectgroup")) {
+			String name = element.getAttribute("name", null);
+			MapLayer layer = new MapLayer();
+			layer.setName(name);
+			Element properties = element.getChildByName("properties");
+			if (properties != null) {
+				loadProperties(layer.getProperties(), properties);
+			}
+
+			for (Element objectElement : element.getChildrenByName("object")) {
+				loadObject(layer, objectElement);
+			}
+
+			map.getLayers().add(layer);
+		}
+	}
+
+	protected void loadObject (MapLayer layer, Element element) {
+		if (element.getName().equals("object")) {
+			MapObject object = null;
+
+			float scaleX = convertObjectToTileSpace ? 1.0f / mapTileWidth : 1.0f;
+			float scaleY = convertObjectToTileSpace ? 1.0f / mapTileHeight : 1.0f;
+
+			float x = element.getFloatAttribute("x", 0) * scaleX;
+			float y = (mapHeightInPixels - element.getFloatAttribute("y", 0)) * scaleY;
+
+			float width = element.getFloatAttribute("width", 0) * scaleX;
+			float height = element.getFloatAttribute("height", 0) * scaleY;
+
+			if (element.getChildCount() > 0) {
+				Element child = null;
+				if ((child = element.getChildByName("polygon")) != null) {
+					String[] points = child.getAttribute("points").split(" ");
+					float[] vertices = new float[points.length * 2];
+					for (int i = 0; i < points.length; i++) {
+						String[] point = points[i].split(",");
+						vertices[i * 2] = Float.parseFloat(point[0]) * scaleX;
+						vertices[i * 2 + 1] = -Float.parseFloat(point[1]) * scaleY;
 					}
-					Element properties = tileElement.getChildByName("properties");
-					if (properties != null) {
-						loadProperties(tile.getProperties(), properties);
+					Polygon polygon = new Polygon(vertices);
+					polygon.setPosition(x, y);
+					object = new PolygonMapObject(polygon);
+				} else if ((child = element.getChildByName("polyline")) != null) {
+					String[] points = child.getAttribute("points").split(" ");
+					float[] vertices = new float[points.length * 2];
+					for (int i = 0; i < points.length; i++) {
+						String[] point = points[i].split(",");
+						vertices[i * 2] = Float.parseFloat(point[0]) * scaleX;
+						vertices[i * 2 + 1] = -Float.parseFloat(point[1]) * scaleY;
 					}
+					Polyline polyline = new Polyline(vertices);
+					polyline.setPosition(x, y);
+					object = new PolylineMapObject(polyline);
+				} else if ((child = element.getChildByName("ellipse")) != null) {
+					object = new EllipseMapObject(x, y - height, width, height);
 				}
 			}
-
-			for (AnimatedTiledMapTile tile : animatedTiles) {
-				tileset.putTile(tile.getId(), tile);
-			}			
-			
+			if (object == null) {
+				object = new RectangleMapObject(x, y - height, width, height);
+			}
+			object.setName(element.getAttribute("name", null));
+			String rotation = element.getAttribute("rotation", null);
+			if (rotation != null) {
+				object.getProperties().put("rotation", Float.parseFloat(rotation));
+			}
+			String type = element.getAttribute("type", null);
+			if (type != null) {
+				object.getProperties().put("type", type);
+			}
+			int gid = element.getIntAttribute("gid", -1);
+			if (gid != -1) {
+				object.getProperties().put("gid", gid);
+			}
+			object.getProperties().put("x", x * scaleX);
+			object.getProperties().put("y", (y - height) * scaleY);
+			object.setVisible(element.getIntAttribute("visible", 1) == 1);
 			Element properties = element.getChildByName("properties");
 			if (properties != null) {
-				loadProperties(tileset.getProperties(), properties);
+				loadProperties(object.getProperties(), properties);
 			}
-			map.getTileSets().addTileSet(tileset);
+			layer.getObjects().add(object);
+		}
+	}
+
+	protected void loadProperties (MapProperties properties, Element element) {
+		if (element.getName().equals("properties")) {
+			for (Element property : element.getChildrenByName("property")) {
+				String name = property.getAttribute("name", null);
+				String value = property.getAttribute("value", null);
+				if (value == null) {
+					value = property.getText();
+				}
+				properties.put(name, value);
+			}
+		}
+	}
+
+	protected Cell createTileLayerCell (boolean flipHorizontally, boolean flipVertically, boolean flipDiagonally) {
+		Cell cell = new Cell();
+		if (flipDiagonally) {
+			if (flipHorizontally && flipVertically) {
+				cell.setFlipHorizontally(true);
+				cell.setRotation(Cell.ROTATE_270);
+			} else if (flipHorizontally) {
+				cell.setRotation(Cell.ROTATE_270);
+			} else if (flipVertically) {
+				cell.setRotation(Cell.ROTATE_90);
+			} else {
+				cell.setFlipVertically(true);
+				cell.setRotation(Cell.ROTATE_270);
+			}
+		} else {
+			cell.setFlipHorizontally(flipHorizontally);
+			cell.setFlipVertically(flipVertically);
 		}
+		return cell;
 	}
 
+	public static FileHandle getRelativeFileHandle (FileHandle file, String path) {
+		StringTokenizer tokenizer = new StringTokenizer(path, "\\/");
+		FileHandle result = file.parent();
+		while (tokenizer.hasMoreElements()) {
+			String token = tokenizer.nextToken();
+			if (token.equals(".."))
+				result = result.parent();
+			else {
+				result = result.child(token);
+			}
+		}
+		return result;
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/BaseTmxMapLoader.java b/gdx/src/com/badlogic/gdx/maps/tiled/BaseTmxMapLoader.java
deleted file mode 100644
index 0a5d6b4..0000000
--- a/gdx/src/com/badlogic/gdx/maps/tiled/BaseTmxMapLoader.java
+++ /dev/null
@@ -1,350 +0,0 @@
-
-package com.badlogic.gdx.maps.tiled;
-
-import com.badlogic.gdx.assets.AssetLoaderParameters;
-import com.badlogic.gdx.assets.loaders.AsynchronousAssetLoader;
-import com.badlogic.gdx.assets.loaders.FileHandleResolver;
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.Texture.TextureFilter;
-import com.badlogic.gdx.graphics.g2d.TextureRegion;
-import com.badlogic.gdx.maps.ImageResolver;
-import com.badlogic.gdx.maps.MapLayer;
-import com.badlogic.gdx.maps.MapObject;
-import com.badlogic.gdx.maps.MapProperties;
-import com.badlogic.gdx.maps.objects.EllipseMapObject;
-import com.badlogic.gdx.maps.objects.PolygonMapObject;
-import com.badlogic.gdx.maps.objects.PolylineMapObject;
-import com.badlogic.gdx.maps.objects.RectangleMapObject;
-import com.badlogic.gdx.maps.objects.TextureMapObject;
-import com.badlogic.gdx.maps.tiled.TiledMapTileLayer.Cell;
-import com.badlogic.gdx.math.Polygon;
-import com.badlogic.gdx.math.Polyline;
-import com.badlogic.gdx.utils.Base64Coder;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-import com.badlogic.gdx.utils.StreamUtils;
-import com.badlogic.gdx.utils.XmlReader;
-import com.badlogic.gdx.utils.XmlReader.Element;
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.StringTokenizer;
-import java.util.zip.GZIPInputStream;
-import java.util.zip.InflaterInputStream;
-
-public abstract class BaseTmxMapLoader<P extends AssetLoaderParameters<TiledMap>> extends AsynchronousAssetLoader<TiledMap, P> {
-
-	public static class Parameters extends AssetLoaderParameters<TiledMap> {
-		/** generate mipmaps? **/
-		public boolean generateMipMaps = false;
-		/** The TextureFilter to use for minification **/
-		public TextureFilter textureMinFilter = TextureFilter.Nearest;
-		/** The TextureFilter to use for magnification **/
-		public TextureFilter textureMagFilter = TextureFilter.Nearest;
-		/** Whether to convert the objects' pixel position and size to the equivalent in tile space. **/
-		public boolean convertObjectToTileSpace = false;
-	}
-
-	protected static final int FLAG_FLIP_HORIZONTALLY = 0x80000000;
-	protected static final int FLAG_FLIP_VERTICALLY = 0x40000000;
-	protected static final int FLAG_FLIP_DIAGONALLY = 0x20000000;
-	protected static final int MASK_CLEAR = 0xE0000000;
-
-	protected XmlReader xml = new XmlReader();
-	protected Element root;
-	protected boolean convertObjectToTileSpace;
-
-	protected int mapTileWidth;
-	protected int mapTileHeight;
-	protected int mapWidthInPixels;
-	protected int mapHeightInPixels;
-
-	protected TiledMap map;
-
-	public BaseTmxMapLoader (FileHandleResolver resolver) {
-		super(resolver);
-	}
-
-	protected void loadTileLayer (TiledMap map, Element element) {
-		if (element.getName().equals("layer")) {
-			int width = element.getIntAttribute("width", 0);
-			int height = element.getIntAttribute("height", 0);
-			int tileWidth = element.getParent().getIntAttribute("tilewidth", 0);
-			int tileHeight = element.getParent().getIntAttribute("tileheight", 0);
-			TiledMapTileLayer layer = new TiledMapTileLayer(width, height, tileWidth, tileHeight);
-
-			loadBasicLayerInfo(layer, element);
-
-			int[] ids = getTileIds(element, width, height);
-			TiledMapTileSets tilesets = map.getTileSets();
-			for (int y = 0; y < height; y++) {
-				for (int x = 0; x < width; x++) {
-					int id = ids[y * width + x];
-					boolean flipHorizontally = ((id & FLAG_FLIP_HORIZONTALLY) != 0);
-					boolean flipVertically = ((id & FLAG_FLIP_VERTICALLY) != 0);
-					boolean flipDiagonally = ((id & FLAG_FLIP_DIAGONALLY) != 0);
-
-					TiledMapTile tile = tilesets.getTile(id & ~MASK_CLEAR);
-					if (tile != null) {
-						Cell cell = createTileLayerCell(flipHorizontally, flipVertically, flipDiagonally);
-						cell.setTile(tile);
-						layer.setCell(x, height - 1 - y, cell);
-					}
-				}
-			}
-
-			Element properties = element.getChildByName("properties");
-			if (properties != null) {
-				loadProperties(layer.getProperties(), properties);
-			}
-			map.getLayers().add(layer);
-		}
-	}
-
-	protected void loadObjectGroup (TiledMap map, Element element) {
-		if (element.getName().equals("objectgroup")) {
-			String name = element.getAttribute("name", null);
-			MapLayer layer = new MapLayer();
-			layer.setName(name);
-			Element properties = element.getChildByName("properties");
-			if (properties != null) {
-				loadProperties(layer.getProperties(), properties);
-			}
-
-			for (Element objectElement : element.getChildrenByName("object")) {
-				loadObject(map, layer, objectElement);
-			}
-
-			map.getLayers().add(layer);
-		}
-	}
-
-	protected void loadImageLayer (TiledMap map, Element element, FileHandle tmxFile, ImageResolver imageResolver) {
-		if (element.getName().equals("imagelayer")) {
-			int x = Integer.parseInt(element.getAttribute("x", "0"));
-			int y = mapHeightInPixels - Integer.parseInt(element.getAttribute("y", "0"));
-			TextureRegion texture = null;
-
-			Element image = element.getChildByName("image");
-
-			if (image != null) {
-				String source = image.getAttribute("source");
-				FileHandle handle = getRelativeFileHandle(tmxFile, source);
-				texture = imageResolver.getImage(handle.path());
-				y -= texture.getRegionHeight();
-			}
-
-			TiledMapImageLayer layer = new TiledMapImageLayer(texture, x, y);
-
-			loadBasicLayerInfo(layer, element);
-
-			Element properties = element.getChildByName("properties");
-			if (properties != null) {
-				loadProperties(layer.getProperties(), properties);
-			}
-
-			map.getLayers().add(layer);
-		}
-	}
-
-	protected void loadBasicLayerInfo (MapLayer layer, Element element) {
-		String name = element.getAttribute("name", null);
-		float opacity = Float.parseFloat(element.getAttribute("opacity", "1.0"));
-		boolean visible = element.getIntAttribute("visible", 1) == 1;
-
-		layer.setName(name);
-		layer.setOpacity(opacity);
-		layer.setVisible(visible);
-	}
-
-	protected void loadObject (TiledMap map, MapLayer layer, Element element) {
-		if (element.getName().equals("object")) {
-			MapObject object = null;
-
-			float scaleX = convertObjectToTileSpace ? 1.0f / mapTileWidth : 1.0f;
-			float scaleY = convertObjectToTileSpace ? 1.0f / mapTileHeight : 1.0f;
-
-			float x = element.getFloatAttribute("x", 0) * scaleX;
-			float y = (mapHeightInPixels - element.getFloatAttribute("y", 0)) * scaleY;
-
-			float width = element.getFloatAttribute("width", 0) * scaleX;
-			float height = element.getFloatAttribute("height", 0) * scaleY;
-
-			if (element.getChildCount() > 0) {
-				Element child = null;
-				if ((child = element.getChildByName("polygon")) != null) {
-					String[] points = child.getAttribute("points").split(" ");
-					float[] vertices = new float[points.length * 2];
-					for (int i = 0; i < points.length; i++) {
-						String[] point = points[i].split(",");
-						vertices[i * 2] = Float.parseFloat(point[0]) * scaleX;
-						vertices[i * 2 + 1] = -Float.parseFloat(point[1]) * scaleY;
-					}
-					Polygon polygon = new Polygon(vertices);
-					polygon.setPosition(x, y);
-					object = new PolygonMapObject(polygon);
-				} else if ((child = element.getChildByName("polyline")) != null) {
-					String[] points = child.getAttribute("points").split(" ");
-					float[] vertices = new float[points.length * 2];
-					for (int i = 0; i < points.length; i++) {
-						String[] point = points[i].split(",");
-						vertices[i * 2] = Float.parseFloat(point[0]) * scaleX;
-						vertices[i * 2 + 1] = -Float.parseFloat(point[1]) * scaleY;
-					}
-					Polyline polyline = new Polyline(vertices);
-					polyline.setPosition(x, y);
-					object = new PolylineMapObject(polyline);
-				} else if ((child = element.getChildByName("ellipse")) != null) {
-					object = new EllipseMapObject(x, y - height, width, height);
-				}
-			}
-			if (object == null) {
-				int gid = -1;
-				if ((gid = element.getIntAttribute("gid", -1)) != -1) {
-					TiledMapTile tile = map.getTileSets().getTile(gid);
-					TextureMapObject textureMapObject = new TextureMapObject(tile.getTextureRegion());
-					textureMapObject.setX(x);
-					textureMapObject.setY(y - height);
-					textureMapObject.setScaleX(scaleX);
-					textureMapObject.setScaleY(scaleY);
-					textureMapObject.setRotation(element.getFloatAttribute("rotation", 0));
-					object = textureMapObject;
-				} else {
-					object = new RectangleMapObject(x, y - height, width, height);
-				}
-			}
-			object.setName(element.getAttribute("name", null));
-			String rotation = element.getAttribute("rotation", null);
-			if (rotation != null) {
-				object.getProperties().put("rotation", Float.parseFloat(rotation));
-			}
-			String type = element.getAttribute("type", null);
-			if (type != null) {
-				object.getProperties().put("type", type);
-			}
-			int gid = element.getIntAttribute("gid", -1);
-			if (gid != -1) {
-				object.getProperties().put("gid", gid);
-			}
-			object.getProperties().put("x", x * scaleX);
-			object.getProperties().put("y", (y - height) * scaleY);
-			object.getProperties().put("width", width);
-			object.getProperties().put("height", height);
-			object.setVisible(element.getIntAttribute("visible", 1) == 1);
-			Element properties = element.getChildByName("properties");
-			if (properties != null) {
-				loadProperties(object.getProperties(), properties);
-			}
-			layer.getObjects().add(object);
-		}
-	}
-
-	protected void loadProperties (MapProperties properties, Element element) {
-		if (element == null) return;
-		if (element.getName().equals("properties")) {
-			for (Element property : element.getChildrenByName("property")) {
-				String name = property.getAttribute("name", null);
-				String value = property.getAttribute("value", null);
-				if (value == null) {
-					value = property.getText();
-				}
-				properties.put(name, value);
-			}
-		}
-	}
-
-	protected Cell createTileLayerCell (boolean flipHorizontally, boolean flipVertically, boolean flipDiagonally) {
-		Cell cell = new Cell();
-		if (flipDiagonally) {
-			if (flipHorizontally && flipVertically) {
-				cell.setFlipHorizontally(true);
-				cell.setRotation(Cell.ROTATE_270);
-			} else if (flipHorizontally) {
-				cell.setRotation(Cell.ROTATE_270);
-			} else if (flipVertically) {
-				cell.setRotation(Cell.ROTATE_90);
-			} else {
-				cell.setFlipVertically(true);
-				cell.setRotation(Cell.ROTATE_270);
-			}
-		} else {
-			cell.setFlipHorizontally(flipHorizontally);
-			cell.setFlipVertically(flipVertically);
-		}
-		return cell;
-	}
-
-	static public int[] getTileIds (Element element, int width, int height) {
-		Element data = element.getChildByName("data");
-		String encoding = data.getAttribute("encoding", null);
-		if (encoding == null) { // no 'encoding' attribute means that the encoding is XML
-			throw new GdxRuntimeException("Unsupported encoding (XML) for TMX Layer Data");
-		}
-		int[] ids = new int[width * height];
-		if (encoding.equals("csv")) {
-			String[] array = data.getText().split(",");
-			for (int i = 0; i < array.length; i++)
-				ids[i] = (int)Long.parseLong(array[i].trim());
-		} else {
-			if (true)
-				if (encoding.equals("base64")) {
-					InputStream is = null;
-					try {
-						String compression = data.getAttribute("compression", null);
-						byte[] bytes = Base64Coder.decode(data.getText());
-						if (compression == null)
-							is = new ByteArrayInputStream(bytes);
-						else if (compression.equals("gzip"))
-							is = new GZIPInputStream(new ByteArrayInputStream(bytes), bytes.length);
-						else if (compression.equals("zlib"))
-							is = new InflaterInputStream(new ByteArrayInputStream(bytes));
-						else
-							throw new GdxRuntimeException("Unrecognised compression (" + compression + ") for TMX Layer Data");
-
-						byte[] temp = new byte[4];
-						for (int y = 0; y < height; y++) {
-							for (int x = 0; x < width; x++) {
-								int read = is.read(temp);
-								while (read < temp.length) {
-									int curr = is.read(temp, read, temp.length - read);
-									if (curr == -1) break;
-									read += curr;
-								}
-								if (read != temp.length)
-									throw new GdxRuntimeException("Error Reading TMX Layer Data: Premature end of tile data");
-								ids[y * width + x] = unsignedByteToInt(temp[0]) | unsignedByteToInt(temp[1]) << 8
-									| unsignedByteToInt(temp[2]) << 16 | unsignedByteToInt(temp[3]) << 24;
-							}
-						}
-					} catch (IOException e) {
-						throw new GdxRuntimeException("Error Reading TMX Layer Data - IOException: " + e.getMessage());
-					} finally {
-						StreamUtils.closeQuietly(is);
-					}
-				} else {
-					// any other value of 'encoding' is one we're not aware of, probably a feature of a future version of Tiled
-					// or another editor
-					throw new GdxRuntimeException("Unrecognised encoding (" + encoding + ") for TMX Layer Data");
-				}
-		}
-		return ids;
-	}
-
-	protected static int unsignedByteToInt (byte b) {
-		return (int)b & 0xFF;
-	}
-
-	protected static FileHandle getRelativeFileHandle (FileHandle file, String path) {
-		StringTokenizer tokenizer = new StringTokenizer(path, "\\/");
-		FileHandle result = file.parent();
-		while (tokenizer.hasMoreElements()) {
-			String token = tokenizer.nextToken();
-			if (token.equals(".."))
-				result = result.parent();
-			else {
-				result = result.child(token);
-			}
-		}
-		return result;
-	}
-
-}
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/TiledMapImageLayer.java b/gdx/src/com/badlogic/gdx/maps/tiled/TiledMapImageLayer.java
deleted file mode 100644
index 6818bbb..0000000
--- a/gdx/src/com/badlogic/gdx/maps/tiled/TiledMapImageLayer.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package com.badlogic.gdx.maps.tiled;
-
-import com.badlogic.gdx.graphics.g2d.TextureRegion;
-import com.badlogic.gdx.maps.MapLayer;
-
-public class TiledMapImageLayer extends MapLayer {
-	private int x;
-	private int y;
-	private TextureRegion region;
-	
-	public TiledMapImageLayer(TextureRegion region, int x, int y) {
-		this.region = region;
-		this.x = x;
-		this.y = y;
-	}
-	
-	public int getX() {
-		return x;
-	}
-	
-	public int getY() {
-		return y;
-	}
-	
-	public TextureRegion getTextureRegion () {
-		return region;
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/TiledMapRenderer.java b/gdx/src/com/badlogic/gdx/maps/tiled/TiledMapRenderer.java
index ee3afc7..f939632 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/TiledMapRenderer.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/TiledMapRenderer.java
@@ -1,29 +1,28 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.maps.tiled;
-
-import com.badlogic.gdx.maps.MapLayer;
-import com.badlogic.gdx.maps.MapObject;
-import com.badlogic.gdx.maps.MapRenderer;
-
-public interface TiledMapRenderer extends MapRenderer {
-	public void renderObjects (MapLayer layer);
-	public void renderObject (MapObject object);
-
-	public void renderTileLayer (TiledMapTileLayer layer);
-	public void renderImageLayer(TiledMapImageLayer layer);
-}
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.maps.tiled;
+
+import com.badlogic.gdx.maps.MapLayer;
+import com.badlogic.gdx.maps.MapObject;
+import com.badlogic.gdx.maps.MapRenderer;
+
+public interface TiledMapRenderer extends MapRenderer {
+	public void renderObjects (MapLayer layer);
+	public void renderObject (MapObject object);
+
+	public void renderTileLayer (TiledMapTileLayer layer);
+}
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/TmxMapHelper.java b/gdx/src/com/badlogic/gdx/maps/tiled/TmxMapHelper.java
new file mode 100644
index 0000000..a5fab68
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/TmxMapHelper.java
@@ -0,0 +1,101 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.maps.tiled;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.zip.GZIPInputStream;
+import java.util.zip.InflaterInputStream;
+
+import com.badlogic.gdx.utils.Base64Coder;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+import com.badlogic.gdx.utils.StreamUtils;
+import com.badlogic.gdx.utils.XmlReader.Element;
+
+/** Helper class for common tiled map tasks.
+ * @author hneuer */
+public final class TmxMapHelper {
+	static final int FLAG_FLIP_HORIZONTALLY = 0x80000000;
+	static final int FLAG_FLIP_VERTICALLY = 0x40000000;
+	static final int FLAG_FLIP_DIAGONALLY = 0x20000000;
+	static final int MASK_CLEAR = 0xE0000000;
+
+	private TmxMapHelper () {
+
+	}
+
+	static public int[] getTileIds (Element element, int width, int height) {
+		Element data = element.getChildByName("data");
+		String encoding = data.getAttribute("encoding", null);
+		if (encoding == null) { // no 'encoding' attribute means that the encoding is XML
+			throw new GdxRuntimeException("Unsupported encoding (XML) for TMX Layer Data");
+		}
+		int[] ids = new int[width * height];
+		if (encoding.equals("csv")) {
+			String[] array = data.getText().split(",");
+			for (int i = 0; i < array.length; i++)
+				ids[i] = (int)Long.parseLong(array[i].trim());
+		} else {
+			if (true)
+				if (encoding.equals("base64")) {
+					InputStream is = null;
+					try {
+						String compression = data.getAttribute("compression", null);
+						byte[] bytes = Base64Coder.decode(data.getText());
+						if (compression == null)
+							is = new ByteArrayInputStream(bytes);
+						else if (compression.equals("gzip"))
+							is = new GZIPInputStream(new ByteArrayInputStream(bytes), bytes.length);
+						else if (compression.equals("zlib"))
+							is = new InflaterInputStream(new ByteArrayInputStream(bytes));
+						else
+							throw new GdxRuntimeException("Unrecognised compression (" + compression + ") for TMX Layer Data");
+
+						byte[] temp = new byte[4];
+						for (int y = 0; y < height; y++) {
+							for (int x = 0; x < width; x++) {
+								int read = is.read(temp);
+								while (read < temp.length) {
+									int curr = is.read(temp, read, temp.length - read);
+									if (curr == -1) break;
+									read += curr;
+								}
+								if (read != temp.length)
+									throw new GdxRuntimeException("Error Reading TMX Layer Data: Premature end of tile data");
+								ids[y * width + x] = unsignedByteToInt(temp[0]) | unsignedByteToInt(temp[1]) << 8
+									| unsignedByteToInt(temp[2]) << 16 | unsignedByteToInt(temp[3]) << 24;
+							}
+						}
+					} catch (IOException e) {
+						throw new GdxRuntimeException("Error Reading TMX Layer Data - IOException: " + e.getMessage());
+					} finally {
+						StreamUtils.closeQuietly(is);
+					}
+				} else {
+					// any other value of 'encoding' is one we're not aware of, probably a feature of a future version of Tiled
+					// or another editor
+					throw new GdxRuntimeException("Unrecognised encoding (" + encoding + ") for TMX Layer Data");
+				}
+		}
+		return ids;
+	}
+
+	static public int unsignedByteToInt (byte b) {
+		return (int)b & 0xFF;
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/TmxMapLoader.java b/gdx/src/com/badlogic/gdx/maps/tiled/TmxMapLoader.java
index a64e068..af32752 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/TmxMapLoader.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/TmxMapLoader.java
@@ -16,34 +16,73 @@
 
 package com.badlogic.gdx.maps.tiled;
 
+import java.io.IOException;
+import java.util.StringTokenizer;
+
 import com.badlogic.gdx.assets.AssetDescriptor;
+import com.badlogic.gdx.assets.AssetLoaderParameters;
 import com.badlogic.gdx.assets.AssetManager;
+import com.badlogic.gdx.assets.loaders.AsynchronousAssetLoader;
 import com.badlogic.gdx.assets.loaders.FileHandleResolver;
 import com.badlogic.gdx.assets.loaders.TextureLoader;
 import com.badlogic.gdx.assets.loaders.TextureLoader.TextureParameter;
 import com.badlogic.gdx.assets.loaders.resolvers.InternalFileHandleResolver;
 import com.badlogic.gdx.files.FileHandle;
 import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.Texture.TextureFilter;
 import com.badlogic.gdx.graphics.g2d.TextureRegion;
 import com.badlogic.gdx.maps.ImageResolver;
 import com.badlogic.gdx.maps.ImageResolver.AssetManagerImageResolver;
 import com.badlogic.gdx.maps.ImageResolver.DirectImageResolver;
+import com.badlogic.gdx.maps.MapLayer;
+import com.badlogic.gdx.maps.MapObject;
 import com.badlogic.gdx.maps.MapProperties;
+import com.badlogic.gdx.maps.objects.EllipseMapObject;
+import com.badlogic.gdx.maps.objects.PolygonMapObject;
+import com.badlogic.gdx.maps.objects.PolylineMapObject;
+import com.badlogic.gdx.maps.objects.RectangleMapObject;
+import com.badlogic.gdx.maps.tiled.TiledMapTileLayer.Cell;
 import com.badlogic.gdx.maps.tiled.tiles.AnimatedTiledMapTile;
 import com.badlogic.gdx.maps.tiled.tiles.StaticTiledMapTile;
+import com.badlogic.gdx.math.Polygon;
+import com.badlogic.gdx.math.Polyline;
+import com.badlogic.gdx.utils.*;
 import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.LongArray;
 import com.badlogic.gdx.utils.GdxRuntimeException;
-import com.badlogic.gdx.utils.IntArray;
 import com.badlogic.gdx.utils.ObjectMap;
+import com.badlogic.gdx.utils.XmlReader;
 import com.badlogic.gdx.utils.XmlReader.Element;
-import java.io.IOException;
 
 /** @brief synchronous loader for TMX maps created with the Tiled tool */
-public class TmxMapLoader extends BaseTmxMapLoader<TmxMapLoader.Parameters> {
+public class TmxMapLoader extends AsynchronousAssetLoader<TiledMap, TmxMapLoader.Parameters> {
+
+	public static class Parameters extends AssetLoaderParameters<TiledMap> {
+		/** generate mipmaps? **/
+		public boolean generateMipMaps = false;
+		/** The TextureFilter to use for minification **/
+		public TextureFilter textureMinFilter = TextureFilter.Nearest;
+		/** The TextureFilter to use for magnification **/
+		public TextureFilter textureMagFilter = TextureFilter.Nearest;
+		/** Whether to convert the objects' pixel position and size to the equivalent in tile space. **/
+		public boolean convertObjectToTileSpace = false;
+	}
 
-	public static class Parameters extends BaseTmxMapLoader.Parameters {
+	protected static final int FLAG_FLIP_HORIZONTALLY = 0x80000000;
+	protected static final int FLAG_FLIP_VERTICALLY = 0x40000000;
+	protected static final int FLAG_FLIP_DIAGONALLY = 0x20000000;
+	protected static final int MASK_CLEAR = 0xE0000000;
 
-	}
+	protected XmlReader xml = new XmlReader();
+	protected Element root;
+	protected boolean convertObjectToTileSpace;
+
+	protected int mapTileWidth;
+	protected int mapTileHeight;
+	protected int mapWidthInPixels;
+	protected int mapHeightInPixels;
+
+	protected TiledMap map;
 
 	public TmxMapLoader () {
 		super(new InternalFileHandleResolver());
@@ -76,15 +115,11 @@ public class TmxMapLoader extends BaseTmxMapLoader<TmxMapLoader.Parameters> {
 			FileHandle tmxFile = resolve(fileName);
 			root = xml.parse(tmxFile);
 			ObjectMap<String, Texture> textures = new ObjectMap<String, Texture>();
-			Array<FileHandle> textureFiles = loadTilesets(root, tmxFile);
-			textureFiles.addAll(loadImages(root, tmxFile));
-			
-			for (FileHandle textureFile : textureFiles) {
+			for (FileHandle textureFile : loadTilesets(root, tmxFile)) {
 				Texture texture = new Texture(textureFile, parameters.generateMipMaps);
 				texture.setFilter(parameters.textureMinFilter, parameters.textureMagFilter);
 				textures.put(textureFile.path(), texture);
 			}
-
 			DirectImageResolver imageResolver = new DirectImageResolver(textures);
 			TiledMap map = loadTilemap(root, tmxFile, imageResolver);
 			map.setOwnedResources(textures.values().toArray());
@@ -135,9 +170,6 @@ public class TmxMapLoader extends BaseTmxMapLoader<TmxMapLoader.Parameters> {
 			for (FileHandle image : loadTilesets(root, tmxFile)) {
 				dependencies.add(new AssetDescriptor(image, Texture.class, texParams));
 			}
-			for (FileHandle image : loadImages(root, tmxFile)) {
-				dependencies.add(new AssetDescriptor(image, Texture.class, texParams));
-			}
 			return dependencies;
 		} catch (IOException e) {
 			throw new GdxRuntimeException("Couldn't load tilemap '" + fileName + "'", e);
@@ -175,15 +207,6 @@ public class TmxMapLoader extends BaseTmxMapLoader<TmxMapLoader.Parameters> {
 		mapWidthInPixels = mapWidth * tileWidth;
 		mapHeightInPixels = mapHeight * tileHeight;
 
-		if (mapOrientation != null) {
-			if ("staggered".equals(mapOrientation)) {
-				if (mapHeight > 1) {
-					mapWidthInPixels += tileWidth / 2;
-					mapHeightInPixels = mapHeightInPixels / 2 + tileHeight / 2;
-				}
-			}
-		}
-		
 		Element properties = root.getChildByName("properties");
 		if (properties != null) {
 			loadProperties(map.getProperties(), properties);
@@ -201,9 +224,6 @@ public class TmxMapLoader extends BaseTmxMapLoader<TmxMapLoader.Parameters> {
 			} else if (name.equals("objectgroup")) {
 				loadObjectGroup(map, element);
 			}
-			else if (name.equals("imagelayer")) {
-				loadImageLayer(map, element, tmxFile, imageResolver);
-			}
 		}
 		return map;
 	}
@@ -216,61 +236,20 @@ public class TmxMapLoader extends BaseTmxMapLoader<TmxMapLoader.Parameters> {
 		Array<FileHandle> images = new Array<FileHandle>();
 		for (Element tileset : root.getChildrenByName("tileset")) {
 			String source = tileset.getAttribute("source", null);
+			FileHandle image = null;
 			if (source != null) {
-				FileHandle tsxFile = getRelativeFileHandle(tmxFile, source);
-				tileset = xml.parse(tsxFile);
-				Element imageElement = tileset.getChildByName("image");
-				if (imageElement != null) {
-					String imageSource = tileset.getChildByName("image").getAttribute("source");
-					FileHandle image = getRelativeFileHandle(tsxFile, imageSource);
-					images.add(image);
-				} else {
-					for (Element tile : tileset.getChildrenByName("tile")) {
-						String imageSource = tile.getChildByName("image").getAttribute("source");
-						FileHandle image = getRelativeFileHandle(tsxFile, imageSource);
-						images.add(image);
-					}
-				}
+				FileHandle tsx = getRelativeFileHandle(tmxFile, source);
+				tileset = xml.parse(tsx);
+				String imageSource = tileset.getChildByName("image").getAttribute("source");
+				image = getRelativeFileHandle(tsx, imageSource);
 			} else {
-				Element imageElement = tileset.getChildByName("image");
-				if (imageElement != null) {
-					String imageSource = tileset.getChildByName("image").getAttribute("source");
-					FileHandle image = getRelativeFileHandle(tmxFile, imageSource);
-					images.add(image);
-				} else {
-					for (Element tile : tileset.getChildrenByName("tile")) {
-						String imageSource = tile.getChildByName("image").getAttribute("source");
-						FileHandle image = getRelativeFileHandle(tmxFile, imageSource);
-						images.add(image);
-					}
-				}
+				String imageSource = tileset.getChildByName("image").getAttribute("source");
+				image = getRelativeFileHandle(tmxFile, imageSource);
 			}
+			images.add(image);
 		}
 		return images;
 	}
-	
-	/** Loads the images in image layers
-	 * @param root the root XML element
-	 * @return a list of filenames for images inside image layers
-	 * @throws IOException */
-	protected Array<FileHandle> loadImages (Element root, FileHandle tmxFile) throws IOException {
-		Array<FileHandle> images = new Array<FileHandle>();
-		
-		for (Element imageLayer : root.getChildrenByName("imagelayer")) {
-			Element image = imageLayer.getChildByName("image");
-			String source = image.getAttribute("source", null);
-
-			if (source != null) {
-				FileHandle handle = getRelativeFileHandle(tmxFile, source);
-				
-				if (!images.contains(handle, false)) {
-					images.add(handle);
-				}
-			}
-		}
-		
-		return images;
-	}
 
 	/** Loads the specified tileset data, adding it to the collection of the specified map, given the XML element, the tmxFile and
 	 * an {@link ImageResolver} used to retrieve the tileset Textures.
@@ -328,13 +307,10 @@ public class TmxMapLoader extends BaseTmxMapLoader<TmxMapLoader.Parameters> {
 						offsetX = offset.getIntAttribute("x", 0);
 						offsetY = offset.getIntAttribute("y", 0);
 					}
-					Element imageElement = element.getChildByName("image");
-					if (imageElement != null) {
-						imageSource = imageElement.getAttribute("source");
-						imageWidth = imageElement.getIntAttribute("width", 0);
-						imageHeight = imageElement.getIntAttribute("height", 0);
-						image = getRelativeFileHandle(tsx, imageSource);
-					}					
+					imageSource = element.getChildByName("image").getAttribute("source");
+					imageWidth = element.getChildByName("image").getIntAttribute("width", 0);
+					imageHeight = element.getChildByName("image").getIntAttribute("height", 0);
+					image = getRelativeFileHandle(tsx, imageSource);
 				} catch (IOException e) {
 					throw new GdxRuntimeException("Error parsing external tileset.");
 				}
@@ -344,63 +320,42 @@ public class TmxMapLoader extends BaseTmxMapLoader<TmxMapLoader.Parameters> {
 					offsetX = offset.getIntAttribute("x", 0);
 					offsetY = offset.getIntAttribute("y", 0);
 				}
-				Element imageElement = element.getChildByName("image");
-				if (imageElement != null) {
-					imageSource = imageElement.getAttribute("source");
-					imageWidth = imageElement.getIntAttribute("width", 0);
-					imageHeight = imageElement.getIntAttribute("height", 0);
-					image = getRelativeFileHandle(tmxFile, imageSource);
-				}
+				imageSource = element.getChildByName("image").getAttribute("source");
+				imageWidth = element.getChildByName("image").getIntAttribute("width", 0);
+				imageHeight = element.getChildByName("image").getIntAttribute("height", 0);
+				image = getRelativeFileHandle(tmxFile, imageSource);
 			}
 
+			TextureRegion texture = imageResolver.getImage(image.path());
+
 			TiledMapTileSet tileset = new TiledMapTileSet();
+			MapProperties props = tileset.getProperties();
 			tileset.setName(name);
-			tileset.getProperties().put("firstgid", firstgid);
-			if (image != null) {
-				TextureRegion texture = imageResolver.getImage(image.path());
-	
-				MapProperties props = tileset.getProperties();
-				props.put("imagesource", imageSource);
-				props.put("imagewidth", imageWidth);
-				props.put("imageheight", imageHeight);
-				props.put("tilewidth", tilewidth);
-				props.put("tileheight", tileheight);
-				props.put("margin", margin);
-				props.put("spacing", spacing);
-	
-				int stopWidth = texture.getRegionWidth() - tilewidth;
-				int stopHeight = texture.getRegionHeight() - tileheight;
-	
-				int id = firstgid;
-	
-				for (int y = margin; y <= stopHeight; y += tileheight + spacing) {
-					for (int x = margin; x <= stopWidth; x += tilewidth + spacing) {
-						TextureRegion tileRegion = new TextureRegion(texture, x, y, tilewidth, tileheight);
-						TiledMapTile tile = new StaticTiledMapTile(tileRegion);
-						tile.setId(id);
-						tile.setOffsetX(offsetX);
-						tile.setOffsetY(-offsetY);
-						tileset.putTile(id++, tile);
-					}
-				}
-			} else {
-				Array<Element> tileElements = element.getChildrenByName("tile");
-				for (Element tileElement : tileElements) {
-					Element imageElement = tileElement.getChildByName("image");
-					if (imageElement != null) {
-						imageSource = imageElement.getAttribute("source");
-						imageWidth = imageElement.getIntAttribute("width", 0);
-						imageHeight = imageElement.getIntAttribute("height", 0);
-						image = getRelativeFileHandle(tmxFile, imageSource);
-					}
-					TextureRegion texture = imageResolver.getImage(image.path());
-					TiledMapTile tile = new StaticTiledMapTile(texture);
-					tile.setId(firstgid + tileElement.getIntAttribute("id"));
+			props.put("firstgid", firstgid);
+			props.put("imagesource", imageSource);
+			props.put("imagewidth", imageWidth);
+			props.put("imageheight", imageHeight);
+			props.put("tilewidth", tilewidth);
+			props.put("tileheight", tileheight);
+			props.put("margin", margin);
+			props.put("spacing", spacing);
+
+			int stopWidth = texture.getRegionWidth() - tilewidth;
+			int stopHeight = texture.getRegionHeight() - tileheight;
+
+			int id = firstgid;
+
+			for (int y = margin; y <= stopHeight; y += tileheight + spacing) {
+				for (int x = margin; x <= stopWidth; x += tilewidth + spacing) {
+					TextureRegion tileRegion = new TextureRegion(texture, x, y, tilewidth, tileheight);
+					TiledMapTile tile = new StaticTiledMapTile(tileRegion);
+					tile.setId(id);
 					tile.setOffsetX(offsetX);
 					tile.setOffsetY(-offsetY);
-					tileset.putTile(tile.getId(), tile);
+					tileset.putTile(id++, tile);
 				}
 			}
+
 			Array<Element> tileElements = element.getChildrenByName("tile");
 
 			Array<AnimatedTiledMapTile> animatedTiles = new Array<AnimatedTiledMapTile>();
@@ -413,7 +368,7 @@ public class TmxMapLoader extends BaseTmxMapLoader<TmxMapLoader.Parameters> {
 					if (animationElement != null) {
 
 						Array<StaticTiledMapTile> staticTiles = new Array<StaticTiledMapTile>();
-						IntArray intervals = new IntArray();
+						LongArray intervals = new LongArray();
 						for (Element frameElement: animationElement.getChildrenByName("frame")) {
 							staticTiles.add((StaticTiledMapTile) tileset.getTile(firstgid + frameElement.getIntAttribute("tileid")));
 							intervals.add(frameElement.getIntAttribute("duration"));
@@ -452,4 +407,180 @@ public class TmxMapLoader extends BaseTmxMapLoader<TmxMapLoader.Parameters> {
 		}
 	}
 
+	/** Load one layer (a 'layer' tag).
+	 * @param map
+	 * @param element */
+	protected void loadTileLayer (TiledMap map, Element element) {
+		if (element.getName().equals("layer")) {
+			String name = element.getAttribute("name", null);
+			int width = element.getIntAttribute("width", 0);
+			int height = element.getIntAttribute("height", 0);
+			int tileWidth = element.getParent().getIntAttribute("tilewidth", 0);
+			int tileHeight = element.getParent().getIntAttribute("tileheight", 0);
+			boolean visible = element.getIntAttribute("visible", 1) == 1;
+			float opacity = element.getFloatAttribute("opacity", 1.0f);
+			TiledMapTileLayer layer = new TiledMapTileLayer(width, height, tileWidth, tileHeight);
+			layer.setVisible(visible);
+			layer.setOpacity(opacity);
+			layer.setName(name);
+
+			int[] ids = TmxMapHelper.getTileIds(element, width, height);
+			TiledMapTileSets tilesets = map.getTileSets();
+			for (int y = 0; y < height; y++) {
+				for (int x = 0; x < width; x++) {
+					int id = ids[y * width + x];
+					boolean flipHorizontally = ((id & FLAG_FLIP_HORIZONTALLY) != 0);
+					boolean flipVertically = ((id & FLAG_FLIP_VERTICALLY) != 0);
+					boolean flipDiagonally = ((id & FLAG_FLIP_DIAGONALLY) != 0);
+
+					TiledMapTile tile = tilesets.getTile(id & ~MASK_CLEAR);
+					if (tile != null) {
+						Cell cell = createTileLayerCell(flipHorizontally, flipVertically, flipDiagonally);
+						cell.setTile(tile);
+						layer.setCell(x, height - 1 - y, cell);
+					}
+				}
+			}
+
+			Element properties = element.getChildByName("properties");
+			if (properties != null) {
+				loadProperties(layer.getProperties(), properties);
+			}
+			map.getLayers().add(layer);
+		}
+	}
+
+	protected void loadObjectGroup (TiledMap map, Element element) {
+		if (element.getName().equals("objectgroup")) {
+			String name = element.getAttribute("name", null);
+			MapLayer layer = new MapLayer();
+			layer.setName(name);
+			Element properties = element.getChildByName("properties");
+			if (properties != null) {
+				loadProperties(layer.getProperties(), properties);
+			}
+
+			for (Element objectElement : element.getChildrenByName("object")) {
+				loadObject(layer, objectElement);
+			}
+
+			map.getLayers().add(layer);
+		}
+	}
+
+	protected void loadObject (MapLayer layer, Element element) {
+		if (element.getName().equals("object")) {
+			MapObject object = null;
+
+			float scaleX = convertObjectToTileSpace ? 1.0f / mapTileWidth : 1.0f;
+			float scaleY = convertObjectToTileSpace ? 1.0f / mapTileHeight : 1.0f;
+
+			float x = element.getFloatAttribute("x", 0) * scaleX;
+			float y = (mapHeightInPixels - element.getFloatAttribute("y", 0)) * scaleY;
+
+			float width = element.getFloatAttribute("width", 0) * scaleX;
+			float height = element.getFloatAttribute("height", 0) * scaleY;
+
+			if (element.getChildCount() > 0) {
+				Element child = null;
+				if ((child = element.getChildByName("polygon")) != null) {
+					String[] points = child.getAttribute("points").split(" ");
+					float[] vertices = new float[points.length * 2];
+					for (int i = 0; i < points.length; i++) {
+						String[] point = points[i].split(",");
+						vertices[i * 2] = Float.parseFloat(point[0]) * scaleX;
+						vertices[i * 2 + 1] = -Float.parseFloat(point[1]) * scaleY;
+					}
+					Polygon polygon = new Polygon(vertices);
+					polygon.setPosition(x, y);
+					object = new PolygonMapObject(polygon);
+				} else if ((child = element.getChildByName("polyline")) != null) {
+					String[] points = child.getAttribute("points").split(" ");
+					float[] vertices = new float[points.length * 2];
+					for (int i = 0; i < points.length; i++) {
+						String[] point = points[i].split(",");
+						vertices[i * 2] = Float.parseFloat(point[0]) * scaleX;
+						vertices[i * 2 + 1] = -Float.parseFloat(point[1]) * scaleY;
+					}
+					Polyline polyline = new Polyline(vertices);
+					polyline.setPosition(x, y);
+					object = new PolylineMapObject(polyline);
+				} else if ((child = element.getChildByName("ellipse")) != null) {
+					object = new EllipseMapObject(x, y - height, width, height);
+				}
+			}
+			if (object == null) {
+				object = new RectangleMapObject(x, y - height, width, height);
+			}
+			object.setName(element.getAttribute("name", null));
+			String rotation = element.getAttribute("rotation", null);
+			if (rotation != null) {
+				object.getProperties().put("rotation", Float.parseFloat(rotation));
+			}
+			String type = element.getAttribute("type", null);
+			if (type != null) {
+				object.getProperties().put("type", type);
+			}
+			int gid = element.getIntAttribute("gid", -1);
+			if (gid != -1) {
+				object.getProperties().put("gid", gid);
+			}
+			object.getProperties().put("x", x * scaleX);
+			object.getProperties().put("y", (y - height) * scaleY);
+			object.setVisible(element.getIntAttribute("visible", 1) == 1);
+			Element properties = element.getChildByName("properties");
+			if (properties != null) {
+				loadProperties(object.getProperties(), properties);
+			}
+			layer.getObjects().add(object);
+		}
+	}
+
+	protected void loadProperties (MapProperties properties, Element element) {
+		if (element.getName().equals("properties")) {
+			for (Element property : element.getChildrenByName("property")) {
+				String name = property.getAttribute("name", null);
+				String value = property.getAttribute("value", null);
+				if (value == null) {
+					value = property.getText();
+				}
+				properties.put(name, value);
+			}
+		}
+	}
+
+	protected Cell createTileLayerCell (boolean flipHorizontally, boolean flipVertically, boolean flipDiagonally) {
+		Cell cell = new Cell();
+		if (flipDiagonally) {
+			if (flipHorizontally && flipVertically) {
+				cell.setFlipHorizontally(true);
+				cell.setRotation(Cell.ROTATE_270);
+			} else if (flipHorizontally) {
+				cell.setRotation(Cell.ROTATE_270);
+			} else if (flipVertically) {
+				cell.setRotation(Cell.ROTATE_90);
+			} else {
+				cell.setFlipVertically(true);
+				cell.setRotation(Cell.ROTATE_270);
+			}
+		} else {
+			cell.setFlipHorizontally(flipHorizontally);
+			cell.setFlipVertically(flipVertically);
+		}
+		return cell;
+	}
+
+	protected static FileHandle getRelativeFileHandle (FileHandle file, String path) {
+		StringTokenizer tokenizer = new StringTokenizer(path, "\\/");
+		FileHandle result = file.parent();
+		while (tokenizer.hasMoreElements()) {
+			String token = tokenizer.nextToken();
+			if (token.equals(".."))
+				result = result.parent();
+			else {
+				result = result.child(token);
+			}
+		}
+		return result;
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/BatchTiledMapRenderer.java b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/BatchTiledMapRenderer.java
index 0b7b375..c4ae546 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/BatchTiledMapRenderer.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/BatchTiledMapRenderer.java
@@ -1,256 +1,163 @@
-/*******************************************************************************
- * Copyright 2013 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.maps.tiled.renderers;
-
-import static com.badlogic.gdx.graphics.g2d.Batch.C1;
-import static com.badlogic.gdx.graphics.g2d.Batch.C2;
-import static com.badlogic.gdx.graphics.g2d.Batch.C3;
-import static com.badlogic.gdx.graphics.g2d.Batch.C4;
-import static com.badlogic.gdx.graphics.g2d.Batch.U1;
-import static com.badlogic.gdx.graphics.g2d.Batch.U2;
-import static com.badlogic.gdx.graphics.g2d.Batch.U3;
-import static com.badlogic.gdx.graphics.g2d.Batch.U4;
-import static com.badlogic.gdx.graphics.g2d.Batch.V1;
-import static com.badlogic.gdx.graphics.g2d.Batch.V2;
-import static com.badlogic.gdx.graphics.g2d.Batch.V3;
-import static com.badlogic.gdx.graphics.g2d.Batch.V4;
-import static com.badlogic.gdx.graphics.g2d.Batch.X1;
-import static com.badlogic.gdx.graphics.g2d.Batch.X2;
-import static com.badlogic.gdx.graphics.g2d.Batch.X3;
-import static com.badlogic.gdx.graphics.g2d.Batch.X4;
-import static com.badlogic.gdx.graphics.g2d.Batch.Y1;
-import static com.badlogic.gdx.graphics.g2d.Batch.Y2;
-import static com.badlogic.gdx.graphics.g2d.Batch.Y3;
-import static com.badlogic.gdx.graphics.g2d.Batch.Y4;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.graphics.Color;
-import com.badlogic.gdx.graphics.OrthographicCamera;
-import com.badlogic.gdx.graphics.g2d.Batch;
-import com.badlogic.gdx.graphics.g2d.SpriteBatch;
-import com.badlogic.gdx.graphics.g2d.TextureRegion;
-import com.badlogic.gdx.maps.MapLayer;
-import com.badlogic.gdx.maps.MapObject;
-import com.badlogic.gdx.maps.tiled.TiledMap;
-import com.badlogic.gdx.maps.tiled.TiledMapImageLayer;
-import com.badlogic.gdx.maps.tiled.TiledMapRenderer;
-import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
-import com.badlogic.gdx.maps.tiled.TiledMapTileLayer.Cell;
-import com.badlogic.gdx.maps.tiled.tiles.AnimatedTiledMapTile;
-import com.badlogic.gdx.math.Matrix4;
-import com.badlogic.gdx.math.Rectangle;
-import com.badlogic.gdx.utils.Disposable;
-
-public abstract class BatchTiledMapRenderer implements TiledMapRenderer, Disposable {
-	static protected final int NUM_VERTICES = 20;
-	
-	protected TiledMap map;
-
-	protected float unitScale;
-
-	protected Batch batch;
-
-	protected Rectangle viewBounds;
-	protected Rectangle imageBounds = new Rectangle();
-
-	protected boolean ownsBatch;
-
-	protected float vertices[] = new float[NUM_VERTICES];
-
-	public TiledMap getMap () {
-		return map;
-	}
-
-	public void setMap (TiledMap map) {
-		this.map = map;
-	}
-
-	public float getUnitScale () {
-		return unitScale;
-	}
-
-	public Batch getBatch () {
-		return batch;
-	}
-
-	public Rectangle getViewBounds () {
-		return viewBounds;
-	}
-
-	public BatchTiledMapRenderer (TiledMap map) {
-		this(map, 1.0f);
-	}
-
-	public BatchTiledMapRenderer (TiledMap map, float unitScale) {
-		this.map = map;
-		this.unitScale = unitScale;
-		this.viewBounds = new Rectangle();
-		this.batch = new SpriteBatch();
-		this.ownsBatch = true;
-	}
-
-	public BatchTiledMapRenderer (TiledMap map, Batch batch) {
-		this(map, 1.0f, batch);
-	}
-
-	public BatchTiledMapRenderer (TiledMap map, float unitScale, Batch batch) {
-		this.map = map;
-		this.unitScale = unitScale;
-		this.viewBounds = new Rectangle();
-		this.batch = batch;
-		this.ownsBatch = false;
-	}
-
-	@Override
-	public void setView (OrthographicCamera camera) {
-		batch.setProjectionMatrix(camera.combined);
-		float width = camera.viewportWidth * camera.zoom;
-		float height = camera.viewportHeight * camera.zoom;
-		viewBounds.set(camera.position.x - width / 2, camera.position.y - height / 2, width, height);
-	}
-
-	@Override
-	public void setView (Matrix4 projection, float x, float y, float width, float height) {
-		batch.setProjectionMatrix(projection);
-		viewBounds.set(x, y, width, height);
-	}
-
-	@Override
-	public void render () {
-		beginRender();
-		for (MapLayer layer : map.getLayers()) {
-			if (layer.isVisible()) {
-				if (layer instanceof TiledMapTileLayer) {
-					renderTileLayer((TiledMapTileLayer)layer);
-				} if (layer instanceof TiledMapImageLayer) {
-					renderImageLayer((TiledMapImageLayer)layer);
-				} else {
-					renderObjects(layer);
-				}
-			}
-		}
-		endRender();
-	}
-
-	@Override
-	public void render (int[] layers) {
-		beginRender();
-		for (int layerIdx : layers) {
-			MapLayer layer = map.getLayers().get(layerIdx);
-			if (layer.isVisible()) {
-				if (layer instanceof TiledMapTileLayer) {
-					renderTileLayer((TiledMapTileLayer)layer);
-				} else if (layer instanceof TiledMapImageLayer) {
-					renderImageLayer((TiledMapImageLayer)layer);
-				} else {
-					renderObjects(layer);
-				}
-			}
-		}
-		endRender();
-	}
-
-	@Override
-	public void renderObjects(MapLayer layer) {
-		for (MapObject object : layer.getObjects()) {
-			renderObject(object);
-		}
-	}
-
-	@Override
-	public void renderObject(MapObject object) {
-
-	}
-	
-	@Override
-	public void renderImageLayer(TiledMapImageLayer layer) {
-		final Color batchColor = batch.getColor();
-		final float color = Color.toFloatBits(batchColor.r,
-														  batchColor.g,
-														  batchColor.b,
-														  batchColor.a * layer.getOpacity());
-		
-		final float[] vertices = this.vertices;
-		
-		TextureRegion region = layer.getTextureRegion();
-
-		if (region == null) {
-			return;
-		}
-		
-		final float x = layer.getX();
-		final float y = layer.getY();
-		final float x1 = x * unitScale;
-		final float y1 = y * unitScale;
-		final float x2 = x1 + region.getRegionWidth() * unitScale;
-		final float y2 = y1 + region.getRegionHeight() * unitScale;
-		
-		imageBounds.set(x1, y1, x2 - x1, y2 - y1);
-		
-		if (viewBounds.contains(imageBounds) || viewBounds.overlaps(imageBounds)) {
-			final float u1 = region.getU();
-			final float v1 = region.getV2();
-			final float u2 = region.getU2();
-			final float v2 = region.getV();
-
-			vertices[X1] = x1;
-			vertices[Y1] = y1;
-			vertices[C1] = color;
-			vertices[U1] = u1;
-			vertices[V1] = v1;
-
-			vertices[X2] = x1;
-			vertices[Y2] = y2;
-			vertices[C2] = color;
-			vertices[U2] = u1;
-			vertices[V2] = v2;
-
-			vertices[X3] = x2;
-			vertices[Y3] = y2;
-			vertices[C3] = color;
-			vertices[U3] = u2;
-			vertices[V3] = v2;
-
-			vertices[X4] = x2;
-			vertices[Y4] = y1;
-			vertices[C4] = color;
-			vertices[U4] = u2;
-			vertices[V4] = v1;
-
-			batch.draw(region.getTexture(), vertices, 0, NUM_VERTICES);
-		}
-	}
-
-	/** Called before the rendering of all layers starts. */
-	protected void beginRender () {
-		AnimatedTiledMapTile.updateAnimationBaseTime();
-		batch.begin();
-	}
-
-	/** Called after the rendering of all layers ended. */
-	protected void endRender () {
-		batch.end();
-	}
-
-	@Override
-	public void dispose () {
-		if (ownsBatch) {
-			batch.dispose();
-		}
-	}
-
-}
+/*******************************************************************************
+ * Copyright 2013 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.maps.tiled.renderers;
+
+import com.badlogic.gdx.graphics.OrthographicCamera;
+import com.badlogic.gdx.graphics.g2d.Batch;
+import com.badlogic.gdx.graphics.g2d.SpriteBatch;
+import com.badlogic.gdx.maps.MapLayer;
+import com.badlogic.gdx.maps.MapObject;
+import com.badlogic.gdx.maps.tiled.TiledMap;
+import com.badlogic.gdx.maps.tiled.TiledMapRenderer;
+import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
+import com.badlogic.gdx.maps.tiled.tiles.AnimatedTiledMapTile;
+import com.badlogic.gdx.math.Matrix4;
+import com.badlogic.gdx.math.Rectangle;
+import com.badlogic.gdx.utils.Disposable;
+
+public abstract class BatchTiledMapRenderer implements TiledMapRenderer, Disposable {
+	protected TiledMap map;
+
+	protected float unitScale;
+
+	protected Batch spriteBatch;
+
+	protected Rectangle viewBounds;
+
+	protected boolean ownsSpriteBatch;
+
+	protected float vertices[] = new float[20];
+
+	public TiledMap getMap () {
+		return map;
+	}
+
+	public void setMap (TiledMap map) {
+		this.map = map;
+	}
+
+	public float getUnitScale () {
+		return unitScale;
+	}
+
+	public Batch getSpriteBatch () {
+		return spriteBatch;
+	}
+
+	public Rectangle getViewBounds () {
+		return viewBounds;
+	}
+
+	public BatchTiledMapRenderer (TiledMap map) {
+		this(map, 1.0f);
+	}
+
+	public BatchTiledMapRenderer (TiledMap map, float unitScale) {
+		this.map = map;
+		this.unitScale = unitScale;
+		this.viewBounds = new Rectangle();
+		this.spriteBatch = new SpriteBatch();
+		this.ownsSpriteBatch = true;
+	}
+
+	public BatchTiledMapRenderer (TiledMap map, Batch batch) {
+		this(map, 1.0f, batch);
+	}
+
+	public BatchTiledMapRenderer (TiledMap map, float unitScale, Batch batch) {
+		this.map = map;
+		this.unitScale = unitScale;
+		this.viewBounds = new Rectangle();
+		this.spriteBatch = batch;
+		this.ownsSpriteBatch = false;
+	}
+
+	@Override
+	public void setView (OrthographicCamera camera) {
+		spriteBatch.setProjectionMatrix(camera.combined);
+		float width = camera.viewportWidth * camera.zoom;
+		float height = camera.viewportHeight * camera.zoom;
+		viewBounds.set(camera.position.x - width / 2, camera.position.y - height / 2, width, height);
+	}
+
+	@Override
+	public void setView (Matrix4 projection, float x, float y, float width, float height) {
+		spriteBatch.setProjectionMatrix(projection);
+		viewBounds.set(x, y, width, height);
+	}
+
+	@Override
+	public void render () {
+		beginRender();
+		for (MapLayer layer : map.getLayers()) {
+			if (layer.isVisible()) {
+				if (layer instanceof TiledMapTileLayer) {
+					renderTileLayer((TiledMapTileLayer)layer);
+				} else {
+					renderObjects(layer);
+				}
+			}
+		}
+		endRender();
+	}
+
+	@Override
+	public void render (int[] layers) {
+		beginRender();
+		for (int layerIdx : layers) {
+			MapLayer layer = map.getLayers().get(layerIdx);
+			if (layer.isVisible()) {
+				if (layer instanceof TiledMapTileLayer) {
+					renderTileLayer((TiledMapTileLayer)layer);
+				} else {
+					renderObjects(layer);
+				}
+			}
+		}
+		endRender();
+	}
+
+	@Override
+	public void renderObjects(MapLayer layer) {
+		for (MapObject object : layer.getObjects()) {
+			renderObject(object);
+		}
+	}
+
+	@Override
+	public void renderObject(MapObject object) {
+
+	}
+
+	/** Called before the rendering of all layers starts. */
+	protected void beginRender () {
+		AnimatedTiledMapTile.updateAnimationBaseTime();
+		spriteBatch.begin();
+	}
+
+	/** Called after the rendering of all layers ended. */
+	protected void endRender () {
+		spriteBatch.end();
+	}
+
+	@Override
+	public void dispose () {
+		if (ownsSpriteBatch) {
+			spriteBatch.dispose();
+		}
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/HexagonalTiledMapRenderer.java b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/HexagonalTiledMapRenderer.java
index 7b4de5b..01bda85 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/HexagonalTiledMapRenderer.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/HexagonalTiledMapRenderer.java
@@ -46,7 +46,7 @@ public class HexagonalTiledMapRenderer extends BatchTiledMapRenderer {
 
 	@Override
 	public void renderTileLayer (TiledMapTileLayer layer) {
-		final Color batchColor = batch.getColor();
+		final Color batchColor = spriteBatch.getColor();
 		final float color = Color.toFloatBits(batchColor.r, batchColor.g, batchColor.b, batchColor.a * layer.getOpacity());
 
 		final int layerWidth = layer.getWidth();
@@ -154,7 +154,7 @@ public class HexagonalTiledMapRenderer extends BatchTiledMapRenderer {
 						vertices[V4] = tempV;
 						break;
 					}
-					batch.draw(region.getTexture(), vertices, 0, NUM_VERTICES);
+					spriteBatch.draw(region.getTexture(), vertices, 0, 20);
 				}
 			}
 		}
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/IsometricStaggeredTiledMapRenderer.java b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/IsometricStaggeredTiledMapRenderer.java
index 4edb6ec..9c281fa 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/IsometricStaggeredTiledMapRenderer.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/IsometricStaggeredTiledMapRenderer.java
@@ -46,7 +46,7 @@ public class IsometricStaggeredTiledMapRenderer extends BatchTiledMapRenderer {
 
 	@Override
 	public void renderTileLayer (TiledMapTileLayer layer) {
-		final Color batchColor = batch.getColor();
+		final Color batchColor = spriteBatch.getColor();
 		final float color = Color.toFloatBits(batchColor.r, batchColor.g, batchColor.b, batchColor.a * layer.getOpacity());
 
 		final int layerWidth = layer.getWidth();
@@ -177,7 +177,7 @@ public class IsometricStaggeredTiledMapRenderer extends BatchTiledMapRenderer {
 						}
 						}
 					}
-					batch.draw(region.getTexture(), vertices, 0, NUM_VERTICES);
+					spriteBatch.draw(region.getTexture(), vertices, 0, 20);
 				}
 			}
 		}
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/IsometricTiledMapRenderer.java b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/IsometricTiledMapRenderer.java
index 7924565..a4bfa21 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/IsometricTiledMapRenderer.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/IsometricTiledMapRenderer.java
@@ -1,229 +1,229 @@
-/*******************************************************************************
- * Copyright 2013 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.maps.tiled.renderers;
-
-import static com.badlogic.gdx.graphics.g2d.Batch.*;
-
-import com.badlogic.gdx.graphics.Color;
-import com.badlogic.gdx.graphics.g2d.Batch;
-import com.badlogic.gdx.graphics.g2d.TextureRegion;
-import com.badlogic.gdx.maps.tiled.TiledMap;
-import com.badlogic.gdx.maps.tiled.TiledMapTile;
-import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
-import com.badlogic.gdx.maps.tiled.TiledMapTileLayer.Cell;
-import com.badlogic.gdx.math.Matrix4;
-import com.badlogic.gdx.math.Vector2;
-import com.badlogic.gdx.math.Vector3;
-
-public class IsometricTiledMapRenderer extends BatchTiledMapRenderer {
-
-	private Matrix4 isoTransform;
-	private Matrix4 invIsotransform;
-	private Vector3 screenPos = new Vector3();
-
-	private Vector2 topRight = new Vector2();
-	private Vector2 bottomLeft = new Vector2();
-	private Vector2 topLeft = new Vector2();
-	private Vector2 bottomRight = new Vector2();
-
-	public IsometricTiledMapRenderer (TiledMap map) {
-		super(map);
-		init();
-	}
-
-	public IsometricTiledMapRenderer (TiledMap map, Batch batch) {
-		super(map, batch);
-		init();
-	}
-
-	public IsometricTiledMapRenderer (TiledMap map, float unitScale) {
-		super(map, unitScale);
-		init();
-	}
-
-	public IsometricTiledMapRenderer (TiledMap map, float unitScale, Batch batch) {
-		super(map, unitScale, batch);
-		init();
-	}
-
-	private void init () {
-		// create the isometric transform
-		isoTransform = new Matrix4();
-		isoTransform.idt();
-
-		// isoTransform.translate(0, 32, 0);
-		isoTransform.scale((float)(Math.sqrt(2.0) / 2.0), (float)(Math.sqrt(2.0) / 4.0), 1.0f);
-		isoTransform.rotate(0.0f, 0.0f, 1.0f, -45);
-
-		// ... and the inverse matrix
-		invIsotransform = new Matrix4(isoTransform);
-		invIsotransform.inv();
-	}
-
-	private Vector3 translateScreenToIso (Vector2 vec) {
-		screenPos.set(vec.x, vec.y, 0);
-		screenPos.mul(invIsotransform);
-
-		return screenPos;
-	}
-
-	@Override
-	public void renderTileLayer (TiledMapTileLayer layer) {
-		final Color batchColor = batch.getColor();
-		final float color = Color.toFloatBits(batchColor.r, batchColor.g, batchColor.b, batchColor.a * layer.getOpacity());
-
-		float tileWidth = layer.getTileWidth() * unitScale;
-		float tileHeight = layer.getTileHeight() * unitScale;
-		float halfTileWidth = tileWidth * 0.5f;
-		float halfTileHeight = tileHeight * 0.5f;
-
-		// setting up the screen points
-		// COL1
-		topRight.set(viewBounds.x + viewBounds.width, viewBounds.y);
-		// COL2
-		bottomLeft.set(viewBounds.x, viewBounds.y + viewBounds.height);
-		// ROW1
-		topLeft.set(viewBounds.x, viewBounds.y);
-		// ROW2
-		bottomRight.set(viewBounds.x + viewBounds.width, viewBounds.y + viewBounds.height);
-
-		// transforming screen coordinates to iso coordinates
-		int row1 = (int)(translateScreenToIso(topLeft).y / tileWidth) - 2;
-		int row2 = (int)(translateScreenToIso(bottomRight).y / tileWidth) + 2;
-
-		int col1 = (int)(translateScreenToIso(bottomLeft).x / tileWidth) - 2;
-		int col2 = (int)(translateScreenToIso(topRight).x / tileWidth) + 2;
-
-		for (int row = row2; row >= row1; row--) {
-			for (int col = col1; col <= col2; col++) {
-				float x = (col * halfTileWidth) + (row * halfTileWidth);
-				float y = (row * halfTileHeight) - (col * halfTileHeight);
-
-				final TiledMapTileLayer.Cell cell = layer.getCell(col, row);
-				if (cell == null) continue;
-				final TiledMapTile tile = cell.getTile();
-
-				if (tile != null) {
-					final boolean flipX = cell.getFlipHorizontally();
-					final boolean flipY = cell.getFlipVertically();
-					final int rotations = cell.getRotation();
-
-					TextureRegion region = tile.getTextureRegion();
-
-					float x1 = x + tile.getOffsetX() * unitScale;
-					float y1 = y + tile.getOffsetY() * unitScale;
-					float x2 = x1 + region.getRegionWidth() * unitScale;
-					float y2 = y1 + region.getRegionHeight() * unitScale;
-
-					float u1 = region.getU();
-					float v1 = region.getV2();
-					float u2 = region.getU2();
-					float v2 = region.getV();
-
-					vertices[X1] = x1;
-					vertices[Y1] = y1;
-					vertices[C1] = color;
-					vertices[U1] = u1;
-					vertices[V1] = v1;
-
-					vertices[X2] = x1;
-					vertices[Y2] = y2;
-					vertices[C2] = color;
-					vertices[U2] = u1;
-					vertices[V2] = v2;
-
-					vertices[X3] = x2;
-					vertices[Y3] = y2;
-					vertices[C3] = color;
-					vertices[U3] = u2;
-					vertices[V3] = v2;
-
-					vertices[X4] = x2;
-					vertices[Y4] = y1;
-					vertices[C4] = color;
-					vertices[U4] = u2;
-					vertices[V4] = v1;
-
-					if (flipX) {
-						float temp = vertices[U1];
-						vertices[U1] = vertices[U3];
-						vertices[U3] = temp;
-						temp = vertices[U2];
-						vertices[U2] = vertices[U4];
-						vertices[U4] = temp;
-					}
-					if (flipY) {
-						float temp = vertices[V1];
-						vertices[V1] = vertices[V3];
-						vertices[V3] = temp;
-						temp = vertices[V2];
-						vertices[V2] = vertices[V4];
-						vertices[V4] = temp;
-					}
-					if (rotations != 0) {
-						switch (rotations) {
-						case Cell.ROTATE_90: {
-							float tempV = vertices[V1];
-							vertices[V1] = vertices[V2];
-							vertices[V2] = vertices[V3];
-							vertices[V3] = vertices[V4];
-							vertices[V4] = tempV;
-
-							float tempU = vertices[U1];
-							vertices[U1] = vertices[U2];
-							vertices[U2] = vertices[U3];
-							vertices[U3] = vertices[U4];
-							vertices[U4] = tempU;
-							break;
-						}
-						case Cell.ROTATE_180: {
-							float tempU = vertices[U1];
-							vertices[U1] = vertices[U3];
-							vertices[U3] = tempU;
-							tempU = vertices[U2];
-							vertices[U2] = vertices[U4];
-							vertices[U4] = tempU;
-							float tempV = vertices[V1];
-							vertices[V1] = vertices[V3];
-							vertices[V3] = tempV;
-							tempV = vertices[V2];
-							vertices[V2] = vertices[V4];
-							vertices[V4] = tempV;
-							break;
-						}
-						case Cell.ROTATE_270: {
-							float tempV = vertices[V1];
-							vertices[V1] = vertices[V4];
-							vertices[V4] = vertices[V3];
-							vertices[V3] = vertices[V2];
-							vertices[V2] = tempV;
-
-							float tempU = vertices[U1];
-							vertices[U1] = vertices[U4];
-							vertices[U4] = vertices[U3];
-							vertices[U3] = vertices[U2];
-							vertices[U2] = tempU;
-							break;
-						}
-						}
-					}
-					batch.draw(region.getTexture(), vertices, 0, NUM_VERTICES);
-				}
-			}
-		}
-	}
-}
+/*******************************************************************************
+ * Copyright 2013 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.maps.tiled.renderers;
+
+import static com.badlogic.gdx.graphics.g2d.Batch.*;
+
+import com.badlogic.gdx.graphics.Color;
+import com.badlogic.gdx.graphics.g2d.Batch;
+import com.badlogic.gdx.graphics.g2d.TextureRegion;
+import com.badlogic.gdx.maps.tiled.TiledMap;
+import com.badlogic.gdx.maps.tiled.TiledMapTile;
+import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
+import com.badlogic.gdx.maps.tiled.TiledMapTileLayer.Cell;
+import com.badlogic.gdx.math.Matrix4;
+import com.badlogic.gdx.math.Vector2;
+import com.badlogic.gdx.math.Vector3;
+
+public class IsometricTiledMapRenderer extends BatchTiledMapRenderer {
+
+	private Matrix4 isoTransform;
+	private Matrix4 invIsotransform;
+	private Vector3 screenPos = new Vector3();
+
+	private Vector2 topRight = new Vector2();
+	private Vector2 bottomLeft = new Vector2();
+	private Vector2 topLeft = new Vector2();
+	private Vector2 bottomRight = new Vector2();
+
+	public IsometricTiledMapRenderer (TiledMap map) {
+		super(map);
+		init();
+	}
+
+	public IsometricTiledMapRenderer (TiledMap map, Batch batch) {
+		super(map, batch);
+		init();
+	}
+
+	public IsometricTiledMapRenderer (TiledMap map, float unitScale) {
+		super(map, unitScale);
+		init();
+	}
+
+	public IsometricTiledMapRenderer (TiledMap map, float unitScale, Batch batch) {
+		super(map, unitScale, batch);
+		init();
+	}
+
+	private void init () {
+		// create the isometric transform
+		isoTransform = new Matrix4();
+		isoTransform.idt();
+
+		// isoTransform.translate(0, 32, 0);
+		isoTransform.scale((float)(Math.sqrt(2.0) / 2.0), (float)(Math.sqrt(2.0) / 4.0), 1.0f);
+		isoTransform.rotate(0.0f, 0.0f, 1.0f, -45);
+
+		// ... and the inverse matrix
+		invIsotransform = new Matrix4(isoTransform);
+		invIsotransform.inv();
+	}
+
+	private Vector3 translateScreenToIso (Vector2 vec) {
+		screenPos.set(vec.x, vec.y, 0);
+		screenPos.mul(invIsotransform);
+
+		return screenPos;
+	}
+
+	@Override
+	public void renderTileLayer (TiledMapTileLayer layer) {
+		final Color batchColor = spriteBatch.getColor();
+		final float color = Color.toFloatBits(batchColor.r, batchColor.g, batchColor.b, batchColor.a * layer.getOpacity());
+
+		float tileWidth = layer.getTileWidth() * unitScale;
+		float tileHeight = layer.getTileHeight() * unitScale;
+		float halfTileWidth = tileWidth * 0.5f;
+		float halfTileHeight = tileHeight * 0.5f;
+
+		// setting up the screen points
+		// COL1
+		topRight.set(viewBounds.x + viewBounds.width, viewBounds.y);
+		// COL2
+		bottomLeft.set(viewBounds.x, viewBounds.y + viewBounds.height);
+		// ROW1
+		topLeft.set(viewBounds.x, viewBounds.y);
+		// ROW2
+		bottomRight.set(viewBounds.x + viewBounds.width, viewBounds.y + viewBounds.height);
+
+		// transforming screen coordinates to iso coordinates
+		int row1 = (int)(translateScreenToIso(topLeft).y / tileWidth) - 2;
+		int row2 = (int)(translateScreenToIso(bottomRight).y / tileWidth) + 2;
+
+		int col1 = (int)(translateScreenToIso(bottomLeft).x / tileWidth) - 2;
+		int col2 = (int)(translateScreenToIso(topRight).x / tileWidth) + 2;
+
+		for (int row = row2; row >= row1; row--) {
+			for (int col = col1; col <= col2; col++) {
+				float x = (col * halfTileWidth) + (row * halfTileWidth);
+				float y = (row * halfTileHeight) - (col * halfTileHeight);
+
+				final TiledMapTileLayer.Cell cell = layer.getCell(col, row);
+				if (cell == null) continue;
+				final TiledMapTile tile = cell.getTile();
+
+				if (tile != null) {
+					final boolean flipX = cell.getFlipHorizontally();
+					final boolean flipY = cell.getFlipVertically();
+					final int rotations = cell.getRotation();
+
+					TextureRegion region = tile.getTextureRegion();
+
+					float x1 = x + tile.getOffsetX() * unitScale;
+					float y1 = y + tile.getOffsetY() * unitScale;
+					float x2 = x1 + region.getRegionWidth() * unitScale;
+					float y2 = y1 + region.getRegionHeight() * unitScale;
+
+					float u1 = region.getU();
+					float v1 = region.getV2();
+					float u2 = region.getU2();
+					float v2 = region.getV();
+
+					vertices[X1] = x1;
+					vertices[Y1] = y1;
+					vertices[C1] = color;
+					vertices[U1] = u1;
+					vertices[V1] = v1;
+
+					vertices[X2] = x1;
+					vertices[Y2] = y2;
+					vertices[C2] = color;
+					vertices[U2] = u1;
+					vertices[V2] = v2;
+
+					vertices[X3] = x2;
+					vertices[Y3] = y2;
+					vertices[C3] = color;
+					vertices[U3] = u2;
+					vertices[V3] = v2;
+
+					vertices[X4] = x2;
+					vertices[Y4] = y1;
+					vertices[C4] = color;
+					vertices[U4] = u2;
+					vertices[V4] = v1;
+
+					if (flipX) {
+						float temp = vertices[U1];
+						vertices[U1] = vertices[U3];
+						vertices[U3] = temp;
+						temp = vertices[U2];
+						vertices[U2] = vertices[U4];
+						vertices[U4] = temp;
+					}
+					if (flipY) {
+						float temp = vertices[V1];
+						vertices[V1] = vertices[V3];
+						vertices[V3] = temp;
+						temp = vertices[V2];
+						vertices[V2] = vertices[V4];
+						vertices[V4] = temp;
+					}
+					if (rotations != 0) {
+						switch (rotations) {
+						case Cell.ROTATE_90: {
+							float tempV = vertices[V1];
+							vertices[V1] = vertices[V2];
+							vertices[V2] = vertices[V3];
+							vertices[V3] = vertices[V4];
+							vertices[V4] = tempV;
+
+							float tempU = vertices[U1];
+							vertices[U1] = vertices[U2];
+							vertices[U2] = vertices[U3];
+							vertices[U3] = vertices[U4];
+							vertices[U4] = tempU;
+							break;
+						}
+						case Cell.ROTATE_180: {
+							float tempU = vertices[U1];
+							vertices[U1] = vertices[U3];
+							vertices[U3] = tempU;
+							tempU = vertices[U2];
+							vertices[U2] = vertices[U4];
+							vertices[U4] = tempU;
+							float tempV = vertices[V1];
+							vertices[V1] = vertices[V3];
+							vertices[V3] = tempV;
+							tempV = vertices[V2];
+							vertices[V2] = vertices[V4];
+							vertices[V4] = tempV;
+							break;
+						}
+						case Cell.ROTATE_270: {
+							float tempV = vertices[V1];
+							vertices[V1] = vertices[V4];
+							vertices[V4] = vertices[V3];
+							vertices[V3] = vertices[V2];
+							vertices[V2] = tempV;
+
+							float tempU = vertices[U1];
+							vertices[U1] = vertices[U4];
+							vertices[U4] = vertices[U3];
+							vertices[U3] = vertices[U2];
+							vertices[U2] = tempU;
+							break;
+						}
+						}
+					}
+					spriteBatch.draw(region.getTexture(), vertices, 0, 20);
+				}
+			}
+		}
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/OrthoCachedTiledMapRenderer.java b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/OrthoCachedTiledMapRenderer.java
index 4150d4c..62e64fe 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/OrthoCachedTiledMapRenderer.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/OrthoCachedTiledMapRenderer.java
@@ -29,7 +29,6 @@ import com.badlogic.gdx.maps.MapLayer;
 import com.badlogic.gdx.maps.MapLayers;
 import com.badlogic.gdx.maps.MapObject;
 import com.badlogic.gdx.maps.tiled.TiledMap;
-import com.badlogic.gdx.maps.tiled.TiledMapImageLayer;
 import com.badlogic.gdx.maps.tiled.TiledMapRenderer;
 import com.badlogic.gdx.maps.tiled.TiledMapTile;
 import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
@@ -47,11 +46,9 @@ import com.badlogic.gdx.utils.Disposable;
  * @author Nathan Sweet */
 public class OrthoCachedTiledMapRenderer implements TiledMapRenderer, Disposable {
 	static private final float tolerance = 0.00001f;
-	static protected final int NUM_VERTICES = 20;
-	
+
 	protected final TiledMap map;
 	protected final SpriteCache spriteCache;
-
 	protected final float[] vertices = new float[20];
 	protected boolean blending;
 
@@ -130,8 +127,6 @@ public class OrthoCachedTiledMapRenderer implements TiledMapRenderer, Disposable
 				spriteCache.beginCache();
 				if (layer instanceof TiledMapTileLayer) {
 					renderTileLayer((TiledMapTileLayer)layer);
-				} else if (layer instanceof TiledMapImageLayer) {
-					renderImageLayer((TiledMapImageLayer)layer);
 				}
 				spriteCache.endCache();
 			}
@@ -172,8 +167,6 @@ public class OrthoCachedTiledMapRenderer implements TiledMapRenderer, Disposable
 				spriteCache.beginCache();
 				if (layer instanceof TiledMapTileLayer) {
 					renderTileLayer((TiledMapTileLayer)layer);
-				} else if (layer instanceof TiledMapImageLayer) {
-					renderImageLayer((TiledMapImageLayer)layer);
 				}
 				spriteCache.endCache();
 			}
@@ -344,60 +337,10 @@ public class OrthoCachedTiledMapRenderer implements TiledMapRenderer, Disposable
 					}
 					}
 				}
-				spriteCache.add(texture, vertices, 0, NUM_VERTICES);
+				spriteCache.add(texture, vertices, 0, 20);
 			}
 		}
 	}
-	
-	@Override
-	public void renderImageLayer (TiledMapImageLayer layer) {
-		final float color = Color.toFloatBits(1.0f, 1.0f, 1.0f, layer.getOpacity());
-		final float[] vertices = this.vertices;
-		
-		TextureRegion region = layer.getTextureRegion();
-		
-		if (region == null) {
-			return;
-		}
-
-		final float x = layer.getX();
-		final float y = layer.getY();
-		final float x1 = x * unitScale;
-		final float y1 = y * unitScale;
-		final float x2 = x1 + region.getRegionWidth() * unitScale;
-		final float y2 = y1 + region.getRegionHeight() * unitScale;
-
-		final float u1 = region.getU();
-		final float v1 = region.getV2();
-		final float u2 = region.getU2();
-		final float v2 = region.getV();
-
-		vertices[X1] = x1;
-		vertices[Y1] = y1;
-		vertices[C1] = color;
-		vertices[U1] = u1;
-		vertices[V1] = v1;
-
-		vertices[X2] = x1;
-		vertices[Y2] = y2;
-		vertices[C2] = color;
-		vertices[U2] = u1;
-		vertices[V2] = v2;
-
-		vertices[X3] = x2;
-		vertices[Y3] = y2;
-		vertices[C3] = color;
-		vertices[U3] = u2;
-		vertices[V3] = v2;
-
-		vertices[X4] = x2;
-		vertices[Y4] = y1;
-		vertices[C4] = color;
-		vertices[U4] = u2;
-		vertices[V4] = v1;
-
-		spriteCache.add(region.getTexture(), vertices, 0, NUM_VERTICES);
-	}
 
 	/** Causes the cache to be rebuilt the next time it is rendered. */
 	public void invalidateCache () {
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/OrthogonalTiledMapRenderer.java b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/OrthogonalTiledMapRenderer.java
index facd9c3..672cf09 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/OrthogonalTiledMapRenderer.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/OrthogonalTiledMapRenderer.java
@@ -1,208 +1,208 @@
-/*******************************************************************************
- * Copyright 2013 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.maps.tiled.renderers;
-
-import static com.badlogic.gdx.graphics.g2d.Batch.C1;
-import static com.badlogic.gdx.graphics.g2d.Batch.C2;
-import static com.badlogic.gdx.graphics.g2d.Batch.C3;
-import static com.badlogic.gdx.graphics.g2d.Batch.C4;
-import static com.badlogic.gdx.graphics.g2d.Batch.U1;
-import static com.badlogic.gdx.graphics.g2d.Batch.U2;
-import static com.badlogic.gdx.graphics.g2d.Batch.U3;
-import static com.badlogic.gdx.graphics.g2d.Batch.U4;
-import static com.badlogic.gdx.graphics.g2d.Batch.V1;
-import static com.badlogic.gdx.graphics.g2d.Batch.V2;
-import static com.badlogic.gdx.graphics.g2d.Batch.V3;
-import static com.badlogic.gdx.graphics.g2d.Batch.V4;
-import static com.badlogic.gdx.graphics.g2d.Batch.X1;
-import static com.badlogic.gdx.graphics.g2d.Batch.X2;
-import static com.badlogic.gdx.graphics.g2d.Batch.X3;
-import static com.badlogic.gdx.graphics.g2d.Batch.X4;
-import static com.badlogic.gdx.graphics.g2d.Batch.Y1;
-import static com.badlogic.gdx.graphics.g2d.Batch.Y2;
-import static com.badlogic.gdx.graphics.g2d.Batch.Y3;
-import static com.badlogic.gdx.graphics.g2d.Batch.Y4;
-
-import com.badlogic.gdx.graphics.Color;
-import com.badlogic.gdx.graphics.g2d.Batch;
-import com.badlogic.gdx.graphics.g2d.TextureRegion;
-import com.badlogic.gdx.maps.tiled.TiledMap;
-import com.badlogic.gdx.maps.tiled.TiledMapTile;
-import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
-import com.badlogic.gdx.maps.tiled.TiledMapTileLayer.Cell;
-
-public class OrthogonalTiledMapRenderer extends BatchTiledMapRenderer {
-
-	public OrthogonalTiledMapRenderer (TiledMap map) {
-		super(map);
-	}
-
-	public OrthogonalTiledMapRenderer (TiledMap map, Batch batch) {
-		super(map, batch);
-	}
-
-	public OrthogonalTiledMapRenderer (TiledMap map, float unitScale) {
-		super(map, unitScale);
-	}
-
-	public OrthogonalTiledMapRenderer (TiledMap map, float unitScale, Batch batch) {
-		super(map, unitScale, batch);
-	}
-
-	@Override
-	public void renderTileLayer (TiledMapTileLayer layer) {
-		final Color batchColor = batch.getColor();
-		final float color = Color.toFloatBits(batchColor.r, batchColor.g, batchColor.b, batchColor.a * layer.getOpacity());
-
-		final int layerWidth = layer.getWidth();
-		final int layerHeight = layer.getHeight();
-
-		final float layerTileWidth = layer.getTileWidth() * unitScale;
-		final float layerTileHeight = layer.getTileHeight() * unitScale;
-
-		final int col1 = Math.max(0, (int)(viewBounds.x / layerTileWidth));
-		final int col2 = Math.min(layerWidth, (int)((viewBounds.x + viewBounds.width + layerTileWidth) / layerTileWidth));
-
-		final int row1 = Math.max(0, (int)(viewBounds.y / layerTileHeight));
-		final int row2 = Math.min(layerHeight, (int)((viewBounds.y + viewBounds.height + layerTileHeight) / layerTileHeight));
-
-		float y = row2 * layerTileHeight;
-		float xStart = col1 * layerTileWidth;
-		final float[] vertices = this.vertices;
-
-		for (int row = row2; row >= row1; row--) {
-			float x = xStart;
-			for (int col = col1; col < col2; col++) {
-				final TiledMapTileLayer.Cell cell = layer.getCell(col, row);
-				if (cell == null) {
-					x += layerTileWidth;
-					continue;
-				}
-				final TiledMapTile tile = cell.getTile();
-
-				if (tile != null) {
-					final boolean flipX = cell.getFlipHorizontally();
-					final boolean flipY = cell.getFlipVertically();
-					final int rotations = cell.getRotation();
-
-					TextureRegion region = tile.getTextureRegion();
-
-					float x1 = x + tile.getOffsetX() * unitScale;
-					float y1 = y + tile.getOffsetY() * unitScale;
-					float x2 = x1 + region.getRegionWidth() * unitScale;
-					float y2 = y1 + region.getRegionHeight() * unitScale;
-
-					float u1 = region.getU();
-					float v1 = region.getV2();
-					float u2 = region.getU2();
-					float v2 = region.getV();
-
-					vertices[X1] = x1;
-					vertices[Y1] = y1;
-					vertices[C1] = color;
-					vertices[U1] = u1;
-					vertices[V1] = v1;
-
-					vertices[X2] = x1;
-					vertices[Y2] = y2;
-					vertices[C2] = color;
-					vertices[U2] = u1;
-					vertices[V2] = v2;
-
-					vertices[X3] = x2;
-					vertices[Y3] = y2;
-					vertices[C3] = color;
-					vertices[U3] = u2;
-					vertices[V3] = v2;
-
-					vertices[X4] = x2;
-					vertices[Y4] = y1;
-					vertices[C4] = color;
-					vertices[U4] = u2;
-					vertices[V4] = v1;
-
-					if (flipX) {
-						float temp = vertices[U1];
-						vertices[U1] = vertices[U3];
-						vertices[U3] = temp;
-						temp = vertices[U2];
-						vertices[U2] = vertices[U4];
-						vertices[U4] = temp;
-					}
-					if (flipY) {
-						float temp = vertices[V1];
-						vertices[V1] = vertices[V3];
-						vertices[V3] = temp;
-						temp = vertices[V2];
-						vertices[V2] = vertices[V4];
-						vertices[V4] = temp;
-					}
-					if (rotations != 0) {
-						switch (rotations) {
-						case Cell.ROTATE_90: {
-							float tempV = vertices[V1];
-							vertices[V1] = vertices[V2];
-							vertices[V2] = vertices[V3];
-							vertices[V3] = vertices[V4];
-							vertices[V4] = tempV;
-
-							float tempU = vertices[U1];
-							vertices[U1] = vertices[U2];
-							vertices[U2] = vertices[U3];
-							vertices[U3] = vertices[U4];
-							vertices[U4] = tempU;
-							break;
-						}
-						case Cell.ROTATE_180: {
-							float tempU = vertices[U1];
-							vertices[U1] = vertices[U3];
-							vertices[U3] = tempU;
-							tempU = vertices[U2];
-							vertices[U2] = vertices[U4];
-							vertices[U4] = tempU;
-							float tempV = vertices[V1];
-							vertices[V1] = vertices[V3];
-							vertices[V3] = tempV;
-							tempV = vertices[V2];
-							vertices[V2] = vertices[V4];
-							vertices[V4] = tempV;
-							break;
-						}
-						case Cell.ROTATE_270: {
-							float tempV = vertices[V1];
-							vertices[V1] = vertices[V4];
-							vertices[V4] = vertices[V3];
-							vertices[V3] = vertices[V2];
-							vertices[V2] = tempV;
-
-							float tempU = vertices[U1];
-							vertices[U1] = vertices[U4];
-							vertices[U4] = vertices[U3];
-							vertices[U3] = vertices[U2];
-							vertices[U2] = tempU;
-							break;
-						}
-						}
-					}
-					batch.draw(region.getTexture(), vertices, 0, NUM_VERTICES);
-				}
-				x += layerTileWidth;
-			}
-			y -= layerTileHeight;
-		}
-	}
-}
+/*******************************************************************************
+ * Copyright 2013 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.maps.tiled.renderers;
+
+import static com.badlogic.gdx.graphics.g2d.Batch.C1;
+import static com.badlogic.gdx.graphics.g2d.Batch.C2;
+import static com.badlogic.gdx.graphics.g2d.Batch.C3;
+import static com.badlogic.gdx.graphics.g2d.Batch.C4;
+import static com.badlogic.gdx.graphics.g2d.Batch.U1;
+import static com.badlogic.gdx.graphics.g2d.Batch.U2;
+import static com.badlogic.gdx.graphics.g2d.Batch.U3;
+import static com.badlogic.gdx.graphics.g2d.Batch.U4;
+import static com.badlogic.gdx.graphics.g2d.Batch.V1;
+import static com.badlogic.gdx.graphics.g2d.Batch.V2;
+import static com.badlogic.gdx.graphics.g2d.Batch.V3;
+import static com.badlogic.gdx.graphics.g2d.Batch.V4;
+import static com.badlogic.gdx.graphics.g2d.Batch.X1;
+import static com.badlogic.gdx.graphics.g2d.Batch.X2;
+import static com.badlogic.gdx.graphics.g2d.Batch.X3;
+import static com.badlogic.gdx.graphics.g2d.Batch.X4;
+import static com.badlogic.gdx.graphics.g2d.Batch.Y1;
+import static com.badlogic.gdx.graphics.g2d.Batch.Y2;
+import static com.badlogic.gdx.graphics.g2d.Batch.Y3;
+import static com.badlogic.gdx.graphics.g2d.Batch.Y4;
+
+import com.badlogic.gdx.graphics.Color;
+import com.badlogic.gdx.graphics.g2d.Batch;
+import com.badlogic.gdx.graphics.g2d.TextureRegion;
+import com.badlogic.gdx.maps.tiled.TiledMap;
+import com.badlogic.gdx.maps.tiled.TiledMapTile;
+import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
+import com.badlogic.gdx.maps.tiled.TiledMapTileLayer.Cell;
+
+public class OrthogonalTiledMapRenderer extends BatchTiledMapRenderer {
+
+	public OrthogonalTiledMapRenderer (TiledMap map) {
+		super(map);
+	}
+
+	public OrthogonalTiledMapRenderer (TiledMap map, Batch batch) {
+		super(map, batch);
+	}
+
+	public OrthogonalTiledMapRenderer (TiledMap map, float unitScale) {
+		super(map, unitScale);
+	}
+
+	public OrthogonalTiledMapRenderer (TiledMap map, float unitScale, Batch batch) {
+		super(map, unitScale, batch);
+	}
+
+	@Override
+	public void renderTileLayer (TiledMapTileLayer layer) {
+		final Color batchColor = spriteBatch.getColor();
+		final float color = Color.toFloatBits(batchColor.r, batchColor.g, batchColor.b, batchColor.a * layer.getOpacity());
+
+		final int layerWidth = layer.getWidth();
+		final int layerHeight = layer.getHeight();
+
+		final float layerTileWidth = layer.getTileWidth() * unitScale;
+		final float layerTileHeight = layer.getTileHeight() * unitScale;
+
+		final int col1 = Math.max(0, (int)(viewBounds.x / layerTileWidth));
+		final int col2 = Math.min(layerWidth, (int)((viewBounds.x + viewBounds.width + layerTileWidth) / layerTileWidth));
+
+		final int row1 = Math.max(0, (int)(viewBounds.y / layerTileHeight));
+		final int row2 = Math.min(layerHeight, (int)((viewBounds.y + viewBounds.height + layerTileHeight) / layerTileHeight));
+
+		float y = row2 * layerTileHeight;
+		float xStart = col1 * layerTileWidth;
+		final float[] vertices = this.vertices;
+
+		for (int row = row2; row >= row1; row--) {
+			float x = xStart;
+			for (int col = col1; col < col2; col++) {
+				final TiledMapTileLayer.Cell cell = layer.getCell(col, row);
+				if (cell == null) {
+					x += layerTileWidth;
+					continue;
+				}
+				final TiledMapTile tile = cell.getTile();
+
+				if (tile != null) {
+					final boolean flipX = cell.getFlipHorizontally();
+					final boolean flipY = cell.getFlipVertically();
+					final int rotations = cell.getRotation();
+
+					TextureRegion region = tile.getTextureRegion();
+
+					float x1 = x + tile.getOffsetX() * unitScale;
+					float y1 = y + tile.getOffsetY() * unitScale;
+					float x2 = x1 + region.getRegionWidth() * unitScale;
+					float y2 = y1 + region.getRegionHeight() * unitScale;
+
+					float u1 = region.getU();
+					float v1 = region.getV2();
+					float u2 = region.getU2();
+					float v2 = region.getV();
+
+					vertices[X1] = x1;
+					vertices[Y1] = y1;
+					vertices[C1] = color;
+					vertices[U1] = u1;
+					vertices[V1] = v1;
+
+					vertices[X2] = x1;
+					vertices[Y2] = y2;
+					vertices[C2] = color;
+					vertices[U2] = u1;
+					vertices[V2] = v2;
+
+					vertices[X3] = x2;
+					vertices[Y3] = y2;
+					vertices[C3] = color;
+					vertices[U3] = u2;
+					vertices[V3] = v2;
+
+					vertices[X4] = x2;
+					vertices[Y4] = y1;
+					vertices[C4] = color;
+					vertices[U4] = u2;
+					vertices[V4] = v1;
+
+					if (flipX) {
+						float temp = vertices[U1];
+						vertices[U1] = vertices[U3];
+						vertices[U3] = temp;
+						temp = vertices[U2];
+						vertices[U2] = vertices[U4];
+						vertices[U4] = temp;
+					}
+					if (flipY) {
+						float temp = vertices[V1];
+						vertices[V1] = vertices[V3];
+						vertices[V3] = temp;
+						temp = vertices[V2];
+						vertices[V2] = vertices[V4];
+						vertices[V4] = temp;
+					}
+					if (rotations != 0) {
+						switch (rotations) {
+						case Cell.ROTATE_90: {
+							float tempV = vertices[V1];
+							vertices[V1] = vertices[V2];
+							vertices[V2] = vertices[V3];
+							vertices[V3] = vertices[V4];
+							vertices[V4] = tempV;
+
+							float tempU = vertices[U1];
+							vertices[U1] = vertices[U2];
+							vertices[U2] = vertices[U3];
+							vertices[U3] = vertices[U4];
+							vertices[U4] = tempU;
+							break;
+						}
+						case Cell.ROTATE_180: {
+							float tempU = vertices[U1];
+							vertices[U1] = vertices[U3];
+							vertices[U3] = tempU;
+							tempU = vertices[U2];
+							vertices[U2] = vertices[U4];
+							vertices[U4] = tempU;
+							float tempV = vertices[V1];
+							vertices[V1] = vertices[V3];
+							vertices[V3] = tempV;
+							tempV = vertices[V2];
+							vertices[V2] = vertices[V4];
+							vertices[V4] = tempV;
+							break;
+						}
+						case Cell.ROTATE_270: {
+							float tempV = vertices[V1];
+							vertices[V1] = vertices[V4];
+							vertices[V4] = vertices[V3];
+							vertices[V3] = vertices[V2];
+							vertices[V2] = tempV;
+
+							float tempU = vertices[U1];
+							vertices[U1] = vertices[U4];
+							vertices[U4] = vertices[U3];
+							vertices[U3] = vertices[U2];
+							vertices[U2] = tempU;
+							break;
+						}
+						}
+					}
+					spriteBatch.draw(region.getTexture(), vertices, 0, 20);
+				}
+				x += layerTileWidth;
+			}
+			y -= layerTileHeight;
+		}
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/tiles/AnimatedTiledMapTile.java b/gdx/src/com/badlogic/gdx/maps/tiled/tiles/AnimatedTiledMapTile.java
index f376c41..55f77c7 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/tiles/AnimatedTiledMapTile.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/tiles/AnimatedTiledMapTile.java
@@ -21,7 +21,8 @@ import com.badlogic.gdx.maps.MapProperties;
 import com.badlogic.gdx.maps.tiled.TiledMapTile;
 import com.badlogic.gdx.maps.tiled.tiles.StaticTiledMapTile;
 import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.IntArray;
+import com.badlogic.gdx.utils.LongArray;
+import com.badlogic.gdx.utils.FloatArray;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 import com.badlogic.gdx.utils.TimeUtils;
 
@@ -38,9 +39,9 @@ public class AnimatedTiledMapTile implements TiledMapTile {
 
 	private StaticTiledMapTile[] frameTiles;
 
-	private int[] animationIntervals;
-	private int frameCount = 0;
-	private int loopDuration;
+	private long[] animationIntervals;
+	private long frameCount = 0;
+	private long loopDuration;
 	private static final long initialTimeOffset = TimeUtils.millis();
 
 	@Override
@@ -63,22 +64,18 @@ public class AnimatedTiledMapTile implements TiledMapTile {
 		this.blendMode = blendMode;
 	}
 
-	public int getCurrentFrameIndex() {
-		int currentTime = (int)(lastTiledMapRenderTime % loopDuration);
+	private TiledMapTile getCurrentFrame() {
+		long currentTime = lastTiledMapRenderTime % loopDuration;
 
 		for (int i = 0; i < animationIntervals.length; ++i){
-			int animationInterval = animationIntervals[i];
-			if (currentTime <= animationInterval) return i;
+			long animationInterval = animationIntervals[i];
+			if (currentTime<=animationInterval) return frameTiles[i];
 			currentTime -= animationInterval;
 		}
 
 		throw new GdxRuntimeException("Could not determine current animation frame in AnimatedTiledMapTile.  This should never happen.");
 	}
 
-	public TiledMapTile getCurrentFrame() {
-		return frameTiles[getCurrentFrameIndex()];
-	}
-
 	@Override
 	public TextureRegion getTextureRegion () {
 		return getCurrentFrame().getTextureRegion();
@@ -131,11 +128,11 @@ public class AnimatedTiledMapTile implements TiledMapTile {
 		this.frameTiles = new StaticTiledMapTile[frameTiles.size];
 		this.frameCount = frameTiles.size;
 
-		this.loopDuration = frameTiles.size * (int)(interval * 1000f);
-		this.animationIntervals = new int[frameTiles.size];
+		this.loopDuration = (long)(frameTiles.size * interval * 1000f);
+		this.animationIntervals = new long[frameTiles.size];
 		for (int i = 0; i < frameTiles.size; ++i){
 			this.frameTiles[i] = frameTiles.get(i);
-			this.animationIntervals[i] = (int)(interval * 1000f);
+			this.animationIntervals[i] = (long)(interval * 1000f);
 		}
 	}
 
@@ -143,7 +140,7 @@ public class AnimatedTiledMapTile implements TiledMapTile {
 	 *
 	 * @param intervals The intervals between each individual frame tile in milliseconds.
 	 * @param frameTiles An array of {@link StaticTiledMapTile}s that make up the animation. */
-	public AnimatedTiledMapTile (IntArray intervals, Array<StaticTiledMapTile> frameTiles) {
+	public AnimatedTiledMapTile (LongArray intervals, Array<StaticTiledMapTile> frameTiles) {
 		this.frameTiles = new StaticTiledMapTile[frameTiles.size];
 		this.frameCount = frameTiles.size;
 
diff --git a/gdx/src/com/badlogic/gdx/math/MathUtils.java b/gdx/src/com/badlogic/gdx/math/MathUtils.java
index 4be5041..e12316e 100644
--- a/gdx/src/com/badlogic/gdx/math/MathUtils.java
+++ b/gdx/src/com/badlogic/gdx/math/MathUtils.java
@@ -142,16 +142,6 @@ public final class MathUtils {
 		return start + random.nextInt(end - start + 1);
 	}
 
-	/** Returns a random number between 0 (inclusive) and the specified value (inclusive). */
-	static public long random (long range) {
-		return (long)(random.nextDouble() * range);
-	}
-
-	/** Returns a random number between start (inclusive) and end (inclusive). */
-	static public long random (long start, long end) {
-		return start + (long)(random.nextDouble() * (end - start));
-	}
-
 	/** Returns a random boolean value. */
 	static public boolean randomBoolean () {
 		return random.nextBoolean();
@@ -206,7 +196,7 @@ public final class MathUtils {
 	 * @param min the lower limit
 	 * @param max the upper limit */
 	public static float randomTriangular (float min, float max) {
-		return randomTriangular(min, max, min + (max - min) * 0.5f);
+		return randomTriangular(min, max, (max - min) * .5f);
 	}
 
 	/** Returns a triangularly distributed random number between {@code min} (inclusive) and {@code max} (exclusive), where values
@@ -241,19 +231,13 @@ public final class MathUtils {
 
 	// ---
 
-	static public short clamp (short value, short min, short max) {
-		if (value < min) return min;
-		if (value > max) return max;
-		return value;
-	}
-
 	static public int clamp (int value, int min, int max) {
 		if (value < min) return min;
 		if (value > max) return max;
 		return value;
 	}
 
-	static public long clamp (long value, long min, long max) {
+	static public short clamp (short value, short min, short max) {
 		if (value < min) return min;
 		if (value > max) return max;
 		return value;
@@ -265,12 +249,6 @@ public final class MathUtils {
 		return value;
 	}
 
-	static public double clamp (double value, double min, double max) {
-		if (value < min) return min;
-		if (value > max) return max;
-		return value;
-	}
-
 	// ---
 
 	/** Linearly interpolates between fromValue to toValue on progress position. */
diff --git a/gdx/src/com/badlogic/gdx/math/Matrix4.java b/gdx/src/com/badlogic/gdx/math/Matrix4.java
index f664362..b593435 100644
--- a/gdx/src/com/badlogic/gdx/math/Matrix4.java
+++ b/gdx/src/com/badlogic/gdx/math/Matrix4.java
@@ -71,7 +71,8 @@ public class Matrix4 implements Serializable {
 	public static final int M33 = 15;
 
 	/** @Deprecated Do not use this member, instead use a temporary Matrix4 instance, or create a temporary float array. */
-	@Deprecated public static final float tmp[] = new float[16]; // FIXME Change to private access
+	@Deprecated
+	public static final float tmp[] = new float[16]; // FIXME Change to private access
 	public final float val[] = new float[16];
 
 	/** Constructs an identity matrix */
@@ -501,44 +502,6 @@ public class Matrix4 implements Serializable {
 		return this;
 	}
 
-	/** Sets the matrix to a projection matrix with a near/far plane, and left, bottom, right and top specifying the points on the
-	 * near plane that are mapped to the lower left and upper right corners of the viewport. This allows to create projection
-	 * matrix with off-center vanishing point.
-	 * 
-	 * @param left
-	 * @param right
-	 * @param bottom
-	 * @param top
-	 * @param near The near plane
-	 * @param far The far plane
-	 * @return This matrix for the purpose of chaining methods together. */
-	public Matrix4 setToProjection (float left, float right, float bottom, float top, float near, float far) {
-		float x = 2.0f * near / (right - left);
-		float y = 2.0f * near / (top - bottom);
-		float a = (right + left) / (right - left);
-		float b = (top + bottom) / (top - bottom);
-		float l_a1 = (far + near) / (near - far);
-		float l_a2 = (2 * far * near) / (near - far);
-		val[M00] = x;
-		val[M10] = 0;
-		val[M20] = 0;
-		val[M30] = 0;
-		val[M01] = 0;
-		val[M11] = y;
-		val[M21] = 0;
-		val[M31] = 0;
-		val[M02] = a;
-		val[M12] = b;
-		val[M22] = l_a1;
-		val[M32] = -1;
-		val[M03] = 0;
-		val[M13] = 0;
-		val[M23] = l_a2;
-		val[M33] = 0;
-
-		return this;
-	}
-
 	/** Sets this matrix to an orthographic projection matrix with the origin at (x,y) extending by width and height. The near plane
 	 * is set to 0, the far plane is set to 1.
 	 * 
@@ -889,46 +852,71 @@ public class Matrix4 implements Serializable {
 		return this;
 	}
 
-	/** Averages the given transform with this one and stores the result in this matrix. Translations and scales are lerped while
-	 * rotations are slerped.
+	/**
+	 * Averages the given transform with this one and stores the result in this matrix.
+	 * Translations and scales are lerped while rotations are slerped. 
 	 * @param other The other transform
 	 * @param w Weight of this transform; weight of the other transform is (1 - w)
 	 * @return This matrix for chaining */
 	public Matrix4 avg (Matrix4 other, float w) {
+
+		//Get this and other matrix's scale component
 		getScale(tmpVec);
 		other.getScale(tmpForward);
-
+		
+		//Get this and other matrix's rotation component
 		getRotation(quat);
 		other.getRotation(quat2);
-
+		
+		//Get this and other matrix's translation component
 		getTranslation(tmpUp);
 		other.getTranslation(right);
-
+		
+		//Calculate scale components
 		setToScaling(tmpVec.scl(w).add(tmpForward.scl(1 - w)));
+
+		//Calculate rotation components
 		rotate(quat.slerp(quat2, 1 - w));
-		setTranslation(tmpUp.scl(w).add(right.scl(1 - w)));
 
+		//Calculate translation components
+		setTranslation(tmpUp.scl(w).add(right.scl(1 - w)));
+		
 		return this;
 	}
-
-	/** Averages the given transforms and stores the result in this matrix. Translations and scales are lerped while rotations are
-	 * slerped. Does not destroy the data contained in t.
+	
+	/**
+	 * Averages the given transforms and stores the result in this matrix.
+	 * Translations and scales are lerped while rotations are slerped. 
+	 * Does not destroy the data contained in t.
 	 * @param t List of transforms
 	 * @return This matrix for chaining */
 	public Matrix4 avg (Matrix4[] t) {
-		final float w = 1.0f / t.length;
+		final float w = 1.0f/t.length;
 
+		//Initialize scale components
 		tmpVec.set(t[0].getScale(tmpUp).scl(w));
+		
+		//Initialize rotation components
 		quat.set(t[0].getRotation(quat2).exp(w));
+		
+		//Initialize translation components
 		tmpForward.set(t[0].getTranslation(tmpUp).scl(w));
-
-		for (int i = 1; i < t.length; i++) {
+		
+		//Continue calculating
+		for(int i=1;i<t.length;i++){
+			
+			//Calculate scale components
 			tmpVec.add(t[i].getScale(tmpUp).scl(w));
+			
+			//Calculate rotation components
 			quat.mul(t[i].getRotation(quat2).exp(w));
+			
+			//Calculate translation components
 			tmpForward.add(t[i].getTranslation(tmpUp).scl(w));
 		}
 		quat.nor();
-
+		
+		//Set calculated components to this matrix
 		setToScaling(tmpVec);
 		rotate(quat);
 		setTranslation(tmpForward);
@@ -936,31 +924,47 @@ public class Matrix4 implements Serializable {
 		return this;
 	}
 
-	/** Averages the given transforms with the given weights and stores the result in this matrix. Translations and scales are
-	 * lerped while rotations are slerped. Does not destroy the data contained in t or w; Sum of w_i must be equal to 1, or
-	 * unexpected results will occur.
+	/**
+	 * Averages the given transforms with the given weights and stores the result in this matrix.
+	 * Translations and scales are lerped while rotations are slerped. 
+	 * Does not destroy the data contained in t or w;
+	 * Sum of w_i must be equal to 1, or unexpected results will occur.
 	 * @param t List of transforms
 	 * @param w List of weights
 	 * @return This matrix for chaining */
 	public Matrix4 avg (Matrix4[] t, float[] w) {
+
+		//Initialize scale components
 		tmpVec.set(t[0].getScale(tmpUp).scl(w[0]));
+		
+		//Initialize rotation components
 		quat.set(t[0].getRotation(quat2).exp(w[0]));
+		
+		//Initialize translation components
 		tmpForward.set(t[0].getTranslation(tmpUp).scl(w[0]));
-
-		for (int i = 1; i < t.length; i++) {
+		
+		//Continue calculating
+		for(int i=1;i<t.length;i++){
+			
+			//Calculate scale components
 			tmpVec.add(t[i].getScale(tmpUp).scl(w[i]));
+			
+			//Calculate rotation components
 			quat.mul(t[i].getRotation(quat2).exp(w[i]));
+			
+			//Calculate translation components
 			tmpForward.add(t[i].getTranslation(tmpUp).scl(w[i]));
 		}
 		quat.nor();
-
+		
+		//Set calculated components to this matrix
 		setToScaling(tmpVec);
 		rotate(quat);
 		setTranslation(tmpForward);
 
 		return this;
 	}
-
+	
 	/** Sets this matrix to the given 3x3 matrix. The third column of this matrix is set to (0,0,1,0).
 	 * @param mat the matrix */
 	public Matrix4 set (Matrix3 mat) {
diff --git a/gdx/src/com/badlogic/gdx/math/Quaternion.java b/gdx/src/com/badlogic/gdx/math/Quaternion.java
index e7739aa..2798144 100644
--- a/gdx/src/com/badlogic/gdx/math/Quaternion.java
+++ b/gdx/src/com/badlogic/gdx/math/Quaternion.java
@@ -421,7 +421,7 @@ public class Quaternion implements Serializable {
 		float d = Vector3.len(x, y, z);
 		if (d == 0f) return idt();
 		d = 1f / d;
-		float l_ang = radians < 0 ? MathUtils.PI2 - (-radians % MathUtils.PI2) : radians % MathUtils.PI2;
+		float l_ang = radians;
 		float l_sin = (float)Math.sin(l_ang / 2);
 		float l_cos = (float)Math.cos(l_ang / 2);
 		return this.set(d * x * l_sin, d * y * l_sin, d * z * l_sin, l_cos).nor();
diff --git a/gdx/src/com/badlogic/gdx/math/RandomXS128.java b/gdx/src/com/badlogic/gdx/math/RandomXS128.java
index 1e106ab..cb9dca3 100644
--- a/gdx/src/com/badlogic/gdx/math/RandomXS128.java
+++ b/gdx/src/com/badlogic/gdx/math/RandomXS128.java
@@ -174,15 +174,6 @@ public class RandomXS128 extends Random {
 		this.seed0 = seed0;
 		this.seed1 = seed1;
 	}
-	
-	/**
-	 * Returns the internal seeds to allow state saving.
-	 * @param seed muse be 0 or 1, designating which of the 2 long seeds to return
-	 * @return the internal seed that can be used in setState
-	 */
-	public long getState(int seed) {
-		return seed == 0 ? seed0 : seed1;
-	}
 
 	private final static long murmurHash3 (long x) {
 		x ^= x >>> 33;
diff --git a/gdx/src/com/badlogic/gdx/math/Shape2D.java b/gdx/src/com/badlogic/gdx/math/Shape2D.java
index 4bbe571..2f02476 100644
--- a/gdx/src/com/badlogic/gdx/math/Shape2D.java
+++ b/gdx/src/com/badlogic/gdx/math/Shape2D.java
@@ -1,4 +1,6 @@
 package com.badlogic.gdx.math;
 
+import com.badlogic.gdx.math.collision.*;
+
 public interface Shape2D {
 }
diff --git a/gdx/src/com/badlogic/gdx/math/Vector.java b/gdx/src/com/badlogic/gdx/math/Vector.java
index e55fdd1..9c754d1 100644
--- a/gdx/src/com/badlogic/gdx/math/Vector.java
+++ b/gdx/src/com/badlogic/gdx/math/Vector.java
@@ -1,12 +1,12 @@
 /*******************************************************************************
  * Copyright 2011 See AUTHORS file.
- *
+ * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *
+ * 
  *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * 
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -27,36 +27,14 @@ public interface Vector<T extends Vector<T>> {
 	float len ();
 
 	/** This method is faster than {@link Vector#len()} because it avoids calculating a square root. It is useful for comparisons,
-	 * but not for getting exact lengths, as the return value is the square of the actual length.
+	 * but not for getting accurate lengths, as the return value is the square of the actual length.
 	 * @return The squared euclidean length */
 	float len2 ();
 
-	/** Limits the length of this vector, based on the desired maximum length.
-	 * @param limit desired maximum length for this vector
-	 * @return this vector for chaining */
+	/** Limits this vector's length to given value
+	 * @return This vector for chaining */
 	T limit (float limit);
 
-	/** Limits the length of this vector, based on the desired maximum length squared.
-	 * <p />
-	 * This method is slightly faster than limit().
-	 * @param limit2 squared desired maximum length for this vector
-	 * @return this vector for chaining
-	 * @see #len2() */
-	T limit2 (float limit2);
-
-	/** Sets the length of this vector. Does nothing is this vector is zero.
-	 * @param len desired length for this vector
-	 * @return this vector for chaining */
-	T setLength (float len);
-
-	/** Sets the length of this vector, based on the square of the desired length. Does nothing is this vector is zero.
-	 * <p />
-	 * This method is slightly faster than setLength().
-	 * @param len2 desired square of the length for this vector
-	 * @return this vector for chaining
-	 * @see #len2() */
-	T setLength2 (float len2);
-
 	/** Clamps this vector's length to given min and max values
 	 * @param min Min length
 	 * @param max Max length
diff --git a/gdx/src/com/badlogic/gdx/math/Vector2.java b/gdx/src/com/badlogic/gdx/math/Vector2.java
index 6517adb..0f1b096 100644
--- a/gdx/src/com/badlogic/gdx/math/Vector2.java
+++ b/gdx/src/com/badlogic/gdx/math/Vector2.java
@@ -1,12 +1,12 @@
 /*******************************************************************************
  * Copyright 2011 See AUTHORS file.
- *
+ * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *
+ * 
  *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * 
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -231,46 +231,23 @@ public class Vector2 implements Serializable, Vector<Vector2> {
 
 	@Override
 	public Vector2 limit (float limit) {
-		return limit2(limit * limit);
-	}
-
-	@Override
-	public Vector2 limit2 (float limit2) {
-		float len2 = len2();
-		if (len2 > limit2) {
-			return scl((float)Math.sqrt(limit2 / len2));
+		if (len2() > limit * limit) {
+			nor();
+			scl(limit);
 		}
 		return this;
 	}
 
 	@Override
 	public Vector2 clamp (float min, float max) {
-		final float len2 = len2();
-		if (len2 == 0f)
-			return this;
-		float max2 = max * max;
-		if (len2 > max2)
-			return scl((float)Math.sqrt(max2 / len2));
-		float min2 = min * min;
-		if (len2 < min2)
-			return scl((float)Math.sqrt(min2 / len2));
+		final float l2 = len2();
+		if (l2 == 0f) return this;
+		if (l2 > max * max) return nor().scl(max);
+		if (l2 < min * min) return nor().scl(min);
 		return this;
 	}
 
 	@Override
-	public Vector2 setLength ( float len ) {
-		return setLength2( len * len );
-	}
-
-	@Override
-	public Vector2 setLength2 ( float len2 ) {
-		float oldLen2 = len2();
-		return ( oldLen2 == 0 || oldLen2 == len2 )
-				? this
-				: scl((float) Math.sqrt( len2 / oldLen2 ));
-	}
-
-	@Override
 	public String toString () {
 		return "[" + x + ":" + y + "]";
 	}
diff --git a/gdx/src/com/badlogic/gdx/math/Vector3.java b/gdx/src/com/badlogic/gdx/math/Vector3.java
index 4371fe7..26cb602 100644
--- a/gdx/src/com/badlogic/gdx/math/Vector3.java
+++ b/gdx/src/com/badlogic/gdx/math/Vector3.java
@@ -1,12 +1,12 @@
 /*******************************************************************************
  * Copyright 2011 See AUTHORS file.
- *
+ * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *
+ * 
  *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * 
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -58,14 +58,14 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	}
 
 	/** Creates a vector from the given array. The array must have at least 3 elements.
-	 *
+	 * 
 	 * @param values The array */
 	public Vector3 (final float[] values) {
 		this.set(values[0], values[1], values[2]);
 	}
 
 	/** Creates a vector from the given vector and z-component
-	 *
+	 * 
 	 * @param vector The vector
 	 * @param z The z-component */
 	public Vector3 (final Vector2 vector, float z) {
@@ -73,7 +73,7 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	}
 
 	/** Sets the vector to the given components
-	 *
+	 * 
 	 * @param x The x-component
 	 * @param y The y-component
 	 * @param z The z-component
@@ -91,7 +91,7 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	}
 
 	/** Sets the components from the array. The array must have at least 3 elements
-	 *
+	 * 
 	 * @param values The array
 	 * @return this vector for chaining */
 	public Vector3 set (final float[] values) {
@@ -99,7 +99,7 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	}
 
 	/** Sets the components of the given vector and z-component
-	 *
+	 * 
 	 * @param vector The vector
 	 * @param z The z-component
 	 * @return This vector for chaining */
@@ -127,7 +127,7 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	}
 
 	/** Adds the given value to all three components of the vector.
-	 *
+	 * 
 	 * @param values The value
 	 * @return This vector for chaining */
 	public Vector3 add (float values) {
@@ -140,7 +140,7 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	}
 
 	/** Subtracts the other vector from this vector.
-	 *
+	 * 
 	 * @param x The x-component of the other vector
 	 * @param y The y-component of the other vector
 	 * @param z The z-component of the other vector
@@ -150,7 +150,7 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	}
 
 	/** Subtracts the given value from all components of this vector
-	 *
+	 * 
 	 * @param value The value
 	 * @return This vector for chaining */
 	public Vector3 sub (float value) {
@@ -367,7 +367,7 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 
 	/** Multiplies this vector by the given matrix dividing by w, assuming the fourth (w) component of the vector is 1. This is
 	 * mostly used to project/unproject vectors via a perspective projection matrix.
-	 *
+	 * 
 	 * @param matrix The matrix.
 	 * @return This vector for chaining */
 	public Vector3 prj (final Matrix4 matrix) {
@@ -379,7 +379,7 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	}
 
 	/** Multiplies this vector by the first three columns of the matrix, essentially only applying rotation and scaling.
-	 *
+	 * 
 	 * @param matrix The matrix
 	 * @return This vector for chaining */
 	public Vector3 rot (final Matrix4 matrix) {
@@ -413,7 +413,7 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	}
 
 	/** Rotates this vector by the given angle in degrees around the given axis.
-	 *
+	 * 
 	 * @param degrees the angle in degrees
 	 * @param axisX the x-component of the axis
 	 * @param axisY the y-component of the axis
@@ -424,7 +424,7 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	}
 
 	/** Rotates this vector by the given angle in radians around the given axis.
-	 *
+	 * 
 	 * @param radians the angle in radians
 	 * @param axisX the x-component of the axis
 	 * @param axisY the y-component of the axis
@@ -435,7 +435,7 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	}
 
 	/** Rotates this vector by the given angle in degrees around the given axis.
-	 *
+	 * 
 	 * @param axis the axis
 	 * @param degrees the angle in degrees
 	 * @return This vector for chaining */
@@ -445,7 +445,7 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	}
 
 	/** Rotates this vector by the given angle in radians around the given axis.
-	 *
+	 * 
 	 * @param axis the axis
 	 * @param radians the angle in radians
 	 * @return This vector for chaining */
@@ -478,12 +478,12 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	public boolean isOnLine (Vector3 other, float epsilon) {
 		return len2(y * other.z - z * other.y, z * other.x - x * other.z, x * other.y - y * other.x) <= epsilon;
 	}
-
+	
 	@Override
 	public boolean isOnLine (Vector3 other) {
 		return len2(y * other.z - z * other.y, z * other.x - x * other.z, x * other.y - y * other.x) <= MathUtils.FLOAT_ROUNDING_ERROR;
 	}
-
+	
 	@Override
 	public boolean isCollinear (Vector3 other, float epsilon) {
 		return isOnLine(other, epsilon) && hasSameDirection(other);
@@ -534,10 +534,10 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	public Vector3 interpolate (Vector3 target, float alpha, Interpolation interpolator) {
 		return lerp(target, interpolator.apply(0f, 1f, alpha));
 	}
-
+	
 	/** Spherically interpolates between this vector and the target vector by alpha which is in the range [0,1]. The result is
 	 * stored in this vector.
-	 *
+	 * 
 	 * @param target The target vector
 	 * @param alpha The interpolation coefficient
 	 * @return This vector for chaining. */
@@ -561,50 +561,22 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 		return scl((float)Math.cos(theta)).add(tx * dl, ty * dl, tz * dl).nor();
 	}
 
-    @Override
 	public String toString () {
 		return "[" + x + ", " + y + ", " + z + "]";
 	}
 
-
 	@Override
 	public Vector3 limit (float limit) {
-		return limit2(limit * limit);
-	}
-
-	@Override
-	public Vector3 limit2 (float limit2) {
-		float len2 = len2();
-		if (len2 > limit2) {
-			scl((float) Math.sqrt(limit2 / len2));
-		}
+		if (len2() > limit * limit) nor().scl(limit);
 		return this;
 	}
 
 	@Override
-	public Vector3 setLength ( float len ) {
-		return setLength2( len * len );
-	}
-
-	@Override
-	public Vector3 setLength2 ( float len2 ) {
-		float oldLen2 = len2();
-		return ( oldLen2 == 0 || oldLen2 == len2 )
-				? this
-				: scl((float) Math.sqrt( len2 / oldLen2 ));
-	}
-
-	@Override
 	public Vector3 clamp (float min, float max) {
-		final float len2 = len2();
-		if (len2 == 0f)
-			return this;
-		float max2 = max * max;
-		if (len2 > max2)
-			return scl((float)Math.sqrt(max2 / len2));
-		float min2 = min * min;
-		if (len2 < min2)
-			return scl((float)Math.sqrt(min2 / len2));
+		final float l2 = len2();
+		if (l2 == 0f) return this;
+		if (l2 > max * max) return nor().scl(max);
+		if (l2 < min * min) return nor().scl(min);
 		return this;
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/net/HttpRequestBuilder.java b/gdx/src/com/badlogic/gdx/net/HttpRequestBuilder.java
deleted file mode 100644
index c1a3f45..0000000
--- a/gdx/src/com/badlogic/gdx/net/HttpRequestBuilder.java
+++ /dev/null
@@ -1,151 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.net;
-
-import java.io.InputStream;
-import java.util.Map;
-
-import com.badlogic.gdx.Net.HttpRequest;
-import com.badlogic.gdx.utils.Base64Coder;
-import com.badlogic.gdx.utils.Json;
-import com.badlogic.gdx.utils.Pools;
-
-/** A builder for {@link HttpRequest}s.
- * 
- * Make sure to call {@link #newRequest()} first, then set the request up and obtain it via {@link #build()} when you are done.
- * 
- * It also offers a few utility methods to deal with content encoding and HTTP headers.
- * 
- * @author Daniel Holderbaum */
-public class HttpRequestBuilder {
-
-	/** Will be added as a prefix to each URL when {@link #url(String)} is called. Empty by default. */
-	public static String baseUrl = "";
-
-	/** Will be set for each new HttpRequest. By default set to {@code 1000}. Can be overwritten via {@link #timeout(int)}. */
-	public static int defaultTimeout = 1000;
-
-	/** Will be used for the object serialization in case {@link #jsonContent(Object)} is called. */
-	public static Json json = new Json();
-
-	private HttpRequest httpRequest;
-
-	/** Initializes the builder and sets it up to build a new {@link HttpRequest} . */
-	public HttpRequestBuilder newRequest () {
-		if (httpRequest != null) {
-			throw new IllegalStateException("A new request has already been started. Call HttpRequestBuilder.build() first.");
-		}
-
-		httpRequest = Pools.obtain(HttpRequest.class);
-		httpRequest.setTimeOut(defaultTimeout);
-		return this;
-	}
-
-	/** @see HttpRequest#setMethod(String) */
-	public HttpRequestBuilder method (String httpMethod) {
-		validate();
-		httpRequest.setMethod(httpMethod);
-		return this;
-	}
-
-	/** The {@link #baseUrl} will automatically be added as a prefix to the given URL.
-	 * 
-	 * @see HttpRequest#setUrl(String) */
-	public HttpRequestBuilder url (String url) {
-		validate();
-		httpRequest.setUrl(baseUrl + url);
-		return this;
-	}
-
-	/** If this method is not called, the {@link #defaultTimeout} will be used.
-	 * 
-	 * @see HttpRequest#setTimeOut(int) */
-	public HttpRequestBuilder timeout (int timeOut) {
-		validate();
-		httpRequest.setTimeOut(timeOut);
-		return this;
-	}
-
-	/** @see HttpRequest#setFollowRedirects(boolean) */
-	public HttpRequestBuilder followRedirects (boolean followRedirects) {
-		validate();
-		httpRequest.setFollowRedirects(followRedirects);
-		return this;
-	}
-
-	/** @see HttpRequest#setHeader(String, String) */
-	public HttpRequestBuilder header (String name, String value) {
-		validate();
-		httpRequest.setHeader(name, value);
-		return this;
-	}
-
-	/** @see HttpRequest#setContent(String) */
-	public HttpRequestBuilder content (String content) {
-		validate();
-		httpRequest.setContent(content);
-		return this;
-	}
-
-	/** @see HttpRequest#setContent(java.io.InputStream, long) */
-	public HttpRequestBuilder content (InputStream contentStream, long contentLength) {
-		validate();
-		httpRequest.setContent(contentStream, contentLength);
-		return this;
-	}
-
-	/** Sets the correct {@code ContentType} and encodes the given parameter map, then sets it as the content. */
-	public HttpRequestBuilder formEncodedContent (Map<String, String> content) {
-		validate();
-		httpRequest.setHeader(HttpRequestHeader.ContentType, "application/x-www-form-urlencoded");
-		String formEncodedContent = HttpParametersUtils.convertHttpParameters(content);
-		httpRequest.setContent(formEncodedContent);
-		return this;
-	}
-
-	/** Sets the correct {@code ContentType} and encodes the given content object via {@link #json}, then sets it as the content. */
-	public HttpRequestBuilder jsonContent (Object content) {
-		validate();
-		httpRequest.setHeader(HttpRequestHeader.ContentType, "application/json");
-		String jsonContent = json.toJson(content);
-		httpRequest.setContent(jsonContent);
-		return this;
-	}
-
-	/** Sets the {@code Authorization} header via the Base64 encoded username and password. */
-	public HttpRequestBuilder basicAuthentication (String username, String password) {
-		validate();
-		httpRequest.setHeader(HttpRequestHeader.Authorization, "Basic " + Base64Coder.encodeString(username + ":" + password));
-		return this;
-	}
-
-	/** Returns the {@link HttpRequest} that has been setup by this builder so far. After using the request, it should be returned
-	 * to the pool via {@code Pools.free(request)}. */
-	public HttpRequest build () {
-		validate();
-		HttpRequest request = httpRequest;
-		httpRequest = null;
-		return request;
-	}
-
-	private void validate () {
-		if (httpRequest == null) {
-			throw new IllegalStateException("A new request has not been started yet. Call HttpRequestBuilder.newRequest() first.");
-		}
-	}
-
-}
diff --git a/gdx/src/com/badlogic/gdx/net/NetJavaImpl.java b/gdx/src/com/badlogic/gdx/net/NetJavaImpl.java
index 5b6a339..a844689 100644
--- a/gdx/src/com/badlogic/gdx/net/NetJavaImpl.java
+++ b/gdx/src/com/badlogic/gdx/net/NetJavaImpl.java
@@ -44,7 +44,7 @@ import com.badlogic.gdx.utils.StreamUtils;
 public class NetJavaImpl {
 
 	static class HttpClientResponse implements HttpResponse {
-		private final HttpURLConnection connection;
+		private HttpURLConnection connection;
 		private HttpStatus status;
 
 		public HttpClientResponse (HttpURLConnection connection) throws IOException {
@@ -139,7 +139,7 @@ public class NetJavaImpl {
 			} else {
 				url = new URL(httpRequest.getUrl());
 			}
-
+			
 			final HttpURLConnection connection = (HttpURLConnection)url.openConnection();
 			// should be enabled to upload data.
 			final boolean doingOutPut = method.equalsIgnoreCase(HttpMethods.POST) || method.equalsIgnoreCase(HttpMethods.PUT);
@@ -197,23 +197,21 @@ public class NetJavaImpl {
 							HttpResponseListener listener = listeners.get(httpRequest);
 
 							if (listener != null) {
-								lock.unlock();
 								listener.handleHttpResponse(clientResponse);
-								lock.lock();
 								listeners.remove(httpRequest);
 							}
 
 							connections.remove(httpRequest);
 						} finally {
-							lock.unlock();
 							connection.disconnect();
+							lock.unlock();
 						}
 					} catch (final Exception e) {
 						connection.disconnect();
-						try {
+						lock.lock();
+						try {   
 							httpResponseListener.failed(e);
-						} finally {
-							lock.lock();
+						} finally {	
 							connections.remove(httpRequest);
 							listeners.remove(httpRequest);
 							lock.unlock();
@@ -221,11 +219,12 @@ public class NetJavaImpl {
 					}
 				}
 			});
+
 		} catch (Exception e) {
+			lock.lock();
 			try {
 				httpResponseListener.failed(e);
 			} finally {
-				lock.lock();
 				connections.remove(httpRequest);
 				listeners.remove(httpRequest);
 				lock.unlock();
@@ -234,15 +233,13 @@ public class NetJavaImpl {
 		}
 	}
 
-	public void cancelHttpRequest (HttpRequest httpRequest) {
+	public void cancelHttpRequest (HttpRequest httpRequest) {				
 		try {
 			lock.lock();
 			HttpResponseListener httpResponseListener = listeners.get(httpRequest);
-
+	
 			if (httpResponseListener != null) {
-				lock.unlock();
 				httpResponseListener.cancelled();
-				lock.lock();
 				connections.remove(httpRequest);
 				listeners.remove(httpRequest);
 			}
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/Action.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/Action.java
index 4f03ce0..e210318 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/Action.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/Action.java
@@ -27,9 +27,6 @@ abstract public class Action implements Poolable {
 	/** The actor this action is attached to, or null if it is not attached. */
 	protected Actor actor;
 
-	/** The actor this action targets, or null if a target has not been set. */
-	protected Actor target;
-
 	private Pool pool;
 
 	/** Updates the action based on time. Typically this is called each frame by {@link Actor#act(float)}.
@@ -41,20 +38,21 @@ abstract public class Action implements Poolable {
 	public void restart () {
 	}
 
-	/** Sets the actor this action is attached to. This also sets the {@link #setTarget(Actor) target} actor if it is null. This
-	 * method is called automatically when an action is added to an actor. This method is also called with null when an action is
-	 * removed from an actor.
-	 * <p>
-	 * When set to null, if the action has a {@link #setPool(Pool) pool} then the action is {@link Pool#free(Object) returned} to
-	 * the pool (which calls {@link #reset()}) and the pool is set to null. If the action does not have a pool, {@link #reset()} is
-	 * not called.
+	/** @return null if the action is not attached to an actor. */
+	public Actor getActor () {
+		return actor;
+	}
+
+	/** Sets the actor this action will be used for. This is called automatically when an action is added to an actor. This is also
+	 * called with null when an action is removed from an actor. When set to null, if the action has a {@link #setPool(Pool) pool}
+	 * then the action is {@link Pool#free(Object) returned} to the pool (which calls {@link #reset()}) and the pool is set to null.
+	 * If the action does not have a pool, {@link #reset()} is not called.
 	 * <p>
-	 * This method is not typically a good place for an action subclass to query the actor's state because the action may not be
-	 * executed for some time, eg it may be {@link DelayAction delayed}. The actor's state is best queried in the first call to
+	 * This method is not typically a good place for a subclass to query the actor's state because the action may not be executed
+	 * for some time, eg it may be {@link DelayAction delayed}. The actor's state is best queried in the first call to
 	 * {@link #act(float)}. For a {@link TemporalAction}, use TemporalAction#begin(). */
 	public void setActor (Actor actor) {
 		this.actor = actor;
-		if (target == null) setTarget(actor);
 		if (actor == null) {
 			if (pool != null) {
 				pool.free(this);
@@ -63,22 +61,6 @@ abstract public class Action implements Poolable {
 		}
 	}
 
-	/** @return null if the action is not attached to an actor. */
-	public Actor getActor () {
-		return actor;
-	}
-
-	/** Sets the actor this action will manipulate. If no target actor is set, {@link #setActor(Actor)} will set the target actor
-	 * when the action is added to an actor. */
-	public void setTarget (Actor target) {
-		this.target = target;
-	}
-
-	/** @return null if the action has no target. */
-	public Actor getTarget () {
-		return target;
-	}
-
 	/** Resets the optional state of this action to as if it were newly created, allowing the action to be pooled and reused. State
 	 * required to be set for every usage of this action or computed during the action does not need to be reset.
 	 * <p>
@@ -86,9 +68,6 @@ abstract public class Action implements Poolable {
 	 * <p>
 	 * If a subclass has optional state, it must override this method, call super, and reset the optional state. */
 	public void reset () {
-		actor = null;
-		target = null;
-		pool = null;
 		restart();
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/Actor.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/Actor.java
index 288029d..727f66a 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/Actor.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/Actor.java
@@ -18,7 +18,6 @@ package com.badlogic.gdx.scenes.scene2d;
 
 import static com.badlogic.gdx.scenes.scene2d.utils.Align.*;
 
-import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.g2d.Batch;
 import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
@@ -70,6 +69,8 @@ public class Actor {
 	float rotation;
 	final Color color = new Color(1, 1, 1, 1);
 	private Object userObject;
+	
+	static boolean actionsChanged;
 
 	/** Draws the actor. The batch is configured to draw in the parent's coordinate system.
 	 * {@link Batch#draw(com.badlogic.gdx.graphics.g2d.TextureRegion, float, float, float, float, float, float, float, float, float)
@@ -89,7 +90,7 @@ public class Actor {
 	public void act (float delta) {
 		Array<Action> actions = this.actions;
 		if (actions.size > 0) {
-			if (stage != null && stage.getActionsRequestRendering()) Gdx.graphics.requestRendering();
+			actionsChanged = true;
 			for (int i = 0; i < actions.size; i++) {
 				Action action = actions.get(i);
 				if (action.act(delta) && i < actions.size) {
@@ -255,8 +256,7 @@ public class Actor {
 	public void addAction (Action action) {
 		action.setActor(this);
 		actions.add(action);
-
-		if (stage != null && stage.getActionsRequestRendering()) Gdx.graphics.requestRendering();
+		actionsChanged = true;
 	}
 
 	public void removeAction (Action action) {
@@ -373,11 +373,11 @@ public class Actor {
 	}
 
 	/** Returns the X position of the specified {@link Align alignment}. */
-	public float getX (int alignment) {
+	public float getX (int align) {
 		float x = this.x;
-		if ((alignment & right) != 0)
+		if ((align & right) != 0)
 			x += width;
-		else if ((alignment & left) == 0) //
+		else if ((align & left) == 0) //
 			x += width / 2;
 		return x;
 	}
@@ -402,11 +402,11 @@ public class Actor {
 	}
 
 	/** Returns the Y position of the specified {@link Align alignment}. */
-	public float getY (int alignment) {
+	public float getY (int align) {
 		float y = this.y;
-		if ((alignment & top) != 0)
+		if ((align & top) != 0)
 			y += height;
-		else if ((alignment & bottom) == 0) //
+		else if ((align & bottom) == 0) //
 			y += height / 2;
 		return y;
 	}
@@ -421,15 +421,15 @@ public class Actor {
 	}
 
 	/** Sets the position using the specified {@link Align alignment}. Note this may set the position to non-integer coordinates. */
-	public void setPosition (float x, float y, int alignment) {
-		if ((alignment & right) != 0)
+	public void setPosition (float x, float y, int align) {
+		if ((align & right) != 0)
 			x -= width;
-		else if ((alignment & left) == 0) //
+		else if ((align & left) == 0) //
 			x -= width / 2;
 
-		if ((alignment & top) != 0)
+		if ((align & top) != 0)
 			y -= height;
-		else if ((alignment & bottom) == 0) //
+		else if ((align & bottom) == 0) //
 			y -= height / 2;
 
 		if (this.x != x || this.y != y) {
@@ -546,17 +546,17 @@ public class Actor {
 	}
 
 	/** Sets the origin position to the specified {@link Align alignment}. */
-	public void setOrigin (int alignment) {
-		if ((alignment & left) != 0)
+	public void setOrigin (int align) {
+		if ((align & left) != 0)
 			originX = 0;
-		else if ((alignment & right) != 0)
+		else if ((align & right) != 0)
 			originX = width;
 		else
 			originX = width / 2;
 
-		if ((alignment & bottom) != 0)
+		if ((align & bottom) != 0)
 			originY = 0;
-		else if ((alignment & top) != 0)
+		else if ((align & top) != 0)
 			originY = height;
 		else
 			originY = height / 2;
@@ -712,7 +712,8 @@ public class Actor {
 
 	/** Transforms the specified point in the stage's coordinates to the actor's local coordinate system. */
 	public Vector2 stageToLocalCoordinates (Vector2 stageCoords) {
-		if (parent != null) parent.stageToLocalCoordinates(stageCoords);
+		if (parent == null) return stageCoords;
+		parent.stageToLocalCoordinates(stageCoords);
 		parentToLocalCoordinates(stageCoords);
 		return stageCoords;
 	}
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/Group.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/Group.java
index 1e04ed8..d607f8b 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/Group.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/Group.java
@@ -234,11 +234,6 @@ public class Group extends Actor implements Cullable {
 	public void setCullingArea (Rectangle cullingArea) {
 		this.cullingArea = cullingArea;
 	}
-	
-	/** @see #setCullingArea(Rectangle) */
-	public Rectangle getCullingArea () {
-		return cullingArea;
-	}
 
 	public Actor hit (float x, float y, boolean touchable) {
 		if (touchable && getTouchable() == Touchable.disabled) return null;
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/Stage.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/Stage.java
index 412d3aa..a080482 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/Stage.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/Stage.java
@@ -62,14 +62,15 @@ import com.badlogic.gdx.utils.viewport.Viewport;
  * @author mzechner
  * @author Nathan Sweet */
 public class Stage extends InputAdapter implements Disposable {
-	/** True if any actor has ever had debug enabled. */
+	static private final Vector2 actorCoords = new Vector2();
 	static boolean debug;
+	static boolean actionsRequestRendering;
 
 	private Viewport viewport;
 	private final Batch batch;
 	private boolean ownsBatch;
 	private final Group root;
-	private final Vector2 tempCoords = new Vector2();
+	private final Vector2 stageCoords = new Vector2();
 	private final Actor[] pointerOverActors = new Actor[20];
 	private final boolean[] pointerTouched = new boolean[20];
 	private final int[] pointerScreenX = new int[20];
@@ -78,7 +79,6 @@ public class Stage extends InputAdapter implements Disposable {
 	private Actor mouseOverActor;
 	private Actor keyboardFocus, scrollFocus;
 	private final SnapshotArray<TouchFocus> touchFocuses = new SnapshotArray(true, 4, TouchFocus.class);
-	private boolean actionsRequestRendering = true;
 
 	private ShapeRenderer debugShapes;
 	private boolean debugInvisible, debugAll, debugUnderMouse, debugParentUnderMouse;
@@ -139,8 +139,8 @@ public class Stage extends InputAdapter implements Disposable {
 		}
 
 		if (debugUnderMouse || debugParentUnderMouse || debugTableUnderMouse != Debug.none) {
-			screenToStageCoordinates(tempCoords.set(Gdx.input.getX(), Gdx.input.getY()));
-			Actor actor = hit(tempCoords.x, tempCoords.y, true);
+			screenToStageCoordinates(stageCoords.set(Gdx.input.getX(), Gdx.input.getY()));
+			Actor actor = hit(stageCoords.x, stageCoords.y, true);
 			if (actor == null) return;
 
 			if (debugParentUnderMouse && actor.parent != null) actor = actor.parent;
@@ -197,13 +197,13 @@ public class Stage extends InputAdapter implements Disposable {
 			if (!pointerTouched[pointer]) {
 				if (overLast != null) {
 					pointerOverActors[pointer] = null;
-					screenToStageCoordinates(tempCoords.set(pointerScreenX[pointer], pointerScreenY[pointer]));
+					screenToStageCoordinates(stageCoords.set(pointerScreenX[pointer], pointerScreenY[pointer]));
 					// Exit over last.
 					InputEvent event = Pools.obtain(InputEvent.class);
 					event.setType(InputEvent.Type.exit);
 					event.setStage(this);
-					event.setStageX(tempCoords.x);
-					event.setStageY(tempCoords.y);
+					event.setStageX(stageCoords.x);
+					event.setStageY(stageCoords.y);
 					event.setRelatedActor(overLast);
 					event.setPointer(pointer);
 					overLast.fire(event);
@@ -221,18 +221,20 @@ public class Stage extends InputAdapter implements Disposable {
 
 		// Run actions and determine whether to request rendering (for when setContinuousRendering is off)
 		root.act(delta);
+		if (actionsRequestRendering && Actor.actionsChanged) Gdx.graphics.requestRendering();
+		Actor.actionsChanged = false;
 	}
 
 	private Actor fireEnterAndExit (Actor overLast, int screenX, int screenY, int pointer) {
 		// Find the actor under the point.
-		screenToStageCoordinates(tempCoords.set(screenX, screenY));
-		Actor over = hit(tempCoords.x, tempCoords.y, true);
+		screenToStageCoordinates(stageCoords.set(screenX, screenY));
+		Actor over = hit(stageCoords.x, stageCoords.y, true);
 		if (over == overLast) return overLast;
 
 		InputEvent event = Pools.obtain(InputEvent.class);
 		event.setStage(this);
-		event.setStageX(tempCoords.x);
-		event.setStageY(tempCoords.y);
+		event.setStageX(stageCoords.x);
+		event.setStageY(stageCoords.y);
 		event.setPointer(pointer);
 		// Exit overLast.
 		if (overLast != null) {
@@ -260,23 +262,20 @@ public class Stage extends InputAdapter implements Disposable {
 		pointerScreenX[pointer] = screenX;
 		pointerScreenY[pointer] = screenY;
 
-		screenToStageCoordinates(tempCoords.set(screenX, screenY));
+		screenToStageCoordinates(stageCoords.set(screenX, screenY));
 
 		InputEvent event = Pools.obtain(InputEvent.class);
 		event.setType(Type.touchDown);
 		event.setStage(this);
-		event.setStageX(tempCoords.x);
-		event.setStageY(tempCoords.y);
+		event.setStageX(stageCoords.x);
+		event.setStageY(stageCoords.y);
 		event.setPointer(pointer);
 		event.setButton(button);
 
-		Actor target = hit(tempCoords.x, tempCoords.y, true);
-		if (target == null) {
-			if (root.getTouchable() == Touchable.enabled) root.fire(event);
-		} else {
-			target.fire(event);
-		}
+		Actor target = hit(stageCoords.x, stageCoords.y, true);
+		if (target == null) target = root;
 
+		target.fire(event);
 		boolean handled = event.isHandled();
 		Pools.free(event);
 		return handled;
@@ -292,13 +291,13 @@ public class Stage extends InputAdapter implements Disposable {
 
 		if (touchFocuses.size == 0) return false;
 
-		screenToStageCoordinates(tempCoords.set(screenX, screenY));
+		screenToStageCoordinates(stageCoords.set(screenX, screenY));
 
 		InputEvent event = Pools.obtain(InputEvent.class);
 		event.setType(Type.touchDragged);
 		event.setStage(this);
-		event.setStageX(tempCoords.x);
-		event.setStageY(tempCoords.y);
+		event.setStageX(stageCoords.x);
+		event.setStageY(stageCoords.y);
 		event.setPointer(pointer);
 
 		SnapshotArray<TouchFocus> touchFocuses = this.touchFocuses;
@@ -306,7 +305,6 @@ public class Stage extends InputAdapter implements Disposable {
 		for (int i = 0, n = touchFocuses.size; i < n; i++) {
 			TouchFocus focus = focuses[i];
 			if (focus.pointer != pointer) continue;
-			if (!touchFocuses.contains(focus, true)) continue; // Touch focus already gone.
 			event.setTarget(focus.target);
 			event.setListenerActor(focus.listenerActor);
 			if (focus.listener.handle(event)) event.handle();
@@ -327,13 +325,13 @@ public class Stage extends InputAdapter implements Disposable {
 
 		if (touchFocuses.size == 0) return false;
 
-		screenToStageCoordinates(tempCoords.set(screenX, screenY));
+		screenToStageCoordinates(stageCoords.set(screenX, screenY));
 
 		InputEvent event = Pools.obtain(InputEvent.class);
 		event.setType(Type.touchUp);
 		event.setStage(this);
-		event.setStageX(tempCoords.x);
-		event.setStageY(tempCoords.y);
+		event.setStageX(stageCoords.x);
+		event.setStageY(stageCoords.y);
 		event.setPointer(pointer);
 		event.setButton(button);
 
@@ -365,15 +363,15 @@ public class Stage extends InputAdapter implements Disposable {
 		mouseScreenX = screenX;
 		mouseScreenY = screenY;
 
-		screenToStageCoordinates(tempCoords.set(screenX, screenY));
+		screenToStageCoordinates(stageCoords.set(screenX, screenY));
 
 		InputEvent event = Pools.obtain(InputEvent.class);
 		event.setStage(this);
 		event.setType(Type.mouseMoved);
-		event.setStageX(tempCoords.x);
-		event.setStageY(tempCoords.y);
+		event.setStageX(stageCoords.x);
+		event.setStageY(stageCoords.y);
 
-		Actor target = hit(tempCoords.x, tempCoords.y, true);
+		Actor target = hit(stageCoords.x, stageCoords.y, true);
 		if (target == null) target = root;
 
 		target.fire(event);
@@ -387,14 +385,14 @@ public class Stage extends InputAdapter implements Disposable {
 	public boolean scrolled (int amount) {
 		Actor target = scrollFocus == null ? root : scrollFocus;
 
-		screenToStageCoordinates(tempCoords.set(mouseScreenX, mouseScreenY));
+		screenToStageCoordinates(stageCoords.set(mouseScreenX, mouseScreenY));
 
 		InputEvent event = Pools.obtain(InputEvent.class);
 		event.setStage(this);
 		event.setType(InputEvent.Type.scrolled);
 		event.setScrollAmount(amount);
-		event.setStageX(tempCoords.x);
-		event.setStageY(tempCoords.y);
+		event.setStageX(stageCoords.x);
+		event.setStageY(stageCoords.y);
 		target.fire(event);
 		boolean handled = event.isHandled();
 		Pools.free(event);
@@ -698,8 +696,8 @@ public class Stage extends InputAdapter implements Disposable {
 	 * @param touchable If true, the hit detection will respect the {@link Actor#setTouchable(Touchable) touchability}.
 	 * @return May be null if no actor was hit. */
 	public Actor hit (float stageX, float stageY, boolean touchable) {
-		root.parentToLocalCoordinates(tempCoords.set(stageX, stageY));
-		return root.hit(tempCoords.x, tempCoords.y, touchable);
+		root.parentToLocalCoordinates(actorCoords.set(stageX, stageY));
+		return root.hit(actorCoords.x, actorCoords.y, touchable);
 	}
 
 	/** Transforms the screen coordinates to stage coordinates.
@@ -737,17 +735,6 @@ public class Stage extends InputAdapter implements Disposable {
 		viewport.calculateScissors(transformMatrix, localRect, scissorRect);
 	}
 
-	/** If true, any actions executed during a call to {@link #act()}) will result in a call to {@link Graphics#requestRendering()}.
-	 * Widgets that animate or otherwise require additional rendering may check this setting before calling
-	 * {@link Graphics#requestRendering()}. Default is true. */
-	public void setActionsRequestRendering (boolean actionsRequestRendering) {
-		this.actionsRequestRendering = actionsRequestRendering;
-	}
-
-	public boolean getActionsRequestRendering () {
-		return actionsRequestRendering;
-	}
-
 	/** The default color that can be used by actors to draw debug lines. */
 	public Color getDebugColor () {
 		return debugColor;
@@ -807,6 +794,11 @@ public class Stage extends InputAdapter implements Disposable {
 	public void setDebugTableUnderMouse (boolean debugTableUnderMouse) {
 		setDebugTableUnderMouse(debugTableUnderMouse ? Debug.all : Debug.none);
 	}
+	
+	/** If true, any actions executed during a call to Stage.act() will result in a call to Gdx.graphics.requestRendering(). */
+	public static void setActionsRequestRendering (boolean actionsRequestRendering) {
+		Stage.actionsRequestRendering = actionsRequestRendering;
+	}
 
 	public void dispose () {
 		clear();
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/Actions.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/Actions.java
index a5369f2..effe117 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/Actions.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/Actions.java
@@ -44,7 +44,7 @@ public class Actions {
 
 	static public AddAction addAction (Action action, Actor targetActor) {
 		AddAction addAction = action(AddAction.class);
-		addAction.setTarget(targetActor);
+		addAction.setTargetActor(targetActor);
 		addAction.setAction(action);
 		return addAction;
 	}
@@ -57,7 +57,7 @@ public class Actions {
 
 	static public RemoveAction removeAction (Action action, Actor targetActor) {
 		RemoveAction removeAction = action(RemoveAction.class);
-		removeAction.setTarget(targetActor);
+		removeAction.setTargetActor(targetActor);
 		removeAction.setAction(action);
 		return removeAction;
 	}
@@ -79,22 +79,6 @@ public class Actions {
 		return action;
 	}
 
-	static public MoveToAction moveToAligned (float x, float y, int alignment) {
-		return moveToAligned(x, y, alignment, 0, null);
-	}
-
-	static public MoveToAction moveToAligned (float x, float y, int alignment, float duration) {
-		return moveToAligned(x, y, alignment, duration, null);
-	}
-
-	static public MoveToAction moveToAligned (float x, float y, int alignment, float duration, Interpolation interpolation) {
-		MoveToAction action = action(MoveToAction.class);
-		action.setPosition(x, y, alignment);
-		action.setDuration(duration);
-		action.setInterpolation(interpolation);
-		return action;
-	}
-
 	/** Moves the actor instantly. */
 	static public MoveByAction moveBy (float amountX, float amountY) {
 		return moveBy(amountX, amountY, 0, null);
@@ -306,7 +290,7 @@ public class Actions {
 
 	static public RemoveActorAction removeActor (Actor removeActor) {
 		RemoveActorAction action = action(RemoveActorAction.class);
-		action.setTarget(removeActor);
+		action.setRemoveActor(removeActor);
 		return action;
 	}
 
@@ -473,7 +457,7 @@ public class Actions {
 
 	static public AddListenerAction addListener (EventListener listener, boolean capture, Actor targetActor) {
 		AddListenerAction addAction = action(AddListenerAction.class);
-		addAction.setTarget(targetActor);
+		addAction.setTargetActor(targetActor);
 		addAction.setListener(listener);
 		addAction.setCapture(capture);
 		return addAction;
@@ -488,7 +472,7 @@ public class Actions {
 
 	static public RemoveListenerAction removeListener (EventListener listener, boolean capture, Actor targetActor) {
 		RemoveListenerAction addAction = action(RemoveListenerAction.class);
-		addAction.setTarget(targetActor);
+		addAction.setTargetActor(targetActor);
 		addAction.setListener(listener);
 		addAction.setCapture(capture);
 		return addAction;
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/AddAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/AddAction.java
index 3b71140..dd11d0b 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/AddAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/AddAction.java
@@ -22,13 +22,23 @@ import com.badlogic.gdx.scenes.scene2d.Actor;
 /** Adds an action to an actor.
  * @author Nathan Sweet */
 public class AddAction extends Action {
+	private Actor targetActor;
 	private Action action;
 
 	public boolean act (float delta) {
-		target.addAction(action);
+		(targetActor != null ? targetActor : actor).addAction(action);
 		return true;
 	}
 
+	public Actor getTargetActor () {
+		return targetActor;
+	}
+
+	/** Sets the actor to add an action to. If null (the default), the {@link #getActor() actor} will be used. */
+	public void setTargetActor (Actor actor) {
+		this.targetActor = actor;
+	}
+
 	public Action getAction () {
 		return action;
 	}
@@ -43,6 +53,7 @@ public class AddAction extends Action {
 
 	public void reset () {
 		super.reset();
+		targetActor = null;
 		action = null;
 	}
 }
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/AddListenerAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/AddListenerAction.java
index 0938963..37d672d 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/AddListenerAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/AddListenerAction.java
@@ -23,17 +23,28 @@ import com.badlogic.gdx.scenes.scene2d.EventListener;
 /** Adds a listener to an actor.
  * @author Nathan Sweet */
 public class AddListenerAction extends Action {
+	private Actor targetActor;
 	private EventListener listener;
 	private boolean capture;
 
 	public boolean act (float delta) {
+		Actor actor = (targetActor != null ? targetActor : this.actor);
 		if (capture)
-			target.addCaptureListener(listener);
+			actor.addCaptureListener(listener);
 		else
-			target.addListener(listener);
+			actor.addListener(listener);
 		return true;
 	}
 
+	public Actor getTargetActor () {
+		return targetActor;
+	}
+
+	/** Sets the actor to add a listener to. If null (the default), the {@link #getActor() actor} will be used. */
+	public void setTargetActor (Actor actor) {
+		this.targetActor = actor;
+	}
+
 	public EventListener getListener () {
 		return listener;
 	}
@@ -52,6 +63,7 @@ public class AddListenerAction extends Action {
 
 	public void reset () {
 		super.reset();
+		targetActor = null;
 		listener = null;
 	}
 }
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/AfterAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/AfterAction.java
index 2595f88..cae1e4a 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/AfterAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/AfterAction.java
@@ -20,14 +20,14 @@ import com.badlogic.gdx.scenes.scene2d.Action;
 import com.badlogic.gdx.scenes.scene2d.Actor;
 import com.badlogic.gdx.utils.Array;
 
-/** Executes an action only after all other actions on the actor at the time this action's target was set have finished.
+/** Executes an action only after all other actions on the actor at the time this action was added have finished.
  * @author Nathan Sweet */
 public class AfterAction extends DelegateAction {
 	private Array<Action> waitForActions = new Array(false, 4);
 
-	public void setTarget (Actor target) {
-		if (target != null) waitForActions.addAll(target.getActions());
-		super.setTarget(target);
+	public void setActor (Actor actor) {
+		if (actor != null) waitForActions.addAll(actor.getActions());
+		super.setActor(actor);
 	}
 
 	public void restart () {
@@ -36,7 +36,7 @@ public class AfterAction extends DelegateAction {
 	}
 
 	protected boolean delegate (float delta) {
-		Array<Action> currentActions = target.getActions();
+		Array<Action> currentActions = actor.getActions();
 		if (currentActions.size == 1) waitForActions.clear();
 		for (int i = waitForActions.size - 1; i >= 0; i--) {
 			Action action = waitForActions.get(i);
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/AlphaAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/AlphaAction.java
index 7b3e3e9..7cf2e1a 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/AlphaAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/AlphaAction.java
@@ -27,7 +27,7 @@ public class AlphaAction extends TemporalAction {
 	private Color color;
 
 	protected void begin () {
-		if (color == null) color = target.getColor();
+		if (color == null) color = actor.getColor();
 		start = color.a;
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/ColorAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/ColorAction.java
index b096e29..975828d 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/ColorAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/ColorAction.java
@@ -28,7 +28,7 @@ public class ColorAction extends TemporalAction {
 	private final Color end = new Color();
 
 	protected void begin () {
-		if (color == null) color = target.getColor();
+		if (color == null) color = actor.getColor();
 		startR = color.r;
 		startG = color.g;
 		startB = color.b;
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/DelegateAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/DelegateAction.java
index 1927055..b7eddfa 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/DelegateAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/DelegateAction.java
@@ -60,11 +60,6 @@ abstract public class DelegateAction extends Action {
 		super.setActor(actor);
 	}
 
-	public void setTarget (Actor target) {
-		if (action != null) action.setTarget(target);
-		super.setTarget(target);
-	}
-
 	public String toString () {
 		return super.toString() + (action == null ? "" : "(" + action + ")");
 	}
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/EventAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/EventAction.java
index 7d66110..9d6f5cd 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/EventAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/EventAction.java
@@ -31,10 +31,10 @@ abstract public class EventAction<T extends Event> extends Action {
 		active = false;
 	}
 
-	public void setTarget (Actor newTarget) {
-		if (target != null) target.removeListener(listener);
-		super.setTarget(newTarget);
-		if (newTarget != null) newTarget.addListener(listener);
+	public void setActor (Actor actor) {
+		if (getActor() != null) getActor().removeListener(listener);
+		super.setActor(actor);
+		if (actor != null) actor.addListener(listener);
 	}
 
 	/** Called when the specific type of event occurs on the actor.
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/LayoutAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/LayoutAction.java
index cd7bc25..17f0942 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/LayoutAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/LayoutAction.java
@@ -27,13 +27,13 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
 public class LayoutAction extends Action {
 	private boolean enabled;
 
-	public void setTarget (Actor actor) {
+	public void setActor (Actor actor) {
 		if (actor != null && !(actor instanceof Layout)) throw new GdxRuntimeException("Actor must implement layout: " + actor);
-		super.setTarget(actor);
+		super.setActor(actor);
 	}
 
 	public boolean act (float delta) {
-		((Layout)target).setLayoutEnabled(enabled);
+		((Layout)actor).setLayoutEnabled(enabled);
 		return true;
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/MoveByAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/MoveByAction.java
index 4ff2d49..c508998 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/MoveByAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/MoveByAction.java
@@ -22,7 +22,7 @@ public class MoveByAction extends RelativeTemporalAction {
 	private float amountX, amountY;
 
 	protected void updateRelative (float percentDelta) {
-		target.moveBy(amountX * percentDelta, amountY * percentDelta);
+		actor.moveBy(amountX * percentDelta, amountY * percentDelta);
 	}
 
 	public void setAmount (float x, float y) {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/MoveToAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/MoveToAction.java
index fab2ed6..e87a6a8 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/MoveToAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/MoveToAction.java
@@ -16,27 +16,19 @@
 
 package com.badlogic.gdx.scenes.scene2d.actions;
 
-import com.badlogic.gdx.scenes.scene2d.utils.Align;
-
 /** Moves an actor from its current position to a specific position.
  * @author Nathan Sweet */
 public class MoveToAction extends TemporalAction {
 	private float startX, startY;
 	private float endX, endY;
-	private int alignment = Align.bottomLeft;
 
 	protected void begin () {
-		startX = target.getX(alignment);
-		startY = target.getY(alignment);
+		startX = actor.getX();
+		startY = actor.getY();
 	}
 
 	protected void update (float percent) {
-		target.setPosition(startX + (endX - startX) * percent, startY + (endY - startY) * percent, alignment);
-	}
-
-	public void reset () {
-		super.reset();
-		alignment = Align.bottomLeft;
+		actor.setPosition(startX + (endX - startX) * percent, startY + (endY - startY) * percent);
 	}
 
 	public void setPosition (float x, float y) {
@@ -44,12 +36,6 @@ public class MoveToAction extends TemporalAction {
 		endY = y;
 	}
 
-	public void setPosition (float x, float y, int alignment) {
-		endX = x;
-		endY = y;
-		this.alignment = alignment;
-	}
-
 	public float getX () {
 		return endX;
 	}
@@ -65,12 +51,4 @@ public class MoveToAction extends TemporalAction {
 	public void setY (float y) {
 		endY = y;
 	}
-
-	public int getAlignment () {
-		return alignment;
-	}
-
-	public void setAlignment (int alignment) {
-		this.alignment = alignment;
-	}
 }
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RemoveAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RemoveAction.java
index 6bc3a89..3460108 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RemoveAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RemoveAction.java
@@ -22,13 +22,23 @@ import com.badlogic.gdx.scenes.scene2d.Actor;
 /** Removes an action from an actor.
  * @author Nathan Sweet */
 public class RemoveAction extends Action {
+	private Actor targetActor;
 	private Action action;
 
 	public boolean act (float delta) {
-		target.removeAction(action);
+		(targetActor != null ? targetActor : actor).removeAction(action);
 		return true;
 	}
 
+	public Actor getTargetActor () {
+		return targetActor;
+	}
+
+	/** Sets the actor to remove an action from. If null (the default), the {@link #getActor() actor} will be used. */
+	public void setTargetActor (Actor actor) {
+		this.targetActor = actor;
+	}
+
 	public Action getAction () {
 		return action;
 	}
@@ -39,6 +49,7 @@ public class RemoveAction extends Action {
 
 	public void reset () {
 		super.reset();
+		targetActor = null;
 		action = null;
 	}
 }
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RemoveActorAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RemoveActorAction.java
index d9c128c..25ce733 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RemoveActorAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RemoveActorAction.java
@@ -22,12 +22,13 @@ import com.badlogic.gdx.scenes.scene2d.Actor;
 /** Removes an actor from the stage.
  * @author Nathan Sweet */
 public class RemoveActorAction extends Action {
+	private Actor removeActor;
 	private boolean removed;
 
 	public boolean act (float delta) {
 		if (!removed) {
 			removed = true;
-			target.remove();
+			(removeActor != null ? removeActor : actor).remove();
 		}
 		return true;
 	}
@@ -35,4 +36,18 @@ public class RemoveActorAction extends Action {
 	public void restart () {
 		removed = false;
 	}
+
+	public void reset () {
+		super.reset();
+		removeActor = null;
+	}
+
+	public Actor getRemoveActor () {
+		return removeActor;
+	}
+
+	/** Sets the actor to remove. If null (the default), the {@link #getActor() actor} will be used. */
+	public void setRemoveActor (Actor removeActor) {
+		this.removeActor = removeActor;
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RemoveListenerAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RemoveListenerAction.java
index 4697c2c..867b509 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RemoveListenerAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RemoveListenerAction.java
@@ -23,17 +23,28 @@ import com.badlogic.gdx.scenes.scene2d.EventListener;
 /** Removes a listener from an actor.
  * @author Nathan Sweet */
 public class RemoveListenerAction extends Action {
+	private Actor targetActor;
 	private EventListener listener;
 	private boolean capture;
 
 	public boolean act (float delta) {
+		Actor actor = (targetActor != null ? targetActor : this.actor);
 		if (capture)
-			target.removeCaptureListener(listener);
+			actor.removeCaptureListener(listener);
 		else
-			target.removeListener(listener);
+			actor.removeListener(listener);
 		return true;
 	}
 
+	public Actor getTargetActor () {
+		return targetActor;
+	}
+
+	/** Sets the actor to remove a listener from. If null (the default), the {@link #getActor() actor} will be used. */
+	public void setTargetActor (Actor actor) {
+		this.targetActor = actor;
+	}
+
 	public EventListener getListener () {
 		return listener;
 	}
@@ -52,6 +63,7 @@ public class RemoveListenerAction extends Action {
 
 	public void reset () {
 		super.reset();
+		targetActor = null;
 		listener = null;
 	}
 }
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RotateByAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RotateByAction.java
index 67fa9bf..56dbbfa 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RotateByAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RotateByAction.java
@@ -22,7 +22,7 @@ public class RotateByAction extends RelativeTemporalAction {
 	private float amount;
 
 	protected void updateRelative (float percentDelta) {
-		target.rotateBy(amount * percentDelta);
+		actor.rotateBy(amount * percentDelta);
 	}
 
 	public float getAmount () {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RotateToAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RotateToAction.java
index 20d1514..24f2b4a 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RotateToAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RotateToAction.java
@@ -22,11 +22,11 @@ public class RotateToAction extends TemporalAction {
 	private float start, end;
 
 	protected void begin () {
-		start = target.getRotation();
+		start = actor.getRotation();
 	}
 
 	protected void update (float percent) {
-		target.setRotation(start + (end - start) * percent);
+		actor.setRotation(start + (end - start) * percent);
 	}
 
 	public float getRotation () {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/ScaleByAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/ScaleByAction.java
index c3c6475..ec9af5c 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/ScaleByAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/ScaleByAction.java
@@ -22,7 +22,7 @@ public class ScaleByAction extends RelativeTemporalAction {
 	private float amountX, amountY;
 
 	protected void updateRelative (float percentDelta) {
-		target.scaleBy(amountX * percentDelta, amountY * percentDelta);
+		actor.scaleBy(amountX * percentDelta, amountY * percentDelta);
 	}
 
 	public void setAmount (float x, float y) {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/ScaleToAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/ScaleToAction.java
index 1ee933d..fad298b 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/ScaleToAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/ScaleToAction.java
@@ -23,12 +23,12 @@ public class ScaleToAction extends TemporalAction {
 	private float endX, endY;
 
 	protected void begin () {
-		startX = target.getScaleX();
-		startY = target.getScaleY();
+		startX = actor.getScaleX();
+		startY = actor.getScaleY();
 	}
 
 	protected void update (float percent) {
-		target.setScale(startX + (endX - startX) * percent, startY + (endY - startY) * percent);
+		actor.setScale(startX + (endX - startX) * percent, startY + (endY - startY) * percent);
 	}
 
 	public void setScale (float x, float y) {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/SizeByAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/SizeByAction.java
index abd2838..484e05d 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/SizeByAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/SizeByAction.java
@@ -22,7 +22,7 @@ public class SizeByAction extends RelativeTemporalAction {
 	private float amountWidth, amountHeight;
 
 	protected void updateRelative (float percentDelta) {
-		target.sizeBy(amountWidth * percentDelta, amountHeight * percentDelta);
+		actor.sizeBy(amountWidth * percentDelta, amountHeight * percentDelta);
 	}
 
 	public void setAmount (float width, float height) {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/SizeToAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/SizeToAction.java
index 6c85aa9..2d0feac 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/SizeToAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/SizeToAction.java
@@ -23,12 +23,12 @@ public class SizeToAction extends TemporalAction {
 	private float endWidth, endHeight;
 
 	protected void begin () {
-		startWidth = target.getWidth();
-		startHeight = target.getHeight();
+		startWidth = actor.getWidth();
+		startHeight = actor.getHeight();
 	}
 
 	protected void update (float percent) {
-		target.setSize(startWidth + (endWidth - startWidth) * percent, startHeight + (endHeight - startHeight) * percent);
+		actor.setSize(startWidth + (endWidth - startWidth) * percent, startHeight + (endHeight - startHeight) * percent);
 	}
 
 	public void setSize (float width, float height) {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/TouchableAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/TouchableAction.java
index 6ee89cb..aea4cfa 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/TouchableAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/TouchableAction.java
@@ -26,7 +26,7 @@ public class TouchableAction extends Action {
 	private Touchable touchable;
 
 	public boolean act (float delta) {
-		target.setTouchable(touchable);
+		actor.setTouchable(touchable);
 		return true;
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/VisibleAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/VisibleAction.java
index b899356..82c8d2c 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/VisibleAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/VisibleAction.java
@@ -25,7 +25,7 @@ public class VisibleAction extends Action {
 	private boolean visible;
 
 	public boolean act (float delta) {
-		target.setVisible(visible);
+		actor.setVisible(visible);
 		return true;
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Button.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Button.java
index 1ca1366..f3a225e 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Button.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Button.java
@@ -16,11 +16,9 @@
 
 package com.badlogic.gdx.scenes.scene2d.ui;
 
-import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.g2d.Batch;
 import com.badlogic.gdx.scenes.scene2d.Actor;
 import com.badlogic.gdx.scenes.scene2d.InputEvent;
-import com.badlogic.gdx.scenes.scene2d.Stage;
 import com.badlogic.gdx.scenes.scene2d.Touchable;
 import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener.ChangeEvent;
 import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
@@ -174,11 +172,6 @@ public class Button extends Table implements Disableable {
 		return style;
 	}
 
-	/** @return May be null. */
-	public ButtonGroup getButtonGroup () {
-		return buttonGroup;
-	}
-
 	public void draw (Batch batch, float parentAlpha) {
 		validate();
 
@@ -213,10 +206,6 @@ public class Button extends Table implements Disableable {
 		super.draw(batch, parentAlpha);
 		for (int i = 0; i < children.size; i++)
 			children.get(i).moveBy(-offsetX, -offsetY);
-
-		Stage stage = getStage();
-		if (stage != null && stage.getActionsRequestRendering() && isPressed != clickListener.isPressed())
-			Gdx.graphics.requestRendering();
 	}
 
 	public float getPrefWidth () {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ButtonGroup.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ButtonGroup.java
index 254ba00..daaa91a 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ButtonGroup.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ButtonGroup.java
@@ -20,50 +20,48 @@ import com.badlogic.gdx.utils.Array;
 
 /** Manages a group of buttons to enforce a minimum and maximum number of checked buttons. This enables "radio button"
  * functionality and more. A button may only be in one group at a time.
- * <p>
- * The {@link #canCheck(Button, boolean)} method can be overridden to control if a button check or uncheck is allowed.
  * @author Nathan Sweet */
-public class ButtonGroup<T extends Button> {
-	private final Array<T> buttons = new Array();
-	private Array<T> checkedButtons = new Array(1);
+public class ButtonGroup {
+	private final Array<Button> buttons = new Array();
+	private Array<Button> checkedButtons = new Array(1);
 	private int minCheckCount, maxCheckCount = 1;
 	private boolean uncheckLast = true;
-	private T lastChecked;
+	private Button lastChecked;
 
 	public ButtonGroup () {
 		minCheckCount = 1;
 	}
 
-	public ButtonGroup (T... buttons) {
+	public ButtonGroup (Button... buttons) {
 		minCheckCount = 0;
 		add(buttons);
 		minCheckCount = 1;
 	}
 
-	public void add (T button) {
+	public void add (Button button) {
 		if (button == null) throw new IllegalArgumentException("button cannot be null.");
 		button.buttonGroup = null;
 		boolean shouldCheck = button.isChecked() || buttons.size < minCheckCount;
 		button.setChecked(false);
 		button.buttonGroup = this;
 		buttons.add(button);
-		button.setChecked(shouldCheck);
+		if (shouldCheck) button.setChecked(true);
 	}
 
-	public void add (T... buttons) {
+	public void add (Button... buttons) {
 		if (buttons == null) throw new IllegalArgumentException("buttons cannot be null.");
 		for (int i = 0, n = buttons.length; i < n; i++)
 			add(buttons[i]);
 	}
 
-	public void remove (T button) {
+	public void remove (Button button) {
 		if (button == null) throw new IllegalArgumentException("button cannot be null.");
 		button.buttonGroup = null;
 		buttons.removeValue(button, true);
 		checkedButtons.removeValue(button, true);
 	}
 
-	public void remove (T... buttons) {
+	public void remove (Button... buttons) {
 		if (buttons == null) throw new IllegalArgumentException("buttons cannot be null.");
 		for (int i = 0, n = buttons.length; i < n; i++)
 			remove(buttons[i]);
@@ -78,7 +76,7 @@ public class ButtonGroup<T extends Button> {
 	public void setChecked (String text) {
 		if (text == null) throw new IllegalArgumentException("text cannot be null.");
 		for (int i = 0, n = buttons.size; i < n; i++) {
-			T button = buttons.get(i);
+			Button button = buttons.get(i);
 			if (button instanceof TextButton && text.contentEquals(((TextButton)button).getText())) {
 				button.setChecked(true);
 				return;
@@ -86,10 +84,9 @@ public class ButtonGroup<T extends Button> {
 		}
 	}
 
-	/** Called when a button is checked or unchecked. If overridden, generally changing button checked states should not be done
-	 * from within this method.
+	/** Called when a button is checked or unchecked.
 	 * @return True if the new state should be allowed. */
-	protected boolean canCheck (T button, boolean newState) {
+	protected boolean canCheck (Button button, boolean newState) {
 		if (button.isChecked == newState) return false;
 
 		if (!newState) {
@@ -119,29 +116,23 @@ public class ButtonGroup<T extends Button> {
 		int old = minCheckCount;
 		minCheckCount = 0;
 		for (int i = 0, n = buttons.size; i < n; i++) {
-			T button = buttons.get(i);
+			Button button = buttons.get(i);
 			button.setChecked(false);
 		}
 		minCheckCount = old;
 	}
 
 	/** @return The first checked button, or null. */
-	public T getChecked () {
+	public Button getChecked () {
 		if (checkedButtons.size > 0) return checkedButtons.get(0);
 		return null;
 	}
 
-	/** @return The first checked button index, or -1. */
-	public int getCheckedIndex () {
-		if (checkedButtons.size > 0) return buttons.indexOf(checkedButtons.get(0), true);
-		return -1;
-	}
-
-	public Array<T> getAllChecked () {
+	public Array<Button> getAllChecked () {
 		return checkedButtons;
 	}
 
-	public Array<T> getButtons () {
+	public Array<Button> getButtons () {
 		return buttons;
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Cell.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Cell.java
index 2014e76..f0bd416 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Cell.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Cell.java
@@ -32,13 +32,9 @@ public class Cell<T extends Actor> implements Poolable {
 	private Table table;
 	boolean endRow;
 	int column, row;
-	int cellAboveIndex;
+	int cellAboveIndex = -1;
 	float computedPadTop, computedPadLeft, computedPadBottom, computedPadRight;
 
-	public Cell () {
-		reset();
-	}
-
 	public void setLayout (Table table) {
 		this.table = table;
 	}
@@ -850,8 +846,8 @@ public class Cell<T extends Actor> implements Poolable {
 		return computedPadRight;
 	}
 
-	public void row () {
-		table.row();
+	public Cell<T> row () {
+		return table.row();
 	}
 
 	public Table getTable () {
@@ -884,13 +880,16 @@ public class Cell<T extends Actor> implements Poolable {
 		uniformY = null;
 	}
 
-	/** Reset state so the cell can be reused, setting all constraints to their default values. */
+	/** Reset state so the cell can be reused. Doesn't reset the constraint fields. */
 	public void reset () {
 		actor = null;
 		table = null;
 		endRow = false;
 		cellAboveIndex = -1;
+	}
 
+	/** Set all constraints to cell default values. */
+	void defaults () {
 		minWidth = Value.minWidth;
 		minHeight = Value.minHeight;
 		prefWidth = Value.prefWidth;
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Dialog.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Dialog.java
index f2fcee4..1faca84 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Dialog.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Dialog.java
@@ -55,7 +55,6 @@ public class Dialog extends Window {
 
 	public Dialog (String title, Skin skin) {
 		super(title, skin.get(WindowStyle.class));
-		setSkin(skin);
 		this.skin = skin;
 		initialize();
 	}
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ImageTextButton.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ImageTextButton.java
index 2ff205f..9991a53 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ImageTextButton.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ImageTextButton.java
@@ -138,10 +138,6 @@ public class ImageTextButton extends Button {
 		return label.getText();
 	}
 
-	public String toString () {
-		return super.toString() + ": " + label.getText();
-	}
-
 	/** The style for an image text button, see {@link ImageTextButton}.
 	 * @author Nathan Sweet */
 	static public class ImageTextButtonStyle extends TextButtonStyle {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Label.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Label.java
index b7c6d2f..0ec8341 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Label.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Label.java
@@ -44,7 +44,7 @@ public class Label extends Widget {
 	private float lastPrefHeight;
 	private boolean sizeInvalid = true;
 	private float fontScaleX = 1, fontScaleY = 1;
-	private boolean ellipsis;
+	private boolean ellipse;
 
 	public Label (CharSequence text, Skin skin) {
 		this(text, skin.get(LabelStyle.class));
@@ -86,14 +86,14 @@ public class Label extends Widget {
 		return style;
 	}
 
-	/** @param newText May be null, "" will be used. */
+	/** @param newText May be null. */
 	public void setText (CharSequence newText) {
-		if (newText == null) newText = "";
 		if (newText instanceof StringBuilder) {
 			if (text.equals(newText)) return;
 			text.setLength(0);
 			text.append((StringBuilder)newText);
 		} else {
+			if (newText == null) newText = "";
 			if (textEquals(newText)) return;
 			text.setLength(0);
 			text.append(newText);
@@ -158,7 +158,7 @@ public class Label extends Widget {
 
 		float width = getWidth(), height = getHeight();
 		StringBuilder text;
-		if (ellipsis && width < bounds.width) {
+		if (ellipse && width < bounds.width) {
 			float ellipseWidth = font.getBounds("...").width;
 			text = tempText != null ? tempText : (tempText = new StringBuilder());
 			text.setLength(0);
@@ -194,7 +194,6 @@ public class Label extends Widget {
 				x += (int)((width - bounds.width) / 2);
 		}
 
-		cache.setColor(Color.WHITE);
 		if (wrap)
 			cache.setWrappedText(text, x, y, bounds.width, lineAlign);
 		else
@@ -251,13 +250,6 @@ public class Label extends Widget {
 		invalidateHierarchy();
 	}
 
-	/** Provide any additional characters that should act as break characters when the label is wrapped. By default, only whitespace
-	 * characters act as break chars. */
-	public void setBreakChars (char[] breakChars) {
-		cache.setBreakChars(breakChars);
-		invalidateHierarchy();
-	}
-
 	/** @param alignment Aligns each line of text horizontally and all the text vertically.
 	 * @see Align */
 	public void setAlignment (int alignment) {
@@ -310,9 +302,9 @@ public class Label extends Widget {
 		invalidateHierarchy();
 	}
 
-	/** When true the text will be truncated "..." if it does not fit within the width of the label. Default is false. */
-	public void setEllipsis (boolean ellipsis) {
-		this.ellipsis = ellipsis;
+	/** When true the text will be truncated with an ellipse if it does not fit within the width of the label. Default is false. */
+	public void setEllipse (boolean ellipse) {
+		this.ellipse = ellipse;
 	}
 
 	/** Allows subclasses to access the cache in {@link #draw(Batch, float)}. */
@@ -320,10 +312,6 @@ public class Label extends Widget {
 		return cache;
 	}
 
-	public String toString () {
-		return super.toString() + ": " + text;
-	}
-
 	/** The style for a label, see {@link Label}.
 	 * @author Nathan Sweet */
 	static public class LabelStyle {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/List.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/List.java
index 3cdb2e3..78678c4 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/List.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/List.java
@@ -213,7 +213,7 @@ public class List<T> extends Widget implements Cullable {
 		if (oldPrefWidth != getPrefWidth() || oldPrefHeight != getPrefHeight()) invalidateHierarchy();
 	}
 
-	/** Sets the items visible in the list, clearing the selection if it is no longer valid. If a selection is
+	/** Sets the current items, clearing the selection if it is no longer valid. If a selection is
 	 * {@link ArraySelection#getRequired()}, the first item is selected. */
 	public void setItems (Array newItems) {
 		if (newItems == null) throw new IllegalArgumentException("newItems cannot be null.");
@@ -234,7 +234,6 @@ public class List<T> extends Widget implements Cullable {
 		invalidateHierarchy();
 	}
 
-	/** Returns the internal items array. If modified, {@link #setItems(Array)} must be called to reflect the changes. */
 	public Array<T> getItems () {
 		return items;
 	}
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ProgressBar.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ProgressBar.java
index 3d9b816..24cfa91 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ProgressBar.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ProgressBar.java
@@ -24,7 +24,6 @@ import com.badlogic.gdx.graphics.g2d.NinePatch;
 import com.badlogic.gdx.graphics.g2d.TextureRegion;
 import com.badlogic.gdx.math.Interpolation;
 import com.badlogic.gdx.math.MathUtils;
-import com.badlogic.gdx.scenes.scene2d.Stage;
 import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener.ChangeEvent;
 import com.badlogic.gdx.scenes.scene2d.utils.Disableable;
 import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
@@ -99,11 +98,7 @@ public class ProgressBar extends Widget implements Disableable {
 	@Override
 	public void act (float delta) {
 		super.act(delta);
-		if (animateTime > 0) {
-			animateTime -= delta;
-			Stage stage = getStage();
-			if (stage != null && stage.getActionsRequestRendering()) Gdx.graphics.requestRendering();
-		}
+		animateTime -= delta;
 	}
 
 	@Override
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ScrollPane.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ScrollPane.java
index d69cd55..a4d2d23 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ScrollPane.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ScrollPane.java
@@ -16,7 +16,6 @@
 
 package com.badlogic.gdx.scenes.scene2d.ui;
 
-import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.g2d.Batch;
 import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
@@ -269,12 +268,10 @@ public class ScrollPane extends WidgetGroup {
 		super.act(delta);
 
 		boolean panning = flickScrollListener.getGestureDetector().isPanning();
-		boolean animating = false;
 
 		if (fadeAlpha > 0 && fadeScrollBars && !panning && !touchScrollH && !touchScrollV) {
 			fadeDelay -= delta;
 			if (fadeDelay <= 0) fadeAlpha = Math.max(0, fadeAlpha - delta);
-			animating = true;
 		}
 
 		if (flingTimer > 0) {
@@ -296,8 +293,6 @@ public class ScrollPane extends WidgetGroup {
 				velocityX = 0;
 				velocityY = 0;
 			}
-
-			animating = true;
 		}
 
 		if (smoothScrolling && flingTimer <= 0 && !touchScrollH && !touchScrollV && !panning) {
@@ -306,14 +301,12 @@ public class ScrollPane extends WidgetGroup {
 					visualScrollX(Math.min(amountX, visualAmountX + Math.max(200 * delta, (amountX - visualAmountX) * 7 * delta)));
 				else
 					visualScrollX(Math.max(amountX, visualAmountX - Math.max(200 * delta, (visualAmountX - amountX) * 7 * delta)));
-				animating = true;
 			}
 			if (visualAmountY != amountY) {
 				if (visualAmountY < amountY)
 					visualScrollY(Math.min(amountY, visualAmountY + Math.max(200 * delta, (amountY - visualAmountY) * 7 * delta)));
 				else
 					visualScrollY(Math.max(amountY, visualAmountY - Math.max(200 * delta, (visualAmountY - amountY) * 7 * delta)));
-				animating = true;
 			}
 		} else {
 			if (visualAmountX != amountX) visualScrollX(amountX);
@@ -327,14 +320,12 @@ public class ScrollPane extends WidgetGroup {
 					amountX += (overscrollSpeedMin + (overscrollSpeedMax - overscrollSpeedMin) * -amountX / overscrollDistance)
 						* delta;
 					if (amountX > 0) scrollX(0);
-					animating = true;
 				} else if (amountX > maxX) {
 					resetFade();
 					amountX -= (overscrollSpeedMin + (overscrollSpeedMax - overscrollSpeedMin) * -(maxX - amountX)
 						/ overscrollDistance)
 						* delta;
 					if (amountX < maxX) scrollX(maxX);
-					animating = true;
 				}
 			}
 			if (overscrollY && scrollY) {
@@ -343,22 +334,15 @@ public class ScrollPane extends WidgetGroup {
 					amountY += (overscrollSpeedMin + (overscrollSpeedMax - overscrollSpeedMin) * -amountY / overscrollDistance)
 						* delta;
 					if (amountY > 0) scrollY(0);
-					animating = true;
 				} else if (amountY > maxY) {
 					resetFade();
 					amountY -= (overscrollSpeedMin + (overscrollSpeedMax - overscrollSpeedMin) * -(maxY - amountY)
 						/ overscrollDistance)
 						* delta;
 					if (amountY < maxY) scrollY(maxY);
-					animating = true;
 				}
 			}
 		}
-
-		if (animating) {
-			Stage stage = getStage();
-			if (stage != null && stage.getActionsRequestRendering()) Gdx.graphics.requestRendering();
-		}
 	}
 
 	public void layout () {
@@ -426,10 +410,8 @@ public class ScrollPane extends WidgetGroup {
 
 		if (fade) {
 			// Make sure widget is drawn under fading scrollbars.
-			if (scrollX && scrollY) {
-				areaHeight -= scrollbarHeight;
-				areaWidth -= scrollbarWidth;
-			}
+			if (scrollX) areaHeight -= scrollbarHeight;
+			if (scrollY) areaWidth -= scrollbarWidth;
 		} else {
 			if (scrollbarsOnTop) {
 				// Make sure widget is drawn under non-fading scrollbars.
@@ -444,17 +426,15 @@ public class ScrollPane extends WidgetGroup {
 		}
 
 		// If the widget is smaller than the available space, make it take up the available space.
-		widgetWidth = disableX ? areaWidth : Math.max(areaWidth, widgetWidth);
-		widgetHeight = disableY ? areaHeight : Math.max(areaHeight, widgetHeight);
+		widgetWidth = disableX ? width : Math.max(areaWidth, widgetWidth);
+		widgetHeight = disableY ? height : Math.max(areaHeight, widgetHeight);
 
 		maxX = widgetWidth - areaWidth;
 		maxY = widgetHeight - areaHeight;
 		if (fade) {
 			// Make sure widget is drawn under fading scrollbars.
-			if (scrollX && scrollY) {
-				maxY -= scrollbarHeight;
-				maxX -= scrollbarWidth;
-			}
+			if (scrollX) maxY -= scrollbarHeight;
+			if (scrollY) maxX -= scrollbarWidth;
 		}
 		scrollX(MathUtils.clamp(amountX, 0, maxX));
 		scrollY(MathUtils.clamp(amountY, 0, maxY));
@@ -542,24 +522,15 @@ public class ScrollPane extends WidgetGroup {
 		else
 			y -= (int)(maxY - visualAmountY);
 
-		float x = widgetAreaBounds.x;
-		if (scrollX) x -= (int)visualAmountX;
-
-		if (!fadeScrollBars && scrollbarsOnTop) {
-			if (scrollX && hScrollOnBottom) {
-				float scrollbarHeight = 0;
-				if (style.hScrollKnob != null) scrollbarHeight = style.hScrollKnob.getMinHeight();
-				if (style.hScroll != null) scrollbarHeight = Math.max(scrollbarHeight, style.hScroll.getMinHeight());
-				y += scrollbarHeight;
-			}
-			if (scrollY && !vScrollOnRight) {
-				float scrollbarWidth = 0;
-				if (style.hScrollKnob != null) scrollbarWidth = style.hScrollKnob.getMinWidth();
-				if (style.hScroll != null) scrollbarWidth = Math.max(scrollbarWidth, style.hScroll.getMinWidth());
-				x += scrollbarWidth;
-			}
+		if (!fadeScrollBars && scrollbarsOnTop && scrollX) {
+			float scrollbarHeight = 0;
+			if (style.hScrollKnob != null) scrollbarHeight = style.hScrollKnob.getMinHeight();
+			if (style.hScroll != null) scrollbarHeight = Math.max(scrollbarHeight, style.hScroll.getMinHeight());
+			y += scrollbarHeight;
 		}
 
+		float x = widgetAreaBounds.x;
+		if (scrollX) x -= (int)visualAmountX;
 		widget.setPosition(x, y);
 
 		if (widget instanceof Cullable) {
@@ -627,12 +598,6 @@ public class ScrollPane extends WidgetGroup {
 		if (widget instanceof Layout) {
 			float width = ((Layout)widget).getPrefWidth();
 			if (style.background != null) width += style.background.getLeftWidth() + style.background.getRightWidth();
-			if (forceScrollY) {
-				float scrollbarWidth = 0;
-				if (style.vScrollKnob != null) scrollbarWidth = style.vScrollKnob.getMinWidth();
-				if (style.vScroll != null) scrollbarWidth = Math.max(scrollbarWidth, style.vScroll.getMinWidth());
-				width += scrollbarWidth;
-			}
 			return width;
 		}
 		return 150;
@@ -642,12 +607,6 @@ public class ScrollPane extends WidgetGroup {
 		if (widget instanceof Layout) {
 			float height = ((Layout)widget).getPrefHeight();
 			if (style.background != null) height += style.background.getTopHeight() + style.background.getBottomHeight();
-			if (forceScrollX) {
-				float scrollbarHeight = 0;
-				if (style.hScrollKnob != null) scrollbarHeight = style.hScrollKnob.getMinHeight();
-				if (style.hScroll != null) scrollbarHeight = Math.max(scrollbarHeight, style.hScroll.getMinHeight());
-				height += scrollbarHeight;
-			}
 			return height;
 		}
 		return 150;
@@ -815,28 +774,28 @@ public class ScrollPane extends WidgetGroup {
 	/** Sets the scroll offset so the specified rectangle is fully in view, if possible. Coordinates are in the scroll pane widget's
 	 * coordinate system. */
 	public void scrollTo (float x, float y, float width, float height) {
-		scrollTo(x, y, width, height, false, false);
+		float amountX = this.amountX;
+		if (x + width > amountX + areaWidth) amountX = x + width - areaWidth;
+		if (x < amountX) amountX = x;
+		scrollX(MathUtils.clamp(amountX, 0, maxX));
+
+		float amountY = this.amountY;
+		if (amountY > maxY - y - height + areaHeight) amountY = maxY - y - height + areaHeight;
+		if (amountY < maxY - y) amountY = maxY - y;
+		scrollY(MathUtils.clamp(amountY, 0, maxY));
 	}
 
-	/** Sets the scroll offset so the specified rectangle is fully in view, and optionally centered vertically and/or horizontally,
-	 * if possible. Coordinates are in the scroll pane widget's coordinate system. */
-	public void scrollTo (float x, float y, float width, float height, boolean centerHorizontal, boolean centerVertical) {
+	/** Sets the scroll offset so the specified rectangle is fully in view and centered vertically in the scroll pane, if possible.
+	 * Coordinates are in the scroll pane widget's coordinate system. */
+	public void scrollToCenter (float x, float y, float width, float height) {
 		float amountX = this.amountX;
-		if (centerHorizontal) {
-			amountX = x - areaWidth / 2 + width / 2;
-		} else {
-			if (x + width > amountX + areaWidth) amountX = x + width - areaWidth;
-			if (x < amountX) amountX = x;
-		}
+		if (x + width > amountX + areaWidth) amountX = x + width - areaWidth;
+		if (x < amountX) amountX = x;
 		scrollX(MathUtils.clamp(amountX, 0, maxX));
 
 		float amountY = this.amountY;
-		if (centerVertical) {
-			amountY = maxY - y + areaHeight / 2 - height / 2;
-		} else {
-			if (amountY > maxY - y - height + areaHeight) amountY = maxY - y - height + areaHeight;
-			if (amountY < maxY - y) amountY = maxY - y;
-		}
+		float centerY = maxY - y + areaHeight / 2 - height / 2;
+		if (amountY < centerY - areaHeight / 4 || amountY > centerY + areaHeight / 4) amountY = centerY;
 		scrollY(MathUtils.clamp(amountY, 0, maxY));
 	}
 
@@ -851,19 +810,11 @@ public class ScrollPane extends WidgetGroup {
 	}
 
 	public float getScrollBarHeight () {
-		if (!scrollX) return 0;
-		float height = 0;
-		if (style.hScrollKnob != null) height = style.hScrollKnob.getMinHeight();
-		if (style.hScroll != null) height = Math.max(height, style.hScroll.getMinHeight());
-		return height;
+		return style.hScrollKnob == null || !scrollX ? 0 : style.hScrollKnob.getMinHeight();
 	}
 
 	public float getScrollBarWidth () {
-		if (!scrollY) return 0;
-		float width = 0;
-		if (style.vScrollKnob != null) width = style.vScrollKnob.getMinWidth();
-		if (style.vScroll != null) width = Math.max(width, style.vScroll.getMinWidth());
-		return width;
+		return style.vScrollKnob == null || !scrollY ? 0 : style.vScrollKnob.getMinWidth();
 	}
 
 	/** Returns the width of the scrolled viewport. */
@@ -892,22 +843,6 @@ public class ScrollPane extends WidgetGroup {
 		disableY = y;
 	}
 
-	public boolean isLeftEdge () {
-		return !scrollX || amountX <= 0;
-	}
-
-	public boolean isRightEdge () {
-		return !scrollX || amountX >= maxX;
-	}
-
-	public boolean isTopEdge () {
-		return !scrollY || amountY <= 0;
-	}
-
-	public boolean isBottomEdge () {
-		return !scrollY || amountY >= maxY;
-	}
-
 	public boolean isDragging () {
 		return draggingPointer != -1;
 	}
@@ -1029,7 +964,7 @@ public class ScrollPane extends WidgetGroup {
 	}
 
 	public void drawDebug (ShapeRenderer shapes) {
-		shapes.flush();
+		drawDebugBounds(shapes);
 		applyTransform(shapes, computeTransform());
 		if (ScissorStack.pushScissors(scissorBounds)) {
 			drawDebugChildren(shapes);
@@ -1038,13 +973,6 @@ public class ScrollPane extends WidgetGroup {
 		resetTransform(shapes);
 	}
 
-	public String toString () {
-		if (widget == null)
-			return super.toString();
-		else
-			return super.toString() + ": " + widget.toString();
-	}
-
 	/** The style for a scroll pane, see {@link ScrollPane}.
 	 * @author mzechner
 	 * @author Nathan Sweet */
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SelectBox.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SelectBox.java
index 5e1da03..ab843e8 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SelectBox.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SelectBox.java
@@ -1,12 +1,12 @@
 /*******************************************************************************
  * Copyright 2011 See AUTHORS file.
- *
+ * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- *
+ * 
  *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * 
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -134,7 +134,7 @@ public class SelectBox<T> extends Widget implements Disableable {
 		if (oldPrefWidth != getPrefWidth()) invalidateHierarchy();
 	}
 
-	/** Sets the items visible in the select box. */
+	/** Set the backing Array that makes up the choices available in the SelectBox */
 	public void setItems (Array<T> newItems) {
 		if (newItems == null) throw new IllegalArgumentException("newItems cannot be null.");
 		float oldPrefWidth = getPrefWidth();
@@ -155,7 +155,8 @@ public class SelectBox<T> extends Widget implements Disableable {
 		invalidateHierarchy();
 	}
 
-	/** Returns the internal items array. If modified, {@link #setItems(Array)} must be called to reflect the changes. */
+	/** Retrieve the backing Array that makes up the chocies available in the SelectBox
+	 * @see SelectBox#setItems(Array) */
 	public Array<T> getItems () {
 		return items;
 	}
@@ -238,7 +239,7 @@ public class SelectBox<T> extends Widget implements Disableable {
 
 	/** Get the set of selected items, useful when multiple items are selected
 	 * @return a Selection object containing the selected elements */
-	public ArraySelection<T> getSelection () {
+	public Selection<T> getSelection () {
 		return selection;
 	}
 
@@ -403,7 +404,7 @@ public class SelectBox<T> extends Widget implements Disableable {
 			setSize(Math.max(getPrefWidth(), selectBox.getWidth()), height);
 
 			validate();
-			scrollTo(0, list.getHeight() - selectBox.getSelectedIndex() * itemHeight - itemHeight / 2, 0, 0, true, true);
+			scrollToCenter(0, list.getHeight() - selectBox.getSelectedIndex() * itemHeight - itemHeight / 2, 0, 0);
 			updateVisualScroll();
 
 			previousScrollFocus = null;
@@ -411,7 +412,6 @@ public class SelectBox<T> extends Widget implements Disableable {
 			if (actor != null && !actor.isDescendantOf(this)) previousScrollFocus = actor;
 			stage.setScrollFocus(this);
 
-			list.selection.set(selectBox.getSelected());
 			list.setTouchable(Touchable.enabled);
 			clearActions();
 			selectBox.onShow(this, below);
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Skin.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Skin.java
index 6646472..7ec8690 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Skin.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Skin.java
@@ -331,13 +331,30 @@ public class Skin implements Disposable {
 	/** Returns a tinted copy of a drawable found in the skin via {@link #getDrawable(String)}. */
 	public Drawable newDrawable (Drawable drawable, Color tint) {
 		Drawable newDrawable;
-		if (drawable instanceof TextureRegionDrawable)
-			newDrawable = ((TextureRegionDrawable)drawable).tint(tint);
-		else if (drawable instanceof NinePatchDrawable)
-			newDrawable = ((NinePatchDrawable)drawable).tint(tint);
-		else if (drawable instanceof SpriteDrawable)
-			newDrawable = ((SpriteDrawable)drawable).tint(tint);
-		else
+		if (drawable instanceof TextureRegionDrawable) {
+			TextureRegion region = ((TextureRegionDrawable)drawable).getRegion();
+			Sprite sprite;
+			if (region instanceof AtlasRegion)
+				sprite = new AtlasSprite((AtlasRegion)region);
+			else
+				sprite = new Sprite(region);
+			sprite.setColor(tint);
+			newDrawable = new SpriteDrawable(sprite);
+		} else if (drawable instanceof NinePatchDrawable) {
+			NinePatchDrawable patchDrawable = new NinePatchDrawable((NinePatchDrawable)drawable);
+			patchDrawable.setPatch(new NinePatch(patchDrawable.getPatch(), tint));
+			newDrawable = patchDrawable;
+		} else if (drawable instanceof SpriteDrawable) {
+			SpriteDrawable spriteDrawable = new SpriteDrawable((SpriteDrawable)drawable);
+			Sprite sprite = spriteDrawable.getSprite();
+			if (sprite instanceof AtlasSprite)
+				sprite = new AtlasSprite((AtlasSprite)sprite);
+			else
+				sprite = new Sprite(sprite);
+			sprite.setColor(tint);
+			spriteDrawable.setSprite(sprite);
+			newDrawable = spriteDrawable;
+		} else
 			throw new GdxRuntimeException("Unable to copy, unknown drawable type: " + drawable.getClass());
 
 		if (newDrawable instanceof BaseDrawable) {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Table.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Table.java
index 0896148..b84c4b9 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Table.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Table.java
@@ -84,6 +84,7 @@ public class Table extends WidgetGroup {
 		this.skin = skin;
 
 		cellDefaults = obtainCell();
+		cellDefaults.defaults();
 
 		setTransform(false);
 		setTouchable(Touchable.childrenOnly);
@@ -321,7 +322,7 @@ public class Table extends WidgetGroup {
 		padRight = backgroundRight;
 		align = Align.center;
 		debug(Debug.none);
-		cellDefaults.reset();
+		cellDefaults.defaults();
 		for (int i = 0, n = columnDefaults.size; i < n; i++) {
 			Cell columnCell = columnDefaults.get(i);
 			if (columnCell != null) cellPool.free(columnCell);
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextArea.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextArea.java
index 567a7c9..e81a395 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextArea.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextArea.java
@@ -192,8 +192,6 @@ public class TextArea extends TextField {
 
 	@Override
 	protected void sizeChanged () {
-		lastText = null; // Cause calculateOffsets to recalculate the line breaks.
-
 		// The number of lines showed must be updated whenever the height is updated
 		BitmapFont font = style.font;
 		Drawable background = style.background;
@@ -331,7 +329,7 @@ public class TextArea extends TextField {
 	protected boolean continueCursor (int index, int offset) {
 		int pos = calculateCurrentLineIndex(index + offset);
 		return super.continueCursor(index, offset)
-			&& (pos < 0 || pos >= linesBreak.size - 2 || (linesBreak.items[pos + 1] != index) || (linesBreak.items[pos + 1] == linesBreak.items[pos + 2]));
+			&& (pos < 0 || pos >= linesBreak.size || (linesBreak.items[pos + 1] != index) || (linesBreak.items[pos + 1] == linesBreak.items[pos + 2]));
 	}
 
 	public int getCursorLine () {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextButton.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextButton.java
index 07cf67c..0bac148 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextButton.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextButton.java
@@ -101,10 +101,6 @@ public class TextButton extends Button {
 		return label.getText();
 	}
 
-	public String toString () {
-		return super.toString() + ": " + label.getText();
-	}
-
 	/** The style for a text button, see {@link TextButton}.
 	 * @author Nathan Sweet */
 	static public class TextButtonStyle extends ButtonStyle {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextField.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextField.java
index 2fb173b..c69d654 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextField.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextField.java
@@ -1,957 +1,938 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.scenes.scene2d.ui;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.Input;
-import com.badlogic.gdx.Input.Keys;
-import com.badlogic.gdx.graphics.Color;
-import com.badlogic.gdx.graphics.g2d.Batch;
-import com.badlogic.gdx.graphics.g2d.BitmapFont;
-import com.badlogic.gdx.math.MathUtils;
-import com.badlogic.gdx.math.Vector2;
-import com.badlogic.gdx.scenes.scene2d.Actor;
-import com.badlogic.gdx.scenes.scene2d.Group;
-import com.badlogic.gdx.scenes.scene2d.InputEvent;
-import com.badlogic.gdx.scenes.scene2d.InputListener;
-import com.badlogic.gdx.scenes.scene2d.Stage;
-import com.badlogic.gdx.scenes.scene2d.utils.Align;
-import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
-import com.badlogic.gdx.scenes.scene2d.utils.Disableable;
-import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
-import com.badlogic.gdx.scenes.scene2d.utils.UIUtils;
-import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.Clipboard;
-import com.badlogic.gdx.utils.FloatArray;
-import com.badlogic.gdx.utils.TimeUtils;
-import com.badlogic.gdx.utils.Timer;
-import com.badlogic.gdx.utils.Timer.Task;
-
-/** A single-line text input field.
- * <p>
- * The preferred height of a text field is the height of the {@link TextFieldStyle#font} and {@link TextFieldStyle#background}.
- * The preferred width of a text field is 150, a relatively arbitrary size.
- * <p>
- * The text field will copy the currently selected text when ctrl+c is pressed, and paste any text in the clipboard when ctrl+v is
- * pressed. Clipboard functionality is provided via the {@link Clipboard} interface. Currently there are two standard
- * implementations, one for the desktop and one for Android. The Android clipboard is a stub, as copy & pasting on Android is not
- * supported yet.
- * <p>
- * The text field allows you to specify an {@link OnscreenKeyboard} for displaying a softkeyboard and piping all key events
- * generated by the keyboard to the text field. There are two standard implementations, one for the desktop and one for Android.
- * The desktop keyboard is a stub, as a softkeyboard is not needed on the desktop. The Android {@link OnscreenKeyboard}
- * implementation will bring up the default IME.
- * @author mzechner
- * @author Nathan Sweet */
-public class TextField extends Widget implements Disableable {
-	static private final char BACKSPACE = 8;
-	static protected final char ENTER_DESKTOP = '\r';
-	static protected final char ENTER_ANDROID = '\n';
-	static private final char TAB = '\t';
-	static private final char DELETE = 127;
-	static private final char BULLET = 149;
-
-	static private final Vector2 tmp1 = new Vector2();
-	static private final Vector2 tmp2 = new Vector2();
-	static private final Vector2 tmp3 = new Vector2();
-
-	static public float keyRepeatInitialTime = 0.4f;
-	static public float keyRepeatTime = 0.1f;
-
-	protected String text;
-	protected int cursor, selectionStart;
-	protected boolean hasSelection;
-	protected boolean writeEnters;
-	protected final FloatArray glyphAdvances = new FloatArray(), glyphPositions = new FloatArray();
-
-	TextFieldStyle style;
-	private String messageText;
-	protected CharSequence displayText;
-	private Clipboard clipboard;
-	InputListener inputListener;
-	TextFieldListener listener;
-	TextFieldFilter filter;
-	OnscreenKeyboard keyboard = new DefaultOnscreenKeyboard();
-	boolean focusTraversal = true, onlyFontChars = true, disabled;
-	private int textHAlign = Align.left;
-	private float selectionX, selectionWidth;
-
-	boolean passwordMode;
-	private StringBuilder passwordBuffer;
-	private char passwordCharacter = BULLET;
-
-	protected float textHeight, textOffset;
-	float renderOffset;
-	private int visibleTextStart, visibleTextEnd;
-	private int maxLength = 0;
-
-	private float blinkTime = 0.32f;
-	boolean cursorOn = true;
-	long lastBlink;
-
-	KeyRepeatTask keyRepeatTask = new KeyRepeatTask();
-	
-	public TextField (String text, Skin skin) {
-		this(text, skin.get(TextFieldStyle.class));
-	}
-
-	public TextField (String text, Skin skin, String styleName) {
-		this(text, skin.get(styleName, TextFieldStyle.class));
-	}
-
-	public TextField (String text, TextFieldStyle style) {
-		setStyle(style);
-		clipboard = Gdx.app.getClipboard();
-		initialize();
-		setText(text);
-		setSize(getPrefWidth(), getPrefHeight());
-	}
-
-	protected void initialize () {
-		writeEnters = false;
-		addListener(inputListener = createInputListener());
-	}
-
-	protected InputListener createInputListener () {
-		return new TextFieldClickListener();
-	}
-
-	protected int letterUnderCursor (float x) {
-		x -= renderOffset + textOffset;
-		int index = glyphPositions.size - 1;
-		float[] glyphPositions = this.glyphPositions.items;
-		for (int i = 0, n = this.glyphPositions.size; i < n; i++) {
-			if (glyphPositions[i] > x) {
-				index = i - 1;
-				break;
-			}
-		}
-		return Math.max(0, index);
-	}
-
-	protected boolean isWordCharacter (char c) {
-		return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9');
-	}
-
-	protected int[] wordUnderCursor (int at) {
-		String text = this.text;
-		int start = at, right = text.length(), left = 0, index = start;
-		for (; index < right; index++) {
-			if (!isWordCharacter(text.charAt(index))) {
-				right = index;
-				break;
-			}
-		}
-		for (index = start - 1; index > -1; index--) {
-			if (!isWordCharacter(text.charAt(index))) {
-				left = index + 1;
-				break;
-			}
-		}
-		return new int[] {left, right};
-	}
-
-	int[] wordUnderCursor (float x) {
-		return wordUnderCursor(letterUnderCursor(x));
-	}
-
-	boolean withinMaxLength (int size) {
-		return maxLength <= 0 || size < maxLength;
-	}
-
-	public void setMaxLength (int maxLength) {
-		this.maxLength = maxLength;
-	}
-
-	public int getMaxLength () {
-		return this.maxLength;
-	}
-
-	/** When false, text set by {@link #setText(String)} may contain characters not in the font, a space will be displayed instead.
-	 * When true (the default), characters not in the font are stripped by setText. Characters not in the font are always stripped
-	 * when typed or pasted. */
-	public void setOnlyFontChars (boolean onlyFontChars) {
-		this.onlyFontChars = onlyFontChars;
-	}
-
-	public void setStyle (TextFieldStyle style) {
-		if (style == null) throw new IllegalArgumentException("style cannot be null.");
-		this.style = style;
-		textHeight = style.font.getCapHeight() - style.font.getDescent() * 2;
-		invalidateHierarchy();
-	}
-
-	/** Returns the text field's style. Modifying the returned style may not have an effect until {@link #setStyle(TextFieldStyle)}
-	 * is called. */
-	public TextFieldStyle getStyle () {
-		return style;
-	}
-
-	protected void calculateOffsets () {
-		float visibleWidth = getWidth();
-		if (style.background != null) visibleWidth -= style.background.getLeftWidth() + style.background.getRightWidth();
-
-		// Check if the cursor has gone out the left or right side of the visible area and adjust renderoffset.
-		float position = glyphPositions.get(cursor);
-		float distance = position - Math.abs(renderOffset);
-		if (distance <= 0) {
-			if (cursor > 0)
-				renderOffset = -glyphPositions.get(cursor - 1);
-			else
-				renderOffset = 0;
-		} else if (distance > visibleWidth) {
-			renderOffset -= distance - visibleWidth;
-		}
-
-		// calculate first visible char based on render offset
-		visibleTextStart = 0;
-		textOffset = 0;
-		float start = Math.abs(renderOffset);
-		int glyphCount = glyphPositions.size;
-		float[] glyphPositions = this.glyphPositions.items;
-		float startPos = 0;
-		for (int i = 0; i < glyphCount; i++) {
-			if (glyphPositions[i] >= start) {
-				visibleTextStart = i;
-				startPos = glyphPositions[i];
-				textOffset = startPos - start;
-				break;
-			}
-		}
-
-		// calculate last visible char based on visible width and render offset
-		visibleTextEnd = Math.min(displayText.length(), cursor + 1);
-		for (; visibleTextEnd <= displayText.length(); visibleTextEnd++) {
-			if (glyphPositions[visibleTextEnd] - startPos > visibleWidth) break;
-		}
-		visibleTextEnd = Math.max(0, visibleTextEnd - 1);
-
-		// calculate selection x position and width
-		if (hasSelection) {
-			int minIndex = Math.min(cursor, selectionStart);
-			int maxIndex = Math.max(cursor, selectionStart);
-			float minX = Math.max(glyphPositions[minIndex], startPos);
-			float maxX = Math.min(glyphPositions[maxIndex], glyphPositions[visibleTextEnd]);
-			selectionX = minX;
-			selectionWidth = maxX - minX;
-		}
-
-		if (textHAlign == Align.center || textHAlign == Align.right) {
-			textOffset = visibleWidth - (glyphPositions[visibleTextEnd] - startPos);
-			if (textHAlign == Align.center) textOffset = Math.round(textOffset * 0.5f);
-			if (hasSelection) selectionX += textOffset;
-		}
-	}
-
-	@Override
-	public void draw (Batch batch, float parentAlpha) {
-		Stage stage = getStage();
-		boolean focused = stage != null && stage.getKeyboardFocus() == this;
-
-		final BitmapFont font = style.font;
-		final Color fontColor = (disabled && style.disabledFontColor != null) ? style.disabledFontColor
-			: ((focused && style.focusedFontColor != null) ? style.focusedFontColor : style.fontColor);
-		final Drawable selection = style.selection;
-		final Drawable cursorPatch = style.cursor;
-		final Drawable background = (disabled && style.disabledBackground != null) ? style.disabledBackground
-			: ((focused && style.focusedBackground != null) ? style.focusedBackground : style.background);
-
-		Color color = getColor();
-		float x = getX();
-		float y = getY();
-		float width = getWidth();
-		float height = getHeight();
-
-		batch.setColor(color.r, color.g, color.b, color.a * parentAlpha);
-		float bgLeftWidth = 0;
-		if (background != null) {
-			background.draw(batch, x, y, width, height);
-			bgLeftWidth = background.getLeftWidth();
-		}
-
-		float textY = getTextY(font, background);
-		calculateOffsets();
-
-		if (focused && hasSelection && selection != null) {
-			drawSelection(selection, batch, font, x + bgLeftWidth, y + textY);
-		}
-
-		float yOffset = font.isFlipped() ? -textHeight : 0;
-		if (displayText.length() == 0) {
-			if (!focused && messageText != null) {
-				if (style.messageFontColor != null) {
-					font.setColor(style.messageFontColor.r, style.messageFontColor.g, style.messageFontColor.b,
-						style.messageFontColor.a * parentAlpha);
-				} else
-					font.setColor(0.7f, 0.7f, 0.7f, parentAlpha);
-				BitmapFont messageFont = style.messageFont != null ? style.messageFont : font;
-				messageFont.draw(batch, messageText, x + bgLeftWidth, y + textY + yOffset);
-			}
-		} else {
-			font.setColor(fontColor.r, fontColor.g, fontColor.b, fontColor.a * parentAlpha);
-			drawText(batch, font, x + bgLeftWidth, y + textY + yOffset);
-		}
-		if (focused && !disabled) {
-			blink();
-			if (cursorOn && cursorPatch != null) {
-				drawCursor(cursorPatch, batch, font, x + bgLeftWidth, y + textY);
-			}
-		}
-	}
-
-	protected float getTextY (BitmapFont font, Drawable background) {
-		float height = getHeight();
-		float textY = textHeight / 2 + font.getDescent();
-		if (background != null) {
-			float bottom = background.getBottomHeight();
-			textY = (int)(textY + (height - background.getTopHeight() - bottom) / 2 + bottom);
-		} else {
-			textY = (int)(textY + height / 2);
-		}
-		return textY;
-	}
-
-	/** Draws selection rectangle **/
-	protected void drawSelection (Drawable selection, Batch batch, BitmapFont font, float x, float y) {
-		selection.draw(batch, x + selectionX + renderOffset, y - textHeight - font.getDescent(), selectionWidth,
-			textHeight + font.getDescent() / 2);
-	}
-
-	protected void drawText (Batch batch, BitmapFont font, float x, float y) {
-		font.draw(batch, displayText, x + textOffset, y, visibleTextStart, visibleTextEnd);
-	}
-
-	protected void drawCursor (Drawable cursorPatch, Batch batch, BitmapFont font, float x, float y) {
-		cursorPatch.draw(batch, x + textOffset + glyphPositions.get(cursor) - glyphPositions.items[visibleTextStart] - 1, y
-			- textHeight - font.getDescent(), cursorPatch.getMinWidth(), textHeight + font.getDescent() / 2);
-	}
-
-	void updateDisplayText () {
-		BitmapFont font = style.font;
-		String text = this.text;
-		int textLength = text.length();
-
-		StringBuilder buffer = new StringBuilder();
-		for (int i = 0; i < textLength; i++) {
-			char c = text.charAt(i);
-			buffer.append(font.containsCharacter(c) ? c : ' ');
-		}
-		String newDisplayText = buffer.toString();
-
-		if (passwordMode && font.containsCharacter(passwordCharacter)) {
-			if (passwordBuffer == null) passwordBuffer = new StringBuilder(newDisplayText.length());
-			if (passwordBuffer.length() > textLength)
-				passwordBuffer.setLength(textLength);
-			else {
-				for (int i = passwordBuffer.length(); i < textLength; i++)
-					passwordBuffer.append(passwordCharacter);
-			}
-			displayText = passwordBuffer;
-		} else
-			displayText = newDisplayText;
-		font.computeGlyphAdvancesAndPositions(displayText, glyphAdvances, glyphPositions);
-		if (selectionStart > newDisplayText.length()) selectionStart = textLength;
-	}
-
-	private void blink () {
-		if (!Gdx.graphics.isContinuousRendering()) {
-			cursorOn = true;
-			return;
-		}
-		long time = TimeUtils.nanoTime();
-		if ((time - lastBlink) / 1000000000.0f > blinkTime) {
-			cursorOn = !cursorOn;
-			lastBlink = time;
-		}
-	}
-
-	/** Copies the contents of this TextField to the {@link Clipboard} implementation set on this TextField. */
-	public void copy () {
-		if (hasSelection && !passwordMode) {
-			clipboard.setContents(text.substring(Math.min(cursor, selectionStart), Math.max(cursor, selectionStart)));
-		}
-	}
-
-	/** Copies the selected contents of this TextField to the {@link Clipboard} implementation set on this TextField, then removes
-	 * it. */
-	public void cut () {
-		if (hasSelection && !passwordMode) {
-			copy();
-			cursor = delete();
-		}
-	}
-
-	/** Pastes the content of the {@link Clipboard} implementation set on this Textfield to this TextField. */
-	void paste () {
-		paste(clipboard.getContents(), true);
-	}
-
-	void paste (String content, boolean onlyFontChars) {
-		if (content == null) return;
-		StringBuilder buffer = new StringBuilder();
-		int textLength = text.length();
-		for (int i = 0, n = content.length(); i < n; i++) {
-			if (!withinMaxLength(textLength + buffer.length())) break;
-			char c = content.charAt(i);
-			if (!(writeEnters && (c == ENTER_ANDROID || c == ENTER_DESKTOP))) {
-				if (onlyFontChars && !style.font.containsCharacter(c)) continue;
-				if (filter != null && !filter.acceptChar(this, c)) continue;
-			}
-			buffer.append(c);
-		}
-		content = buffer.toString();
-
-		if (hasSelection) cursor = delete(false);
-		text = insert(cursor, content, text);
-		updateDisplayText();
-		cursor += content.length();
-	}
-
-	String insert (int position, CharSequence text, String to) {
-		if (to.length() == 0) return text.toString();
-		return to.substring(0, position) + text + to.substring(position, to.length());
-	}
-
-	int delete () {
-		return delete(true);
-	}
-
-	int delete (boolean updateText) {
-		return delete(selectionStart, cursor, updateText);
-	}
-
-	int delete (int from, int to, boolean updateText) {
-		int minIndex = Math.min(from, to);
-		int maxIndex = Math.max(from, to);
-		text = (minIndex > 0 ? text.substring(0, minIndex) : "")
-			+ (maxIndex < text.length() ? text.substring(maxIndex, text.length()) : "");
-		if (updateText) updateDisplayText();
-		clearSelection();
-		return minIndex;
-	}
-
-	/** Focuses the next TextField. If none is found, the keyboard is hidden. Does nothing if the text field is not in a stage.
-	 * @param up If true, the TextField with the same or next smallest y coordinate is found, else the next highest. */
-	public void next (boolean up) {
-		Stage stage = getStage();
-		if (stage == null) return;
-		getParent().localToStageCoordinates(tmp1.set(getX(), getY()));
-		TextField textField = findNextTextField(stage.getActors(), null, tmp2, tmp1, up);
-		if (textField == null) { // Try to wrap around.
-			if (up)
-				tmp1.set(Float.MIN_VALUE, Float.MIN_VALUE);
-			else
-				tmp1.set(Float.MAX_VALUE, Float.MAX_VALUE);
-			textField = findNextTextField(getStage().getActors(), null, tmp2, tmp1, up);
-		}
-		if (textField != null)
-			stage.setKeyboardFocus(textField);
-		else
-			Gdx.input.setOnscreenKeyboardVisible(false);
-	}
-
-	private TextField findNextTextField (Array<Actor> actors, TextField best, Vector2 bestCoords, Vector2 currentCoords, boolean up) {
-		for (int i = 0, n = actors.size; i < n; i++) {
-			Actor actor = actors.get(i);
-			if (actor == this) continue;
-			if (actor instanceof TextField) {
-				TextField textField = (TextField)actor;
-				if (textField.isDisabled() || !textField.focusTraversal) continue;
-				Vector2 actorCoords = actor.getParent().localToStageCoordinates(tmp3.set(actor.getX(), actor.getY()));
-				if ((actorCoords.y < currentCoords.y || (actorCoords.y == currentCoords.y && actorCoords.x > currentCoords.x)) ^ up) {
-					if (best == null
-						|| (actorCoords.y > bestCoords.y || (actorCoords.y == bestCoords.y && actorCoords.x < bestCoords.x)) ^ up) {
-						best = (TextField)actor;
-						bestCoords.set(actorCoords);
-					}
-				}
-			} else if (actor instanceof Group)
-				best = findNextTextField(((Group)actor).getChildren(), best, bestCoords, currentCoords, up);
-		}
-		return best;
-	}
-
-	public InputListener getDefaultInputListener () {
-		return inputListener;
-	}
-
-	/** @param listener May be null. */
-	public void setTextFieldListener (TextFieldListener listener) {
-		this.listener = listener;
-	}
-
-	/** @param filter May be null. */
-	public void setTextFieldFilter (TextFieldFilter filter) {
-		this.filter = filter;
-	}
-
-	public TextFieldFilter getTextFieldFilter () {
-		return filter;
-	}
-
-	/** If true (the default), tab/shift+tab will move to the next text field. */
-	public void setFocusTraversal (boolean focusTraversal) {
-		this.focusTraversal = focusTraversal;
-	}
-
-	/** @return May be null. */
-	public String getMessageText () {
-		return messageText;
-	}
-
-	/** Sets the text that will be drawn in the text field if no text has been entered.
-	 * @param messageText may be null. */
-	public void setMessageText (String messageText) {
-		this.messageText = messageText;
-	}
-
-	public void appendText (String str) {
-		if (str == null) throw new IllegalArgumentException("text cannot be null.");
-
-		clearSelection();
-		cursor = text.length();
-		paste(str, onlyFontChars);
-	}
-
-	public void setText (String str) {
-		if (str == null) throw new IllegalArgumentException("text cannot be null.");
-		if (str.equals(text)) return;
-
-		clearSelection();
-		text = "";
-		paste(str, onlyFontChars);
-		cursor = 0;
-	}
-
-	/** @return Never null, might be an empty string. */
-	public String getText () {
-		return text;
-	}
-
-	public int getSelectionStart () {
-		return selectionStart;
-	}
-
-	public String getSelection () {
-		return hasSelection ? text.substring(Math.min(selectionStart, cursor), Math.max(selectionStart, cursor)) : "";
-	}
-
-	/** Sets the selected text. */
-	public void setSelection (int selectionStart, int selectionEnd) {
-		if (selectionStart < 0) throw new IllegalArgumentException("selectionStart must be >= 0");
-		if (selectionEnd < 0) throw new IllegalArgumentException("selectionEnd must be >= 0");
-		selectionStart = Math.min(text.length(), selectionStart);
-		selectionEnd = Math.min(text.length(), selectionEnd);
-		if (selectionEnd == selectionStart) {
-			clearSelection();
-			return;
-		}
-		if (selectionEnd < selectionStart) {
-			int temp = selectionEnd;
-			selectionEnd = selectionStart;
-			selectionStart = temp;
-		}
-
-		hasSelection = true;
-		this.selectionStart = selectionStart;
-		cursor = selectionEnd;
-	}
-
-	public void selectAll () {
-		setSelection(0, text.length());
-	}
-
-	public void clearSelection () {
-		hasSelection = false;
-	}
-
-	/** Sets the cursor position and clears any selection. */
-	public void setCursorPosition (int cursorPosition) {
-		if (cursorPosition < 0) throw new IllegalArgumentException("cursorPosition must be >= 0");
-		clearSelection();
-		cursor = Math.min(cursorPosition, text.length());
-	}
-
-	public int getCursorPosition () {
-		return cursor;
-	}
-
-	/** Default is an instance of {@link DefaultOnscreenKeyboard}. */
-	public OnscreenKeyboard getOnscreenKeyboard () {
-		return keyboard;
-	}
-
-	public void setOnscreenKeyboard (OnscreenKeyboard keyboard) {
-		this.keyboard = keyboard;
-	}
-
-	public void setClipboard (Clipboard clipboard) {
-		this.clipboard = clipboard;
-	}
-
-	public float getPrefWidth () {
-		return 150;
-	}
-
-	public float getPrefHeight () {
-		float prefHeight = textHeight;
-		if (style.background != null) {
-			prefHeight = Math.max(prefHeight + style.background.getBottomHeight() + style.background.getTopHeight(),
-				style.background.getMinHeight());
-		}
-		return prefHeight;
-	}
-
-	/** Sets text horizontal alignment (left, center or right). */
-	public void setAlignment (int alignment) {
-		if (alignment == Align.left || alignment == Align.center || alignment == Align.right) 
-			this.textHAlign = alignment;
-	}
-
-	/** If true, the text in this text field will be shown as bullet characters.
-	 * @see #setPasswordCharacter(char) */
-	public void setPasswordMode (boolean passwordMode) {
-		this.passwordMode = passwordMode;
-		updateDisplayText();
-	}
-
-	public boolean isPasswordMode () {
-		return passwordMode;
-	}
-
-	/** Sets the password character for the text field. The character must be present in the {@link BitmapFont}. Default is 149
-	 * (bullet). */
-	public void setPasswordCharacter (char passwordCharacter) {
-		this.passwordCharacter = passwordCharacter;
-		if (passwordMode) updateDisplayText();
-	}
-
-	public void setBlinkTime (float blinkTime) {
-		this.blinkTime = blinkTime;
-	}
-
-	public void setDisabled (boolean disabled) {
-		this.disabled = disabled;
-	}
-
-	public boolean isDisabled () {
-		return disabled;
-	}
-
-	protected void moveCursor (boolean forward, boolean jump) {
-		int limit = forward ? text.length() : 0;
-		int charOffset = forward ? 0 : -1;
-		while ((forward ? ++cursor < limit : --cursor > limit) && jump) {
-			if (!continueCursor(cursor, charOffset)) break;
-		}
-	}
-
-	protected boolean continueCursor (int index, int offset) {
-		char c = text.charAt(index + offset);
-		return isWordCharacter(c);
-	}
-
-	class KeyRepeatTask extends Task {
-		int keycode;
-
-		public void run () {
-			inputListener.keyDown(null, keycode);
-		}
-	}
-
-	/** Interface for listening to typed characters.
-	 * @author mzechner */
-	static public interface TextFieldListener {
-		public void keyTyped (TextField textField, char c);
-	}
-
-	/** Interface for filtering characters entered into the text field.
-	 * @author mzechner */
-	static public interface TextFieldFilter {
-		public boolean acceptChar (TextField textField, char c);
-
-		static public class DigitsOnlyFilter implements TextFieldFilter {
-			@Override
-			public boolean acceptChar (TextField textField, char c) {
-				return Character.isDigit(c);
-			}
-
-		}
-	}
-
-	/** An interface for onscreen keyboards. Can invoke the default keyboard or render your own keyboard!
-	 * @author mzechner */
-	static public interface OnscreenKeyboard {
-		public void show (boolean visible);
-	}
-
-	/** The default {@link OnscreenKeyboard} used by all {@link TextField} instances. Just uses
-	 * {@link Input#setOnscreenKeyboardVisible(boolean)} as appropriate. Might overlap your actual rendering, so use with care!
-	 * @author mzechner */
-	static public class DefaultOnscreenKeyboard implements OnscreenKeyboard {
-		@Override
-		public void show (boolean visible) {
-			Gdx.input.setOnscreenKeyboardVisible(visible);
-		}
-	}
-
-	/** Basic input listener for the text field */
-	public class TextFieldClickListener extends ClickListener {
-		public void clicked (InputEvent event, float x, float y) {
-			int count = getTapCount() % 4;
-			if (count == 0) clearSelection();
-			if (count == 2) {
-				int[] array = wordUnderCursor(x);
-				setSelection(array[0], array[1]);
-			}
-			if (count == 3) selectAll();
-		}
-
-		public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
-			if (!super.touchDown(event, x, y, pointer, button)) return false;
-			if (pointer == 0 && button != 0) return false;
-			if (disabled) return true;
-			setCursorPosition(x, y);
-			selectionStart = cursor;
-			Stage stage = getStage();
-			if (stage != null) stage.setKeyboardFocus(TextField.this);
-			keyboard.show(true);
-			hasSelection = true;
-			return true;
-		}
-
-		public void touchDragged (InputEvent event, float x, float y, int pointer) {
-			super.touchDragged(event, x, y, pointer);
-			setCursorPosition(x, y);
-		}
-
-		public void touchUp (InputEvent event, float x, float y, int pointer, int button) {
-			if (selectionStart == cursor) hasSelection = false;
-			super.touchUp(event, x, y, pointer, button);
-		}
-
-		protected void setCursorPosition (float x, float y) {
-			lastBlink = 0;
-			cursorOn = false;
-			cursor = letterUnderCursor(x);
-		}
-
-		protected void goHome (boolean jump) {
-			cursor = 0;
-		}
-
-		protected void goEnd (boolean jump) {
-			cursor = text.length();
-		}
-
-		public boolean keyDown (InputEvent event, int keycode) {
-			if (disabled) return false;
-
-			lastBlink = 0;
-			cursorOn = false;
-
-			Stage stage = getStage();
-			if (stage == null || stage.getKeyboardFocus() != TextField.this) return false;
-
-			boolean repeat = false;
-			boolean ctrl = UIUtils.ctrl();
-			boolean jump = ctrl && !passwordMode;
-
-			if (ctrl) {
-				if (keycode == Keys.V) {
-					paste();
-					repeat = true;
-				}
-				if (keycode == Keys.C || keycode == Keys.INSERT) {
-					copy();
-					return true;
-				}
-				if (keycode == Keys.X || keycode == Keys.DEL) {
-					cut();
-					return true;
-				}
-				if (keycode == Keys.A) {
-					selectAll();
-					return true;
-				}
-			}
-
-			if (UIUtils.shift()) {
-				if (keycode == Keys.INSERT) paste();
-				if (keycode == Keys.FORWARD_DEL && hasSelection) {
-					copy();
-					delete(); // cut
-				}
-				selection:
-				{
-					int temp = cursor;
-					keys:
-					{
-						if (keycode == Keys.LEFT) {
-							moveCursor(false, jump);
-							repeat = true;
-							break keys;
-						}
-						if (keycode == Keys.RIGHT) {
-							moveCursor(true, jump);
-							repeat = true;
-							break keys;
-						}
-						if (keycode == Keys.HOME) {
-							goHome(jump);
-							break keys;
-						}
-						if (keycode == Keys.END) {
-							goEnd(jump);
-							break keys;
-						}
-						break selection;
-					}
-					if (!hasSelection) {
-						selectionStart = temp;
-						hasSelection = true;
-					}
-				}
-			} else {
-				// Cursor movement or other keys (kills selection).
-				if (keycode == Keys.LEFT) {
-					moveCursor(false, jump);
-					clearSelection();
-					repeat = true;
-				}
-				if (keycode == Keys.RIGHT) {
-					moveCursor(true, jump);
-					clearSelection();
-					repeat = true;
-				}
-				if (keycode == Keys.HOME) {
-					goHome(jump);
-					clearSelection();
-				}
-				if (keycode == Keys.END) {
-					goEnd(jump);
-					clearSelection();
-				}
-			}
-			cursor = MathUtils.clamp(cursor, 0, text.length());
-
-			if (repeat) {
-				scheduleKeyRepeatTask(keycode);
-			}
-			return true;
-		}
-
-		protected void scheduleKeyRepeatTask (int keycode) {
-			if (!keyRepeatTask.isScheduled() || keyRepeatTask.keycode != keycode) {
-				keyRepeatTask.keycode = keycode;
-				keyRepeatTask.cancel();
-				Timer.schedule(keyRepeatTask, keyRepeatInitialTime, keyRepeatTime);
-			}
-		}
-
-		public boolean keyUp (InputEvent event, int keycode) {
-			if (disabled) return false;
-			keyRepeatTask.cancel();
-			return true;
-		}
-
-		public boolean keyTyped (InputEvent event, char character) {
-			if (disabled) return false;
-			if (character == 0) return false;
-
-			Stage stage = getStage();
-			if (stage == null || stage.getKeyboardFocus() != TextField.this) return false;
-
-			if ((character == TAB || character == ENTER_ANDROID) && focusTraversal) {
-				next(UIUtils.shift());
-			} else {
-				boolean delete = character == DELETE;
-				boolean backspace = character == BACKSPACE;
-				boolean add = style.font.containsCharacter(character)
-					|| (writeEnters && (character == ENTER_ANDROID || character == ENTER_DESKTOP));
-				boolean remove = backspace || delete;
-				if (add || remove) {
-					if (hasSelection)
-						cursor = delete(false);
-					else {
-						if (backspace && cursor > 0) {
-							text = text.substring(0, cursor - 1) + text.substring(cursor--);
-							renderOffset = 0;
-						}
-						if (delete && cursor < text.length()) {
-							text = text.substring(0, cursor) + text.substring(cursor + 1);
-						}
-					}
-					if (add && !remove) {
-						// Character may be added to the text.
-						boolean isEnter = character == ENTER_DESKTOP || character == ENTER_ANDROID;
-						if (!isEnter) {
-							if (filter != null && !filter.acceptChar(TextField.this, character)) return true;
-						}
-						if (!withinMaxLength(text.length())) return true;
-						String insertion = isEnter ? "\n" : String.valueOf(character);
-						text = insert(cursor++, insertion, text);
-					}
-					updateDisplayText();
-				}
-			}
-			if (listener != null) listener.keyTyped(TextField.this, character);
-			return true;
-		}
-	}
-
-	/** The style for a text field, see {@link TextField}.
-	 * @author mzechner
-	 * @author Nathan Sweet */
-	static public class TextFieldStyle {
-		public BitmapFont font;
-		public Color fontColor;
-		/** Optional. */
-		public Color focusedFontColor, disabledFontColor;
-		/** Optional. */
-		public Drawable background, focusedBackground, disabledBackground, cursor, selection;
-		/** Optional. */
-		public BitmapFont messageFont;
-		/** Optional. */
-		public Color messageFontColor;
-
-		public TextFieldStyle () {
-		}
-
-		public TextFieldStyle (BitmapFont font, Color fontColor, Drawable cursor, Drawable selection, Drawable background) {
-			this.background = background;
-			this.cursor = cursor;
-			this.font = font;
-			this.fontColor = fontColor;
-			this.selection = selection;
-		}
-
-		public TextFieldStyle (TextFieldStyle style) {
-			this.messageFont = style.messageFont;
-			if (style.messageFontColor != null) this.messageFontColor = new Color(style.messageFontColor);
-			this.background = style.background;
-			this.focusedBackground = style.focusedBackground;
-			this.disabledBackground = style.disabledBackground;
-			this.cursor = style.cursor;
-			this.font = style.font;
-			if (style.fontColor != null) this.fontColor = new Color(style.fontColor);
-			if (style.focusedFontColor != null) this.focusedFontColor = new Color(style.focusedFontColor);
-			if (style.disabledFontColor != null) this.disabledFontColor = new Color(style.disabledFontColor);
-			this.selection = style.selection;
-		}
-	}
-}
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.scenes.scene2d.ui;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.Input;
+import com.badlogic.gdx.Input.Keys;
+import com.badlogic.gdx.graphics.Color;
+import com.badlogic.gdx.graphics.g2d.Batch;
+import com.badlogic.gdx.graphics.g2d.BitmapFont;
+import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.math.Vector2;
+import com.badlogic.gdx.scenes.scene2d.Actor;
+import com.badlogic.gdx.scenes.scene2d.Group;
+import com.badlogic.gdx.scenes.scene2d.InputEvent;
+import com.badlogic.gdx.scenes.scene2d.InputListener;
+import com.badlogic.gdx.scenes.scene2d.Stage;
+import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
+import com.badlogic.gdx.scenes.scene2d.utils.Disableable;
+import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
+import com.badlogic.gdx.scenes.scene2d.utils.UIUtils;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.Clipboard;
+import com.badlogic.gdx.utils.FloatArray;
+import com.badlogic.gdx.utils.TimeUtils;
+import com.badlogic.gdx.utils.Timer;
+import com.badlogic.gdx.utils.Timer.Task;
+
+/** A single-line text input field.
+ * <p>
+ * The preferred height of a text field is the height of the {@link TextFieldStyle#font} and {@link TextFieldStyle#background}.
+ * The preferred width of a text field is 150, a relatively arbitrary size.
+ * <p>
+ * The text field will copy the currently selected text when ctrl+c is pressed, and paste any text in the clipboard when ctrl+v is
+ * pressed. Clipboard functionality is provided via the {@link Clipboard} interface. Currently there are two standard
+ * implementations, one for the desktop and one for Android. The Android clipboard is a stub, as copy & pasting on Android is not
+ * supported yet.
+ * <p>
+ * The text field allows you to specify an {@link OnscreenKeyboard} for displaying a softkeyboard and piping all key events
+ * generated by the keyboard to the text field. There are two standard implementations, one for the desktop and one for Android.
+ * The desktop keyboard is a stub, as a softkeyboard is not needed on the desktop. The Android {@link OnscreenKeyboard}
+ * implementation will bring up the default IME.
+ * @author mzechner
+ * @author Nathan Sweet */
+public class TextField extends Widget implements Disableable {
+	static private final char BACKSPACE = 8;
+	static protected final char ENTER_DESKTOP = '\r';
+	static protected final char ENTER_ANDROID = '\n';
+	static private final char TAB = '\t';
+	static private final char DELETE = 127;
+	static private final char BULLET = 149;
+
+	static private final Vector2 tmp1 = new Vector2();
+	static private final Vector2 tmp2 = new Vector2();
+	static private final Vector2 tmp3 = new Vector2();
+
+	protected String text;
+	protected int cursor, selectionStart;
+	protected boolean hasSelection;
+	protected boolean writeEnters;
+	protected final FloatArray glyphAdvances = new FloatArray(), glyphPositions = new FloatArray();
+
+	TextFieldStyle style;
+	private String messageText;
+	protected CharSequence displayText;
+	private Clipboard clipboard;
+	InputListener inputListener;
+	TextFieldListener listener;
+	TextFieldFilter filter;
+	OnscreenKeyboard keyboard = new DefaultOnscreenKeyboard();
+	boolean focusTraversal = true, onlyFontChars = true, disabled, rightAligned;
+	private float selectionX, selectionWidth;
+
+	boolean passwordMode;
+	private StringBuilder passwordBuffer;
+	private char passwordCharacter = BULLET;
+
+	protected float textHeight, textOffset;
+	float renderOffset;
+	private int visibleTextStart, visibleTextEnd;
+	private int maxLength = 0;
+
+	private float blinkTime = 0.32f;
+	boolean cursorOn = true;
+	long lastBlink;
+
+	KeyRepeatTask keyRepeatTask = new KeyRepeatTask();
+	float keyRepeatInitialTime = 0.4f;
+	float keyRepeatTime = 0.1f;
+
+	public TextField (String text, Skin skin) {
+		this(text, skin.get(TextFieldStyle.class));
+	}
+
+	public TextField (String text, Skin skin, String styleName) {
+		this(text, skin.get(styleName, TextFieldStyle.class));
+	}
+
+	public TextField (String text, TextFieldStyle style) {
+		setStyle(style);
+		clipboard = Gdx.app.getClipboard();
+		initialize();
+		setText(text);
+		setSize(getPrefWidth(), getPrefHeight());
+	}
+
+	protected void initialize () {
+		writeEnters = false;
+		addListener(inputListener = createInputListener());
+	}
+
+	protected InputListener createInputListener () {
+		return new TextFieldClickListener();
+	}
+
+	protected int letterUnderCursor (float x) {
+		x -= renderOffset + textOffset;
+		int index = glyphPositions.size - 1;
+		float[] glyphPositions = this.glyphPositions.items;
+		for (int i = 0, n = this.glyphPositions.size; i < n; i++) {
+			if (glyphPositions[i] > x) {
+				index = i - 1;
+				break;
+			}
+		}
+		return Math.max(0, index);
+	}
+
+	protected boolean isWordCharacter (char c) {
+		return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9');
+	}
+
+	protected int[] wordUnderCursor (int at) {
+		String text = this.text;
+		int start = at, right = text.length(), left = 0, index = start;
+		for (; index < right; index++) {
+			if (!isWordCharacter(text.charAt(index))) {
+				right = index;
+				break;
+			}
+		}
+		for (index = start - 1; index > -1; index--) {
+			if (!isWordCharacter(text.charAt(index))) {
+				left = index + 1;
+				break;
+			}
+		}
+		return new int[] {left, right};
+	}
+
+	int[] wordUnderCursor (float x) {
+		return wordUnderCursor(letterUnderCursor(x));
+	}
+
+	boolean withinMaxLength (int size) {
+		return maxLength <= 0 || size < maxLength;
+	}
+
+	public void setMaxLength (int maxLength) {
+		this.maxLength = maxLength;
+	}
+
+	public int getMaxLength () {
+		return this.maxLength;
+	}
+
+	/** When false, text set by {@link #setText(String)} may contain characters not in the font, a space will be displayed instead.
+	 * When true (the default), characters not in the font are stripped by setText. Characters not in the font are always stripped
+	 * when typed or pasted. */
+	public void setOnlyFontChars (boolean onlyFontChars) {
+		this.onlyFontChars = onlyFontChars;
+	}
+
+	public void setStyle (TextFieldStyle style) {
+		if (style == null) throw new IllegalArgumentException("style cannot be null.");
+		this.style = style;
+		textHeight = style.font.getCapHeight() - style.font.getDescent() * 2;
+		invalidateHierarchy();
+	}
+
+	/** Returns the text field's style. Modifying the returned style may not have an effect until {@link #setStyle(TextFieldStyle)}
+	 * is called. */
+	public TextFieldStyle getStyle () {
+		return style;
+	}
+
+	protected void calculateOffsets () {
+		float visibleWidth = getWidth();
+		if (style.background != null) visibleWidth -= style.background.getLeftWidth() + style.background.getRightWidth();
+
+		// Check if the cursor has gone out the left or right side of the visible area and adjust renderoffset.
+		float position = glyphPositions.get(cursor);
+		float distance = position - Math.abs(renderOffset);
+		if (distance <= 0) {
+			if (cursor > 0)
+				renderOffset = -glyphPositions.get(cursor - 1);
+			else
+				renderOffset = 0;
+		} else if (distance > visibleWidth) {
+			renderOffset -= distance - visibleWidth;
+		}
+
+		// calculate first visible char based on render offset
+		visibleTextStart = 0;
+		textOffset = 0;
+		float start = Math.abs(renderOffset);
+		int glyphCount = glyphPositions.size;
+		float[] glyphPositions = this.glyphPositions.items;
+		float startPos = 0;
+		for (int i = 0; i < glyphCount; i++) {
+			if (glyphPositions[i] >= start) {
+				visibleTextStart = i;
+				startPos = glyphPositions[i];
+				textOffset = startPos - start;
+				break;
+			}
+		}
+
+		// calculate last visible char based on visible width and render offset
+		visibleTextEnd = Math.min(displayText.length(), cursor + 1);
+		for (; visibleTextEnd <= displayText.length(); visibleTextEnd++) {
+			if (glyphPositions[visibleTextEnd] - startPos > visibleWidth) break;
+		}
+		visibleTextEnd = Math.max(0, visibleTextEnd - 1);
+
+		// calculate selection x position and width
+		if (hasSelection) {
+			int minIndex = Math.min(cursor, selectionStart);
+			int maxIndex = Math.max(cursor, selectionStart);
+			float minX = Math.max(glyphPositions[minIndex], startPos);
+			float maxX = Math.min(glyphPositions[maxIndex], glyphPositions[visibleTextEnd]);
+			selectionX = minX;
+			selectionWidth = maxX - minX;
+		}
+
+		if (rightAligned) {
+			textOffset = visibleWidth - (glyphPositions[visibleTextEnd] - startPos);
+			if (hasSelection) selectionX += textOffset;
+		}
+	}
+
+	@Override
+	public void draw (Batch batch, float parentAlpha) {
+		Stage stage = getStage();
+		boolean focused = stage != null && stage.getKeyboardFocus() == this;
+
+		final BitmapFont font = style.font;
+		final Color fontColor = (disabled && style.disabledFontColor != null) ? style.disabledFontColor
+			: ((focused && style.focusedFontColor != null) ? style.focusedFontColor : style.fontColor);
+		final Drawable selection = style.selection;
+		final Drawable cursorPatch = style.cursor;
+		final Drawable background = (disabled && style.disabledBackground != null) ? style.disabledBackground
+			: ((focused && style.focusedBackground != null) ? style.focusedBackground : style.background);
+
+		Color color = getColor();
+		float x = getX();
+		float y = getY();
+		float width = getWidth();
+		float height = getHeight();
+
+		batch.setColor(color.r, color.g, color.b, color.a * parentAlpha);
+		float bgLeftWidth = 0;
+		if (background != null) {
+			background.draw(batch, x, y, width, height);
+			bgLeftWidth = background.getLeftWidth();
+		}
+
+		float textY = getTextY(font, background);
+		calculateOffsets();
+
+		if (focused && hasSelection && selection != null) {
+			drawSelection(selection, batch, font, x + bgLeftWidth, y + textY);
+		}
+
+		float yOffset = font.isFlipped() ? -textHeight : 0;
+		if (displayText.length() == 0) {
+			if (!focused && messageText != null) {
+				if (style.messageFontColor != null) {
+					font.setColor(style.messageFontColor.r, style.messageFontColor.g, style.messageFontColor.b,
+						style.messageFontColor.a * parentAlpha);
+				} else
+					font.setColor(0.7f, 0.7f, 0.7f, parentAlpha);
+				BitmapFont messageFont = style.messageFont != null ? style.messageFont : font;
+				messageFont.draw(batch, messageText, x + bgLeftWidth, y + textY + yOffset);
+			}
+		} else {
+			font.setColor(fontColor.r, fontColor.g, fontColor.b, fontColor.a * parentAlpha);
+			drawText(batch, font, x + bgLeftWidth, y + textY + yOffset);
+		}
+		if (focused && !disabled) {
+			blink();
+			if (cursorOn && cursorPatch != null) {
+				drawCursor(cursorPatch, batch, font, x + bgLeftWidth, y + textY);
+			}
+		}
+	}
+
+	protected float getTextY (BitmapFont font, Drawable background) {
+		float height = getHeight();
+		float textY = textHeight / 2 + font.getDescent();
+		if (background != null) {
+			float bottom = background.getBottomHeight();
+			textY = (int)(textY + (height - background.getTopHeight() - bottom) / 2 + bottom);
+		} else {
+			textY = (int)(textY + height / 2);
+		}
+		return textY;
+	}
+
+	/** Draws selection rectangle **/
+	protected void drawSelection (Drawable selection, Batch batch, BitmapFont font, float x, float y) {
+		selection.draw(batch, x + selectionX + renderOffset, y - textHeight - font.getDescent(), selectionWidth,
+			textHeight + font.getDescent() / 2);
+	}
+
+	protected void drawText (Batch batch, BitmapFont font, float x, float y) {
+		font.draw(batch, displayText, x + textOffset, y, visibleTextStart, visibleTextEnd);
+	}
+
+	protected void drawCursor (Drawable cursorPatch, Batch batch, BitmapFont font, float x, float y) {
+		cursorPatch.draw(batch, x + textOffset + glyphPositions.get(cursor) - glyphPositions.items[visibleTextStart] - 1, y
+			- textHeight - font.getDescent(), cursorPatch.getMinWidth(), textHeight + font.getDescent() / 2);
+	}
+
+	void updateDisplayText () {
+		BitmapFont font = style.font;
+		String text = this.text;
+		int textLength = text.length();
+
+		StringBuilder buffer = new StringBuilder();
+		for (int i = 0; i < textLength; i++) {
+			char c = text.charAt(i);
+			buffer.append(font.containsCharacter(c) ? c : ' ');
+		}
+		String newDisplayText = buffer.toString();
+
+		if (passwordMode && font.containsCharacter(passwordCharacter)) {
+			if (passwordBuffer == null) passwordBuffer = new StringBuilder(newDisplayText.length());
+			if (passwordBuffer.length() > textLength) //
+				passwordBuffer.setLength(textLength);
+			else {
+				for (int i = passwordBuffer.length(); i < textLength; i++)
+					passwordBuffer.append(passwordCharacter);
+			}
+			displayText = passwordBuffer;
+		} else
+			displayText = newDisplayText;
+		font.computeGlyphAdvancesAndPositions(displayText, glyphAdvances, glyphPositions);
+		if (selectionStart > newDisplayText.length()) selectionStart = textLength;
+	}
+
+	private void blink () {
+		long time = TimeUtils.nanoTime();
+		if ((time - lastBlink) / 1000000000.0f > blinkTime) {
+			cursorOn = !cursorOn;
+			lastBlink = time;
+		}
+	}
+
+	/** Copies the contents of this TextField to the {@link Clipboard} implementation set on this TextField. */
+	public void copy () {
+		if (hasSelection && !passwordMode) {
+			clipboard.setContents(text.substring(Math.min(cursor, selectionStart), Math.max(cursor, selectionStart)));
+		}
+	}
+
+	/** Copies the selected contents of this TextField to the {@link Clipboard} implementation set on this TextField, then removes
+	 * it. */
+	public void cut () {
+		if (hasSelection && !passwordMode) {
+			copy();
+			cursor = delete();
+		}
+	}
+
+	/** Pastes the content of the {@link Clipboard} implementation set on this Textfield to this TextField. */
+	void paste () {
+		paste(clipboard.getContents(), true);
+	}
+
+	void paste (String content, boolean onlyFontChars) {
+		if (content == null) return;
+		StringBuilder buffer = new StringBuilder();
+		int textLength = text.length();
+		for (int i = 0, n = content.length(); i < n; i++) {
+			if (!withinMaxLength(textLength + buffer.length())) break;
+			char c = content.charAt(i);
+			if (!(writeEnters && (c == ENTER_ANDROID || c == ENTER_DESKTOP))) {
+				if (onlyFontChars && !style.font.containsCharacter(c)) continue;
+				if (filter != null && !filter.acceptChar(this, c)) continue;
+			}
+			buffer.append(c);
+		}
+		content = buffer.toString();
+
+		if (hasSelection) cursor = delete(false);
+		text = insert(cursor, content, text);
+		updateDisplayText();
+		cursor += content.length();
+	}
+
+	String insert (int position, CharSequence text, String to) {
+		if (to.length() == 0) return text.toString();
+		return to.substring(0, position) + text + to.substring(position, to.length());
+	}
+
+	int delete () {
+		return delete(true);
+	}
+
+	int delete (boolean updateText) {
+		return delete(selectionStart, cursor, updateText);
+	}
+
+	int delete (int from, int to, boolean updateText) {
+		int minIndex = Math.min(from, to);
+		int maxIndex = Math.max(from, to);
+		text = (minIndex > 0 ? text.substring(0, minIndex) : "")
+			+ (maxIndex < text.length() ? text.substring(maxIndex, text.length()) : "");
+		if (updateText) updateDisplayText();
+		clearSelection();
+		return minIndex;
+	}
+
+	/** Focuses the next TextField. If none is found, the keyboard is hidden. Does nothing if the text field is not in a stage.
+	 * @param up If true, the TextField with the same or next smallest y coordinate is found, else the next highest. */
+	public void next (boolean up) {
+		Stage stage = getStage();
+		if (stage == null) return;
+		getParent().localToStageCoordinates(tmp1.set(getX(), getY()));
+		TextField textField = findNextTextField(stage.getActors(), null, tmp2, tmp1, up);
+		if (textField == null) { // Try to wrap around.
+			if (up)
+				tmp1.set(Float.MIN_VALUE, Float.MIN_VALUE);
+			else
+				tmp1.set(Float.MAX_VALUE, Float.MAX_VALUE);
+			textField = findNextTextField(getStage().getActors(), null, tmp2, tmp1, up);
+		}
+		if (textField != null)
+			stage.setKeyboardFocus(textField);
+		else
+			Gdx.input.setOnscreenKeyboardVisible(false);
+	}
+
+	private TextField findNextTextField (Array<Actor> actors, TextField best, Vector2 bestCoords, Vector2 currentCoords, boolean up) {
+		for (int i = 0, n = actors.size; i < n; i++) {
+			Actor actor = actors.get(i);
+			if (actor == this) continue;
+			if (actor instanceof TextField) {
+				TextField textField = (TextField)actor;
+				if (textField.isDisabled() || !textField.focusTraversal) continue;
+				Vector2 actorCoords = actor.getParent().localToStageCoordinates(tmp3.set(actor.getX(), actor.getY()));
+				if ((actorCoords.y < currentCoords.y || (actorCoords.y == currentCoords.y && actorCoords.x > currentCoords.x)) ^ up) {
+					if (best == null
+						|| (actorCoords.y > bestCoords.y || (actorCoords.y == bestCoords.y && actorCoords.x < bestCoords.x)) ^ up) {
+						best = (TextField)actor;
+						bestCoords.set(actorCoords);
+					}
+				}
+			} else if (actor instanceof Group)
+				best = findNextTextField(((Group)actor).getChildren(), best, bestCoords, currentCoords, up);
+		}
+		return best;
+	}
+
+	public InputListener getDefaultInputListener () {
+		return inputListener;
+	}
+
+	/** @param listener May be null. */
+	public void setTextFieldListener (TextFieldListener listener) {
+		this.listener = listener;
+	}
+
+	/** @param filter May be null. */
+	public void setTextFieldFilter (TextFieldFilter filter) {
+		this.filter = filter;
+	}
+
+	public TextFieldFilter getTextFieldFilter () {
+		return filter;
+	}
+
+	/** If true (the default), tab/shift+tab will move to the next text field. */
+	public void setFocusTraversal (boolean focusTraversal) {
+		this.focusTraversal = focusTraversal;
+	}
+
+	/** @return May be null. */
+	public String getMessageText () {
+		return messageText;
+	}
+
+	/** Sets the text that will be drawn in the text field if no text has been entered.
+	 * @param messageText may be null. */
+	public void setMessageText (String messageText) {
+		this.messageText = messageText;
+	}
+
+	public void setText (String str) {
+		if (str == null) throw new IllegalArgumentException("text cannot be null.");
+		if (str.equals(text)) return;
+
+		clearSelection();
+		text = "";
+		paste(str, onlyFontChars);
+		cursor = 0;
+	}
+
+	/** @return Never null, might be an empty string. */
+	public String getText () {
+		return text;
+	}
+
+	public int getSelectionStart () {
+		return selectionStart;
+	}
+
+	public String getSelection () {
+		return hasSelection ? text.substring(Math.min(selectionStart, cursor), Math.max(selectionStart, cursor)) : "";
+	}
+
+	/** Sets the selected text. */
+	public void setSelection (int selectionStart, int selectionEnd) {
+		if (selectionStart < 0) throw new IllegalArgumentException("selectionStart must be >= 0");
+		if (selectionEnd < 0) throw new IllegalArgumentException("selectionEnd must be >= 0");
+		selectionStart = Math.min(text.length(), selectionStart);
+		selectionEnd = Math.min(text.length(), selectionEnd);
+		if (selectionEnd == selectionStart) {
+			clearSelection();
+			return;
+		}
+		if (selectionEnd < selectionStart) {
+			int temp = selectionEnd;
+			selectionEnd = selectionStart;
+			selectionStart = temp;
+		}
+
+		hasSelection = true;
+		this.selectionStart = selectionStart;
+		cursor = selectionEnd;
+	}
+
+	public void selectAll () {
+		setSelection(0, text.length());
+	}
+
+	public void clearSelection () {
+		hasSelection = false;
+	}
+
+	/** Sets the cursor position and clears any selection. */
+	public void setCursorPosition (int cursorPosition) {
+		if (cursorPosition < 0) throw new IllegalArgumentException("cursorPosition must be >= 0");
+		clearSelection();
+		cursor = Math.min(cursorPosition, text.length());
+	}
+
+	public int getCursorPosition () {
+		return cursor;
+	}
+
+	/** Default is an instance of {@link DefaultOnscreenKeyboard}. */
+	public OnscreenKeyboard getOnscreenKeyboard () {
+		return keyboard;
+	}
+
+	public void setOnscreenKeyboard (OnscreenKeyboard keyboard) {
+		this.keyboard = keyboard;
+	}
+
+	public void setClipboard (Clipboard clipboard) {
+		this.clipboard = clipboard;
+	}
+
+	public float getPrefWidth () {
+		return 150;
+	}
+
+	public float getPrefHeight () {
+		float prefHeight = textHeight;
+		if (style.background != null) {
+			prefHeight = Math.max(prefHeight + style.background.getBottomHeight() + style.background.getTopHeight(),
+				style.background.getMinHeight());
+		}
+		return prefHeight;
+	}
+
+	public void setRightAligned (boolean rightAligned) {
+		this.rightAligned = rightAligned;
+	}
+
+	/** If true, the text in this text field will be shown as bullet characters.
+	 * @see #setPasswordCharacter(char) */
+	public void setPasswordMode (boolean passwordMode) {
+		this.passwordMode = passwordMode;
+		updateDisplayText();
+	}
+
+	public boolean isPasswordMode () {
+		return passwordMode;
+	}
+
+	/** Sets the password character for the text field. The character must be present in the {@link BitmapFont}. Default is 149
+	 * (bullet). */
+	public void setPasswordCharacter (char passwordCharacter) {
+		this.passwordCharacter = passwordCharacter;
+		if (passwordMode) updateDisplayText();
+	}
+
+	public void setBlinkTime (float blinkTime) {
+		this.blinkTime = blinkTime;
+	}
+
+	public void setDisabled (boolean disabled) {
+		this.disabled = disabled;
+	}
+
+	public boolean isDisabled () {
+		return disabled;
+	}
+
+	protected void moveCursor (boolean forward, boolean jump) {
+		int limit = forward ? text.length() : 0;
+		int charOffset = forward ? 0 : -1;
+		while ((forward ? ++cursor < limit : --cursor > limit) && jump) {
+			if (!continueCursor(cursor, charOffset)) break;
+		}
+	}
+
+	protected boolean continueCursor (int index, int offset) {
+		char c = text.charAt(index + offset);
+		return isWordCharacter(c);
+	}
+
+	class KeyRepeatTask extends Task {
+		int keycode;
+
+		public void run () {
+			inputListener.keyDown(null, keycode);
+		}
+	}
+
+	/** Interface for listening to typed characters.
+	 * @author mzechner */
+	static public interface TextFieldListener {
+		public void keyTyped (TextField textField, char c);
+	}
+
+	/** Interface for filtering characters entered into the text field.
+	 * @author mzechner */
+	static public interface TextFieldFilter {
+		public boolean acceptChar (TextField textField, char c);
+
+		static public class DigitsOnlyFilter implements TextFieldFilter {
+			@Override
+			public boolean acceptChar (TextField textField, char c) {
+				return Character.isDigit(c);
+			}
+
+		}
+	}
+
+	/** An interface for onscreen keyboards. Can invoke the default keyboard or render your own keyboard!
+	 * @author mzechner */
+	static public interface OnscreenKeyboard {
+		public void show (boolean visible);
+	}
+
+	/** The default {@link OnscreenKeyboard} used by all {@link TextField} instances. Just uses
+	 * {@link Input#setOnscreenKeyboardVisible(boolean)} as appropriate. Might overlap your actual rendering, so use with care!
+	 * @author mzechner */
+	static public class DefaultOnscreenKeyboard implements OnscreenKeyboard {
+		@Override
+		public void show (boolean visible) {
+			Gdx.input.setOnscreenKeyboardVisible(visible);
+		}
+	}
+
+	/** Basic input listener for the text field */
+	public class TextFieldClickListener extends ClickListener {
+		public void clicked (InputEvent event, float x, float y) {
+			int count = getTapCount() % 4;
+			if (count == 0) clearSelection();
+			if (count == 2) {
+				int[] array = wordUnderCursor(x);
+				setSelection(array[0], array[1]);
+			}
+			if (count == 3) selectAll();
+		}
+
+		public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
+			if (!super.touchDown(event, x, y, pointer, button)) return false;
+			if (pointer == 0 && button != 0) return false;
+			if (disabled) return true;
+			setCursorPosition(x, y);
+			selectionStart = cursor;
+			Stage stage = getStage();
+			if (stage != null) stage.setKeyboardFocus(TextField.this);
+			keyboard.show(true);
+			hasSelection = true;
+			return true;
+		}
+
+		public void touchDragged (InputEvent event, float x, float y, int pointer) {
+			super.touchDragged(event, x, y, pointer);
+			setCursorPosition(x, y);
+		}
+
+		public void touchUp (InputEvent event, float x, float y, int pointer, int button) {
+			if (selectionStart == cursor) hasSelection = false;
+			super.touchUp(event, x, y, pointer, button);
+		}
+
+		protected void setCursorPosition (float x, float y) {
+			lastBlink = 0;
+			cursorOn = false;
+			cursor = letterUnderCursor(x);
+		}
+
+		protected void goHome (boolean jump) {
+			cursor = 0;
+		}
+
+		protected void goEnd (boolean jump) {
+			cursor = text.length();
+		}
+
+		public boolean keyDown (InputEvent event, int keycode) {
+			if (disabled) return false;
+
+			lastBlink = 0;
+			cursorOn = false;
+
+			Stage stage = getStage();
+			if (stage == null || stage.getKeyboardFocus() != TextField.this) return false;
+
+			boolean repeat = false;
+			boolean ctrl = UIUtils.ctrl();
+			boolean jump = ctrl && !passwordMode;
+
+			if (ctrl) {
+				if (keycode == Keys.V) {
+					paste();
+					return true;
+				}
+				if (keycode == Keys.C || keycode == Keys.INSERT) {
+					copy();
+					return true;
+				}
+				if (keycode == Keys.X || keycode == Keys.DEL) {
+					cut();
+					return true;
+				}
+				if (keycode == Keys.A) {
+					selectAll();
+					return true;
+				}
+			}
+
+			if (UIUtils.shift()) {
+				if (keycode == Keys.INSERT) paste();
+				if (keycode == Keys.FORWARD_DEL && hasSelection) {
+					copy();
+					delete(); // cut
+				}
+				selection:
+				{
+					int temp = cursor;
+					keys:
+					{
+						if (keycode == Keys.LEFT) {
+							moveCursor(false, jump);
+							repeat = true;
+							break keys;
+						}
+						if (keycode == Keys.RIGHT) {
+							moveCursor(true, jump);
+							repeat = true;
+							break keys;
+						}
+						if (keycode == Keys.HOME) {
+							goHome(jump);
+							break keys;
+						}
+						if (keycode == Keys.END) {
+							goEnd(jump);
+							break keys;
+						}
+						break selection;
+					}
+					if (!hasSelection) {
+						selectionStart = temp;
+						hasSelection = true;
+					}
+				}
+			} else {
+				// Cursor movement or other keys (kills selection).
+				if (keycode == Keys.LEFT) {
+					moveCursor(false, jump);
+					clearSelection();
+					repeat = true;
+				}
+				if (keycode == Keys.RIGHT) {
+					moveCursor(true, jump);
+					clearSelection();
+					repeat = true;
+				}
+				if (keycode == Keys.HOME) {
+					goHome(jump);
+					clearSelection();
+				}
+				if (keycode == Keys.END) {
+					goEnd(jump);
+					clearSelection();
+				}
+			}
+			cursor = MathUtils.clamp(cursor, 0, text.length());
+
+			if (repeat) {
+				scheduleKeyRepeatTask(keycode);
+			}
+			return true;
+		}
+
+		protected void scheduleKeyRepeatTask (int keycode) {
+			if (!keyRepeatTask.isScheduled() || keyRepeatTask.keycode != keycode) {
+				keyRepeatTask.keycode = keycode;
+				keyRepeatTask.cancel();
+				Timer.schedule(keyRepeatTask, keyRepeatInitialTime, keyRepeatTime);
+			}
+		}
+
+		public boolean keyUp (InputEvent event, int keycode) {
+			if (disabled) return false;
+			keyRepeatTask.cancel();
+			return true;
+		}
+
+		public boolean keyTyped (InputEvent event, char character) {
+			if (disabled) return false;
+
+			Stage stage = getStage();
+			if (stage == null || stage.getKeyboardFocus() != TextField.this) return false;
+
+			if ((character == TAB || character == ENTER_ANDROID) && focusTraversal) {
+				next(UIUtils.shift());
+			} else {
+				boolean delete = character == DELETE;
+				boolean backspace = character == BACKSPACE;
+				boolean add = style.font.containsCharacter(character)
+					|| (writeEnters && (character == ENTER_ANDROID || character == ENTER_DESKTOP));
+				boolean remove = backspace || delete;
+				if (add || remove) {
+					if (hasSelection)
+						cursor = delete(false);
+					else {
+						if (backspace && cursor > 0) {
+							text = text.substring(0, cursor - 1) + text.substring(cursor--);
+							renderOffset = 0;
+						}
+						if (delete && cursor < text.length()) {
+							text = text.substring(0, cursor) + text.substring(cursor + 1);
+						}
+					}
+					if (add && !remove) {
+						// Character may be added to the text.
+						boolean isEnter = character == ENTER_DESKTOP || character == ENTER_ANDROID;
+						if (!isEnter) {
+							if (filter != null && !filter.acceptChar(TextField.this, character)) return true;
+						}
+						if (!withinMaxLength(text.length())) return true;
+						String insertion = isEnter ? "\n" : String.valueOf(character);
+						text = insert(cursor++, insertion, text);
+					}
+					updateDisplayText();
+				}
+			}
+			if (listener != null) listener.keyTyped(TextField.this, character);
+			return true;
+		}
+	}
+
+	/** The style for a text field, see {@link TextField}.
+	 * @author mzechner
+	 * @author Nathan Sweet */
+	static public class TextFieldStyle {
+		public BitmapFont font;
+		public Color fontColor;
+		/** Optional. */
+		public Color focusedFontColor, disabledFontColor;
+		/** Optional. */
+		public Drawable background, focusedBackground, disabledBackground, cursor, selection;
+		/** Optional. */
+		public BitmapFont messageFont;
+		/** Optional. */
+		public Color messageFontColor;
+
+		public TextFieldStyle () {
+		}
+
+		public TextFieldStyle (BitmapFont font, Color fontColor, Drawable cursor, Drawable selection, Drawable background) {
+			this.background = background;
+			this.cursor = cursor;
+			this.font = font;
+			this.fontColor = fontColor;
+			this.selection = selection;
+		}
+
+		public TextFieldStyle (TextFieldStyle style) {
+			this.messageFont = style.messageFont;
+			if (style.messageFontColor != null) this.messageFontColor = new Color(style.messageFontColor);
+			this.background = style.background;
+			this.focusedBackground = style.focusedBackground;
+			this.disabledBackground = style.disabledBackground;
+			this.cursor = style.cursor;
+			this.font = style.font;
+			if (style.fontColor != null) this.fontColor = new Color(style.fontColor);
+			if (style.focusedFontColor != null) this.focusedFontColor = new Color(style.focusedFontColor);
+			if (style.disabledFontColor != null) this.disabledFontColor = new Color(style.disabledFontColor);
+			this.selection = style.selection;
+		}
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/ClickListener.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/ClickListener.java
index dd38abe..54411d9 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/ClickListener.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/ClickListener.java
@@ -38,7 +38,7 @@ public class ClickListener extends InputListener {
 	private int pressedButton = -1;
 	private int button;
 	private boolean pressed, over, cancelled;
-	private long visualPressedTime;
+	private float visualPressedTime;
 	private long tapCountInterval = (long)(0.4f * 1000000000l);
 	private int tapCount;
 	private long lastTapTime;
@@ -61,7 +61,7 @@ public class ClickListener extends InputListener {
 		pressedButton = button;
 		touchDownX = x;
 		touchDownY = y;
-		visualPressedTime = TimeUtils.millis() + (long)(visualPressedDuration * 1000);
+		visualPressedTime = TimeUtils.nanoTime() + visualPressedDuration * 1000000000;
 		return true;
 	}
 
@@ -147,7 +147,7 @@ public class ClickListener extends InputListener {
 	public boolean isVisualPressed () {
 		if (pressed) return true;
 		if (visualPressedTime <= 0) return false;
-		if (visualPressedTime > TimeUtils.millis()) return true;
+		if (visualPressedTime > TimeUtils.nanoTime() && Gdx.graphics.isContinuousRendering()) return true;
 		visualPressedTime = 0;
 		return false;
 	}
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/DragAndDrop.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/DragAndDrop.java
index fc373fe..78dcd85 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/DragAndDrop.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/DragAndDrop.java
@@ -46,7 +46,6 @@ public class DragAndDrop {
 	int dragTime = 250;
 	int activePointer = -1;
 	boolean cancelTouchFocus = true;
-	boolean keepWithinStage = true;
 
 	public void addSource (final Source source) {
 		DragListener listener = new DragListener() {
@@ -112,12 +111,10 @@ public class DragAndDrop {
 				}
 				float actorX = event.getStageX() + dragActorX;
 				float actorY = event.getStageY() + dragActorY - actor.getHeight();
-				if (keepWithinStage) {
-					if (actorX < 0) actorX = 0;
-					if (actorY < 0) actorY = 0;
-					if (actorX + actor.getWidth() > stage.getWidth()) actorX = stage.getWidth() - actor.getWidth();
-					if (actorY + actor.getHeight() > stage.getHeight()) actorY = stage.getHeight() - actor.getHeight();
-				}
+				if (actorX < 0) actorX = 0;
+				if (actorY < 0) actorY = 0;
+				if (actorX + actor.getWidth() > stage.getWidth()) actorX = stage.getWidth() - actor.getWidth();
+				if (actorY + actor.getHeight() > stage.getHeight()) actorY = stage.getHeight() - actor.getHeight();
 				actor.setPosition(actorX, actorY);
 			}
 
@@ -211,10 +208,6 @@ public class DragAndDrop {
 		this.cancelTouchFocus = cancelTouchFocus;
 	}
 
-	public void setKeepWithinStage (boolean keepWithinStage) {
-		this.keepWithinStage = keepWithinStage;
-	}
-
 	/** A target where a payload can be dragged from.
 	 * @author Nathan Sweet */
 	static abstract public class Source {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/NinePatchDrawable.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/NinePatchDrawable.java
index 3dc2d12..f818453 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/NinePatchDrawable.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/NinePatchDrawable.java
@@ -16,7 +16,6 @@
 
 package com.badlogic.gdx.scenes.scene2d.utils;
 
-import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.g2d.Batch;
 import com.badlogic.gdx.graphics.g2d.NinePatch;
 
@@ -62,11 +61,4 @@ public class NinePatchDrawable extends BaseDrawable {
 	public NinePatch getPatch () {
 		return patch;
 	}
-
-	/** Creates a new drawable that renders the same as this drawable tinted the specified color. */
-	public NinePatchDrawable tint (Color tint) {
-		NinePatchDrawable drawable = new NinePatchDrawable(this);
-		drawable.setPatch(new NinePatch(drawable.getPatch(), tint));
-		return drawable;
-	}
 }
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/SpriteDrawable.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/SpriteDrawable.java
index 604d3dc..b231228 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/SpriteDrawable.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/SpriteDrawable.java
@@ -64,17 +64,4 @@ public class SpriteDrawable extends BaseDrawable implements TransformDrawable {
 	public Sprite getSprite () {
 		return sprite;
 	}
-
-	/** Creates a new drawable that renders the same as this drawable tinted the specified color. */
-	public SpriteDrawable tint (Color tint) {
-		SpriteDrawable drawable = new SpriteDrawable(this);
-		Sprite sprite = drawable.getSprite();
-		if (sprite instanceof AtlasSprite)
-			sprite = new AtlasSprite((AtlasSprite)sprite);
-		else
-			sprite = new Sprite(sprite);
-		sprite.setColor(tint);
-		drawable.setSprite(sprite);
-		return drawable;
-	}
 }
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/TextureRegionDrawable.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/TextureRegionDrawable.java
index f4b3cf3..3a462e5 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/TextureRegionDrawable.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/TextureRegionDrawable.java
@@ -16,12 +16,8 @@
 
 package com.badlogic.gdx.scenes.scene2d.utils;
 
-import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.g2d.Batch;
-import com.badlogic.gdx.graphics.g2d.Sprite;
 import com.badlogic.gdx.graphics.g2d.TextureRegion;
-import com.badlogic.gdx.graphics.g2d.TextureAtlas.AtlasRegion;
-import com.badlogic.gdx.graphics.g2d.TextureAtlas.AtlasSprite;
 
 /** Drawable for a {@link TextureRegion}.
  * @author Nathan Sweet */
@@ -59,15 +55,4 @@ public class TextureRegionDrawable extends BaseDrawable implements TransformDraw
 	public TextureRegion getRegion () {
 		return region;
 	}
-
-	/** Creates a new drawable that renders the same as this drawable tinted the specified color. */
-	public SpriteDrawable tint (Color tint) {
-		Sprite sprite;
-		if (region instanceof AtlasRegion)
-			sprite = new AtlasSprite((AtlasRegion)region);
-		else
-			sprite = new Sprite(region);
-		sprite.setColor(tint);
-		return new SpriteDrawable(sprite);
-	}
 }
diff --git a/gdx/src/com/badlogic/gdx/utils/Array.java b/gdx/src/com/badlogic/gdx/utils/Array.java
index 5485f98..3962eef 100644
--- a/gdx/src/com/badlogic/gdx/utils/Array.java
+++ b/gdx/src/com/badlogic/gdx/utils/Array.java
@@ -92,7 +92,7 @@ public class Array<T> implements Iterable<T> {
 	public Array (boolean ordered, T[] array, int start, int count) {
 		this(ordered, count, (Class)array.getClass().getComponentType());
 		size = count;
-		System.arraycopy(array, start, items, 0, size);
+		System.arraycopy(array, 0, items, 0, size);
 	}
 
 	public void add (T value) {
@@ -105,22 +105,22 @@ public class Array<T> implements Iterable<T> {
 		addAll(array, 0, array.size);
 	}
 
-	public void addAll (Array<? extends T> array, int start, int count) {
-		if (start + count > array.size)
-			throw new IllegalArgumentException("start + count must be <= size: " + start + " + " + count + " <= " + array.size);
-		addAll((T[])array.items, start, count);
+	public void addAll (Array<? extends T> array, int offset, int length) {
+		if (offset + length > array.size)
+			throw new IllegalArgumentException("offset + length must be <= size: " + offset + " + " + length + " <= " + array.size);
+		addAll((T[])array.items, offset, length);
 	}
 
 	public void addAll (T... array) {
 		addAll(array, 0, array.length);
 	}
 
-	public void addAll (T[] array, int start, int count) {
+	public void addAll (T[] array, int offset, int length) {
 		T[] items = this.items;
-		int sizeNeeded = size + count;
+		int sizeNeeded = size + length;
 		if (sizeNeeded > items.length) items = resize(Math.max(8, (int)(sizeNeeded * 1.75f)));
-		System.arraycopy(array, start, items, size, count);
-		size += count;
+		System.arraycopy(array, offset, items, size, length);
+		size += length;
 	}
 
 	public T get (int index) {
diff --git a/gdx/src/com/badlogic/gdx/utils/ArrayMap.java b/gdx/src/com/badlogic/gdx/utils/ArrayMap.java
index 69e001e..f67da4a 100644
--- a/gdx/src/com/badlogic/gdx/utils/ArrayMap.java
+++ b/gdx/src/com/badlogic/gdx/utils/ArrayMap.java
@@ -26,8 +26,8 @@ import com.badlogic.gdx.utils.reflect.ArrayReflection;
 /** An ordered or unordered map of objects. This implementation uses arrays to store the keys and values, which means
  * {@link #getKey(Object, boolean) gets} do a comparison for each key in the map. This is slower than a typical hash map
  * implementation, but may be acceptable for small maps and has the benefits that keys and values can be accessed by index, which
- * makes iteration fast. Like {@link Array}, if ordered is false, this class avoids a memory copy when removing elements (the last
- * element is moved to the removed element's position).
+ * makes iteration fast. Like {@link Array}, if ordered is false, * this class avoids a memory copy when removing elements (the
+ * last element is moved to the removed element's position).
  * @author Nathan Sweet */
 public class ArrayMap<K, V> implements Iterable<ObjectMap.Entry<K, V>> {
 	public K[] keys;
@@ -83,29 +83,23 @@ public class ArrayMap<K, V> implements Iterable<ObjectMap.Entry<K, V>> {
 		System.arraycopy(array.values, 0, values, 0, size);
 	}
 
-	public int put (K key, V value) {
+	public void put (K key, V value) {
+		if (size == keys.length) resize(Math.max(8, (int)(size * 1.75f)));
 		int index = indexOfKey(key);
-		if (index == -1) {
-			if (size == keys.length) resize(Math.max(8, (int)(size * 1.75f)));
-			index = size++;
-		}
+		if (index == -1) index = size++;
 		keys[index] = key;
 		values[index] = value;
-		return index;
 	}
 
-	public int put (K key, V value, int index) {
+	public void put (K key, V value, int index) {
+		if (size == keys.length) resize(Math.max(8, (int)(size * 1.75f)));
 		int existingIndex = indexOfKey(key);
-		if (existingIndex != -1)
-			removeIndex(existingIndex);
-		else if (size == keys.length) //
-			resize(Math.max(8, (int)(size * 1.75f)));
+		if (existingIndex != -1) removeIndex(existingIndex);
 		System.arraycopy(keys, index, keys, index + 1, size - index);
 		System.arraycopy(values, index, values, index + 1, size - index);
 		keys[index] = key;
 		values[index] = value;
 		size++;
-		return index;
 	}
 
 	public void putAll (ArrayMap map) {
diff --git a/gdx/src/com/badlogic/gdx/utils/BufferUtils.java b/gdx/src/com/badlogic/gdx/utils/BufferUtils.java
index 191d81d..30e9799 100644
--- a/gdx/src/com/badlogic/gdx/utils/BufferUtils.java
+++ b/gdx/src/com/badlogic/gdx/utils/BufferUtils.java
@@ -79,7 +79,7 @@ public final class BufferUtils {
 	 * @param dst the destination Buffer, its position is used as an offset.
 	 * @param numElements the number of elements to copy. */
 	public static void copy (short[] src, int srcOffset, Buffer dst, int numElements) {
-		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements << 1);
+		copyJni(src, srcOffset << 1, dst, positionInBytes(dst), numElements << 1);
 		dst.limit(dst.position() + bytesToElements(dst, numElements << 1));
 	}
 
@@ -92,7 +92,7 @@ public final class BufferUtils {
 	 * @param numElements the number of elements to copy.
 	 * @param dst the destination Buffer, its position is used as an offset. */
 	public static void copy (char[] src, int srcOffset, int numElements, Buffer dst) {
-		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements << 1);
+		copyJni(src, srcOffset << 1, dst, positionInBytes(dst), numElements << 1);
 	}
 
 	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
@@ -104,7 +104,7 @@ public final class BufferUtils {
 	 * @param numElements the number of elements to copy.
 	 * @param dst the destination Buffer, its position is used as an offset. */
 	public static void copy (int[] src, int srcOffset, int numElements, Buffer dst) {
-		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements << 2);
+		copyJni(src, srcOffset << 2, dst, positionInBytes(dst), numElements << 2);
 	}
 
 	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
@@ -116,7 +116,7 @@ public final class BufferUtils {
 	 * @param numElements the number of elements to copy.
 	 * @param dst the destination Buffer, its position is used as an offset. */
 	public static void copy (long[] src, int srcOffset, int numElements, Buffer dst) {
-		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements << 3);
+		copyJni(src, srcOffset << 3, dst, positionInBytes(dst), numElements << 3);
 	}
 
 	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
@@ -128,7 +128,7 @@ public final class BufferUtils {
 	 * @param numElements the number of elements to copy.
 	 * @param dst the destination Buffer, its position is used as an offset. */
 	public static void copy (float[] src, int srcOffset, int numElements, Buffer dst) {
-		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements << 2);
+		copyJni(src, srcOffset << 2, dst, positionInBytes(dst), numElements << 2);
 	}
 
 	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
@@ -140,7 +140,7 @@ public final class BufferUtils {
 	 * @param numElements the number of elements to copy.
 	 * @param dst the destination Buffer, its position is used as an offset. */
 	public static void copy (double[] src, int srcOffset, int numElements, Buffer dst) {
-		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements << 3);
+		copyJni(src, srcOffset << 3, dst, positionInBytes(dst), numElements << 3);
 	}
 
 	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
@@ -153,7 +153,7 @@ public final class BufferUtils {
 	 * @param dst the destination Buffer, its position is used as an offset.
 	 * @param numElements the number of elements to copy. */
 	public static void copy (char[] src, int srcOffset, Buffer dst, int numElements) {
-		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements << 1);
+		copyJni(src, srcOffset << 1, dst, positionInBytes(dst), numElements << 1);
 		dst.limit(dst.position() + bytesToElements(dst, numElements << 1));
 	}
 
@@ -167,7 +167,7 @@ public final class BufferUtils {
 	 * @param dst the destination Buffer, its position is used as an offset.
 	 * @param numElements the number of elements to copy. */
 	public static void copy (int[] src, int srcOffset, Buffer dst, int numElements) {
-		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements << 2);
+		copyJni(src, srcOffset << 2, dst, positionInBytes(dst), numElements << 2);
 		dst.limit(dst.position() + bytesToElements(dst, numElements << 2));
 	}
 
@@ -181,7 +181,7 @@ public final class BufferUtils {
 	 * @param dst the destination Buffer, its position is used as an offset.
 	 * @param numElements the number of elements to copy. */
 	public static void copy (long[] src, int srcOffset, Buffer dst, int numElements) {
-		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements << 3);
+		copyJni(src, srcOffset << 3, dst, positionInBytes(dst), numElements << 3);
 		dst.limit(dst.position() + bytesToElements(dst, numElements << 3));
 	}
 
@@ -195,7 +195,7 @@ public final class BufferUtils {
 	 * @param dst the destination Buffer, its position is used as an offset.
 	 * @param numElements the number of elements to copy. */
 	public static void copy (float[] src, int srcOffset, Buffer dst, int numElements) {
-		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements << 2);
+		copyJni(src, srcOffset << 2, dst, positionInBytes(dst), numElements << 2);
 		dst.limit(dst.position() + bytesToElements(dst, numElements << 2));
 	}
 
@@ -209,7 +209,7 @@ public final class BufferUtils {
 	 * @param dst the destination Buffer, its position is used as an offset.
 	 * @param numElements the number of elements to copy. */
 	public static void copy (double[] src, int srcOffset, Buffer dst, int numElements) {
-		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements << 3);
+		copyJni(src, srcOffset << 3, dst, positionInBytes(dst), numElements << 3);
 		dst.limit(dst.position() + bytesToElements(dst, numElements << 3));
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/utils/I18NBundle.java b/gdx/src/com/badlogic/gdx/utils/I18NBundle.java
index bb4fc8a..cc4f510 100644
--- a/gdx/src/com/badlogic/gdx/utils/I18NBundle.java
+++ b/gdx/src/com/badlogic/gdx/utils/I18NBundle.java
@@ -67,9 +67,6 @@ public class I18NBundle {
 
 	private static final String DEFAULT_ENCODING = "UTF-8";
 
-	// Locale.ROOT does not exist in Android API level 8
-	private static final Locale ROOT_LOCALE = new Locale("", "", "");
-
 	private static boolean simpleFormatter = false;
 	private static boolean exceptionOnMissingKey = true;
 
@@ -173,7 +170,7 @@ public class I18NBundle {
 			// Check the loaded bundle (if any)
 			if (bundle != null) {
 				Locale bundleLocale = bundle.getLocale(); // WTH? GWT can't access bundle.locale directly
-				boolean isBaseBundle = bundleLocale.equals(ROOT_LOCALE);
+				boolean isBaseBundle = bundleLocale.equals(Locale.ROOT);
 
 				if (!isBaseBundle || bundleLocale.equals(locale)) {
 					// Found the bundle for the requested locale
@@ -270,7 +267,7 @@ public class I18NBundle {
 		if (language.length() > 0) {
 			locales.add((locales.size() == 0) ? locale : new Locale(language));
 		}
-		locales.add(ROOT_LOCALE);
+		locales.add(Locale.ROOT);
 		return locales;
 	}
 
@@ -299,7 +296,7 @@ public class I18NBundle {
 		if (candidateIndex != candidateLocales.size() - 1) {
 			// Load recursively the parent having the next candidate locale
 			parent = loadBundleChain(baseFileHandle, encoding, candidateLocales, candidateIndex + 1, baseBundle);
-		} else if (baseBundle != null && targetLocale.equals(ROOT_LOCALE)) {
+		} else if (baseBundle != null && targetLocale.equals(Locale.ROOT)) {
 			return baseBundle;
 		}
 
@@ -381,7 +378,7 @@ public class I18NBundle {
 	 * @exception NullPointerException if <code>baseFileHandle</code> or <code>locale</code> is <code>null</code> */
 	private static FileHandle toFileHandle (FileHandle baseFileHandle, Locale locale) {
 		StringBuilder sb = new StringBuilder(baseFileHandle.name());
-		if (!locale.equals(ROOT_LOCALE)) {
+		if (!locale.equals(Locale.ROOT)) {
 			String language = locale.getLanguage();
 			String country = locale.getCountry();
 			String variant = locale.getVariant();
diff --git a/gdx/src/com/badlogic/gdx/utils/Json.java b/gdx/src/com/badlogic/gdx/utils/Json.java
index c75730b..105d7ba 100644
--- a/gdx/src/com/badlogic/gdx/utils/Json.java
+++ b/gdx/src/com/badlogic/gdx/utils/Json.java
@@ -23,7 +23,6 @@ import java.io.StringWriter;
 import java.io.Writer;
 import java.security.AccessControlException;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
@@ -33,7 +32,7 @@ import com.badlogic.gdx.files.FileHandle;
 import com.badlogic.gdx.utils.JsonValue.PrettyPrintSettings;
 import com.badlogic.gdx.utils.JsonWriter.OutputType;
 import com.badlogic.gdx.utils.ObjectMap.Entry;
-import com.badlogic.gdx.utils.OrderedMap.OrderedMapValues;
+import com.badlogic.gdx.utils.ObjectMap.Values;
 import com.badlogic.gdx.utils.reflect.ArrayReflection;
 import com.badlogic.gdx.utils.reflect.ClassReflection;
 import com.badlogic.gdx.utils.reflect.Constructor;
@@ -54,12 +53,11 @@ public class Json {
 	private boolean ignoreUnknownFields;
 	private boolean enumNames = true;
 	private Serializer defaultSerializer;
-	private final ObjectMap<Class, OrderedMap<String, FieldMetadata>> typeToFields = new ObjectMap();
+	private final ObjectMap<Class, ObjectMap<String, FieldMetadata>> typeToFields = new ObjectMap();
 	private final ObjectMap<String, Class> tagToClass = new ObjectMap();
 	private final ObjectMap<Class, String> classToTag = new ObjectMap();
 	private final ObjectMap<Class, Serializer> classToSerializer = new ObjectMap();
 	private final ObjectMap<Class, Object[]> classToDefaultValues = new ObjectMap();
-	private final Object[] equals1 = {null}, equals2 = {null};
 
 	public Json () {
 		outputType = OutputType.minimal;
@@ -97,14 +95,20 @@ public class Json {
 		classToTag.put(type, tag);
 	}
 
-	/** Returns the class for the specified tag, or null. */
-	public Class getClass (String tag) {
-		return tagToClass.get(tag);
+	public Class getClass (String tagOrClassName) {
+		Class type = tagToClass.get(tagOrClassName);
+		if (type != null) return type;
+		try {
+			return ClassReflection.forName(tagOrClassName);
+		} catch (ReflectionException ex) {
+			throw new SerializationException(ex);
+		}
 	}
 
-	/** Returns the tag for the specified class, or null. */
 	public String getTag (Class type) {
-		return classToTag.get(type);
+		String tag = classToTag.get(type);
+		if (tag != null) return tag;
+		return type.getName();
 	}
 
 	/** Sets the name of the JSON field to store the Java class name or class tag when required to avoid ambiguity during
@@ -138,27 +142,22 @@ public class Json {
 	/** Sets the type of elements in a collection. When the element type is known, the class for each element in the collection does
 	 * not need to be written unless different from the element type. */
 	public void setElementType (Class type, String fieldName, Class elementType) {
-		ObjectMap<String, FieldMetadata> fields = getFields(type);
+		ObjectMap<String, FieldMetadata> fields = typeToFields.get(type);
+		if (fields == null) fields = cacheFields(type);
 		FieldMetadata metadata = fields.get(fieldName);
 		if (metadata == null) throw new SerializationException("Field not found: " + fieldName + " (" + type.getName() + ")");
 		metadata.elementType = elementType;
 	}
 
-	private OrderedMap<String, FieldMetadata> getFields (Class type) {
-		OrderedMap<String, FieldMetadata> fields = typeToFields.get(type);
-		if (fields != null) return fields;
-
-		Array<Class> classHierarchy = new Array();
+	private ObjectMap<String, FieldMetadata> cacheFields (Class type) {
+		ArrayList<Field> allFields = new ArrayList();
 		Class nextClass = type;
 		while (nextClass != Object.class) {
-			classHierarchy.add(nextClass);
+			Collections.addAll(allFields, ClassReflection.getDeclaredFields(nextClass));
 			nextClass = nextClass.getSuperclass();
 		}
-		ArrayList<Field> allFields = new ArrayList();
-		for (int i = classHierarchy.size - 1; i >= 0; i--)
-			Collections.addAll(allFields, ClassReflection.getDeclaredFields(classHierarchy.get(i)));
 
-		OrderedMap<String, FieldMetadata> nameToField = new OrderedMap();
+		ObjectMap<String, FieldMetadata> nameToField = new ObjectMap();
 		for (int i = 0, n = allFields.size(); i < n; i++) {
 			Field field = allFields.get(i);
 
@@ -258,23 +257,17 @@ public class Json {
 
 		Object[] defaultValues = getDefaultValues(type);
 
-		OrderedMap<String, FieldMetadata> fields = getFields(type);
+		ObjectMap<String, FieldMetadata> fields = typeToFields.get(type);
+		if (fields == null) fields = cacheFields(type);
 		int i = 0;
-		for (FieldMetadata metadata : new OrderedMapValues<FieldMetadata>(fields)) {
+		for (FieldMetadata metadata : new Values<FieldMetadata>(fields)) {
 			Field field = metadata.field;
 			try {
 				Object value = field.get(object);
 				if (defaultValues != null) {
 					Object defaultValue = defaultValues[i++];
 					if (value == null && defaultValue == null) continue;
-					if (value != null && defaultValue != null) {
-						if (value.equals(defaultValue)) continue;
-						if (value.getClass().isArray() && defaultValue.getClass().isArray()) {
-							equals1[0] = value;
-							equals2[0] = defaultValue;
-							if (Arrays.deepEquals(equals1, equals2)) continue;
-						}
-					}
+					if (value != null && defaultValue != null && value.equals(defaultValue)) continue;
 				}
 
 				if (debug) System.out.println("Writing field: " + field.getName() + " (" + type.getName() + ")");
@@ -304,7 +297,9 @@ public class Json {
 			return null;
 		}
 
-		ObjectMap<String, FieldMetadata> fields = getFields(type);
+		ObjectMap<String, FieldMetadata> fields = typeToFields.get(type);
+		if (fields == null) fields = cacheFields(type);
+
 		Object[] values = new Object[fields.size];
 		classToDefaultValues.put(type, values);
 
@@ -347,7 +342,8 @@ public class Json {
 	 * @param elementType May be null if the type is unknown. */
 	public void writeField (Object object, String fieldName, String jsonName, Class elementType) {
 		Class type = object.getClass();
-		ObjectMap<String, FieldMetadata> fields = getFields(type);
+		ObjectMap<String, FieldMetadata> fields = typeToFields.get(type);
+		if (fields == null) fields = cacheFields(type);
 		FieldMetadata metadata = fields.get(fieldName);
 		if (metadata == null) throw new SerializationException("Field not found: " + fieldName + " (" + type.getName() + ")");
 		Field field = metadata.field;
@@ -638,7 +634,7 @@ public class Json {
 
 	public void writeType (Class type) {
 		if (typeName == null) return;
-		String className = getTag(type);
+		String className = classToTag.get(type);
 		if (className == null) className = type.getName();
 		try {
 			writer.set(typeName, className);
@@ -735,37 +731,32 @@ public class Json {
 	/** @param elementType May be null if the type is unknown. */
 	public void readField (Object object, String fieldName, String jsonName, Class elementType, JsonValue jsonMap) {
 		Class type = object.getClass();
-		ObjectMap<String, FieldMetadata> fields = getFields(type);
+		ObjectMap<String, FieldMetadata> fields = typeToFields.get(type);
+		if (fields == null) fields = cacheFields(type);
 		FieldMetadata metadata = fields.get(fieldName);
 		if (metadata == null) throw new SerializationException("Field not found: " + fieldName + " (" + type.getName() + ")");
 		Field field = metadata.field;
-		if (elementType == null) elementType = metadata.elementType;
-		readField(object, field, jsonName, elementType, jsonMap);
-	}
-
-	/** @param object May be null if the field is static.
-	 * @param elementType May be null if the type is unknown. */
-	public void readField (Object object, Field field, String jsonName, Class elementType, JsonValue jsonMap) {
 		JsonValue jsonValue = jsonMap.get(jsonName);
 		if (jsonValue == null) return;
+		if (elementType == null) elementType = metadata.elementType;
 		try {
 			field.set(object, readValue(field.getType(), elementType, jsonValue));
 		} catch (ReflectionException ex) {
-			throw new SerializationException("Error accessing field: " + field.getName() + " ("
-				+ field.getDeclaringClass().getName() + ")", ex);
+			throw new SerializationException("Error accessing field: " + field.getName() + " (" + type.getName() + ")", ex);
 		} catch (SerializationException ex) {
-			ex.addTrace(field.getName() + " (" + field.getDeclaringClass().getName() + ")");
+			ex.addTrace(field.getName() + " (" + type.getName() + ")");
 			throw ex;
 		} catch (RuntimeException runtimeEx) {
 			SerializationException ex = new SerializationException(runtimeEx);
-			ex.addTrace(field.getName() + " (" + field.getDeclaringClass().getName() + ")");
+			ex.addTrace(field.getName() + " (" + type.getName() + ")");
 			throw ex;
 		}
 	}
 
 	public void readFields (Object object, JsonValue jsonMap) {
 		Class type = object.getClass();
-		ObjectMap<String, FieldMetadata> fields = getFields(type);
+		ObjectMap<String, FieldMetadata> fields = typeToFields.get(type);
+		if (fields == null) fields = cacheFields(type);
 		for (JsonValue child = jsonMap.child; child != null; child = child.next) {
 			FieldMetadata metadata = fields.get(child.name());
 			if (metadata == null) {
@@ -844,7 +835,7 @@ public class Json {
 			String className = typeName == null ? null : jsonData.getString(typeName, null);
 			if (className != null) {
 				jsonData.remove(typeName);
-				type = getClass(className);
+				type = tagToClass.get(className);
 				if (type == null) {
 					try {
 						type = (Class<T>)ClassReflection.forName(className);
diff --git a/gdx/src/com/badlogic/gdx/utils/JsonReader.java b/gdx/src/com/badlogic/gdx/utils/JsonReader.java
index 27b0dfc..08d8dcc 100644
--- a/gdx/src/com/badlogic/gdx/utils/JsonReader.java
+++ b/gdx/src/com/badlogic/gdx/utils/JsonReader.java
@@ -177,15 +177,16 @@ public class JsonReader implements BaseJsonReader {
 							while (_nacts-- > 0) {
 								switch (_json_actions[_acts++]) {
 								case 0:
-								// line 104 "JsonReader.rl"
+								// line 108 "JsonReader.rl"
 								{
 									stringIsName = true;
 								}
 									break;
 								case 1:
-								// line 107 "JsonReader.rl"
+								// line 111 "JsonReader.rl"
 								{
 									String value = new String(data, s, p - s);
+									s = p;
 									if (needsUnescape) value = unescape(value);
 									outer:
 									if (stringIsName) {
@@ -206,46 +207,16 @@ public class JsonReader implements BaseJsonReader {
 											} else if (value.equals("null")) {
 												string(name, null);
 												break outer;
-											}
-											boolean couldBeDouble = false, couldBeLong = true;
-											outer2:
-											for (int i = s; i < p; i++) {
-												switch (data[i]) {
-												case '0':
-												case '1':
-												case '2':
-												case '3':
-												case '4':
-												case '5':
-												case '6':
-												case '7':
-												case '8':
-												case '9':
-												case '-':
-												case '+':
-													break;
-												case '.':
-												case 'e':
-												case 'E':
-													couldBeDouble = true;
-													couldBeLong = false;
-													break;
-												default:
-													couldBeDouble = false;
-													couldBeLong = false;
-													break outer2;
-												}
-											}
-											if (couldBeDouble) {
+											} else if (value.indexOf('.') != -1) {
 												try {
 													if (debug) System.out.println("double: " + name + "=" + Double.parseDouble(value));
 													number(name, Double.parseDouble(value));
 													break outer;
 												} catch (NumberFormatException ignored) {
 												}
-											} else if (couldBeLong) {
-												if (debug) System.out.println("double: " + name + "=" + Double.parseDouble(value));
+											} else {
 												try {
+													if (debug) System.out.println("double: " + name + "=" + Double.parseDouble(value));
 													number(name, Long.parseLong(value));
 													break outer;
 												} catch (NumberFormatException ignored) {
@@ -256,11 +227,10 @@ public class JsonReader implements BaseJsonReader {
 										string(name, value);
 									}
 									stringIsUnquoted = false;
-									s = p;
 								}
 									break;
 								case 2:
-								// line 181 "JsonReader.rl"
+								// line 153 "JsonReader.rl"
 								{
 									String name = names.size > 0 ? names.pop() : null;
 									if (debug) System.out.println("startObject: " + name);
@@ -281,7 +251,7 @@ public class JsonReader implements BaseJsonReader {
 								}
 									break;
 								case 3:
-								// line 187 "JsonReader.rl"
+								// line 159 "JsonReader.rl"
 								{
 									if (debug) System.out.println("endObject");
 									pop();
@@ -293,7 +263,7 @@ public class JsonReader implements BaseJsonReader {
 								}
 									break;
 								case 4:
-								// line 192 "JsonReader.rl"
+								// line 164 "JsonReader.rl"
 								{
 									String name = names.size > 0 ? names.pop() : null;
 									if (debug) System.out.println("startArray: " + name);
@@ -306,7 +276,7 @@ public class JsonReader implements BaseJsonReader {
 										}
 										{
 											stack[top++] = cs;
-											cs = 23;
+											cs = 19;
 											_goto_targ = 2;
 											if (true) continue _goto;
 										}
@@ -314,7 +284,7 @@ public class JsonReader implements BaseJsonReader {
 								}
 									break;
 								case 5:
-								// line 198 "JsonReader.rl"
+								// line 170 "JsonReader.rl"
 								{
 									if (debug) System.out.println("endArray");
 									pop();
@@ -326,23 +296,21 @@ public class JsonReader implements BaseJsonReader {
 								}
 									break;
 								case 6:
-								// line 203 "JsonReader.rl"
+								// line 175 "JsonReader.rl"
 								{
-									int start = p - 1;
+									if (debug) System.out.println("comment /" + data[p]);
 									if (data[p++] == '/') {
-										while (p != eof && data[p] != '\n')
+										while (data[p] != '\n')
 											p++;
-										p--;
 									} else {
-										while (p + 1 < eof && data[p] != '*' || data[p + 1] != '/')
+										while (data[p] != '*' || data[p + 1] != '/')
 											p++;
 										p++;
 									}
-									if (debug) System.out.println("comment " + new String(data, start, p - start));
 								}
 									break;
 								case 7:
-								// line 216 "JsonReader.rl"
+								// line 186 "JsonReader.rl"
 								{
 									if (debug) System.out.println("unquotedChars");
 									s = p;
@@ -355,17 +323,14 @@ public class JsonReader implements BaseJsonReader {
 											case '\\':
 												needsUnescape = true;
 												break;
-											case '/':
-												if (p + 1 == eof) break;
-												char c = data[p + 1];
-												if (c == '/' || c == '*') break outer;
-												break;
 											case ':':
+											case ' ':
 											case '\r':
 											case '\n':
+											case '\t':
 												break outer;
 											}
-											if (debug) System.out.println("unquotedChar (name): '" + data[p] + "'");
+											// if (debug) System.out.println("unquotedChar (name): '" + data[p] + "'");
 											p++;
 											if (p == eof) break;
 										}
@@ -376,30 +341,25 @@ public class JsonReader implements BaseJsonReader {
 											case '\\':
 												needsUnescape = true;
 												break;
-											case '/':
-												if (p + 1 == eof) break;
-												char c = data[p + 1];
-												if (c == '/' || c == '*') break outer;
-												break;
 											case '}':
 											case ']':
 											case ',':
+											case ' ':
 											case '\r':
 											case '\n':
+											case '\t':
 												break outer;
 											}
-											if (debug) System.out.println("unquotedChar (value): '" + data[p] + "'");
+											// if (debug) System.out.println("unquotedChar (value): '" + data[p] + "'");
 											p++;
 											if (p == eof) break;
 										}
 									}
 									p--;
-									while (data[p] == ' ')
-										p--;
 								}
 									break;
 								case 8:
-								// line 270 "JsonReader.rl"
+								// line 232 "JsonReader.rl"
 								{
 									if (debug) System.out.println("quotedChars");
 									s = ++p;
@@ -421,7 +381,7 @@ public class JsonReader implements BaseJsonReader {
 									p--;
 								}
 									break;
-								// line 313 "JsonReader.java"
+								// line 271 "JsonReader.java"
 								}
 							}
 						}
@@ -442,9 +402,10 @@ public class JsonReader implements BaseJsonReader {
 							while (__nacts-- > 0) {
 								switch (_json_actions[__acts++]) {
 								case 1:
-								// line 107 "JsonReader.rl"
+								// line 111 "JsonReader.rl"
 								{
 									String value = new String(data, s, p - s);
+									s = p;
 									if (needsUnescape) value = unescape(value);
 									outer:
 									if (stringIsName) {
@@ -465,46 +426,16 @@ public class JsonReader implements BaseJsonReader {
 											} else if (value.equals("null")) {
 												string(name, null);
 												break outer;
-											}
-											boolean couldBeDouble = false, couldBeLong = true;
-											outer2:
-											for (int i = s; i < p; i++) {
-												switch (data[i]) {
-												case '0':
-												case '1':
-												case '2':
-												case '3':
-												case '4':
-												case '5':
-												case '6':
-												case '7':
-												case '8':
-												case '9':
-												case '-':
-												case '+':
-													break;
-												case '.':
-												case 'e':
-												case 'E':
-													couldBeDouble = true;
-													couldBeLong = false;
-													break;
-												default:
-													couldBeDouble = false;
-													couldBeLong = false;
-													break outer2;
-												}
-											}
-											if (couldBeDouble) {
+											} else if (value.indexOf('.') != -1) {
 												try {
 													if (debug) System.out.println("double: " + name + "=" + Double.parseDouble(value));
 													number(name, Double.parseDouble(value));
 													break outer;
 												} catch (NumberFormatException ignored) {
 												}
-											} else if (couldBeLong) {
-												if (debug) System.out.println("double: " + name + "=" + Double.parseDouble(value));
+											} else {
 												try {
+													if (debug) System.out.println("double: " + name + "=" + Double.parseDouble(value));
 													number(name, Long.parseLong(value));
 													break outer;
 												} catch (NumberFormatException ignored) {
@@ -515,10 +446,9 @@ public class JsonReader implements BaseJsonReader {
 										string(name, value);
 									}
 									stringIsUnquoted = false;
-									s = p;
 								}
 									break;
-								// line 411 "JsonReader.java"
+								// line 337 "JsonReader.java"
 								}
 							}
 						}
@@ -529,7 +459,7 @@ public class JsonReader implements BaseJsonReader {
 				}
 			}
 
-			// line 306 "JsonReader.rl"
+			// line 263 "JsonReader.rl"
 
 		} catch (RuntimeException ex) {
 			parseRuntimeEx = ex;
@@ -544,8 +474,8 @@ public class JsonReader implements BaseJsonReader {
 			int lineNumber = 1;
 			for (int i = 0; i < p; i++)
 				if (data[i] == '\n') lineNumber++;
-			throw new SerializationException("Error parsing JSON on line " + lineNumber + " near: "
-				+ new String(data, p, Math.min(256, pe - p)), parseRuntimeEx);
+			throw new SerializationException("Error parsing JSON on line " + lineNumber + " near: " + new String(data, p, pe - p),
+				parseRuntimeEx);
 		} else if (elements.size != 0) {
 			JsonValue element = elements.peek();
 			elements.clear();
@@ -559,7 +489,7 @@ public class JsonReader implements BaseJsonReader {
 		return root;
 	}
 
-	// line 421 "JsonReader.java"
+	// line 347 "JsonReader.java"
 	private static byte[] init__json_actions_0 () {
 		return new byte[] {0, 1, 1, 1, 2, 1, 3, 1, 4, 1, 5, 1, 6, 1, 7, 1, 8, 2, 0, 7, 2, 0, 8, 2, 1, 3, 2, 1, 5};
 	}
@@ -567,89 +497,82 @@ public class JsonReader implements BaseJsonReader {
 	private static final byte _json_actions[] = init__json_actions_0();
 
 	private static short[] init__json_key_offsets_0 () {
-		return new short[] {0, 0, 11, 13, 14, 16, 25, 31, 37, 39, 50, 57, 64, 73, 74, 83, 85, 87, 96, 98, 100, 101, 103, 105, 116,
-			123, 130, 141, 142, 153, 155, 157, 168, 170, 172, 174, 179, 184, 184};
+		return new short[] {0, 0, 12, 14, 15, 17, 29, 35, 41, 43, 55, 62, 69, 81, 82, 84, 86, 87, 89, 91, 103, 110, 117, 129, 130,
+			132, 134, 136, 141, 146, 146};
 	}
 
 	private static final short _json_key_offsets[] = init__json_key_offsets_0();
 
 	private static char[] init__json_trans_keys_0 () {
-		return new char[] {13, 32, 34, 44, 47, 58, 91, 93, 123, 9, 10, 42, 47, 34, 42, 47, 13, 32, 34, 44, 47, 58, 125, 9, 10, 13,
-			32, 47, 58, 9, 10, 13, 32, 47, 58, 9, 10, 42, 47, 13, 32, 34, 44, 47, 58, 91, 93, 123, 9, 10, 9, 10, 13, 32, 44, 47,
-			125, 9, 10, 13, 32, 44, 47, 125, 13, 32, 34, 44, 47, 58, 125, 9, 10, 34, 13, 32, 34, 44, 47, 58, 125, 9, 10, 42, 47, 42,
-			47, 13, 32, 34, 44, 47, 58, 125, 9, 10, 42, 47, 42, 47, 34, 42, 47, 42, 47, 13, 32, 34, 44, 47, 58, 91, 93, 123, 9, 10,
-			9, 10, 13, 32, 44, 47, 93, 9, 10, 13, 32, 44, 47, 93, 13, 32, 34, 44, 47, 58, 91, 93, 123, 9, 10, 34, 13, 32, 34, 44,
-			47, 58, 91, 93, 123, 9, 10, 42, 47, 42, 47, 13, 32, 34, 44, 47, 58, 91, 93, 123, 9, 10, 42, 47, 42, 47, 42, 47, 13, 32,
-			47, 9, 10, 13, 32, 47, 9, 10, 0};
+		return new char[] {13, 32, 34, 44, 47, 58, 91, 93, 123, 125, 9, 10, 42, 47, 34, 42, 47, 13, 32, 34, 44, 47, 58, 91, 93,
+			123, 125, 9, 10, 13, 32, 47, 58, 9, 10, 13, 32, 47, 58, 9, 10, 42, 47, 13, 32, 34, 44, 47, 58, 91, 93, 123, 125, 9, 10,
+			13, 32, 44, 47, 125, 9, 10, 13, 32, 44, 47, 125, 9, 10, 13, 32, 34, 44, 47, 58, 91, 93, 123, 125, 9, 10, 34, 42, 47, 42,
+			47, 34, 42, 47, 42, 47, 13, 32, 34, 44, 47, 58, 91, 93, 123, 125, 9, 10, 13, 32, 44, 47, 93, 9, 10, 13, 32, 44, 47, 93,
+			9, 10, 13, 32, 34, 44, 47, 58, 91, 93, 123, 125, 9, 10, 34, 42, 47, 42, 47, 42, 47, 13, 32, 47, 9, 10, 13, 32, 47, 9,
+			10, 0};
 	}
 
 	private static final char _json_trans_keys[] = init__json_trans_keys_0();
 
 	private static byte[] init__json_single_lengths_0 () {
-		return new byte[] {0, 9, 2, 1, 2, 7, 4, 4, 2, 9, 7, 7, 7, 1, 7, 2, 2, 7, 2, 2, 1, 2, 2, 9, 7, 7, 9, 1, 9, 2, 2, 9, 2, 2, 2,
-			3, 3, 0, 0};
+		return new byte[] {0, 10, 2, 1, 2, 10, 4, 4, 2, 10, 5, 5, 10, 1, 2, 2, 1, 2, 2, 10, 5, 5, 10, 1, 2, 2, 2, 3, 3, 0, 0};
 	}
 
 	private static final byte _json_single_lengths[] = init__json_single_lengths_0();
 
 	private static byte[] init__json_range_lengths_0 () {
-		return new byte[] {0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0,
-			1, 1, 0, 0};
+		return new byte[] {0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0};
 	}
 
 	private static final byte _json_range_lengths[] = init__json_range_lengths_0();
 
 	private static short[] init__json_index_offsets_0 () {
-		return new short[] {0, 0, 11, 14, 16, 19, 28, 34, 40, 43, 54, 62, 70, 79, 81, 90, 93, 96, 105, 108, 111, 113, 116, 119,
-			130, 138, 146, 157, 159, 170, 173, 176, 187, 190, 193, 196, 201, 206, 207};
+		return new short[] {0, 0, 12, 15, 17, 20, 32, 38, 44, 47, 59, 66, 73, 85, 87, 90, 93, 95, 98, 101, 113, 120, 127, 139, 141,
+			144, 147, 150, 155, 160, 161};
 	}
 
 	private static final short _json_index_offsets[] = init__json_index_offsets_0();
 
 	private static byte[] init__json_indicies_0 () {
-		return new byte[] {1, 1, 2, 3, 4, 3, 5, 3, 6, 1, 0, 7, 7, 3, 8, 3, 9, 9, 3, 11, 11, 12, 13, 14, 3, 15, 11, 10, 16, 16, 17,
-			18, 16, 3, 19, 19, 20, 21, 19, 3, 22, 22, 3, 21, 21, 24, 3, 25, 3, 26, 3, 27, 21, 23, 28, 29, 28, 28, 30, 31, 32, 3, 33,
-			34, 33, 33, 13, 35, 15, 3, 34, 34, 12, 36, 37, 3, 15, 34, 10, 16, 3, 36, 36, 12, 3, 38, 3, 3, 36, 10, 39, 39, 3, 40, 40,
-			3, 13, 13, 12, 3, 41, 3, 15, 13, 10, 42, 42, 3, 43, 43, 3, 28, 3, 44, 44, 3, 45, 45, 3, 47, 47, 48, 49, 50, 3, 51, 52,
-			53, 47, 46, 54, 55, 54, 54, 56, 57, 58, 3, 59, 60, 59, 59, 49, 61, 52, 3, 60, 60, 48, 62, 63, 3, 51, 52, 53, 60, 46, 54,
-			3, 62, 62, 48, 3, 64, 3, 51, 3, 53, 62, 46, 65, 65, 3, 66, 66, 3, 49, 49, 48, 3, 67, 3, 51, 52, 53, 49, 46, 68, 68, 3,
-			69, 69, 3, 70, 70, 3, 8, 8, 71, 8, 3, 72, 72, 73, 72, 3, 3, 3, 0};
+		return new byte[] {1, 1, 2, 3, 4, 3, 5, 3, 6, 3, 1, 0, 7, 7, 3, 8, 3, 9, 9, 3, 11, 11, 12, 13, 14, 3, 3, 3, 3, 15, 11, 10,
+			16, 16, 17, 18, 16, 3, 19, 19, 20, 21, 19, 3, 22, 22, 3, 21, 21, 24, 3, 25, 3, 26, 3, 27, 3, 21, 23, 28, 28, 29, 30, 31,
+			28, 3, 32, 32, 13, 33, 15, 32, 3, 13, 13, 12, 3, 34, 3, 3, 3, 3, 15, 13, 10, 16, 3, 35, 35, 3, 36, 36, 3, 28, 3, 37, 37,
+			3, 38, 38, 3, 40, 40, 41, 42, 43, 3, 44, 45, 46, 3, 40, 39, 47, 47, 48, 49, 50, 47, 3, 51, 51, 42, 52, 45, 51, 3, 42,
+			42, 41, 3, 53, 3, 44, 45, 46, 3, 42, 39, 47, 3, 54, 54, 3, 55, 55, 3, 56, 56, 3, 8, 8, 57, 8, 3, 58, 58, 59, 58, 3, 3,
+			3, 0};
 	}
 
 	private static final byte _json_indicies[] = init__json_indicies_0();
 
 	private static byte[] init__json_trans_targs_0 () {
-		return new byte[] {35, 1, 3, 0, 4, 36, 36, 36, 36, 1, 6, 5, 13, 17, 22, 37, 7, 8, 9, 7, 8, 9, 7, 10, 20, 21, 11, 11, 11,
-			12, 17, 19, 37, 11, 12, 19, 14, 16, 15, 14, 12, 18, 17, 11, 9, 5, 24, 23, 27, 31, 34, 25, 38, 25, 25, 26, 31, 33, 38,
-			25, 26, 33, 28, 30, 29, 28, 26, 32, 31, 25, 23, 2, 36, 2};
+		return new byte[] {27, 1, 3, 0, 4, 28, 28, 28, 28, 1, 6, 5, 13, 12, 18, 29, 7, 8, 9, 7, 8, 9, 7, 10, 16, 17, 11, 11, 11,
+			12, 15, 29, 11, 15, 14, 12, 11, 9, 5, 20, 19, 23, 22, 26, 21, 30, 21, 21, 22, 25, 30, 21, 25, 24, 22, 21, 19, 2, 28, 2};
 	}
 
 	private static final byte _json_trans_targs[] = init__json_trans_targs_0();
 
 	private static byte[] init__json_trans_actions_0 () {
-		return new byte[] {13, 0, 15, 0, 0, 7, 3, 11, 1, 11, 17, 0, 20, 0, 0, 5, 1, 1, 1, 0, 0, 0, 11, 13, 15, 0, 7, 3, 1, 1, 1, 1,
-			23, 0, 0, 0, 0, 0, 0, 11, 11, 0, 11, 11, 11, 11, 13, 0, 15, 0, 0, 7, 9, 3, 1, 1, 1, 1, 26, 0, 0, 0, 0, 0, 0, 11, 11, 0,
-			11, 11, 11, 1, 0, 0};
+		return new byte[] {13, 0, 15, 0, 0, 7, 3, 11, 1, 11, 17, 0, 20, 0, 0, 5, 1, 1, 1, 0, 0, 0, 11, 13, 15, 0, 7, 3, 1, 1, 1,
+			23, 0, 0, 0, 11, 11, 11, 11, 13, 0, 15, 0, 0, 7, 9, 3, 1, 1, 1, 26, 0, 0, 0, 11, 11, 11, 1, 0, 0};
 	}
 
 	private static final byte _json_trans_actions[] = init__json_trans_actions_0();
 
 	private static byte[] init__json_eof_actions_0 () {
-		return new byte[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-			1, 0, 0, 0};
+		return new byte[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0};
 	}
 
 	private static final byte _json_eof_actions[] = init__json_eof_actions_0();
 
 	static final int json_start = 1;
-	static final int json_first_final = 35;
+	static final int json_first_final = 27;
 	static final int json_error = 0;
 
 	static final int json_en_object = 5;
-	static final int json_en_array = 23;
+	static final int json_en_array = 19;
 	static final int json_en_main = 1;
 
-	// line 336 "JsonReader.rl"
+	// line 293 "JsonReader.rl"
 
 	private final Array<JsonValue> elements = new Array(8);
 	private final Array<JsonValue> lastChild = new Array(8);
diff --git a/gdx/src/com/badlogic/gdx/utils/JsonReader.rl b/gdx/src/com/badlogic/gdx/utils/JsonReader.rl
index df12130..7e3f6fb 100644
--- a/gdx/src/com/badlogic/gdx/utils/JsonReader.rl
+++ b/gdx/src/com/badlogic/gdx/utils/JsonReader.rl
@@ -101,11 +101,16 @@ public class JsonReader implements BaseJsonReader {
 				}
 			}
 
+			action buffer {
+				s = p;
+				needsUnescape = false;
+			}
 			action name {
 				stringIsName = true;
 			}
 			action string {
 				String value = new String(data, s, p - s);
+				s = p;
 				if (needsUnescape) value = unescape(value);
 				outer:
 				if (stringIsName) {
@@ -126,57 +131,24 @@ public class JsonReader implements BaseJsonReader {
 						} else if (value.equals("null")) {
 							string(name, null);
 							break outer;
-						}
-						boolean couldBeDouble = false, couldBeLong = true;
-						outer2:
-						for (int i = s; i < p; i++) {
-							switch (data[i]) {
-							case '0':
-							case '1':
-							case '2':
-							case '3':
-							case '4':
-							case '5':
-							case '6':
-							case '7':
-							case '8':
-							case '9':
-							case '-':
-							case '+':
-								break;
-							case '.':
-							case 'e':
-							case 'E':
-								couldBeDouble = true;
-								couldBeLong = false;
-								break;
-							default:
-								couldBeDouble = false;
-								couldBeLong = false;
-								break outer2;
-							}
-						}
-						if (couldBeDouble) {
+						} else if (value.indexOf('.') != -1) {
 							try {
 								if (debug) System.out.println("double: " + name + "=" + Double.parseDouble(value));
 								number(name, Double.parseDouble(value));
 								break outer;
-							} catch (NumberFormatException ignored) {
-							}
-						} else if (couldBeLong) {
-							if (debug) System.out.println("double: " + name + "=" + Double.parseDouble(value));
+							} catch (NumberFormatException ignored) {}
+						} else {
 							try {
+								if (debug) System.out.println("double: " + name + "=" + Double.parseDouble(value));
 								number(name, Long.parseLong(value));
 								break outer;
-							} catch (NumberFormatException ignored) {
-							}
+							} catch (NumberFormatException ignored) {}
 						}
 					}
 					if (debug) System.out.println("string: " + name + "=" + value);
 					string(name, value);
 				}
 				stringIsUnquoted = false;
-				s = p;
 			}
 			action startObject {
 				String name = names.size > 0 ? names.pop() : null;
@@ -201,17 +173,15 @@ public class JsonReader implements BaseJsonReader {
 				fret;
 			}
 			action comment {
-				int start = p - 1;
+				if (debug) System.out.println("comment /" + data[p]);
 				if (data[p++] == '/') {
-					while (p != eof && data[p] != '\n')
+					while (data[p] != '\n')
 						p++;
-					p--;
 				} else {
-					while (p + 1 < eof && data[p] != '*' || data[p + 1] != '/')
+					while (data[p] != '*' || data[p + 1] != '/')
 						p++;
 					p++;
 				}
-				if (debug) System.out.println("comment " + new String(data, start, p - start));
 			}
 			action unquotedChars {
 				if (debug) System.out.println("unquotedChars");
@@ -225,17 +195,14 @@ public class JsonReader implements BaseJsonReader {
 						case '\\':
 							needsUnescape = true;
 							break;
-						case '/':
-							if (p + 1 == eof) break;
-							char c = data[p + 1];
-							if (c == '/' || c == '*') break outer;
-							break;
 						case ':':
+						case ' ':
 						case '\r':
 						case '\n':
+						case '\t':
 							break outer;
 						}
-						if (debug) System.out.println("unquotedChar (name): '" + data[p] + "'");
+						// if (debug) System.out.println("unquotedChar (name): '" + data[p] + "'");
 						p++;
 						if (p == eof) break;
 					}
@@ -246,26 +213,21 @@ public class JsonReader implements BaseJsonReader {
 						case '\\':
 							needsUnescape = true;
 							break;
-						case '/':
-							if (p + 1 == eof) break;
-							char c = data[p + 1];
-							if (c == '/' || c == '*') break outer;
-							break;
 						case '}':
 						case ']':
 						case ',':
+						case ' ':
 						case '\r':
 						case '\n':
+						case '\t':
 							break outer;
 						}
-						if (debug) System.out.println("unquotedChar (value): '" + data[p] + "'");
+						// if (debug) System.out.println("unquotedChar (value): '" + data[p] + "'");
 						p++;
 						if (p == eof) break;
 					}
 				}
 				p--;
-				while (data[p] == ' ')
-					p--;
 			}
 			action quotedChars {
 				if (debug) System.out.println("quotedChars");
@@ -288,17 +250,12 @@ public class JsonReader implements BaseJsonReader {
 				p--;
 			}
 
-			comment = ('//' | '/*') @comment;
-			ws = [\r\n\t ] | comment;
-			ws2 = [\r\t ] | comment;
-			comma = ',' | ('\n' ws* ','?);
-			quotedString = '"' @quotedChars %string '"';
-			nameString = quotedString | ^[":,}/\r\n\t ] >unquotedChars %string;
-			valueString = quotedString | ^[":,{[\]/\r\n\t ] >unquotedChars %string;
-			value = '{' @startObject | '[' @startArray | valueString;
-			nameValue = nameString >name ws* ':' ws* value;
-			object := ws* nameValue? ws2* <: (comma ws* nameValue ws2*)** :>> (','? ws* '}' @endObject);
-			array := ws* value? ws2* <: (comma ws* value ws2*)** :>> (','? ws* ']' @endArray);
+			ws = [ \r\n\t] | (('//' | '/*') @comment);
+			string = '"' @quotedChars %string '"' | ^[/{}\[\],:"\r\n\t ] >unquotedChars %string;
+			value = '{' @startObject | '[' @startArray | string;
+			nameValue = string >name ws* ':' ws* value;
+			object := ws* nameValue? ws* (',' ws* nameValue ws*)** ','? ws* '}' @endObject;
+			array := ws* value? ws* (',' ws* value ws*)** ','? ws* ']' @endArray;
 			main := ws* value ws*;
 
 			write init;
@@ -317,8 +274,8 @@ public class JsonReader implements BaseJsonReader {
 			int lineNumber = 1;
 			for (int i = 0; i < p; i++)
 				if (data[i] == '\n') lineNumber++;
-			throw new SerializationException("Error parsing JSON on line " + lineNumber + " near: "
-				+ new String(data, p, Math.min(256, pe - p)), parseRuntimeEx);
+			throw new SerializationException("Error parsing JSON on line " + lineNumber + " near: " + new String(data, p, pe - p),
+				parseRuntimeEx);
 		} else if (elements.size != 0) {
 			JsonValue element = elements.peek();
 			elements.clear();
diff --git a/gdx/src/com/badlogic/gdx/utils/JsonValue.java b/gdx/src/com/badlogic/gdx/utils/JsonValue.java
index 79886d0..7a4231f 100644
--- a/gdx/src/com/badlogic/gdx/utils/JsonValue.java
+++ b/gdx/src/com/badlogic/gdx/utils/JsonValue.java
@@ -16,11 +16,11 @@
 
 package com.badlogic.gdx.utils;
 
+import com.badlogic.gdx.utils.JsonWriter.OutputType;
+
 import java.util.Iterator;
 import java.util.NoSuchElementException;
 
-import com.badlogic.gdx.utils.JsonWriter.OutputType;
-
 /** Container for a JSON object, array, string, double, long, boolean, or null.
  * <p>
  * JsonValue children are a linked list. Iteration of arrays or objects is easily done using a for loop, either with the enhanced
@@ -894,7 +894,7 @@ public class JsonValue implements Iterable<JsonValue> {
 		if (isValue())
 			return name == null ? asString() : name + ": " + asString();
 		else
-			return (name == null ? "" : name + ": ") + prettyPrint(OutputType.minimal, 0);
+			return prettyPrint(OutputType.minimal, 0);
 	}
 
 	public String prettyPrint (OutputType outputType, int singleLineColumns) {
@@ -911,9 +911,8 @@ public class JsonValue implements Iterable<JsonValue> {
 	}
 
 	private void prettyPrint (JsonValue object, StringBuilder buffer, int indent, PrettyPrintSettings settings) {
-		OutputType outputType = settings.outputType;
 		if (object.isObject()) {
-			if (object.child == null) {
+			if (object.child() == null) {
 				buffer.append("{}");
 			} else {
 				boolean newLines = !isFlat(object);
@@ -922,12 +921,12 @@ public class JsonValue implements Iterable<JsonValue> {
 				while (true) {
 					buffer.append(newLines ? "{\n" : "{ ");
 					int i = 0;
-					for (JsonValue child = object.child; child != null; child = child.next) {
+					for (JsonValue child = object.child(); child != null; child = child.next()) {
 						if (newLines) indent(indent, buffer);
-						buffer.append(outputType.quoteName(child.name));
+						buffer.append(settings.outputType.quoteName(child.name()));
 						buffer.append(": ");
 						prettyPrint(child, buffer, indent + 1, settings);
-						if ((!newLines || outputType != OutputType.minimal) && child.next != null) buffer.append(',');
+						if (child.next() != null) buffer.append(",");
 						buffer.append(newLines ? '\n' : ' ');
 						if (!newLines && buffer.length() - start > settings.singleLineColumns) {
 							buffer.setLength(start);
@@ -941,7 +940,7 @@ public class JsonValue implements Iterable<JsonValue> {
 				buffer.append('}');
 			}
 		} else if (object.isArray()) {
-			if (object.child == null) {
+			if (object.child() == null) {
 				buffer.append("[]");
 			} else {
 				boolean newLines = !isFlat(object);
@@ -950,10 +949,10 @@ public class JsonValue implements Iterable<JsonValue> {
 				outer:
 				while (true) {
 					buffer.append(newLines ? "[\n" : "[ ");
-					for (JsonValue child = object.child; child != null; child = child.next) {
+					for (JsonValue child = object.child(); child != null; child = child.next()) {
 						if (newLines) indent(indent, buffer);
 						prettyPrint(child, buffer, indent + 1, settings);
-						if ((!newLines || outputType != OutputType.minimal) && child.next != null) buffer.append(',');
+						if (child.next() != null) buffer.append(",");
 						buffer.append(newLines ? '\n' : ' ');
 						if (wrap && !newLines && buffer.length() - start > settings.singleLineColumns) {
 							buffer.setLength(start);
@@ -967,7 +966,7 @@ public class JsonValue implements Iterable<JsonValue> {
 				buffer.append(']');
 			}
 		} else if (object.isString()) {
-			buffer.append(outputType.quoteValue(object.asString()));
+			buffer.append(settings.outputType.quoteValue(object.asString()));
 		} else if (object.isDouble()) {
 			double doubleValue = object.asDouble();
 			long longValue = object.asLong();
@@ -983,13 +982,13 @@ public class JsonValue implements Iterable<JsonValue> {
 	}
 
 	static private boolean isFlat (JsonValue object) {
-		for (JsonValue child = object.child; child != null; child = child.next)
+		for (JsonValue child = object.child(); child != null; child = child.next())
 			if (child.isObject() || child.isArray()) return false;
 		return true;
 	}
 
 	static private boolean isNumeric (JsonValue object) {
-		for (JsonValue child = object.child; child != null; child = child.next)
+		for (JsonValue child = object.child(); child != null; child = child.next())
 			if (!child.isNumber()) return false;
 		return true;
 	}
diff --git a/gdx/src/com/badlogic/gdx/utils/JsonWriter.java b/gdx/src/com/badlogic/gdx/utils/JsonWriter.java
index c6cdf8b..69b2649 100644
--- a/gdx/src/com/badlogic/gdx/utils/JsonWriter.java
+++ b/gdx/src/com/badlogic/gdx/utils/JsonWriter.java
@@ -171,31 +171,21 @@ public class JsonWriter extends Writer {
 		json,
 		/** Like JSON, but names are only quoted if necessary. */
 		javascript,
-		/** Like JSON, but:
-		 * <ul>
-		 * <li>Names only require quotes if they start with <code>space</code> or any of <code>":,}/</code> or they contain
-		 * <code>//</code> or <code>/*</code> or <code>:</code>.
-		 * <li>Values only require quotes if they start with <code>space</code> or any of <code>":,{[]/</code> or they contain
-		 * <code>//</code> or <code>/*</code> or any of <code>}],</code> or they are equal to <code>true</code>, <code>false</code>
-		 * , or <code>null</code>.
-		 * <li>Newlines are treated as commas, making commas optional in many cases.
-		 * <li>C style comments may be used: <code>//...</code> or <code>/*...*<b></b>/</code>
-		 * </ul> */
+		/** Like JSON, but names and values are only quoted if they don't contain <code>\r\n\t</code> or <code>space</code> and don't
+		 * begin with <code>/{}[]:,"</code>. Additionally, names cannot contain <code>:</code> and values cannot contain
+		 * <code>}],</code>. */
 		minimal;
 
-		static private Pattern javascriptPattern = Pattern.compile("^[a-zA-Z_$][a-zA-Z_$0-9]*$");
-		static private Pattern minimalNamePattern = Pattern.compile("^[^\":,}/ ][^:]*$");
-		static private Pattern minimalValuePattern = Pattern.compile("^[^\":,{\\[\\]/ ][^}\\],]*$");
+		static private Pattern javascriptPattern = Pattern.compile("[a-zA-Z_$][a-zA-Z_$0-9]*");
+		static private Pattern minimalNamePattern = Pattern.compile("[^/{}\\[\\],\":\\r\\n\\t ][^:\\r\\n\\t ]*");
+		static private Pattern minimalValuePattern = Pattern.compile("[^/{}\\[\\],\":\\r\\n\\t ][^}\\],\\r\\n\\t ]*");
 
 		public String quoteValue (Object value) {
 			if (value == null || value instanceof Number || value instanceof Boolean) return String.valueOf(value);
 			String string = String.valueOf(value).replace("\\", "\\\\").replace("\r", "\\r").replace("\n", "\\n")
 				.replace("\t", "\\t");
 			if (this == OutputType.minimal && !string.equals("true") && !string.equals("false") && !string.equals("null")
-				&& !string.contains("//") && !string.contains("/*")) {
-				int length = string.length();
-				if (length > 0 && string.charAt(length - 1) != ' ' && minimalValuePattern.matcher(string).matches()) return string;
-			}
+				&& minimalValuePattern.matcher(string).matches()) return string;
 			return '"' + string.replace("\"", "\\\"") + '"';
 		}
 
@@ -203,7 +193,7 @@ public class JsonWriter extends Writer {
 			value = value.replace("\\", "\\\\").replace("\r", "\\r").replace("\n", "\\n").replace("\t", "\\t");
 			switch (this) {
 			case minimal:
-				if (!value.contains("//") && !value.contains("/*") && minimalNamePattern.matcher(value).matches()) return value;
+				if (minimalNamePattern.matcher(value).matches()) return value;
 			case javascript:
 				if (javascriptPattern.matcher(value).matches()) return value;
 			}
diff --git a/gdx/src/com/badlogic/gdx/utils/ObjectFloatMap.java b/gdx/src/com/badlogic/gdx/utils/ObjectFloatMap.java
index 5978287..ea49477 100644
--- a/gdx/src/com/badlogic/gdx/utils/ObjectFloatMap.java
+++ b/gdx/src/com/badlogic/gdx/utils/ObjectFloatMap.java
@@ -513,7 +513,7 @@ public class ObjectFloatMap<K> implements Iterable<ObjectFloatMap.Entry<K>> {
 		return buffer.toString();
 	}
 
-	public Entries<K> iterator () {
+	public Iterator<Entry<K>> iterator () {
 		return entries();
 	}
 
@@ -650,7 +650,7 @@ public class ObjectFloatMap<K> implements Iterable<ObjectFloatMap.Entry<K>> {
 			return hasNext;
 		}
 
-		public Entries<K> iterator () {
+		public Iterator<Entry<K>> iterator () {
 			return this;
 		}
 
@@ -706,7 +706,7 @@ public class ObjectFloatMap<K> implements Iterable<ObjectFloatMap.Entry<K>> {
 			return key;
 		}
 
-		public Keys<K> iterator () {
+		public Iterator<K> iterator () {
 			return this;
 		}
 
@@ -718,13 +718,6 @@ public class ObjectFloatMap<K> implements Iterable<ObjectFloatMap.Entry<K>> {
 			return array;
 		}
 
-		/** Adds the remaining keys to the array. */
-		public Array<K> toArray (Array<K> array) {
-			while (hasNext)
-				array.add(next());
-			return array;
-		}
-
 		public void remove () {
 			super.remove();
 		}
diff --git a/gdx/src/com/badlogic/gdx/utils/ObjectIntMap.java b/gdx/src/com/badlogic/gdx/utils/ObjectIntMap.java
index 315ce11..bf3ba68 100644
--- a/gdx/src/com/badlogic/gdx/utils/ObjectIntMap.java
+++ b/gdx/src/com/badlogic/gdx/utils/ObjectIntMap.java
@@ -513,7 +513,7 @@ public class ObjectIntMap<K> implements Iterable<ObjectIntMap.Entry<K>> {
 		return buffer.toString();
 	}
 
-	public Entries<K> iterator () {
+	public Iterator<Entry<K>> iterator () {
 		return entries();
 	}
 
@@ -650,7 +650,7 @@ public class ObjectIntMap<K> implements Iterable<ObjectIntMap.Entry<K>> {
 			return hasNext;
 		}
 
-		public Entries<K> iterator () {
+		public Iterator<Entry<K>> iterator () {
 			return this;
 		}
 
@@ -706,7 +706,7 @@ public class ObjectIntMap<K> implements Iterable<ObjectIntMap.Entry<K>> {
 			return key;
 		}
 
-		public Keys<K> iterator () {
+		public Iterator<K> iterator () {
 			return this;
 		}
 
@@ -718,13 +718,6 @@ public class ObjectIntMap<K> implements Iterable<ObjectIntMap.Entry<K>> {
 			return array;
 		}
 
-		/** Adds the remaining keys to the array. */
-		public Array<K> toArray (Array<K> array) {
-			while (hasNext)
-				array.add(next());
-			return array;
-		}
-
 		public void remove () {
 			super.remove();
 		}
diff --git a/gdx/src/com/badlogic/gdx/utils/ObjectMap.java b/gdx/src/com/badlogic/gdx/utils/ObjectMap.java
index 35008e3..7b93be2 100644
--- a/gdx/src/com/badlogic/gdx/utils/ObjectMap.java
+++ b/gdx/src/com/badlogic/gdx/utils/ObjectMap.java
@@ -553,7 +553,7 @@ public class ObjectMap<K, V> implements Iterable<ObjectMap.Entry<K, V>> {
 		return buffer.toString();
 	}
 
-	public Entries<K, V> iterator () {
+	public Iterator<Entry<K, V>> iterator () {
 		return entries();
 	}
 
@@ -691,7 +691,7 @@ public class ObjectMap<K, V> implements Iterable<ObjectMap.Entry<K, V>> {
 			return hasNext;
 		}
 
-		public Entries<K, V> iterator () {
+		public Iterator<Entry<K, V>> iterator () {
 			return this;
 		}
 	}
@@ -715,7 +715,7 @@ public class ObjectMap<K, V> implements Iterable<ObjectMap.Entry<K, V>> {
 			return value;
 		}
 
-		public Values<V> iterator () {
+		public Iterator<V> iterator () {
 			return this;
 		}
 
@@ -751,7 +751,7 @@ public class ObjectMap<K, V> implements Iterable<ObjectMap.Entry<K, V>> {
 			return key;
 		}
 
-		public Keys<K> iterator () {
+		public Iterator<K> iterator () {
 			return this;
 		}
 
diff --git a/gdx/src/com/badlogic/gdx/utils/ObjectSet.java b/gdx/src/com/badlogic/gdx/utils/ObjectSet.java
index 2815637..3765f60 100644
--- a/gdx/src/com/badlogic/gdx/utils/ObjectSet.java
+++ b/gdx/src/com/badlogic/gdx/utils/ObjectSet.java
@@ -509,7 +509,7 @@ public class ObjectSet<T> implements Iterable<T> {
 			return key;
 		}
 
-		public ObjectSetIterator<K> iterator () {
+		public Iterator<K> iterator () {
 			return this;
 		}
 
diff --git a/gdx/src/com/badlogic/gdx/utils/OrderedMap.java b/gdx/src/com/badlogic/gdx/utils/OrderedMap.java
index c843293..d62d45f 100644
--- a/gdx/src/com/badlogic/gdx/utils/OrderedMap.java
+++ b/gdx/src/com/badlogic/gdx/utils/OrderedMap.java
@@ -19,8 +19,6 @@ package com.badlogic.gdx.utils;
 import java.util.Iterator;
 import java.util.NoSuchElementException;
 
-import com.badlogic.gdx.utils.ObjectMap.Entries;
-
 /** An {@link ObjectMap} that also stores keys in an {@link Array} using the insertion order. There is some additional overhead for
  * put and remove. Iteration over the {@link #entries()}, {@link #keys()}, and {@link #values()} is ordered and faster than an
  * unordered map. Keys can also be accessed and the order changed using {@link #orderedKeys()}.
@@ -75,7 +73,7 @@ public class OrderedMap<K, V> extends ObjectMap<K, V> {
 		return keys;
 	}
 
-	public Entries<K, V> iterator () {
+	public Iterator<Entry<K, V>> iterator () {
 		return entries();
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/utils/Pools.java b/gdx/src/com/badlogic/gdx/utils/Pools.java
index 305f178..411da44 100644
--- a/gdx/src/com/badlogic/gdx/utils/Pools.java
+++ b/gdx/src/com/badlogic/gdx/utils/Pools.java
@@ -16,15 +16,15 @@
 
 package com.badlogic.gdx.utils;
 
-/** Stores a map of {@link Pool}s (usually {@link ReflectionPool}s) by type for convenient static access.
+/** Stores a map of {@link ReflectionPool}s by type for convenient static access.
  * @author Nathan Sweet */
 public class Pools {
-	static private final ObjectMap<Class, Pool> typePools = new ObjectMap();
+	static private final ObjectMap<Class, ReflectionPool> typePools = new ObjectMap();
 
-	/** Returns a new or existing pool for the specified type, stored in a Class to {@link Pool} map. Note the max size is ignored
-	 * if this is not the first time this pool has been requested. */
+	/** Returns a new or existing pool for the specified type, stored in a a Class to {@link ReflectionPool} map. Note the max size
+	 * is ignored if this is not the first time this pool has been requested. */
 	static public <T> Pool<T> get (Class<T> type, int max) {
-		Pool pool = typePools.get(type);
+		ReflectionPool pool = typePools.get(type);
 		if (pool == null) {
 			pool = new ReflectionPool(type, 4, max);
 			typePools.put(type, pool);
@@ -32,26 +32,21 @@ public class Pools {
 		return pool;
 	}
 
-	/** Returns a new or existing pool for the specified type, stored in a Class to {@link Pool} map. The max size of the pool used
-	 * is 100. */
+	/** Returns a new or existing pool for the specified type, stored in a a Class to {@link ReflectionPool} map. The max size of
+	 * the pool used is 100. */
 	static public <T> Pool<T> get (Class<T> type) {
 		return get(type, 100);
 	}
 
-	/** Sets an existing pool for the specified type, stored in a Class to {@link Pool} map. */
-	static public <T> void set (Class<T> type, Pool<T> pool) {
-		typePools.put(type, pool);
-	}
-
 	/** Obtains an object from the {@link #get(Class) pool}. */
 	static public <T> T obtain (Class<T> type) {
-		return get(type).obtain();
+		return (T)get(type).obtain();
 	}
 
 	/** Frees an object from the {@link #get(Class) pool}. */
 	static public void free (Object object) {
-		if (object == null) throw new IllegalArgumentException("Object cannot be null.");
-		Pool pool = typePools.get(object.getClass());
+		if (object == null) throw new IllegalArgumentException("object cannot be null.");
+		ReflectionPool pool = typePools.get(object.getClass());
 		if (pool == null) return; // Ignore freeing an object that was never retained.
 		pool.free(object);
 	}
@@ -65,8 +60,8 @@ public class Pools {
 	/** Frees the specified objects from the {@link #get(Class) pool}. Null objects within the array are silently ignored.
 	 * @param samePool If true, objects don't need to be from the same pool but the pool must be looked up for each object. */
 	static public void freeAll (Array objects, boolean samePool) {
-		if (objects == null) throw new IllegalArgumentException("Objects cannot be null.");
-		Pool pool = null;
+		if (objects == null) throw new IllegalArgumentException("objects cannot be null.");
+		ReflectionPool pool = null;
 		for (int i = 0, n = objects.size; i < n; i++) {
 			Object object = objects.get(i);
 			if (object == null) continue;
diff --git a/gdx/src/com/badlogic/gdx/utils/Scaling.java b/gdx/src/com/badlogic/gdx/utils/Scaling.java
index 480ca98..d399079 100644
--- a/gdx/src/com/badlogic/gdx/utils/Scaling.java
+++ b/gdx/src/com/badlogic/gdx/utils/Scaling.java
@@ -67,12 +67,16 @@ public enum Scaling {
 			break;
 		}
 		case fillX: {
+			float targetRatio = targetHeight / targetWidth;
+			float sourceRatio = sourceHeight / sourceWidth;
 			float scale = targetWidth / sourceWidth;
 			temp.x = sourceWidth * scale;
 			temp.y = sourceHeight * scale;
 			break;
 		}
 		case fillY: {
+			float targetRatio = targetHeight / targetWidth;
+			float sourceRatio = sourceHeight / sourceWidth;
 			float scale = targetHeight / sourceHeight;
 			temp.x = sourceWidth * scale;
 			temp.y = sourceHeight * scale;
diff --git a/gdx/src/com/badlogic/gdx/utils/Timer.java b/gdx/src/com/badlogic/gdx/utils/Timer.java
index 0c84c96..65cdf1d 100644
--- a/gdx/src/com/badlogic/gdx/utils/Timer.java
+++ b/gdx/src/com/badlogic/gdx/utils/Timer.java
@@ -45,22 +45,22 @@ public class Timer {
 	}
 
 	/** Schedules a task to occur once as soon as possible, but not sooner than the start of the next frame. */
-	public Task postTask (Task task) {
-		return scheduleTask(task, 0, 0, 0);
+	public void postTask (Task task) {
+		scheduleTask(task, 0, 0, 0);
 	}
 
 	/** Schedules a task to occur once after the specified delay. */
-	public Task scheduleTask (Task task, float delaySeconds) {
-		return scheduleTask(task, delaySeconds, 0, 0);
+	public void scheduleTask (Task task, float delaySeconds) {
+		scheduleTask(task, delaySeconds, 0, 0);
 	}
 
 	/** Schedules a task to occur once after the specified delay and then repeatedly at the specified interval until cancelled. */
-	public Task scheduleTask (Task task, float delaySeconds, float intervalSeconds) {
-		return scheduleTask(task, delaySeconds, intervalSeconds, FOREVER);
+	public void scheduleTask (Task task, float delaySeconds, float intervalSeconds) {
+		scheduleTask(task, delaySeconds, intervalSeconds, FOREVER);
 	}
 
 	/** Schedules a task to occur once after the specified delay and then a number of additional times at the specified interval. */
-	public Task scheduleTask (Task task, float delaySeconds, float intervalSeconds, int repeatCount) {
+	public void scheduleTask (Task task, float delaySeconds, float intervalSeconds, int repeatCount) {
 		if (task.repeatCount != CANCELLED) throw new IllegalArgumentException("The same task may not be scheduled twice.");
 		task.executeTimeMillis = System.nanoTime() / 1000000 + (long)(delaySeconds * 1000);
 		task.intervalMillis = (long)(intervalSeconds * 1000);
@@ -69,8 +69,6 @@ public class Timer {
 			tasks.add(task);
 		}
 		wake();
-		
-		return task;
 	}
 
 	/** Stops the timer, tasks will not be executed and time that passes will not be applied to the task delays. */
@@ -146,26 +144,26 @@ public class Timer {
 
 	/** Schedules a task on {@link #instance}.
 	 * @see #postTask(Task) */
-	static public Task post (Task task) {
-		return instance().postTask(task);
+	static public void post (Task task) {
+		instance().postTask(task);
 	}
 
 	/** Schedules a task on {@link #instance}.
 	 * @see #scheduleTask(Task, float) */
-	static public Task schedule (Task task, float delaySeconds) {
-		return instance().scheduleTask(task, delaySeconds);
+	static public void schedule (Task task, float delaySeconds) {
+		instance().scheduleTask(task, delaySeconds);
 	}
 
 	/** Schedules a task on {@link #instance}.
 	 * @see #scheduleTask(Task, float, float) */
-	static public Task schedule (Task task, float delaySeconds, float intervalSeconds) {
-		return instance().scheduleTask(task, delaySeconds, intervalSeconds);
+	static public void schedule (Task task, float delaySeconds, float intervalSeconds) {
+		instance().scheduleTask(task, delaySeconds, intervalSeconds);
 	}
 
 	/** Schedules a task on {@link #instance}.
 	 * @see #scheduleTask(Task, float, float, int) */
-	static public Task schedule (Task task, float delaySeconds, float intervalSeconds, int repeatCount) {
-		return instance().scheduleTask(task, delaySeconds, intervalSeconds, repeatCount);
+	static public void schedule (Task task, float delaySeconds, float intervalSeconds, int repeatCount) {
+		instance().scheduleTask(task, delaySeconds, intervalSeconds, repeatCount);
 	}
 
 	/** Runnable with a cancel method.
diff --git a/gdx/src/com/badlogic/gdx/utils/UBJsonReader.java b/gdx/src/com/badlogic/gdx/utils/UBJsonReader.java
index 9dc3220..2a33f84 100644
--- a/gdx/src/com/badlogic/gdx/utils/UBJsonReader.java
+++ b/gdx/src/com/badlogic/gdx/utils/UBJsonReader.java
@@ -120,7 +120,6 @@ public class UBJsonReader implements BaseJsonReader {
 		while (din.available() > 0 && type != ']') {
 			final JsonValue val = parse(din, type);
 			if (prev != null) {
-				val.prev = prev;
 				prev.next = val;
 				result.size++;
 			} else {
@@ -156,7 +155,6 @@ public class UBJsonReader implements BaseJsonReader {
 			final JsonValue child = parse(din, valueType == 0 ? din.readByte() : valueType);
 			child.setName(key);
 			if (prev != null) {
-				child.prev = prev;
 				prev.next = child;
 				result.size++;
 			} else {
diff --git a/gdx/src/com/badlogic/gdx/utils/UBJsonWriter.java b/gdx/src/com/badlogic/gdx/utils/UBJsonWriter.java
index 7920eed..10911e4 100644
--- a/gdx/src/com/badlogic/gdx/utils/UBJsonWriter.java
+++ b/gdx/src/com/badlogic/gdx/utils/UBJsonWriter.java
@@ -341,46 +341,6 @@ public class UBJsonWriter implements Closeable {
 		return this;
 	}
 
-	/** Appends the given JsonValue, including all its fields recursively, to the stream.
-	 * @return this writer, for chaining */
-	public UBJsonWriter value (JsonValue value) throws IOException {
-		if (value.isObject()) {
-			if (value.name != null)
-				object(value.name);
-			else
-				object();
-			for (JsonValue child = value.child; child != null; child = child.next)
-				value(child);
-			pop();
-		} else if (value.isArray()) {
-			if (value.name != null)
-				array(value.name);
-			else
-				array();
-			for (JsonValue child = value.child; child != null; child = child.next)
-				value(child);
-			pop();
-		} else if (value.isBoolean()) {
-			if (value.name != null) name(value.name);
-			value(value.asBoolean());
-		} else if (value.isDouble()) {
-			if (value.name != null) name(value.name);
-			value(value.asDouble());
-		} else if (value.isLong()) {
-			if (value.name != null) name(value.name);
-			value(value.asLong());
-		} else if (value.isString()) {
-			if (value.name != null) name(value.name);
-			value(value.asString());
-		} else if (value.isNull()) {
-			if (value.name != null) name(value.name);
-			value();
-		} else {
-			throw new IOException("Unhandled JsonValue type");
-		}
-		return this;
-	}
-
 	/** Appends the object to the stream, if it is a known value type. This is a convenience method that calls through to the
 	 * appropriate value method.
 	 * @return this writer, for chaining */
diff --git a/pom.xml b/pom.xml
index 3819094..5921ed2 100644
--- a/pom.xml
+++ b/pom.xml
@@ -10,7 +10,7 @@
   <groupId>com.badlogicgames.gdx</groupId>
   <artifactId>gdx-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.5.4-SNAPSHOT</version>
+  <version>1.4.2-SNAPSHOT</version>
 
   <name>libGDX Parent</name>
   <description>Android/Desktop/iOS/HTML5 game development framework.</description>
@@ -44,9 +44,9 @@
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
     <android.version>4.4</android.version>
     <gwt.version>2.6.0</gwt.version>
-    <lwjgl.version>2.9.2</lwjgl.version>
+    <lwjgl.version>2.9.1</lwjgl.version>
     <jglfw.version>1.1</jglfw.version>
-    <robovm.version>1.0.0-beta-03</robovm.version>
+    <robovm.version>1.0.0-SNAPSHOT</robovm.version>
   </properties>
 
   <modules>
diff --git a/tests/gdx-tests-android/assets/data/cubemap.zktx b/tests/gdx-tests-android/assets/data/cubemap.zktx
deleted file mode 100644
index 534146f..0000000
Binary files a/tests/gdx-tests-android/assets/data/cubemap.zktx and /dev/null differ
diff --git a/tests/gdx-tests-android/assets/data/egg.zktx b/tests/gdx-tests-android/assets/data/egg.zktx
deleted file mode 100644
index be57ea9..0000000
Binary files a/tests/gdx-tests-android/assets/data/egg.zktx and /dev/null differ
diff --git a/tests/gdx-tests-android/assets/data/maps/tiled-objects/Start.bmp b/tests/gdx-tests-android/assets/data/maps/tiled-objects/Start.bmp
deleted file mode 100644
index 820fd1a..0000000
Binary files a/tests/gdx-tests-android/assets/data/maps/tiled-objects/Start.bmp and /dev/null differ
diff --git a/tests/gdx-tests-android/assets/data/maps/tiled-objects/test-load-mapobjects.tmx b/tests/gdx-tests-android/assets/data/maps/tiled-objects/test-load-mapobjects.tmx
deleted file mode 100644
index 70e39c8..0000000
--- a/tests/gdx-tests-android/assets/data/maps/tiled-objects/test-load-mapobjects.tmx
+++ /dev/null
@@ -1,24 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<map version="1.0" orientation="orthogonal" renderorder="right-down" width="16" height="16" tilewidth="32" tileheight="32" nextobjectid="14">
- <tileset firstgid="1" name="Test" tilewidth="256" tileheight="256">
-  <tile id="0">
-   <image width="32" height="32" source="Start.bmp"/>
-  </tile>
-  <tile id="1">
-   <image width="32" height="32" source="../../badlogicsmall.jpg"/>
-  </tile>
-  <tile id="2">
-   <image width="256" height="256" source="../../badlogic.jpg"/>
-  </tile>
- </tileset>
- <objectgroup name="Objects">
-  <object id="3" name="Ellipse" x="59.3333" y="335" width="130" height="87">
-   <ellipse/>
-  </object>
-  <object id="5" name="Polygon" x="238.667" y="351.333">
-   <polygon points="0,0 78,-4 32,73"/>
-  </object>
-  <object id="9" name="Rectangle" x="340" y="341.333" width="118.667" height="100"/>
-  <object id="12" name="Texture" gid="3" x="128" y="298.667"/>
- </objectgroup>
-</map>
diff --git a/tests/gdx-tests-android/assets/data/maps/tiled/super-koalio/koalio-single.png b/tests/gdx-tests-android/assets/data/maps/tiled/super-koalio/koalio-single.png
deleted file mode 100644
index 068583c..0000000
Binary files a/tests/gdx-tests-android/assets/data/maps/tiled/super-koalio/koalio-single.png and /dev/null differ
diff --git a/tests/gdx-tests-android/assets/data/maps/tiled/super-koalio/level1.tmx b/tests/gdx-tests-android/assets/data/maps/tiled/super-koalio/level1.tmx
index 5d5ee05..419496f 100755
--- a/tests/gdx-tests-android/assets/data/maps/tiled/super-koalio/level1.tmx
+++ b/tests/gdx-tests-android/assets/data/maps/tiled/super-koalio/level1.tmx
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<map version="1.0" orientation="orthogonal" renderorder="right-down" width="212" height="20" tilewidth="16" tileheight="16" nextobjectid="1">
+<map version="1.0" orientation="orthogonal" width="212" height="20" tilewidth="16" tileheight="16">
  <tileset firstgid="1" name="tileSet-hd" tilewidth="16" tileheight="16">
   <image source="tileSet.png" trans="fe80fe" width="256" height="256"/>
  </tileset>
@@ -8,15 +8,9 @@
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIoAAACLAAAAjAAAAI0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACKAAAAiwAAAIwAAACNAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACKAAAAiwAAAIwAAACNAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAmgAAAJsAAACcAAAAnQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJoAAACbAAAAnAAAAJ0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJoAAACbAAAAnAAAAJ0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKEAAACiAAAAowAAAKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAChAAAAogAAAKMAAACkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAigAAAIsAAACMAAAAjQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsQAAALIAAACzAAAAtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALEAAACyAAAAswAAALQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACaAAAAmwAAAJwAAACdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoQAAAKIAAACjAAAApAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoQAAAKIAAACjAAAApAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIoAAACLAAAAjAAAAI0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACKAAAAiwAAAIwAAACNAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACxAAAAsgAAALMAAAC0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACKAAAAiwAAAIwAAACNAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACxAAAAsgAAALMAAAC0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAmgAAAJsAAACcAAAAnQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARAAAAEgAAABMAAAAUAAAAFQAAABYAAAAXAAAAGAAAABkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoQAAAKIAAACjAAAApAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJoAAACbAAAAnAAAAJ0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJoAAACbAAAAnAAAAJ0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKEAAACiAAAAowAAAKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACEAAAAiAAAAIwAAACQAAAAlAAAAJgAAACcAAAAoAAAAKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACxAAAAsgAAALMAAAC0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKEAAACiAAAAowAAAKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsQAAALIAAACzAAAAtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMQAAADIAAAAzAAAANAAAADUAAAA2AAAANwAAADgAAAA5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsQAAALIAAACzAAAAtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBAAAAQgAAAEMAAABEAAAARQAAAEYAAABHAAAASAAAAEkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAANAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACKAAAAiwAAAIwAAACNAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAChAAAAogAAAKMAAACkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFEAAABSAAAAUwAAAFQAAABVAAAAVgAAAFcAAABYAAAAWQAAAAAAAAAAAAAAAAAAAAAAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJoAAACbAAAAnAAAAJ0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALEAAACyAAAAswAAALQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYQAAAGIAAABjAAAAZAAAAGUAAABmAAAAZwAAAGgAAABpAAAAAAAAAAAAAAAAAAAAKgAAACsAAAAsAAAALQAAAC4AAAAvAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWgAAAFsAAABcAAAAXQAAAF4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWgAAAFsAAABcAAAAXQAAAF4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWgAAAFsAAABcAAAAXQAAAF4AAAAAAAAAAAAAAFoAAABbAAAAXAAAAF0AAABeAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAAAAABxAAAAcgAAAHMAAAB0AAAAdQAAAHYAAAB3AAAAeAAAAHkAAAAAAAAAAAAAAAAAAAA6AAAAOwAAADwAAAA9AAAAPgAAAD8AAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWwAAAFwAAABdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAqAAAAKwAAACwAAAAtAAAALgAAAC8AAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABqAAAAawAAAGwAAABtAAAAbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABqAAAAawAAAGwAAABtAAAAbgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABqAAAAawAAAGwAAABtAAAAbgAAAAAAAAAAAAAAagAAAGsAAABsAAAAbQAAAG4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaAAAAGwAAABwAAAAdAAAAHgAAAB8AAAAgAAAAAAAAAIEAAACCAAAAgwAAAIQAAACFAAAAhgAAAIcAAACIAAAAiQAAAAAAAAAAAAAAAAAAAEoAAABLAAAATAAAAE0AAABOAAAATwAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGoAAABrAAAAbAAAAG0AAABuAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADoAAAA7AAAAPAAAAD0AAAA+AAAAPwAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHoAAAB7AAAAfAAAAH0AAAB+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAqAAAAKwAAACwAAAAtAAAALgAAAC8AAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHoAAAB7AAAAfAAAAH0AAAB+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKgAAACsAAAAsAAAALQAAAC4AAAAvAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHoAAAB7AAAAfAAAAH0AAAB+AAAAAAAAAAAAAAB6AAAAewAAAHwAAAB9AAAAfgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACoAAAArAAAALAAAAC0AAAAuAAAALwAAADAAAAAAAAAAkQAAAJIAAACTAAAAlAAAAJUAAACWAAAAlwAAAJgAAACZAAAAAAAAAAAAAAAAAAAASgAAAEsAAABMAAAATQAAAE4AAABPAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAegAAAHsAAAB8AAAAfQAAAH4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASgAAAEsAAABMAAAATQAAAE4AAABPAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAegAAAHsAAAB8AAAAfQAAAH4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADoAAAA7AAAAPAAAAD0AAAA+AAAAPwAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAegAAAHsAAAB8AAAAfQAAAH4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA6AAAAOwAAADwAAAA9AAAAPgAAAD8AAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAagAAAGsAAABsAAAAbQAAAG4AAAAAAAAAAAAAAGoAAABrAAAAbAAAAG0AAABuAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOgAAADsAAAA8AAAAPQAAAD4AAAA/AAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASgAAAEsAAABMAAAATQAAAE4AAABPAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEoAAABLAAAATAAAAE0AAABOAAAATwAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB6AAAAewAAAHwAAAB9AAAAfgAAAAAAAAAAAAAAegAAAHsAAAB8AAAAfQAAAH4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABKAAAASwAAAEwAAABNAAAATgAAAE8AAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==
   </data>
  </layer>
- <imagelayer name="koalio" x="241" y="200">
-  <image source="koalio-single.png"/>
- </imagelayer>
  <layer name="walls" width="212" height="20">
   <data encoding="base64">
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI8AAACPAAAAjwAAAI8AAACPAAAAjwAAAI8AAACPAAAAAAAAAAAAAAAAAAAAjwAAAI8AAACPAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjwAAAI8AAACPAAAAAAAAAAAAAAAAAAAAAAAAAI8AAACAAAAAgAAAAI8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH8AAAB/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB/AAAAfwAAAH8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfwAAAH8AAAB/AAAAfwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAjwAAAIAAAACPAAAAgAAAAI8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF8AAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjwAAAIAAAACPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACPAAAAgAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAACAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI8AAACPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfwAAAAAAAAAAAAAAfwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB/AAAAfwAAAAAAAAAAAAAAfwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI8AAACPAAAAgAAAAI8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABfAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF8AAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbwAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH8AAAB/AAAAAAAAAAAAAAB/AAAAfwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfwAAAH8AAAB/AAAAAAAAAAAAAAB/AAAAfwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXwAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG8AAABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbwAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACOAAAAjgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB/AAAAfwAAAH8AAAAAAAAAAAAAAH8AAAB/AAAAfwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH8AAAB/AAAAfwAAAH8AAAAAAAAAAAAAAH8AAAB/AAAAfwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXwAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF8AAABgAAAAAAAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABvAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjgAAAI4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACOAAAAjgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI4AAACOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfwAAAH8AAAB/AAAAfwAAAAAAAAAAAAAAfwAAAH8AAAB/AAAAfwAAAAAAAAAAAAAAAAAAAAAAAAB/AAAAfwAAAH8AAAB/AAAAfwAAAAAAAAAAAAAAfwAAAH8AAAB/AAAAfwAAAAAAAAAAAAAAAAAAAAAAAABvAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbwAAAHAAAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAB/AAAAfwAAAH8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAAAAAAAAAAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAAAAAAAAAAAAAAAAAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAAAAAAAAAAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAAAAAAAAAAAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAAAAAAAAAAAAAAAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAAAAAAAAAAAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAI4AAACOAAAAjgAAAA==
   </data>
  </layer>
- <imagelayer name="koalio-color" x="352" y="136" opacity="0.5">
-  <image source="koalio-single.png" trans="127c91"/>
- </imagelayer>
 </map>
diff --git a/tests/gdx-tests-android/project.properties b/tests/gdx-tests-android/project.properties
index 081c244..71b7a4c 100644
--- a/tests/gdx-tests-android/project.properties
+++ b/tests/gdx-tests-android/project.properties
@@ -11,3 +11,6 @@
 split.density=false
 # Project target.
 target=android-19
+android.library.reference.1=../../extensions/gdx-pay/gdx-pay-android
+android.library.reference.3=../../extensions/gdx-pay/gdx-pay-android-ouya
+android.library.reference.2=..\\..\\extensions\\gdx-pay\\gdx-pay-android-openiab
diff --git a/tests/gdx-tests-android/src/com/badlogic/gdx/tests/android/FragmentTestStarter.java b/tests/gdx-tests-android/src/com/badlogic/gdx/tests/android/FragmentTestStarter.java
index ab77568..b61df48 100644
--- a/tests/gdx-tests-android/src/com/badlogic/gdx/tests/android/FragmentTestStarter.java
+++ b/tests/gdx-tests-android/src/com/badlogic/gdx/tests/android/FragmentTestStarter.java
@@ -132,9 +132,7 @@ public class FragmentTestStarter extends FragmentActivity implements AndroidFrag
 
 		@Override
 		public View onCreateView (LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-			AndroidApplicationConfiguration config = new AndroidApplicationConfiguration();
-			config.useImmersiveMode = true;
-			return initializeForView(test, config);
+			return initializeForView(test, new AndroidApplicationConfiguration());
 		}
 		
 	}
diff --git a/tests/gdx-tests-gwt/.settings/com.google.gdt.eclipse.core.prefs b/tests/gdx-tests-gwt/.settings/com.google.gdt.eclipse.core.prefs
index 249a4db..f2d1bdc 100644
--- a/tests/gdx-tests-gwt/.settings/com.google.gdt.eclipse.core.prefs
+++ b/tests/gdx-tests-gwt/.settings/com.google.gdt.eclipse.core.prefs
@@ -1,5 +1,5 @@
 eclipse.preferences.version=1
 jarsExcludedFromWebInfLib=
-lastWarOutDir=/Users/badlogic/workspaces/libgdx/libgdx/tests/gdx-tests-gwt/war
+lastWarOutDir=/Users/badlogic/workspace/libgdx/tests/gdx-tests-gwt/war
 warSrcDir=war
 warSrcDirIsOutput=false
diff --git a/tests/gdx-tests-gwt/src/com/badlogic/gdx/tests/gwt/GdxTestsGwt.gwt.xml b/tests/gdx-tests-gwt/src/com/badlogic/gdx/tests/gwt/GdxTestsGwt.gwt.xml
index a760e71..6625be4 100644
--- a/tests/gdx-tests-gwt/src/com/badlogic/gdx/tests/gwt/GdxTestsGwt.gwt.xml
+++ b/tests/gdx-tests-gwt/src/com/badlogic/gdx/tests/gwt/GdxTestsGwt.gwt.xml
@@ -6,6 +6,5 @@
 	<inherits name="com.badlogic.gdx.physics.box2d.box2d-gwt"/>
 	<inherits name="com.badlogic.gdx.controllers.controllers-gwt"/>
 	<set-configuration-property name="gdx.assetpath" value="../gdx-tests-android/assets"/>
-	<set-configuration-property name='xsiframe.failIfScriptTag' value='FALSE'/>
-	<entry-point class='com.badlogic.gdx.tests.gwt.client.GwtTestStarter' />	
+	<entry-point class='com.badlogic.gdx.tests.gwt.client.GwtTestStarter' />
 </module>
\ No newline at end of file
diff --git a/tests/gdx-tests-gwt/war/index.html b/tests/gdx-tests-gwt/war/index.html
index f8b1ba5..e40006b 100644
--- a/tests/gdx-tests-gwt/war/index.html
+++ b/tests/gdx-tests-gwt/war/index.html
@@ -3,8 +3,6 @@
   <head>
     <meta http-equiv="content-type" content="text/html; charset=UTF-8">
     <title>libGDX GWT Test Runner</title>
-    <script src="soundmanager2-setup.js"></script>  
-	<script src="soundmanager2-jsmin.js"></script> 
   </head>
   <body>
     <h1>libGDX GWT Test Runner</h1>
diff --git a/tests/gdx-tests-gwt/war/soundmanager2-jsmin.js b/tests/gdx-tests-gwt/war/soundmanager2-jsmin.js
deleted file mode 100644
index b6af93d..0000000
--- a/tests/gdx-tests-gwt/war/soundmanager2-jsmin.js
+++ /dev/null
@@ -1,110 +0,0 @@
-/** @license
-
-
- SoundManager 2: JavaScript Sound for the Web
- ----------------------------------------------
- http://schillmania.com/projects/soundmanager2/
-
- Copyright (c) 2007, Scott Schiller. All rights reserved.
- Code provided under the BSD License:
- http://schillmania.com/projects/soundmanager2/license.txt
-
- V2.97a.20130512
-*/
-(function(h,g){function fa(fa,wa){function ga(b){return c.preferFlash&&H&&!c.ignoreFlash&&c.flash[b]!==g&&c.flash[b]}function s(b){return function(d){var e=this._s;!e||!e._a?(e&&e.id?c._wD(e.id+": Ignoring "+d.type):c._wD(rb+"Ignoring "+d.type),d=null):d=b.call(this,d);return d}}this.setupOptions={url:fa||null,flashVersion:8,debugMode:!0,debugFlash:!1,useConsole:!0,consoleOnly:!0,waitForWindowLoad:!1,bgColor:"#ffffff",useHighPerformance:!1,flashPollingInterval:null,html5PollingInterval:null,flashLoadTimeout:1E3,
-wmode:null,allowScriptAccess:"always",useFlashBlock:!1,useHTML5Audio:!0,html5Test:/^(probably|maybe)$/i,preferFlash:!0,noSWFCache:!1,idPrefix:"sound"};this.defaultOptions={autoLoad:!1,autoPlay:!1,from:null,loops:1,onid3:null,onload:null,whileloading:null,onplay:null,onpause:null,onresume:null,whileplaying:null,onposition:null,onstop:null,onfailure:null,onfinish:null,multiShot:!0,multiShotEvents:!1,position:null,pan:0,stream:!0,to:null,type:null,usePolicyFile:!1,volume:100};this.flash9Options={isMovieStar:null,
-usePeakData:!1,useWaveformData:!1,useEQData:!1,onbufferchange:null,ondataerror:null};this.movieStarOptions={bufferTime:3,serverURL:null,onconnect:null,duration:null};this.audioFormats={mp3:{type:['audio/mpeg; codecs\x3d"mp3"',"audio/mpeg","audio/mp3","audio/MPA","audio/mpa-robust"],required:!0},mp4:{related:["aac","m4a","m4b"],type:['audio/mp4; codecs\x3d"mp4a.40.2"',"audio/aac","audio/x-m4a","audio/MP4A-LATM","audio/mpeg4-generic"],required:!1},ogg:{type:["audio/ogg; codecs\x3dvorbis"],required:!1},
-opus:{type:["audio/ogg; codecs\x3dopus","audio/opus"],required:!1},wav:{type:['audio/wav; codecs\x3d"1"',"audio/wav","audio/wave","audio/x-wav"],required:!1}};this.movieID="sm2-container";this.id=wa||"sm2movie";this.debugID="soundmanager-debug";this.debugURLParam=/([#?&])debug=1/i;this.versionNumber="V2.97a.20130512";this.altURL=this.movieURL=this.version=null;this.enabled=this.swfLoaded=!1;this.oMC=null;this.sounds={};this.soundIDs=[];this.didFlashBlock=this.muted=!1;this.filePattern=null;this.filePatterns=
-{flash8:/\.mp3(\?.*)?$/i,flash9:/\.mp3(\?.*)?$/i};this.features={buffering:!1,peakData:!1,waveformData:!1,eqData:!1,movieStar:!1};this.sandbox={type:null,types:{remote:"remote (domain-based) rules",localWithFile:"local with file access (no internet access)",localWithNetwork:"local with network (internet access only, no local access)",localTrusted:"local, trusted (local+internet access)"},description:null,noRemote:null,noLocal:null};this.html5={usingFlash:null};this.flash={};this.ignoreFlash=this.html5Only=
-!1;var Ua,c=this,Va=null,k=null,rb="HTML5::",A,t=navigator.userAgent,U=h.location.href.toString(),m=document,xa,Wa,ya,n,F=[],za=!0,C,V=!1,W=!1,q=!1,y=!1,ha=!1,p,sb=0,X,B,Aa,O,Ba,M,P,Q,Xa,Ca,ia,I,ja,Da,R,Ea,Y,ka,la,S,Ya,Fa,Za=["log","info","warn","error"],$a,Ga,ab,Z=null,Ha=null,r,Ia,T,bb,ma,na,J,v,$=!1,Ja=!1,cb,db,eb,oa=0,aa=null,pa,N=[],qa,u=null,fb,ra,ba,K,sa,Ka,gb,w,hb=Array.prototype.slice,E=!1,La,H,Ma,ib,G,jb,Na,ta,kb=0,ca=t.match(/(ipad|iphone|ipod)/i),lb=t.match(/android/i),L=t.match(/msie/i),
-tb=t.match(/webkit/i),ua=t.match(/safari/i)&&!t.match(/chrome/i),Oa=t.match(/opera/i),ub=t.match(/firefox/i),Pa=t.match(/(mobile|pre\/|xoom)/i)||ca||lb,Qa=!U.match(/usehtml5audio/i)&&!U.match(/sm2\-ignorebadua/i)&&ua&&!t.match(/silk/i)&&t.match(/OS X 10_6_([3-7])/i),da=h.console!==g&&console.log!==g,Ra=m.hasFocus!==g?m.hasFocus():null,va=ua&&(m.hasFocus===g||!m.hasFocus()),mb=!va,nb=/(mp3|mp4|mpa|m4a|m4b)/i,ea=m.location?m.location.protocol.match(/http/i):null,ob=!ea?"http://":"",pb=/^\s*audio\/(?:x-)?(?:mpeg4|aac|flv|mov|mp4||m4v|m4a|m4b|mp4v|3gp|3g2)\s*(?:$|;)/i,
-qb="mpeg4 aac flv mov mp4 m4v f4v m4a m4b mp4v 3gp 3g2".split(" "),vb=RegExp("\\.("+qb.join("|")+")(\\?.*)?$","i");this.mimePattern=/^\s*audio\/(?:x-)?(?:mp(?:eg|3))\s*(?:$|;)/i;this.useAltURL=!ea;var Sa;try{Sa=Audio!==g&&(Oa&&opera!==g&&10>opera.version()?new Audio(null):new Audio).canPlayType!==g}catch(wb){Sa=!1}this.hasHTML5=Sa;this.setup=function(b){var d=!c.url;b!==g&&(q&&u&&c.ok()&&(b.flashVersion!==g||b.url!==g||b.html5Test!==g))&&J(r("setupLate"));Aa(b);b&&(d&&(Y&&b.url!==g)&&c.beginDelayedInit(),
-!Y&&(b.url!==g&&"complete"===m.readyState)&&setTimeout(R,1));return c};this.supported=this.ok=function(){return u?q&&!y:c.useHTML5Audio&&c.hasHTML5};this.getMovie=function(c){return A(c)||m[c]||h[c]};this.createSound=function(b,d){function e(){f=ma(f);c.sounds[f.id]=new Ua(f);c.soundIDs.push(f.id);return c.sounds[f.id]}var a,f;a=null;a="soundManager.createSound(): "+r(!q?"notReady":"notOK");if(!q||!c.ok())return J(a),!1;d!==g&&(b={id:b,url:d});f=B(b);f.url=pa(f.url);void 0===f.id&&(f.id=c.setupOptions.idPrefix+
-kb++);f.id.toString().charAt(0).match(/^[0-9]$/)&&c._wD("soundManager.createSound(): "+r("badID",f.id),2);c._wD("soundManager.createSound(): "+f.id+(f.url?" ("+f.url+")":""),1);if(v(f.id,!0))return c._wD("soundManager.createSound(): "+f.id+" exists",1),c.sounds[f.id];if(ra(f))a=e(),c._wD(f.id+": Using HTML5"),a._setup_html5(f);else{if(c.html5Only)return c._wD(f.id+": No HTML5 support for this sound, and no Flash. Exiting."),e();if(c.html5.usingFlash&&f.url&&f.url.match(/data\:/i))return c._wD(f.id+
-": data: URIs not supported via Flash. Exiting."),e();8<n&&(null===f.isMovieStar&&(f.isMovieStar=!(!f.serverURL&&!(f.type&&f.type.match(pb)||f.url&&f.url.match(vb)))),f.isMovieStar&&(c._wD("soundManager.createSound(): using MovieStar handling"),1<f.loops&&p("noNSLoop")));f=na(f,"soundManager.createSound(): ");a=e();8===n?k._createSound(f.id,f.loops||1,f.usePolicyFile):(k._createSound(f.id,f.url,f.usePeakData,f.useWaveformData,f.useEQData,f.isMovieStar,f.isMovieStar?f.bufferTime:!1,f.loops||1,f.serverURL,
-f.duration||null,f.autoPlay,!0,f.autoLoad,f.usePolicyFile),f.serverURL||(a.connected=!0,f.onconnect&&f.onconnect.apply(a)));!f.serverURL&&(f.autoLoad||f.autoPlay)&&a.load(f)}!f.serverURL&&f.autoPlay&&a.play();return a};this.destroySound=function(b,d){if(!v(b))return!1;var e=c.sounds[b],a;e._iO={};e.stop();e.unload();for(a=0;a<c.soundIDs.length;a++)if(c.soundIDs[a]===b){c.soundIDs.splice(a,1);break}d||e.destruct(!0);delete c.sounds[b];return!0};this.load=function(b,d){return!v(b)?!1:c.sounds[b].load(d)};
-this.unload=function(b){return!v(b)?!1:c.sounds[b].unload()};this.onposition=this.onPosition=function(b,d,e,a){return!v(b)?!1:c.sounds[b].onposition(d,e,a)};this.clearOnPosition=function(b,d,e){return!v(b)?!1:c.sounds[b].clearOnPosition(d,e)};this.start=this.play=function(b,d){var e=null,a=d&&!(d instanceof Object);if(!q||!c.ok())return J("soundManager.play(): "+r(!q?"notReady":"notOK")),!1;if(v(b,a))a&&(d={url:d});else{if(!a)return!1;a&&(d={url:d});d&&d.url&&(c._wD('soundManager.play(): Attempting to create "'+
-b+'"',1),d.id=b,e=c.createSound(d).play())}null===e&&(e=c.sounds[b].play(d));return e};this.setPosition=function(b,d){return!v(b)?!1:c.sounds[b].setPosition(d)};this.stop=function(b){if(!v(b))return!1;c._wD("soundManager.stop("+b+")",1);return c.sounds[b].stop()};this.stopAll=function(){var b;c._wD("soundManager.stopAll()",1);for(b in c.sounds)c.sounds.hasOwnProperty(b)&&c.sounds[b].stop()};this.pause=function(b){return!v(b)?!1:c.sounds[b].pause()};this.pauseAll=function(){var b;for(b=c.soundIDs.length-
-1;0<=b;b--)c.sounds[c.soundIDs[b]].pause()};this.resume=function(b){return!v(b)?!1:c.sounds[b].resume()};this.resumeAll=function(){var b;for(b=c.soundIDs.length-1;0<=b;b--)c.sounds[c.soundIDs[b]].resume()};this.togglePause=function(b){return!v(b)?!1:c.sounds[b].togglePause()};this.setPan=function(b,d){return!v(b)?!1:c.sounds[b].setPan(d)};this.setVolume=function(b,d){return!v(b)?!1:c.sounds[b].setVolume(d)};this.mute=function(b){var d=0;b instanceof String&&(b=null);if(b){if(!v(b))return!1;c._wD('soundManager.mute(): Muting "'+
-b+'"');return c.sounds[b].mute()}c._wD("soundManager.mute(): Muting all sounds");for(d=c.soundIDs.length-1;0<=d;d--)c.sounds[c.soundIDs[d]].mute();return c.muted=!0};this.muteAll=function(){c.mute()};this.unmute=function(b){b instanceof String&&(b=null);if(b){if(!v(b))return!1;c._wD('soundManager.unmute(): Unmuting "'+b+'"');return c.sounds[b].unmute()}c._wD("soundManager.unmute(): Unmuting all sounds");for(b=c.soundIDs.length-1;0<=b;b--)c.sounds[c.soundIDs[b]].unmute();c.muted=!1;return!0};this.unmuteAll=
-function(){c.unmute()};this.toggleMute=function(b){return!v(b)?!1:c.sounds[b].toggleMute()};this.getMemoryUse=function(){var c=0;k&&8!==n&&(c=parseInt(k._getMemoryUse(),10));return c};this.disable=function(b){var d;b===g&&(b=!1);if(y)return!1;y=!0;p("shutdown",1);for(d=c.soundIDs.length-1;0<=d;d--)$a(c.sounds[c.soundIDs[d]]);X(b);w.remove(h,"load",P);return!0};this.canPlayMIME=function(b){var d;c.hasHTML5&&(d=ba({type:b}));!d&&u&&(d=b&&c.ok()?!!(8<n&&b.match(pb)||b.match(c.mimePattern)):null);return d};
-this.canPlayURL=function(b){var d;c.hasHTML5&&(d=ba({url:b}));!d&&u&&(d=b&&c.ok()?!!b.match(c.filePattern):null);return d};this.canPlayLink=function(b){return b.type!==g&&b.type&&c.canPlayMIME(b.type)?!0:c.canPlayURL(b.href)};this.getSoundById=function(b,d){if(!b)return null;var e=c.sounds[b];!e&&!d&&c._wD('soundManager.getSoundById(): Sound "'+b+'" not found.',2);return e};this.onready=function(b,d){if("function"===typeof b)q&&c._wD(r("queue","onready")),d||(d=h),Ba("onready",b,d),M();else throw r("needFunction",
-"onready");return!0};this.ontimeout=function(b,d){if("function"===typeof b)q&&c._wD(r("queue","ontimeout")),d||(d=h),Ba("ontimeout",b,d),M({type:"ontimeout"});else throw r("needFunction","ontimeout");return!0};this._writeDebug=function(b,d){var e,a;if(!c.debugMode)return!1;if(da&&c.useConsole){if(d&&"object"===typeof d)console.log(b,d);else if(Za[d]!==g)console[Za[d]](b);else console.log(b);if(c.consoleOnly)return!0}e=A("soundmanager-debug");if(!e)return!1;a=m.createElement("div");0===++sb%2&&(a.className=
-"sm2-alt");d=d===g?0:parseInt(d,10);a.appendChild(m.createTextNode(b));d&&(2<=d&&(a.style.fontWeight="bold"),3===d&&(a.style.color="#ff3333"));e.insertBefore(a,e.firstChild);return!0};-1!==U.indexOf("sm2-debug\x3dalert")&&(this._writeDebug=function(c){h.alert(c)});this._wD=this._writeDebug;this._debug=function(){var b,d;p("currentObj",1);b=0;for(d=c.soundIDs.length;b<d;b++)c.sounds[c.soundIDs[b]]._debug()};this.reboot=function(b,d){c.soundIDs.length&&c._wD("Destroying "+c.soundIDs.length+" SMSound object"+
-(1!==c.soundIDs.length?"s":"")+"...");var e,a,f;for(e=c.soundIDs.length-1;0<=e;e--)c.sounds[c.soundIDs[e]].destruct();if(k)try{L&&(Ha=k.innerHTML),Z=k.parentNode.removeChild(k)}catch(g){p("badRemove",2)}Ha=Z=u=k=null;c.enabled=Y=q=$=Ja=V=W=y=E=c.swfLoaded=!1;c.soundIDs=[];c.sounds={};kb=0;if(b)F=[];else for(e in F)if(F.hasOwnProperty(e)){a=0;for(f=F[e].length;a<f;a++)F[e][a].fired=!1}d||c._wD("soundManager: Rebooting...");c.html5={usingFlash:null};c.flash={};c.html5Only=!1;c.ignoreFlash=!1;h.setTimeout(function(){Da();
-d||c.beginDelayedInit()},20);return c};this.reset=function(){p("reset");return c.reboot(!0,!0)};this.getMoviePercent=function(){return k&&"PercentLoaded"in k?k.PercentLoaded():null};this.beginDelayedInit=function(){ha=!0;R();setTimeout(function(){if(Ja)return!1;la();ja();return Ja=!0},20);Q()};this.destruct=function(){c._wD("soundManager.destruct()");c.disable(!0)};Ua=function(b){var d,e,a=this,f,h,z,l,m,q,s=!1,D=[],t=0,Ta,y,u=null,A;e=d=null;this.sID=this.id=b.id;this.url=b.url;this._iO=this.instanceOptions=
-this.options=B(b);this.pan=this.options.pan;this.volume=this.options.volume;this.isHTML5=!1;this._a=null;A=this.url?!1:!0;this.id3={};this._debug=function(){c._wD(a.id+": Merged options:",a.options)};this.load=function(b){var d=null,e;b!==g?a._iO=B(b,a.options):(b=a.options,a._iO=b,u&&u!==a.url&&(p("manURL"),a._iO.url=a.url,a.url=null));a._iO.url||(a._iO.url=a.url);a._iO.url=pa(a._iO.url);e=a.instanceOptions=a._iO;c._wD(a.id+": load ("+e.url+")");if(!e.url&&!a.url)return c._wD(a.id+": load(): url is unassigned. Exiting.",
-2),a;!a.isHTML5&&(8===n&&!a.url&&!e.autoPlay)&&c._wD(a.id+": Flash 8 load() limitation: Wait for onload() before calling play().",1);if(e.url===a.url&&0!==a.readyState&&2!==a.readyState)return p("onURL",1),3===a.readyState&&e.onload&&ta(a,function(){e.onload.apply(a,[!!a.duration])}),a;a.loaded=!1;a.readyState=1;a.playState=0;a.id3={};if(ra(e))d=a._setup_html5(e),d._called_load?c._wD(a.id+": Ignoring request to load again"):(a._html5_canplay=!1,a.url!==e.url&&(c._wD(p("manURL")+": "+e.url),a._a.src=
-e.url,a.setPosition(0)),a._a.autobuffer="auto",a._a.preload="auto",a._a._called_load=!0,e.autoPlay&&a.play());else{if(c.html5Only)return c._wD(a.id+": No flash support. Exiting."),a;if(a._iO.url&&a._iO.url.match(/data\:/i))return c._wD(a.id+": data: URIs not supported via Flash. Exiting."),a;try{a.isHTML5=!1,a._iO=na(ma(e)),e=a._iO,8===n?k._load(a.id,e.url,e.stream,e.autoPlay,e.usePolicyFile):k._load(a.id,e.url,!!e.stream,!!e.autoPlay,e.loops||1,!!e.autoLoad,e.usePolicyFile)}catch(f){p("smError",
-2),C("onload",!1),S({type:"SMSOUND_LOAD_JS_EXCEPTION",fatal:!0})}}a.url=e.url;return a};this.unload=function(){0!==a.readyState&&(c._wD(a.id+": unload()"),a.isHTML5?(l(),a._a&&(a._a.pause(),u=sa(a._a))):8===n?k._unload(a.id,"about:blank"):k._unload(a.id),f());return a};this.destruct=function(b){c._wD(a.id+": Destruct");a.isHTML5?(l(),a._a&&(a._a.pause(),sa(a._a),E||z(),a._a._s=null,a._a=null)):(a._iO.onfailure=null,k._destroySound(a.id));b||c.destroySound(a.id,!0)};this.start=this.play=function(b,
-d){var e,f,l,z,h,x=!0,x=null;e=a.id+": play(): ";d=d===g?!0:d;b||(b={});a.url&&(a._iO.url=a.url);a._iO=B(a._iO,a.options);a._iO=B(b,a._iO);a._iO.url=pa(a._iO.url);a.instanceOptions=a._iO;if(!a.isHTML5&&a._iO.serverURL&&!a.connected)return a.getAutoPlay()||(c._wD(e+" Netstream not connected yet - setting autoPlay"),a.setAutoPlay(!0)),a;ra(a._iO)&&(a._setup_html5(a._iO),m());1===a.playState&&!a.paused&&((f=a._iO.multiShot)?c._wD(e+"Already playing (multi-shot)",1):(c._wD(e+"Already playing (one-shot)",
-1),a.isHTML5&&a.setPosition(a._iO.position),x=a));if(null!==x)return x;b.url&&b.url!==a.url&&(!a.readyState&&!a.isHTML5&&8===n&&A?A=!1:a.load(a._iO));a.loaded?c._wD(e.substr(0,e.lastIndexOf(":"))):0===a.readyState?(c._wD(e+"Attempting to load"),!a.isHTML5&&!c.html5Only?(a._iO.autoPlay=!0,a.load(a._iO)):a.isHTML5?a.load(a._iO):(c._wD(e+"Unsupported type. Exiting."),x=a),a.instanceOptions=a._iO):2===a.readyState?(c._wD(e+"Could not load - exiting",2),x=a):c._wD(e+"Loading - attempting to play...");
-if(null!==x)return x;!a.isHTML5&&(9===n&&0<a.position&&a.position===a.duration)&&(c._wD(e+"Sound at end, resetting to position:0"),b.position=0);if(a.paused&&0<=a.position&&(!a._iO.serverURL||0<a.position))c._wD(e+"Resuming from paused state",1),a.resume();else{a._iO=B(b,a._iO);if(null!==a._iO.from&&null!==a._iO.to&&0===a.instanceCount&&0===a.playState&&!a._iO.serverURL){f=function(){a._iO=B(b,a._iO);a.play(a._iO)};if(a.isHTML5&&!a._html5_canplay)c._wD(e+"Beginning load for from/to case"),a.load({oncanplay:f}),
-x=!1;else if(!a.isHTML5&&!a.loaded&&(!a.readyState||2!==a.readyState))c._wD(e+"Preloading for from/to case"),a.load({onload:f}),x=!1;if(null!==x)return x;a._iO=y()}(!a.instanceCount||a._iO.multiShotEvents||a.isHTML5&&a._iO.multiShot&&!E||!a.isHTML5&&8<n&&!a.getAutoPlay())&&a.instanceCount++;a._iO.onposition&&0===a.playState&&q(a);a.playState=1;a.paused=!1;a.position=a._iO.position!==g&&!isNaN(a._iO.position)?a._iO.position:0;a.isHTML5||(a._iO=na(ma(a._iO)));a._iO.onplay&&d&&(a._iO.onplay.apply(a),
-s=!0);a.setVolume(a._iO.volume,!0);a.setPan(a._iO.pan,!0);a.isHTML5?2>a.instanceCount?(m(),e=a._setup_html5(),a.setPosition(a._iO.position),e.play()):(c._wD(a.id+": Cloning Audio() for instance #"+a.instanceCount+"..."),l=new Audio(a._iO.url),z=function(){w.remove(l,"onended",z);a._onfinish(a);sa(l);l=null},h=function(){w.remove(l,"canplay",h);try{l.currentTime=a._iO.position/1E3}catch(c){J(a.id+": multiShot play() failed to apply position of "+a._iO.position/1E3)}l.play()},w.add(l,"ended",z),a._iO.position?
-w.add(l,"canplay",h):l.play()):(x=k._start(a.id,a._iO.loops||1,9===n?a.position:a.position/1E3,a._iO.multiShot||!1),9===n&&!x&&(c._wD(e+"No sound hardware, or 32-sound ceiling hit",2),a._iO.onplayerror&&a._iO.onplayerror.apply(a)))}return a};this.stop=function(b){var d=a._iO;1===a.playState&&(c._wD(a.id+": stop()"),a._onbufferchange(0),a._resetOnPosition(0),a.paused=!1,a.isHTML5||(a.playState=0),Ta(),d.to&&a.clearOnPosition(d.to),a.isHTML5?a._a&&(b=a.position,a.setPosition(0),a.position=b,a._a.pause(),
-a.playState=0,a._onTimer(),l()):(k._stop(a.id,b),d.serverURL&&a.unload()),a.instanceCount=0,a._iO={},d.onstop&&d.onstop.apply(a));return a};this.setAutoPlay=function(b){c._wD(a.id+": Autoplay turned "+(b?"on":"off"));a._iO.autoPlay=b;a.isHTML5||(k._setAutoPlay(a.id,b),b&&(!a.instanceCount&&1===a.readyState)&&(a.instanceCount++,c._wD(a.id+": Incremented instance count to "+a.instanceCount)))};this.getAutoPlay=function(){return a._iO.autoPlay};this.setPosition=function(b){b===g&&(b=0);var d=a.isHTML5?
-Math.max(b,0):Math.min(a.duration||a._iO.duration,Math.max(b,0));a.position=d;b=a.position/1E3;a._resetOnPosition(a.position);a._iO.position=d;if(a.isHTML5){if(a._a){if(a._html5_canplay){if(a._a.currentTime!==b){c._wD(a.id+": setPosition("+b+")");try{a._a.currentTime=b,(0===a.playState||a.paused)&&a._a.pause()}catch(e){c._wD(a.id+": setPosition("+b+") failed: "+e.message,2)}}}else if(b)return c._wD(a.id+": setPosition("+b+"): Cannot seek yet, sound not ready",2),a;a.paused&&a._onTimer(!0)}}else b=
-9===n?a.position:b,a.readyState&&2!==a.readyState&&k._setPosition(a.id,b,a.paused||!a.playState,a._iO.multiShot);return a};this.pause=function(b){if(a.paused||0===a.playState&&1!==a.readyState)return a;c._wD(a.id+": pause()");a.paused=!0;a.isHTML5?(a._setup_html5().pause(),l()):(b||b===g)&&k._pause(a.id,a._iO.multiShot);a._iO.onpause&&a._iO.onpause.apply(a);return a};this.resume=function(){var b=a._iO;if(!a.paused)return a;c._wD(a.id+": resume()");a.paused=!1;a.playState=1;a.isHTML5?(a._setup_html5().play(),
-m()):(b.isMovieStar&&!b.serverURL&&a.setPosition(a.position),k._pause(a.id,b.multiShot));!s&&b.onplay?(b.onplay.apply(a),s=!0):b.onresume&&b.onresume.apply(a);return a};this.togglePause=function(){c._wD(a.id+": togglePause()");if(0===a.playState)return a.play({position:9===n&&!a.isHTML5?a.position:a.position/1E3}),a;a.paused?a.resume():a.pause();return a};this.setPan=function(b,c){b===g&&(b=0);c===g&&(c=!1);a.isHTML5||k._setPan(a.id,b);a._iO.pan=b;c||(a.pan=b,a.options.pan=b);return a};this.setVolume=
-function(b,d){b===g&&(b=100);d===g&&(d=!1);a.isHTML5?a._a&&(a._a.volume=Math.max(0,Math.min(1,b/100))):k._setVolume(a.id,c.muted&&!a.muted||a.muted?0:b);a._iO.volume=b;d||(a.volume=b,a.options.volume=b);return a};this.mute=function(){a.muted=!0;a.isHTML5?a._a&&(a._a.muted=!0):k._setVolume(a.id,0);return a};this.unmute=function(){a.muted=!1;var b=a._iO.volume!==g;a.isHTML5?a._a&&(a._a.muted=!1):k._setVolume(a.id,b?a._iO.volume:a.options.volume);return a};this.toggleMute=function(){return a.muted?a.unmute():
-a.mute()};this.onposition=this.onPosition=function(b,c,d){D.push({position:parseInt(b,10),method:c,scope:d!==g?d:a,fired:!1});return a};this.clearOnPosition=function(a,b){var c;a=parseInt(a,10);if(isNaN(a))return!1;for(c=0;c<D.length;c++)if(a===D[c].position&&(!b||b===D[c].method))D[c].fired&&t--,D.splice(c,1)};this._processOnPosition=function(){var b,c;b=D.length;if(!b||!a.playState||t>=b)return!1;for(b-=1;0<=b;b--)c=D[b],!c.fired&&a.position>=c.position&&(c.fired=!0,t++,c.method.apply(c.scope,[c.position]));
-return!0};this._resetOnPosition=function(a){var b,c;b=D.length;if(!b)return!1;for(b-=1;0<=b;b--)c=D[b],c.fired&&a<=c.position&&(c.fired=!1,t--);return!0};y=function(){var b=a._iO,d=b.from,e=b.to,f,g;g=function(){c._wD(a.id+': "To" time of '+e+" reached.");a.clearOnPosition(e,g);a.stop()};f=function(){c._wD(a.id+': Playing "from" '+d);if(null!==e&&!isNaN(e))a.onPosition(e,g)};null!==d&&!isNaN(d)&&(b.position=d,b.multiShot=!1,f());return b};q=function(){var b,c=a._iO.onposition;if(c)for(b in c)if(c.hasOwnProperty(b))a.onPosition(parseInt(b,
-10),c[b])};Ta=function(){var b,c=a._iO.onposition;if(c)for(b in c)c.hasOwnProperty(b)&&a.clearOnPosition(parseInt(b,10))};m=function(){a.isHTML5&&cb(a)};l=function(){a.isHTML5&&db(a)};f=function(b){b||(D=[],t=0);s=!1;a._hasTimer=null;a._a=null;a._html5_canplay=!1;a.bytesLoaded=null;a.bytesTotal=null;a.duration=a._iO&&a._iO.duration?a._iO.duration:null;a.durationEstimate=null;a.buffered=[];a.eqData=[];a.eqData.left=[];a.eqData.right=[];a.failures=0;a.isBuffering=!1;a.instanceOptions={};a.instanceCount=
-0;a.loaded=!1;a.metadata={};a.readyState=0;a.muted=!1;a.paused=!1;a.peakData={left:0,right:0};a.waveformData={left:[],right:[]};a.playState=0;a.position=null;a.id3={}};f();this._onTimer=function(b){var c,f=!1,g={};if(a._hasTimer||b){if(a._a&&(b||(0<a.playState||1===a.readyState)&&!a.paused))c=a._get_html5_duration(),c!==d&&(d=c,a.duration=c,f=!0),a.durationEstimate=a.duration,c=1E3*a._a.currentTime||0,c!==e&&(e=c,f=!0),(f||b)&&a._whileplaying(c,g,g,g,g);return f}};this._get_html5_duration=function(){var b=
-a._iO;return(b=a._a&&a._a.duration?1E3*a._a.duration:b&&b.duration?b.duration:null)&&!isNaN(b)&&Infinity!==b?b:null};this._apply_loop=function(a,b){!a.loop&&1<b&&c._wD("Note: Native HTML5 looping is infinite.",1);a.loop=1<b?"loop":""};this._setup_html5=function(b){b=B(a._iO,b);var c=E?Va:a._a,d=decodeURI(b.url),e;E?d===decodeURI(La)&&(e=!0):d===decodeURI(u)&&(e=!0);if(c){if(c._s)if(E)c._s&&(c._s.playState&&!e)&&c._s.stop();else if(!E&&d===decodeURI(u))return a._apply_loop(c,b.loops),c;e||(f(!1),c.src=
-b.url,La=u=a.url=b.url,c._called_load=!1)}else a._a=b.autoLoad||b.autoPlay?new Audio(b.url):Oa&&10>opera.version()?new Audio(null):new Audio,c=a._a,c._called_load=!1,E&&(Va=c);a.isHTML5=!0;a._a=c;c._s=a;h();a._apply_loop(c,b.loops);b.autoLoad||b.autoPlay?a.load():(c.autobuffer=!1,c.preload="auto");return c};h=function(){if(a._a._added_events)return!1;var b;a._a._added_events=!0;for(b in G)G.hasOwnProperty(b)&&a._a&&a._a.addEventListener(b,G[b],!1);return!0};z=function(){var b;c._wD(a.id+": Removing event listeners");
-a._a._added_events=!1;for(b in G)G.hasOwnProperty(b)&&a._a&&a._a.removeEventListener(b,G[b],!1)};this._onload=function(b){var d=!!b||!a.isHTML5&&8===n&&a.duration;b=a.id+": ";c._wD(b+(d?"onload()":"Failed to load / invalid sound?"+(!a.duration?" Zero-length duration reported.":" -")+" ("+a.url+")"),d?1:2);!d&&!a.isHTML5&&(!0===c.sandbox.noRemote&&c._wD(b+r("noNet"),1),!0===c.sandbox.noLocal&&c._wD(b+r("noLocal"),1));a.loaded=d;a.readyState=d?3:2;a._onbufferchange(0);a._iO.onload&&ta(a,function(){a._iO.onload.apply(a,
-[d])});return!0};this._onbufferchange=function(b){if(0===a.playState||b&&a.isBuffering||!b&&!a.isBuffering)return!1;a.isBuffering=1===b;a._iO.onbufferchange&&(c._wD(a.id+": Buffer state change: "+b),a._iO.onbufferchange.apply(a));return!0};this._onsuspend=function(){a._iO.onsuspend&&(c._wD(a.id+": Playback suspended"),a._iO.onsuspend.apply(a));return!0};this._onfailure=function(b,d,e){a.failures++;c._wD(a.id+": Failures \x3d "+a.failures);if(a._iO.onfailure&&1===a.failures)a._iO.onfailure(a,b,d,e);
-else c._wD(a.id+": Ignoring failure")};this._onfinish=function(){var b=a._iO.onfinish;a._onbufferchange(0);a._resetOnPosition(0);if(a.instanceCount&&(a.instanceCount--,a.instanceCount||(Ta(),a.playState=0,a.paused=!1,a.instanceCount=0,a.instanceOptions={},a._iO={},l(),a.isHTML5&&(a.position=0)),(!a.instanceCount||a._iO.multiShotEvents)&&b))c._wD(a.id+": onfinish()"),ta(a,function(){b.apply(a)})};this._whileloading=function(b,c,d,e){var f=a._iO;a.bytesLoaded=b;a.bytesTotal=c;a.duration=Math.floor(d);
-a.bufferLength=e;a.durationEstimate=!a.isHTML5&&!f.isMovieStar?f.duration?a.duration>f.duration?a.duration:f.duration:parseInt(a.bytesTotal/a.bytesLoaded*a.duration,10):a.duration;a.isHTML5||(a.buffered=[{start:0,end:a.duration}]);(3!==a.readyState||a.isHTML5)&&f.whileloading&&f.whileloading.apply(a)};this._whileplaying=function(b,c,d,e,f){var l=a._iO;if(isNaN(b)||null===b)return!1;a.position=Math.max(0,b);a._processOnPosition();!a.isHTML5&&8<n&&(l.usePeakData&&(c!==g&&c)&&(a.peakData={left:c.leftPeak,
-right:c.rightPeak}),l.useWaveformData&&(d!==g&&d)&&(a.waveformData={left:d.split(","),right:e.split(",")}),l.useEQData&&(f!==g&&f&&f.leftEQ)&&(b=f.leftEQ.split(","),a.eqData=b,a.eqData.left=b,f.rightEQ!==g&&f.rightEQ&&(a.eqData.right=f.rightEQ.split(","))));1===a.playState&&(!a.isHTML5&&(8===n&&!a.position&&a.isBuffering)&&a._onbufferchange(0),l.whileplaying&&l.whileplaying.apply(a));return!0};this._oncaptiondata=function(b){c._wD(a.id+": Caption data received.");a.captiondata=b;a._iO.oncaptiondata&&
-a._iO.oncaptiondata.apply(a,[b])};this._onmetadata=function(b,d){c._wD(a.id+": Metadata received.");var e={},f,g;f=0;for(g=b.length;f<g;f++)e[b[f]]=d[f];a.metadata=e;a._iO.onmetadata&&a._iO.onmetadata.apply(a)};this._onid3=function(b,d){c._wD(a.id+": ID3 data received.");var e=[],f,g;f=0;for(g=b.length;f<g;f++)e[b[f]]=d[f];a.id3=B(a.id3,e);a._iO.onid3&&a._iO.onid3.apply(a)};this._onconnect=function(b){b=1===b;c._wD(a.id+": "+(b?"Connected.":"Failed to connect? - "+a.url),b?1:2);if(a.connected=b)a.failures=
-0,v(a.id)&&(a.getAutoPlay()?a.play(g,a.getAutoPlay()):a._iO.autoLoad&&a.load()),a._iO.onconnect&&a._iO.onconnect.apply(a,[b])};this._ondataerror=function(b){0<a.playState&&(c._wD(a.id+": Data error: "+b),a._iO.ondataerror&&a._iO.ondataerror.apply(a))};this._debug()};ka=function(){return m.body||m._docElement||m.getElementsByTagName("div")[0]};A=function(b){return m.getElementById(b)};B=function(b,d){var e=b||{},a,f;a=d===g?c.defaultOptions:d;for(f in a)a.hasOwnProperty(f)&&e[f]===g&&(e[f]="object"!==
-typeof a[f]||null===a[f]?a[f]:B(e[f],a[f]));return e};ta=function(b,c){!b.isHTML5&&8===n?h.setTimeout(c,0):c()};O={onready:1,ontimeout:1,defaultOptions:1,flash9Options:1,movieStarOptions:1};Aa=function(b,d){var e,a=!0,f=d!==g,x=c.setupOptions;if(b===g){a=[];for(e in x)x.hasOwnProperty(e)&&a.push(e);for(e in O)O.hasOwnProperty(e)&&("object"===typeof c[e]?a.push(e+": {...}"):c[e]instanceof Function?a.push(e+": function() {...}"):a.push(e));c._wD(r("setup",a.join(", ")));return!1}for(e in b)if(b.hasOwnProperty(e))if("object"!==
-typeof b[e]||null===b[e]||b[e]instanceof Array||b[e]instanceof RegExp)f&&O[d]!==g?c[d][e]=b[e]:x[e]!==g?(c.setupOptions[e]=b[e],c[e]=b[e]):O[e]===g?(J(r(c[e]===g?"setupUndef":"setupError",e),2),a=!1):c[e]instanceof Function?c[e].apply(c,b[e]instanceof Array?b[e]:[b[e]]):c[e]=b[e];else if(O[e]===g)J(r(c[e]===g?"setupUndef":"setupError",e),2),a=!1;else return Aa(b[e],e);return a};w=function(){function b(a){a=hb.call(a);var b=a.length;e?(a[1]="on"+a[1],3<b&&a.pop()):3===b&&a.push(!1);return a}function c(b,
-d){var g=b.shift(),l=[a[d]];if(e)g[l](b[0],b[1]);else g[l].apply(g,b)}var e=h.attachEvent,a={add:e?"attachEvent":"addEventListener",remove:e?"detachEvent":"removeEventListener"};return{add:function(){c(b(arguments),"add")},remove:function(){c(b(arguments),"remove")}}}();G={abort:s(function(){c._wD(this._s.id+": abort")}),canplay:s(function(){var b=this._s,d;if(b._html5_canplay)return!0;b._html5_canplay=!0;c._wD(b.id+": canplay");b._onbufferchange(0);d=b._iO.position!==g&&!isNaN(b._iO.position)?b._iO.position/
-1E3:null;if(b.position&&this.currentTime!==d){c._wD(b.id+": canplay: Setting position to "+d);try{this.currentTime=d}catch(e){c._wD(b.id+": canplay: Setting position of "+d+" failed: "+e.message,2)}}b._iO._oncanplay&&b._iO._oncanplay()}),canplaythrough:s(function(){var b=this._s;b.loaded||(b._onbufferchange(0),b._whileloading(b.bytesLoaded,b.bytesTotal,b._get_html5_duration()),b._onload(!0))}),ended:s(function(){var b=this._s;c._wD(b.id+": ended");b._onfinish()}),error:s(function(){c._wD(this._s.id+
-": HTML5 error, code "+this.error.code);this._s._onload(!1)}),loadeddata:s(function(){var b=this._s;c._wD(b.id+": loadeddata");!b._loaded&&!ua&&(b.duration=b._get_html5_duration())}),loadedmetadata:s(function(){c._wD(this._s.id+": loadedmetadata")}),loadstart:s(function(){c._wD(this._s.id+": loadstart");this._s._onbufferchange(1)}),play:s(function(){this._s._onbufferchange(0)}),playing:s(function(){c._wD(this._s.id+": playing");this._s._onbufferchange(0)}),progress:s(function(b){var d=this._s,e,a,
-f;e=0;var g="progress"===b.type,z=b.target.buffered,l=b.loaded||0,h=b.total||1;d.buffered=[];if(z&&z.length){e=0;for(a=z.length;e<a;e++)d.buffered.push({start:1E3*z.start(e),end:1E3*z.end(e)});e=1E3*(z.end(0)-z.start(0));l=Math.min(1,e/(1E3*b.target.duration));if(g&&1<z.length){f=[];a=z.length;for(e=0;e<a;e++)f.push(1E3*b.target.buffered.start(e)+"-"+1E3*b.target.buffered.end(e));c._wD(this._s.id+": progress, timeRanges: "+f.join(", "))}g&&!isNaN(l)&&c._wD(this._s.id+": progress, "+Math.floor(100*
-l)+"% loaded")}isNaN(l)||(d._onbufferchange(0),d._whileloading(l,h,d._get_html5_duration()),l&&(h&&l===h)&&G.canplaythrough.call(this,b))}),ratechange:s(function(){c._wD(this._s.id+": ratechange")}),suspend:s(function(b){var d=this._s;c._wD(this._s.id+": suspend");G.progress.call(this,b);d._onsuspend()}),stalled:s(function(){c._wD(this._s.id+": stalled")}),timeupdate:s(function(){this._s._onTimer()}),waiting:s(function(){var b=this._s;c._wD(this._s.id+": waiting");b._onbufferchange(1)})};ra=function(b){return!b||
-!b.type&&!b.url&&!b.serverURL?!1:b.serverURL||b.type&&ga(b.type)?!1:b.type?ba({type:b.type}):ba({url:b.url})||c.html5Only||b.url.match(/data\:/i)};sa=function(b){var c;b&&(c=ua&&!ca?null:ub?"about:blank":null,b.src=c,void 0!==b._called_unload&&(b._called_load=!1));E&&(La=null);return c};ba=function(b){if(!c.useHTML5Audio||!c.hasHTML5)return!1;var d=b.url||null;b=b.type||null;var e=c.audioFormats,a;if(b&&c.html5[b]!==g)return c.html5[b]&&!ga(b);if(!K){K=[];for(a in e)e.hasOwnProperty(a)&&(K.push(a),
-e[a].related&&(K=K.concat(e[a].related)));K=RegExp("\\.("+K.join("|")+")(\\?.*)?$","i")}a=d?d.toLowerCase().match(K):null;!a||!a.length?b&&(d=b.indexOf(";"),a=(-1!==d?b.substr(0,d):b).substr(6)):a=a[1];a&&c.html5[a]!==g?d=c.html5[a]&&!ga(a):(b="audio/"+a,d=c.html5.canPlayType({type:b}),d=(c.html5[a]=d)&&c.html5[b]&&!ga(b));return d};gb=function(){function b(a){var b,e,f=b=!1;if(!d||"function"!==typeof d.canPlayType)return b;if(a instanceof Array){b=0;for(e=a.length;b<e;b++)if(c.html5[a[b]]||d.canPlayType(a[b]).match(c.html5Test))f=
-!0,c.html5[a[b]]=!0,c.flash[a[b]]=!!a[b].match(nb);b=f}else a=d&&"function"===typeof d.canPlayType?d.canPlayType(a):!1,b=!(!a||!a.match(c.html5Test));return b}if(!c.useHTML5Audio||!c.hasHTML5)return u=c.html5.usingFlash=!0,!1;var d=Audio!==g?Oa&&10>opera.version()?new Audio(null):new Audio:null,e,a,f={},h;h=c.audioFormats;for(e in h)if(h.hasOwnProperty(e)&&(a="audio/"+e,f[e]=b(h[e].type),f[a]=f[e],e.match(nb)?(c.flash[e]=!0,c.flash[a]=!0):(c.flash[e]=!1,c.flash[a]=!1),h[e]&&h[e].related))for(a=h[e].related.length-
-1;0<=a;a--)f["audio/"+h[e].related[a]]=f[e],c.html5[h[e].related[a]]=f[e],c.flash[h[e].related[a]]=f[e];f.canPlayType=d?b:null;c.html5=B(c.html5,f);c.html5.usingFlash=fb();u=c.html5.usingFlash;return!0};I={notReady:"Unavailable - wait until onready() has fired.",notOK:"Audio support is not available.",domError:"soundManagerexception caught while appending SWF to DOM.",spcWmode:"Removing wmode, preventing known SWF loading issue(s)",swf404:"soundManager: Verify that %s is a valid path.",tryDebug:"Try soundManager.debugFlash \x3d true for more security details (output goes to SWF.)",
-checkSWF:"See SWF output for more debug info.",localFail:"soundManager: Non-HTTP page ("+m.location.protocol+" URL?) Review Flash player security settings for this special case:\nhttp://www.macromedia.com/support/documentation/en/flashplayer/help/settings_manager04.html\nMay need to add/allow path, eg. c:/sm2/ or /users/me/sm2/",waitFocus:"soundManager: Special case: Waiting for SWF to load with window focus...",waitForever:"soundManager: Waiting indefinitely for Flash (will recover if unblocked)...",
-waitSWF:"soundManager: Waiting for 100% SWF load...",needFunction:"soundManager: Function object expected for %s",badID:'Sound ID "%s" should be a string, starting with a non-numeric character',currentObj:"soundManager: _debug(): Current sound objects",waitOnload:"soundManager: Waiting for window.onload()",docLoaded:"soundManager: Document already loaded",onload:"soundManager: initComplete(): calling soundManager.onload()",onloadOK:"soundManager.onload() complete",didInit:"soundManager: init(): Already called?",
-secNote:"Flash security note: Network/internet URLs will not load due to security restrictions. Access can be configured via Flash Player Global Security Settings Page: http://www.macromedia.com/support/documentation/en/flashplayer/help/settings_manager04.html",badRemove:"soundManager: Failed to remove Flash node.",shutdown:"soundManager.disable(): Shutting down",queue:"soundManager: Queueing %s handler",smError:"SMSound.load(): Exception: JS-Flash communication failed, or JS error.",fbTimeout:"No flash response, applying .swf_timedout CSS...",
-fbLoaded:"Flash loaded",fbHandler:"soundManager: flashBlockHandler()",manURL:"SMSound.load(): Using manually-assigned URL",onURL:"soundManager.load(): current URL already assigned.",badFV:'soundManager.flashVersion must be 8 or 9. "%s" is invalid. Reverting to %s.',as2loop:"Note: Setting stream:false so looping can work (flash 8 limitation)",noNSLoop:"Note: Looping not implemented for MovieStar formats",needfl9:"Note: Switching to flash 9, required for MP4 formats.",mfTimeout:"Setting flashLoadTimeout \x3d 0 (infinite) for off-screen, mobile flash case",
-needFlash:"soundManager: Fatal error: Flash is needed to play some required formats, but is not available.",gotFocus:"soundManager: Got window focus.",policy:"Enabling usePolicyFile for data access",setup:"soundManager.setup(): allowed parameters: %s",setupError:'soundManager.setup(): "%s" cannot be assigned with this method.',setupUndef:'soundManager.setup(): Could not find option "%s"',setupLate:"soundManager.setup(): url, flashVersion and html5Test property changes will not take effect until reboot().",
-noURL:"soundManager: Flash URL required. Call soundManager.setup({url:...}) to get started.",sm2Loaded:"SoundManager 2: Ready.",reset:"soundManager.reset(): Removing event callbacks",mobileUA:"Mobile UA detected, preferring HTML5 by default.",globalHTML5:"Using singleton HTML5 Audio() pattern for this device."};r=function(){var b=hb.call(arguments),c=b.shift(),c=I&&I[c]?I[c]:"",e,a;if(c&&b&&b.length){e=0;for(a=b.length;e<a;e++)c=c.replace("%s",b[e])}return c};ma=function(b){8===n&&(1<b.loops&&b.stream)&&
-(p("as2loop"),b.stream=!1);return b};na=function(b,d){if(b&&!b.usePolicyFile&&(b.onid3||b.usePeakData||b.useWaveformData||b.useEQData))c._wD((d||"")+r("policy")),b.usePolicyFile=!0;return b};J=function(b){da&&console.warn!==g?console.warn(b):c._wD(b)};xa=function(){return!1};$a=function(b){for(var c in b)b.hasOwnProperty(c)&&"function"===typeof b[c]&&(b[c]=xa)};Ga=function(b){b===g&&(b=!1);(y||b)&&c.disable(b)};ab=function(b){var d=null;if(b)if(b.match(/\.swf(\?.*)?$/i)){if(d=b.substr(b.toLowerCase().lastIndexOf(".swf?")+
-4))return b}else b.lastIndexOf("/")!==b.length-1&&(b+="/");b=(b&&-1!==b.lastIndexOf("/")?b.substr(0,b.lastIndexOf("/")+1):"./")+c.movieURL;c.noSWFCache&&(b+="?ts\x3d"+(new Date).getTime());return b};Ca=function(){n=parseInt(c.flashVersion,10);8!==n&&9!==n&&(c._wD(r("badFV",n,8)),c.flashVersion=n=8);var b=c.debugMode||c.debugFlash?"_debug.swf":".swf";c.useHTML5Audio&&(!c.html5Only&&c.audioFormats.mp4.required&&9>n)&&(c._wD(r("needfl9")),c.flashVersion=n=9);c.version=c.versionNumber+(c.html5Only?" (HTML5-only mode)":
-9===n?" (AS3/Flash 9)":" (AS2/Flash 8)");8<n?(c.defaultOptions=B(c.defaultOptions,c.flash9Options),c.features.buffering=!0,c.defaultOptions=B(c.defaultOptions,c.movieStarOptions),c.filePatterns.flash9=RegExp("\\.(mp3|"+qb.join("|")+")(\\?.*)?$","i"),c.features.movieStar=!0):c.features.movieStar=!1;c.filePattern=c.filePatterns[8!==n?"flash9":"flash8"];c.movieURL=(8===n?"soundmanager2.swf":"soundmanager2_flash9.swf").replace(".swf",b);c.features.peakData=c.features.waveformData=c.features.eqData=8<
-n};Ya=function(b,c){if(!k)return!1;k._setPolling(b,c)};Fa=function(){c.debugURLParam.test(U)&&(c.debugMode=!0);if(A(c.debugID))return!1;var b,d,e,a;if(c.debugMode&&!A(c.debugID)&&(!da||!c.useConsole||!c.consoleOnly)){b=m.createElement("div");b.id=c.debugID+"-toggle";d={position:"fixed",bottom:"0px",right:"0px",width:"1.2em",height:"1.2em",lineHeight:"1.2em",margin:"2px",textAlign:"center",border:"1px solid #999",cursor:"pointer",background:"#fff",color:"#333",zIndex:10001};b.appendChild(m.createTextNode("-"));
-b.onclick=bb;b.title="Toggle SM2 debug console";t.match(/msie 6/i)&&(b.style.position="absolute",b.style.cursor="hand");for(a in d)d.hasOwnProperty(a)&&(b.style[a]=d[a]);d=m.createElement("div");d.id=c.debugID;d.style.display=c.debugMode?"block":"none";if(c.debugMode&&!A(b.id)){try{e=ka(),e.appendChild(b)}catch(f){throw Error(r("domError")+" \n"+f.toString());}e.appendChild(d)}}};v=this.getSoundById;p=function(b,d){return!b?"":c._wD(r(b),d)};bb=function(){var b=A(c.debugID),d=A(c.debugID+"-toggle");
-if(!b)return!1;za?(d.innerHTML="+",b.style.display="none"):(d.innerHTML="-",b.style.display="block");za=!za};C=function(b,c,e){if(h.sm2Debugger!==g)try{sm2Debugger.handleEvent(b,c,e)}catch(a){return!1}return!0};T=function(){var b=[];c.debugMode&&b.push("sm2_debug");c.debugFlash&&b.push("flash_debug");c.useHighPerformance&&b.push("high_performance");return b.join(" ")};Ia=function(){var b=r("fbHandler"),d=c.getMoviePercent(),e={type:"FLASHBLOCK"};if(c.html5Only)return!1;c.ok()?(c.didFlashBlock&&c._wD(b+
-": Unblocked"),c.oMC&&(c.oMC.className=[T(),"movieContainer","swf_loaded"+(c.didFlashBlock?" swf_unblocked":"")].join(" "))):(u&&(c.oMC.className=T()+" movieContainer "+(null===d?"swf_timedout":"swf_error"),c._wD(b+": "+r("fbTimeout")+(d?" ("+r("fbLoaded")+")":""))),c.didFlashBlock=!0,M({type:"ontimeout",ignoreInit:!0,error:e}),S(e))};Ba=function(b,c,e){F[b]===g&&(F[b]=[]);F[b].push({method:c,scope:e||null,fired:!1})};M=function(b){b||(b={type:c.ok()?"onready":"ontimeout"});if(!q&&b&&!b.ignoreInit||
-"ontimeout"===b.type&&(c.ok()||y&&!b.ignoreInit))return!1;var d={success:b&&b.ignoreInit?c.ok():!y},e=b&&b.type?F[b.type]||[]:[],a=[],f,d=[d],g=u&&!c.ok();b.error&&(d[0].error=b.error);b=0;for(f=e.length;b<f;b++)!0!==e[b].fired&&a.push(e[b]);if(a.length){b=0;for(f=a.length;b<f;b++)a[b].scope?a[b].method.apply(a[b].scope,d):a[b].method.apply(this,d),g||(a[b].fired=!0)}return!0};P=function(){h.setTimeout(function(){c.useFlashBlock&&Ia();M();"function"===typeof c.onload&&(p("onload",1),c.onload.apply(h),
-p("onloadOK",1));c.waitForWindowLoad&&w.add(h,"load",P)},1)};Ma=function(){if(H!==g)return H;var b=!1,c=navigator,e=c.plugins,a,f=h.ActiveXObject;if(e&&e.length)(c=c.mimeTypes)&&(c["application/x-shockwave-flash"]&&c["application/x-shockwave-flash"].enabledPlugin&&c["application/x-shockwave-flash"].enabledPlugin.description)&&(b=!0);else if(f!==g&&!t.match(/MSAppHost/i)){try{a=new f("ShockwaveFlash.ShockwaveFlash")}catch(m){a=null}b=!!a}return H=b};fb=function(){var b,d,e=c.audioFormats;if(ca&&t.match(/os (1|2|3_0|3_1)/i))c.hasHTML5=
-!1,c.html5Only=!0,c.oMC&&(c.oMC.style.display="none");else if(c.useHTML5Audio){if(!c.html5||!c.html5.canPlayType)c._wD("SoundManager: No HTML5 Audio() support detected."),c.hasHTML5=!1;Qa&&c._wD("soundManager: Note: Buggy HTML5 Audio in Safari on this OS X release, see https://bugs.webkit.org/show_bug.cgi?id\x3d32159 - "+(!H?" would use flash fallback for MP3/MP4, but none detected.":"will use flash fallback for MP3/MP4, if available"),1)}if(c.useHTML5Audio&&c.hasHTML5)for(d in qa=!0,e)if(e.hasOwnProperty(d)&&
-e[d].required)if(c.html5.canPlayType(e[d].type)){if(c.preferFlash&&(c.flash[d]||c.flash[e[d].type]))b=!0}else qa=!1,b=!0;c.ignoreFlash&&(b=!1,qa=!0);c.html5Only=c.hasHTML5&&c.useHTML5Audio&&!b;return!c.html5Only};pa=function(b){var d,e,a=0;if(b instanceof Array){d=0;for(e=b.length;d<e;d++)if(b[d]instanceof Object){if(c.canPlayMIME(b[d].type)){a=d;break}}else if(c.canPlayURL(b[d])){a=d;break}b[a].url&&(b[a]=b[a].url);b=b[a]}return b};cb=function(b){b._hasTimer||(b._hasTimer=!0,!Pa&&c.html5PollingInterval&&
-(null===aa&&0===oa&&(aa=setInterval(eb,c.html5PollingInterval)),oa++))};db=function(b){b._hasTimer&&(b._hasTimer=!1,!Pa&&c.html5PollingInterval&&oa--)};eb=function(){var b;if(null!==aa&&!oa)return clearInterval(aa),aa=null,!1;for(b=c.soundIDs.length-1;0<=b;b--)c.sounds[c.soundIDs[b]].isHTML5&&c.sounds[c.soundIDs[b]]._hasTimer&&c.sounds[c.soundIDs[b]]._onTimer()};S=function(b){b=b!==g?b:{};"function"===typeof c.onerror&&c.onerror.apply(h,[{type:b.type!==g?b.type:null}]);b.fatal!==g&&b.fatal&&c.disable()};
-ib=function(){if(!Qa||!Ma())return!1;var b=c.audioFormats,d,e;for(e in b)if(b.hasOwnProperty(e)&&("mp3"===e||"mp4"===e))if(c._wD("soundManager: Using flash fallback for "+e+" format"),c.html5[e]=!1,b[e]&&b[e].related)for(d=b[e].related.length-1;0<=d;d--)c.html5[b[e].related[d]]=!1};this._setSandboxType=function(b){var d=c.sandbox;d.type=b;d.description=d.types[d.types[b]!==g?b:"unknown"];"localWithFile"===d.type?(d.noRemote=!0,d.noLocal=!1,p("secNote",2)):"localWithNetwork"===d.type?(d.noRemote=!1,
-d.noLocal=!0):"localTrusted"===d.type&&(d.noRemote=!1,d.noLocal=!1)};this._externalInterfaceOK=function(b){if(c.swfLoaded)return!1;var d;C("swf",!0);C("flashtojs",!0);c.swfLoaded=!0;va=!1;Qa&&ib();if(!b||b.replace(/\+dev/i,"")!==c.versionNumber.replace(/\+dev/i,""))return d='soundManager: Fatal: JavaScript file build "'+c.versionNumber+'" does not match Flash SWF build "'+b+'" at '+c.url+". Ensure both are up-to-date.",setTimeout(function(){throw Error(d);},0),!1;setTimeout(ya,L?100:1)};la=function(b,
-d){function e(){var a=[],b,d=[];b="SoundManager "+c.version+(!c.html5Only&&c.useHTML5Audio?c.hasHTML5?" + HTML5 audio":", no HTML5 audio support":"");c.html5Only?c.html5PollingInterval&&a.push("html5PollingInterval ("+c.html5PollingInterval+"ms)"):(c.preferFlash&&a.push("preferFlash"),c.useHighPerformance&&a.push("useHighPerformance"),c.flashPollingInterval&&a.push("flashPollingInterval ("+c.flashPollingInterval+"ms)"),c.html5PollingInterval&&a.push("html5PollingInterval ("+c.html5PollingInterval+
-"ms)"),c.wmode&&a.push("wmode ("+c.wmode+")"),c.debugFlash&&a.push("debugFlash"),c.useFlashBlock&&a.push("flashBlock"));a.length&&(d=d.concat([a.join(" + ")]));c._wD(b+(d.length?" + "+d.join(", "):""),1);jb()}function a(a,b){return'\x3cparam name\x3d"'+a+'" value\x3d"'+b+'" /\x3e'}if(V&&W)return!1;if(c.html5Only)return Ca(),e(),c.oMC=A(c.movieID),ya(),W=V=!0,!1;var f=d||c.url,h=c.altURL||f,k=ka(),l=T(),n=null,n=m.getElementsByTagName("html")[0],p,s,q,n=n&&n.dir&&n.dir.match(/rtl/i);b=b===g?c.id:b;
-Ca();c.url=ab(ea?f:h);d=c.url;c.wmode=!c.wmode&&c.useHighPerformance?"transparent":c.wmode;if(null!==c.wmode&&(t.match(/msie 8/i)||!L&&!c.useHighPerformance)&&navigator.platform.match(/win32|win64/i))N.push(I.spcWmode),c.wmode=null;k={name:b,id:b,src:d,quality:"high",allowScriptAccess:c.allowScriptAccess,bgcolor:c.bgColor,pluginspage:ob+"www.macromedia.com/go/getflashplayer",title:"JS/Flash audio component (SoundManager 2)",type:"application/x-shockwave-flash",wmode:c.wmode,hasPriority:"true"};c.debugFlash&&
-(k.FlashVars="debug\x3d1");c.wmode||delete k.wmode;if(L)f=m.createElement("div"),s=['\x3cobject id\x3d"'+b+'" data\x3d"'+d+'" type\x3d"'+k.type+'" title\x3d"'+k.title+'" classid\x3d"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase\x3d"'+ob+'download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version\x3d6,0,40,0"\x3e',a("movie",d),a("AllowScriptAccess",c.allowScriptAccess),a("quality",k.quality),c.wmode?a("wmode",c.wmode):"",a("bgcolor",c.bgColor),a("hasPriority","true"),c.debugFlash?
-a("FlashVars",k.FlashVars):"","\x3c/object\x3e"].join("");else for(p in f=m.createElement("embed"),k)k.hasOwnProperty(p)&&f.setAttribute(p,k[p]);Fa();l=T();if(k=ka())if(c.oMC=A(c.movieID)||m.createElement("div"),c.oMC.id)q=c.oMC.className,c.oMC.className=(q?q+" ":"movieContainer")+(l?" "+l:""),c.oMC.appendChild(f),L&&(p=c.oMC.appendChild(m.createElement("div")),p.className="sm2-object-box",p.innerHTML=s),W=!0;else{c.oMC.id=c.movieID;c.oMC.className="movieContainer "+l;p=l=null;c.useFlashBlock||(c.useHighPerformance?
-l={position:"fixed",width:"8px",height:"8px",bottom:"0px",left:"0px",overflow:"hidden"}:(l={position:"absolute",width:"6px",height:"6px",top:"-9999px",left:"-9999px"},n&&(l.left=Math.abs(parseInt(l.left,10))+"px")));tb&&(c.oMC.style.zIndex=1E4);if(!c.debugFlash)for(q in l)l.hasOwnProperty(q)&&(c.oMC.style[q]=l[q]);try{L||c.oMC.appendChild(f),k.appendChild(c.oMC),L&&(p=c.oMC.appendChild(m.createElement("div")),p.className="sm2-object-box",p.innerHTML=s),W=!0}catch(u){throw Error(r("domError")+" \n"+
-u.toString());}}V=!0;e();return!0};ja=function(){if(c.html5Only)return la(),!1;if(k)return!1;if(!c.url)return p("noURL"),!1;k=c.getMovie(c.id);k||(Z?(L?c.oMC.innerHTML=Ha:c.oMC.appendChild(Z),Z=null,V=!0):la(c.id,c.url),k=c.getMovie(c.id));"function"===typeof c.oninitmovie&&setTimeout(c.oninitmovie,1);Na();return!0};Q=function(){setTimeout(Xa,1E3)};Xa=function(){var b,d=!1;if(!c.url||$)return!1;$=!0;w.remove(h,"load",Q);if(va&&!Ra)return p("waitFocus"),!1;q||(b=c.getMoviePercent(),0<b&&100>b&&(d=
-!0));setTimeout(function(){b=c.getMoviePercent();if(d)return $=!1,c._wD(r("waitSWF")),h.setTimeout(Q,1),!1;q||(c._wD("soundManager: No Flash response within expected time. Likely causes: "+(0===b?"SWF load failed, ":"")+"Flash blocked or JS-Flash security error."+(c.debugFlash?" "+r("checkSWF"):""),2),!ea&&b&&(p("localFail",2),c.debugFlash||p("tryDebug",2)),0===b&&c._wD(r("swf404",c.url),1),C("flashtojs",!1,": Timed out"+ea?" (Check flash security or flash blockers)":" (No plugin/missing SWF?)"));
-!q&&mb&&(null===b?c.useFlashBlock||0===c.flashLoadTimeout?(c.useFlashBlock&&Ia(),p("waitForever")):!c.useFlashBlock&&qa?h.setTimeout(function(){J("soundManager: useFlashBlock is false, 100% HTML5 mode is possible. Rebooting with preferFlash: false...");c.setup({preferFlash:!1}).reboot();c.didFlashBlock=!0;c.beginDelayedInit()},1):(p("waitForever"),M({type:"ontimeout",ignoreInit:!0})):0===c.flashLoadTimeout?p("waitForever"):Ga(!0))},c.flashLoadTimeout)};ia=function(){if(Ra||!va)return w.remove(h,"focus",
-ia),!0;Ra=mb=!0;p("gotFocus");$=!1;Q();w.remove(h,"focus",ia);return!0};Na=function(){N.length&&(c._wD("SoundManager 2: "+N.join(" "),1),N=[])};jb=function(){Na();var b,d=[];if(c.useHTML5Audio&&c.hasHTML5){for(b in c.audioFormats)c.audioFormats.hasOwnProperty(b)&&d.push(b+" \x3d "+c.html5[b]+(!c.html5[b]&&u&&c.flash[b]?" (using flash)":c.preferFlash&&c.flash[b]&&u?" (preferring flash)":!c.html5[b]?" ("+(c.audioFormats[b].required?"required, ":"")+"and no flash support)":""));c._wD("SoundManager 2 HTML5 support: "+
-d.join(", "),1)}};X=function(b){if(q)return!1;if(c.html5Only)return p("sm2Loaded"),q=!0,P(),C("onload",!0),!0;var d=!0,e;if(!c.useFlashBlock||!c.flashLoadTimeout||c.getMoviePercent())q=!0,y&&(e={type:!H&&u?"NO_FLASH":"INIT_TIMEOUT"});c._wD("SoundManager 2 "+(y?"failed to load":"loaded")+" ("+(y?"Flash security/load error":"OK")+")",y?2:1);y||b?(c.useFlashBlock&&c.oMC&&(c.oMC.className=T()+" "+(null===c.getMoviePercent()?"swf_timedout":"swf_error")),M({type:"ontimeout",error:e,ignoreInit:!0}),C("onload",
-!1),S(e),d=!1):C("onload",!0);y||(c.waitForWindowLoad&&!ha?(p("waitOnload"),w.add(h,"load",P)):(c.waitForWindowLoad&&ha&&p("docLoaded"),P()));return d};Wa=function(){var b,d=c.setupOptions;for(b in d)d.hasOwnProperty(b)&&(c[b]===g?c[b]=d[b]:c[b]!==d[b]&&(c.setupOptions[b]=c[b]))};ya=function(){if(q)return p("didInit"),!1;if(c.html5Only)return q||(w.remove(h,"load",c.beginDelayedInit),c.enabled=!0,X()),!0;ja();try{k._externalInterfaceTest(!1),Ya(!0,c.flashPollingInterval||(c.useHighPerformance?10:
-50)),c.debugMode||k._disableDebug(),c.enabled=!0,C("jstoflash",!0),c.html5Only||w.add(h,"unload",xa)}catch(b){return c._wD("js/flash exception: "+b.toString()),C("jstoflash",!1),S({type:"JS_TO_FLASH_EXCEPTION",fatal:!0}),Ga(!0),X(),!1}X();w.remove(h,"load",c.beginDelayedInit);return!0};R=function(){if(Y)return!1;Y=!0;Wa();Fa();var b=null,b=null,d=U.toLowerCase();-1!==d.indexOf("sm2-usehtml5audio\x3d")&&(b="1"===d.charAt(d.indexOf("sm2-usehtml5audio\x3d")+18),da&&console.log((b?"Enabling ":"Disabling ")+
-"useHTML5Audio via URL parameter"),c.setup({useHTML5Audio:b}));-1!==d.indexOf("sm2-preferflash\x3d")&&(b="1"===d.charAt(d.indexOf("sm2-preferflash\x3d")+16),da&&console.log((b?"Enabling ":"Disabling ")+"preferFlash via URL parameter"),c.setup({preferFlash:b}));!H&&c.hasHTML5&&(c._wD("SoundManager: No Flash detected"+(!c.useHTML5Audio?", enabling HTML5.":". Trying HTML5-only mode."),1),c.setup({useHTML5Audio:!0,preferFlash:!1}));gb();!H&&u&&(N.push(I.needFlash),c.setup({flashLoadTimeout:1}));m.removeEventListener&&
-m.removeEventListener("DOMContentLoaded",R,!1);ja();return!0};Ka=function(){"complete"===m.readyState&&(R(),m.detachEvent("onreadystatechange",Ka));return!0};Ea=function(){ha=!0;w.remove(h,"load",Ea)};Da=function(){if(Pa&&((!c.setupOptions.useHTML5Audio||c.setupOptions.preferFlash)&&N.push(I.mobileUA),c.setupOptions.useHTML5Audio=!0,c.setupOptions.preferFlash=!1,ca||lb&&!t.match(/android\s2\.3/i)))N.push(I.globalHTML5),ca&&(c.ignoreFlash=!0),E=!0};Da();Ma();w.add(h,"focus",ia);w.add(h,"load",Q);w.add(h,
-"load",Ea);m.addEventListener?m.addEventListener("DOMContentLoaded",R,!1):m.attachEvent?m.attachEvent("onreadystatechange",Ka):(C("onload",!1),S({type:"NO_DOM2_EVENTS",fatal:!0}))}var wa=null;if(void 0===h.SM2_DEFER||!SM2_DEFER)wa=new fa;h.SoundManager=fa;h.soundManager=wa})(window);
\ No newline at end of file
diff --git a/tests/gdx-tests-gwt/war/soundmanager2-setup.js b/tests/gdx-tests-gwt/war/soundmanager2-setup.js
deleted file mode 100644
index 4d0ac66..0000000
--- a/tests/gdx-tests-gwt/war/soundmanager2-setup.js
+++ /dev/null
@@ -1 +0,0 @@
-window.SM2_DEFER = true;
\ No newline at end of file
diff --git a/tests/gdx-tests-iosrobovm/src/com/badlogic/gdx/tests/IOSRobovmTests.java b/tests/gdx-tests-iosrobovm/src/com/badlogic/gdx/tests/IOSRobovmTests.java
index 0491cbd..c253d36 100644
--- a/tests/gdx-tests-iosrobovm/src/com/badlogic/gdx/tests/IOSRobovmTests.java
+++ b/tests/gdx-tests-iosrobovm/src/com/badlogic/gdx/tests/IOSRobovmTests.java
@@ -28,7 +28,7 @@ public class IOSRobovmTests extends IOSApplication.Delegate {
 	protected IOSApplication createApplication() {
 		IOSApplicationConfiguration config = new IOSApplicationConfiguration();
 		config.useAccelerometer = false;
-		return new IOSApplication(new AccelerometerTest(), config);
+		return new IOSApplication(new BulletTestCollection(), config);
 	}
 
 	public static void main(String[] argv) {
diff --git a/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java b/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java
index 18ab9d7..b0cc536 100644
--- a/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java
+++ b/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java
@@ -18,10 +18,12 @@ package com.badlogic.gdx.tests.lwjgl;
 
 import com.badlogic.gdx.backends.lwjgl.LwjglApplication;
 import com.badlogic.gdx.backends.lwjgl.LwjglApplicationConfiguration;
-import com.badlogic.gdx.tests.BitmapFontTest;
-import com.badlogic.gdx.tests.FullscreenTest;
-import com.badlogic.gdx.tests.JsonTest;
-import com.badlogic.gdx.tests.extensions.ControllersTest;
+import com.badlogic.gdx.tests.AssetManagerTest;
+import com.badlogic.gdx.tests.BitmapFontAtlasRegionTest;
+import com.badlogic.gdx.tests.BulletTestCollection;
+import com.badlogic.gdx.tests.SpriteBatchTest;
+import com.badlogic.gdx.tests.StageDebugTest;
+import com.badlogic.gdx.tests.StageTest;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
 public class LwjglDebugStarter {
@@ -33,7 +35,7 @@ public class LwjglDebugStarter {
 //		new SharedLibraryLoader("../../extensions/gdx-controllers/gdx-controllers-desktop/libs/gdx-controllers-desktop-natives.jar").load("gdx-controllers-desktop");
 //		new SharedLibraryLoader("../../gdx/libs/gdx-natives.jar").load("gdx");
 
-		GdxTest test = new BitmapFontTest();		
+		GdxTest test = new BulletTestCollection();		
 		LwjglApplicationConfiguration config = new LwjglApplicationConfiguration();
 		config.r = config.g = config.b = config.a = 8;
 //		config.width = 320;
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/GdxTests.gwt.xml b/tests/gdx-tests/src/com/badlogic/gdx/GdxTests.gwt.xml
index d860fb3..6329e67 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/GdxTests.gwt.xml
+++ b/tests/gdx-tests/src/com/badlogic/gdx/GdxTests.gwt.xml
@@ -9,7 +9,6 @@
 		<exclude name="**/ContactListenerTest.java"/> <!-- String.format, Reflection -->
 		<exclude name="**/CullTest.java"/> <!-- GL ES 1.0 -->
 		<exclude name="**/DownloadTest.java"/> <!-- Incompatible Pixmap ctor -->
-		<exclude name="**/KTXTest.java"/> <!-- use ECT1 which is native -->
 		<exclude name="**/ETC1Test.java"/> <!-- native -->
 		<exclude name="**/FFTTest.java"/> <!-- native -->
 		<exclude name="**/FramebufferToTextureTest.java"/> <!-- ScreenUtils missing -->
@@ -21,9 +20,8 @@
 		<exclude name="**/I18NMessageTest.java"/> <!-- MessageBundle -->
 		<exclude name="**/InterpolationTest.java"/> <!-- reflection -->
 		<exclude name="**/JpegTest.java"/> <!-- native -->
-		<exclude name="**/JsonReaderTest.java"/> <!-- uses ArrayList -->
 		<exclude name="**/Mpg123Test.java"/> <!-- native -->
-		<exclude name="**/PngTest.java"/> <!-- Not compatible -->
+		<exclude name="**/PayTest.java"/> <!-- Not ready -->
 		<exclude name="**/RemoteTest.java"/> <!-- networking -->
 		<exclude name="**/ScreenCaptureTest.java"/> <!-- ScreenUtils -->
 		<exclude name="**/ScreenshotTest.java"/> <!-- ScreenUtils -->
@@ -45,4 +43,4 @@
 		<exclude name="**/voxel/*.java"/> <!-- PerlinNoiseGenerator uses a method not in the emulated version of Buffer -->
 	</source>
 	<extend-configuration-property name="gdx.reflect.include" value="com.badlogic.gdx.tests.AnnotationTest" />
-</module>
+</module>
\ No newline at end of file
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/ActionTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/ActionTest.java
index 0e795c9..f5b4719 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/ActionTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/ActionTest.java
@@ -16,17 +16,21 @@
 
 package com.badlogic.gdx.tests;
 
+import static com.badlogic.gdx.scenes.scene2d.actions.Actions.delay;
+import static com.badlogic.gdx.scenes.scene2d.actions.Actions.forever;
+import static com.badlogic.gdx.scenes.scene2d.actions.Actions.sequence;
+
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.graphics.Texture.TextureFilter;
 import com.badlogic.gdx.graphics.g2d.TextureRegion;
+import com.badlogic.gdx.scenes.scene2d.Action;
 import com.badlogic.gdx.scenes.scene2d.Stage;
-import com.badlogic.gdx.scenes.scene2d.actions.Actions;
 import com.badlogic.gdx.scenes.scene2d.ui.Image;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
-public class ActionTest extends GdxTest {
+public class ActionTest extends GdxTest implements Runnable {
 	Stage stage;
 	Texture texture;
 
@@ -40,16 +44,87 @@ public class ActionTest extends GdxTest {
 		img.setOrigin(50, 50);
 		img.setPosition(100, 100);
 
-		// img.addAction(forever(sequence(delay(1.0f), new Action() {
-		// public boolean act (float delta) {
-		// System.out.println(1);
-		// img.clearActions();
-		// return true;
-		// }
-		// })));
+		img.addAction(forever(sequence(delay(1.0f), new Action() {
+			public boolean act (float delta) {
+				System.out.println(1);
+				img.clearActions();
+				return true;
+			}
+		})));
 
-		img.addAction(Actions.moveBy(100, 0, 2));
-		img.addAction(Actions.after(Actions.scaleTo(2, 2, 2)));
+		// img.action(Forever.$(Sequence.$(ScaleTo.$(1.1f,
+		// 1.1f,0.3f),ScaleTo.$(1f, 1f, 0.3f))));
+		// img.action(Forever.$(Parallel.$(RotateTo.$(1, 1))));
+		// img.action(Delay.$(RotateBy.$(45, 2),
+		// 1).setCompletionListener(this));
+// // Action actionMoveBy = MoveBy.$(30, 0, 0.5f).setCompletionListener(
+// // new OnActionCompleted() {
+// //
+// // @Override
+// // public void completed(Action action) {
+// // System.out.println("move by complete");
+// // }
+// // });
+// //
+// // Action actionDelay = Delay.$(actionMoveBy, 1).setCompletionListener(
+// // new OnActionCompleted() {
+// //
+// // @Override
+// // public void completed(Action action) {
+// // System.out.println("delay complete");
+// // }
+// // });
+// //
+// // img.action(actionDelay);
+//
+// // img.action(Repeat.$(Sequence.$(MoveBy.$(50, 0, 1), MoveBy.$(0, 50, 1), MoveBy.$(-50, 0, 1), MoveBy.$(0, -50, 1)), 3));
+// // img.action(Sequence.$(FadeOut.$(1),
+// // FadeIn.$(1),
+// // Delay.$(MoveTo.$(100, 100, 1), 2),
+// // ScaleTo.$(0.5f, 0.5f, 1),
+// // FadeOut.$(0.5f),
+// // Delay.$(Parallel.$( RotateTo.$(360, 1),
+// // FadeIn.$(1),
+// // ScaleTo.$(1, 1, 1)), 1)));
+// // OnActionCompleted listener = new OnActionCompleted() {
+// // @Override public void completed (Action action) {
+// // img.action(Parallel.$(Sequence.$(FadeOut.$(2), FadeIn.$(2)),
+// // Sequence.$(ScaleTo.$(0.1f, 0.1f, 1.5f), ScaleTo.$(1.0f, 1.0f, 1.5f))).setCompletionListener(this));
+// // }
+// // };
+// //
+// // img.action(Parallel.$(Sequence.$(FadeOut.$(2), FadeIn.$(2)),
+// // Sequence.$(ScaleTo.$(0.1f, 0.1f, 1.5f), ScaleTo.$(1.0f, 1.0f, 1.5f))).setCompletionListener(listener));
+//
+// // img.action(
+// // Sequence.$(
+// // Parallel.$(RotateBy.$(180, 2), ScaleTo.$(1.4f, 1.4f, 2), FadeTo.$(0.7f, 2)),
+// // Parallel.$(RotateBy.$(180, 2), ScaleTo.$(1.0f, 1.0f, 2), FadeTo.$(1.0f, 2)),
+// // Remove.$()
+// // )
+// // );
+// //
+// // Action action = Repeat.$(Sequence.$(
+// // MoveBy.$(8, 0, 0.5f),
+// // MoveBy.$(0, 8, 0.5f),
+// // MoveBy.$(-8, 0, 0.5f),
+// // MoveBy.$(0, -8, 0.5f)), 20);
+// // Action action2 = action.copy();
+// // img.action(action2);
+//
+// // float scale = 1;
+// // float showDuration = 1;
+// // ScaleTo scaleCountdown = ScaleTo.$(scale * 1.0f, scale * 1.0f, 1.0f);
+// // scaleCountdown.setInterpolator(DecelerateInterpolator.$(3.0f));
+// // Parallel parallel = Parallel.$(scaleCountdown);
+// // // Sequence.$(FadeIn.$(0.25f), Delay.$(FadeOut.$(0.25f), 0.5f)));
+// // Sequence cdAnim = Sequence.$(Delay.$(parallel, showDuration), Remove.$());
+// // cdAnim.setCompletionListener(this);
+// // img.action(cdAnim);
+// //
+// // Delay delay = Delay.$(MoveBy.$(100, 100, 1).setCompletionListener(this), 1);
+// // delay.setCompletionListener(this);
+// // img.action(Sequence.$(delay).setCompletionListener(this));
 
 		stage.addActor(img);
 	}
@@ -62,6 +137,11 @@ public class ActionTest extends GdxTest {
 	}
 
 	@Override
+	public void run () {
+		System.out.println("completed action");
+	}
+
+	@Override
 	public void dispose () {
 		stage.dispose();
 		texture.dispose();
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontTest.java
index 11c4909..637a21c 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontTest.java
@@ -62,9 +62,9 @@ public class BitmapFontTest extends GdxTest {
 
 		// Notice that the last [] has been deliberately added to test the effect of excessive pop operations.
 		// They are silently ignored, as expected.
-		Label label = new Label("<<[BLUE]M[RED]u[YELLOW]l[GREEN]t[OLIVE]ic[]o[]l[]o[]r[]*[MAROON]Label[][] [Unknown Color]>>", skin);
+		Label label = new Label("<<[BLUE]M[RED]u[YELLOW]l[GREEN]t[OLIVE]ic[]o[]l[]o[]r[]*[MAROON]Label[][]>>", skin);
 
-		label.setPosition(100, 200);
+		label.setPosition(200, 200);
 		stage.addActor(label);
 
 		Window window = new Window("[RED]Multicolor[GREEN] Title", skin);
@@ -139,11 +139,6 @@ public class BitmapFontTest extends GdxTest {
 
 		cache.draw(spriteBatch);
 
-		// tinting
-		cache.tint(new Color(1f, 1f, 1f, 0.3f));
-		cache.translate(0f, 40f);
-		cache.draw(spriteBatch);
-
 		spriteBatch.end();
 		// System.out.println(spriteBatch.renderCalls);
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/BufferUtilsTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/BufferUtilsTest.java
index c2d31cb..f5a927b 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/BufferUtilsTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/BufferUtilsTest.java
@@ -61,11 +61,6 @@ public class BufferUtilsTest extends GdxTest {
 		checkInt(cb.get(), 2);
 		checkInt(cb.get(), 3);
 		checkInt(cb.get(), 4);
-		cb.position(0);
-		BufferUtils.copy(new char[] {5, 6, 7, 8}, 1, cb, 3);
-		checkInt(cb.get(), 6);
-		checkInt(cb.get(), 7);
-		checkInt(cb.get(), 8);
 		
 		sb.position(4);
 		BufferUtils.copy(new short[] {1, 2, 3, 4}, 0, sb, 4);
@@ -73,11 +68,6 @@ public class BufferUtilsTest extends GdxTest {
 		checkInt(sb.get(), 2);
 		checkInt(sb.get(), 3);
 		checkInt(sb.get(), 4);
-		sb.position(0);
-		BufferUtils.copy(new short[] {5, 6, 7, 8}, 1, sb, 3);
-		checkInt(sb.get(), 6);
-		checkInt(sb.get(), 7);
-		checkInt(sb.get(), 8);
 
 		ib.position(4);
 		BufferUtils.copy(new int[] {1, 2, 3, 4}, 0, ib, 4);
@@ -85,11 +75,6 @@ public class BufferUtilsTest extends GdxTest {
 		checkInt(ib.get(), 2);
 		checkInt(ib.get(), 3);
 		checkInt(ib.get(), 4);
-		ib.position(0);
-		BufferUtils.copy(new int[] {5, 6, 7, 8}, 1, ib, 3);
-		checkInt(ib.get(), 6);
-		checkInt(ib.get(), 7);
-		checkInt(ib.get(), 8);
 		
 		lb.position(4);
 		BufferUtils.copy(new long[] {1, 2, 3, 4}, 0, lb, 4);
@@ -97,11 +82,6 @@ public class BufferUtilsTest extends GdxTest {
 		checkInt(lb.get(), 2);
 		checkInt(lb.get(), 3);
 		checkInt(lb.get(), 4);
-		lb.position(0);
-		BufferUtils.copy(new long[] {5, 6, 7, 8}, 1, lb, 3);
-		checkInt(lb.get(), 6);
-		checkInt(lb.get(), 7);
-		checkInt(lb.get(), 8);
 
 		fb.position(4);
 		BufferUtils.copy(new float[] {1, 2, 3, 4}, 0, fb, 4);
@@ -109,11 +89,6 @@ public class BufferUtilsTest extends GdxTest {
 		checkFloat(fb.get(), 2);
 		checkFloat(fb.get(), 3);
 		checkFloat(fb.get(), 4);
-		fb.position(0);
-		BufferUtils.copy(new float[] {5, 6, 7, 8}, 1, fb, 3);
-		checkFloat(fb.get(), 6);
-		checkFloat(fb.get(), 7);
-		checkFloat(fb.get(), 8);
 
 		if (Gdx.app.getType() != ApplicationType.WebGL) { // gwt throws: NYI: Numbers.doubleToRawLongBits
 			db.position(4);
@@ -122,11 +97,6 @@ public class BufferUtilsTest extends GdxTest {
 			checkFloat(db.get(), 2);
 			checkFloat(db.get(), 3);
 			checkFloat(db.get(), 4);
-			db.position(0);
-			BufferUtils.copy(new double[] {5, 6, 7, 8}, 1, db, 3);
-			checkFloat(db.get(), 6);
-			checkFloat(db.get(), 7);
-			checkFloat(db.get(), 8);
 		}
 
 		ByteBuffer bb2 = BufferUtils.newByteBuffer(4);
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/BulletTestCollection.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/BulletTestCollection.java
index d57806e..a522393 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/BulletTestCollection.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/BulletTestCollection.java
@@ -36,10 +36,10 @@ import com.badlogic.gdx.tests.utils.GdxTest;
 /** @author xoppa */
 public class BulletTestCollection extends GdxTest implements InputProcessor, GestureListener {
 	protected final BulletTest[] tests = {new BasicBulletTest(), new ShootTest(), new BasicShapesTest(), new KinematicTest(),
-		new ConstraintsTest(), new MeshShapeTest(), new GimpactTest(), new ConvexHullTest(), new ConvexHullDistanceTest(),
-		new RayCastTest(), new RayPickRagdollTest(), new InternalTickTest(), new CollisionWorldTest(), new CollisionTest(),
-		new FrustumCullingTest(), new CollisionDispatcherTest(), new ContactCallbackTest(), new ContactCallbackTest2(),
-		new ContactCacheTest(), new SoftBodyTest(), new SoftMeshTest(), new VehicleTest(), new CharacterTest(), new ImportTest()};
+		new ConstraintsTest(), new MeshShapeTest(), new ConvexHullTest(), new ConvexHullDistanceTest(), new RayCastTest(),
+		new RayPickRagdollTest(), new InternalTickTest(), new CollisionWorldTest(), new CollisionTest(), new FrustumCullingTest(),
+		new CollisionDispatcherTest(), new ContactCallbackTest(), new ContactCallbackTest2(), new ContactCacheTest(),
+		new SoftBodyTest(), new SoftMeshTest(), new VehicleTest(), new CharacterTest(), new ImportTest()};
 
 	protected int testIndex = 0;
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/FloatTextureTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/FloatTextureTest.java
index 6376f8c..062c7b3 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/FloatTextureTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/FloatTextureTest.java
@@ -43,63 +43,36 @@ public class FloatTextureTest extends GdxTest {
 		fb = new FrameBuffer(Format.RGBA8888, 200, 100, false);
 		ffb = new FloatFrameBuffer(200, 100, false);
 
-		// @off
-		String vertexShader = 
-			  "attribute vec4 a_position; "
-			+ "varying vec2 v_position; "
-			+ "void main(){ "
-			+ "    v_position = a_position.xy; "
-			+ "    gl_Position = vec4(a_position.x, a_position.y, 0.0, 1.0); "
+		String vertexShader = "attribute vec4 a_position; " + "varying vec2 v_position; " +
+
+		"void main(){ " + "    v_position = a_position.xy; " + "    gl_Position = vec4(a_position.x, a_position.y, 0.0, 1.0); "
 			+ "}";
 
-		String fragmentShader = 
-			  "#ifdef GL_ES\n"
-		   + "precision mediump float;\n"
-		   + "#endif\n" + "uniform vec3 u_color;"
-			+ "uniform vec2 u_viewport; "
-		   + "void main(void){ "
-			+ "    vec2 uv = gl_FragCoord.xy/u_viewport; "
-		   + "    float res = mix(0.0, 0.0001, uv.x); " // <--- // regular (non-float) texture loses precision here, res == 0 for every fragment
-			+ "    gl_FragColor = vec4(u_color, res); "
-		   + "}";
+		String fragmentShader = "#ifdef GL_ES\n" + "precision mediump float;\n" + "#endif\n" + "uniform vec3 u_color;"
+			+ "uniform vec2 u_viewport; " +
+
+			"void main(void){ " + "    vec2 uv = gl_FragCoord.xy/u_viewport; " + "    float res = mix(0.0, 0.0001, uv.x); " + // <---
+// regular (non-float) texture loses precision here, res == 0 for every fragment
+			"    gl_FragColor = vec4(u_color, res); " + "}";
 
 		fbshader = new ShaderProgram(vertexShader, fragmentShader);
 
-		vertexShader = 
-			  "attribute vec4 a_position; "
-		   + "attribute vec4 a_color; "
-		   + "attribute vec2 a_texCoords; "
-			+ "uniform mat4 u_worldView; "
-		   + "varying vec4 v_color; "
-			+ "varying vec2 v_texCoords; "
-		   + "void main() "
-			+ "{ "
-		   + "    v_color = a_color; "
-			+ "    v_texCoords = a_texCoords; "
-			+ "    gl_Position =  u_worldView * a_position; "
-			+ "}";
+		vertexShader = "attribute vec4 a_position; " + "attribute vec4 a_color; " + "attribute vec2 a_texCoords; "
+			+ "uniform mat4 u_worldView; " + "varying vec4 v_color; " + "varying vec2 v_texCoords; " +
+
+			"void main() " + "{ " + "    v_color = a_color; " + "    v_texCoords = a_texCoords; "
+			+ "    gl_Position =  u_worldView * a_position; " + "}";
+
+		fragmentShader = "#ifdef GL_ES\n" + "precision mediump float;\n" + "#endif\n" + "varying vec2 v_texCoords; "
+			+ "uniform sampler2D u_fbtex, u_ffbtex; " +
+
+			"vec4 getValue(vec4 col) {" + "    if (col.a > 0.00005)" + "        return vec4(col.rgb, 1.0);" + "    else"
+			+ "        return vec4(0.0, 0.0, 0.0, 1.0);" + "}" +
+
+			"void main() " + "{ " + "    if (v_texCoords.y < 0.45)"
+			+ "        gl_FragColor = getValue(texture2D(u_fbtex, v_texCoords)); " + "    else if (v_texCoords.y > 0.55)"
+			+ "        gl_FragColor = getValue(texture2D(u_ffbtex, v_texCoords)); " + "}";
 
-		fragmentShader =
-			  "#ifdef GL_ES\n"
-		   + "precision mediump float;\n"
-			+ "#endif\n"
-		   + "varying vec2 v_texCoords; "
-			+ "uniform sampler2D u_fbtex, u_ffbtex; "
-			+ "vec4 getValue(vec4 col) {"
-			+ "    if (col.a > 0.00005)"
-			+ "        return vec4(col.rgb, 1.0);"
-			+ "    else"
-			+ "        return vec4(0.0, 0.0, 0.0, 1.0);"
-			+ "}"
-			+ "void main() "
-			+ "{ "
-			+ "    if (v_texCoords.y < 0.45)"
-			+ "        gl_FragColor = getValue(texture2D(u_fbtex, v_texCoords)); "
-			+ "    else if (v_texCoords.y > 0.55)"
-			+ "        gl_FragColor = getValue(texture2D(u_ffbtex, v_texCoords)); "
-			+ "}";
-		// @on
-		
 		shader = new ShaderProgram(vertexShader, fragmentShader);
 		createQuad();
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/FullscreenTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/FullscreenTest.java
index f7e14ae..e7ed10b 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/FullscreenTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/FullscreenTest.java
@@ -19,22 +19,18 @@ package com.badlogic.gdx.tests;
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.Graphics.DisplayMode;
 import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.gdx.graphics.Mesh;
 import com.badlogic.gdx.graphics.Texture;
-import com.badlogic.gdx.graphics.g2d.BitmapFont;
-import com.badlogic.gdx.graphics.g2d.SpriteBatch;
+import com.badlogic.gdx.graphics.VertexAttribute;
+import com.badlogic.gdx.graphics.VertexAttributes.Usage;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
 public class FullscreenTest extends GdxTest {
-	SpriteBatch batch;
-	Texture tex;
+
 	boolean fullscreen = false;
-	BitmapFont font;
 
 	@Override
 	public void create () {
-		batch = new SpriteBatch();
-		font = new BitmapFont();
-		tex = new Texture(Gdx.files.internal("data/badlogic.jpg"));
 		DisplayMode[] modes = Gdx.graphics.getDisplayModes();
 		for (DisplayMode mode : modes) {
 			System.out.println(mode);
@@ -49,35 +45,16 @@ public class FullscreenTest extends GdxTest {
 
 	@Override
 	public void render () {
-		Gdx.gl.glClearColor(0, 0, 0, 1);
+		Gdx.gl.glClearColor((float)Math.random(), 0, 0, 1);
 		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
-		
-		batch.begin();
-		batch.draw(tex, Gdx.input.getX(), Gdx.graphics.getHeight() - Gdx.input.getY());
-		font.draw(batch, "" + Gdx.graphics.getWidth() + ", " + Gdx.graphics.getHeight(), 0, 20);
-		batch.end();
-		
+
 		if (Gdx.input.justTouched()) {
 			if (fullscreen) {
 				Gdx.graphics.setDisplayMode(480, 320, false);
-				batch.getProjectionMatrix().setToOrtho2D(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
-				Gdx.gl.glViewport(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
 				fullscreen = false;
 			} else {
-				DisplayMode m = null;
-				for(DisplayMode mode: Gdx.graphics.getDisplayModes()) {
-					if(m == null) {
-						m = mode;
-					} else {
-						if(m.width < mode.width) {
-							m = mode;
-						}
-					}
-				}
-				
-				Gdx.graphics.setDisplayMode(m);
-				batch.getProjectionMatrix().setToOrtho2D(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
-				Gdx.gl.glViewport(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
+				DisplayMode desktopDisplayMode = Gdx.graphics.getDesktopDisplayMode();
+				Gdx.graphics.setDisplayMode(desktopDisplayMode.width, desktopDisplayMode.height, true);
 				fullscreen = true;
 			}
 		}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/I18NMessageTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/I18NMessageTest.java
index 826e333..bf13b46 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/I18NMessageTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/I18NMessageTest.java
@@ -50,7 +50,7 @@ public class I18NMessageTest extends GdxTest {
 
 		try {
 			FileHandle bfh = Gdx.files.internal("data/i18n/message1");
-			rb_root = I18NBundle.createBundle(bfh, new Locale("", "", "")); // Locale.ROOT doesn't exist in Android API level 8
+			rb_root = I18NBundle.createBundle(bfh, Locale.ROOT);
 			rb_default = I18NBundle.createBundle(bfh);
 			rb_en = I18NBundle.createBundle(bfh, new Locale("en", "US"));
 			rb_it = I18NBundle.createBundle(bfh, new Locale("it", "IT"));
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/I18NSimpleMessageTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/I18NSimpleMessageTest.java
index 2784e2b..0e24acd 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/I18NSimpleMessageTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/I18NSimpleMessageTest.java
@@ -52,7 +52,7 @@ public class I18NSimpleMessageTest extends GdxTest {
 
 		try {
 			FileHandle bfh = Gdx.files.internal("data/i18n/message2");
-			rb_root = I18NBundle.createBundle(bfh, new Locale("", "", "")); // Locale.ROOT doesn't exist in Android API level 8
+			rb_root = I18NBundle.createBundle(bfh, Locale.ROOT);
 			rb_default = I18NBundle.createBundle(bfh);
 			rb_en = I18NBundle.createBundle(bfh, new Locale("en", "US"));
 			rb_it = I18NBundle.createBundle(bfh, new Locale("it", "IT"));
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/JsonTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/JsonTest.java
deleted file mode 100644
index efa4cc3..0000000
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/JsonTest.java
+++ /dev/null
@@ -1,245 +0,0 @@
-
-package com.badlogic.gdx.tests;
-
-import java.util.ArrayList;
-
-import com.badlogic.gdx.tests.utils.GdxTest;
-import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.Json;
-import com.badlogic.gdx.utils.ObjectMap;
-import com.badlogic.gdx.utils.reflect.ArrayReflection;
-
-public class JsonTest extends GdxTest {
-	Json json;
-
-	public void create () {
-		json = new Json();
-
-// json.fromJson(Test1.class, //
-// "{byteArrayField:[-1\n,-2]}"
-// );
-// if (true) return;
-
-		Test1 test = new Test1();
-		test.booleanField = true;
-		test.byteField = 123;
-		test.charField = 'Z';
-		test.shortField = 12345;
-		test.intField = 123456;
-		test.longField = 123456789;
-		test.floatField = 123.456f;
-		test.doubleField = 1.23456d;
-		test.BooleanField = true;
-		test.ByteField = -12;
-		test.CharacterField = 'X';
-		test.ShortField = -12345;
-		test.IntegerField = -123456;
-		test.LongField = -123456789l;
-		test.FloatField = -123.3f;
-		test.DoubleField = -0.121231d;
-		test.stringField = "stringvalue";
-		test.byteArrayField = new byte[] {2, 1, 0, -1, -2};
-		test.map = new ObjectMap();
-		test.map.put("one", 1);
-		test.map.put("two", 2);
-		test.map.put("nine", 9);
-		test.array = new Array();
-		test.array.add("meow");
-		test.array.add("moo");
-		roundTrip(test);
-
-		test = new Test1();
-		roundTrip(test);
-
-		test.array = new Array();
-		roundTrip(test);
-
-		test.array.add("meow");
-		roundTrip(test);
-
-		test.array.add("moo");
-		roundTrip(test);
-
-		test = new Test1();
-		test.map = new ObjectMap();
-		roundTrip(test);
-
-		test.map.put("one", 1);
-		roundTrip(test);
-
-		test.map.put("two", 2);
-		test.map.put("nine", 9);
-		roundTrip(test);
-
-		test.map.put("\nst\nuff\n", 9);
-		test.map.put("\r\nst\r\nuff\r\n", 9);
-		roundTrip(test);
-
-		equals(json.toJson("meow"), "meow");
-		equals(json.toJson("meow "), "\"meow \"");
-		equals(json.toJson(" meow"), "\" meow\"");
-		equals(json.toJson(" meow "), "\" meow \"");
-		equals(json.toJson("\nmeow\n"), "\\nmeow\\n");
-		equals(json.toJson(Array.with(1, 2, 3), null, int.class), "[1,2,3]");
-		equals(json.toJson(Array.with("1", "2", "3"), null, String.class), "[1,2,3]");
-		equals(json.toJson(Array.with(" 1", "2 ", " 3 "), null, String.class), "[\" 1\",\"2 \",\" 3 \"]");
-		equals(json.toJson(Array.with("1", "", "3"), null, String.class), "[1,\"\",3]");
-
-		System.out.println();
-		System.out.println("Success!");
-	}
-
-	private String roundTrip (Object object) {
-		String text = json.toJson(object);
-		System.out.println(text);
-		test(text, object);
-
-		text = json.prettyPrint(object, 130);
-		test(text, object);
-
-		return text;
-	}
-
-	private void test (String text, Object object) {
-		check(text, object);
-
-		text = text.replace("{", "/*moo*/{/*moo*/");
-		check(text, object);
-
-		text = text.replace("}", "/*moo*/}/*moo*/");
-		text = text.replace("[", "/*moo*/[/*moo*/");
-		text = text.replace("]", "/*moo*/]/*moo*/");
-		text = text.replace(":", "/*moo*/:/*moo*/");
-		text = text.replace(",", "/*moo*/,/*moo*/");
-		check(text, object);
-
-		text = text.replace("/*moo*/", " /*moo*/ ");
-		check(text, object);
-
-		text = text.replace("/*moo*/", "// moo\n");
-		check(text, object);
-
-		text = text.replace("\n", "\r\n");
-		check(text, object);
-
-		text = text.replace(",", "\n");
-		check(text, object);
-
-		text = text.replace("\n", "\r\n");
-		check(text, object);
-
-		text = text.replace("\r\n", "\r\n\r\n");
-		check(text, object);
-	}
-
-	private void check (String text, Object object) {
-		Object object2 = json.fromJson(object.getClass(), text);
-		equals(object, object2);
-	}
-
-	private void equals (Object a, Object b) {
-		if (!a.equals(b)) throw new RuntimeException("Fail!\n" + a + "\n!=\n" + b);
-	}
-
-	static public class Test1 {
-		// Primitives.
-		public boolean booleanField;
-		public byte byteField;
-		public char charField;
-		public short shortField;
-		public int intField;
-		public long longField;
-		public float floatField;
-		public double doubleField;
-		// Primitive wrappers.
-		public Boolean BooleanField;
-		public Byte ByteField;
-		public Character CharacterField;
-		public Short ShortField;
-		public Integer IntegerField;
-		public Long LongField;
-		public Float FloatField;
-		public Double DoubleField;
-		// Other.
-		public String stringField;
-		public byte[] byteArrayField;
-		public Object object;
-		public ObjectMap<String, Integer> map;
-		public Array<String> array;
-
-		public boolean equals (Object obj) {
-			if (this == obj) return true;
-			if (obj == null) return false;
-			if (getClass() != obj.getClass()) return false;
-			Test1 other = (Test1)obj;
-			if (BooleanField == null) {
-				if (other.BooleanField != null) return false;
-			} else if (!BooleanField.equals(other.BooleanField)) return false;
-			if (ByteField == null) {
-				if (other.ByteField != null) return false;
-			} else if (!ByteField.equals(other.ByteField)) return false;
-			if (CharacterField == null) {
-				if (other.CharacterField != null) return false;
-			} else if (!CharacterField.equals(other.CharacterField)) return false;
-			if (DoubleField == null) {
-				if (other.DoubleField != null) return false;
-			} else if (!DoubleField.equals(other.DoubleField)) return false;
-			if (FloatField == null) {
-				if (other.FloatField != null) return false;
-			} else if (!FloatField.equals(other.FloatField)) return false;
-			if (IntegerField == null) {
-				if (other.IntegerField != null) return false;
-			} else if (!IntegerField.equals(other.IntegerField)) return false;
-			if (LongField == null) {
-				if (other.LongField != null) return false;
-			} else if (!LongField.equals(other.LongField)) return false;
-			if (ShortField == null) {
-				if (other.ShortField != null) return false;
-			} else if (!ShortField.equals(other.ShortField)) return false;
-			if (stringField == null) {
-				if (other.stringField != null) return false;
-			} else if (!stringField.equals(other.stringField)) return false;
-			if (booleanField != other.booleanField) return false;
-
-			Object list1 = arrayToList(byteArrayField);
-			Object list2 = arrayToList(other.byteArrayField);
-			if (list1 != list2) {
-				if (list1 == null || list2 == null) return false;
-				if (!list1.equals(list2)) return false;
-			}
-
-			if (object != other.object) {
-				if (object == null || other.object == null) return false;
-				if (object != this && !object.equals(other.object)) return false;
-			}
-
-			if (map != other.map) {
-				if (map == null || other.map == null) return false;
-				if (!map.keys().toArray().equals(other.map.keys().toArray())) return false;
-				if (!map.values().toArray().equals(other.map.values().toArray())) return false;
-			}
-
-			if (array != other.array) {
-				if (array == null || other.array == null) return false;
-				if (!array.equals(other.array)) return false;
-			}
-
-			if (byteField != other.byteField) return false;
-			if (charField != other.charField) return false;
-			if (Double.doubleToLongBits(doubleField) != Double.doubleToLongBits(other.doubleField)) return false;
-			if (Float.floatToIntBits(floatField) != Float.floatToIntBits(other.floatField)) return false;
-			if (intField != other.intField) return false;
-			if (longField != other.longField) return false;
-			if (shortField != other.shortField) return false;
-			return true;
-		}
-	}
-
-	static Object arrayToList (Object array) {
-		if (array == null || !array.getClass().isArray()) return array;
-		ArrayList list = new ArrayList(ArrayReflection.getLength(array));
-		for (int i = 0, n = ArrayReflection.getLength(array); i < n; i++)
-			list.add(arrayToList(ArrayReflection.get(array, i)));
-		return list;
-	}
-}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/KTXTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/KTXTest.java
deleted file mode 100644
index da89c66..0000000
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/KTXTest.java
+++ /dev/null
@@ -1,217 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.tests;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.InputMultiplexer;
-import com.badlogic.gdx.graphics.Color;
-import com.badlogic.gdx.graphics.Cubemap;
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.OrthographicCamera;
-import com.badlogic.gdx.graphics.PerspectiveCamera;
-import com.badlogic.gdx.graphics.Texture;
-import com.badlogic.gdx.graphics.Texture.TextureFilter;
-import com.badlogic.gdx.graphics.VertexAttributes.Usage;
-import com.badlogic.gdx.graphics.g2d.SpriteBatch;
-import com.badlogic.gdx.graphics.g3d.Environment;
-import com.badlogic.gdx.graphics.g3d.Material;
-import com.badlogic.gdx.graphics.g3d.Model;
-import com.badlogic.gdx.graphics.g3d.ModelBatch;
-import com.badlogic.gdx.graphics.g3d.ModelInstance;
-import com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute;
-import com.badlogic.gdx.graphics.g3d.attributes.CubemapAttribute;
-import com.badlogic.gdx.graphics.g3d.environment.DirectionalLight;
-import com.badlogic.gdx.graphics.g3d.shaders.DefaultShader.Config;
-import com.badlogic.gdx.graphics.g3d.utils.CameraInputController;
-import com.badlogic.gdx.graphics.g3d.utils.DefaultShaderProvider;
-import com.badlogic.gdx.graphics.g3d.utils.ModelBuilder;
-import com.badlogic.gdx.graphics.glutils.KTXTextureData;
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-import com.badlogic.gdx.math.MathUtils;
-import com.badlogic.gdx.tests.utils.GdxTest;
-
-/** Simple test and example for the KTX/ZKTX file format
- * @author Vincent Bousquet */
-public class KTXTest extends GdxTest {
-
-	// 3D texture cubemap example
-	private PerspectiveCamera perspectiveCamera;
-	private CameraInputController inputController;
-	private ModelBatch modelBatch;
-	private Model model;
-	private ModelInstance instance;
-	private Environment environment;
-	private Cubemap cubemap;
-
-	// 2D texture alpha ETC1 example
-	private OrthographicCamera orthoCamera;
-	private Texture image;
-	private SpriteBatch batch;
-	private ShaderProgram etc1aShader;
-
-	// animation
-	private float time;
-
-	@Override
-	public void create () {
-
-		// Cubemap test
-
-		String cubemapVS = "" //
-			+ "attribute vec3 a_position;\n"//
-			+ "uniform mat4 u_projViewTrans;\n"//
-			+ "uniform mat4 u_worldTrans;\n"//
-			+ "\n"//
-			+ "varying vec3 v_cubeMapUV;\n"//
-			+ "\n"//
-			+ "void main() {\n"//
-			+ "   vec4 g_position = vec4(a_position, 1.0);\n"//
-			+ "   g_position = u_worldTrans * g_position;\n"//
-			+ "   v_cubeMapUV = normalize(g_position.xyz);\n"//
-			+ "   gl_Position = u_projViewTrans * g_position;\n"//
-			+ "}";
-		String cubemapFS = ""//
-			+ "#ifdef GL_ES\n"//
-			+ "precision mediump float;\n"//
-			+ "#endif\n"//
-			+ "uniform samplerCube u_environmentCubemap;\n"//
-			+ "varying vec3 v_cubeMapUV;\n"//
-			+ "void main() {\n" //
-			+ "	gl_FragColor = vec4(textureCube(u_environmentCubemap, v_cubeMapUV).rgb, 1.0);\n" //
-			+ "}\n";
-		modelBatch = new ModelBatch(new DefaultShaderProvider(new Config(cubemapVS, cubemapFS)));
-
-		cubemap = new Cubemap(new KTXTextureData(Gdx.files.internal("data/cubemap.zktx"), true));
-		cubemap.setFilter(TextureFilter.MipMapLinearLinear, TextureFilter.Linear);
-
-		environment = new Environment();
-		environment.set(new ColorAttribute(ColorAttribute.AmbientLight, 0.1f, 0.1f, 0.1f, 1.f));
-		environment.add(new DirectionalLight().set(0.8f, 0.8f, 0.8f, -0.5f, -1.0f, -0.8f));
-		environment.set(new CubemapAttribute(CubemapAttribute.EnvironmentMap, cubemap));
-
-		perspectiveCamera = new PerspectiveCamera(67, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
-		perspectiveCamera.position.set(10f, 10f, 10f);
-		perspectiveCamera.lookAt(0, 0, 0);
-		perspectiveCamera.near = 0.1f;
-		perspectiveCamera.far = 300f;
-		perspectiveCamera.update();
-
-		ModelBuilder modelBuilder = new ModelBuilder();
-		model = modelBuilder.createBox(5f, 5f, 5f, new Material(ColorAttribute.createDiffuse(Color.GREEN)), Usage.Position
-			| Usage.Normal);
-		instance = new ModelInstance(model);
-
-		Gdx.input.setInputProcessor(new InputMultiplexer(this, inputController = new CameraInputController(perspectiveCamera)));
-
-		// 2D texture test
-		String etc1aVS = "" //
-			+ "uniform mat4 u_projTrans;\n"//
-			+ "\n"//
-			+ "attribute vec4 a_position;\n"//
-			+ "attribute vec2 a_texCoord0;\n"//
-			+ "attribute vec4 a_color;\n"//
-			+ "\n"//
-			+ "varying vec4 v_color;\n"//
-			+ "varying vec2 v_texCoord;\n"//
-			+ "\n"//
-			+ "void main() {\n"//
-			+ "   gl_Position = u_projTrans * a_position;\n"//
-			+ "   v_texCoord = a_texCoord0;\n"//
-			+ "   v_color = a_color;\n"//
-			+ "}\n";//
-		String etc1aFS = ""//
-			+ "#ifdef GL_ES\n"//
-			+ "precision mediump float;\n"//
-			+ "#endif\n"//
-			+ "uniform sampler2D u_texture;\n"//
-			+ "\n"//
-			+ "varying vec4 v_color;\n"//
-			+ "varying vec2 v_texCoord;\n"//
-			+ "\n"//
-			+ "void main() {\n"//
-			+ "   vec3 col = texture2D(u_texture, v_texCoord.st).rgb;\n"//
-			+ "   float alpha = texture2D(u_texture, v_texCoord.st + vec2(0.0, 0.5)).r;\n"//
-			+ "   gl_FragColor = vec4(col, alpha) * v_color;\n"//
-			+ "}\n";//
-		etc1aShader = new ShaderProgram(etc1aVS, etc1aFS);
-		orthoCamera = new OrthographicCamera(Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
-		image = new Texture("data/egg.zktx");
-		batch = new SpriteBatch(100, etc1aShader);
-
-	}
-
-	@Override
-	public void render () {
-		time += Gdx.graphics.getDeltaTime();
-		inputController.update();
-		int gw = Gdx.graphics.getWidth(), gh = Gdx.graphics.getHeight();
-		int pw = gw > gh ? gw / 2 : gw, ph = gw > gh ? gh : gh / 2;
-
-		Gdx.gl.glClearColor(0, 0, 0, 1);
-		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT | GL20.GL_DEPTH_BUFFER_BIT);
-
-		// cubemap
-		Gdx.gl.glViewport(gw - pw, gh - ph, pw, ph);
-		perspectiveCamera.viewportWidth = pw;
-		perspectiveCamera.viewportHeight = ph;
-		perspectiveCamera.update();
-		modelBatch.begin(perspectiveCamera);
-		modelBatch.render(instance, environment);
-		modelBatch.end();
-
-		// 2D texture with alpha & ETC1
-		Gdx.gl.glViewport(0, 0, pw, ph);
-		orthoCamera.viewportWidth = pw;
-		orthoCamera.viewportHeight = ph;
-		orthoCamera.update();
-		batch.setProjectionMatrix(orthoCamera.combined);
-		batch.begin();
-		float s = 0.1f + 0.5f * (1 + MathUtils.sinDeg(time * 90.0f));
-		float w = s * image.getWidth(), h = s * image.getHeight() / 2, x = -w / 2, y = -h / 2;
-		batch.setShader(null);
-		batch.disableBlending();
-		batch.draw(image, -pw / 2, -ph / 2, pw, ph, 0, 1, 1, 0);
-		batch.setShader(etc1aShader);
-		batch.enableBlending();
-		batch.draw(image, x, y, w, h, 0, 0.5f, 1, 0);
-		batch.end();
-	}
-
-	@Override
-	public void dispose () {
-		modelBatch.dispose();
-		model.dispose();
-		cubemap.dispose();
-		image.dispose();
-		batch.dispose();
-		etc1aShader.dispose();
-	}
-
-	public boolean needsGL20 () {
-		return true;
-	}
-
-	public void resume () {
-	}
-
-	public void resize (int width, int height) {
-	}
-
-	public void pause () {
-	}
-
-}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/MusicTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/MusicTest.java
index 62fe024..934ed12 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/MusicTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/MusicTest.java
@@ -35,7 +35,6 @@ public class MusicTest extends GdxTest {
 
 	Music music;
 	float songDuration = 183;
-	float currentPosition;
 
 	TextureRegion buttons;
 	SpriteBatch batch;
@@ -81,15 +80,13 @@ public class MusicTest extends GdxTest {
 
 	@Override
 	public void render () {
-		currentPosition = music.getPosition();
 		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
 		batch.begin();
 		batch.draw(buttons, 0, 0);
-		font.draw(batch, (int)currentPosition / 60 + ":" + (int)currentPosition % 60, 365, 35);
 		batch.end();
 
 		sliderUpdating = true;
-		slider.setValue((currentPosition / songDuration) * 100f);
+		//slider.setValue((music.getPosition() / songDuration) * 100f);
 		sliderUpdating = false;
 		stage.act();
 		stage.draw();
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/ScrollPaneScrollBarsTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/ScrollPaneScrollBarsTest.java
index 0e4d6a3..445757a 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/ScrollPaneScrollBarsTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/ScrollPaneScrollBarsTest.java
@@ -20,7 +20,6 @@ import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.scenes.scene2d.Actor;
 import com.badlogic.gdx.scenes.scene2d.Stage;
-import com.badlogic.gdx.scenes.scene2d.ui.Image;
 import com.badlogic.gdx.scenes.scene2d.ui.Label;
 import com.badlogic.gdx.scenes.scene2d.ui.ScrollPane;
 import com.badlogic.gdx.scenes.scene2d.ui.Skin;
@@ -180,41 +179,35 @@ public class ScrollPaneScrollBarsTest extends GdxTest {
 
 		Table[] tables = new Table[] {bottomLeftTable, bottomRightTable, topLeftTable, topRightTable, horizOnlyTopTable,
 			horizOnlyBottomTable, vertOnlyLeftTable, vertOnlyRightTable};
-		for (Table t : tables)
-			t.defaults().expandX().fillX();
-
-		horizOnlyTopTable.add(
-			new Label("HORIZONTAL-ONLY-TOP verify HORIZONTAL scroll bar is on the TOP and properly aligned", skin)).row();
-		horizOnlyTopTable.add(new Image(skin.getDrawable("default-rect"))).height(20).row();
+		for (Table t : tables) {
+			t.pad(10).defaults().expandX().space(4);
+		}
 
-		horizOnlyBottomTable.add(
-			new Label("HORIZONTAL-ONLY-BOTTOM verify HORIZONTAL scroll bar is on the BOTTOM and properly aligned", skin)).row();
-		horizOnlyBottomTable.add(new Image(skin.getDrawable("default-rect"))).height(20).row();
+		horizOnlyTopTable
+			.add(new Label("HORIZONTAL-ONLY-TOP verify HORIZONTAL scroll bar is on the TOP and properly aligned", skin));
+		horizOnlyBottomTable.add(new Label(
+			"HORIZONTAL-ONLY-BOTTOM verify HORIZONTAL scroll bar is on the BOTTOM and properly aligned", skin));
 
 		for (int i = 0; i < 12; i++) {
-			bottomLeftTable.add(
-				new Label(i + " BOTTOM-LEFT verify scroll bars are on the BOTTOM and the LEFT, and are properly aligned", skin))
-				.row();
-			bottomLeftTable.add(new Image(skin.getDrawable("default-rect"))).height(20).row();
-
-			bottomRightTable.add(
-				new Label(i + " BOTTOM-RIGHT verify scroll bars are on the BOTTOM and the RIGHT, and are properly aligned", skin))
-				.row();
-			bottomRightTable.add(new Image(skin.getDrawable("default-rect"))).height(20).row();
-
-			topLeftTable.add(
-				new Label(i + " TOP-LEFT verify scroll bars are on the TOP and the LEFT, and are properly aligned", skin)).row();
-			topLeftTable.add(new Image(skin.getDrawable("default-rect"))).height(20).row();
-
-			topRightTable.add(
-				new Label(i + " TOP-RIGHT verify scroll bars are on the TOP and the RIGHT, and are properly aligned", skin)).row();
-			topRightTable.add(new Image(skin.getDrawable("default-rect"))).height(20).row();
-
-			vertOnlyLeftTable.add(new Label("VERT-ONLY-LEFT", skin)).row();
-			vertOnlyLeftTable.add(new Image(skin.getDrawable("default-rect"))).height(20).row();
-
-			vertOnlyRightTable.add(new Label("VERT-ONLY-RIGHT", skin)).row();
-			vertOnlyRightTable.add(new Image(skin.getDrawable("default-rect"))).height(20).row();
+			bottomLeftTable.row();
+			bottomRightTable.row();
+			topLeftTable.row();
+			topRightTable.row();
+
+			bottomLeftTable.add(new Label(i
+				+ " BOTTOM-LEFT verify scroll bars are on the BOTTOM and the LEFT, and are properly aligned", skin));
+			bottomRightTable.add(new Label(i
+				+ " BOTTOM-RIGHT verify scroll bars are on the BOTTOM and the RIGHT, and are properly aligned", skin));
+			topLeftTable.add(new Label(i + " TOP-LEFT verify scroll bars are on the TOP and the LEFT, and are properly aligned",
+				skin));
+			topRightTable.add(new Label(i + " TOP-RIGHT verify scroll bars are on the TOP and the RIGHT, and are properly aligned",
+				skin));
+
+			vertOnlyLeftTable.row();
+			vertOnlyRightTable.row();
+
+			vertOnlyLeftTable.add(new Label("VERT-ONLY-LEFT", skin));
+			vertOnlyRightTable.add(new Label("VERT-ONLY-RIGHT", skin));
 		}
 
 		bottomLeft.add(bottomLeftScroll).expand().fill().colspan(4);
@@ -225,11 +218,6 @@ public class ScrollPaneScrollBarsTest extends GdxTest {
 		horizOnlyBottom.add(horizOnlyBottomScroll).expand().fill().colspan(4);
 		vertOnlyLeft.add(vertOnlyLeftScroll).expand().fill().colspan(4);
 		vertOnlyRight.add(vertOnlyRightScroll).expand().fill().colspan(4);
-
-		for (ScrollPane pane : scrollPanes) {
-			pane.setFadeScrollBars(doFade);
-			pane.setScrollbarsOnTop(doOnTop);
-		}
 	}
 
 	public void render () {
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/TextInputDialogTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/TextInputDialogTest.java
index b87e71f..20c53e2 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/TextInputDialogTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/TextInputDialogTest.java
@@ -51,7 +51,7 @@ public class TextInputDialogTest extends GdxTest {
 				public void canceled () {
 					message = "cancled by user";
 				}
-			}, "enter something funny", "funny", "something funny");
+			}, "enter something funny", "funny");
 		}
 	}
 }
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/TiledMapObjectLoadingTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/TiledMapObjectLoadingTest.java
deleted file mode 100644
index 491213a..0000000
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/TiledMapObjectLoadingTest.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/**
- * *****************************************************************************
- * Copyright 2011 See AUTHORS file.
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not
- * use this file except in compliance with the License. You may obtain a copy of
- * the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations under
- * the License.
- * ****************************************************************************
- */
-
-package com.badlogic.gdx.tests;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.graphics.Color;
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.OrthographicCamera;
-import com.badlogic.gdx.graphics.g2d.BitmapFont;
-import com.badlogic.gdx.graphics.g2d.SpriteBatch;
-import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
-import com.badlogic.gdx.maps.MapLayer;
-import com.badlogic.gdx.maps.MapObject;
-import com.badlogic.gdx.maps.MapProperties;
-import com.badlogic.gdx.maps.objects.EllipseMapObject;
-import com.badlogic.gdx.maps.objects.PolygonMapObject;
-import com.badlogic.gdx.maps.objects.RectangleMapObject;
-import com.badlogic.gdx.maps.objects.TextureMapObject;
-import com.badlogic.gdx.maps.tiled.TiledMap;
-import com.badlogic.gdx.maps.tiled.TmxMapLoader;
-import com.badlogic.gdx.math.Ellipse;
-import com.badlogic.gdx.math.Polygon;
-import com.badlogic.gdx.math.Rectangle;
-import com.badlogic.gdx.tests.utils.GdxTest;
-import com.badlogic.gdx.tests.utils.OrthoCamController;
-
-public class TiledMapObjectLoadingTest extends GdxTest {
-
-	private TiledMap map;
-	private ShapeRenderer shapeRenderer;
-	private OrthographicCamera camera;
-	private OrthoCamController cameraController;
-	private BitmapFont font;
-	private SpriteBatch batch;
-
-	@Override
-	public void create () {
-		float w = Gdx.graphics.getWidth();
-		float h = Gdx.graphics.getHeight();
-
-		camera = new OrthographicCamera();
-		camera.setToOrtho(false, (w / h) * 100, 100);
-		camera.zoom = 2;
-		camera.update();
-
-		cameraController = new OrthoCamController(camera);
-		Gdx.input.setInputProcessor(cameraController);
-
-		font = new BitmapFont();
-		batch = new SpriteBatch();
-		map = new TmxMapLoader().load("data/maps/tiled-objects/test-load-mapobjects.tmx");
-		MapProperties properties = map.getProperties();
-		shapeRenderer = new ShapeRenderer();
-	}
-
-	@Override
-	public void render () {
-		Gdx.gl.glClearColor(0.55f, 0.55f, 0.55f, 1f);
-		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
-		camera.update();
-		shapeRenderer.setProjectionMatrix(camera.combined);
-		batch.setProjectionMatrix(camera.combined);
-		shapeRenderer.setColor(Color.BLUE);
-		Gdx.gl20.glLineWidth(2);
-		MapLayer layer = map.getLayers().get("Objects");
-		for (MapObject mapObject : layer.getObjects()) {
-			if (mapObject instanceof TextureMapObject) {
-				TextureMapObject tmObject = (TextureMapObject)mapObject;
-				batch.begin();
-				batch.draw(tmObject.getTextureRegion(), tmObject.getX(), tmObject.getY(), tmObject.getOriginX(),
-					tmObject.getOriginY(), tmObject.getTextureRegion().getRegionWidth(),
-					tmObject.getTextureRegion().getRegionHeight(), tmObject.getScaleX(), tmObject.getScaleY(), tmObject.getOpacity());
-				batch.end();
-			} else if (mapObject instanceof EllipseMapObject) {
-				shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
-				Ellipse ellipse = ((EllipseMapObject)mapObject).getEllipse();
-				shapeRenderer.ellipse(ellipse.x, ellipse.y, ellipse.width, ellipse.height);
-				shapeRenderer.end();
-			} else if (mapObject instanceof RectangleMapObject) {
-				shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
-				Rectangle rectangle = ((RectangleMapObject)mapObject).getRectangle();
-				shapeRenderer.rect(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
-				shapeRenderer.end();
-			} else if (mapObject instanceof PolygonMapObject) {
-				shapeRenderer.begin(ShapeRenderer.ShapeType.Line);
-				Polygon polygon = ((PolygonMapObject)mapObject).getPolygon();
-				shapeRenderer.polygon(polygon.getTransformedVertices());
-				shapeRenderer.end();
-			}
-		}
-		batch.begin();
-		font.draw(batch, "FPS: " + Gdx.graphics.getFramesPerSecond(), 10, 20);
-		batch.end();
-	}
-
-	@Override
-	public void dispose () {
-		map.dispose();
-		shapeRenderer.dispose();
-	}
-}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/TimerTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/TimerTest.java
index 147e28a..004a82a 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/TimerTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/TimerTest.java
@@ -24,14 +24,11 @@ import com.badlogic.gdx.utils.Timer.Task;
 public class TimerTest extends GdxTest {
 	@Override
 	public void create () {
-		Timer timer = new Timer();
-		Task task = timer.scheduleTask(new Task() {
+		new Timer().scheduleTask(new Task() {
 			@Override
 			public void run () {
 				Gdx.app.log("TimerTest", "ping");
 			}
 		}, 1, 1);
-		
-		Gdx.app.log("TimerTest","is task scheduled: "+String.valueOf(task.isScheduled()));
 	}
 }
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/UITest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/UITest.java
index 1f4b314..22ff8cf 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/UITest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/UITest.java
@@ -1,214 +1,204 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.tests;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.Input.Keys;
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.Texture;
-import com.badlogic.gdx.graphics.g2d.TextureRegion;
-import com.badlogic.gdx.scenes.scene2d.Actor;
-import com.badlogic.gdx.scenes.scene2d.Stage;
-import com.badlogic.gdx.scenes.scene2d.ui.Button;
-import com.badlogic.gdx.scenes.scene2d.ui.Button.ButtonStyle;
-import com.badlogic.gdx.scenes.scene2d.ui.CheckBox;
-import com.badlogic.gdx.scenes.scene2d.ui.Dialog;
-import com.badlogic.gdx.scenes.scene2d.ui.Image;
-import com.badlogic.gdx.scenes.scene2d.ui.ImageButton;
-import com.badlogic.gdx.scenes.scene2d.ui.ImageButton.ImageButtonStyle;
-import com.badlogic.gdx.scenes.scene2d.ui.Label;
-import com.badlogic.gdx.scenes.scene2d.ui.List;
-import com.badlogic.gdx.scenes.scene2d.ui.ScrollPane;
-import com.badlogic.gdx.scenes.scene2d.ui.SelectBox;
-import com.badlogic.gdx.scenes.scene2d.ui.Skin;
-import com.badlogic.gdx.scenes.scene2d.ui.Slider;
-import com.badlogic.gdx.scenes.scene2d.ui.SplitPane;
-import com.badlogic.gdx.scenes.scene2d.ui.Table;
-import com.badlogic.gdx.scenes.scene2d.ui.TextButton;
-import com.badlogic.gdx.scenes.scene2d.ui.TextField;
-import com.badlogic.gdx.scenes.scene2d.ui.TextField.TextFieldListener;
-import com.badlogic.gdx.scenes.scene2d.ui.Window;
-import com.badlogic.gdx.scenes.scene2d.utils.Align;
-import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
-import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
-import com.badlogic.gdx.tests.utils.GdxTest;
-import com.badlogic.gdx.utils.viewport.ScreenViewport;
-
-public class UITest extends GdxTest {
-	Object[] listEntries = {"This is a list entry1", "And another one1", "The meaning of life1", "Is hard to come by1",
-		"This is a list entry2", "And another one2", "The meaning of life2", "Is hard to come by2", "This is a list entry3",
-		"And another one3", "The meaning of life3", "Is hard to come by3", "This is a list entry4", "And another one4",
-		"The meaning of life4", "Is hard to come by4", "This is a list entry5", "And another one5", "The meaning of life5",
-		"Is hard to come by5"};
-
-	Skin skin;
-	Stage stage;
-	Texture texture1;
-	Texture texture2;
-	Label fpsLabel;
-
-	@Override
-	public void create () {
-		skin = new Skin(Gdx.files.internal("data/uiskin.json"));
-		texture1 = new Texture(Gdx.files.internal("data/badlogicsmall.jpg"));
-		texture2 = new Texture(Gdx.files.internal("data/badlogic.jpg"));
-		TextureRegion image = new TextureRegion(texture1);
-		TextureRegion imageFlipped = new TextureRegion(image);
-		imageFlipped.flip(true, true);
-		TextureRegion image2 = new TextureRegion(texture2);
-		// stage = new Stage(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), false, new PolygonSpriteBatch());
-		stage = new Stage(new ScreenViewport());
-		Gdx.input.setInputProcessor(stage);
-
-		// Group.debug = true;
-
-		ImageButtonStyle style = new ImageButtonStyle(skin.get(ButtonStyle.class));
-		style.imageUp = new TextureRegionDrawable(image);
-		style.imageDown = new TextureRegionDrawable(imageFlipped);
-		ImageButton iconButton = new ImageButton(style);
-
-		Button buttonMulti = new TextButton("Multi\nLine\nToggle", skin, "toggle");
-		Button imgButton = new Button(new Image(image), skin);
-		Button imgToggleButton = new Button(new Image(image), skin, "toggle");
-
-		Label myLabel = new Label("this is some text.", skin);
-		myLabel.setWrap(true);
-
-		Table t = new Table();
-		t.row();
-		t.add(myLabel);
-
-		t.layout();
-
-		final CheckBox checkBox = new CheckBox(" Continuous rendering", skin);
-		checkBox.setChecked(true);
-		final Slider slider = new Slider(0, 10, 1, false, skin);
-		slider.setAnimateDuration(0.3f);
-		TextField textfield = new TextField("", skin);
-		textfield.setMessageText("Click here!");
-		textfield.setAlignment(Align.center);
-		final SelectBox dropdown = new SelectBox(skin);
-		dropdown.addListener(new ChangeListener() {
-			public void changed (ChangeEvent event, Actor actor) {
-				System.out.println(dropdown.getSelected());
-			}
-		});
-		dropdown.setItems("Android1", "Windows1", "Linux1", "OSX1", "Android2", "Windows2", "Linux2", "OSX2", "Android3",
-			"Windows3", "Linux3", "OSX3", "Android4", "Windows4", "Linux4", "OSX4", "Android5", "Windows5", "Linux5", "OSX5",
-			"Android6", "Windows6", "Linux6", "OSX6", "Android7", "Windows7", "Linux7", "OSX7");
-		dropdown.setSelected("Linux6");
-		Image imageActor = new Image(image2);
-		ScrollPane scrollPane = new ScrollPane(imageActor);
-		List list = new List(skin);
-		list.setItems(listEntries);
-		list.getSelection().setMultiple(true);
-		list.getSelection().setRequired(false);
-		// list.getSelection().setToggle(true);
-		ScrollPane scrollPane2 = new ScrollPane(list, skin);
-		scrollPane2.setFlickScroll(false);
-		SplitPane splitPane = new SplitPane(scrollPane, scrollPane2, false, skin, "default-horizontal");
-		fpsLabel = new Label("fps:", skin);
-
-		// configures an example of a TextField in password mode.
-		final Label passwordLabel = new Label("Textfield in password mode: ", skin);
-		final TextField passwordTextField = new TextField("", skin);
-		passwordTextField.setMessageText("password");
-		passwordTextField.setPasswordCharacter('*');
-		passwordTextField.setPasswordMode(true);
-
-		// window.debug();
-		Window window = new Window("Dialog", skin);
-		window.getButtonTable().add(new TextButton("X", skin)).height(window.getPadTop());
-		window.setPosition(0, 0);
-		window.defaults().spaceBottom(10);
-		window.row().fill().expandX();
-		window.add(iconButton);
-		window.add(buttonMulti);
-		window.add(imgButton);
-		window.add(imgToggleButton);
-		window.row();
-		window.add(checkBox);
-		window.add(slider).minWidth(100).fillX().colspan(3);
-		window.row();
-		window.add(dropdown);
-		window.add(textfield).minWidth(100).expandX().fillX().colspan(3);
-		window.row();
-		window.add(splitPane).fill().expand().colspan(4).maxHeight(200);
-		window.row();
-		window.add(passwordLabel).colspan(2);
-		window.add(passwordTextField).minWidth(100).expandX().fillX().colspan(2);
-		window.row();
-		window.add(fpsLabel).colspan(4);
-		window.pack();
-
-		// stage.addActor(new Button("Behind Window", skin));
-		stage.addActor(window);
-
-		textfield.setTextFieldListener(new TextFieldListener() {
-			public void keyTyped (TextField textField, char key) {
-				if (key == '\n') textField.getOnscreenKeyboard().show(false);
-			}
-		});
-
-		slider.addListener(new ChangeListener() {
-			public void changed (ChangeEvent event, Actor actor) {
-				Gdx.app.log("UITest", "slider: " + slider.getValue());
-			}
-		});
-
-		iconButton.addListener(new ChangeListener() {
-			public void changed (ChangeEvent event, Actor actor) {
-				new Dialog("Some Dialog", skin, "dialog") {
-					protected void result (Object object) {
-						System.out.println("Chosen: " + object);
-					}
-				}.text("Are you enjoying this demo?").button("Yes", true).button("No", false).key(Keys.ENTER, true)
-					.key(Keys.ESCAPE, false).show(stage);
-			}
-		});
-
-		checkBox.addListener(new ChangeListener() {
-			public void changed (ChangeEvent event, Actor actor) {
-				Gdx.graphics.setContinuousRendering(checkBox.isChecked());
-			}
-		});
-	}
-
-	@Override
-	public void render () {
-		Gdx.gl.glClearColor(0.2f, 0.2f, 0.2f, 1);
-		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
-
-		fpsLabel.setText("fps: " + Gdx.graphics.getFramesPerSecond());
-
-		stage.act(Math.min(Gdx.graphics.getDeltaTime(), 1 / 30f));
-		stage.draw();
-	}
-
-	@Override
-	public void resize (int width, int height) {
-		stage.getViewport().update(width, height, true);
-	}
-
-	@Override
-	public void dispose () {
-		stage.dispose();
-		skin.dispose();
-		texture1.dispose();
-		texture2.dispose();
-	}
-}
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.tests;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.Input.Keys;
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.g2d.TextureRegion;
+import com.badlogic.gdx.scenes.scene2d.Actor;
+import com.badlogic.gdx.scenes.scene2d.Stage;
+import com.badlogic.gdx.scenes.scene2d.ui.Button;
+import com.badlogic.gdx.scenes.scene2d.ui.Button.ButtonStyle;
+import com.badlogic.gdx.scenes.scene2d.ui.CheckBox;
+import com.badlogic.gdx.scenes.scene2d.ui.Dialog;
+import com.badlogic.gdx.scenes.scene2d.ui.Image;
+import com.badlogic.gdx.scenes.scene2d.ui.ImageButton;
+import com.badlogic.gdx.scenes.scene2d.ui.ImageButton.ImageButtonStyle;
+import com.badlogic.gdx.scenes.scene2d.ui.Label;
+import com.badlogic.gdx.scenes.scene2d.ui.List;
+import com.badlogic.gdx.scenes.scene2d.ui.ScrollPane;
+import com.badlogic.gdx.scenes.scene2d.ui.SelectBox;
+import com.badlogic.gdx.scenes.scene2d.ui.Skin;
+import com.badlogic.gdx.scenes.scene2d.ui.Slider;
+import com.badlogic.gdx.scenes.scene2d.ui.SplitPane;
+import com.badlogic.gdx.scenes.scene2d.ui.Table;
+import com.badlogic.gdx.scenes.scene2d.ui.TextButton;
+import com.badlogic.gdx.scenes.scene2d.ui.TextField;
+import com.badlogic.gdx.scenes.scene2d.ui.TextField.TextFieldListener;
+import com.badlogic.gdx.scenes.scene2d.ui.Window;
+import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
+import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
+import com.badlogic.gdx.tests.utils.GdxTest;
+import com.badlogic.gdx.utils.viewport.ScreenViewport;
+
+public class UITest extends GdxTest {
+	Object[] listEntries = {"This is a list entry1", "And another one1", "The meaning of life1", "Is hard to come by1",
+		"This is a list entry2", "And another one2", "The meaning of life2", "Is hard to come by2", "This is a list entry3",
+		"And another one3", "The meaning of life3", "Is hard to come by3", "This is a list entry4", "And another one4",
+		"The meaning of life4", "Is hard to come by4", "This is a list entry5", "And another one5", "The meaning of life5",
+		"Is hard to come by5"};
+
+	Skin skin;
+	Stage stage;
+	Texture texture1;
+	Texture texture2;
+	Label fpsLabel;
+
+	@Override
+	public void create () {
+		skin = new Skin(Gdx.files.internal("data/uiskin.json"));
+		texture1 = new Texture(Gdx.files.internal("data/badlogicsmall.jpg"));
+		texture2 = new Texture(Gdx.files.internal("data/badlogic.jpg"));
+		TextureRegion image = new TextureRegion(texture1);
+		TextureRegion imageFlipped = new TextureRegion(image);
+		imageFlipped.flip(true, true);
+		TextureRegion image2 = new TextureRegion(texture2);
+		// stage = new Stage(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), false, new PolygonSpriteBatch());
+		stage = new Stage(new ScreenViewport());
+		Gdx.input.setInputProcessor(stage);
+
+		// Group.debug = true;
+
+		ImageButtonStyle style = new ImageButtonStyle(skin.get(ButtonStyle.class));
+		style.imageUp = new TextureRegionDrawable(image);
+		style.imageDown = new TextureRegionDrawable(imageFlipped);
+		ImageButton iconButton = new ImageButton(style);
+
+		Button buttonMulti = new TextButton("Multi\nLine\nToggle", skin, "toggle");
+		Button imgButton = new Button(new Image(image), skin);
+		Button imgToggleButton = new Button(new Image(image), skin, "toggle");
+
+		Label myLabel = new Label("this is some text.", skin);
+		myLabel.setWrap(true);
+
+		Table t = new Table();
+		t.row();
+		t.add(myLabel);
+
+		t.layout();
+
+		CheckBox checkBox = new CheckBox("Check me", skin);
+		final Slider slider = new Slider(0, 10, 1, false, skin);
+		TextField textfield = new TextField("", skin);
+		textfield.setMessageText("Click here!");
+		final SelectBox dropdown = new SelectBox(skin);
+		dropdown.addListener(new ChangeListener(){
+			public void changed (ChangeEvent event, Actor actor) {
+				System.out.println(dropdown.getSelected());
+			}
+		});
+		dropdown.setItems("Android1", "Windows1", "Linux1", "OSX1", "Android2", "Windows2", "Linux2", "OSX2", "Android3",
+			"Windows3", "Linux3", "OSX3", "Android4", "Windows4", "Linux4", "OSX4", "Android5", "Windows5", "Linux5", "OSX5",
+			"Android6", "Windows6", "Linux6", "OSX6", "Android7", "Windows7", "Linux7", "OSX7");
+		dropdown.setSelected("Linux6");
+		Image imageActor = new Image(image2);
+		ScrollPane scrollPane = new ScrollPane(imageActor);
+		List list = new List(skin);
+		list.setItems(listEntries);
+		list.getSelection().setMultiple(true);
+		list.getSelection().setRequired(false);
+		// list.getSelection().setToggle(true);
+		ScrollPane scrollPane2 = new ScrollPane(list, skin);
+		scrollPane2.setFlickScroll(false);
+		SplitPane splitPane = new SplitPane(scrollPane, scrollPane2, false, skin, "default-horizontal");
+		fpsLabel = new Label("fps:", skin);
+
+		// configures an example of a TextField in password mode.
+		final Label passwordLabel = new Label("Textfield in password mode: ", skin);
+		final TextField passwordTextField = new TextField("", skin);
+		passwordTextField.setMessageText("password");
+		passwordTextField.setPasswordCharacter('*');
+		passwordTextField.setPasswordMode(true);
+
+		// window.debug();
+		Window window = new Window("Dialog", skin);
+		window.getButtonTable().add(new TextButton("X", skin)).height(window.getPadTop());
+		window.setPosition(0, 0);
+		window.defaults().spaceBottom(10);
+		window.row().fill().expandX();
+		window.add(iconButton);
+		window.add(buttonMulti);
+		window.add(imgButton);
+		window.add(imgToggleButton);
+		window.row();
+		window.add(checkBox);
+		window.add(slider).minWidth(100).fillX().colspan(3);
+		window.row();
+		window.add(dropdown);
+		window.add(textfield).minWidth(100).expandX().fillX().colspan(3);
+		window.row();
+		window.add(splitPane).fill().expand().colspan(4).maxHeight(200);
+		window.row();
+		window.add(passwordLabel).colspan(2);
+		window.add(passwordTextField).minWidth(100).expandX().fillX().colspan(2);
+		window.row();
+		window.add(fpsLabel).colspan(4);
+		window.pack();
+
+		// stage.addActor(new Button("Behind Window", skin));
+		stage.addActor(window);
+
+		textfield.setTextFieldListener(new TextFieldListener() {
+			public void keyTyped (TextField textField, char key) {
+				if (key == '\n') textField.getOnscreenKeyboard().show(false);
+			}
+		});
+
+		slider.addListener(new ChangeListener() {
+			public void changed (ChangeEvent event, Actor actor) {
+				Gdx.app.log("UITest", "slider: " + slider.getValue());
+			}
+		});
+
+		iconButton.addListener(new ChangeListener() {
+			public void changed (ChangeEvent event, Actor actor) {
+				new Dialog("Some Dialog", skin, "dialog") {
+					protected void result (Object object) {
+						System.out.println("Chosen: " + object);
+					}
+				}.text("Are you enjoying this demo?").button("Yes", true).button("No", false).key(Keys.ENTER, true)
+					.key(Keys.ESCAPE, false).show(stage);
+			}
+		});
+	}
+
+	@Override
+	public void render () {
+		Gdx.gl.glClearColor(0.2f, 0.2f, 0.2f, 1);
+		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
+
+		fpsLabel.setText("fps: " + Gdx.graphics.getFramesPerSecond());
+
+		stage.act(Math.min(Gdx.graphics.getDeltaTime(), 1 / 30f));
+		stage.draw();
+	}
+
+	@Override
+	public void resize (int width, int height) {
+		stage.getViewport().update(width, height, true);
+	}
+
+	@Override
+	public void dispose () {
+		stage.dispose();
+		skin.dispose();
+		texture1.dispose();
+		texture2.dispose();
+	}
+}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/VertexBufferObjectShaderTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/VertexBufferObjectShaderTest.java
index ac30dd3..c11786d 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/VertexBufferObjectShaderTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/VertexBufferObjectShaderTest.java
@@ -62,30 +62,14 @@ public class VertexBufferObjectShaderTest extends GdxTest {
 
 	@Override
 	public void create () {
-		//@off
-		String vertexShader = 
-			  "attribute vec4 a_position;    \n"
-			+ "attribute vec4 a_color;\n"
-			+ "attribute vec2 a_texCoords;\n"
-			+ "varying vec4 v_color;"
-			+ "varying vec2 v_texCoords;" + "void main()                  \n"
-			+ "{                            \n"
-			+ "   v_color = vec4(a_color.x, a_color.y, a_color.z, 1); \n"
-			+ "   v_texCoords = a_texCoords; \n"
-			+ "   gl_Position =  a_position;  \n"
-			+ "}                            \n";
-		String fragmentShader = 
-			  "#ifdef GL_ES\n"
-			+ "precision mediump float;\n"
-			+ "#endif\n" 
-			+ "varying vec4 v_color;\n"
-			+ "varying vec2 v_texCoords;\n" 
-			+ "uniform sampler2D u_texture;\n" 
-			+ "void main()                                  \n"
-			+ "{                                            \n" 
-			+ "  gl_FragColor = v_color * texture2D(u_texture, v_texCoords);\n"
+		String vertexShader = "attribute vec4 a_position;    \n" + "attribute vec4 a_color;\n" + "attribute vec2 a_texCoords;\n"
+			+ "varying vec4 v_color;" + "varying vec2 v_texCoords;" + "void main()                  \n"
+			+ "{                            \n" + "   v_color = vec4(a_color.x, a_color.y, a_color.z, 1); \n"
+			+ "   v_texCoords = a_texCoords; \n" + "   gl_Position =  a_position;  \n" + "}                            \n";
+		String fragmentShader = "#ifdef GL_ES\n" + "precision mediump float;\n" + "#endif\n" + "varying vec4 v_color;\n"
+			+ "varying vec2 v_texCoords;\n" + "uniform sampler2D u_texture;\n" + "void main()                                  \n"
+			+ "{                                            \n" + "  gl_FragColor = v_color * texture2D(u_texture, v_texCoords);\n"
 			+ "}";
-		//@on
 
 		shader = new ShaderProgram(vertexShader, fragmentShader);
 		vbo = new VertexBufferObject(true, 3, new VertexAttribute(VertexAttributes.Usage.Position, 2, "a_position"),
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseBulletTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseBulletTest.java
index 13ccd9f..3d65786 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseBulletTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseBulletTest.java
@@ -50,7 +50,7 @@ public class BaseBulletTest extends BulletTest {
 
 	private static boolean initialized = false;
 	
-	public static boolean shadows = true;
+	public static boolean shadows = false;
 	
 	public static void init () {
 		if (initialized) return;
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/GimpactTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/GimpactTest.java
deleted file mode 100644
index 34cb6a0..0000000
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/GimpactTest.java
+++ /dev/null
@@ -1,53 +0,0 @@
-
-package com.badlogic.gdx.tests.bullet;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.graphics.Color;
-import com.badlogic.gdx.graphics.g3d.Model;
-import com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.physics.bullet.collision.btGImpactMeshShape;
-import com.badlogic.gdx.physics.bullet.collision.btTriangleIndexVertexArray;
-
-/** @author Xoppa */
-public class GimpactTest extends BaseBulletTest {
-	BulletEntity ground;
-	btTriangleIndexVertexArray chassisVertexArray;
-
-	@Override
-	public void create () {
-		super.create();
-		
-		final Model chassisModel = objLoader.loadModel(Gdx.files.internal("data/car.obj"));
-		disposables.add(chassisModel);
-		chassisModel.materials.get(0).clear();
-		chassisModel.materials.get(0).set(ColorAttribute.createDiffuse(Color.RED), ColorAttribute.createSpecular(Color.WHITE));
-		
-		chassisVertexArray = new btTriangleIndexVertexArray(chassisModel.meshParts);
-		btGImpactMeshShape chassisShape = new btGImpactMeshShape(chassisVertexArray);
-		chassisShape.setLocalScaling(new Vector3(1f, 1f, 1f));
-		chassisShape.setMargin(0f);
-		chassisShape.updateBound();
-		
-		world.addConstructor("chassis", new BulletConstructor(chassisModel, 1f, chassisShape));
-		
-		(ground = world.add("ground", 0f, 0f, 0f)).setColor(0.25f + 0.5f * (float)Math.random(),
-			0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 1f);
-		
-		world.add("chassis", 3f, 10f, 3f);
-	}
-
-	@Override
-	public boolean tap (float x, float y, int count, int button) {
-		shoot(x, y);
-		return true;
-	}
-
-	@Override
-	public void dispose () {
-		super.dispose();
-		chassisVertexArray.dispose();
-		chassisVertexArray = null;
-		ground = null;
-	}
-}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/extensions/ControllersTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/extensions/ControllersTest.java
index 413262c..2cc1be6 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/extensions/ControllersTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/extensions/ControllersTest.java
@@ -45,57 +45,7 @@ public class ControllersTest extends GdxTest {
 	@Override
 	public void create () {
 		setupUi();
-	}
-
-	void print (String message) {
-		String[] lines = console.getItems().toArray(String.class);
-		String[] newLines = new String[lines.length + 1];
-		System.arraycopy(lines, 0, newLines, 0, lines.length);
-		newLines[newLines.length - 1] = message;
-		console.setItems(newLines);
-		scrollPane.invalidate();
-		scrollPane.validate();
-		scrollPane.setScrollPercentY(1.0f);
-	}
-
-	void clear () {
-		console.setItems(new String[0]);
-	}
-
-	private void setupUi () {
-		// setup a tiny ui with a console and a clear button.
-		skin = new Skin(Gdx.files.internal("data/uiskin.json"));
-		stage = new Stage();
-		ui = new Table();
-		ui.setSize(Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
-		console = new List(skin);
-		scrollPane = new ScrollPane(console);
-		scrollPane.setScrollbarsOnTop(true);
-		TextButton clear = new TextButton("Clear", skin);
-		ui.add(scrollPane).expand(true, true).fill();
-		ui.row();
-		ui.add(clear).expand(true, false).fill();
-		stage.addActor(ui);
-		clear.addListener(new ClickListener() {
-			@Override
-			public void clicked (InputEvent event, float x, float y) {
-				clear();
-			}
-		});
-		Gdx.input.setInputProcessor(stage);
-	}
-
-	@Override
-	public void resize (int width, int height) {
-		ui.setSize(width, height);
-		ui.invalidate();
-		stage.getViewport().update(width, height, true);
-	}
 
-	boolean initialized = false;
-
-	private void initialize () {
-		if (initialized) return;
 		// print the currently connected controllers to the console
 		print("Controllers: " + Controllers.getControllers().size);
 		int i = 0;
@@ -171,12 +121,55 @@ public class ControllersTest extends GdxTest {
 				return false;
 			}
 		});
-		initialized = true;
+	}
+
+	void print (String message) {
+		String[] lines = console.getItems().toArray(String.class);
+		String[] newLines = new String[lines.length + 1];
+		System.arraycopy(lines, 0, newLines, 0, lines.length);
+		newLines[newLines.length - 1] = message;
+		console.setItems(newLines);
+		scrollPane.invalidate();
+		scrollPane.validate();
+		scrollPane.setScrollPercentY(1.0f);
+	}
+
+	void clear () {
+		console.setItems(new String[0]);
+	}
+
+	private void setupUi () {
+		// setup a tiny ui with a console and a clear button.
+		skin = new Skin(Gdx.files.internal("data/uiskin.json"));
+		stage = new Stage();
+		ui = new Table();
+		ui.setSize(Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
+		console = new List(skin);
+		scrollPane = new ScrollPane(console);
+		scrollPane.setScrollbarsOnTop(true);
+		TextButton clear = new TextButton("Clear", skin);
+		ui.add(scrollPane).expand(true, true).fill();
+		ui.row();
+		ui.add(clear).expand(true, false).fill();
+		stage.addActor(ui);
+		clear.addListener(new ClickListener() {
+			@Override
+			public void clicked (InputEvent event, float x, float y) {
+				clear();
+			}
+		});
+		Gdx.input.setInputProcessor(stage);
+	}
+
+	@Override
+	public void resize (int width, int height) {
+		ui.setSize(width, height);
+		ui.invalidate();
+		stage.getViewport().update(width, height, true);
 	}
 
 	@Override
 	public void render () {
-		initialize();
 		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
 		stage.act(Gdx.graphics.getDeltaTime());
 		stage.draw();
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/MeshBuilderTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/MeshBuilderTest.java
index 1917988..df130f6 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/MeshBuilderTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/MeshBuilderTest.java
@@ -1,14 +1,10 @@
-
 package com.badlogic.gdx.tests.g3d;
 
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.Input.Keys;
 import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.Mesh;
 import com.badlogic.gdx.graphics.Texture;
-import com.badlogic.gdx.graphics.VertexAttribute;
-import com.badlogic.gdx.graphics.VertexAttributes;
 import com.badlogic.gdx.graphics.VertexAttributes.Usage;
 import com.badlogic.gdx.graphics.g3d.Environment;
 import com.badlogic.gdx.graphics.g3d.Material;
@@ -22,7 +18,6 @@ import com.badlogic.gdx.graphics.g3d.environment.DirectionalLight;
 import com.badlogic.gdx.graphics.g3d.model.Animation;
 import com.badlogic.gdx.graphics.g3d.model.Node;
 import com.badlogic.gdx.graphics.g3d.utils.AnimationController;
-import com.badlogic.gdx.graphics.g3d.utils.MeshBuilder;
 import com.badlogic.gdx.graphics.g3d.utils.MeshPartBuilder;
 import com.badlogic.gdx.graphics.g3d.utils.ModelBuilder;
 import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
@@ -39,71 +34,44 @@ import com.badlogic.gdx.utils.StringBuilder;
 public class MeshBuilderTest extends BaseG3dHudTest {
 	Model model;
 	Environment environment;
-
+	
 	@Override
 	public void create () {
 		super.create();
 		environment = new Environment();
 		environment.set(new ColorAttribute(ColorAttribute.AmbientLight, 0.4f, 0.4f, 0.4f, 1.f));
 		environment.add(new DirectionalLight().set(0.8f, 0.8f, 0.8f, -0.5f, -1.0f, -0.8f));
-
+		
 		modelsWindow.setVisible(false);
-
+		
 		Texture texture = new Texture(Gdx.files.internal("data/badlogic.jpg"));
-
+		
 		Material material = new Material(TextureAttribute.createDiffuse(texture));
-
-		MeshBuilder meshBuilder = new MeshBuilder();
-		meshBuilder.begin(Usage.Position | Usage.Normal | Usage.ColorPacked | Usage.TextureCoordinates, GL20.GL_TRIANGLES);
-		meshBuilder.box(1f, 1f, 1f);
-		Mesh mesh = new Mesh(true, meshBuilder.getNumVertices(), meshBuilder.getNumIndices(), meshBuilder.getAttributes());
-		mesh = meshBuilder.end(mesh);
 		
-		ModelBuilder modelBuilder = new ModelBuilder();
-		modelBuilder.begin();
-		modelBuilder.manage(texture);
-	
-		modelBuilder.node().id = "box";
-		MeshPartBuilder mpb = modelBuilder.part("box", GL20.GL_TRIANGLES, Usage.Position | Usage.Normal | Usage.TextureCoordinates
-			| Usage.ColorPacked, material);
+		ModelBuilder mb = new ModelBuilder();
+		mb.begin();
+		mb.manage(texture);
+		
+		mb.node().id = "box";
+		MeshPartBuilder mpb = mb.part("box", GL20.GL_TRIANGLES, Usage.Position | Usage.Normal | Usage.TextureCoordinates | Usage.ColorPacked, material);
 		mpb.setColor(Color.RED);
 		mpb.box(1f, 1f, 1f);
-
-		modelBuilder.node().id = "sphere";
-		mpb = modelBuilder.part("sphere", GL20.GL_TRIANGLES, Usage.Position | Usage.Normal | Usage.TextureCoordinates
-			| Usage.ColorPacked, material);
+		
+		mb.node().id = "sphere";
+		mpb = mb.part("sphere", GL20.GL_TRIANGLES, Usage.Position | Usage.Normal | Usage.TextureCoordinates | Usage.ColorPacked, material);
 		mpb.sphere(2f, 2f, 2f, 10, 5);
-
-		modelBuilder.node().id = "cone";
-		mpb = modelBuilder.part("cone", GL20.GL_TRIANGLES, Usage.Position | Usage.Normal | Usage.TextureCoordinates
-			| Usage.ColorPacked, material);
+		
+		mb.node().id = "cone";
+		mpb = mb.part("cone", GL20.GL_TRIANGLES, Usage.Position | Usage.Normal | Usage.TextureCoordinates | Usage.ColorPacked, material);
 		mpb.setVertexTransform(new Matrix4().rotate(Vector3.X, -45f));
 		mpb.cone(2f, 3f, 1f, 8);
-
-		modelBuilder.node().id = "cylinder";
-		mpb = modelBuilder.part("cylinder", GL20.GL_TRIANGLES, Usage.Position | Usage.Normal | Usage.TextureCoordinates
-			| Usage.ColorPacked, material);
-		mpb.setUVRange(1f, 1f, 0f, 0f);
+		
+		mb.node().id = "cylinder";
+		mpb = mb.part("cylinder", GL20.GL_TRIANGLES, Usage.Position | Usage.Normal | Usage.TextureCoordinates | Usage.ColorPacked, material);
 		mpb.cylinder(2f, 4f, 3f, 15);
 		
-		modelBuilder.node().id = "mesh";
-		mpb = modelBuilder.part("mesh", GL20.GL_TRIANGLES, mesh.getVertexAttributes(), material);
-		Matrix4 transform = new Matrix4();
-		mpb.setVertexTransform(transform.setToTranslation(0, 2, 0));
-		mpb.addMesh(mesh);
-		mpb.setColor(Color.BLUE);
-		mpb.setVertexTransform(transform.setToTranslation(1, 1, 0));
-		mpb.addMesh(mesh);
-		mpb.setColor(null);
-		mpb.setVertexTransform(transform.setToTranslation(-1, 1, 0).rotate(Vector3.X, 45));
-		mpb.addMesh(mesh);
-		mpb.setVertexTransform(transform.setToTranslation(0, 1, 1));
-		mpb.setUVRange(0.75f, 0.75f, 0.25f, 0.25f);
-		mpb.addMesh(mesh);
-
-		model = modelBuilder.end();
-
-		instances.add(new ModelInstance(model, new Matrix4().trn(0f, 0f, 0f), "mesh", true));
+		model = mb.end();
+		
 		instances.add(new ModelInstance(model, new Matrix4().trn(-5f, 0f, -5f), "box", true));
 		instances.add(new ModelInstance(model, new Matrix4().trn(5f, 0f, -5f), "sphere", true));
 		instances.add(new ModelInstance(model, new Matrix4().trn(-5f, 0f, 5f), "cone", true));
@@ -114,14 +82,14 @@ public class MeshBuilderTest extends BaseG3dHudTest {
 	protected void render (ModelBatch batch, Array<ModelInstance> instances) {
 		batch.render(instances, environment);
 	}
-
+	
 	@Override
 	protected void onModelClicked (String name) {
 	}
-
+	
 	@Override
 	public void dispose () {
 		super.dispose();
 		model.dispose();
 	}
-}
+}
\ No newline at end of file
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ShaderCollectionTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ShaderCollectionTest.java
index f9309b1..7a75279 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ShaderCollectionTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ShaderCollectionTest.java
@@ -36,7 +36,6 @@ import com.badlogic.gdx.graphics.g3d.shaders.BaseShader;
 import com.badlogic.gdx.graphics.g3d.shaders.DefaultShader;
 import com.badlogic.gdx.graphics.g3d.utils.AnimationController;
 import com.badlogic.gdx.graphics.g3d.utils.DefaultShaderProvider;
-import com.badlogic.gdx.graphics.glutils.FacedCubemapData;
 import com.badlogic.gdx.math.Quaternion;
 import com.badlogic.gdx.math.Vector3;
 import com.badlogic.gdx.math.collision.BoundingBox;
@@ -169,12 +168,10 @@ public class ShaderCollectionTest extends BaseG3dHudTest {
 			}
 		} else {
 			FileHandle root = Gdx.files.internal("data/g3d/environment");
-			FacedCubemapData faces = new FacedCubemapData(root.child(name + "_PX.png"), root.child(name+"_NX.png"),
+			cubemap = new Cubemap(root.child(name + "_PX.png"), root.child(name+"_NX.png"),
 				root.child(name + "_PY.png"), root.child(name + "_NY.png"), root.child(name + "_PZ.png"),
 				root.child(name + "_NZ.png"), false); // FIXME mipmapping on desktop
-			cubemap = new Cubemap(faces);
-			faces.load(CubemapSide.NegativeX, root.child(name + "_NX.png"));
-			cubemap.load(faces);
+			cubemap.load(CubemapSide.NegativeX, root.child(name + "_NX.png"));
 			if (!lights.has(CubemapAttribute.EnvironmentMap)) shaderProvider.clear();
 			lights.set(new CubemapAttribute(CubemapAttribute.EnvironmentMap, cubemap));
 		}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/SkeletonTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/SkeletonTest.java
index 3340ff3..d32235f 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/SkeletonTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/SkeletonTest.java
@@ -20,7 +20,6 @@ import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.Input.Keys;
 import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.g3d.Material;
 import com.badlogic.gdx.graphics.g3d.Model;
 import com.badlogic.gdx.graphics.g3d.ModelBatch;
 import com.badlogic.gdx.graphics.g3d.ModelInstance;
@@ -75,7 +74,7 @@ public class SkeletonTest extends BaseG3dHudTest {
 			shapeRenderer.setColor(node.isAnimated ? Color.RED : Color.YELLOW);
 			node.globalTransform.getTranslation(tmpV);
 			shapeRenderer.box(tmpV.x, tmpV.y, tmpV.z, 0.5f, 0.5f, 0.5f);
-			for (Node child : node.getChildren())
+			for (Node child : node.children)
 				renderSkeleton(tmpV, child);
 		}
 		shapeRenderer.end();
@@ -88,7 +87,7 @@ public class SkeletonTest extends BaseG3dHudTest {
 		shapeRenderer.box(pos.x, pos.y, pos.z, 0.5f, 0.5f, 0.5f);
 		shapeRenderer.setColor(Color.WHITE);
 		shapeRenderer.line(from.x, from.y, from.z, pos.x, pos.y, pos.z);
-		for (Node child : node.getChildren())
+		for (Node child : node.children)
 			renderSkeleton(pos, child);
 		vectorPool.free(pos);
 	}
@@ -123,8 +122,7 @@ public class SkeletonTest extends BaseG3dHudTest {
 		instances.clear();
 		animationControllers.clear();
 		final ModelInstance instance = new ModelInstance(assets.get(currentlyLoading, Model.class));
-		for (Material m : instance.materials)
-			m.set(new BlendingAttribute(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA, 0.8f));
+		instance.materials.get(0).set(new BlendingAttribute(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA, 0.5f));
 		instances.add(instance);
 		if (instance.animations.size > 0) animationControllers.put(instance, new AnimationController(instance));
 		currentlyLoading = null;
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/voxel/VoxelChunk.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/voxel/VoxelChunk.java
index e86b6f8..d078deb 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/voxel/VoxelChunk.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/voxel/VoxelChunk.java
@@ -213,29 +213,29 @@ public class VoxelChunk {
 		vertices[vertexOffset++] = offset.x + x + 1;
 		vertices[vertexOffset++] = offset.y + y;
 		vertices[vertexOffset++] = offset.z + z;
-		vertices[vertexOffset++] = 1;
 		vertices[vertexOffset++] = 0;
+		vertices[vertexOffset++] = 1;
 		vertices[vertexOffset++] = 0;
 
 		vertices[vertexOffset++] = offset.x + x + 1;
 		vertices[vertexOffset++] = offset.y + y;
 		vertices[vertexOffset++] = offset.z + z + 1;
-		vertices[vertexOffset++] = 1;
 		vertices[vertexOffset++] = 0;
+		vertices[vertexOffset++] = 1;
 		vertices[vertexOffset++] = 0;
 
 		vertices[vertexOffset++] = offset.x + x + 1;
 		vertices[vertexOffset++] = offset.y + y + 1;
 		vertices[vertexOffset++] = offset.z + z + 1;
-		vertices[vertexOffset++] = 1;
 		vertices[vertexOffset++] = 0;
+		vertices[vertexOffset++] = 1;
 		vertices[vertexOffset++] = 0;
 
 		vertices[vertexOffset++] = offset.x + x + 1;
 		vertices[vertexOffset++] = offset.y + y + 1;
 		vertices[vertexOffset++] = offset.z + z;
-		vertices[vertexOffset++] = 1;
 		vertices[vertexOffset++] = 0;
+		vertices[vertexOffset++] = 1;
 		vertices[vertexOffset++] = 0;
 		return vertexOffset;
 	}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/gwt/GwtTestWrapper.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/gwt/GwtTestWrapper.java
index 9a451b9..95538b6 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/gwt/GwtTestWrapper.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/gwt/GwtTestWrapper.java
@@ -19,7 +19,6 @@ package com.badlogic.gdx.tests.gwt;
 import com.badlogic.gdx.Application;
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.Input;
-import com.badlogic.gdx.Input.TextInputListener;
 import com.badlogic.gdx.InputAdapter;
 import com.badlogic.gdx.InputMultiplexer;
 import com.badlogic.gdx.InputProcessor;
@@ -304,8 +303,13 @@ public class GwtTestWrapper extends GdxTest {
 		}
 
 		@Override
-		public void getTextInput (TextInputListener listener, String title, String text, String hint) {
-			input.getTextInput(listener, title, text, hint);
+		public void getTextInput (TextInputListener listener, String title, String text) {
+			input.getTextInput(listener, title, text);
+		}
+
+		@Override
+		public void getPlaceholderTextInput (TextInputListener listener, String title, String placeholder) {
+			input.getPlaceholderTextInput(listener, title, placeholder);
 		}
 
 		@Override
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/superkoalio/SuperKoalio.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/superkoalio/SuperKoalio.java
index ec80980..d08dcd8 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/superkoalio/SuperKoalio.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/superkoalio/SuperKoalio.java
@@ -289,7 +289,7 @@ public class SuperKoalio extends GdxTest {
 		// draw the koala, depending on the current velocity
 		// on the x-axis, draw the koala facing either right
 		// or left
-		Batch batch = renderer.getBatch();
+		Batch batch = renderer.getSpriteBatch();
 		batch.begin();
 		if (koala.facesRight) {
 			batch.draw(frame, koala.position.x, koala.position.y, Koala.WIDTH, Koala.HEIGHT);
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
index 506bfad..fd47da6 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
@@ -136,7 +136,6 @@ public class GdxTests {
 		InverseKinematicsTest.class,
 		IsometricTileTest.class,
 		KinematicBodyTest.class,
-		KTXTest.class,
 		LabelScaleTest.class,
 		LabelTest.class,
 		LifeCycleTest.class,
@@ -211,8 +210,6 @@ public class GdxTests {
 		TileTest.class,
 		TiledMapAssetManagerTest.class,
 		TiledMapAtlasAssetManagerTest.class,
-		TiledMapDirectLoaderTest.class,
-		TiledMapObjectLoadingTest.class,
 		TiledMapBench.class,
 		TimerTest.class,
 		TimeUtilsTest.class,
@@ -228,8 +225,7 @@ public class GdxTests {
 		ViewportTest3.class,
 		YDownTest.class,
 		FreeTypeFontLoaderTest.class,
-		PngTest.class,
-		JsonTest.class
+		PngTest.class
 		// @on
 
 		// SoundTouchTest.class, Mpg123Test.class, WavTest.class, FreeTypeTest.class,
