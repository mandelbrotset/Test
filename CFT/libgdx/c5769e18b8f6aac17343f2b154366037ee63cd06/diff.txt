diff --git a/.gitignore b/.gitignore
index 526309b..0098f27 100644
--- a/.gitignore
+++ b/.gitignore
@@ -6,14 +6,14 @@
 # per project ignores, it's cumbersome, but reduces the risk of missing something
 
 # target directories:
-backends/gdx-backend-android/target/
-backends/gdx-backends-gwt/target/
-extensions/gdx-audio/target/
-extensions/gdx-freetype/target/
-extensions/gdx-image/target/
-extensions/gdx-tiled-preprocessor/target/
-extensions/gdx-tools/target/
-extensions/gdx-bullet/target/
+/backends/gdx-backend-android/target/
+/backends/gdx-backends-gwt/target/
+/extensions/gdx-audio/target/
+/extensions/gdx-freetype/target/
+/extensions/gdx-image/target/
+/extensions/gdx-tiled-preprocessor/target/
+/extensions/gdx-tools/target/
+/extensions/gdx-bullet/target/
 
 /backends/gdx-backend-android/bin
 /backends/gdx-backend-iosmonotouch/bin
@@ -165,6 +165,11 @@ extensions/gdx-bullet/target/
 /extensions/model-loaders/model-loaders-android/gen
 /extensions/model-loaders/model-loaders/bin
 
+/extensions/gdx-controllers/gdx-controllers/bin
+/extensions/gdx-controllers/gdx-controllers-desktop/bin
+/extensions/gdx-controllers/gdx-controllers-desktop/jni/target
+/extensions/gdx-controllers/gdx-controllers-desktop/libs/windows32
+
 /gdx/target
 /gdx/obj
 /gdx/bin
diff --git a/backends/gdx-backend-iosmonotouch/.classpath b/backends/gdx-backend-iosmonotouch/.classpath
index 9d39cf7..16f3ab7 100644
--- a/backends/gdx-backend-iosmonotouch/.classpath
+++ b/backends/gdx-backend-iosmonotouch/.classpath
@@ -9,5 +9,6 @@
 	<classpathentry kind="lib" path="libs/monotouch-jars/system-2.1.jar"/>
 	<classpathentry kind="lib" path="libs/monotouch-jars/system-core-2.1.jar"/>
 	<classpathentry kind="lib" path="libs/monotouch-jars/system-data-2.1.jar"/>
+	<classpathentry kind="lib" path="libs/objectal/libObjectAL.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/backends/gdx-backend-iosmonotouch/build.xml b/backends/gdx-backend-iosmonotouch/build.xml
index 75ee50e..69b0f67 100644
--- a/backends/gdx-backend-iosmonotouch/build.xml
+++ b/backends/gdx-backend-iosmonotouch/build.xml
@@ -31,6 +31,9 @@
 			<fileset dir="libs/monotouch-jars">
 				<include name="**/*.jar"/>
 			</fileset>
+			<fileset dir="libs/objectal">
+				<include name="**/*.jar"/>
+			</fileset>
 			<pathelement path="target/core"/>
 			</classpath>
 		</javac>
diff --git a/backends/gdx-backend-iosmonotouch/convert.xml b/backends/gdx-backend-iosmonotouch/convert.xml
index ef8ce1e..03ac521 100644
--- a/backends/gdx-backend-iosmonotouch/convert.xml
+++ b/backends/gdx-backend-iosmonotouch/convert.xml
@@ -24,6 +24,7 @@
 			<arg value="-target:library"/>
 			<arg value="-debug"/>
 			<arg value="-out:${OUT}"/>
+			<arg value="-r:libs/objectal/libObjectAL.dll"/>
 			<arg value="-r:${MONO_HOME}/mscorlib.dll"/>
 			<arg value="-r:${MONO_HOME}/System.dll"/>
 			<arg value="-r:${MONO_HOME}/System.Core.dll"/>
diff --git a/backends/gdx-backend-iosmonotouch/libs/objectal/libObjectAL.dll b/backends/gdx-backend-iosmonotouch/libs/objectal/libObjectAL.dll
new file mode 100755
index 0000000..b2aa54f
Binary files /dev/null and b/backends/gdx-backend-iosmonotouch/libs/objectal/libObjectAL.dll differ
diff --git a/backends/gdx-backend-iosmonotouch/libs/objectal/libObjectAL.jar b/backends/gdx-backend-iosmonotouch/libs/objectal/libObjectAL.jar
new file mode 100644
index 0000000..05ef30a
Binary files /dev/null and b/backends/gdx-backend-iosmonotouch/libs/objectal/libObjectAL.jar differ
diff --git a/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSApplication.java b/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSApplication.java
index f5d3afd..2b52a3c 100644
--- a/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSApplication.java
+++ b/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSApplication.java
@@ -146,7 +146,7 @@ public class IOSApplication extends UIApplicationDelegate implements Application
 		this.input = new IOSInput(this);
 		this.graphics = new IOSGraphics(getBounds(uiViewController), this, input, gl20);
 		this.files = new IOSFiles();
-		this.audio = new IOSAudio();
+		this.audio = new IOSAudio(config.useObjectAL);
 		this.net = new IOSNet(this);
 
 		Gdx.files = this.files;
diff --git a/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSApplicationConfiguration.java b/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSApplicationConfiguration.java
index 4998c6e..1321f67 100644
--- a/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSApplicationConfiguration.java
+++ b/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSApplicationConfiguration.java
@@ -59,4 +59,7 @@ public class IOSApplicationConfiguration {
 	
 	/** whether Monotouch GL20 implementation should be used or not, false by default, so native iosgles20 is used. */
 	public boolean useMonotouchOpenTK = false;
+	
+	/** whether to use ObjectAL for sound implementation or not.  */
+	public boolean useObjectAL = false;
 }
diff --git a/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSAudio.java b/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSAudio.java
index 6433bd6..dd0faee 100644
--- a/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSAudio.java
+++ b/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSAudio.java
@@ -12,90 +12,104 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- ******************************************************************************/
-package com.badlogic.gdx.backends.ios;
-
-import com.badlogic.gdx.Audio;
+ ******************************************************************************/
+
+package com.badlogic.gdx.backends.ios;
+
+import com.badlogic.gdx.Audio;
 import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.audio.AudioDevice;
-import com.badlogic.gdx.audio.AudioRecorder;
-import com.badlogic.gdx.audio.Music;
-import com.badlogic.gdx.audio.Sound;
-import com.badlogic.gdx.files.FileHandle;
+import com.badlogic.gdx.audio.AudioDevice;
+import com.badlogic.gdx.audio.AudioRecorder;
+import com.badlogic.gdx.audio.Music;
+import com.badlogic.gdx.audio.Sound;
+import com.badlogic.gdx.files.FileHandle;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 
 import cli.MonoTouch.AVFoundation.AVAudioPlayer;
 import cli.MonoTouch.Foundation.NSData;
 import cli.MonoTouch.Foundation.NSError;
 import cli.MonoTouch.Foundation.NSUrl;
-
-public class IOSAudio implements Audio {
-
-	@Override
-	public AudioDevice newAudioDevice(int samplingRate, boolean isMono) {
-		// FIXME implement via OpenAL if possible
-		return null;
-	}
-
-	@Override
-	public AudioRecorder newAudioRecorder(int samplingRate, boolean isMono) {
-		// FIXME see what MonoTouch offers
-		return null;
-	}
-
-	/**
-	 * Let's verify the file format. 
+import cli.objectal.*;
+
+public class IOSAudio implements Audio {
+
+	private boolean useObjectAL;
+
+	public IOSAudio () {
+
+	}
+
+	public IOSAudio (boolean useObjectAL) {
+		this.useObjectAL = useObjectAL;
+
+		if (useObjectAL) {
+			OALSimpleAudio.sharedInstance().set_allowIpod(false);
+			OALSimpleAudio.sharedInstance().set_honorSilentSwitch(true);
+		}
+	}
+
+	@Override
+	public AudioDevice newAudioDevice (int samplingRate, boolean isMono) {
+		// FIXME implement via OpenAL if possible
+		return null;
+	}
+
+	@Override
+	public AudioRecorder newAudioRecorder (int samplingRate, boolean isMono) {
+		// FIXME see what MonoTouch offers
+		return null;
+	}
+
+	/** Let's verify the file format.
 	 * 
-	 * @param fileHandle  The file to load.
-	 * @throws GdxRuntimeException  If we are using a OGG file (not supported under iOS).
-	 */
-	private void verify(FileHandle fileHandle) {
-		if (fileHandle.extension().equalsIgnoreCase("ogg")) {  
+	 * @param fileHandle The file to load.
+	 * @throws GdxRuntimeException If we are using a OGG file (not supported under iOS). */
+	private void verify (FileHandle fileHandle) {
+		if (fileHandle.extension().equalsIgnoreCase("ogg")) {
 			// Ogg is not supported on iOS (return a sound object that does nothing)
 			throw new GdxRuntimeException("Audio format .ogg is not supported on iOS. Cannot load: " + fileHandle.path());
 		}
 	}
-	
-	/**
-	 * Returns a new sound object. We are playing from memory, a.k.a. suited for short 
-	 * sound FXs.
+
+	/** Returns a new sound object. We are playing from memory, a.k.a. suited for short sound FXs.
 	 * 
-	 * @return  The new sound object.
-	 * @throws GdxRuntimeException  If we are unable to load the file for some reason.
-	 */
-	@Override
-	public Sound newSound(FileHandle fileHandle) {
-		// verify file format (make sure we don't have an OGG file)
-		verify(fileHandle);
-				
-		// create audio player - from byte array 
-		// FIXME check if there's a faster way to load files
-		NSData data = NSData.FromArray(fileHandle.readBytes());
-	   return new IOSSound(data);
-	}
-
-	/**
-	 * Returns a new music object. We are playing directly from file, a.k.a. suited for
-	 * background music.
+	 * @return The new sound object.
+	 * @throws GdxRuntimeException If we are unable to load the file for some reason. */
+	@Override
+	public Sound newSound (FileHandle fileHandle) {
+		if (useObjectAL) {
+			// let OALSimpleAudio report error if there is a problem loading the sound file.
+			return new IOSObjectALSound(fileHandle);
+		} else {
+
+			// verify file format (make sure we don't have an OGG file)
+			verify(fileHandle);
+
+			// create audio player - from byte array
+			// FIXME check if there's a faster way to load files
+			NSData data = NSData.FromArray(fileHandle.readBytes());
+			return new IOSSound(data);
+		}
+	}
+
+	/** Returns a new music object. We are playing directly from file, a.k.a. suited for background music.
 	 * 
-	 * @return  The new music object.
-	 * @throws GdxRuntimeException  If we are unable to load the file for some reason.
-	 */
-	@Override
-	public Music newMusic(FileHandle fileHandle) {
+	 * @return The new music object.
+	 * @throws GdxRuntimeException If we are unable to load the file for some reason. */
+	@Override
+	public Music newMusic (FileHandle fileHandle) {
 		// verify file format (make sure we don't have an OGG file)
 		verify(fileHandle);
-		
+
 		// create audio player - from file path
 		NSError[] error = new NSError[1];
 		AVAudioPlayer player = AVAudioPlayer.FromUrl(NSUrl.FromFilename(fileHandle.path()), error);
 		if (error[0] == null) {
 			// no error: return the music object
 			return new IOSMusic(player);
-		}
-		else {
+		} else {
 			// throw an exception
 			throw new GdxRuntimeException("Error opening music file at " + fileHandle.path() + ": " + error[0].ToString());
 		}
-	}
-}
\ No newline at end of file
+	}
+}
diff --git a/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSObjectALSound.java b/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSObjectALSound.java
new file mode 100644
index 0000000..ba329ab
--- /dev/null
+++ b/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSObjectALSound.java
@@ -0,0 +1,119 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.backends.ios;
+
+import cli.objectal.ALBuffer;
+import cli.objectal.ALSource;
+import cli.objectal.OALSimpleAudio;
+
+import com.badlogic.gdx.audio.Sound;
+import com.badlogic.gdx.files.FileHandle;
+
+/** @author tescott
+ * 
+ *         First pass at implementing OALSimpleAudio support. */
+public class IOSObjectALSound implements Sound {
+
+	private ALSource soundSource;
+	private ALBuffer soundBuffer;
+	private String soundPath;
+
+	public IOSObjectALSound (FileHandle filePath) {
+		soundPath = filePath.path();
+		soundBuffer = OALSimpleAudio.sharedInstance().preloadEffect(soundPath);
+	}
+
+	@Override
+	public long play () {
+		return play(1, 1, 1, false);
+	}
+
+	@Override
+	public long play (float volume) {
+		return play(volume, 1, 1, false);
+	}
+
+	@Override
+	public long play (float volume, float pitch, float pan) {
+		return play(volume, pitch, pan, false);
+	}
+
+	public long play (float volume, float pitch, float pan, boolean loop) {
+		soundSource = OALSimpleAudio.sharedInstance().playEffect(soundPath, volume, pitch, pan, loop);
+		return 0;
+	}
+
+	@Override
+	public long loop () {
+		return play(1, 1, 1, true);
+	}
+
+	@Override
+	public long loop (float volume) {
+		return play(volume, 1, 1, true);
+	}
+
+	@Override
+	public long loop (float volume, float pitch, float pan) {
+		return play(volume, pitch, pan, true);
+	}
+
+	@Override
+	public void stop () {
+		if (soundSource != null) soundSource.stop();
+	}
+
+	@Override
+	public void dispose () {
+		OALSimpleAudio.sharedInstance().unloadEffect(soundPath);
+	}
+
+	@Override
+	public void stop (long soundId) {
+		// we should do something to give an id for each sound.
+		stop();
+	}
+
+	@Override
+	public void setLooping (long soundId, boolean looping) {
+		// TODO Auto-generated method stub
+	}
+
+	@Override
+	public void setPitch (long soundId, float pitch) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void setVolume (long soundId, float volume) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void setPan (long soundId, float pan, float volume) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void setPriority (long soundId, int priority) {
+		// TODO Auto-generated method stub
+
+	}
+}
diff --git a/backends/gdx-openal/src/com/badlogic/gdx/backends/openal/OpenALAudio.java b/backends/gdx-openal/src/com/badlogic/gdx/backends/openal/OpenALAudio.java
index 44ee12a..e2efffa 100644
--- a/backends/gdx-openal/src/com/badlogic/gdx/backends/openal/OpenALAudio.java
+++ b/backends/gdx-openal/src/com/badlogic/gdx/backends/openal/OpenALAudio.java
@@ -27,6 +27,7 @@ import com.badlogic.gdx.Audio;
 import com.badlogic.gdx.audio.AudioDevice;
 import com.badlogic.gdx.audio.AudioRecorder;
 import com.badlogic.gdx.files.FileHandle;
+import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 import com.badlogic.gdx.utils.IntArray;
@@ -149,7 +150,7 @@ public class OpenALAudio implements Audio {
 				alSourcei(sourceId, AL_BUFFER, 0);
 				AL10.alSourcef(sourceId, AL10.AL_GAIN, 1);
 				AL10.alSourcef(sourceId, AL10.AL_PITCH, 1);
-				AL10.alSource3f(sourceId, AL10.AL_POSITION, 0, 0, 0);
+				AL10.alSource3f(sourceId, AL10.AL_POSITION, 0, 0, 1f);
 				return sourceId;
 			}
 		}
@@ -235,7 +236,8 @@ public class OpenALAudio implements Audio {
 		if (!soundIdToSource.containsKey(soundId)) return;
 		int sourceId = soundIdToSource.get(soundId);
 
-		AL10.alSource3f(sourceId, AL10.AL_POSITION, pan, 0, 0);
+		AL10.alSource3f(sourceId, AL10.AL_POSITION, MathUtils.cos((pan - 1) * MathUtils.PI / 2), 0,
+			MathUtils.sin((pan + 1) * MathUtils.PI / 2));
 		AL10.alSourcef(sourceId, AL10.AL_GAIN, volume);
 	}
 
diff --git a/extensions/gdx-bullet/jni/src/GdxCustom/ClosestNotMeConvexResultCallback.h b/extensions/gdx-bullet/jni/src/GdxCustom/ClosestNotMeConvexResultCallback.h
new file mode 100644
index 0000000..60676f9
--- /dev/null
+++ b/extensions/gdx-bullet/jni/src/GdxCustom/ClosestNotMeConvexResultCallback.h
@@ -0,0 +1,56 @@
+#ifndef ClosestNotMeConvexResultCallback_H
+#define ClosestNotMeConvexResultCallback_H
+
+class ClosestNotMeConvexResultCallback : public ClosestConvexResultCallback
+{
+public:
+
+	btCollisionObject* m_me;
+	btScalar m_allowedPenetration;
+
+public:
+	ClosestNotMeConvexResultCallback (btCollisionObject* me,const btVector3& fromA,const btVector3& toA) : 
+	  ClosestConvexResultCallback(fromA,toA),
+		m_me(me),
+		m_allowedPenetration(0.0f)
+	{
+	}
+
+	virtual btScalar addSingleResult(btCollisionWorld::LocalConvexResult& convexResult,bool normalInWorldSpace)
+	{
+		if (convexResult.m_hitCollisionObject == m_me)
+			return 1.0f;
+
+		//ignore result if there is no contact response
+		if(!convexResult.m_hitCollisionObject->hasContactResponse())
+			return 1.0f;
+
+		btVector3 linVelA,linVelB;
+		linVelA = m_convexToWorld-m_convexFromWorld;
+		linVelB = btVector3(0,0,0);//toB.getOrigin()-fromB.getOrigin();
+
+		btVector3 relativeVelocity = (linVelA-linVelB);
+		//don't report time of impact for motion away from the contact normal (or causes minor penetration)
+		if (convexResult.m_hitNormalLocal.dot(relativeVelocity)>=-m_allowedPenetration)
+			return 1.f;
+
+		return ClosestConvexResultCallback::addSingleResult (convexResult, normalInWorldSpace);
+	}
+
+	virtual bool needsCollision(btBroadphaseProxy* proxy0) const
+	{
+		//don't collide with itself
+		if (proxy0->m_clientObject == m_me)
+			return false;
+
+		///don't do CCD when the collision filters are not matching
+		if (!ClosestConvexResultCallback::needsCollision(proxy0))
+			return false;
+
+		btCollisionObject* otherObj = (btCollisionObject*) proxy0->m_clientObject;
+
+		return false;
+	}
+};
+
+#endif // ClosestNotMeConvexResultCallback_H
diff --git a/extensions/gdx-bullet/jni/src/GdxCustom/ClosestNotMeRayResultCallback.h b/extensions/gdx-bullet/jni/src/GdxCustom/ClosestNotMeRayResultCallback.h
new file mode 100644
index 0000000..09f0887
--- /dev/null
+++ b/extensions/gdx-bullet/jni/src/GdxCustom/ClosestNotMeRayResultCallback.h
@@ -0,0 +1,23 @@
+#ifndef ClosestNotMeRayResultCallback_H
+#define ClosestNotMeRayResultCallback_H
+
+class ClosestNotMeRayResultCallback : public ClosestRayResultCallback
+{
+public:
+	ClosestNotMeRayResultCallback (btCollisionObject* me) : ClosestRayResultCallback(btVector3(0.0, 0.0, 0.0), btVector3(0.0, 0.0, 0.0))
+	{
+		m_me = me;
+	}
+
+	virtual btScalar addSingleResult(btCollisionWorld::LocalRayResult& rayResult,bool normalInWorldSpace)
+	{
+		if (rayResult.m_collisionObject == m_me)
+			return 1.0;
+
+		return ClosestRayResultCallback::addSingleResult (rayResult, normalInWorldSpace);
+	}
+protected:
+	btCollisionObject* m_me;
+};
+
+#endif // ClosestNotMeRayResultCallback_H
diff --git a/extensions/gdx-bullet/jni/src/GdxCustom/InternalTickCallback.h b/extensions/gdx-bullet/jni/src/GdxCustom/InternalTickCallback.h
new file mode 100644
index 0000000..4ffd9a7
--- /dev/null
+++ b/extensions/gdx-bullet/jni/src/GdxCustom/InternalTickCallback.h
@@ -0,0 +1,60 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+#ifndef InternalTickCallback_H
+#define InternalTickCallback_H
+
+static void InternalTickCallback_CB(btDynamicsWorld *world, btScalar timeStep);
+
+/** @author xoppa */
+class InternalTickCallback {
+protected:
+	btDynamicsWorld *mWorld;
+	bool mIsPreTick;
+public:
+	InternalTickCallback(btDynamicsWorld *dynamicsWorld = NULL, bool isPreTick = false) {
+		attach(dynamicsWorld, isPreTick);
+	}
+
+	virtual void onInternalTick(btDynamicsWorld *dynamicsWorld, btScalar timeStep) { }
+
+	void detach() {
+		detach(mWorld, mIsPreTick);
+	}
+
+	void attach(btDynamicsWorld *dynamicsWorld, bool isPreTick) {
+		mIsPreTick = isPreTick;
+		mWorld = dynamicsWorld;
+		if (mWorld != NULL)
+			mWorld->setInternalTickCallback(InternalTickCallback_CB, static_cast<void *>(this), isPreTick);
+	}
+
+	void attach() {
+		attach(mWorld, mIsPreTick);
+	}
+
+	static void detach(btDynamicsWorld *dynamicsWorld, bool isPreTick) {
+		if (dynamicsWorld != NULL)
+			dynamicsWorld->setInternalTickCallback(NULL, 0, isPreTick);
+	}
+};
+
+void InternalTickCallback_CB(btDynamicsWorld *world, btScalar timeStep) {
+	InternalTickCallback *cb = static_cast<InternalTickCallback *>(world->getWorldUserInfo());
+	cb->onInternalTick(world, timeStep);
+}
+
+#endif // InternalTickCallback_H
diff --git a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btBvhTriangleMeshShape.java b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btBvhTriangleMeshShape.java
index d5b82d8..a33f1bd 100755
--- a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btBvhTriangleMeshShape.java
+++ b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btBvhTriangleMeshShape.java
@@ -29,7 +29,7 @@ public class btBvhTriangleMeshShape extends btTriangleMeshShape {
     delete();
   }
 
-  public synchronized void delete() {
+  public synchronized void delete()  {
     if (swigCPtr != 0) {
       if (swigCMemOwn) {
         swigCMemOwn = false;
@@ -38,7 +38,101 @@ public class btBvhTriangleMeshShape extends btTriangleMeshShape {
       swigCPtr = 0;
     }
     super.delete();
-  }
+	dispose();
+  }
+
+
+	btStridingMeshInterface meshInterface = null;
+	
+	/** @param managed If true this btBvhTriangleMeshShape will keep a reference to the {@link btStridingMeshInterface}
+	 * and deletes it when this btBvhTriangleMeshShape gets deleted. */
+	public btBvhTriangleMeshShape(boolean managed, btStridingMeshInterface meshInterface, boolean useQuantizedAabbCompression) {
+		this(meshInterface, useQuantizedAabbCompression);
+		this.meshInterface = meshInterface;
+	}
+
+	/** @param managed If true this btBvhTriangleMeshShape will keep a reference to the {@link btStridingMeshInterface}
+	 * and deletes it when this btBvhTriangleMeshShape gets deleted. */
+	public btBvhTriangleMeshShape(boolean managed, btStridingMeshInterface meshInterface, boolean useQuantizedAabbCompression, boolean buildBvh) {
+		this(meshInterface, useQuantizedAabbCompression, buildBvh);
+		this.meshInterface = meshInterface;
+	}
+	
+	/** @param managed If true this btBvhTriangleMeshShape will keep a reference to the {@link btStridingMeshInterface}
+	 * and deletes it when this btBvhTriangleMeshShape gets deleted. */
+	public btBvhTriangleMeshShape(boolean managed, btStridingMeshInterface meshInterface, boolean useQuantizedAabbCompression, Vector3 bvhAabbMin, Vector3 bvhAabbMax, boolean buildBvh) {
+		this(meshInterface, useQuantizedAabbCompression, bvhAabbMin, bvhAabbMax, buildBvh);
+		this.meshInterface = meshInterface;
+	}
+	
+	/** @param managed If true this btBvhTriangleMeshShape will keep a reference to the {@link btStridingMeshInterface}
+	 * and deletes it when this btBvhTriangleMeshShape gets deleted. */
+	public btBvhTriangleMeshShape(boolean managed, btStridingMeshInterface meshInterface, boolean useQuantizedAabbCompression, Vector3 bvhAabbMin, Vector3 bvhAabbMax) {
+		this(meshInterface, useQuantizedAabbCompression, bvhAabbMin, bvhAabbMax);
+		this.meshInterface = meshInterface;
+	}
+	
+	/** Construct a new btBvhTriangleMeshShape based one or more supplied {@link com.badlogic.gdx.graphics.Mesh} instances.
+	 * The specified meshes must be indexed and triangulated and must outlive this btBvhTriangleMeshShape.
+     * The buffers for the vertices and indices are shared amonst both. */
+	public btBvhTriangleMeshShape(boolean useQuantizedAabbCompression, final com.badlogic.gdx.graphics.Mesh... meshes) {
+		this(true, new btTriangleIndexVertexArray(meshes), useQuantizedAabbCompression);
+	}
+	
+	/** Construct a new btBvhTriangleMeshShape based one or more supplied {@link com.badlogic.gdx.graphics.Mesh} instances.
+	 * The specified meshes must be indexed and triangulated and must outlive this btBvhTriangleMeshShape.
+     * The buffers for the vertices and indices are shared amonst both. */
+	public btBvhTriangleMeshShape(boolean useQuantizedAabbCompression, boolean buildBvh, final com.badlogic.gdx.graphics.Mesh... meshes) {
+		this(true, new btTriangleIndexVertexArray(meshes), useQuantizedAabbCompression, buildBvh);
+	}
+	
+	/** Construct a new btBvhTriangleMeshShape based one or more supplied {@link com.badlogic.gdx.graphics.Mesh} instances.
+	 * The specified meshes must be indexed and triangulated and must outlive this btBvhTriangleMeshShape.
+     * The buffers for the vertices and indices are shared amonst both. */
+	public btBvhTriangleMeshShape(boolean useQuantizedAabbCompression, Vector3 bvhAabbMin, Vector3 bvhAabbMax, boolean buildBvh, final com.badlogic.gdx.graphics.Mesh... meshes) {
+		this(true, new btTriangleIndexVertexArray(meshes), useQuantizedAabbCompression, bvhAabbMin, bvhAabbMax, buildBvh);
+	}
+	
+	/** Construct a new btBvhTriangleMeshShape based one or more supplied {@link com.badlogic.gdx.graphics.Mesh} instances.
+	 * The specified meshes must be indexed and triangulated and must outlive this btBvhTriangleMeshShape.
+     * The buffers for the vertices and indices are shared amonst both. */
+	public btBvhTriangleMeshShape(boolean useQuantizedAabbCompression, Vector3 bvhAabbMin, Vector3 bvhAabbMax, final com.badlogic.gdx.graphics.Mesh... meshes) {
+		this(true, new btTriangleIndexVertexArray(meshes), useQuantizedAabbCompression, bvhAabbMin, bvhAabbMax);
+	}
+	
+	/** Construct a new btBvhTriangleMeshShape based one or more supplied {@link com.badlogic.gdx.graphics.g3d.model.Model} instances.
+	 * Only the triangulated submeshes are added, which must be indexed. The model must outlive this btTriangleIndexVertexArray.
+     * The buffers for the vertices and indices are shared amonst both. */
+	public btBvhTriangleMeshShape(boolean useQuantizedAabbCompression, final com.badlogic.gdx.graphics.g3d.model.Model... models) {
+		this(true, new btTriangleIndexVertexArray(models), useQuantizedAabbCompression);
+	}
+	
+	/** Construct a new btBvhTriangleMeshShape based one or more supplied {@link com.badlogic.gdx.graphics.g3d.model.Model} instances.
+	 * Only the triangulated submeshes are added, which must be indexed. The model must outlive this btTriangleIndexVertexArray.
+     * The buffers for the vertices and indices are shared amonst both. */
+	public btBvhTriangleMeshShape(boolean useQuantizedAabbCompression, boolean buildBvh, final com.badlogic.gdx.graphics.g3d.model.Model... models) {
+		this(true, new btTriangleIndexVertexArray(models), useQuantizedAabbCompression, buildBvh);
+	}
+	
+	/** Construct a new btBvhTriangleMeshShape based one or more supplied {@link com.badlogic.gdx.graphics.g3d.model.Model} instances.
+	 * Only the triangulated submeshes are added, which must be indexed. The model must outlive this btTriangleIndexVertexArray.
+	 * The buffers for the vertices and indices are shared amonst both. */
+	public btBvhTriangleMeshShape(boolean useQuantizedAabbCompression, Vector3 bvhAabbMin, Vector3 bvhAabbMax, boolean buildBvh, final com.badlogic.gdx.graphics.g3d.model.Model... models) {
+		this(true, new btTriangleIndexVertexArray(models), useQuantizedAabbCompression, bvhAabbMin, bvhAabbMax, buildBvh);
+	}
+	
+	/** Construct a new btBvhTriangleMeshShape based one or more supplied {@link com.badlogic.gdx.graphics.g3d.model.Model} instances.
+	 * Only the triangulated submeshes are added, which must be indexed. The model must outlive this btTriangleIndexVertexArray.
+     * The buffers for the vertices and indices are shared amonst both. */
+	public btBvhTriangleMeshShape(boolean useQuantizedAabbCompression, Vector3 bvhAabbMin, Vector3 bvhAabbMax, final com.badlogic.gdx.graphics.g3d.model.Model... models) {
+		this(true, new btTriangleIndexVertexArray(models), useQuantizedAabbCompression, bvhAabbMin, bvhAabbMax);
+	}
+		
+	protected void dispose() {
+		if (meshInterface != null)
+			meshInterface.delete();
+		meshInterface = null;
+	}
 
   public btBvhTriangleMeshShape(btStridingMeshInterface meshInterface, boolean useQuantizedAabbCompression, boolean buildBvh) {
     this(gdxBulletJNI.new_btBvhTriangleMeshShape__SWIG_0(btStridingMeshInterface.getCPtr(meshInterface), meshInterface, useQuantizedAabbCompression, buildBvh), true);
diff --git a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btIndexedMesh.java b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btIndexedMesh.java
index 1a96ae3..9bd08fa 100755
--- a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btIndexedMesh.java
+++ b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btIndexedMesh.java
@@ -8,10 +8,9 @@
 
 package com.badlogic.gdx.physics.bullet;
 
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.VertexAttribute;
+import com.badlogic.gdx.graphics.VertexAttributes.Usage;
 
 public class btIndexedMesh {
   private long swigCPtr;
@@ -40,6 +39,38 @@ public class btIndexedMesh {
     }
   }
 
+	/** Construct a new btIndexedMesh based on the supplied {@link Mesh}
+	 * The specified mesh must be indexed and triangulated and must outlive this btIndexedMesh.
+	 * The buffers for the vertices and indices are shared amonst both. */
+	public btIndexedMesh(final Mesh mesh) {
+		this();
+		set(mesh);
+	}
+	
+	/** Convenience method to set this btIndexedMesh to the specified {@link Mesh} 
+	 * The specified mesh must be indexed and triangulated and must outlive this btIndexedMesh.
+	 * The buffers for the vertices and indices are shared amonst both. */
+	public void set(final Mesh mesh) {
+		final int numIndices = mesh.getNumIndices();
+		if ((numIndices <= 0) || ((numIndices % 3) != 0))
+			throw new com.badlogic.gdx.utils.GdxRuntimeException("Mesh must be indexed and triangulated");
+		java.nio.FloatBuffer buf = mesh.getVerticesBuffer();
+		VertexAttribute posAttr = mesh.getVertexAttribute(Usage.Position);
+		if (posAttr == null)
+			throw new com.badlogic.gdx.utils.GdxRuntimeException("Mesh doesn't have a position attribute");
+		final int pos = buf.position();
+		buf.position(posAttr.offset);
+		setM_indexType(PHY_ScalarType.PHY_SHORT);
+		setM_numTriangles(numIndices/3);
+		setM_numVertices(mesh.getNumVertices());
+		setM_triangleIndexStride(6);
+		setM_vertexStride(mesh.getVertexSize());
+		setM_vertexType(PHY_ScalarType.PHY_FLOAT);
+		setTriangleIndexBase(mesh.getIndicesBuffer());
+		setVertexBase(buf);
+		buf.position(pos);
+	}
+
   public void setM_numTriangles(int value) {
     gdxBulletJNI.btIndexedMesh_m_numTriangles_set(swigCPtr, this, value);
   }
diff --git a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btTriangleIndexVertexArray.java b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btTriangleIndexVertexArray.java
index 695ec49..e5b5c54 100755
--- a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btTriangleIndexVertexArray.java
+++ b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btTriangleIndexVertexArray.java
@@ -29,7 +29,7 @@ public class btTriangleIndexVertexArray extends btStridingMeshInterface {
     delete();
   }
 
-  public synchronized void delete() {
+  public synchronized void delete()  {
     if (swigCPtr != 0) {
       if (swigCMemOwn) {
         swigCMemOwn = false;
@@ -38,8 +38,79 @@ public class btTriangleIndexVertexArray extends btStridingMeshInterface {
       swigCPtr = 0;
     }
     super.delete();
+	dispose();
   }
 
+
+	com.badlogic.gdx.utils.Array<btIndexedMesh> meshes = null;
+	
+	/** Construct a new btTriangleIndexVertexArray based one or more supplied {@link com.badlogic.gdx.graphics.Mesh} instances.
+	 * The specified meshes must be indexed and triangulated and must outlive this btTriangleIndexVertexArray.
+     * The buffers for the vertices and indices are shared amongst both. */
+	public btTriangleIndexVertexArray(final com.badlogic.gdx.graphics.Mesh... meshes) {
+		this();
+		addMesh(meshes);
+	}
+	
+	/** Construct a new btTriangleIndexVertexArray based on one or more {@link com.badlogic.gdx.graphics.g3d.model.Model} instances.
+	 * Only the triangulated submeshes are added, which must be indexed. The model must outlive this btTriangleIndexVertexArray.
+     * The buffers for the vertices and indices are shared amongst both. */
+	public btTriangleIndexVertexArray(final com.badlogic.gdx.graphics.g3d.model.Model... models) {
+		this();
+		addModel(models);
+	}
+
+	/** Add one or more {@link com.badlogic.gdx.graphics.Mesh} instances to this btTriangleIndexVertexArray. 
+	 * The specified meshes must be indexed and triangulated and must outlive this btTriangleIndexVertexArray.
+     * The buffers for the vertices and indices are shared amongst both. */
+	public void addMesh(final com.badlogic.gdx.graphics.Mesh... meshes) {
+		for (int i = 0; i < meshes.length; i++)
+			addIndexedMesh(new btIndexedMesh(meshes[i]), PHY_ScalarType.PHY_SHORT, true);
+	}
+	
+	/** Add one or more {@link com.badlogic.gdx.graphics.g3d.model.Model} instances to this btTriangleIndexVertexArray.
+	 * Only the triangulated submeshes are added, which must be indexed. The model must outlive this btTriangleIndexVertexArray.
+     * The buffers for the vertices and indices are shared amongst both. */
+	public void addModel(final com.badlogic.gdx.graphics.g3d.model.Model... models) {
+		for (int i = 0; i < models.length; i++) {
+			final com.badlogic.gdx.graphics.g3d.model.SubMesh[] subMeshes = models[i].getSubMeshes();
+			for (int j = 0; j < subMeshes.length; j++)
+				if (subMeshes[j].primitiveType == com.badlogic.gdx.graphics.GL10.GL_TRIANGLES)
+					addIndexedMesh(new btIndexedMesh(subMeshes[j].getMesh()), PHY_ScalarType.PHY_SHORT, true);
+		}
+	}
+	
+	/** @param managed If true this btTriangleIndexVertexArray will maintain a reference to the {@link btIndexedMesh}
+	 * and will delete it when this btTriangleIndexVertexArray is deleted. */
+	public void addIndexedMesh(final btIndexedMesh mesh, int indexType, boolean managed) {
+		addIndexedMesh(mesh, indexType);
+		if (managed) {
+			if (meshes == null)
+				meshes = new com.badlogic.gdx.utils.Array<btIndexedMesh>();
+			meshes.add(mesh);
+		}
+	}
+
+	/** @param managed If true this btTriangleIndexVertexArray will maintain a reference to the {@link btIndexedMesh}
+	 * and will delete it when this btTriangleIndexVertexArray is deleted. */
+	public void addIndexedMesh(final btIndexedMesh mesh, boolean managed) {
+		addIndexedMesh(mesh);
+		if (managed) {
+			if (meshes == null)
+				meshes = new com.badlogic.gdx.utils.Array<btIndexedMesh>();
+			meshes.add(mesh);
+		}
+	}
+	
+	protected void dispose() {
+		if (meshes != null) {
+			for (int i = 0; i < meshes.size; i++)
+				meshes.get(i).delete();
+			meshes.clear();
+			meshes = null;
+		}
+	}
+
   public btTriangleIndexVertexArray() {
     this(gdxBulletJNI.new_btTriangleIndexVertexArray__SWIG_0(), true);
   }
diff --git a/extensions/gdx-bullet/jni/swig-src/gdxBullet_wrap.cpp b/extensions/gdx-bullet/jni/swig-src/gdxBullet_wrap.cpp
index 1b3d0ba..af9660a 100755
--- a/extensions/gdx-bullet/jni/swig-src/gdxBullet_wrap.cpp
+++ b/extensions/gdx-bullet/jni/swig-src/gdxBullet_wrap.cpp
@@ -1875,10 +1875,10 @@ typedef btCollisionWorld::ClosestConvexResultCallback ClosestConvexResultCallbac
 typedef btCollisionWorld::ContactResultCallback ContactResultCallback;
 
 
-#include <../swig/custom/ClosestNotMeConvexResultCallback.h>
+#include <GdxCustom/ClosestNotMeConvexResultCallback.h>
 
 
-#include <../swig/custom/ClosestNotMeRayResultCallback.h>
+#include <GdxCustom/ClosestNotMeRayResultCallback.h>
 
 
 #include <BulletCollision/CollisionDispatch/btConvex2dConvex2dAlgorithm.h>
@@ -1962,7 +1962,7 @@ typedef btTypedConstraint::btConstraintInfo2 btConstraintInfo2;
 #include <BulletDynamics/Dynamics/btDynamicsWorld.h>
 
 
-#include <../swig/custom/InternalTickCallback.h>
+#include <GdxCustom/InternalTickCallback.h>
 
 
 #include <BulletDynamics/Dynamics/btSimpleDynamicsWorld.h>
diff --git a/extensions/gdx-bullet/jni/swig/custom/ClosestNotMeConvexResultCallback.h b/extensions/gdx-bullet/jni/swig/custom/ClosestNotMeConvexResultCallback.h
deleted file mode 100644
index 60676f9..0000000
--- a/extensions/gdx-bullet/jni/swig/custom/ClosestNotMeConvexResultCallback.h
+++ /dev/null
@@ -1,56 +0,0 @@
-#ifndef ClosestNotMeConvexResultCallback_H
-#define ClosestNotMeConvexResultCallback_H
-
-class ClosestNotMeConvexResultCallback : public ClosestConvexResultCallback
-{
-public:
-
-	btCollisionObject* m_me;
-	btScalar m_allowedPenetration;
-
-public:
-	ClosestNotMeConvexResultCallback (btCollisionObject* me,const btVector3& fromA,const btVector3& toA) : 
-	  ClosestConvexResultCallback(fromA,toA),
-		m_me(me),
-		m_allowedPenetration(0.0f)
-	{
-	}
-
-	virtual btScalar addSingleResult(btCollisionWorld::LocalConvexResult& convexResult,bool normalInWorldSpace)
-	{
-		if (convexResult.m_hitCollisionObject == m_me)
-			return 1.0f;
-
-		//ignore result if there is no contact response
-		if(!convexResult.m_hitCollisionObject->hasContactResponse())
-			return 1.0f;
-
-		btVector3 linVelA,linVelB;
-		linVelA = m_convexToWorld-m_convexFromWorld;
-		linVelB = btVector3(0,0,0);//toB.getOrigin()-fromB.getOrigin();
-
-		btVector3 relativeVelocity = (linVelA-linVelB);
-		//don't report time of impact for motion away from the contact normal (or causes minor penetration)
-		if (convexResult.m_hitNormalLocal.dot(relativeVelocity)>=-m_allowedPenetration)
-			return 1.f;
-
-		return ClosestConvexResultCallback::addSingleResult (convexResult, normalInWorldSpace);
-	}
-
-	virtual bool needsCollision(btBroadphaseProxy* proxy0) const
-	{
-		//don't collide with itself
-		if (proxy0->m_clientObject == m_me)
-			return false;
-
-		///don't do CCD when the collision filters are not matching
-		if (!ClosestConvexResultCallback::needsCollision(proxy0))
-			return false;
-
-		btCollisionObject* otherObj = (btCollisionObject*) proxy0->m_clientObject;
-
-		return false;
-	}
-};
-
-#endif // ClosestNotMeConvexResultCallback_H
diff --git a/extensions/gdx-bullet/jni/swig/custom/ClosestNotMeRayResultCallback.h b/extensions/gdx-bullet/jni/swig/custom/ClosestNotMeRayResultCallback.h
deleted file mode 100644
index 09f0887..0000000
--- a/extensions/gdx-bullet/jni/swig/custom/ClosestNotMeRayResultCallback.h
+++ /dev/null
@@ -1,23 +0,0 @@
-#ifndef ClosestNotMeRayResultCallback_H
-#define ClosestNotMeRayResultCallback_H
-
-class ClosestNotMeRayResultCallback : public ClosestRayResultCallback
-{
-public:
-	ClosestNotMeRayResultCallback (btCollisionObject* me) : ClosestRayResultCallback(btVector3(0.0, 0.0, 0.0), btVector3(0.0, 0.0, 0.0))
-	{
-		m_me = me;
-	}
-
-	virtual btScalar addSingleResult(btCollisionWorld::LocalRayResult& rayResult,bool normalInWorldSpace)
-	{
-		if (rayResult.m_collisionObject == m_me)
-			return 1.0;
-
-		return ClosestRayResultCallback::addSingleResult (rayResult, normalInWorldSpace);
-	}
-protected:
-	btCollisionObject* m_me;
-};
-
-#endif // ClosestNotMeRayResultCallback_H
diff --git a/extensions/gdx-bullet/jni/swig/custom/InternalTickCallback.h b/extensions/gdx-bullet/jni/swig/custom/InternalTickCallback.h
deleted file mode 100644
index 4ffd9a7..0000000
--- a/extensions/gdx-bullet/jni/swig/custom/InternalTickCallback.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-#ifndef InternalTickCallback_H
-#define InternalTickCallback_H
-
-static void InternalTickCallback_CB(btDynamicsWorld *world, btScalar timeStep);
-
-/** @author xoppa */
-class InternalTickCallback {
-protected:
-	btDynamicsWorld *mWorld;
-	bool mIsPreTick;
-public:
-	InternalTickCallback(btDynamicsWorld *dynamicsWorld = NULL, bool isPreTick = false) {
-		attach(dynamicsWorld, isPreTick);
-	}
-
-	virtual void onInternalTick(btDynamicsWorld *dynamicsWorld, btScalar timeStep) { }
-
-	void detach() {
-		detach(mWorld, mIsPreTick);
-	}
-
-	void attach(btDynamicsWorld *dynamicsWorld, bool isPreTick) {
-		mIsPreTick = isPreTick;
-		mWorld = dynamicsWorld;
-		if (mWorld != NULL)
-			mWorld->setInternalTickCallback(InternalTickCallback_CB, static_cast<void *>(this), isPreTick);
-	}
-
-	void attach() {
-		attach(mWorld, mIsPreTick);
-	}
-
-	static void detach(btDynamicsWorld *dynamicsWorld, bool isPreTick) {
-		if (dynamicsWorld != NULL)
-			dynamicsWorld->setInternalTickCallback(NULL, 0, isPreTick);
-	}
-};
-
-void InternalTickCallback_CB(btDynamicsWorld *world, btScalar timeStep) {
-	InternalTickCallback *cb = static_cast<InternalTickCallback *>(world->getWorldUserInfo());
-	cb->onInternalTick(world, timeStep);
-}
-
-#endif // InternalTickCallback_H
diff --git a/extensions/gdx-bullet/jni/swig/custom/btBvhTriangleMeshShape.i b/extensions/gdx-bullet/jni/swig/custom/btBvhTriangleMeshShape.i
new file mode 100644
index 0000000..de34be5
--- /dev/null
+++ b/extensions/gdx-bullet/jni/swig/custom/btBvhTriangleMeshShape.i
@@ -0,0 +1,116 @@
+/**
+ * Maintain a copy of the data
+ */
+%module btBvhTriangleMeshShape
+
+%{
+#include <BulletCollision/CollisionShapes/btBvhTriangleMeshShape.h>
+%}
+
+%typemap(javacode) btBvhTriangleMeshShape %{
+	btStridingMeshInterface meshInterface = null;
+	
+	/** @param managed If true this btBvhTriangleMeshShape will keep a reference to the {@link btStridingMeshInterface}
+	 * and deletes it when this btBvhTriangleMeshShape gets deleted. */
+	public btBvhTriangleMeshShape(boolean managed, btStridingMeshInterface meshInterface, boolean useQuantizedAabbCompression) {
+		this(meshInterface, useQuantizedAabbCompression);
+		this.meshInterface = meshInterface;
+	}
+
+	/** @param managed If true this btBvhTriangleMeshShape will keep a reference to the {@link btStridingMeshInterface}
+	 * and deletes it when this btBvhTriangleMeshShape gets deleted. */
+	public btBvhTriangleMeshShape(boolean managed, btStridingMeshInterface meshInterface, boolean useQuantizedAabbCompression, boolean buildBvh) {
+		this(meshInterface, useQuantizedAabbCompression, buildBvh);
+		this.meshInterface = meshInterface;
+	}
+	
+	/** @param managed If true this btBvhTriangleMeshShape will keep a reference to the {@link btStridingMeshInterface}
+	 * and deletes it when this btBvhTriangleMeshShape gets deleted. */
+	public btBvhTriangleMeshShape(boolean managed, btStridingMeshInterface meshInterface, boolean useQuantizedAabbCompression, Vector3 bvhAabbMin, Vector3 bvhAabbMax, boolean buildBvh) {
+		this(meshInterface, useQuantizedAabbCompression, bvhAabbMin, bvhAabbMax, buildBvh);
+		this.meshInterface = meshInterface;
+	}
+	
+	/** @param managed If true this btBvhTriangleMeshShape will keep a reference to the {@link btStridingMeshInterface}
+	 * and deletes it when this btBvhTriangleMeshShape gets deleted. */
+	public btBvhTriangleMeshShape(boolean managed, btStridingMeshInterface meshInterface, boolean useQuantizedAabbCompression, Vector3 bvhAabbMin, Vector3 bvhAabbMax) {
+		this(meshInterface, useQuantizedAabbCompression, bvhAabbMin, bvhAabbMax);
+		this.meshInterface = meshInterface;
+	}
+	
+	/** Construct a new btBvhTriangleMeshShape based one or more supplied {@link com.badlogic.gdx.graphics.Mesh} instances.
+	 * The specified meshes must be indexed and triangulated and must outlive this btBvhTriangleMeshShape.
+     * The buffers for the vertices and indices are shared amonst both. */
+	public btBvhTriangleMeshShape(boolean useQuantizedAabbCompression, final com.badlogic.gdx.graphics.Mesh... meshes) {
+		this(true, new btTriangleIndexVertexArray(meshes), useQuantizedAabbCompression);
+	}
+	
+	/** Construct a new btBvhTriangleMeshShape based one or more supplied {@link com.badlogic.gdx.graphics.Mesh} instances.
+	 * The specified meshes must be indexed and triangulated and must outlive this btBvhTriangleMeshShape.
+     * The buffers for the vertices and indices are shared amonst both. */
+	public btBvhTriangleMeshShape(boolean useQuantizedAabbCompression, boolean buildBvh, final com.badlogic.gdx.graphics.Mesh... meshes) {
+		this(true, new btTriangleIndexVertexArray(meshes), useQuantizedAabbCompression, buildBvh);
+	}
+	
+	/** Construct a new btBvhTriangleMeshShape based one or more supplied {@link com.badlogic.gdx.graphics.Mesh} instances.
+	 * The specified meshes must be indexed and triangulated and must outlive this btBvhTriangleMeshShape.
+     * The buffers for the vertices and indices are shared amonst both. */
+	public btBvhTriangleMeshShape(boolean useQuantizedAabbCompression, Vector3 bvhAabbMin, Vector3 bvhAabbMax, boolean buildBvh, final com.badlogic.gdx.graphics.Mesh... meshes) {
+		this(true, new btTriangleIndexVertexArray(meshes), useQuantizedAabbCompression, bvhAabbMin, bvhAabbMax, buildBvh);
+	}
+	
+	/** Construct a new btBvhTriangleMeshShape based one or more supplied {@link com.badlogic.gdx.graphics.Mesh} instances.
+	 * The specified meshes must be indexed and triangulated and must outlive this btBvhTriangleMeshShape.
+     * The buffers for the vertices and indices are shared amonst both. */
+	public btBvhTriangleMeshShape(boolean useQuantizedAabbCompression, Vector3 bvhAabbMin, Vector3 bvhAabbMax, final com.badlogic.gdx.graphics.Mesh... meshes) {
+		this(true, new btTriangleIndexVertexArray(meshes), useQuantizedAabbCompression, bvhAabbMin, bvhAabbMax);
+	}
+	
+	/** Construct a new btBvhTriangleMeshShape based one or more supplied {@link com.badlogic.gdx.graphics.g3d.model.Model} instances.
+	 * Only the triangulated submeshes are added, which must be indexed. The model must outlive this btTriangleIndexVertexArray.
+     * The buffers for the vertices and indices are shared amonst both. */
+	public btBvhTriangleMeshShape(boolean useQuantizedAabbCompression, final com.badlogic.gdx.graphics.g3d.model.Model... models) {
+		this(true, new btTriangleIndexVertexArray(models), useQuantizedAabbCompression);
+	}
+	
+	/** Construct a new btBvhTriangleMeshShape based one or more supplied {@link com.badlogic.gdx.graphics.g3d.model.Model} instances.
+	 * Only the triangulated submeshes are added, which must be indexed. The model must outlive this btTriangleIndexVertexArray.
+     * The buffers for the vertices and indices are shared amonst both. */
+	public btBvhTriangleMeshShape(boolean useQuantizedAabbCompression, boolean buildBvh, final com.badlogic.gdx.graphics.g3d.model.Model... models) {
+		this(true, new btTriangleIndexVertexArray(models), useQuantizedAabbCompression, buildBvh);
+	}
+	
+	/** Construct a new btBvhTriangleMeshShape based one or more supplied {@link com.badlogic.gdx.graphics.g3d.model.Model} instances.
+	 * Only the triangulated submeshes are added, which must be indexed. The model must outlive this btTriangleIndexVertexArray.
+	 * The buffers for the vertices and indices are shared amonst both. */
+	public btBvhTriangleMeshShape(boolean useQuantizedAabbCompression, Vector3 bvhAabbMin, Vector3 bvhAabbMax, boolean buildBvh, final com.badlogic.gdx.graphics.g3d.model.Model... models) {
+		this(true, new btTriangleIndexVertexArray(models), useQuantizedAabbCompression, bvhAabbMin, bvhAabbMax, buildBvh);
+	}
+	
+	/** Construct a new btBvhTriangleMeshShape based one or more supplied {@link com.badlogic.gdx.graphics.g3d.model.Model} instances.
+	 * Only the triangulated submeshes are added, which must be indexed. The model must outlive this btTriangleIndexVertexArray.
+     * The buffers for the vertices and indices are shared amonst both. */
+	public btBvhTriangleMeshShape(boolean useQuantizedAabbCompression, Vector3 bvhAabbMin, Vector3 bvhAabbMax, final com.badlogic.gdx.graphics.g3d.model.Model... models) {
+		this(true, new btTriangleIndexVertexArray(models), useQuantizedAabbCompression, bvhAabbMin, bvhAabbMax);
+	}
+		
+	protected void dispose() {
+		if (meshInterface != null)
+			meshInterface.delete();
+		meshInterface = null;
+	}
+%}
+%typemap(javadestruct_derived, methodname="delete", methodmodifiers="public synchronized") btBvhTriangleMeshShape %{ {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        gdxBulletJNI.delete_btBvhTriangleMeshShape(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+    super.delete();
+	dispose();
+  }
+%}
+
+%include "BulletCollision/CollisionShapes/btBvhTriangleMeshShape.h"
\ No newline at end of file
diff --git a/extensions/gdx-bullet/jni/swig/custom/btTriangleIndexVertexArray.i b/extensions/gdx-bullet/jni/swig/custom/btTriangleIndexVertexArray.i
index e51d5f4..40964a5 100644
--- a/extensions/gdx-bullet/jni/swig/custom/btTriangleIndexVertexArray.i
+++ b/extensions/gdx-bullet/jni/swig/custom/btTriangleIndexVertexArray.i
@@ -6,7 +6,6 @@
 %{
 #include <BulletCollision/CollisionShapes/btTriangleIndexVertexArray.h>
 %}
-%include "BulletCollision/CollisionShapes/btTriangleIndexVertexArray.h"
 
 %extend btIndexedMesh {
 	void setTriangleIndexBase(short *data) {
@@ -15,4 +14,129 @@
 	void setVertexBase(float *data) {
 		$self->m_vertexBase = (unsigned char*)data;
 	}
-};
\ No newline at end of file
+};
+
+%typemap(javaimports) btIndexedMesh %{
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.VertexAttribute;
+import com.badlogic.gdx.graphics.VertexAttributes.Usage;
+%}
+
+%typemap(javacode) btIndexedMesh %{
+	/** Construct a new btIndexedMesh based on the supplied {@link Mesh}
+	 * The specified mesh must be indexed and triangulated and must outlive this btIndexedMesh.
+	 * The buffers for the vertices and indices are shared amonst both. */
+	public btIndexedMesh(final Mesh mesh) {
+		this();
+		set(mesh);
+	}
+	
+	/** Convenience method to set this btIndexedMesh to the specified {@link Mesh} 
+	 * The specified mesh must be indexed and triangulated and must outlive this btIndexedMesh.
+	 * The buffers for the vertices and indices are shared amonst both. */
+	public void set(final Mesh mesh) {
+		final int numIndices = mesh.getNumIndices();
+		if ((numIndices <= 0) || ((numIndices % 3) != 0))
+			throw new com.badlogic.gdx.utils.GdxRuntimeException("Mesh must be indexed and triangulated");
+		java.nio.FloatBuffer buf = mesh.getVerticesBuffer();
+		VertexAttribute posAttr = mesh.getVertexAttribute(Usage.Position);
+		if (posAttr == null)
+			throw new com.badlogic.gdx.utils.GdxRuntimeException("Mesh doesn't have a position attribute");
+		final int pos = buf.position();
+		buf.position(posAttr.offset);
+		setM_indexType(PHY_ScalarType.PHY_SHORT);
+		setM_numTriangles(numIndices/3);
+		setM_numVertices(mesh.getNumVertices());
+		setM_triangleIndexStride(6);
+		setM_vertexStride(mesh.getVertexSize());
+		setM_vertexType(PHY_ScalarType.PHY_FLOAT);
+		setTriangleIndexBase(mesh.getIndicesBuffer());
+		setVertexBase(buf);
+		buf.position(pos);
+	}
+%}
+
+%typemap(javacode) btTriangleIndexVertexArray %{
+	com.badlogic.gdx.utils.Array<btIndexedMesh> meshes = null;
+	
+	/** Construct a new btTriangleIndexVertexArray based one or more supplied {@link com.badlogic.gdx.graphics.Mesh} instances.
+	 * The specified meshes must be indexed and triangulated and must outlive this btTriangleIndexVertexArray.
+     * The buffers for the vertices and indices are shared amongst both. */
+	public btTriangleIndexVertexArray(final com.badlogic.gdx.graphics.Mesh... meshes) {
+		this();
+		addMesh(meshes);
+	}
+	
+	/** Construct a new btTriangleIndexVertexArray based on one or more {@link com.badlogic.gdx.graphics.g3d.model.Model} instances.
+	 * Only the triangulated submeshes are added, which must be indexed. The model must outlive this btTriangleIndexVertexArray.
+     * The buffers for the vertices and indices are shared amongst both. */
+	public btTriangleIndexVertexArray(final com.badlogic.gdx.graphics.g3d.model.Model... models) {
+		this();
+		addModel(models);
+	}
+
+	/** Add one or more {@link com.badlogic.gdx.graphics.Mesh} instances to this btTriangleIndexVertexArray. 
+	 * The specified meshes must be indexed and triangulated and must outlive this btTriangleIndexVertexArray.
+     * The buffers for the vertices and indices are shared amongst both. */
+	public void addMesh(final com.badlogic.gdx.graphics.Mesh... meshes) {
+		for (int i = 0; i < meshes.length; i++)
+			addIndexedMesh(new btIndexedMesh(meshes[i]), PHY_ScalarType.PHY_SHORT, true);
+	}
+	
+	/** Add one or more {@link com.badlogic.gdx.graphics.g3d.model.Model} instances to this btTriangleIndexVertexArray.
+	 * Only the triangulated submeshes are added, which must be indexed. The model must outlive this btTriangleIndexVertexArray.
+     * The buffers for the vertices and indices are shared amongst both. */
+	public void addModel(final com.badlogic.gdx.graphics.g3d.model.Model... models) {
+		for (int i = 0; i < models.length; i++) {
+			final com.badlogic.gdx.graphics.g3d.model.SubMesh[] subMeshes = models[i].getSubMeshes();
+			for (int j = 0; j < subMeshes.length; j++)
+				if (subMeshes[j].primitiveType == com.badlogic.gdx.graphics.GL10.GL_TRIANGLES)
+					addIndexedMesh(new btIndexedMesh(subMeshes[j].getMesh()), PHY_ScalarType.PHY_SHORT, true);
+		}
+	}
+	
+	/** @param managed If true this btTriangleIndexVertexArray will maintain a reference to the {@link btIndexedMesh}
+	 * and will delete it when this btTriangleIndexVertexArray is deleted. */
+	public void addIndexedMesh(final btIndexedMesh mesh, int indexType, boolean managed) {
+		addIndexedMesh(mesh, indexType);
+		if (managed) {
+			if (meshes == null)
+				meshes = new com.badlogic.gdx.utils.Array<btIndexedMesh>();
+			meshes.add(mesh);
+		}
+	}
+
+	/** @param managed If true this btTriangleIndexVertexArray will maintain a reference to the {@link btIndexedMesh}
+	 * and will delete it when this btTriangleIndexVertexArray is deleted. */
+	public void addIndexedMesh(final btIndexedMesh mesh, boolean managed) {
+		addIndexedMesh(mesh);
+		if (managed) {
+			if (meshes == null)
+				meshes = new com.badlogic.gdx.utils.Array<btIndexedMesh>();
+			meshes.add(mesh);
+		}
+	}
+	
+	protected void dispose() {
+		if (meshes != null) {
+			for (int i = 0; i < meshes.size; i++)
+				meshes.get(i).delete();
+			meshes.clear();
+			meshes = null;
+		}
+	}
+%}
+%typemap(javadestruct_derived, methodname="delete", methodmodifiers="public synchronized") btTriangleIndexVertexArray %{ {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        gdxBulletJNI.delete_btTriangleIndexVertexArray(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+    super.delete();
+	dispose();
+  }
+%}
+
+%include "BulletCollision/CollisionShapes/btTriangleIndexVertexArray.h"
diff --git a/extensions/gdx-bullet/jni/swig/gdxBullet.i b/extensions/gdx-bullet/jni/swig/gdxBullet.i
index 70a2914..748f387 100644
--- a/extensions/gdx-bullet/jni/swig/gdxBullet.i
+++ b/extensions/gdx-bullet/jni/swig/gdxBullet.i
@@ -303,10 +303,8 @@ ENABLE_POOLED_TYPEMAP(btTransform, Matrix4, "Lcom/badlogic/gdx/math/Matrix4;");
 %}
 %include "BulletCollision/CollisionShapes/btTriangleMeshShape.h"
 
-%{
-#include <BulletCollision/CollisionShapes/btBvhTriangleMeshShape.h>
-%}
-%include "BulletCollision/CollisionShapes/btBvhTriangleMeshShape.h"
+
+%include "custom/btBvhTriangleMeshShape.i"
 
 %{
 #include <BulletCollision/CollisionShapes/btBoxShape.h>
@@ -537,14 +535,14 @@ ENABLE_POOLED_TYPEMAP(btTransform, Matrix4, "Lcom/badlogic/gdx/math/Matrix4;");
 %include "custom/btCollisionWorld.i"
 
 %{
-#include <../swig/custom/ClosestNotMeConvexResultCallback.h>
+#include <GdxCustom/ClosestNotMeConvexResultCallback.h>
 %}
-%include "../swig/custom/ClosestNotMeConvexResultCallback.h"
+%include "GdxCustom/ClosestNotMeConvexResultCallback.h"
 
 %{
-#include <../swig/custom/ClosestNotMeRayResultCallback.h>
+#include <GdxCustom/ClosestNotMeRayResultCallback.h>
 %}
-%include "../swig/custom/ClosestNotMeRayResultCallback.h"
+%include "GdxCustom/ClosestNotMeRayResultCallback.h"
 
 %{
 #include <BulletCollision/CollisionDispatch/btConvex2dConvex2dAlgorithm.h>
@@ -675,9 +673,9 @@ ENABLE_POOLED_TYPEMAP(btTransform, Matrix4, "Lcom/badlogic/gdx/math/Matrix4;");
 %include "BulletDynamics/Dynamics/btDynamicsWorld.h"
 
 %{
-#include <../swig/custom/InternalTickCallback.h>
+#include <GdxCustom/InternalTickCallback.h>
 %}
-%include "../swig/custom/InternalTickCallback.h"
+%include "GdxCustom/InternalTickCallback.h"
 
 %{
 #include <BulletDynamics/Dynamics/btSimpleDynamicsWorld.h>
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/.classpath b/extensions/gdx-controllers/gdx-controllers-desktop/.classpath
new file mode 100644
index 0000000..d5f1db6
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/.classpath
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
+	<classpathentry excluding="**/.svn/*" kind="src" path="src"/>
+	<classpathentry combineaccessrules="false" exported="true" kind="src" path="/gdx"/>
+	<classpathentry combineaccessrules="false" exported="true" kind="src" path="/gdx-backend-lwjgl"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/gdx-jnigen"/>
+	<classpathentry exported="true" kind="lib" path="libs/gdx-controllers-desktop-natives.jar"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/.project b/extensions/gdx-controllers/gdx-controllers-desktop/.project
new file mode 100644
index 0000000..57623ae
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>gdx-controllers-desktop</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/.settings/org.eclipse.jdt.core.prefs b/extensions/gdx-controllers/gdx-controllers-desktop/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..cc51644
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,369 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.6
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.doc.comment.support=enabled
+org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.autoboxing=ignore
+org.eclipse.jdt.core.compiler.problem.comparingIdentical=warning
+org.eclipse.jdt.core.compiler.problem.deadCode=ignore
+org.eclipse.jdt.core.compiler.problem.deprecation=ignore
+org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
+org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
+org.eclipse.jdt.core.compiler.problem.discouragedReference=warning
+org.eclipse.jdt.core.compiler.problem.emptyStatement=ignore
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.fallthroughCase=ignore
+org.eclipse.jdt.core.compiler.problem.fatalOptionalError=disabled
+org.eclipse.jdt.core.compiler.problem.fieldHiding=ignore
+org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
+org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=warning
+org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
+org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
+org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=ignore
+org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=ignore
+org.eclipse.jdt.core.compiler.problem.invalidJavadoc=warning
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTags=enabled
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsDeprecatedRef=enabled
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsNotVisibleRef=enabled
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsVisibility=private
+org.eclipse.jdt.core.compiler.problem.localVariableHiding=ignore
+org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
+org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingHashCodeMethod=ignore
+org.eclipse.jdt.core.compiler.problem.missingJavadocComments=ignore
+org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsOverriding=enabled
+org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsVisibility=public
+org.eclipse.jdt.core.compiler.problem.missingJavadocTagDescription=return_tag
+org.eclipse.jdt.core.compiler.problem.missingJavadocTags=ignore
+org.eclipse.jdt.core.compiler.problem.missingJavadocTagsOverriding=enabled
+org.eclipse.jdt.core.compiler.problem.missingJavadocTagsVisibility=private
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotationForInterfaceMethodImplementation=enabled
+org.eclipse.jdt.core.compiler.problem.missingSerialVersion=ignore
+org.eclipse.jdt.core.compiler.problem.missingSynchronizedOnInheritedMethod=ignore
+org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
+org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
+org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=ignore
+org.eclipse.jdt.core.compiler.problem.nullReference=warning
+org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
+org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=warning
+org.eclipse.jdt.core.compiler.problem.potentialNullReference=ignore
+org.eclipse.jdt.core.compiler.problem.rawTypeReference=ignore
+org.eclipse.jdt.core.compiler.problem.redundantNullCheck=ignore
+org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=ignore
+org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
+org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=warning
+org.eclipse.jdt.core.compiler.problem.suppressOptionalErrors=disabled
+org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
+org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=warning
+org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
+org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=ignore
+org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=ignore
+org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.unnecessaryElse=ignore
+org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=ignore
+org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=enabled
+org.eclipse.jdt.core.compiler.problem.unusedImport=ignore
+org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
+org.eclipse.jdt.core.compiler.problem.unusedLocal=ignore
+org.eclipse.jdt.core.compiler.problem.unusedObjectAllocation=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameterIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=enabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=enabled
+org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=ignore
+org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
+org.eclipse.jdt.core.compiler.source=1.6
+org.eclipse.jdt.core.formatter.align_type_members_on_columns=false
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_annotation=0
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_qualified_allocation_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_assignment=0
+org.eclipse.jdt.core.formatter.alignment_for_binary_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_compact_if=16
+org.eclipse.jdt.core.formatter.alignment_for_conditional_expression=80
+org.eclipse.jdt.core.formatter.alignment_for_enum_constants=0
+org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer=16
+org.eclipse.jdt.core.formatter.alignment_for_method_declaration=0
+org.eclipse.jdt.core.formatter.alignment_for_multiple_fields=16
+org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_resources_in_try=80
+org.eclipse.jdt.core.formatter.alignment_for_selector_in_method_invocation=16
+org.eclipse.jdt.core.formatter.alignment_for_superclass_in_type_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_enum_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_type_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_union_type_in_multicatch=16
+org.eclipse.jdt.core.formatter.blank_lines_after_imports=1
+org.eclipse.jdt.core.formatter.blank_lines_after_package=1
+org.eclipse.jdt.core.formatter.blank_lines_before_field=0
+org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration=0
+org.eclipse.jdt.core.formatter.blank_lines_before_imports=1
+org.eclipse.jdt.core.formatter.blank_lines_before_member_type=1
+org.eclipse.jdt.core.formatter.blank_lines_before_method=1
+org.eclipse.jdt.core.formatter.blank_lines_before_new_chunk=1
+org.eclipse.jdt.core.formatter.blank_lines_before_package=1
+org.eclipse.jdt.core.formatter.blank_lines_between_import_groups=1
+org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations=1
+org.eclipse.jdt.core.formatter.brace_position_for_annotation_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_anonymous_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_array_initializer=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_block=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_block_in_case=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_enum_constant=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_method_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_switch=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment=false
+org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment=false
+org.eclipse.jdt.core.formatter.comment.format_block_comments=true
+org.eclipse.jdt.core.formatter.comment.format_header=false
+org.eclipse.jdt.core.formatter.comment.format_html=true
+org.eclipse.jdt.core.formatter.comment.format_javadoc_comments=true
+org.eclipse.jdt.core.formatter.comment.format_line_comments=true
+org.eclipse.jdt.core.formatter.comment.format_source_code=true
+org.eclipse.jdt.core.formatter.comment.indent_parameter_description=true
+org.eclipse.jdt.core.formatter.comment.indent_root_tags=true
+org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags=do not insert
+org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter=do not insert
+org.eclipse.jdt.core.formatter.comment.line_length=130
+org.eclipse.jdt.core.formatter.comment.new_lines_at_block_boundaries=true
+org.eclipse.jdt.core.formatter.comment.new_lines_at_javadoc_boundaries=false
+org.eclipse.jdt.core.formatter.comment.preserve_white_space_between_code_and_line_comments=false
+org.eclipse.jdt.core.formatter.compact_else_if=true
+org.eclipse.jdt.core.formatter.continuation_indentation=1
+org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer=1
+org.eclipse.jdt.core.formatter.disabling_tag=@off
+org.eclipse.jdt.core.formatter.enabling_tag=@on
+org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line=false
+org.eclipse.jdt.core.formatter.format_line_comment_starting_on_first_column=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header=true
+org.eclipse.jdt.core.formatter.indent_breaks_compare_to_cases=true
+org.eclipse.jdt.core.formatter.indent_empty_lines=false
+org.eclipse.jdt.core.formatter.indent_statements_compare_to_block=true
+org.eclipse.jdt.core.formatter.indent_statements_compare_to_body=true
+org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases=true
+org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch=false
+org.eclipse.jdt.core.formatter.indentation.size=4
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_field=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_method=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_package=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_type=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_label=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing=insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_annotation_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_anonymous_type_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_block=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_constant=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_method_body=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_after_and_in_type_parameter=insert
+org.eclipse.jdt.core.formatter.insert_space_after_assignment_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation_type_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_binary_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_assert=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_case=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_labeled_statement=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_constant_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_explicitconstructorcall_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_inits=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_throws=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_field_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_local_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_parameterized_type_reference=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_ellipsis=insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_cast=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_catch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_if=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_switch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_try=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_while=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_prefix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_after_question_in_wildcard=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_try_resources=insert
+org.eclipse.jdt.core.formatter.insert_space_after_unary_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_and_in_type_parameter=insert
+org.eclipse.jdt.core.formatter.insert_space_before_assignment_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_before_at_in_annotation_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_binary_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_cast=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_catch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_if=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_switch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_synchronized=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_try=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_while=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_assert=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_throws=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_constant_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_explicitconstructorcall_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_increments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_inits=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_local_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_ellipsis=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_annotation_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_anonymous_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_constructor_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_constant=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation_type_member_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_constructor_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_try=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while=insert
+org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_return=insert
+org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_throw=insert
+org.eclipse.jdt.core.formatter.insert_space_before_postfix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_prefix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_before_question_in_wildcard=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_semicolon=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_try_resources=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_unary_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_brackets_in_array_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_braces_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_brackets_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.join_lines_in_comments=true
+org.eclipse.jdt.core.formatter.join_wrapped_lines=true
+org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line=false
+org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line=false
+org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line=true
+org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line=false
+org.eclipse.jdt.core.formatter.lineSplit=130
+org.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column=true
+org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column=true
+org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body=0
+org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve=1
+org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line=true
+org.eclipse.jdt.core.formatter.tabulation.char=tab
+org.eclipse.jdt.core.formatter.tabulation.size=3
+org.eclipse.jdt.core.formatter.use_on_off_tags=true
+org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations=false
+org.eclipse.jdt.core.formatter.wrap_before_binary_operator=true
+org.eclipse.jdt.core.formatter.wrap_before_or_operator_multicatch=true
+org.eclipse.jdt.core.formatter.wrap_outer_expressions_when_nested=true
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/.settings/org.eclipse.jdt.ui.prefs b/extensions/gdx-controllers/gdx-controllers-desktop/.settings/org.eclipse.jdt.ui.prefs
new file mode 100644
index 0000000..12ca759
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/.settings/org.eclipse.jdt.ui.prefs
@@ -0,0 +1,3 @@
+eclipse.preferences.version=1
+formatter_profile=_libgdx
+formatter_settings_version=12
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/build-windows32home.xml b/extensions/gdx-controllers/gdx-controllers-desktop/jni/build-windows32home.xml
new file mode 100755
index 0000000..ff15af8
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/build-windows32home.xml
@@ -0,0 +1,143 @@
+<project name="gdx-controllers-desktop-Windows-32" basedir="." default="postcompile">
+	<!-- include the environment -->
+	<property environment="env"/>	
+	<!-- output directory for temporary object files -->
+	<property name="buildDir" value="target/windows32" />
+	<!-- output directory for the shared library -->
+	<property name="libsDir" value="../libs/windows32" />
+	<!-- the name of the shared library -->
+	<property name="libName" value="gdx-controllers-desktop.dll"/>
+	<!-- the jni header jniPlatform to use -->
+	<property name="jniPlatform" value="win32"/>
+	<!-- the compilerPrefix for the C & C++ compilers -->
+	<property name="compilerPrefix" value=""/>	
+	
+	<!-- define gcc compiler, options and files to compile -->
+	<property name="gcc" value="${compilerPrefix}gcc"/>	
+	<property name="gcc-opts" value="-c -Wall -O2 -mfpmath=sse -msse2 -fmessage-length=0 -m32"/>
+	<fileset id="gcc-files" dir="./">
+		<exclude name="target/"/>		
+				<include name="memcpy_wrap.c"/>
+
+		
+	</fileset>
+	
+	<!-- define g++ compiler, options and files to compile -->
+	<property name="g++" value="${compilerPrefix}g++"/>
+	<property name="g++-opts" value="-c -Wall -O2 -mfpmath=sse -msse2 -fmessage-length=0 -m32"/>
+	<fileset id="g++-files" dir="./">
+		<exclude name="target/"/>
+				<include name="*.cpp"/>
+		<include name="ois-v1-4svn/src/*.cpp"/>
+		<include name="ois-v1-4svn/src/win32/*.cpp"/>
+
+		
+	</fileset>
+
+	<!-- define linker and options -->
+	<property name="linker" value="${compilerPrefix}g++"/>
+	<property name="linker-opts" value="-Wl,--kill-at -shared -m32 -static-libgcc -static-libstdc++"/>
+	<property name="libraries" value="-ldinput8 -ldxguid"/>
+	
+	<!-- cleans the build directory, removes all object files and shared libs -->
+	<target name="clean">
+		<delete includeemptydirs="true" quiet="true">
+			<fileset dir="${buildDir}"/>
+			<fileset dir="${libsDir}" includes="**/*" excludes="**/.svn"/>
+		</delete>
+	</target>
+	
+	<target name="precompile">
+		<condition property="compiler-found">
+			<and>
+				<or>
+					<!-- Include both b/c Windows might be either -->
+					<available file="${g++}" filepath="${env.PATH}"/>
+					<available file="${g++}" filepath="${env.Path}"/>
+				</or>
+				<or>
+					<!-- Include both b/c Windows might be either -->
+					<available file="${gcc}" filepath="${env.PATH}"/>
+					<available file="${gcc}" filepath="${env.Path}"/>
+				</or>
+			</and>
+		</condition>
+		<condition property="has-compiler">
+			<equals arg1="${compiler-found}" arg2="true"/>
+		</condition>
+		
+	</target>
+	
+	<target name="create-build-dir" depends="precompile" if="has-compiler">
+		<!-- FIXME this is pretty nasty :/ -->
+		<copy todir="${buildDir}">
+			<fileset refid="g++-files"/>
+			<fileset refid="gcc-files"/>
+		</copy>
+		<delete>
+			<fileset dir="${buildDir}">
+				<include name="*"/>
+				<exclude name="*.o"/>
+			</fileset>
+		</delete>
+	</target>
+
+	<!-- compiles all C and C++ files to object files in the build directory -->
+	<target name="compile" depends="create-build-dir" if="has-compiler">
+		<mkdir dir="${buildDir}"/>
+		<apply failonerror="true" executable="${g++}" dest="${buildDir}" verbose="true">
+			<arg line="${g++-opts}"/>
+			<arg value="-Ijni-headers"/>
+			<arg value="-Ijni-headers/${jniPlatform}"/>
+			<arg value="-I."/>
+						<arg value="-Iois-v1-4svn/includes"/>
+			<arg value="-Idinput/"/>
+
+			<srcfile/>
+			<arg value="-o"/>
+			<targetfile/>
+			<fileset refid="g++-files"/>
+			<chainedmapper>
+				<mapper type="glob" from="*.cpp" to="*.o"/>
+			</chainedmapper>
+		</apply>
+		<apply failonerror="true" executable="${gcc}" dest="${buildDir}" verbose="true">
+			<arg line="${gcc-opts}"/>
+			<arg value="-Ijni-headers"/>
+			<arg value="-Ijni-headers/${jniPlatform}"/>
+			<arg value="-I."/>
+						<arg value="-Iois-v1-4svn/includes"/>
+			<arg value="-Idinput/"/>
+
+			<srcfile/>
+			<arg value="-o"/>
+			<targetfile/>
+			<fileset refid="gcc-files"/>
+			<chainedmapper>
+				<mapper type="glob" from="*.c" to="*.o"/>
+			</chainedmapper>
+		</apply>
+	</target>	
+
+	<!-- links the shared library based on the previously compiled object files -->	
+	<target name="link" depends="compile" if="has-compiler">
+		<fileset dir="${buildDir}" id="objFileSet">
+			<patternset>
+				<include name="**/*.o" />
+			</patternset>
+		</fileset>
+		<pathconvert pathsep=" " property="objFiles" refid="objFileSet" />
+		<mkdir dir="${libsDir}" />
+		<exec executable="${linker}" failonerror="true" dir="${buildDir}">
+			<arg line="${linker-opts}" />
+			<arg value="-o" />
+			<arg path="${libsDir}/${libName}" />
+			<arg line="${objFiles}"/>
+			<arg line="${libraries}" />
+		</exec>
+	</target>	
+	
+	<target name="postcompile" depends="link">
+		
+	</target>
+</project>
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/build.xml b/extensions/gdx-controllers/gdx-controllers-desktop/jni/build.xml
new file mode 100755
index 0000000..75b0bef
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/build.xml
@@ -0,0 +1,20 @@
+<project name="gdx-controllers-desktop-natives" basedir="." default="all">
+	<target name="clean">
+		<ant antfile="build-windows32home.xml" target="clean"/>
+
+	</target>
+	
+	<target name="compile-natives">
+		<ant antfile="build-windows32home.xml"/>
+
+	</target>
+	
+	<target name="pack-natives">
+		<jar destfile="../libs/gdx-controllers-desktop-natives.jar">
+			<fileset dir="../libs/windows32" includes="gdx-controllers-desktop.dll"/>
+
+		</jar>
+	</target>
+
+	<target name="all" depends="compile-natives,pack-natives"/>
+</project>
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/com.badlogic.gdx.controllers.OisWrapper.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/com.badlogic.gdx.controllers.OisWrapper.cpp
new file mode 100755
index 0000000..55d0eae
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/com.badlogic.gdx.controllers.OisWrapper.cpp
@@ -0,0 +1,82 @@
+#include <com.badlogic.gdx.controllers.OisWrapper.h>
+
+//@line:14
+
+	#include <OISJoyStick.h>
+	#include <OISInputManager.h>
+	#include <sstream>
+
+	class Listener : public OIS::JoyStickListener {
+	private:
+		bool povMoved (const OIS::JoyStickEvent &event, int pov);
+		bool axisMoved (const OIS::JoyStickEvent &event, int axis);
+		bool sliderMoved (const OIS::JoyStickEvent &event, int sliderID);
+		bool buttonPressed (const OIS::JoyStickEvent &event, int button);
+		bool buttonReleased (const OIS::JoyStickEvent &event, int button);
+	};
+
+	bool Listener::buttonPressed (const OIS::JoyStickEvent &event, int buttonId) {
+		printf("buttonPressed: %i\n", buttonId);
+		fflush(stdout);
+		return true;
+	}
+
+	bool Listener::buttonReleased (const OIS::JoyStickEvent &event, int buttonId) {
+		printf("buttonReleased: %i\n", buttonId);
+		fflush(stdout);
+		return true;
+	}
+
+	bool Listener::axisMoved (const OIS::JoyStickEvent &event, int axisId) {
+		printf("axisMoved: %i\n", axisId);
+		fflush(stdout);
+		return true;
+	}
+
+	bool Listener::povMoved (const OIS::JoyStickEvent &event, int povId) {
+		printf("povMoved: %i\n", povId);
+		fflush(stdout);
+		return true;
+	}
+
+	bool Listener::sliderMoved (const OIS::JoyStickEvent &event, int sliderId) {
+		printf("sliderMoved: %i\n", sliderId);
+		fflush(stdout);
+		return true;
+	}
+	JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_controllers_OisWrapper_initialize(JNIEnv* env, jclass clazz, jlong hwnd) {
+
+
+//@line:59
+
+		std::ostringstream hwndStr;
+		hwndStr << hwnd;
+
+		OIS::ParamList params;
+		params.insert(std::make_pair("WINDOW", hwndStr.str()));
+		params.insert(std::make_pair("w32_joystick", "DISCL_BACKGROUND"));
+		params.insert(std::make_pair("w32_joystick", "DISCL_NONEXCLUSIVE"));
+
+		OIS::InputManager *inputManager = OIS::InputManager::createInputSystem(params);
+		printf("OIS version: %i\n", inputManager->getVersionNumber());
+		fflush(stdout);
+
+		//Listener *listener = new Listener();
+		int count = inputManager->getNumberOfDevices(OIS::OISJoyStick);
+		printf("joystick count: %i\n", count);
+		fflush(stdout);
+		for (int i = 0; i < count; i++) {
+			try {
+				inputManager->createInputObject(OIS::OISJoyStick, true);
+			} catch (std::exception &ex) {
+				printf("exception!\n%s\n", ex.what());
+				fflush(stdout);
+			}
+			//OIS::JoyStick* joystick = static_cast<OIS::JoyStick*>(inputManager->createInputObject(OIS::OISJoyStick, true));
+			//joystick->setEventCallback(listener);
+		}
+		return (jlong)inputManager;
+	
+
+}
+
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/com.badlogic.gdx.controllers.OisWrapper.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/com.badlogic.gdx.controllers.OisWrapper.h
new file mode 100755
index 0000000..8279531
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/com.badlogic.gdx.controllers.OisWrapper.h
@@ -0,0 +1,21 @@
+/* DO NOT EDIT THIS FILE - it is machine generated */
+#include <jni.h>
+/* Header for class com_badlogic_gdx_controllers_OisWrapper */
+
+#ifndef _Included_com_badlogic_gdx_controllers_OisWrapper
+#define _Included_com_badlogic_gdx_controllers_OisWrapper
+#ifdef __cplusplus
+extern "C" {
+#endif
+/*
+ * Class:     com_badlogic_gdx_controllers_OisWrapper
+ * Method:    initialize
+ * Signature: (J)J
+ */
+JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_controllers_OisWrapper_initialize
+  (JNIEnv *, jclass, jlong);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/dinput/dinput.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/dinput/dinput.h
new file mode 100644
index 0000000..5aac256
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/dinput/dinput.h
@@ -0,0 +1,4417 @@
+/****************************************************************************
+ *
+ *  Copyright (C) 1996-2000 Microsoft Corporation.  All Rights Reserved.
+ *
+ *  File:       dinput.h
+ *  Content:    DirectInput include file
+ *
+ ****************************************************************************/
+
+#ifndef __DINPUT_INCLUDED__
+#define __DINPUT_INCLUDED__
+
+#ifndef DIJ_RINGZERO
+
+#ifdef _WIN32
+#define COM_NO_WINDOWS_H
+#include <objbase.h>
+#endif
+
+#endif /* DIJ_RINGZERO */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+
+
+/*
+ *  To build applications for older versions of DirectInput
+ *
+ *  #define DIRECTINPUT_VERSION [ 0x0300 | 0x0500 | 0x0700 ]
+ *
+ *  before #include <dinput.h>.  By default, #include <dinput.h>
+ *  will produce a DirectX 8-compatible header file.
+ *
+ */
+
+#define DIRECTINPUT_HEADER_VERSION  0x0800
+#ifndef DIRECTINPUT_VERSION
+#define DIRECTINPUT_VERSION         DIRECTINPUT_HEADER_VERSION
+#pragma message(__FILE__ ": DIRECTINPUT_VERSION undefined. Defaulting to version 0x0800")
+#endif
+
+#ifndef DIJ_RINGZERO
+
+/****************************************************************************
+ *
+ *      Class IDs
+ *
+ ****************************************************************************/
+
+DEFINE_GUID(CLSID_DirectInput,       0x25E609E0,0xB259,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(CLSID_DirectInputDevice, 0x25E609E1,0xB259,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+
+DEFINE_GUID(CLSID_DirectInput8,      0x25E609E4,0xB259,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(CLSID_DirectInputDevice8,0x25E609E5,0xB259,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+
+/****************************************************************************
+ *
+ *      Interfaces
+ *
+ ****************************************************************************/
+
+DEFINE_GUID(IID_IDirectInputA,     0x89521360,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(IID_IDirectInputW,     0x89521361,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(IID_IDirectInput2A,    0x5944E662,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(IID_IDirectInput2W,    0x5944E663,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(IID_IDirectInput7A,    0x9A4CB684,0x236D,0x11D3,0x8E,0x9D,0x00,0xC0,0x4F,0x68,0x44,0xAE);
+DEFINE_GUID(IID_IDirectInput7W,    0x9A4CB685,0x236D,0x11D3,0x8E,0x9D,0x00,0xC0,0x4F,0x68,0x44,0xAE);
+DEFINE_GUID(IID_IDirectInput8A,    0xBF798030,0x483A,0x4DA2,0xAA,0x99,0x5D,0x64,0xED,0x36,0x97,0x00);
+DEFINE_GUID(IID_IDirectInput8W,    0xBF798031,0x483A,0x4DA2,0xAA,0x99,0x5D,0x64,0xED,0x36,0x97,0x00);
+DEFINE_GUID(IID_IDirectInputDeviceA, 0x5944E680,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(IID_IDirectInputDeviceW, 0x5944E681,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(IID_IDirectInputDevice2A,0x5944E682,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(IID_IDirectInputDevice2W,0x5944E683,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(IID_IDirectInputDevice7A,0x57D7C6BC,0x2356,0x11D3,0x8E,0x9D,0x00,0xC0,0x4F,0x68,0x44,0xAE);
+DEFINE_GUID(IID_IDirectInputDevice7W,0x57D7C6BD,0x2356,0x11D3,0x8E,0x9D,0x00,0xC0,0x4F,0x68,0x44,0xAE);
+DEFINE_GUID(IID_IDirectInputDevice8A,0x54D41080,0xDC15,0x4833,0xA4,0x1B,0x74,0x8F,0x73,0xA3,0x81,0x79);
+DEFINE_GUID(IID_IDirectInputDevice8W,0x54D41081,0xDC15,0x4833,0xA4,0x1B,0x74,0x8F,0x73,0xA3,0x81,0x79);
+DEFINE_GUID(IID_IDirectInputEffect,  0xE7E1F7C0,0x88D2,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+
+/****************************************************************************
+ *
+ *      Predefined object types
+ *
+ ****************************************************************************/
+
+DEFINE_GUID(GUID_XAxis,   0xA36D02E0,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(GUID_YAxis,   0xA36D02E1,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(GUID_ZAxis,   0xA36D02E2,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(GUID_RxAxis,  0xA36D02F4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(GUID_RyAxis,  0xA36D02F5,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(GUID_RzAxis,  0xA36D02E3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(GUID_Slider,  0xA36D02E4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+
+DEFINE_GUID(GUID_Button,  0xA36D02F0,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(GUID_Key,     0x55728220,0xD33C,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+
+DEFINE_GUID(GUID_POV,     0xA36D02F2,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+
+DEFINE_GUID(GUID_Unknown, 0xA36D02F3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+
+/****************************************************************************
+ *
+ *      Predefined product GUIDs
+ *
+ ****************************************************************************/
+
+DEFINE_GUID(GUID_SysMouse,   0x6F1D2B60,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(GUID_SysKeyboard,0x6F1D2B61,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(GUID_Joystick   ,0x6F1D2B70,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(GUID_SysMouseEm, 0x6F1D2B80,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(GUID_SysMouseEm2,0x6F1D2B81,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(GUID_SysKeyboardEm, 0x6F1D2B82,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+DEFINE_GUID(GUID_SysKeyboardEm2,0x6F1D2B83,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
+
+/****************************************************************************
+ *
+ *      Predefined force feedback effects
+ *
+ ****************************************************************************/
+
+DEFINE_GUID(GUID_ConstantForce, 0x13541C20,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+DEFINE_GUID(GUID_RampForce,     0x13541C21,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+DEFINE_GUID(GUID_Square,        0x13541C22,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+DEFINE_GUID(GUID_Sine,          0x13541C23,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+DEFINE_GUID(GUID_Triangle,      0x13541C24,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+DEFINE_GUID(GUID_SawtoothUp,    0x13541C25,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+DEFINE_GUID(GUID_SawtoothDown,  0x13541C26,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+DEFINE_GUID(GUID_Spring,        0x13541C27,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+DEFINE_GUID(GUID_Damper,        0x13541C28,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+DEFINE_GUID(GUID_Inertia,       0x13541C29,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+DEFINE_GUID(GUID_Friction,      0x13541C2A,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+DEFINE_GUID(GUID_CustomForce,   0x13541C2B,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
+
+#endif /* DIJ_RINGZERO */
+
+/****************************************************************************
+ *
+ *      Interfaces and Structures...
+ *
+ ****************************************************************************/
+
+#if(DIRECTINPUT_VERSION >= 0x0500)
+
+/****************************************************************************
+ *
+ *      IDirectInputEffect
+ *
+ ****************************************************************************/
+
+#define DIEFT_ALL                   0x00000000
+
+#define DIEFT_CONSTANTFORCE         0x00000001
+#define DIEFT_RAMPFORCE             0x00000002
+#define DIEFT_PERIODIC              0x00000003
+#define DIEFT_CONDITION             0x00000004
+#define DIEFT_CUSTOMFORCE           0x00000005
+#define DIEFT_HARDWARE              0x000000FF
+#define DIEFT_FFATTACK              0x00000200
+#define DIEFT_FFFADE                0x00000400
+#define DIEFT_SATURATION            0x00000800
+#define DIEFT_POSNEGCOEFFICIENTS    0x00001000
+#define DIEFT_POSNEGSATURATION      0x00002000
+#define DIEFT_DEADBAND              0x00004000
+#define DIEFT_STARTDELAY            0x00008000
+#define DIEFT_GETTYPE(n)            LOBYTE(n)
+
+#define DI_DEGREES                  100
+#define DI_FFNOMINALMAX             10000
+#define DI_SECONDS                  1000000
+
+typedef struct DICONSTANTFORCE {
+    LONG  lMagnitude;
+} DICONSTANTFORCE, *LPDICONSTANTFORCE;
+typedef const DICONSTANTFORCE *LPCDICONSTANTFORCE;
+
+typedef struct DIRAMPFORCE {
+    LONG  lStart;
+    LONG  lEnd;
+} DIRAMPFORCE, *LPDIRAMPFORCE;
+typedef const DIRAMPFORCE *LPCDIRAMPFORCE;
+
+typedef struct DIPERIODIC {
+    DWORD dwMagnitude;
+    LONG  lOffset;
+    DWORD dwPhase;
+    DWORD dwPeriod;
+} DIPERIODIC, *LPDIPERIODIC;
+typedef const DIPERIODIC *LPCDIPERIODIC;
+
+typedef struct DICONDITION {
+    LONG  lOffset;
+    LONG  lPositiveCoefficient;
+    LONG  lNegativeCoefficient;
+    DWORD dwPositiveSaturation;
+    DWORD dwNegativeSaturation;
+    LONG  lDeadBand;
+} DICONDITION, *LPDICONDITION;
+typedef const DICONDITION *LPCDICONDITION;
+
+typedef struct DICUSTOMFORCE {
+    DWORD cChannels;
+    DWORD dwSamplePeriod;
+    DWORD cSamples;
+    LPLONG rglForceData;
+} DICUSTOMFORCE, *LPDICUSTOMFORCE;
+typedef const DICUSTOMFORCE *LPCDICUSTOMFORCE;
+
+
+typedef struct DIENVELOPE {
+    DWORD dwSize;                   /* sizeof(DIENVELOPE)   */
+    DWORD dwAttackLevel;
+    DWORD dwAttackTime;             /* Microseconds         */
+    DWORD dwFadeLevel;
+    DWORD dwFadeTime;               /* Microseconds         */
+} DIENVELOPE, *LPDIENVELOPE;
+typedef const DIENVELOPE *LPCDIENVELOPE;
+
+
+/* This structure is defined for DirectX 5.0 compatibility */
+typedef struct DIEFFECT_DX5 {
+    DWORD dwSize;                   /* sizeof(DIEFFECT_DX5) */
+    DWORD dwFlags;                  /* DIEFF_*              */
+    DWORD dwDuration;               /* Microseconds         */
+    DWORD dwSamplePeriod;           /* Microseconds         */
+    DWORD dwGain;
+    DWORD dwTriggerButton;          /* or DIEB_NOTRIGGER    */
+    DWORD dwTriggerRepeatInterval;  /* Microseconds         */
+    DWORD cAxes;                    /* Number of axes       */
+    LPDWORD rgdwAxes;               /* Array of axes        */
+    LPLONG rglDirection;            /* Array of directions  */
+    LPDIENVELOPE lpEnvelope;        /* Optional             */
+    DWORD cbTypeSpecificParams;     /* Size of params       */
+    LPVOID lpvTypeSpecificParams;   /* Pointer to params    */
+} DIEFFECT_DX5, *LPDIEFFECT_DX5;
+typedef const DIEFFECT_DX5 *LPCDIEFFECT_DX5;
+
+typedef struct DIEFFECT {
+    DWORD dwSize;                   /* sizeof(DIEFFECT)     */
+    DWORD dwFlags;                  /* DIEFF_*              */
+    DWORD dwDuration;               /* Microseconds         */
+    DWORD dwSamplePeriod;           /* Microseconds         */
+    DWORD dwGain;
+    DWORD dwTriggerButton;          /* or DIEB_NOTRIGGER    */
+    DWORD dwTriggerRepeatInterval;  /* Microseconds         */
+    DWORD cAxes;                    /* Number of axes       */
+    LPDWORD rgdwAxes;               /* Array of axes        */
+    LPLONG rglDirection;            /* Array of directions  */
+    LPDIENVELOPE lpEnvelope;        /* Optional             */
+    DWORD cbTypeSpecificParams;     /* Size of params       */
+    LPVOID lpvTypeSpecificParams;   /* Pointer to params    */
+#if(DIRECTINPUT_VERSION >= 0x0600)
+    DWORD  dwStartDelay;            /* Microseconds         */
+#endif /* DIRECTINPUT_VERSION >= 0x0600 */
+} DIEFFECT, *LPDIEFFECT;
+typedef DIEFFECT DIEFFECT_DX6;
+typedef LPDIEFFECT LPDIEFFECT_DX6;
+typedef const DIEFFECT *LPCDIEFFECT;
+
+
+#if(DIRECTINPUT_VERSION >= 0x0700)
+#ifndef DIJ_RINGZERO
+typedef struct DIFILEEFFECT{
+    DWORD       dwSize;
+    GUID        GuidEffect;
+    LPCDIEFFECT lpDiEffect;
+    CHAR        szFriendlyName[MAX_PATH];
+}DIFILEEFFECT, *LPDIFILEEFFECT;
+typedef const DIFILEEFFECT *LPCDIFILEEFFECT;
+typedef BOOL (FAR PASCAL * LPDIENUMEFFECTSINFILECALLBACK)(LPCDIFILEEFFECT , LPVOID);
+#endif /* DIJ_RINGZERO */
+#endif /* DIRECTINPUT_VERSION >= 0x0700 */
+
+#define DIEFF_OBJECTIDS             0x00000001
+#define DIEFF_OBJECTOFFSETS         0x00000002
+#define DIEFF_CARTESIAN             0x00000010
+#define DIEFF_POLAR                 0x00000020
+#define DIEFF_SPHERICAL             0x00000040
+
+#define DIEP_DURATION               0x00000001
+#define DIEP_SAMPLEPERIOD           0x00000002
+#define DIEP_GAIN                   0x00000004
+#define DIEP_TRIGGERBUTTON          0x00000008
+#define DIEP_TRIGGERREPEATINTERVAL  0x00000010
+#define DIEP_AXES                   0x00000020
+#define DIEP_DIRECTION              0x00000040
+#define DIEP_ENVELOPE               0x00000080
+#define DIEP_TYPESPECIFICPARAMS     0x00000100
+#if(DIRECTINPUT_VERSION >= 0x0600)
+#define DIEP_STARTDELAY             0x00000200
+#define DIEP_ALLPARAMS_DX5          0x000001FF
+#define DIEP_ALLPARAMS              0x000003FF
+#else /* DIRECTINPUT_VERSION < 0x0600 */
+#define DIEP_ALLPARAMS              0x000001FF
+#endif /* DIRECTINPUT_VERSION < 0x0600 */
+#define DIEP_START                  0x20000000
+#define DIEP_NORESTART              0x40000000
+#define DIEP_NODOWNLOAD             0x80000000
+#define DIEB_NOTRIGGER              0xFFFFFFFF
+
+#define DIES_SOLO                   0x00000001
+#define DIES_NODOWNLOAD             0x80000000
+
+#define DIEGES_PLAYING              0x00000001
+#define DIEGES_EMULATED             0x00000002
+
+typedef struct DIEFFESCAPE {
+    DWORD   dwSize;
+    DWORD   dwCommand;
+    LPVOID  lpvInBuffer;
+    DWORD   cbInBuffer;
+    LPVOID  lpvOutBuffer;
+    DWORD   cbOutBuffer;
+} DIEFFESCAPE, *LPDIEFFESCAPE;
+
+#ifndef DIJ_RINGZERO
+
+#undef INTERFACE
+#define INTERFACE IDirectInputEffect
+
+DECLARE_INTERFACE_(IDirectInputEffect, IUnknown)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInputEffect methods ***/
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
+    STDMETHOD(GetEffectGuid)(THIS_ LPGUID) PURE;
+    STDMETHOD(GetParameters)(THIS_ LPDIEFFECT,DWORD) PURE;
+    STDMETHOD(SetParameters)(THIS_ LPCDIEFFECT,DWORD) PURE;
+    STDMETHOD(Start)(THIS_ DWORD,DWORD) PURE;
+    STDMETHOD(Stop)(THIS) PURE;
+    STDMETHOD(GetEffectStatus)(THIS_ LPDWORD) PURE;
+    STDMETHOD(Download)(THIS) PURE;
+    STDMETHOD(Unload)(THIS) PURE;
+    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
+};
+
+typedef struct IDirectInputEffect *LPDIRECTINPUTEFFECT;
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectInputEffect_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectInputEffect_AddRef(p) (p)->lpVtbl->AddRef(p)
+#define IDirectInputEffect_Release(p) (p)->lpVtbl->Release(p)
+#define IDirectInputEffect_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
+#define IDirectInputEffect_GetEffectGuid(p,a) (p)->lpVtbl->GetEffectGuid(p,a)
+#define IDirectInputEffect_GetParameters(p,a,b) (p)->lpVtbl->GetParameters(p,a,b)
+#define IDirectInputEffect_SetParameters(p,a,b) (p)->lpVtbl->SetParameters(p,a,b)
+#define IDirectInputEffect_Start(p,a,b) (p)->lpVtbl->Start(p,a,b)
+#define IDirectInputEffect_Stop(p) (p)->lpVtbl->Stop(p)
+#define IDirectInputEffect_GetEffectStatus(p,a) (p)->lpVtbl->GetEffectStatus(p,a)
+#define IDirectInputEffect_Download(p) (p)->lpVtbl->Download(p)
+#define IDirectInputEffect_Unload(p) (p)->lpVtbl->Unload(p)
+#define IDirectInputEffect_Escape(p,a) (p)->lpVtbl->Escape(p,a)
+#else
+#define IDirectInputEffect_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
+#define IDirectInputEffect_AddRef(p) (p)->AddRef()
+#define IDirectInputEffect_Release(p) (p)->Release()
+#define IDirectInputEffect_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
+#define IDirectInputEffect_GetEffectGuid(p,a) (p)->GetEffectGuid(a)
+#define IDirectInputEffect_GetParameters(p,a,b) (p)->GetParameters(a,b)
+#define IDirectInputEffect_SetParameters(p,a,b) (p)->SetParameters(a,b)
+#define IDirectInputEffect_Start(p,a,b) (p)->Start(a,b)
+#define IDirectInputEffect_Stop(p) (p)->Stop()
+#define IDirectInputEffect_GetEffectStatus(p,a) (p)->GetEffectStatus(a)
+#define IDirectInputEffect_Download(p) (p)->Download()
+#define IDirectInputEffect_Unload(p) (p)->Unload()
+#define IDirectInputEffect_Escape(p,a) (p)->Escape(a)
+#endif
+
+#endif /* DIJ_RINGZERO */
+
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+
+/****************************************************************************
+ *
+ *      IDirectInputDevice
+ *
+ ****************************************************************************/
+
+#if DIRECTINPUT_VERSION <= 0x700
+#define DIDEVTYPE_DEVICE        1
+#define DIDEVTYPE_MOUSE         2
+#define DIDEVTYPE_KEYBOARD      3
+#define DIDEVTYPE_JOYSTICK      4
+
+#else
+#define DI8DEVCLASS_ALL             0
+#define DI8DEVCLASS_DEVICE          1
+#define DI8DEVCLASS_POINTER         2
+#define DI8DEVCLASS_KEYBOARD        3
+#define DI8DEVCLASS_GAMECTRL        4
+
+#define DI8DEVTYPE_DEVICE           0x11
+#define DI8DEVTYPE_MOUSE            0x12
+#define DI8DEVTYPE_KEYBOARD         0x13
+#define DI8DEVTYPE_JOYSTICK         0x14
+#define DI8DEVTYPE_GAMEPAD          0x15
+#define DI8DEVTYPE_DRIVING          0x16
+#define DI8DEVTYPE_FLIGHT           0x17
+#define DI8DEVTYPE_1STPERSON        0x18
+#define DI8DEVTYPE_DEVICECTRL       0x19
+#define DI8DEVTYPE_SCREENPOINTER    0x1A
+#define DI8DEVTYPE_REMOTE           0x1B
+#define DI8DEVTYPE_SUPPLEMENTAL     0x1C
+#endif /* DIRECTINPUT_VERSION <= 0x700 */
+
+#define DIDEVTYPE_HID           0x00010000
+
+#if DIRECTINPUT_VERSION <= 0x700
+#define DIDEVTYPEMOUSE_UNKNOWN          1
+#define DIDEVTYPEMOUSE_TRADITIONAL      2
+#define DIDEVTYPEMOUSE_FINGERSTICK      3
+#define DIDEVTYPEMOUSE_TOUCHPAD         4
+#define DIDEVTYPEMOUSE_TRACKBALL        5
+
+#define DIDEVTYPEKEYBOARD_UNKNOWN       0
+#define DIDEVTYPEKEYBOARD_PCXT          1
+#define DIDEVTYPEKEYBOARD_OLIVETTI      2
+#define DIDEVTYPEKEYBOARD_PCAT          3
+#define DIDEVTYPEKEYBOARD_PCENH         4
+#define DIDEVTYPEKEYBOARD_NOKIA1050     5
+#define DIDEVTYPEKEYBOARD_NOKIA9140     6
+#define DIDEVTYPEKEYBOARD_NEC98         7
+#define DIDEVTYPEKEYBOARD_NEC98LAPTOP   8
+#define DIDEVTYPEKEYBOARD_NEC98106      9
+#define DIDEVTYPEKEYBOARD_JAPAN106     10
+#define DIDEVTYPEKEYBOARD_JAPANAX      11
+#define DIDEVTYPEKEYBOARD_J3100        12
+
+#define DIDEVTYPEJOYSTICK_UNKNOWN       1
+#define DIDEVTYPEJOYSTICK_TRADITIONAL   2
+#define DIDEVTYPEJOYSTICK_FLIGHTSTICK   3
+#define DIDEVTYPEJOYSTICK_GAMEPAD       4
+#define DIDEVTYPEJOYSTICK_RUDDER        5
+#define DIDEVTYPEJOYSTICK_WHEEL         6
+#define DIDEVTYPEJOYSTICK_HEADTRACKER   7
+
+#else
+#define DI8DEVTYPEMOUSE_UNKNOWN                     1
+#define DI8DEVTYPEMOUSE_TRADITIONAL                 2
+#define DI8DEVTYPEMOUSE_FINGERSTICK                 3
+#define DI8DEVTYPEMOUSE_TOUCHPAD                    4
+#define DI8DEVTYPEMOUSE_TRACKBALL                   5
+#define DI8DEVTYPEMOUSE_ABSOLUTE                    6
+
+#define DI8DEVTYPEKEYBOARD_UNKNOWN                  0
+#define DI8DEVTYPEKEYBOARD_PCXT                     1
+#define DI8DEVTYPEKEYBOARD_OLIVETTI                 2
+#define DI8DEVTYPEKEYBOARD_PCAT                     3
+#define DI8DEVTYPEKEYBOARD_PCENH                    4
+#define DI8DEVTYPEKEYBOARD_NOKIA1050                5
+#define DI8DEVTYPEKEYBOARD_NOKIA9140                6
+#define DI8DEVTYPEKEYBOARD_NEC98                    7
+#define DI8DEVTYPEKEYBOARD_NEC98LAPTOP              8
+#define DI8DEVTYPEKEYBOARD_NEC98106                 9
+#define DI8DEVTYPEKEYBOARD_JAPAN106                10
+#define DI8DEVTYPEKEYBOARD_JAPANAX                 11
+#define DI8DEVTYPEKEYBOARD_J3100                   12
+
+#define DI8DEVTYPE_LIMITEDGAMESUBTYPE               1
+
+#define DI8DEVTYPEJOYSTICK_LIMITED                  DI8DEVTYPE_LIMITEDGAMESUBTYPE
+#define DI8DEVTYPEJOYSTICK_STANDARD                 2
+
+#define DI8DEVTYPEGAMEPAD_LIMITED                   DI8DEVTYPE_LIMITEDGAMESUBTYPE
+#define DI8DEVTYPEGAMEPAD_STANDARD                  2
+#define DI8DEVTYPEGAMEPAD_TILT                      3
+
+#define DI8DEVTYPEDRIVING_LIMITED                   DI8DEVTYPE_LIMITEDGAMESUBTYPE
+#define DI8DEVTYPEDRIVING_COMBINEDPEDALS            2
+#define DI8DEVTYPEDRIVING_DUALPEDALS                3
+#define DI8DEVTYPEDRIVING_THREEPEDALS               4
+#define DI8DEVTYPEDRIVING_HANDHELD                  5
+
+#define DI8DEVTYPEFLIGHT_LIMITED                    DI8DEVTYPE_LIMITEDGAMESUBTYPE
+#define DI8DEVTYPEFLIGHT_STICK                      2
+#define DI8DEVTYPEFLIGHT_YOKE                       3
+#define DI8DEVTYPEFLIGHT_RC                         4
+
+#define DI8DEVTYPE1STPERSON_LIMITED                 DI8DEVTYPE_LIMITEDGAMESUBTYPE
+#define DI8DEVTYPE1STPERSON_UNKNOWN                 2
+#define DI8DEVTYPE1STPERSON_SIXDOF                  3
+#define DI8DEVTYPE1STPERSON_SHOOTER                 4
+
+#define DI8DEVTYPESCREENPTR_UNKNOWN                 2
+#define DI8DEVTYPESCREENPTR_LIGHTGUN                3
+#define DI8DEVTYPESCREENPTR_LIGHTPEN                4
+#define DI8DEVTYPESCREENPTR_TOUCH                   5
+
+#define DI8DEVTYPEREMOTE_UNKNOWN                    2
+
+#define DI8DEVTYPEDEVICECTRL_UNKNOWN                2
+#define DI8DEVTYPEDEVICECTRL_COMMSSELECTION         3
+#define DI8DEVTYPEDEVICECTRL_COMMSSELECTION_HARDWIRED 4
+
+#define DI8DEVTYPESUPPLEMENTAL_UNKNOWN              2
+#define DI8DEVTYPESUPPLEMENTAL_2NDHANDCONTROLLER    3
+#define DI8DEVTYPESUPPLEMENTAL_HEADTRACKER          4
+#define DI8DEVTYPESUPPLEMENTAL_HANDTRACKER          5
+#define DI8DEVTYPESUPPLEMENTAL_SHIFTSTICKGATE       6
+#define DI8DEVTYPESUPPLEMENTAL_SHIFTER              7
+#define DI8DEVTYPESUPPLEMENTAL_THROTTLE             8
+#define DI8DEVTYPESUPPLEMENTAL_SPLITTHROTTLE        9
+#define DI8DEVTYPESUPPLEMENTAL_COMBINEDPEDALS      10
+#define DI8DEVTYPESUPPLEMENTAL_DUALPEDALS          11
+#define DI8DEVTYPESUPPLEMENTAL_THREEPEDALS         12
+#define DI8DEVTYPESUPPLEMENTAL_RUDDERPEDALS        13
+#endif /* DIRECTINPUT_VERSION <= 0x700 */
+
+#define GET_DIDEVICE_TYPE(dwDevType)    LOBYTE(dwDevType)
+#define GET_DIDEVICE_SUBTYPE(dwDevType) HIBYTE(dwDevType)
+
+#if(DIRECTINPUT_VERSION >= 0x0500)
+/* This structure is defined for DirectX 3.0 compatibility */
+typedef struct DIDEVCAPS_DX3 {
+    DWORD   dwSize;
+    DWORD   dwFlags;
+    DWORD   dwDevType;
+    DWORD   dwAxes;
+    DWORD   dwButtons;
+    DWORD   dwPOVs;
+} DIDEVCAPS_DX3, *LPDIDEVCAPS_DX3;
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+
+typedef struct DIDEVCAPS {
+    DWORD   dwSize;
+    DWORD   dwFlags;
+    DWORD   dwDevType;
+    DWORD   dwAxes;
+    DWORD   dwButtons;
+    DWORD   dwPOVs;
+#if(DIRECTINPUT_VERSION >= 0x0500)
+    DWORD   dwFFSamplePeriod;
+    DWORD   dwFFMinTimeResolution;
+    DWORD   dwFirmwareRevision;
+    DWORD   dwHardwareRevision;
+    DWORD   dwFFDriverVersion;
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+} DIDEVCAPS, *LPDIDEVCAPS;
+
+#define DIDC_ATTACHED           0x00000001
+#define DIDC_POLLEDDEVICE       0x00000002
+#define DIDC_EMULATED           0x00000004
+#define DIDC_POLLEDDATAFORMAT   0x00000008
+#if(DIRECTINPUT_VERSION >= 0x0500)
+#define DIDC_FORCEFEEDBACK      0x00000100
+#define DIDC_FFATTACK           0x00000200
+#define DIDC_FFFADE             0x00000400
+#define DIDC_SATURATION         0x00000800
+#define DIDC_POSNEGCOEFFICIENTS 0x00001000
+#define DIDC_POSNEGSATURATION   0x00002000
+#define DIDC_DEADBAND           0x00004000
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+#define DIDC_STARTDELAY         0x00008000
+#if(DIRECTINPUT_VERSION >= 0x050a)
+#define DIDC_ALIAS              0x00010000
+#define DIDC_PHANTOM            0x00020000
+#endif /* DIRECTINPUT_VERSION >= 0x050a */
+#if(DIRECTINPUT_VERSION >= 0x0800)
+#define DIDC_HIDDEN             0x00040000
+#endif /* DIRECTINPUT_VERSION >= 0x0800 */
+
+#define DIDFT_ALL           0x00000000
+
+#define DIDFT_RELAXIS       0x00000001
+#define DIDFT_ABSAXIS       0x00000002
+#define DIDFT_AXIS          0x00000003
+
+#define DIDFT_PSHBUTTON     0x00000004
+#define DIDFT_TGLBUTTON     0x00000008
+#define DIDFT_BUTTON        0x0000000C
+
+#define DIDFT_POV           0x00000010
+#define DIDFT_COLLECTION    0x00000040
+#define DIDFT_NODATA        0x00000080
+
+#define DIDFT_ANYINSTANCE   0x00FFFF00
+#define DIDFT_INSTANCEMASK  DIDFT_ANYINSTANCE
+#define DIDFT_MAKEINSTANCE(n) ((WORD)(n) << 8)
+#define DIDFT_GETTYPE(n)     LOBYTE(n)
+#define DIDFT_GETINSTANCE(n) LOWORD((n) >> 8)
+#define DIDFT_FFACTUATOR        0x01000000
+#define DIDFT_FFEFFECTTRIGGER   0x02000000
+#if(DIRECTINPUT_VERSION >= 0x050a)
+#define DIDFT_OUTPUT            0x10000000
+#define DIDFT_VENDORDEFINED     0x04000000
+#define DIDFT_ALIAS             0x08000000
+#endif /* DIRECTINPUT_VERSION >= 0x050a */
+#ifndef DIDFT_OPTIONAL
+#define DIDFT_OPTIONAL          0x80000000
+#endif
+
+#define DIDFT_ENUMCOLLECTION(n) ((WORD)(n) << 8)
+#define DIDFT_NOCOLLECTION      0x00FFFF00
+
+#ifndef DIJ_RINGZERO
+
+typedef struct _DIOBJECTDATAFORMAT {
+    const GUID *pguid;
+    DWORD   dwOfs;
+    DWORD   dwType;
+    DWORD   dwFlags;
+} DIOBJECTDATAFORMAT, *LPDIOBJECTDATAFORMAT;
+typedef const DIOBJECTDATAFORMAT *LPCDIOBJECTDATAFORMAT;
+
+typedef struct _DIDATAFORMAT {
+    DWORD   dwSize;
+    DWORD   dwObjSize;
+    DWORD   dwFlags;
+    DWORD   dwDataSize;
+    DWORD   dwNumObjs;
+    LPDIOBJECTDATAFORMAT rgodf;
+} DIDATAFORMAT, *LPDIDATAFORMAT;
+typedef const DIDATAFORMAT *LPCDIDATAFORMAT;
+
+#define DIDF_ABSAXIS            0x00000001
+#define DIDF_RELAXIS            0x00000002
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+extern const DIDATAFORMAT c_dfDIMouse;
+
+#if(DIRECTINPUT_VERSION >= 0x0700)
+extern const DIDATAFORMAT c_dfDIMouse2;
+#endif /* DIRECTINPUT_VERSION >= 0x0700 */
+
+extern const DIDATAFORMAT c_dfDIKeyboard;
+
+#if(DIRECTINPUT_VERSION >= 0x0500)
+extern const DIDATAFORMAT c_dfDIJoystick;
+extern const DIDATAFORMAT c_dfDIJoystick2;
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+
+#ifdef __cplusplus
+};
+#endif
+
+
+#if DIRECTINPUT_VERSION > 0x0700
+
+typedef struct _DIACTIONA {
+                UINT_PTR    uAppData;
+                DWORD       dwSemantic;
+    OPTIONAL    DWORD       dwFlags;
+    OPTIONAL    union {
+                    LPCSTR      lptszActionName;
+                    UINT        uResIdString;
+                };
+    OPTIONAL    GUID        guidInstance;
+    OPTIONAL    DWORD       dwObjID;
+    OPTIONAL    DWORD       dwHow;
+} DIACTIONA, *LPDIACTIONA ;
+typedef struct _DIACTIONW {
+                UINT_PTR    uAppData;
+                DWORD       dwSemantic;
+    OPTIONAL    DWORD       dwFlags;
+    OPTIONAL    union {
+                    LPCWSTR     lptszActionName;
+                    UINT        uResIdString;
+                };
+    OPTIONAL    GUID        guidInstance;
+    OPTIONAL    DWORD       dwObjID;
+    OPTIONAL    DWORD       dwHow;
+} DIACTIONW, *LPDIACTIONW ;
+#ifdef UNICODE
+typedef DIACTIONW DIACTION;
+typedef LPDIACTIONW LPDIACTION;
+#else
+typedef DIACTIONA DIACTION;
+typedef LPDIACTIONA LPDIACTION;
+#endif // UNICODE
+
+typedef const DIACTIONA *LPCDIACTIONA;
+typedef const DIACTIONW *LPCDIACTIONW;
+#ifdef UNICODE
+typedef DIACTIONW DIACTION;
+typedef LPCDIACTIONW LPCDIACTION;
+#else
+typedef DIACTIONA DIACTION;
+typedef LPCDIACTIONA LPCDIACTION;
+#endif // UNICODE
+typedef const DIACTION *LPCDIACTION;
+
+
+#define DIA_FORCEFEEDBACK       0x00000001
+#define DIA_APPMAPPED           0x00000002
+#define DIA_APPNOMAP            0x00000004
+#define DIA_NORANGE             0x00000008
+#define DIA_APPFIXED            0x00000010
+
+#define DIAH_UNMAPPED           0x00000000
+#define DIAH_USERCONFIG         0x00000001
+#define DIAH_APPREQUESTED       0x00000002
+#define DIAH_HWAPP              0x00000004
+#define DIAH_HWDEFAULT          0x00000008
+#define DIAH_DEFAULT            0x00000020
+#define DIAH_ERROR              0x80000000
+
+typedef struct _DIACTIONFORMATA {
+                DWORD       dwSize;
+                DWORD       dwActionSize;
+                DWORD       dwDataSize;
+                DWORD       dwNumActions;
+                LPDIACTIONA rgoAction;
+                GUID        guidActionMap;
+                DWORD       dwGenre;
+                DWORD       dwBufferSize;
+    OPTIONAL    LONG        lAxisMin;
+    OPTIONAL    LONG        lAxisMax;
+    OPTIONAL    HINSTANCE   hInstString;
+                FILETIME    ftTimeStamp;
+                DWORD       dwCRC;
+                CHAR        tszActionMap[MAX_PATH];
+} DIACTIONFORMATA, *LPDIACTIONFORMATA;
+typedef struct _DIACTIONFORMATW {
+                DWORD       dwSize;
+                DWORD       dwActionSize;
+                DWORD       dwDataSize;
+                DWORD       dwNumActions;
+                LPDIACTIONW rgoAction;
+                GUID        guidActionMap;
+                DWORD       dwGenre;
+                DWORD       dwBufferSize;
+    OPTIONAL    LONG        lAxisMin;
+    OPTIONAL    LONG        lAxisMax;
+    OPTIONAL    HINSTANCE   hInstString;
+                FILETIME    ftTimeStamp;
+                DWORD       dwCRC;
+                WCHAR       tszActionMap[MAX_PATH];
+} DIACTIONFORMATW, *LPDIACTIONFORMATW;
+#ifdef UNICODE
+typedef DIACTIONFORMATW DIACTIONFORMAT;
+typedef LPDIACTIONFORMATW LPDIACTIONFORMAT;
+#else
+typedef DIACTIONFORMATA DIACTIONFORMAT;
+typedef LPDIACTIONFORMATA LPDIACTIONFORMAT;
+#endif // UNICODE
+typedef const DIACTIONFORMATA *LPCDIACTIONFORMATA;
+typedef const DIACTIONFORMATW *LPCDIACTIONFORMATW;
+#ifdef UNICODE
+typedef DIACTIONFORMATW DIACTIONFORMAT;
+typedef LPCDIACTIONFORMATW LPCDIACTIONFORMAT;
+#else
+typedef DIACTIONFORMATA DIACTIONFORMAT;
+typedef LPCDIACTIONFORMATA LPCDIACTIONFORMAT;
+#endif // UNICODE
+typedef const DIACTIONFORMAT *LPCDIACTIONFORMAT;
+
+#define DIAFTS_NEWDEVICELOW     0xFFFFFFFF
+#define DIAFTS_NEWDEVICEHIGH    0xFFFFFFFF
+#define DIAFTS_UNUSEDDEVICELOW  0x00000000
+#define DIAFTS_UNUSEDDEVICEHIGH 0x00000000
+
+#define DIDBAM_DEFAULT          0x00000000
+#define DIDBAM_PRESERVE         0x00000001
+#define DIDBAM_INITIALIZE       0x00000002
+#define DIDBAM_HWDEFAULTS       0x00000004
+
+#define DIDSAM_DEFAULT          0x00000000
+#define DIDSAM_NOUSER           0x00000001
+#define DIDSAM_FORCESAVE        0x00000002
+
+#define DICD_DEFAULT            0x00000000
+#define DICD_EDIT               0x00000001
+
+/*
+ * The following definition is normally defined in d3dtypes.h
+ */
+#ifndef D3DCOLOR_DEFINED
+typedef DWORD D3DCOLOR;
+#define D3DCOLOR_DEFINED
+#endif
+
+typedef struct _DICOLORSET{
+    DWORD dwSize;
+    D3DCOLOR cTextFore;
+    D3DCOLOR cTextHighlight;
+    D3DCOLOR cCalloutLine;
+    D3DCOLOR cCalloutHighlight;
+    D3DCOLOR cBorder;
+    D3DCOLOR cControlFill;
+    D3DCOLOR cHighlightFill;
+    D3DCOLOR cAreaFill;
+} DICOLORSET, *LPDICOLORSET;
+typedef const DICOLORSET *LPCDICOLORSET;
+
+
+typedef struct _DICONFIGUREDEVICESPARAMSA{
+     DWORD             dwSize;
+     DWORD             dwcUsers;
+     LPSTR             lptszUserNames;
+     DWORD             dwcFormats;
+     LPDIACTIONFORMATA lprgFormats;
+     HWND              hwnd;
+     DICOLORSET        dics;
+     IUnknown FAR *    lpUnkDDSTarget;
+} DICONFIGUREDEVICESPARAMSA, *LPDICONFIGUREDEVICESPARAMSA;
+typedef struct _DICONFIGUREDEVICESPARAMSW{
+     DWORD             dwSize;
+     DWORD             dwcUsers;
+     LPWSTR            lptszUserNames;
+     DWORD             dwcFormats;
+     LPDIACTIONFORMATW lprgFormats;
+     HWND              hwnd;
+     DICOLORSET        dics;
+     IUnknown FAR *    lpUnkDDSTarget;
+} DICONFIGUREDEVICESPARAMSW, *LPDICONFIGUREDEVICESPARAMSW;
+#ifdef UNICODE
+typedef DICONFIGUREDEVICESPARAMSW DICONFIGUREDEVICESPARAMS;
+typedef LPDICONFIGUREDEVICESPARAMSW LPDICONFIGUREDEVICESPARAMS;
+#else
+typedef DICONFIGUREDEVICESPARAMSA DICONFIGUREDEVICESPARAMS;
+typedef LPDICONFIGUREDEVICESPARAMSA LPDICONFIGUREDEVICESPARAMS;
+#endif // UNICODE
+typedef const DICONFIGUREDEVICESPARAMSA *LPCDICONFIGUREDEVICESPARAMSA;
+typedef const DICONFIGUREDEVICESPARAMSW *LPCDICONFIGUREDEVICESPARAMSW;
+#ifdef UNICODE
+typedef DICONFIGUREDEVICESPARAMSW DICONFIGUREDEVICESPARAMS;
+typedef LPCDICONFIGUREDEVICESPARAMSW LPCDICONFIGUREDEVICESPARAMS;
+#else
+typedef DICONFIGUREDEVICESPARAMSA DICONFIGUREDEVICESPARAMS;
+typedef LPCDICONFIGUREDEVICESPARAMSA LPCDICONFIGUREDEVICESPARAMS;
+#endif // UNICODE
+typedef const DICONFIGUREDEVICESPARAMS *LPCDICONFIGUREDEVICESPARAMS;
+
+
+#define DIDIFT_CONFIGURATION    0x00000001
+#define DIDIFT_OVERLAY          0x00000002
+
+#define DIDAL_CENTERED      0x00000000
+#define DIDAL_LEFTALIGNED   0x00000001
+#define DIDAL_RIGHTALIGNED  0x00000002
+#define DIDAL_MIDDLE        0x00000000
+#define DIDAL_TOPALIGNED    0x00000004
+#define DIDAL_BOTTOMALIGNED 0x00000008
+
+typedef struct _DIDEVICEIMAGEINFOA {
+    CHAR        tszImagePath[MAX_PATH];
+    DWORD       dwFlags; 
+    // These are valid if DIDIFT_OVERLAY is present in dwFlags.
+    DWORD       dwViewID;      
+    RECT        rcOverlay;             
+    DWORD       dwObjID;
+    DWORD       dwcValidPts;
+    POINT       rgptCalloutLine[5];  
+    RECT        rcCalloutRect;  
+    DWORD       dwTextAlign;     
+} DIDEVICEIMAGEINFOA, *LPDIDEVICEIMAGEINFOA;
+typedef struct _DIDEVICEIMAGEINFOW {
+    WCHAR       tszImagePath[MAX_PATH];
+    DWORD       dwFlags; 
+    // These are valid if DIDIFT_OVERLAY is present in dwFlags.
+    DWORD       dwViewID;      
+    RECT        rcOverlay;             
+    DWORD       dwObjID;
+    DWORD       dwcValidPts;
+    POINT       rgptCalloutLine[5];  
+    RECT        rcCalloutRect;  
+    DWORD       dwTextAlign;     
+} DIDEVICEIMAGEINFOW, *LPDIDEVICEIMAGEINFOW;
+#ifdef UNICODE
+typedef DIDEVICEIMAGEINFOW DIDEVICEIMAGEINFO;
+typedef LPDIDEVICEIMAGEINFOW LPDIDEVICEIMAGEINFO;
+#else
+typedef DIDEVICEIMAGEINFOA DIDEVICEIMAGEINFO;
+typedef LPDIDEVICEIMAGEINFOA LPDIDEVICEIMAGEINFO;
+#endif // UNICODE
+typedef const DIDEVICEIMAGEINFOA *LPCDIDEVICEIMAGEINFOA;
+typedef const DIDEVICEIMAGEINFOW *LPCDIDEVICEIMAGEINFOW;
+#ifdef UNICODE
+typedef DIDEVICEIMAGEINFOW DIDEVICEIMAGEINFO;
+typedef LPCDIDEVICEIMAGEINFOW LPCDIDEVICEIMAGEINFO;
+#else
+typedef DIDEVICEIMAGEINFOA DIDEVICEIMAGEINFO;
+typedef LPCDIDEVICEIMAGEINFOA LPCDIDEVICEIMAGEINFO;
+#endif // UNICODE
+typedef const DIDEVICEIMAGEINFO *LPCDIDEVICEIMAGEINFO;
+
+typedef struct _DIDEVICEIMAGEINFOHEADERA {
+    DWORD       dwSize;
+    DWORD       dwSizeImageInfo;
+    DWORD       dwcViews;
+    DWORD       dwcButtons;
+    DWORD       dwcAxes;
+    DWORD       dwcPOVs;
+    DWORD       dwBufferSize;
+    DWORD       dwBufferUsed;
+    LPDIDEVICEIMAGEINFOA lprgImageInfoArray;
+} DIDEVICEIMAGEINFOHEADERA, *LPDIDEVICEIMAGEINFOHEADERA;
+typedef struct _DIDEVICEIMAGEINFOHEADERW {
+    DWORD       dwSize;
+    DWORD       dwSizeImageInfo;
+    DWORD       dwcViews;
+    DWORD       dwcButtons;
+    DWORD       dwcAxes;
+    DWORD       dwcPOVs;
+    DWORD       dwBufferSize;
+    DWORD       dwBufferUsed;
+    LPDIDEVICEIMAGEINFOW lprgImageInfoArray;
+} DIDEVICEIMAGEINFOHEADERW, *LPDIDEVICEIMAGEINFOHEADERW;
+#ifdef UNICODE
+typedef DIDEVICEIMAGEINFOHEADERW DIDEVICEIMAGEINFOHEADER;
+typedef LPDIDEVICEIMAGEINFOHEADERW LPDIDEVICEIMAGEINFOHEADER;
+#else
+typedef DIDEVICEIMAGEINFOHEADERA DIDEVICEIMAGEINFOHEADER;
+typedef LPDIDEVICEIMAGEINFOHEADERA LPDIDEVICEIMAGEINFOHEADER;
+#endif // UNICODE
+typedef const DIDEVICEIMAGEINFOHEADERA *LPCDIDEVICEIMAGEINFOHEADERA;
+typedef const DIDEVICEIMAGEINFOHEADERW *LPCDIDEVICEIMAGEINFOHEADERW;
+#ifdef UNICODE
+typedef DIDEVICEIMAGEINFOHEADERW DIDEVICEIMAGEINFOHEADER;
+typedef LPCDIDEVICEIMAGEINFOHEADERW LPCDIDEVICEIMAGEINFOHEADER;
+#else
+typedef DIDEVICEIMAGEINFOHEADERA DIDEVICEIMAGEINFOHEADER;
+typedef LPCDIDEVICEIMAGEINFOHEADERA LPCDIDEVICEIMAGEINFOHEADER;
+#endif // UNICODE
+typedef const DIDEVICEIMAGEINFOHEADER *LPCDIDEVICEIMAGEINFOHEADER;
+
+#endif /* DIRECTINPUT_VERSION > 0x0700 */
+
+#if(DIRECTINPUT_VERSION >= 0x0500)
+/* These structures are defined for DirectX 3.0 compatibility */
+
+typedef struct DIDEVICEOBJECTINSTANCE_DX3A {
+    DWORD   dwSize;
+    GUID    guidType;
+    DWORD   dwOfs;
+    DWORD   dwType;
+    DWORD   dwFlags;
+    CHAR    tszName[MAX_PATH];
+} DIDEVICEOBJECTINSTANCE_DX3A, *LPDIDEVICEOBJECTINSTANCE_DX3A;
+typedef struct DIDEVICEOBJECTINSTANCE_DX3W {
+    DWORD   dwSize;
+    GUID    guidType;
+    DWORD   dwOfs;
+    DWORD   dwType;
+    DWORD   dwFlags;
+    WCHAR   tszName[MAX_PATH];
+} DIDEVICEOBJECTINSTANCE_DX3W, *LPDIDEVICEOBJECTINSTANCE_DX3W;
+#ifdef UNICODE
+typedef DIDEVICEOBJECTINSTANCE_DX3W DIDEVICEOBJECTINSTANCE_DX3;
+typedef LPDIDEVICEOBJECTINSTANCE_DX3W LPDIDEVICEOBJECTINSTANCE_DX3;
+#else
+typedef DIDEVICEOBJECTINSTANCE_DX3A DIDEVICEOBJECTINSTANCE_DX3;
+typedef LPDIDEVICEOBJECTINSTANCE_DX3A LPDIDEVICEOBJECTINSTANCE_DX3;
+#endif // UNICODE
+typedef const DIDEVICEOBJECTINSTANCE_DX3A *LPCDIDEVICEOBJECTINSTANCE_DX3A;
+typedef const DIDEVICEOBJECTINSTANCE_DX3W *LPCDIDEVICEOBJECTINSTANCE_DX3W;
+typedef const DIDEVICEOBJECTINSTANCE_DX3  *LPCDIDEVICEOBJECTINSTANCE_DX3;
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+
+typedef struct DIDEVICEOBJECTINSTANCEA {
+    DWORD   dwSize;
+    GUID    guidType;
+    DWORD   dwOfs;
+    DWORD   dwType;
+    DWORD   dwFlags;
+    CHAR    tszName[MAX_PATH];
+#if(DIRECTINPUT_VERSION >= 0x0500)
+    DWORD   dwFFMaxForce;
+    DWORD   dwFFForceResolution;
+    WORD    wCollectionNumber;
+    WORD    wDesignatorIndex;
+    WORD    wUsagePage;
+    WORD    wUsage;
+    DWORD   dwDimension;
+    WORD    wExponent;
+    WORD    wReportId;
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+} DIDEVICEOBJECTINSTANCEA, *LPDIDEVICEOBJECTINSTANCEA;
+typedef struct DIDEVICEOBJECTINSTANCEW {
+    DWORD   dwSize;
+    GUID    guidType;
+    DWORD   dwOfs;
+    DWORD   dwType;
+    DWORD   dwFlags;
+    WCHAR   tszName[MAX_PATH];
+#if(DIRECTINPUT_VERSION >= 0x0500)
+    DWORD   dwFFMaxForce;
+    DWORD   dwFFForceResolution;
+    WORD    wCollectionNumber;
+    WORD    wDesignatorIndex;
+    WORD    wUsagePage;
+    WORD    wUsage;
+    DWORD   dwDimension;
+    WORD    wExponent;
+    WORD    wReportId;
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+} DIDEVICEOBJECTINSTANCEW, *LPDIDEVICEOBJECTINSTANCEW;
+#ifdef UNICODE
+typedef DIDEVICEOBJECTINSTANCEW DIDEVICEOBJECTINSTANCE;
+typedef LPDIDEVICEOBJECTINSTANCEW LPDIDEVICEOBJECTINSTANCE;
+#else
+typedef DIDEVICEOBJECTINSTANCEA DIDEVICEOBJECTINSTANCE;
+typedef LPDIDEVICEOBJECTINSTANCEA LPDIDEVICEOBJECTINSTANCE;
+#endif // UNICODE
+typedef const DIDEVICEOBJECTINSTANCEA *LPCDIDEVICEOBJECTINSTANCEA;
+typedef const DIDEVICEOBJECTINSTANCEW *LPCDIDEVICEOBJECTINSTANCEW;
+typedef const DIDEVICEOBJECTINSTANCE  *LPCDIDEVICEOBJECTINSTANCE;
+
+typedef BOOL (FAR PASCAL * LPDIENUMDEVICEOBJECTSCALLBACKA)(LPCDIDEVICEOBJECTINSTANCEA, LPVOID);
+typedef BOOL (FAR PASCAL * LPDIENUMDEVICEOBJECTSCALLBACKW)(LPCDIDEVICEOBJECTINSTANCEW, LPVOID);
+#ifdef UNICODE
+#define LPDIENUMDEVICEOBJECTSCALLBACK  LPDIENUMDEVICEOBJECTSCALLBACKW
+#else
+#define LPDIENUMDEVICEOBJECTSCALLBACK  LPDIENUMDEVICEOBJECTSCALLBACKA
+#endif // !UNICODE
+
+#if(DIRECTINPUT_VERSION >= 0x0500)
+#define DIDOI_FFACTUATOR        0x00000001
+#define DIDOI_FFEFFECTTRIGGER   0x00000002
+#define DIDOI_POLLED            0x00008000
+#define DIDOI_ASPECTPOSITION    0x00000100
+#define DIDOI_ASPECTVELOCITY    0x00000200
+#define DIDOI_ASPECTACCEL       0x00000300
+#define DIDOI_ASPECTFORCE       0x00000400
+#define DIDOI_ASPECTMASK        0x00000F00
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+#if(DIRECTINPUT_VERSION >= 0x050a)
+#define DIDOI_GUIDISUSAGE       0x00010000
+#endif /* DIRECTINPUT_VERSION >= 0x050a */
+
+typedef struct DIPROPHEADER {
+    DWORD   dwSize;
+    DWORD   dwHeaderSize;
+    DWORD   dwObj;
+    DWORD   dwHow;
+} DIPROPHEADER, *LPDIPROPHEADER;
+typedef const DIPROPHEADER *LPCDIPROPHEADER;
+
+#define DIPH_DEVICE             0
+#define DIPH_BYOFFSET           1
+#define DIPH_BYID               2
+#if(DIRECTINPUT_VERSION >= 0x050a)
+#define DIPH_BYUSAGE            3
+#endif /* DIRECTINPUT_VERSION >= 0x050a */
+
+#if(DIRECTINPUT_VERSION >= 0x050a)
+#define DIMAKEUSAGEDWORD(UsagePage, Usage) \
+                                (DWORD)MAKELONG(Usage, UsagePage)
+#endif /* DIRECTINPUT_VERSION >= 0x050a */
+
+typedef struct DIPROPDWORD {
+    DIPROPHEADER diph;
+    DWORD   dwData;
+} DIPROPDWORD, *LPDIPROPDWORD;
+typedef const DIPROPDWORD *LPCDIPROPDWORD;
+
+#if(DIRECTINPUT_VERSION >= 0x0800)
+typedef struct DIPROPPOINTER {
+    DIPROPHEADER diph;
+    UINT_PTR uData;
+} DIPROPPOINTER, *LPDIPROPPOINTER;
+typedef const DIPROPPOINTER *LPCDIPROPPOINTER;
+#endif /* DIRECTINPUT_VERSION >= 0x0800 */
+
+typedef struct DIPROPRANGE {
+    DIPROPHEADER diph;
+    LONG    lMin;
+    LONG    lMax;
+} DIPROPRANGE, *LPDIPROPRANGE;
+typedef const DIPROPRANGE *LPCDIPROPRANGE;
+
+#define DIPROPRANGE_NOMIN       ((LONG)0x80000000)
+#define DIPROPRANGE_NOMAX       ((LONG)0x7FFFFFFF)
+
+#if(DIRECTINPUT_VERSION >= 0x050a)
+typedef struct DIPROPCAL {
+    DIPROPHEADER diph;
+    LONG    lMin;
+    LONG    lCenter;
+    LONG    lMax;
+} DIPROPCAL, *LPDIPROPCAL;
+typedef const DIPROPCAL *LPCDIPROPCAL;
+
+typedef struct DIPROPCALPOV {
+    DIPROPHEADER diph;
+    LONG   lMin[5];
+    LONG   lMax[5];
+} DIPROPCALPOV, *LPDIPROPCALPOV;
+typedef const DIPROPCALPOV *LPCDIPROPCALPOV;
+
+typedef struct DIPROPGUIDANDPATH {
+    DIPROPHEADER diph;
+    GUID    guidClass;
+    WCHAR   wszPath[MAX_PATH];
+} DIPROPGUIDANDPATH, *LPDIPROPGUIDANDPATH;
+typedef const DIPROPGUIDANDPATH *LPCDIPROPGUIDANDPATH;
+
+typedef struct DIPROPSTRING {
+    DIPROPHEADER diph;
+    WCHAR   wsz[MAX_PATH];
+} DIPROPSTRING, *LPDIPROPSTRING;
+typedef const DIPROPSTRING *LPCDIPROPSTRING;
+
+#endif /* DIRECTINPUT_VERSION >= 0x050a */
+
+#if(DIRECTINPUT_VERSION >= 0x0800)
+#define MAXCPOINTSNUM          8
+
+typedef struct _CPOINT
+{
+    LONG  lP;     // raw value
+    DWORD dwLog;  // logical_value / max_logical_value * 10000
+} CPOINT, *PCPOINT;
+
+typedef struct DIPROPCPOINTS {
+    DIPROPHEADER diph;
+    DWORD  dwCPointsNum;
+    CPOINT cp[MAXCPOINTSNUM];
+} DIPROPCPOINTS, *LPDIPROPCPOINTS;
+typedef const DIPROPCPOINTS *LPCDIPROPCPOINTS;
+#endif /* DIRECTINPUT_VERSION >= 0x0800 */
+
+
+#ifdef __cplusplus
+#define MAKEDIPROP(prop)    (*(const GUID *)(prop))
+#else
+#define MAKEDIPROP(prop)    ((REFGUID)(prop))
+#endif
+
+#define DIPROP_BUFFERSIZE       MAKEDIPROP(1)
+
+#define DIPROP_AXISMODE         MAKEDIPROP(2)
+
+#define DIPROPAXISMODE_ABS      0
+#define DIPROPAXISMODE_REL      1
+
+#define DIPROP_GRANULARITY      MAKEDIPROP(3)
+
+#define DIPROP_RANGE            MAKEDIPROP(4)
+
+#define DIPROP_DEADZONE         MAKEDIPROP(5)
+
+#define DIPROP_SATURATION       MAKEDIPROP(6)
+
+#define DIPROP_FFGAIN           MAKEDIPROP(7)
+
+#define DIPROP_FFLOAD           MAKEDIPROP(8)
+
+#define DIPROP_AUTOCENTER       MAKEDIPROP(9)
+
+#define DIPROPAUTOCENTER_OFF    0
+#define DIPROPAUTOCENTER_ON     1
+
+#define DIPROP_CALIBRATIONMODE  MAKEDIPROP(10)
+
+#define DIPROPCALIBRATIONMODE_COOKED    0
+#define DIPROPCALIBRATIONMODE_RAW       1
+
+#if(DIRECTINPUT_VERSION >= 0x050a)
+#define DIPROP_CALIBRATION      MAKEDIPROP(11)
+
+#define DIPROP_GUIDANDPATH      MAKEDIPROP(12)
+
+#define DIPROP_INSTANCENAME     MAKEDIPROP(13)
+
+#define DIPROP_PRODUCTNAME      MAKEDIPROP(14)
+#endif /* DIRECTINPUT_VERSION >= 0x050a */
+
+#if(DIRECTINPUT_VERSION >= 0x05b2)
+#define DIPROP_JOYSTICKID       MAKEDIPROP(15)
+
+#define DIPROP_GETPORTDISPLAYNAME       MAKEDIPROP(16)
+
+#endif /* DIRECTINPUT_VERSION >= 0x05b2 */
+
+#if(DIRECTINPUT_VERSION >= 0x0700)
+#define DIPROP_PHYSICALRANGE            MAKEDIPROP(18)
+
+#define DIPROP_LOGICALRANGE             MAKEDIPROP(19)
+#endif /* DIRECTINPUT_VERSION >= 0x0700 */
+
+#if(DIRECTINPUT_VERSION >= 0x0800)
+#define DIPROP_KEYNAME                     MAKEDIPROP(20)
+
+#define DIPROP_CPOINTS                 MAKEDIPROP(21)
+
+#define DIPROP_APPDATA       MAKEDIPROP(22)
+
+#define DIPROP_SCANCODE      MAKEDIPROP(23)
+
+#define DIPROP_VIDPID           MAKEDIPROP(24)
+
+#define DIPROP_USERNAME         MAKEDIPROP(25)
+
+#define DIPROP_TYPENAME         MAKEDIPROP(26)
+#endif /* DIRECTINPUT_VERSION >= 0x0800 */
+
+
+typedef struct DIDEVICEOBJECTDATA_DX3 {
+    DWORD       dwOfs;
+    DWORD       dwData;
+    DWORD       dwTimeStamp;
+    DWORD       dwSequence;
+} DIDEVICEOBJECTDATA_DX3, *LPDIDEVICEOBJECTDATA_DX3;
+typedef const DIDEVICEOBJECTDATA_DX3 *LPCDIDEVICEOBJECTDATA_DX;
+
+typedef struct DIDEVICEOBJECTDATA {
+    DWORD       dwOfs;
+    DWORD       dwData;
+    DWORD       dwTimeStamp;
+    DWORD       dwSequence;
+#if(DIRECTINPUT_VERSION >= 0x0800)
+    UINT_PTR    uAppData;
+#endif /* DIRECTINPUT_VERSION >= 0x0800 */
+} DIDEVICEOBJECTDATA, *LPDIDEVICEOBJECTDATA;
+typedef const DIDEVICEOBJECTDATA *LPCDIDEVICEOBJECTDATA;
+
+#define DIGDD_PEEK          0x00000001
+
+#define DISEQUENCE_COMPARE(dwSequence1, cmp, dwSequence2) \
+                        ((int)((dwSequence1) - (dwSequence2)) cmp 0)
+#define DISCL_EXCLUSIVE     0x00000001
+#define DISCL_NONEXCLUSIVE  0x00000002
+#define DISCL_FOREGROUND    0x00000004
+#define DISCL_BACKGROUND    0x00000008
+#define DISCL_NOWINKEY      0x00000010
+
+#if(DIRECTINPUT_VERSION >= 0x0500)
+/* These structures are defined for DirectX 3.0 compatibility */
+
+typedef struct DIDEVICEINSTANCE_DX3A {
+    DWORD   dwSize;
+    GUID    guidInstance;
+    GUID    guidProduct;
+    DWORD   dwDevType;
+    CHAR    tszInstanceName[MAX_PATH];
+    CHAR    tszProductName[MAX_PATH];
+} DIDEVICEINSTANCE_DX3A, *LPDIDEVICEINSTANCE_DX3A;
+typedef struct DIDEVICEINSTANCE_DX3W {
+    DWORD   dwSize;
+    GUID    guidInstance;
+    GUID    guidProduct;
+    DWORD   dwDevType;
+    WCHAR   tszInstanceName[MAX_PATH];
+    WCHAR   tszProductName[MAX_PATH];
+} DIDEVICEINSTANCE_DX3W, *LPDIDEVICEINSTANCE_DX3W;
+#ifdef UNICODE
+typedef DIDEVICEINSTANCE_DX3W DIDEVICEINSTANCE_DX3;
+typedef LPDIDEVICEINSTANCE_DX3W LPDIDEVICEINSTANCE_DX3;
+#else
+typedef DIDEVICEINSTANCE_DX3A DIDEVICEINSTANCE_DX3;
+typedef LPDIDEVICEINSTANCE_DX3A LPDIDEVICEINSTANCE_DX3;
+#endif // UNICODE
+typedef const DIDEVICEINSTANCE_DX3A *LPCDIDEVICEINSTANCE_DX3A;
+typedef const DIDEVICEINSTANCE_DX3W *LPCDIDEVICEINSTANCE_DX3W;
+typedef const DIDEVICEINSTANCE_DX3  *LPCDIDEVICEINSTANCE_DX3;
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+
+typedef struct DIDEVICEINSTANCEA {
+    DWORD   dwSize;
+    GUID    guidInstance;
+    GUID    guidProduct;
+    DWORD   dwDevType;
+    CHAR    tszInstanceName[MAX_PATH];
+    CHAR    tszProductName[MAX_PATH];
+#if(DIRECTINPUT_VERSION >= 0x0500)
+    GUID    guidFFDriver;
+    WORD    wUsagePage;
+    WORD    wUsage;
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+} DIDEVICEINSTANCEA, *LPDIDEVICEINSTANCEA;
+typedef struct DIDEVICEINSTANCEW {
+    DWORD   dwSize;
+    GUID    guidInstance;
+    GUID    guidProduct;
+    DWORD   dwDevType;
+    WCHAR   tszInstanceName[MAX_PATH];
+    WCHAR   tszProductName[MAX_PATH];
+#if(DIRECTINPUT_VERSION >= 0x0500)
+    GUID    guidFFDriver;
+    WORD    wUsagePage;
+    WORD    wUsage;
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+} DIDEVICEINSTANCEW, *LPDIDEVICEINSTANCEW;
+#ifdef UNICODE
+typedef DIDEVICEINSTANCEW DIDEVICEINSTANCE;
+typedef LPDIDEVICEINSTANCEW LPDIDEVICEINSTANCE;
+#else
+typedef DIDEVICEINSTANCEA DIDEVICEINSTANCE;
+typedef LPDIDEVICEINSTANCEA LPDIDEVICEINSTANCE;
+#endif // UNICODE
+
+typedef const DIDEVICEINSTANCEA *LPCDIDEVICEINSTANCEA;
+typedef const DIDEVICEINSTANCEW *LPCDIDEVICEINSTANCEW;
+#ifdef UNICODE
+typedef DIDEVICEINSTANCEW DIDEVICEINSTANCE;
+typedef LPCDIDEVICEINSTANCEW LPCDIDEVICEINSTANCE;
+#else
+typedef DIDEVICEINSTANCEA DIDEVICEINSTANCE;
+typedef LPCDIDEVICEINSTANCEA LPCDIDEVICEINSTANCE;
+#endif // UNICODE
+typedef const DIDEVICEINSTANCE  *LPCDIDEVICEINSTANCE;
+
+#undef INTERFACE
+#define INTERFACE IDirectInputDeviceW
+
+DECLARE_INTERFACE_(IDirectInputDeviceW, IUnknown)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInputDeviceW methods ***/
+    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
+    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKW,LPVOID,DWORD) PURE;
+    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
+    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
+    STDMETHOD(Acquire)(THIS) PURE;
+    STDMETHOD(Unacquire)(THIS) PURE;
+    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
+    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
+    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
+    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
+    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEW,DWORD,DWORD) PURE;
+    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
+};
+
+typedef struct IDirectInputDeviceW *LPDIRECTINPUTDEVICEW;
+
+#undef INTERFACE
+#define INTERFACE IDirectInputDeviceA
+
+DECLARE_INTERFACE_(IDirectInputDeviceA, IUnknown)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInputDeviceA methods ***/
+    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
+    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKA,LPVOID,DWORD) PURE;
+    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
+    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
+    STDMETHOD(Acquire)(THIS) PURE;
+    STDMETHOD(Unacquire)(THIS) PURE;
+    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
+    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
+    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
+    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
+    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEA,DWORD,DWORD) PURE;
+    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEA) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
+};
+
+typedef struct IDirectInputDeviceA *LPDIRECTINPUTDEVICEA;
+
+#ifdef UNICODE
+#define IID_IDirectInputDevice IID_IDirectInputDeviceW
+#define IDirectInputDevice IDirectInputDeviceW
+#define IDirectInputDeviceVtbl IDirectInputDeviceWVtbl
+#else
+#define IID_IDirectInputDevice IID_IDirectInputDeviceA
+#define IDirectInputDevice IDirectInputDeviceA
+#define IDirectInputDeviceVtbl IDirectInputDeviceAVtbl
+#endif
+typedef struct IDirectInputDevice *LPDIRECTINPUTDEVICE;
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectInputDevice_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectInputDevice_AddRef(p) (p)->lpVtbl->AddRef(p)
+#define IDirectInputDevice_Release(p) (p)->lpVtbl->Release(p)
+#define IDirectInputDevice_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
+#define IDirectInputDevice_EnumObjects(p,a,b,c) (p)->lpVtbl->EnumObjects(p,a,b,c)
+#define IDirectInputDevice_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
+#define IDirectInputDevice_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
+#define IDirectInputDevice_Acquire(p) (p)->lpVtbl->Acquire(p)
+#define IDirectInputDevice_Unacquire(p) (p)->lpVtbl->Unacquire(p)
+#define IDirectInputDevice_GetDeviceState(p,a,b) (p)->lpVtbl->GetDeviceState(p,a,b)
+#define IDirectInputDevice_GetDeviceData(p,a,b,c,d) (p)->lpVtbl->GetDeviceData(p,a,b,c,d)
+#define IDirectInputDevice_SetDataFormat(p,a) (p)->lpVtbl->SetDataFormat(p,a)
+#define IDirectInputDevice_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
+#define IDirectInputDevice_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
+#define IDirectInputDevice_GetObjectInfo(p,a,b,c) (p)->lpVtbl->GetObjectInfo(p,a,b,c)
+#define IDirectInputDevice_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
+#define IDirectInputDevice_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
+#define IDirectInputDevice_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
+#else
+#define IDirectInputDevice_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
+#define IDirectInputDevice_AddRef(p) (p)->AddRef()
+#define IDirectInputDevice_Release(p) (p)->Release()
+#define IDirectInputDevice_GetCapabilities(p,a) (p)->GetCapabilities(a)
+#define IDirectInputDevice_EnumObjects(p,a,b,c) (p)->EnumObjects(a,b,c)
+#define IDirectInputDevice_GetProperty(p,a,b) (p)->GetProperty(a,b)
+#define IDirectInputDevice_SetProperty(p,a,b) (p)->SetProperty(a,b)
+#define IDirectInputDevice_Acquire(p) (p)->Acquire()
+#define IDirectInputDevice_Unacquire(p) (p)->Unacquire()
+#define IDirectInputDevice_GetDeviceState(p,a,b) (p)->GetDeviceState(a,b)
+#define IDirectInputDevice_GetDeviceData(p,a,b,c,d) (p)->GetDeviceData(a,b,c,d)
+#define IDirectInputDevice_SetDataFormat(p,a) (p)->SetDataFormat(a)
+#define IDirectInputDevice_SetEventNotification(p,a) (p)->SetEventNotification(a)
+#define IDirectInputDevice_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
+#define IDirectInputDevice_GetObjectInfo(p,a,b,c) (p)->GetObjectInfo(a,b,c)
+#define IDirectInputDevice_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
+#define IDirectInputDevice_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
+#define IDirectInputDevice_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
+#endif
+
+#endif /* DIJ_RINGZERO */
+
+
+#if(DIRECTINPUT_VERSION >= 0x0500)
+
+#define DISFFC_RESET            0x00000001
+#define DISFFC_STOPALL          0x00000002
+#define DISFFC_PAUSE            0x00000004
+#define DISFFC_CONTINUE         0x00000008
+#define DISFFC_SETACTUATORSON   0x00000010
+#define DISFFC_SETACTUATORSOFF  0x00000020
+
+#define DIGFFS_EMPTY            0x00000001
+#define DIGFFS_STOPPED          0x00000002
+#define DIGFFS_PAUSED           0x00000004
+#define DIGFFS_ACTUATORSON      0x00000010
+#define DIGFFS_ACTUATORSOFF     0x00000020
+#define DIGFFS_POWERON          0x00000040
+#define DIGFFS_POWEROFF         0x00000080
+#define DIGFFS_SAFETYSWITCHON   0x00000100
+#define DIGFFS_SAFETYSWITCHOFF  0x00000200
+#define DIGFFS_USERFFSWITCHON   0x00000400
+#define DIGFFS_USERFFSWITCHOFF  0x00000800
+#define DIGFFS_DEVICELOST       0x80000000
+
+#ifndef DIJ_RINGZERO
+
+typedef struct DIEFFECTINFOA {
+    DWORD   dwSize;
+    GUID    guid;
+    DWORD   dwEffType;
+    DWORD   dwStaticParams;
+    DWORD   dwDynamicParams;
+    CHAR    tszName[MAX_PATH];
+} DIEFFECTINFOA, *LPDIEFFECTINFOA;
+typedef struct DIEFFECTINFOW {
+    DWORD   dwSize;
+    GUID    guid;
+    DWORD   dwEffType;
+    DWORD   dwStaticParams;
+    DWORD   dwDynamicParams;
+    WCHAR   tszName[MAX_PATH];
+} DIEFFECTINFOW, *LPDIEFFECTINFOW;
+#ifdef UNICODE
+typedef DIEFFECTINFOW DIEFFECTINFO;
+typedef LPDIEFFECTINFOW LPDIEFFECTINFO;
+#else
+typedef DIEFFECTINFOA DIEFFECTINFO;
+typedef LPDIEFFECTINFOA LPDIEFFECTINFO;
+#endif // UNICODE
+typedef const DIEFFECTINFOA *LPCDIEFFECTINFOA;
+typedef const DIEFFECTINFOW *LPCDIEFFECTINFOW;
+typedef const DIEFFECTINFO  *LPCDIEFFECTINFO;
+
+#define DISDD_CONTINUE          0x00000001
+
+typedef BOOL (FAR PASCAL * LPDIENUMEFFECTSCALLBACKA)(LPCDIEFFECTINFOA, LPVOID);
+typedef BOOL (FAR PASCAL * LPDIENUMEFFECTSCALLBACKW)(LPCDIEFFECTINFOW, LPVOID);
+#ifdef UNICODE
+#define LPDIENUMEFFECTSCALLBACK  LPDIENUMEFFECTSCALLBACKW
+#else
+#define LPDIENUMEFFECTSCALLBACK  LPDIENUMEFFECTSCALLBACKA
+#endif // !UNICODE
+typedef BOOL (FAR PASCAL * LPDIENUMCREATEDEFFECTOBJECTSCALLBACK)(LPDIRECTINPUTEFFECT, LPVOID);
+
+#undef INTERFACE
+#define INTERFACE IDirectInputDevice2W
+
+DECLARE_INTERFACE_(IDirectInputDevice2W, IDirectInputDeviceW)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInputDeviceW methods ***/
+    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
+    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKW,LPVOID,DWORD) PURE;
+    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
+    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
+    STDMETHOD(Acquire)(THIS) PURE;
+    STDMETHOD(Unacquire)(THIS) PURE;
+    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
+    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
+    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
+    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
+    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEW,DWORD,DWORD) PURE;
+    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
+
+    /*** IDirectInputDevice2W methods ***/
+    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
+    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKW,LPVOID,DWORD) PURE;
+    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOW,REFGUID) PURE;
+    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
+    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
+    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
+    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
+    STDMETHOD(Poll)(THIS) PURE;
+    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
+};
+
+typedef struct IDirectInputDevice2W *LPDIRECTINPUTDEVICE2W;
+
+#undef INTERFACE
+#define INTERFACE IDirectInputDevice2A
+
+DECLARE_INTERFACE_(IDirectInputDevice2A, IDirectInputDeviceA)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInputDeviceA methods ***/
+    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
+    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKA,LPVOID,DWORD) PURE;
+    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
+    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
+    STDMETHOD(Acquire)(THIS) PURE;
+    STDMETHOD(Unacquire)(THIS) PURE;
+    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
+    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
+    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
+    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
+    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEA,DWORD,DWORD) PURE;
+    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEA) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
+
+    /*** IDirectInputDevice2A methods ***/
+    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
+    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKA,LPVOID,DWORD) PURE;
+    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOA,REFGUID) PURE;
+    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
+    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
+    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
+    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
+    STDMETHOD(Poll)(THIS) PURE;
+    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
+};
+
+typedef struct IDirectInputDevice2A *LPDIRECTINPUTDEVICE2A;
+
+#ifdef UNICODE
+#define IID_IDirectInputDevice2 IID_IDirectInputDevice2W
+#define IDirectInputDevice2 IDirectInputDevice2W
+#define IDirectInputDevice2Vtbl IDirectInputDevice2WVtbl
+#else
+#define IID_IDirectInputDevice2 IID_IDirectInputDevice2A
+#define IDirectInputDevice2 IDirectInputDevice2A
+#define IDirectInputDevice2Vtbl IDirectInputDevice2AVtbl
+#endif
+typedef struct IDirectInputDevice2 *LPDIRECTINPUTDEVICE2;
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectInputDevice2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectInputDevice2_AddRef(p) (p)->lpVtbl->AddRef(p)
+#define IDirectInputDevice2_Release(p) (p)->lpVtbl->Release(p)
+#define IDirectInputDevice2_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
+#define IDirectInputDevice2_EnumObjects(p,a,b,c) (p)->lpVtbl->EnumObjects(p,a,b,c)
+#define IDirectInputDevice2_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
+#define IDirectInputDevice2_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
+#define IDirectInputDevice2_Acquire(p) (p)->lpVtbl->Acquire(p)
+#define IDirectInputDevice2_Unacquire(p) (p)->lpVtbl->Unacquire(p)
+#define IDirectInputDevice2_GetDeviceState(p,a,b) (p)->lpVtbl->GetDeviceState(p,a,b)
+#define IDirectInputDevice2_GetDeviceData(p,a,b,c,d) (p)->lpVtbl->GetDeviceData(p,a,b,c,d)
+#define IDirectInputDevice2_SetDataFormat(p,a) (p)->lpVtbl->SetDataFormat(p,a)
+#define IDirectInputDevice2_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
+#define IDirectInputDevice2_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
+#define IDirectInputDevice2_GetObjectInfo(p,a,b,c) (p)->lpVtbl->GetObjectInfo(p,a,b,c)
+#define IDirectInputDevice2_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
+#define IDirectInputDevice2_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
+#define IDirectInputDevice2_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
+#define IDirectInputDevice2_CreateEffect(p,a,b,c,d) (p)->lpVtbl->CreateEffect(p,a,b,c,d)
+#define IDirectInputDevice2_EnumEffects(p,a,b,c) (p)->lpVtbl->EnumEffects(p,a,b,c)
+#define IDirectInputDevice2_GetEffectInfo(p,a,b) (p)->lpVtbl->GetEffectInfo(p,a,b)
+#define IDirectInputDevice2_GetForceFeedbackState(p,a) (p)->lpVtbl->GetForceFeedbackState(p,a)
+#define IDirectInputDevice2_SendForceFeedbackCommand(p,a) (p)->lpVtbl->SendForceFeedbackCommand(p,a)
+#define IDirectInputDevice2_EnumCreatedEffectObjects(p,a,b,c) (p)->lpVtbl->EnumCreatedEffectObjects(p,a,b,c)
+#define IDirectInputDevice2_Escape(p,a) (p)->lpVtbl->Escape(p,a)
+#define IDirectInputDevice2_Poll(p) (p)->lpVtbl->Poll(p)
+#define IDirectInputDevice2_SendDeviceData(p,a,b,c,d) (p)->lpVtbl->SendDeviceData(p,a,b,c,d)
+#else
+#define IDirectInputDevice2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
+#define IDirectInputDevice2_AddRef(p) (p)->AddRef()
+#define IDirectInputDevice2_Release(p) (p)->Release()
+#define IDirectInputDevice2_GetCapabilities(p,a) (p)->GetCapabilities(a)
+#define IDirectInputDevice2_EnumObjects(p,a,b,c) (p)->EnumObjects(a,b,c)
+#define IDirectInputDevice2_GetProperty(p,a,b) (p)->GetProperty(a,b)
+#define IDirectInputDevice2_SetProperty(p,a,b) (p)->SetProperty(a,b)
+#define IDirectInputDevice2_Acquire(p) (p)->Acquire()
+#define IDirectInputDevice2_Unacquire(p) (p)->Unacquire()
+#define IDirectInputDevice2_GetDeviceState(p,a,b) (p)->GetDeviceState(a,b)
+#define IDirectInputDevice2_GetDeviceData(p,a,b,c,d) (p)->GetDeviceData(a,b,c,d)
+#define IDirectInputDevice2_SetDataFormat(p,a) (p)->SetDataFormat(a)
+#define IDirectInputDevice2_SetEventNotification(p,a) (p)->SetEventNotification(a)
+#define IDirectInputDevice2_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
+#define IDirectInputDevice2_GetObjectInfo(p,a,b,c) (p)->GetObjectInfo(a,b,c)
+#define IDirectInputDevice2_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
+#define IDirectInputDevice2_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
+#define IDirectInputDevice2_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
+#define IDirectInputDevice2_CreateEffect(p,a,b,c,d) (p)->CreateEffect(a,b,c,d)
+#define IDirectInputDevice2_EnumEffects(p,a,b,c) (p)->EnumEffects(a,b,c)
+#define IDirectInputDevice2_GetEffectInfo(p,a,b) (p)->GetEffectInfo(a,b)
+#define IDirectInputDevice2_GetForceFeedbackState(p,a) (p)->GetForceFeedbackState(a)
+#define IDirectInputDevice2_SendForceFeedbackCommand(p,a) (p)->SendForceFeedbackCommand(a)
+#define IDirectInputDevice2_EnumCreatedEffectObjects(p,a,b,c) (p)->EnumCreatedEffectObjects(a,b,c)
+#define IDirectInputDevice2_Escape(p,a) (p)->Escape(a)
+#define IDirectInputDevice2_Poll(p) (p)->Poll()
+#define IDirectInputDevice2_SendDeviceData(p,a,b,c,d) (p)->SendDeviceData(a,b,c,d)
+#endif
+
+#endif /* DIJ_RINGZERO */
+
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+
+#if(DIRECTINPUT_VERSION >= 0x0700)
+#define DIFEF_DEFAULT               0x00000000
+#define DIFEF_INCLUDENONSTANDARD    0x00000001
+#define DIFEF_MODIFYIFNEEDED            0x00000010
+
+#ifndef DIJ_RINGZERO
+
+#undef INTERFACE
+#define INTERFACE IDirectInputDevice7W
+
+DECLARE_INTERFACE_(IDirectInputDevice7W, IDirectInputDevice2W)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInputDevice2W methods ***/
+    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
+    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKW,LPVOID,DWORD) PURE;
+    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
+    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
+    STDMETHOD(Acquire)(THIS) PURE;
+    STDMETHOD(Unacquire)(THIS) PURE;
+    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
+    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
+    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
+    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
+    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEW,DWORD,DWORD) PURE;
+    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
+    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
+    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKW,LPVOID,DWORD) PURE;
+    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOW,REFGUID) PURE;
+    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
+    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
+    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
+    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
+    STDMETHOD(Poll)(THIS) PURE;
+    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
+
+    /*** IDirectInputDevice7W methods ***/
+    STDMETHOD(EnumEffectsInFile)(THIS_ LPCWSTR,LPDIENUMEFFECTSINFILECALLBACK,LPVOID,DWORD) PURE;
+    STDMETHOD(WriteEffectToFile)(THIS_ LPCWSTR,DWORD,LPDIFILEEFFECT,DWORD) PURE;
+};
+
+typedef struct IDirectInputDevice7W *LPDIRECTINPUTDEVICE7W;
+
+#undef INTERFACE
+#define INTERFACE IDirectInputDevice7A
+
+DECLARE_INTERFACE_(IDirectInputDevice7A, IDirectInputDevice2A)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInputDevice2A methods ***/
+    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
+    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKA,LPVOID,DWORD) PURE;
+    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
+    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
+    STDMETHOD(Acquire)(THIS) PURE;
+    STDMETHOD(Unacquire)(THIS) PURE;
+    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
+    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
+    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
+    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
+    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEA,DWORD,DWORD) PURE;
+    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEA) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
+    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
+    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKA,LPVOID,DWORD) PURE;
+    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOA,REFGUID) PURE;
+    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
+    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
+    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
+    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
+    STDMETHOD(Poll)(THIS) PURE;
+    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
+
+    /*** IDirectInputDevice7A methods ***/
+    STDMETHOD(EnumEffectsInFile)(THIS_ LPCSTR,LPDIENUMEFFECTSINFILECALLBACK,LPVOID,DWORD) PURE;
+    STDMETHOD(WriteEffectToFile)(THIS_ LPCSTR,DWORD,LPDIFILEEFFECT,DWORD) PURE;
+};
+
+typedef struct IDirectInputDevice7A *LPDIRECTINPUTDEVICE7A;
+
+#ifdef UNICODE
+#define IID_IDirectInputDevice7 IID_IDirectInputDevice7W
+#define IDirectInputDevice7 IDirectInputDevice7W
+#define IDirectInputDevice7Vtbl IDirectInputDevice7WVtbl
+#else
+#define IID_IDirectInputDevice7 IID_IDirectInputDevice7A
+#define IDirectInputDevice7 IDirectInputDevice7A
+#define IDirectInputDevice7Vtbl IDirectInputDevice7AVtbl
+#endif
+typedef struct IDirectInputDevice7 *LPDIRECTINPUTDEVICE7;
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectInputDevice7_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectInputDevice7_AddRef(p) (p)->lpVtbl->AddRef(p)
+#define IDirectInputDevice7_Release(p) (p)->lpVtbl->Release(p)
+#define IDirectInputDevice7_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
+#define IDirectInputDevice7_EnumObjects(p,a,b,c) (p)->lpVtbl->EnumObjects(p,a,b,c)
+#define IDirectInputDevice7_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
+#define IDirectInputDevice7_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
+#define IDirectInputDevice7_Acquire(p) (p)->lpVtbl->Acquire(p)
+#define IDirectInputDevice7_Unacquire(p) (p)->lpVtbl->Unacquire(p)
+#define IDirectInputDevice7_GetDeviceState(p,a,b) (p)->lpVtbl->GetDeviceState(p,a,b)
+#define IDirectInputDevice7_GetDeviceData(p,a,b,c,d) (p)->lpVtbl->GetDeviceData(p,a,b,c,d)
+#define IDirectInputDevice7_SetDataFormat(p,a) (p)->lpVtbl->SetDataFormat(p,a)
+#define IDirectInputDevice7_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
+#define IDirectInputDevice7_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
+#define IDirectInputDevice7_GetObjectInfo(p,a,b,c) (p)->lpVtbl->GetObjectInfo(p,a,b,c)
+#define IDirectInputDevice7_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
+#define IDirectInputDevice7_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
+#define IDirectInputDevice7_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
+#define IDirectInputDevice7_CreateEffect(p,a,b,c,d) (p)->lpVtbl->CreateEffect(p,a,b,c,d)
+#define IDirectInputDevice7_EnumEffects(p,a,b,c) (p)->lpVtbl->EnumEffects(p,a,b,c)
+#define IDirectInputDevice7_GetEffectInfo(p,a,b) (p)->lpVtbl->GetEffectInfo(p,a,b)
+#define IDirectInputDevice7_GetForceFeedbackState(p,a) (p)->lpVtbl->GetForceFeedbackState(p,a)
+#define IDirectInputDevice7_SendForceFeedbackCommand(p,a) (p)->lpVtbl->SendForceFeedbackCommand(p,a)
+#define IDirectInputDevice7_EnumCreatedEffectObjects(p,a,b,c) (p)->lpVtbl->EnumCreatedEffectObjects(p,a,b,c)
+#define IDirectInputDevice7_Escape(p,a) (p)->lpVtbl->Escape(p,a)
+#define IDirectInputDevice7_Poll(p) (p)->lpVtbl->Poll(p)
+#define IDirectInputDevice7_SendDeviceData(p,a,b,c,d) (p)->lpVtbl->SendDeviceData(p,a,b,c,d)
+#define IDirectInputDevice7_EnumEffectsInFile(p,a,b,c,d) (p)->lpVtbl->EnumEffectsInFile(p,a,b,c,d)
+#define IDirectInputDevice7_WriteEffectToFile(p,a,b,c,d) (p)->lpVtbl->WriteEffectToFile(p,a,b,c,d)
+#else
+#define IDirectInputDevice7_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
+#define IDirectInputDevice7_AddRef(p) (p)->AddRef()
+#define IDirectInputDevice7_Release(p) (p)->Release()
+#define IDirectInputDevice7_GetCapabilities(p,a) (p)->GetCapabilities(a)
+#define IDirectInputDevice7_EnumObjects(p,a,b,c) (p)->EnumObjects(a,b,c)
+#define IDirectInputDevice7_GetProperty(p,a,b) (p)->GetProperty(a,b)
+#define IDirectInputDevice7_SetProperty(p,a,b) (p)->SetProperty(a,b)
+#define IDirectInputDevice7_Acquire(p) (p)->Acquire()
+#define IDirectInputDevice7_Unacquire(p) (p)->Unacquire()
+#define IDirectInputDevice7_GetDeviceState(p,a,b) (p)->GetDeviceState(a,b)
+#define IDirectInputDevice7_GetDeviceData(p,a,b,c,d) (p)->GetDeviceData(a,b,c,d)
+#define IDirectInputDevice7_SetDataFormat(p,a) (p)->SetDataFormat(a)
+#define IDirectInputDevice7_SetEventNotification(p,a) (p)->SetEventNotification(a)
+#define IDirectInputDevice7_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
+#define IDirectInputDevice7_GetObjectInfo(p,a,b,c) (p)->GetObjectInfo(a,b,c)
+#define IDirectInputDevice7_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
+#define IDirectInputDevice7_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
+#define IDirectInputDevice7_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
+#define IDirectInputDevice7_CreateEffect(p,a,b,c,d) (p)->CreateEffect(a,b,c,d)
+#define IDirectInputDevice7_EnumEffects(p,a,b,c) (p)->EnumEffects(a,b,c)
+#define IDirectInputDevice7_GetEffectInfo(p,a,b) (p)->GetEffectInfo(a,b)
+#define IDirectInputDevice7_GetForceFeedbackState(p,a) (p)->GetForceFeedbackState(a)
+#define IDirectInputDevice7_SendForceFeedbackCommand(p,a) (p)->SendForceFeedbackCommand(a)
+#define IDirectInputDevice7_EnumCreatedEffectObjects(p,a,b,c) (p)->EnumCreatedEffectObjects(a,b,c)
+#define IDirectInputDevice7_Escape(p,a) (p)->Escape(a)
+#define IDirectInputDevice7_Poll(p) (p)->Poll()
+#define IDirectInputDevice7_SendDeviceData(p,a,b,c,d) (p)->SendDeviceData(a,b,c,d)
+#define IDirectInputDevice7_EnumEffectsInFile(p,a,b,c,d) (p)->EnumEffectsInFile(a,b,c,d)
+#define IDirectInputDevice7_WriteEffectToFile(p,a,b,c,d) (p)->WriteEffectToFile(a,b,c,d)
+#endif
+
+#endif /* DIJ_RINGZERO */
+
+#endif /* DIRECTINPUT_VERSION >= 0x0700 */
+
+#if(DIRECTINPUT_VERSION >= 0x0800)
+
+#ifndef DIJ_RINGZERO
+
+#undef INTERFACE
+#define INTERFACE IDirectInputDevice8W
+
+DECLARE_INTERFACE_(IDirectInputDevice8W, IUnknown)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInputDevice8W methods ***/
+    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
+    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKW,LPVOID,DWORD) PURE;
+    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
+    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
+    STDMETHOD(Acquire)(THIS) PURE;
+    STDMETHOD(Unacquire)(THIS) PURE;
+    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
+    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
+    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
+    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
+    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEW,DWORD,DWORD) PURE;
+    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
+    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
+    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKW,LPVOID,DWORD) PURE;
+    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOW,REFGUID) PURE;
+    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
+    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
+    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
+    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
+    STDMETHOD(Poll)(THIS) PURE;
+    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
+    STDMETHOD(EnumEffectsInFile)(THIS_ LPCWSTR,LPDIENUMEFFECTSINFILECALLBACK,LPVOID,DWORD) PURE;
+    STDMETHOD(WriteEffectToFile)(THIS_ LPCWSTR,DWORD,LPDIFILEEFFECT,DWORD) PURE;
+    STDMETHOD(BuildActionMap)(THIS_ LPDIACTIONFORMATW,LPCWSTR,DWORD) PURE;
+    STDMETHOD(SetActionMap)(THIS_ LPDIACTIONFORMATW,LPCWSTR,DWORD) PURE;
+    STDMETHOD(GetImageInfo)(THIS_ LPDIDEVICEIMAGEINFOHEADERW) PURE;
+};
+
+typedef struct IDirectInputDevice8W *LPDIRECTINPUTDEVICE8W;
+
+#undef INTERFACE
+#define INTERFACE IDirectInputDevice8A
+
+DECLARE_INTERFACE_(IDirectInputDevice8A, IUnknown)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInputDevice8A methods ***/
+    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
+    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKA,LPVOID,DWORD) PURE;
+    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
+    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
+    STDMETHOD(Acquire)(THIS) PURE;
+    STDMETHOD(Unacquire)(THIS) PURE;
+    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
+    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
+    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
+    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
+    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEA,DWORD,DWORD) PURE;
+    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEA) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
+    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
+    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKA,LPVOID,DWORD) PURE;
+    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOA,REFGUID) PURE;
+    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
+    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
+    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
+    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
+    STDMETHOD(Poll)(THIS) PURE;
+    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
+    STDMETHOD(EnumEffectsInFile)(THIS_ LPCSTR,LPDIENUMEFFECTSINFILECALLBACK,LPVOID,DWORD) PURE;
+    STDMETHOD(WriteEffectToFile)(THIS_ LPCSTR,DWORD,LPDIFILEEFFECT,DWORD) PURE;
+    STDMETHOD(BuildActionMap)(THIS_ LPDIACTIONFORMATA,LPCSTR,DWORD) PURE;
+    STDMETHOD(SetActionMap)(THIS_ LPDIACTIONFORMATA,LPCSTR,DWORD) PURE;
+    STDMETHOD(GetImageInfo)(THIS_ LPDIDEVICEIMAGEINFOHEADERA) PURE;
+};
+
+typedef struct IDirectInputDevice8A *LPDIRECTINPUTDEVICE8A;
+
+#ifdef UNICODE
+#define IID_IDirectInputDevice8 IID_IDirectInputDevice8W
+#define IDirectInputDevice8 IDirectInputDevice8W
+#define IDirectInputDevice8Vtbl IDirectInputDevice8WVtbl
+#else
+#define IID_IDirectInputDevice8 IID_IDirectInputDevice8A
+#define IDirectInputDevice8 IDirectInputDevice8A
+#define IDirectInputDevice8Vtbl IDirectInputDevice8AVtbl
+#endif
+typedef struct IDirectInputDevice8 *LPDIRECTINPUTDEVICE8;
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectInputDevice8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectInputDevice8_AddRef(p) (p)->lpVtbl->AddRef(p)
+#define IDirectInputDevice8_Release(p) (p)->lpVtbl->Release(p)
+#define IDirectInputDevice8_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
+#define IDirectInputDevice8_EnumObjects(p,a,b,c) (p)->lpVtbl->EnumObjects(p,a,b,c)
+#define IDirectInputDevice8_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
+#define IDirectInputDevice8_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
+#define IDirectInputDevice8_Acquire(p) (p)->lpVtbl->Acquire(p)
+#define IDirectInputDevice8_Unacquire(p) (p)->lpVtbl->Unacquire(p)
+#define IDirectInputDevice8_GetDeviceState(p,a,b) (p)->lpVtbl->GetDeviceState(p,a,b)
+#define IDirectInputDevice8_GetDeviceData(p,a,b,c,d) (p)->lpVtbl->GetDeviceData(p,a,b,c,d)
+#define IDirectInputDevice8_SetDataFormat(p,a) (p)->lpVtbl->SetDataFormat(p,a)
+#define IDirectInputDevice8_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
+#define IDirectInputDevice8_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
+#define IDirectInputDevice8_GetObjectInfo(p,a,b,c) (p)->lpVtbl->GetObjectInfo(p,a,b,c)
+#define IDirectInputDevice8_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
+#define IDirectInputDevice8_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
+#define IDirectInputDevice8_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
+#define IDirectInputDevice8_CreateEffect(p,a,b,c,d) (p)->lpVtbl->CreateEffect(p,a,b,c,d)
+#define IDirectInputDevice8_EnumEffects(p,a,b,c) (p)->lpVtbl->EnumEffects(p,a,b,c)
+#define IDirectInputDevice8_GetEffectInfo(p,a,b) (p)->lpVtbl->GetEffectInfo(p,a,b)
+#define IDirectInputDevice8_GetForceFeedbackState(p,a) (p)->lpVtbl->GetForceFeedbackState(p,a)
+#define IDirectInputDevice8_SendForceFeedbackCommand(p,a) (p)->lpVtbl->SendForceFeedbackCommand(p,a)
+#define IDirectInputDevice8_EnumCreatedEffectObjects(p,a,b,c) (p)->lpVtbl->EnumCreatedEffectObjects(p,a,b,c)
+#define IDirectInputDevice8_Escape(p,a) (p)->lpVtbl->Escape(p,a)
+#define IDirectInputDevice8_Poll(p) (p)->lpVtbl->Poll(p)
+#define IDirectInputDevice8_SendDeviceData(p,a,b,c,d) (p)->lpVtbl->SendDeviceData(p,a,b,c,d)
+#define IDirectInputDevice8_EnumEffectsInFile(p,a,b,c,d) (p)->lpVtbl->EnumEffectsInFile(p,a,b,c,d)
+#define IDirectInputDevice8_WriteEffectToFile(p,a,b,c,d) (p)->lpVtbl->WriteEffectToFile(p,a,b,c,d)
+#define IDirectInputDevice8_BuildActionMap(p,a,b,c) (p)->lpVtbl->BuildActionMap(p,a,b,c)
+#define IDirectInputDevice8_SetActionMap(p,a,b,c) (p)->lpVtbl->SetActionMap(p,a,b,c)
+#define IDirectInputDevice8_GetImageInfo(p,a) (p)->lpVtbl->GetImageInfo(p,a)
+#else
+#define IDirectInputDevice8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
+#define IDirectInputDevice8_AddRef(p) (p)->AddRef()
+#define IDirectInputDevice8_Release(p) (p)->Release()
+#define IDirectInputDevice8_GetCapabilities(p,a) (p)->GetCapabilities(a)
+#define IDirectInputDevice8_EnumObjects(p,a,b,c) (p)->EnumObjects(a,b,c)
+#define IDirectInputDevice8_GetProperty(p,a,b) (p)->GetProperty(a,b)
+#define IDirectInputDevice8_SetProperty(p,a,b) (p)->SetProperty(a,b)
+#define IDirectInputDevice8_Acquire(p) (p)->Acquire()
+#define IDirectInputDevice8_Unacquire(p) (p)->Unacquire()
+#define IDirectInputDevice8_GetDeviceState(p,a,b) (p)->GetDeviceState(a,b)
+#define IDirectInputDevice8_GetDeviceData(p,a,b,c,d) (p)->GetDeviceData(a,b,c,d)
+#define IDirectInputDevice8_SetDataFormat(p,a) (p)->SetDataFormat(a)
+#define IDirectInputDevice8_SetEventNotification(p,a) (p)->SetEventNotification(a)
+#define IDirectInputDevice8_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
+#define IDirectInputDevice8_GetObjectInfo(p,a,b,c) (p)->GetObjectInfo(a,b,c)
+#define IDirectInputDevice8_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
+#define IDirectInputDevice8_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
+#define IDirectInputDevice8_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
+#define IDirectInputDevice8_CreateEffect(p,a,b,c,d) (p)->CreateEffect(a,b,c,d)
+#define IDirectInputDevice8_EnumEffects(p,a,b,c) (p)->EnumEffects(a,b,c)
+#define IDirectInputDevice8_GetEffectInfo(p,a,b) (p)->GetEffectInfo(a,b)
+#define IDirectInputDevice8_GetForceFeedbackState(p,a) (p)->GetForceFeedbackState(a)
+#define IDirectInputDevice8_SendForceFeedbackCommand(p,a) (p)->SendForceFeedbackCommand(a)
+#define IDirectInputDevice8_EnumCreatedEffectObjects(p,a,b,c) (p)->EnumCreatedEffectObjects(a,b,c)
+#define IDirectInputDevice8_Escape(p,a) (p)->Escape(a)
+#define IDirectInputDevice8_Poll(p) (p)->Poll()
+#define IDirectInputDevice8_SendDeviceData(p,a,b,c,d) (p)->SendDeviceData(a,b,c,d)
+#define IDirectInputDevice8_EnumEffectsInFile(p,a,b,c,d) (p)->EnumEffectsInFile(a,b,c,d)
+#define IDirectInputDevice8_WriteEffectToFile(p,a,b,c,d) (p)->WriteEffectToFile(a,b,c,d)
+#define IDirectInputDevice8_BuildActionMap(p,a,b,c) (p)->BuildActionMap(a,b,c)
+#define IDirectInputDevice8_SetActionMap(p,a,b,c) (p)->SetActionMap(a,b,c)
+#define IDirectInputDevice8_GetImageInfo(p,a) (p)->GetImageInfo(a)
+#endif
+
+#endif /* DIJ_RINGZERO */
+
+#endif /* DIRECTINPUT_VERSION >= 0x0800 */
+
+/****************************************************************************
+ *
+ *      Mouse
+ *
+ ****************************************************************************/
+
+#ifndef DIJ_RINGZERO
+
+typedef struct _DIMOUSESTATE {
+    LONG    lX;
+    LONG    lY;
+    LONG    lZ;
+    BYTE    rgbButtons[4];
+} DIMOUSESTATE, *LPDIMOUSESTATE;
+
+#if DIRECTINPUT_VERSION >= 0x0700
+typedef struct _DIMOUSESTATE2 {
+    LONG    lX;
+    LONG    lY;
+    LONG    lZ;
+    BYTE    rgbButtons[8];
+} DIMOUSESTATE2, *LPDIMOUSESTATE2;
+#endif
+
+
+#define DIMOFS_X        FIELD_OFFSET(DIMOUSESTATE, lX)
+#define DIMOFS_Y        FIELD_OFFSET(DIMOUSESTATE, lY)
+#define DIMOFS_Z        FIELD_OFFSET(DIMOUSESTATE, lZ)
+#define DIMOFS_BUTTON0 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 0)
+#define DIMOFS_BUTTON1 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 1)
+#define DIMOFS_BUTTON2 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 2)
+#define DIMOFS_BUTTON3 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 3)
+#if (DIRECTINPUT_VERSION >= 0x0700)
+#define DIMOFS_BUTTON4 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 4)
+#define DIMOFS_BUTTON5 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 5)
+#define DIMOFS_BUTTON6 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 6)
+#define DIMOFS_BUTTON7 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 7)
+#endif
+#endif /* DIJ_RINGZERO */
+
+/****************************************************************************
+ *
+ *      Keyboard
+ *
+ ****************************************************************************/
+
+#ifndef DIJ_RINGZERO
+
+/****************************************************************************
+ *
+ *      DirectInput keyboard scan codes
+ *
+ ****************************************************************************/
+#define DIK_ESCAPE          0x01
+#define DIK_1               0x02
+#define DIK_2               0x03
+#define DIK_3               0x04
+#define DIK_4               0x05
+#define DIK_5               0x06
+#define DIK_6               0x07
+#define DIK_7               0x08
+#define DIK_8               0x09
+#define DIK_9               0x0A
+#define DIK_0               0x0B
+#define DIK_MINUS           0x0C    /* - on main keyboard */
+#define DIK_EQUALS          0x0D
+#define DIK_BACK            0x0E    /* backspace */
+#define DIK_TAB             0x0F
+#define DIK_Q               0x10
+#define DIK_W               0x11
+#define DIK_E               0x12
+#define DIK_R               0x13
+#define DIK_T               0x14
+#define DIK_Y               0x15
+#define DIK_U               0x16
+#define DIK_I               0x17
+#define DIK_O               0x18
+#define DIK_P               0x19
+#define DIK_LBRACKET        0x1A
+#define DIK_RBRACKET        0x1B
+#define DIK_RETURN          0x1C    /* Enter on main keyboard */
+#define DIK_LCONTROL        0x1D
+#define DIK_A               0x1E
+#define DIK_S               0x1F
+#define DIK_D               0x20
+#define DIK_F               0x21
+#define DIK_G               0x22
+#define DIK_H               0x23
+#define DIK_J               0x24
+#define DIK_K               0x25
+#define DIK_L               0x26
+#define DIK_SEMICOLON       0x27
+#define DIK_APOSTROPHE      0x28
+#define DIK_GRAVE           0x29    /* accent grave */
+#define DIK_LSHIFT          0x2A
+#define DIK_BACKSLASH       0x2B
+#define DIK_Z               0x2C
+#define DIK_X               0x2D
+#define DIK_C               0x2E
+#define DIK_V               0x2F
+#define DIK_B               0x30
+#define DIK_N               0x31
+#define DIK_M               0x32
+#define DIK_COMMA           0x33
+#define DIK_PERIOD          0x34    /* . on main keyboard */
+#define DIK_SLASH           0x35    /* / on main keyboard */
+#define DIK_RSHIFT          0x36
+#define DIK_MULTIPLY        0x37    /* * on numeric keypad */
+#define DIK_LMENU           0x38    /* left Alt */
+#define DIK_SPACE           0x39
+#define DIK_CAPITAL         0x3A
+#define DIK_F1              0x3B
+#define DIK_F2              0x3C
+#define DIK_F3              0x3D
+#define DIK_F4              0x3E
+#define DIK_F5              0x3F
+#define DIK_F6              0x40
+#define DIK_F7              0x41
+#define DIK_F8              0x42
+#define DIK_F9              0x43
+#define DIK_F10             0x44
+#define DIK_NUMLOCK         0x45
+#define DIK_SCROLL          0x46    /* Scroll Lock */
+#define DIK_NUMPAD7         0x47
+#define DIK_NUMPAD8         0x48
+#define DIK_NUMPAD9         0x49
+#define DIK_SUBTRACT        0x4A    /* - on numeric keypad */
+#define DIK_NUMPAD4         0x4B
+#define DIK_NUMPAD5         0x4C
+#define DIK_NUMPAD6         0x4D
+#define DIK_ADD             0x4E    /* + on numeric keypad */
+#define DIK_NUMPAD1         0x4F
+#define DIK_NUMPAD2         0x50
+#define DIK_NUMPAD3         0x51
+#define DIK_NUMPAD0         0x52
+#define DIK_DECIMAL         0x53    /* . on numeric keypad */
+#define DIK_OEM_102         0x56    /* <> or \| on RT 102-key keyboard (Non-U.S.) */
+#define DIK_F11             0x57
+#define DIK_F12             0x58
+#define DIK_F13             0x64    /*                     (NEC PC98) */
+#define DIK_F14             0x65    /*                     (NEC PC98) */
+#define DIK_F15             0x66    /*                     (NEC PC98) */
+#define DIK_KANA            0x70    /* (Japanese keyboard)            */
+#define DIK_ABNT_C1         0x73    /* /? on Brazilian keyboard */
+#define DIK_CONVERT         0x79    /* (Japanese keyboard)            */
+#define DIK_NOCONVERT       0x7B    /* (Japanese keyboard)            */
+#define DIK_YEN             0x7D    /* (Japanese keyboard)            */
+#define DIK_ABNT_C2         0x7E    /* Numpad . on Brazilian keyboard */
+#define DIK_NUMPADEQUALS    0x8D    /* = on numeric keypad (NEC PC98) */
+#define DIK_PREVTRACK       0x90    /* Previous Track (DIK_CIRCUMFLEX on Japanese keyboard) */
+#define DIK_AT              0x91    /*                     (NEC PC98) */
+#define DIK_COLON           0x92    /*                     (NEC PC98) */
+#define DIK_UNDERLINE       0x93    /*                     (NEC PC98) */
+#define DIK_KANJI           0x94    /* (Japanese keyboard)            */
+#define DIK_STOP            0x95    /*                     (NEC PC98) */
+#define DIK_AX              0x96    /*                     (Japan AX) */
+#define DIK_UNLABELED       0x97    /*                        (J3100) */
+#define DIK_NEXTTRACK       0x99    /* Next Track */
+#define DIK_NUMPADENTER     0x9C    /* Enter on numeric keypad */
+#define DIK_RCONTROL        0x9D
+#define DIK_MUTE            0xA0    /* Mute */
+#define DIK_CALCULATOR      0xA1    /* Calculator */
+#define DIK_PLAYPAUSE       0xA2    /* Play / Pause */
+#define DIK_MEDIASTOP       0xA4    /* Media Stop */
+#define DIK_VOLUMEDOWN      0xAE    /* Volume - */
+#define DIK_VOLUMEUP        0xB0    /* Volume + */
+#define DIK_WEBHOME         0xB2    /* Web home */
+#define DIK_NUMPADCOMMA     0xB3    /* , on numeric keypad (NEC PC98) */
+#define DIK_DIVIDE          0xB5    /* / on numeric keypad */
+#define DIK_SYSRQ           0xB7
+#define DIK_RMENU           0xB8    /* right Alt */
+#define DIK_PAUSE           0xC5    /* Pause */
+#define DIK_HOME            0xC7    /* Home on arrow keypad */
+#define DIK_UP              0xC8    /* UpArrow on arrow keypad */
+#define DIK_PRIOR           0xC9    /* PgUp on arrow keypad */
+#define DIK_LEFT            0xCB    /* LeftArrow on arrow keypad */
+#define DIK_RIGHT           0xCD    /* RightArrow on arrow keypad */
+#define DIK_END             0xCF    /* End on arrow keypad */
+#define DIK_DOWN            0xD0    /* DownArrow on arrow keypad */
+#define DIK_NEXT            0xD1    /* PgDn on arrow keypad */
+#define DIK_INSERT          0xD2    /* Insert on arrow keypad */
+#define DIK_DELETE          0xD3    /* Delete on arrow keypad */
+#define DIK_LWIN            0xDB    /* Left Windows key */
+#define DIK_RWIN            0xDC    /* Right Windows key */
+#define DIK_APPS            0xDD    /* AppMenu key */
+#define DIK_POWER           0xDE    /* System Power */
+#define DIK_SLEEP           0xDF    /* System Sleep */
+#define DIK_WAKE            0xE3    /* System Wake */
+#define DIK_WEBSEARCH       0xE5    /* Web Search */
+#define DIK_WEBFAVORITES    0xE6    /* Web Favorites */
+#define DIK_WEBREFRESH      0xE7    /* Web Refresh */
+#define DIK_WEBSTOP         0xE8    /* Web Stop */
+#define DIK_WEBFORWARD      0xE9    /* Web Forward */
+#define DIK_WEBBACK         0xEA    /* Web Back */
+#define DIK_MYCOMPUTER      0xEB    /* My Computer */
+#define DIK_MAIL            0xEC    /* Mail */
+#define DIK_MEDIASELECT     0xED    /* Media Select */
+
+/*
+ *  Alternate names for keys, to facilitate transition from DOS.
+ */
+#define DIK_BACKSPACE       DIK_BACK            /* backspace */
+#define DIK_NUMPADSTAR      DIK_MULTIPLY        /* * on numeric keypad */
+#define DIK_LALT            DIK_LMENU           /* left Alt */
+#define DIK_CAPSLOCK        DIK_CAPITAL         /* CapsLock */
+#define DIK_NUMPADMINUS     DIK_SUBTRACT        /* - on numeric keypad */
+#define DIK_NUMPADPLUS      DIK_ADD             /* + on numeric keypad */
+#define DIK_NUMPADPERIOD    DIK_DECIMAL         /* . on numeric keypad */
+#define DIK_NUMPADSLASH     DIK_DIVIDE          /* / on numeric keypad */
+#define DIK_RALT            DIK_RMENU           /* right Alt */
+#define DIK_UPARROW         DIK_UP              /* UpArrow on arrow keypad */
+#define DIK_PGUP            DIK_PRIOR           /* PgUp on arrow keypad */
+#define DIK_LEFTARROW       DIK_LEFT            /* LeftArrow on arrow keypad */
+#define DIK_RIGHTARROW      DIK_RIGHT           /* RightArrow on arrow keypad */
+#define DIK_DOWNARROW       DIK_DOWN            /* DownArrow on arrow keypad */
+#define DIK_PGDN            DIK_NEXT            /* PgDn on arrow keypad */
+
+/*
+ *  Alternate names for keys originally not used on US keyboards.
+ */
+#define DIK_CIRCUMFLEX      DIK_PREVTRACK       /* Japanese keyboard */
+
+#endif /* DIJ_RINGZERO */
+
+/****************************************************************************
+ *
+ *      Joystick
+ *
+ ****************************************************************************/
+
+#ifndef DIJ_RINGZERO
+
+typedef struct DIJOYSTATE {
+    LONG    lX;                     /* x-axis position              */
+    LONG    lY;                     /* y-axis position              */
+    LONG    lZ;                     /* z-axis position              */
+    LONG    lRx;                    /* x-axis rotation              */
+    LONG    lRy;                    /* y-axis rotation              */
+    LONG    lRz;                    /* z-axis rotation              */
+    LONG    rglSlider[2];           /* extra axes positions         */
+    DWORD   rgdwPOV[4];             /* POV directions               */
+    BYTE    rgbButtons[32];         /* 32 buttons                   */
+} DIJOYSTATE, *LPDIJOYSTATE;
+
+typedef struct DIJOYSTATE2 {
+    LONG    lX;                     /* x-axis position              */
+    LONG    lY;                     /* y-axis position              */
+    LONG    lZ;                     /* z-axis position              */
+    LONG    lRx;                    /* x-axis rotation              */
+    LONG    lRy;                    /* y-axis rotation              */
+    LONG    lRz;                    /* z-axis rotation              */
+    LONG    rglSlider[2];           /* extra axes positions         */
+    DWORD   rgdwPOV[4];             /* POV directions               */
+    BYTE    rgbButtons[128];        /* 128 buttons                  */
+    LONG    lVX;                    /* x-axis velocity              */
+    LONG    lVY;                    /* y-axis velocity              */
+    LONG    lVZ;                    /* z-axis velocity              */
+    LONG    lVRx;                   /* x-axis angular velocity      */
+    LONG    lVRy;                   /* y-axis angular velocity      */
+    LONG    lVRz;                   /* z-axis angular velocity      */
+    LONG    rglVSlider[2];          /* extra axes velocities        */
+    LONG    lAX;                    /* x-axis acceleration          */
+    LONG    lAY;                    /* y-axis acceleration          */
+    LONG    lAZ;                    /* z-axis acceleration          */
+    LONG    lARx;                   /* x-axis angular acceleration  */
+    LONG    lARy;                   /* y-axis angular acceleration  */
+    LONG    lARz;                   /* z-axis angular acceleration  */
+    LONG    rglASlider[2];          /* extra axes accelerations     */
+    LONG    lFX;                    /* x-axis force                 */
+    LONG    lFY;                    /* y-axis force                 */
+    LONG    lFZ;                    /* z-axis force                 */
+    LONG    lFRx;                   /* x-axis torque                */
+    LONG    lFRy;                   /* y-axis torque                */
+    LONG    lFRz;                   /* z-axis torque                */
+    LONG    rglFSlider[2];          /* extra axes forces            */
+} DIJOYSTATE2, *LPDIJOYSTATE2;
+
+#define DIJOFS_X            FIELD_OFFSET(DIJOYSTATE, lX)
+#define DIJOFS_Y            FIELD_OFFSET(DIJOYSTATE, lY)
+#define DIJOFS_Z            FIELD_OFFSET(DIJOYSTATE, lZ)
+#define DIJOFS_RX           FIELD_OFFSET(DIJOYSTATE, lRx)
+#define DIJOFS_RY           FIELD_OFFSET(DIJOYSTATE, lRy)
+#define DIJOFS_RZ           FIELD_OFFSET(DIJOYSTATE, lRz)
+#define DIJOFS_SLIDER(n)   (FIELD_OFFSET(DIJOYSTATE, rglSlider) + \
+                                                        (n) * sizeof(LONG))
+#define DIJOFS_POV(n)      (FIELD_OFFSET(DIJOYSTATE, rgdwPOV) + \
+                                                        (n) * sizeof(DWORD))
+#define DIJOFS_BUTTON(n)   (FIELD_OFFSET(DIJOYSTATE, rgbButtons) + (n))
+#define DIJOFS_BUTTON0      DIJOFS_BUTTON(0)
+#define DIJOFS_BUTTON1      DIJOFS_BUTTON(1)
+#define DIJOFS_BUTTON2      DIJOFS_BUTTON(2)
+#define DIJOFS_BUTTON3      DIJOFS_BUTTON(3)
+#define DIJOFS_BUTTON4      DIJOFS_BUTTON(4)
+#define DIJOFS_BUTTON5      DIJOFS_BUTTON(5)
+#define DIJOFS_BUTTON6      DIJOFS_BUTTON(6)
+#define DIJOFS_BUTTON7      DIJOFS_BUTTON(7)
+#define DIJOFS_BUTTON8      DIJOFS_BUTTON(8)
+#define DIJOFS_BUTTON9      DIJOFS_BUTTON(9)
+#define DIJOFS_BUTTON10     DIJOFS_BUTTON(10)
+#define DIJOFS_BUTTON11     DIJOFS_BUTTON(11)
+#define DIJOFS_BUTTON12     DIJOFS_BUTTON(12)
+#define DIJOFS_BUTTON13     DIJOFS_BUTTON(13)
+#define DIJOFS_BUTTON14     DIJOFS_BUTTON(14)
+#define DIJOFS_BUTTON15     DIJOFS_BUTTON(15)
+#define DIJOFS_BUTTON16     DIJOFS_BUTTON(16)
+#define DIJOFS_BUTTON17     DIJOFS_BUTTON(17)
+#define DIJOFS_BUTTON18     DIJOFS_BUTTON(18)
+#define DIJOFS_BUTTON19     DIJOFS_BUTTON(19)
+#define DIJOFS_BUTTON20     DIJOFS_BUTTON(20)
+#define DIJOFS_BUTTON21     DIJOFS_BUTTON(21)
+#define DIJOFS_BUTTON22     DIJOFS_BUTTON(22)
+#define DIJOFS_BUTTON23     DIJOFS_BUTTON(23)
+#define DIJOFS_BUTTON24     DIJOFS_BUTTON(24)
+#define DIJOFS_BUTTON25     DIJOFS_BUTTON(25)
+#define DIJOFS_BUTTON26     DIJOFS_BUTTON(26)
+#define DIJOFS_BUTTON27     DIJOFS_BUTTON(27)
+#define DIJOFS_BUTTON28     DIJOFS_BUTTON(28)
+#define DIJOFS_BUTTON29     DIJOFS_BUTTON(29)
+#define DIJOFS_BUTTON30     DIJOFS_BUTTON(30)
+#define DIJOFS_BUTTON31     DIJOFS_BUTTON(31)
+
+
+#endif /* DIJ_RINGZERO */
+
+/****************************************************************************
+ *
+ *  IDirectInput
+ *
+ ****************************************************************************/
+
+#ifndef DIJ_RINGZERO
+
+#define DIENUM_STOP             0
+#define DIENUM_CONTINUE         1
+
+typedef BOOL (FAR PASCAL * LPDIENUMDEVICESCALLBACKA)(LPCDIDEVICEINSTANCEA, LPVOID);
+typedef BOOL (FAR PASCAL * LPDIENUMDEVICESCALLBACKW)(LPCDIDEVICEINSTANCEW, LPVOID);
+#ifdef UNICODE
+#define LPDIENUMDEVICESCALLBACK  LPDIENUMDEVICESCALLBACKW
+#else
+#define LPDIENUMDEVICESCALLBACK  LPDIENUMDEVICESCALLBACKA
+#endif // !UNICODE
+typedef BOOL (FAR PASCAL * LPDICONFIGUREDEVICESCALLBACK)(IUnknown FAR *, LPVOID);
+
+#define DIEDFL_ALLDEVICES       0x00000000
+#define DIEDFL_ATTACHEDONLY     0x00000001
+#if(DIRECTINPUT_VERSION >= 0x0500)
+#define DIEDFL_FORCEFEEDBACK    0x00000100
+#endif /* DIRECTINPUT_VERSION >= 0x0500 */
+#if(DIRECTINPUT_VERSION >= 0x050a)
+#define DIEDFL_INCLUDEALIASES   0x00010000
+#define DIEDFL_INCLUDEPHANTOMS  0x00020000
+#endif /* DIRECTINPUT_VERSION >= 0x050a */
+#if(DIRECTINPUT_VERSION >= 0x0800)
+#define DIEDFL_INCLUDEHIDDEN    0x00040000
+#endif /* DIRECTINPUT_VERSION >= 0x0800 */
+
+
+#if(DIRECTINPUT_VERSION >= 0x0800)
+typedef BOOL (FAR PASCAL * LPDIENUMDEVICESBYSEMANTICSCBA)(LPCDIDEVICEINSTANCEA, LPDIRECTINPUTDEVICE8A, DWORD, DWORD, LPVOID);
+typedef BOOL (FAR PASCAL * LPDIENUMDEVICESBYSEMANTICSCBW)(LPCDIDEVICEINSTANCEW, LPDIRECTINPUTDEVICE8W, DWORD, DWORD, LPVOID);
+#ifdef UNICODE
+#define LPDIENUMDEVICESBYSEMANTICSCB  LPDIENUMDEVICESBYSEMANTICSCBW
+#else
+#define LPDIENUMDEVICESBYSEMANTICSCB  LPDIENUMDEVICESBYSEMANTICSCBA
+#endif // !UNICODE
+#endif /* DIRECTINPUT_VERSION >= 0x0800 */
+
+#if(DIRECTINPUT_VERSION >= 0x0800)
+#define DIEDBS_MAPPEDPRI1         0x00000001
+#define DIEDBS_MAPPEDPRI2         0x00000002
+#define DIEDBS_RECENTDEVICE       0x00000010
+#define DIEDBS_NEWDEVICE          0x00000020
+#endif /* DIRECTINPUT_VERSION >= 0x0800 */
+
+#if(DIRECTINPUT_VERSION >= 0x0800)
+#define DIEDBSFL_ATTACHEDONLY       0x00000000
+#define DIEDBSFL_THISUSER           0x00000010
+#define DIEDBSFL_FORCEFEEDBACK      DIEDFL_FORCEFEEDBACK
+#define DIEDBSFL_AVAILABLEDEVICES   0x00001000
+#define DIEDBSFL_MULTIMICEKEYBOARDS 0x00002000
+#define DIEDBSFL_NONGAMINGDEVICES   0x00004000
+#define DIEDBSFL_VALID              0x00007110
+#endif /* DIRECTINPUT_VERSION >= 0x0800 */
+
+#undef INTERFACE
+#define INTERFACE IDirectInputW
+
+DECLARE_INTERFACE_(IDirectInputW, IUnknown)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInputW methods ***/
+    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEW *,LPUNKNOWN) PURE;
+    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKW,LPVOID,DWORD) PURE;
+    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
+};
+
+typedef struct IDirectInputW *LPDIRECTINPUTW;
+
+#undef INTERFACE
+#define INTERFACE IDirectInputA
+
+DECLARE_INTERFACE_(IDirectInputA, IUnknown)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInputA methods ***/
+    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEA *,LPUNKNOWN) PURE;
+    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKA,LPVOID,DWORD) PURE;
+    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
+};
+
+typedef struct IDirectInputA *LPDIRECTINPUTA;
+
+#ifdef UNICODE
+#define IID_IDirectInput IID_IDirectInputW
+#define IDirectInput IDirectInputW
+#define IDirectInputVtbl IDirectInputWVtbl
+#else
+#define IID_IDirectInput IID_IDirectInputA
+#define IDirectInput IDirectInputA
+#define IDirectInputVtbl IDirectInputAVtbl
+#endif
+typedef struct IDirectInput *LPDIRECTINPUT;
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectInput_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectInput_AddRef(p) (p)->lpVtbl->AddRef(p)
+#define IDirectInput_Release(p) (p)->lpVtbl->Release(p)
+#define IDirectInput_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
+#define IDirectInput_EnumDevices(p,a,b,c,d) (p)->lpVtbl->EnumDevices(p,a,b,c,d)
+#define IDirectInput_GetDeviceStatus(p,a) (p)->lpVtbl->GetDeviceStatus(p,a)
+#define IDirectInput_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
+#define IDirectInput_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
+#else
+#define IDirectInput_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
+#define IDirectInput_AddRef(p) (p)->AddRef()
+#define IDirectInput_Release(p) (p)->Release()
+#define IDirectInput_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
+#define IDirectInput_EnumDevices(p,a,b,c,d) (p)->EnumDevices(a,b,c,d)
+#define IDirectInput_GetDeviceStatus(p,a) (p)->GetDeviceStatus(a)
+#define IDirectInput_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
+#define IDirectInput_Initialize(p,a,b) (p)->Initialize(a,b)
+#endif
+
+#undef INTERFACE
+#define INTERFACE IDirectInput2W
+
+DECLARE_INTERFACE_(IDirectInput2W, IDirectInputW)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInputW methods ***/
+    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEW *,LPUNKNOWN) PURE;
+    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKW,LPVOID,DWORD) PURE;
+    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
+
+    /*** IDirectInput2W methods ***/
+    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCWSTR,LPGUID) PURE;
+};
+
+typedef struct IDirectInput2W *LPDIRECTINPUT2W;
+
+#undef INTERFACE
+#define INTERFACE IDirectInput2A
+
+DECLARE_INTERFACE_(IDirectInput2A, IDirectInputA)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInputA methods ***/
+    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEA *,LPUNKNOWN) PURE;
+    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKA,LPVOID,DWORD) PURE;
+    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
+
+    /*** IDirectInput2A methods ***/
+    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCSTR,LPGUID) PURE;
+};
+
+typedef struct IDirectInput2A *LPDIRECTINPUT2A;
+
+#ifdef UNICODE
+#define IID_IDirectInput2 IID_IDirectInput2W
+#define IDirectInput2 IDirectInput2W
+#define IDirectInput2Vtbl IDirectInput2WVtbl
+#else
+#define IID_IDirectInput2 IID_IDirectInput2A
+#define IDirectInput2 IDirectInput2A
+#define IDirectInput2Vtbl IDirectInput2AVtbl
+#endif
+typedef struct IDirectInput2 *LPDIRECTINPUT2;
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectInput2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectInput2_AddRef(p) (p)->lpVtbl->AddRef(p)
+#define IDirectInput2_Release(p) (p)->lpVtbl->Release(p)
+#define IDirectInput2_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
+#define IDirectInput2_EnumDevices(p,a,b,c,d) (p)->lpVtbl->EnumDevices(p,a,b,c,d)
+#define IDirectInput2_GetDeviceStatus(p,a) (p)->lpVtbl->GetDeviceStatus(p,a)
+#define IDirectInput2_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
+#define IDirectInput2_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
+#define IDirectInput2_FindDevice(p,a,b,c) (p)->lpVtbl->FindDevice(p,a,b,c)
+#else
+#define IDirectInput2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
+#define IDirectInput2_AddRef(p) (p)->AddRef()
+#define IDirectInput2_Release(p) (p)->Release()
+#define IDirectInput2_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
+#define IDirectInput2_EnumDevices(p,a,b,c,d) (p)->EnumDevices(a,b,c,d)
+#define IDirectInput2_GetDeviceStatus(p,a) (p)->GetDeviceStatus(a)
+#define IDirectInput2_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
+#define IDirectInput2_Initialize(p,a,b) (p)->Initialize(a,b)
+#define IDirectInput2_FindDevice(p,a,b,c) (p)->FindDevice(a,b,c)
+#endif
+
+
+#undef INTERFACE
+#define INTERFACE IDirectInput7W
+
+DECLARE_INTERFACE_(IDirectInput7W, IDirectInput2W)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInput2W methods ***/
+    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEW *,LPUNKNOWN) PURE;
+    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKW,LPVOID,DWORD) PURE;
+    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
+    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCWSTR,LPGUID) PURE;
+
+    /*** IDirectInput7W methods ***/
+    STDMETHOD(CreateDeviceEx)(THIS_ REFGUID,REFIID,LPVOID *,LPUNKNOWN) PURE;
+};
+
+typedef struct IDirectInput7W *LPDIRECTINPUT7W;
+
+#undef INTERFACE
+#define INTERFACE IDirectInput7A
+
+DECLARE_INTERFACE_(IDirectInput7A, IDirectInput2A)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInput2A methods ***/
+    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEA *,LPUNKNOWN) PURE;
+    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKA,LPVOID,DWORD) PURE;
+    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
+    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCSTR,LPGUID) PURE;
+
+    /*** IDirectInput7A methods ***/
+    STDMETHOD(CreateDeviceEx)(THIS_ REFGUID,REFIID,LPVOID *,LPUNKNOWN) PURE;
+};
+
+typedef struct IDirectInput7A *LPDIRECTINPUT7A;
+
+#ifdef UNICODE
+#define IID_IDirectInput7 IID_IDirectInput7W
+#define IDirectInput7 IDirectInput7W
+#define IDirectInput7Vtbl IDirectInput7WVtbl
+#else
+#define IID_IDirectInput7 IID_IDirectInput7A
+#define IDirectInput7 IDirectInput7A
+#define IDirectInput7Vtbl IDirectInput7AVtbl
+#endif
+typedef struct IDirectInput7 *LPDIRECTINPUT7;
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectInput7_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectInput7_AddRef(p) (p)->lpVtbl->AddRef(p)
+#define IDirectInput7_Release(p) (p)->lpVtbl->Release(p)
+#define IDirectInput7_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
+#define IDirectInput7_EnumDevices(p,a,b,c,d) (p)->lpVtbl->EnumDevices(p,a,b,c,d)
+#define IDirectInput7_GetDeviceStatus(p,a) (p)->lpVtbl->GetDeviceStatus(p,a)
+#define IDirectInput7_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
+#define IDirectInput7_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
+#define IDirectInput7_FindDevice(p,a,b,c) (p)->lpVtbl->FindDevice(p,a,b,c)
+#define IDirectInput7_CreateDeviceEx(p,a,b,c,d) (p)->lpVtbl->CreateDeviceEx(p,a,b,c,d)
+#else
+#define IDirectInput7_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
+#define IDirectInput7_AddRef(p) (p)->AddRef()
+#define IDirectInput7_Release(p) (p)->Release()
+#define IDirectInput7_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
+#define IDirectInput7_EnumDevices(p,a,b,c,d) (p)->EnumDevices(a,b,c,d)
+#define IDirectInput7_GetDeviceStatus(p,a) (p)->GetDeviceStatus(a)
+#define IDirectInput7_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
+#define IDirectInput7_Initialize(p,a,b) (p)->Initialize(a,b)
+#define IDirectInput7_FindDevice(p,a,b,c) (p)->FindDevice(a,b,c)
+#define IDirectInput7_CreateDeviceEx(p,a,b,c,d) (p)->CreateDeviceEx(a,b,c,d)
+#endif
+
+#if(DIRECTINPUT_VERSION >= 0x0800)
+#undef INTERFACE
+#define INTERFACE IDirectInput8W
+
+DECLARE_INTERFACE_(IDirectInput8W, IUnknown)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInput8W methods ***/
+    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICE8W *,LPUNKNOWN) PURE;
+    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKW,LPVOID,DWORD) PURE;
+    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
+    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCWSTR,LPGUID) PURE;
+    STDMETHOD(EnumDevicesBySemantics)(THIS_ LPCWSTR,LPDIACTIONFORMATW,LPDIENUMDEVICESBYSEMANTICSCBW,LPVOID,DWORD) PURE;
+    STDMETHOD(ConfigureDevices)(THIS_ LPDICONFIGUREDEVICESCALLBACK,LPDICONFIGUREDEVICESPARAMSW,DWORD,LPVOID) PURE;
+};
+
+typedef struct IDirectInput8W *LPDIRECTINPUT8W;
+
+#undef INTERFACE
+#define INTERFACE IDirectInput8A
+
+DECLARE_INTERFACE_(IDirectInput8A, IUnknown)
+{
+    /*** IUnknown methods ***/
+    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
+    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+    STDMETHOD_(ULONG,Release)(THIS) PURE;
+
+    /*** IDirectInput8A methods ***/
+    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICE8A *,LPUNKNOWN) PURE;
+    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKA,LPVOID,DWORD) PURE;
+    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
+    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
+    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
+    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCSTR,LPGUID) PURE;
+    STDMETHOD(EnumDevicesBySemantics)(THIS_ LPCSTR,LPDIACTIONFORMATA,LPDIENUMDEVICESBYSEMANTICSCBA,LPVOID,DWORD) PURE;
+    STDMETHOD(ConfigureDevices)(THIS_ LPDICONFIGUREDEVICESCALLBACK,LPDICONFIGUREDEVICESPARAMSA,DWORD,LPVOID) PURE;
+};
+
+typedef struct IDirectInput8A *LPDIRECTINPUT8A;
+
+#ifdef UNICODE
+#define IID_IDirectInput8 IID_IDirectInput8W
+#define IDirectInput8 IDirectInput8W
+#define IDirectInput8Vtbl IDirectInput8WVtbl
+#else
+#define IID_IDirectInput8 IID_IDirectInput8A
+#define IDirectInput8 IDirectInput8A
+#define IDirectInput8Vtbl IDirectInput8AVtbl
+#endif
+typedef struct IDirectInput8 *LPDIRECTINPUT8;
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectInput8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectInput8_AddRef(p) (p)->lpVtbl->AddRef(p)
+#define IDirectInput8_Release(p) (p)->lpVtbl->Release(p)
+#define IDirectInput8_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
+#define IDirectInput8_EnumDevices(p,a,b,c,d) (p)->lpVtbl->EnumDevices(p,a,b,c,d)
+#define IDirectInput8_GetDeviceStatus(p,a) (p)->lpVtbl->GetDeviceStatus(p,a)
+#define IDirectInput8_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
+#define IDirectInput8_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
+#define IDirectInput8_FindDevice(p,a,b,c) (p)->lpVtbl->FindDevice(p,a,b,c)
+#define IDirectInput8_EnumDevicesBySemantics(p,a,b,c,d,e) (p)->lpVtbl->EnumDevicesBySemantics(p,a,b,c,d,e)
+#define IDirectInput8_ConfigureDevices(p,a,b,c,d) (p)->lpVtbl->ConfigureDevices(p,a,b,c,d)
+#else
+#define IDirectInput8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
+#define IDirectInput8_AddRef(p) (p)->AddRef()
+#define IDirectInput8_Release(p) (p)->Release()
+#define IDirectInput8_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
+#define IDirectInput8_EnumDevices(p,a,b,c,d) (p)->EnumDevices(a,b,c,d)
+#define IDirectInput8_GetDeviceStatus(p,a) (p)->GetDeviceStatus(a)
+#define IDirectInput8_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
+#define IDirectInput8_Initialize(p,a,b) (p)->Initialize(a,b)
+#define IDirectInput8_FindDevice(p,a,b,c) (p)->FindDevice(a,b,c)
+#define IDirectInput8_EnumDevicesBySemantics(p,a,b,c,d,e) (p)->EnumDevicesBySemantics(a,b,c,d,e)
+#define IDirectInput8_ConfigureDevices(p,a,b,c,d) (p)->ConfigureDevices(a,b,c,d)
+#endif
+#endif /* DIRECTINPUT_VERSION >= 0x0800 */
+
+#if DIRECTINPUT_VERSION > 0x0700
+
+extern HRESULT WINAPI DirectInput8Create(HINSTANCE hinst, DWORD dwVersion, REFIID riidltf, LPVOID *ppvOut, LPUNKNOWN punkOuter);
+
+#else
+extern HRESULT WINAPI DirectInputCreateA(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTA *ppDI, LPUNKNOWN punkOuter);
+extern HRESULT WINAPI DirectInputCreateW(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTW *ppDI, LPUNKNOWN punkOuter);
+#ifdef UNICODE
+#define DirectInputCreate  DirectInputCreateW
+#else
+#define DirectInputCreate  DirectInputCreateA
+#endif // !UNICODE
+
+extern HRESULT WINAPI DirectInputCreateEx(HINSTANCE hinst, DWORD dwVersion, REFIID riidltf, LPVOID *ppvOut, LPUNKNOWN punkOuter);
+
+#endif /* DIRECTINPUT_VERSION > 0x700 */
+
+#endif /* DIJ_RINGZERO */
+
+
+/****************************************************************************
+ *
+ *  Return Codes
+ *
+ ****************************************************************************/
+
+/*
+ *  The operation completed successfully.
+ */
+#define DI_OK                           S_OK
+
+/*
+ *  The device exists but is not currently attached.
+ */
+#define DI_NOTATTACHED                  S_FALSE
+
+/*
+ *  The device buffer overflowed.  Some input was lost.
+ */
+#define DI_BUFFEROVERFLOW               S_FALSE
+
+/*
+ *  The change in device properties had no effect.
+ */
+#define DI_PROPNOEFFECT                 S_FALSE
+
+/*
+ *  The operation had no effect.
+ */
+#define DI_NOEFFECT                     S_FALSE
+
+/*
+ *  The device is a polled device.  As a result, device buffering
+ *  will not collect any data and event notifications will not be
+ *  signalled until GetDeviceState is called.
+ */
+#define DI_POLLEDDEVICE                 ((HRESULT)0x00000002L)
+
+/*
+ *  The parameters of the effect were successfully updated by
+ *  IDirectInputEffect::SetParameters, but the effect was not
+ *  downloaded because the device is not exclusively acquired
+ *  or because the DIEP_NODOWNLOAD flag was passed.
+ */
+#define DI_DOWNLOADSKIPPED              ((HRESULT)0x00000003L)
+
+/*
+ *  The parameters of the effect were successfully updated by
+ *  IDirectInputEffect::SetParameters, but in order to change
+ *  the parameters, the effect needed to be restarted.
+ */
+#define DI_EFFECTRESTARTED              ((HRESULT)0x00000004L)
+
+/*
+ *  The parameters of the effect were successfully updated by
+ *  IDirectInputEffect::SetParameters, but some of them were
+ *  beyond the capabilities of the device and were truncated.
+ */
+#define DI_TRUNCATED                    ((HRESULT)0x00000008L)
+
+/*
+ *  The settings have been successfully applied but could not be 
+ *  persisted. 
+ */
+#define DI_SETTINGSNOTSAVED				((HRESULT)0x0000000BL)
+
+/*
+ *  Equal to DI_EFFECTRESTARTED | DI_TRUNCATED.
+ */
+#define DI_TRUNCATEDANDRESTARTED        ((HRESULT)0x0000000CL)
+
+/*
+ *  A SUCCESS code indicating that settings cannot be modified.
+ */
+#define DI_WRITEPROTECT                 ((HRESULT)0x00000013L)
+
+/*
+ *  The application requires a newer version of DirectInput.
+ */
+#define DIERR_OLDDIRECTINPUTVERSION     \
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_OLD_WIN_VERSION)
+
+/*
+ *  The application was written for an unsupported prerelease version
+ *  of DirectInput.
+ */
+#define DIERR_BETADIRECTINPUTVERSION    \
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_RMODE_APP)
+
+/*
+ *  The object could not be created due to an incompatible driver version
+ *  or mismatched or incomplete driver components.
+ */
+#define DIERR_BADDRIVERVER              \
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_BAD_DRIVER_LEVEL)
+
+/*
+ * The device or device instance or effect is not registered with DirectInput.
+ */
+#define DIERR_DEVICENOTREG              REGDB_E_CLASSNOTREG
+
+/*
+ * The requested object does not exist.
+ */
+#define DIERR_NOTFOUND                  \
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)
+
+/*
+ * The requested object does not exist.
+ */
+#define DIERR_OBJECTNOTFOUND            \
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)
+
+/*
+ * An invalid parameter was passed to the returning function,
+ * or the object was not in a state that admitted the function
+ * to be called.
+ */
+#define DIERR_INVALIDPARAM              E_INVALIDARG
+
+/*
+ * The specified interface is not supported by the object
+ */
+#define DIERR_NOINTERFACE               E_NOINTERFACE
+
+/*
+ * An undetermined error occured inside the DInput subsystem
+ */
+#define DIERR_GENERIC                   E_FAIL
+
+/*
+ * The DInput subsystem couldn't allocate sufficient memory to complete the
+ * caller's request.
+ */
+#define DIERR_OUTOFMEMORY               E_OUTOFMEMORY
+
+/*
+ * The function called is not supported at this time
+ */
+#define DIERR_UNSUPPORTED               E_NOTIMPL
+
+/*
+ * This object has not been initialized
+ */
+#define DIERR_NOTINITIALIZED            \
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NOT_READY)
+
+/*
+ * This object is already initialized
+ */
+#define DIERR_ALREADYINITIALIZED        \
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_ALREADY_INITIALIZED)
+
+/*
+ * This object does not support aggregation
+ */
+#define DIERR_NOAGGREGATION             CLASS_E_NOAGGREGATION
+
+/*
+ * Another app has a higher priority level, preventing this call from
+ * succeeding.
+ */
+#define DIERR_OTHERAPPHASPRIO           E_ACCESSDENIED
+
+/*
+ * Access to the device has been lost.  It must be re-acquired.
+ */
+#define DIERR_INPUTLOST                 \
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_READ_FAULT)
+
+/*
+ * The operation cannot be performed while the device is acquired.
+ */
+#define DIERR_ACQUIRED                  \
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_BUSY)
+
+/*
+ * The operation cannot be performed unless the device is acquired.
+ */
+#define DIERR_NOTACQUIRED               \
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_ACCESS)
+
+/*
+ * The specified property cannot be changed.
+ */
+#define DIERR_READONLY                  E_ACCESSDENIED
+
+/*
+ * The device already has an event notification associated with it.
+ */
+#define DIERR_HANDLEEXISTS              E_ACCESSDENIED
+
+/*
+ * Data is not yet available.
+ */
+#ifndef E_PENDING
+#define E_PENDING                       0x8000000AL
+#endif
+
+/*
+ * Unable to IDirectInputJoyConfig_Acquire because the user
+ * does not have sufficient privileges to change the joystick
+ * configuration.
+ */
+#define DIERR_INSUFFICIENTPRIVS         0x80040200L
+
+/*
+ * The device is full.
+ */
+#define DIERR_DEVICEFULL                0x80040201L
+
+/*
+ * Not all the requested information fit into the buffer.
+ */
+#define DIERR_MOREDATA                  0x80040202L
+
+/*
+ * The effect is not downloaded.
+ */
+#define DIERR_NOTDOWNLOADED             0x80040203L
+
+/*
+ *  The device cannot be reinitialized because there are still effects
+ *  attached to it.
+ */
+#define DIERR_HASEFFECTS                0x80040204L
+
+/*
+ *  The operation cannot be performed unless the device is acquired
+ *  in DISCL_EXCLUSIVE mode.
+ */
+#define DIERR_NOTEXCLUSIVEACQUIRED      0x80040205L
+
+/*
+ *  The effect could not be downloaded because essential information
+ *  is missing.  For example, no axes have been associated with the
+ *  effect, or no type-specific information has been created.
+ */
+#define DIERR_INCOMPLETEEFFECT          0x80040206L
+
+/*
+ *  Attempted to read buffered device data from a device that is
+ *  not buffered.
+ */
+#define DIERR_NOTBUFFERED               0x80040207L
+
+/*
+ *  An attempt was made to modify parameters of an effect while it is
+ *  playing.  Not all hardware devices support altering the parameters
+ *  of an effect while it is playing.
+ */
+#define DIERR_EFFECTPLAYING             0x80040208L
+
+/*
+ *  The operation could not be completed because the device is not
+ *  plugged in.
+ */
+#define DIERR_UNPLUGGED                 0x80040209L
+
+/*
+ *  SendDeviceData failed because more information was requested
+ *  to be sent than can be sent to the device.  Some devices have
+ *  restrictions on how much data can be sent to them.  (For example,
+ *  there might be a limit on the number of buttons that can be
+ *  pressed at once.)
+ */
+#define DIERR_REPORTFULL                0x8004020AL
+
+
+/*
+ *  A mapper file function failed because reading or writing the user or IHV 
+ *  settings file failed.
+ */
+#define DIERR_MAPFILEFAIL               0x8004020BL
+
+
+/*--- DINPUT Mapper Definitions: New for Dx8         ---*/
+
+
+/*--- Keyboard
+      Physical Keyboard Device       ---*/
+
+#define DIKEYBOARD_ESCAPE                       0x81000401
+#define DIKEYBOARD_1                            0x81000402
+#define DIKEYBOARD_2                            0x81000403
+#define DIKEYBOARD_3                            0x81000404
+#define DIKEYBOARD_4                            0x81000405
+#define DIKEYBOARD_5                            0x81000406
+#define DIKEYBOARD_6                            0x81000407
+#define DIKEYBOARD_7                            0x81000408
+#define DIKEYBOARD_8                            0x81000409
+#define DIKEYBOARD_9                            0x8100040A
+#define DIKEYBOARD_0                            0x8100040B
+#define DIKEYBOARD_MINUS                        0x8100040C    /* - on main keyboard */
+#define DIKEYBOARD_EQUALS                       0x8100040D
+#define DIKEYBOARD_BACK                         0x8100040E    /* backspace */
+#define DIKEYBOARD_TAB                          0x8100040F
+#define DIKEYBOARD_Q                            0x81000410
+#define DIKEYBOARD_W                            0x81000411
+#define DIKEYBOARD_E                            0x81000412
+#define DIKEYBOARD_R                            0x81000413
+#define DIKEYBOARD_T                            0x81000414
+#define DIKEYBOARD_Y                            0x81000415
+#define DIKEYBOARD_U                            0x81000416
+#define DIKEYBOARD_I                            0x81000417
+#define DIKEYBOARD_O                            0x81000418
+#define DIKEYBOARD_P                            0x81000419
+#define DIKEYBOARD_LBRACKET                     0x8100041A
+#define DIKEYBOARD_RBRACKET                     0x8100041B
+#define DIKEYBOARD_RETURN                       0x8100041C    /* Enter on main keyboard */
+#define DIKEYBOARD_LCONTROL                     0x8100041D
+#define DIKEYBOARD_A                            0x8100041E
+#define DIKEYBOARD_S                            0x8100041F
+#define DIKEYBOARD_D                            0x81000420
+#define DIKEYBOARD_F                            0x81000421
+#define DIKEYBOARD_G                            0x81000422
+#define DIKEYBOARD_H                            0x81000423
+#define DIKEYBOARD_J                            0x81000424
+#define DIKEYBOARD_K                            0x81000425
+#define DIKEYBOARD_L                            0x81000426
+#define DIKEYBOARD_SEMICOLON                    0x81000427
+#define DIKEYBOARD_APOSTROPHE                   0x81000428
+#define DIKEYBOARD_GRAVE                        0x81000429    /* accent grave */
+#define DIKEYBOARD_LSHIFT                       0x8100042A
+#define DIKEYBOARD_BACKSLASH                    0x8100042B
+#define DIKEYBOARD_Z                            0x8100042C
+#define DIKEYBOARD_X                            0x8100042D
+#define DIKEYBOARD_C                            0x8100042E
+#define DIKEYBOARD_V                            0x8100042F
+#define DIKEYBOARD_B                            0x81000430
+#define DIKEYBOARD_N                            0x81000431
+#define DIKEYBOARD_M                            0x81000432
+#define DIKEYBOARD_COMMA                        0x81000433
+#define DIKEYBOARD_PERIOD                       0x81000434    /* . on main keyboard */
+#define DIKEYBOARD_SLASH                        0x81000435    /* / on main keyboard */
+#define DIKEYBOARD_RSHIFT                       0x81000436
+#define DIKEYBOARD_MULTIPLY                     0x81000437    /* * on numeric keypad */
+#define DIKEYBOARD_LMENU                        0x81000438    /* left Alt */
+#define DIKEYBOARD_SPACE                        0x81000439
+#define DIKEYBOARD_CAPITAL                      0x8100043A
+#define DIKEYBOARD_F1                           0x8100043B
+#define DIKEYBOARD_F2                           0x8100043C
+#define DIKEYBOARD_F3                           0x8100043D
+#define DIKEYBOARD_F4                           0x8100043E
+#define DIKEYBOARD_F5                           0x8100043F
+#define DIKEYBOARD_F6                           0x81000440
+#define DIKEYBOARD_F7                           0x81000441
+#define DIKEYBOARD_F8                           0x81000442
+#define DIKEYBOARD_F9                           0x81000443
+#define DIKEYBOARD_F10                          0x81000444
+#define DIKEYBOARD_NUMLOCK                      0x81000445
+#define DIKEYBOARD_SCROLL                       0x81000446    /* Scroll Lock */
+#define DIKEYBOARD_NUMPAD7                      0x81000447
+#define DIKEYBOARD_NUMPAD8                      0x81000448
+#define DIKEYBOARD_NUMPAD9                      0x81000449
+#define DIKEYBOARD_SUBTRACT                     0x8100044A    /* - on numeric keypad */
+#define DIKEYBOARD_NUMPAD4                      0x8100044B
+#define DIKEYBOARD_NUMPAD5                      0x8100044C
+#define DIKEYBOARD_NUMPAD6                      0x8100044D
+#define DIKEYBOARD_ADD                          0x8100044E    /* + on numeric keypad */
+#define DIKEYBOARD_NUMPAD1                      0x8100044F
+#define DIKEYBOARD_NUMPAD2                      0x81000450
+#define DIKEYBOARD_NUMPAD3                      0x81000451
+#define DIKEYBOARD_NUMPAD0                      0x81000452
+#define DIKEYBOARD_DECIMAL                      0x81000453    /* . on numeric keypad */
+#define DIKEYBOARD_OEM_102                      0x81000456    /* <> or \| on RT 102-key keyboard (Non-U.S.) */
+#define DIKEYBOARD_F11                          0x81000457
+#define DIKEYBOARD_F12                          0x81000458
+#define DIKEYBOARD_F13                          0x81000464    /*                     (NEC PC98) */
+#define DIKEYBOARD_F14                          0x81000465    /*                     (NEC PC98) */
+#define DIKEYBOARD_F15                          0x81000466    /*                     (NEC PC98) */
+#define DIKEYBOARD_KANA                         0x81000470    /* (Japanese keyboard)            */
+#define DIKEYBOARD_ABNT_C1                      0x81000473    /* /? on Brazilian keyboard */
+#define DIKEYBOARD_CONVERT                      0x81000479    /* (Japanese keyboard)            */
+#define DIKEYBOARD_NOCONVERT                    0x8100047B    /* (Japanese keyboard)            */
+#define DIKEYBOARD_YEN                          0x8100047D    /* (Japanese keyboard)            */
+#define DIKEYBOARD_ABNT_C2                      0x8100047E    /* Numpad . on Brazilian keyboard */
+#define DIKEYBOARD_NUMPADEQUALS                 0x8100048D    /* = on numeric keypad (NEC PC98) */
+#define DIKEYBOARD_PREVTRACK                    0x81000490    /* Previous Track (DIK_CIRCUMFLEX on Japanese keyboard) */
+#define DIKEYBOARD_AT                           0x81000491    /*                     (NEC PC98) */
+#define DIKEYBOARD_COLON                        0x81000492    /*                     (NEC PC98) */
+#define DIKEYBOARD_UNDERLINE                    0x81000493    /*                     (NEC PC98) */
+#define DIKEYBOARD_KANJI                        0x81000494    /* (Japanese keyboard)            */
+#define DIKEYBOARD_STOP                         0x81000495    /*                     (NEC PC98) */
+#define DIKEYBOARD_AX                           0x81000496    /*                     (Japan AX) */
+#define DIKEYBOARD_UNLABELED                    0x81000497    /*                        (J3100) */
+#define DIKEYBOARD_NEXTTRACK                    0x81000499    /* Next Track */
+#define DIKEYBOARD_NUMPADENTER                  0x8100049C    /* Enter on numeric keypad */
+#define DIKEYBOARD_RCONTROL                     0x8100049D
+#define DIKEYBOARD_MUTE                         0x810004A0    /* Mute */
+#define DIKEYBOARD_CALCULATOR                   0x810004A1    /* Calculator */
+#define DIKEYBOARD_PLAYPAUSE                    0x810004A2    /* Play / Pause */
+#define DIKEYBOARD_MEDIASTOP                    0x810004A4    /* Media Stop */
+#define DIKEYBOARD_VOLUMEDOWN                   0x810004AE    /* Volume - */
+#define DIKEYBOARD_VOLUMEUP                     0x810004B0    /* Volume + */
+#define DIKEYBOARD_WEBHOME                      0x810004B2    /* Web home */
+#define DIKEYBOARD_NUMPADCOMMA                  0x810004B3    /* , on numeric keypad (NEC PC98) */
+#define DIKEYBOARD_DIVIDE                       0x810004B5    /* / on numeric keypad */
+#define DIKEYBOARD_SYSRQ                        0x810004B7
+#define DIKEYBOARD_RMENU                        0x810004B8    /* right Alt */
+#define DIKEYBOARD_PAUSE                        0x810004C5    /* Pause */
+#define DIKEYBOARD_HOME                         0x810004C7    /* Home on arrow keypad */
+#define DIKEYBOARD_UP                           0x810004C8    /* UpArrow on arrow keypad */
+#define DIKEYBOARD_PRIOR                        0x810004C9    /* PgUp on arrow keypad */
+#define DIKEYBOARD_LEFT                         0x810004CB    /* LeftArrow on arrow keypad */
+#define DIKEYBOARD_RIGHT                        0x810004CD    /* RightArrow on arrow keypad */
+#define DIKEYBOARD_END                          0x810004CF    /* End on arrow keypad */
+#define DIKEYBOARD_DOWN                         0x810004D0    /* DownArrow on arrow keypad */
+#define DIKEYBOARD_NEXT                         0x810004D1    /* PgDn on arrow keypad */
+#define DIKEYBOARD_INSERT                       0x810004D2    /* Insert on arrow keypad */
+#define DIKEYBOARD_DELETE                       0x810004D3    /* Delete on arrow keypad */
+#define DIKEYBOARD_LWIN                         0x810004DB    /* Left Windows key */
+#define DIKEYBOARD_RWIN                         0x810004DC    /* Right Windows key */
+#define DIKEYBOARD_APPS                         0x810004DD    /* AppMenu key */
+#define DIKEYBOARD_POWER                        0x810004DE    /* System Power */
+#define DIKEYBOARD_SLEEP                        0x810004DF    /* System Sleep */
+#define DIKEYBOARD_WAKE                         0x810004E3    /* System Wake */
+#define DIKEYBOARD_WEBSEARCH                    0x810004E5    /* Web Search */
+#define DIKEYBOARD_WEBFAVORITES                 0x810004E6    /* Web Favorites */
+#define DIKEYBOARD_WEBREFRESH                   0x810004E7    /* Web Refresh */
+#define DIKEYBOARD_WEBSTOP                      0x810004E8    /* Web Stop */
+#define DIKEYBOARD_WEBFORWARD                   0x810004E9    /* Web Forward */
+#define DIKEYBOARD_WEBBACK                      0x810004EA    /* Web Back */
+#define DIKEYBOARD_MYCOMPUTER                   0x810004EB    /* My Computer */
+#define DIKEYBOARD_MAIL                         0x810004EC    /* Mail */
+#define DIKEYBOARD_MEDIASELECT                  0x810004ED    /* Media Select */
+  
+
+/*--- MOUSE
+      Physical Mouse Device             ---*/
+
+#define DIMOUSE_XAXISAB                         (0x82000200 |DIMOFS_X ) /* X Axis-absolute: Some mice natively report absolute coordinates  */ 
+#define DIMOUSE_YAXISAB                         (0x82000200 |DIMOFS_Y ) /* Y Axis-absolute: Some mice natively report absolute coordinates */
+#define DIMOUSE_XAXIS                           (0x82000300 |DIMOFS_X ) /* X Axis */
+#define DIMOUSE_YAXIS                           (0x82000300 |DIMOFS_Y ) /* Y Axis */
+#define DIMOUSE_WHEEL                           (0x82000300 |DIMOFS_Z ) /* Z Axis */
+#define DIMOUSE_BUTTON0                         (0x82000400 |DIMOFS_BUTTON0) /* Button 0 */
+#define DIMOUSE_BUTTON1                         (0x82000400 |DIMOFS_BUTTON1) /* Button 1 */
+#define DIMOUSE_BUTTON2                         (0x82000400 |DIMOFS_BUTTON2) /* Button 2 */
+#define DIMOUSE_BUTTON3                         (0x82000400 |DIMOFS_BUTTON3) /* Button 3 */
+#define DIMOUSE_BUTTON4                         (0x82000400 |DIMOFS_BUTTON4) /* Button 4 */
+#define DIMOUSE_BUTTON5                         (0x82000400 |DIMOFS_BUTTON5) /* Button 5 */
+#define DIMOUSE_BUTTON6                         (0x82000400 |DIMOFS_BUTTON6) /* Button 6 */
+#define DIMOUSE_BUTTON7                         (0x82000400 |DIMOFS_BUTTON7) /* Button 7 */
+
+
+/*--- VOICE
+      Physical Dplay Voice Device       ---*/
+
+#define DIVOICE_CHANNEL1                        0x83000401
+#define DIVOICE_CHANNEL2                        0x83000402
+#define DIVOICE_CHANNEL3                        0x83000403
+#define DIVOICE_CHANNEL4                        0x83000404
+#define DIVOICE_CHANNEL5                        0x83000405
+#define DIVOICE_CHANNEL6                        0x83000406
+#define DIVOICE_CHANNEL7                        0x83000407
+#define DIVOICE_CHANNEL8                        0x83000408
+#define DIVOICE_TEAM                            0x83000409
+#define DIVOICE_ALL                             0x8300040A
+#define DIVOICE_RECORDMUTE                      0x8300040B
+#define DIVOICE_PLAYBACKMUTE                    0x8300040C
+#define DIVOICE_TRANSMIT                        0x8300040D
+
+#define DIVOICE_VOICECOMMAND                    0x83000410
+
+
+/*--- Driving Simulator - Racing
+      Vehicle control is primary objective  ---*/
+#define DIVIRTUAL_DRIVING_RACE                  0x01000000
+#define DIAXIS_DRIVINGR_STEER                   0x01008A01 /* Steering */
+#define DIAXIS_DRIVINGR_ACCELERATE              0x01039202 /* Accelerate */
+#define DIAXIS_DRIVINGR_BRAKE                   0x01041203 /* Brake-Axis */
+#define DIBUTTON_DRIVINGR_SHIFTUP               0x01000C01 /* Shift to next higher gear */
+#define DIBUTTON_DRIVINGR_SHIFTDOWN             0x01000C02 /* Shift to next lower gear */
+#define DIBUTTON_DRIVINGR_VIEW                  0x01001C03 /* Cycle through view options */
+#define DIBUTTON_DRIVINGR_MENU                  0x010004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIAXIS_DRIVINGR_ACCEL_AND_BRAKE         0x01014A04 /* Some devices combine accelerate and brake in a single axis */
+#define DIHATSWITCH_DRIVINGR_GLANCE             0x01004601 /* Look around */
+#define DIBUTTON_DRIVINGR_BRAKE                 0x01004C04 /* Brake-button */
+#define DIBUTTON_DRIVINGR_DASHBOARD             0x01004405 /* Select next dashboard option */
+#define DIBUTTON_DRIVINGR_AIDS                  0x01004406 /* Driver correction aids */
+#define DIBUTTON_DRIVINGR_MAP                   0x01004407 /* Display Driving Map */
+#define DIBUTTON_DRIVINGR_BOOST                 0x01004408 /* Turbo Boost */
+#define DIBUTTON_DRIVINGR_PIT                   0x01004409 /* Pit stop notification */
+#define DIBUTTON_DRIVINGR_ACCELERATE_LINK       0x0103D4E0 /* Fallback Accelerate button */
+#define DIBUTTON_DRIVINGR_STEER_LEFT_LINK       0x0100CCE4 /* Fallback Steer Left button */
+#define DIBUTTON_DRIVINGR_STEER_RIGHT_LINK      0x0100CCEC /* Fallback Steer Right button */
+#define DIBUTTON_DRIVINGR_GLANCE_LEFT_LINK      0x0107C4E4 /* Fallback Glance Left button */
+#define DIBUTTON_DRIVINGR_GLANCE_RIGHT_LINK     0x0107C4EC /* Fallback Glance Right button */
+#define DIBUTTON_DRIVINGR_DEVICE                0x010044FE /* Show input device and controls */
+#define DIBUTTON_DRIVINGR_PAUSE                 0x010044FC /* Start / Pause / Restart game */
+
+/*--- Driving Simulator - Combat
+      Combat from within a vehicle is primary objective  ---*/
+#define DIVIRTUAL_DRIVING_COMBAT                0x02000000
+#define DIAXIS_DRIVINGC_STEER                   0x02008A01 /* Steering  */
+#define DIAXIS_DRIVINGC_ACCELERATE              0x02039202 /* Accelerate */
+#define DIAXIS_DRIVINGC_BRAKE                   0x02041203 /* Brake-axis */
+#define DIBUTTON_DRIVINGC_FIRE                  0x02000C01 /* Fire */
+#define DIBUTTON_DRIVINGC_WEAPONS               0x02000C02 /* Select next weapon */
+#define DIBUTTON_DRIVINGC_TARGET                0x02000C03 /* Select next available target */
+#define DIBUTTON_DRIVINGC_MENU                  0x020004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIAXIS_DRIVINGC_ACCEL_AND_BRAKE         0x02014A04 /* Some devices combine accelerate and brake in a single axis */
+#define DIHATSWITCH_DRIVINGC_GLANCE             0x02004601 /* Look around */
+#define DIBUTTON_DRIVINGC_SHIFTUP               0x02004C04 /* Shift to next higher gear */
+#define DIBUTTON_DRIVINGC_SHIFTDOWN             0x02004C05 /* Shift to next lower gear */
+#define DIBUTTON_DRIVINGC_DASHBOARD             0x02004406 /* Select next dashboard option */
+#define DIBUTTON_DRIVINGC_AIDS                  0x02004407 /* Driver correction aids */
+#define DIBUTTON_DRIVINGC_BRAKE                 0x02004C08 /* Brake-button */
+#define DIBUTTON_DRIVINGC_FIRESECONDARY         0x02004C09 /* Alternative fire button */
+#define DIBUTTON_DRIVINGC_ACCELERATE_LINK       0x0203D4E0 /* Fallback Accelerate button */
+#define DIBUTTON_DRIVINGC_STEER_LEFT_LINK       0x0200CCE4 /* Fallback Steer Left button */
+#define DIBUTTON_DRIVINGC_STEER_RIGHT_LINK      0x0200CCEC /* Fallback Steer Right button */
+#define DIBUTTON_DRIVINGC_GLANCE_LEFT_LINK      0x0207C4E4 /* Fallback Glance Left button */
+#define DIBUTTON_DRIVINGC_GLANCE_RIGHT_LINK     0x0207C4EC /* Fallback Glance Right button */
+#define DIBUTTON_DRIVINGC_DEVICE                0x020044FE /* Show input device and controls */
+#define DIBUTTON_DRIVINGC_PAUSE                 0x020044FC /* Start / Pause / Restart game */
+
+/*--- Driving Simulator - Tank
+      Combat from withing a tank is primary objective  ---*/
+#define DIVIRTUAL_DRIVING_TANK                  0x03000000
+#define DIAXIS_DRIVINGT_STEER                   0x03008A01 /* Turn tank left / right */
+#define DIAXIS_DRIVINGT_BARREL                  0x03010202 /* Raise / lower barrel */
+#define DIAXIS_DRIVINGT_ACCELERATE              0x03039203 /* Accelerate */
+#define DIAXIS_DRIVINGT_ROTATE                  0x03020204 /* Turn barrel left / right */
+#define DIBUTTON_DRIVINGT_FIRE                  0x03000C01 /* Fire */
+#define DIBUTTON_DRIVINGT_WEAPONS               0x03000C02 /* Select next weapon */
+#define DIBUTTON_DRIVINGT_TARGET                0x03000C03 /* Selects next available target */
+#define DIBUTTON_DRIVINGT_MENU                  0x030004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_DRIVINGT_GLANCE             0x03004601 /* Look around */
+#define DIAXIS_DRIVINGT_BRAKE                   0x03045205 /* Brake-axis */
+#define DIAXIS_DRIVINGT_ACCEL_AND_BRAKE         0x03014A06 /* Some devices combine accelerate and brake in a single axis */
+#define DIBUTTON_DRIVINGT_VIEW                  0x03005C04 /* Cycle through view options */
+#define DIBUTTON_DRIVINGT_DASHBOARD             0x03005C05 /* Select next dashboard option */
+#define DIBUTTON_DRIVINGT_BRAKE                 0x03004C06 /* Brake-button */
+#define DIBUTTON_DRIVINGT_FIRESECONDARY         0x03004C07 /* Alternative fire button */
+#define DIBUTTON_DRIVINGT_ACCELERATE_LINK       0x0303D4E0 /* Fallback Accelerate button */
+#define DIBUTTON_DRIVINGT_STEER_LEFT_LINK       0x0300CCE4 /* Fallback Steer Left button */
+#define DIBUTTON_DRIVINGT_STEER_RIGHT_LINK      0x0300CCEC /* Fallback Steer Right button */
+#define DIBUTTON_DRIVINGT_BARREL_UP_LINK        0x030144E0 /* Fallback Barrel up button */
+#define DIBUTTON_DRIVINGT_BARREL_DOWN_LINK      0x030144E8 /* Fallback Barrel down button */
+#define DIBUTTON_DRIVINGT_ROTATE_LEFT_LINK      0x030244E4 /* Fallback Rotate left button */
+#define DIBUTTON_DRIVINGT_ROTATE_RIGHT_LINK     0x030244EC /* Fallback Rotate right button */
+#define DIBUTTON_DRIVINGT_GLANCE_LEFT_LINK      0x0307C4E4 /* Fallback Glance Left button */
+#define DIBUTTON_DRIVINGT_GLANCE_RIGHT_LINK     0x0307C4EC /* Fallback Glance Right button */
+#define DIBUTTON_DRIVINGT_DEVICE                0x030044FE /* Show input device and controls */
+#define DIBUTTON_DRIVINGT_PAUSE                 0x030044FC /* Start / Pause / Restart game */
+
+/*--- Flight Simulator - Civilian 
+      Plane control is the primary objective  ---*/
+#define DIVIRTUAL_FLYING_CIVILIAN               0x04000000
+#define DIAXIS_FLYINGC_BANK                     0x04008A01 /* Roll ship left / right */
+#define DIAXIS_FLYINGC_PITCH                    0x04010A02 /* Nose up / down */
+#define DIAXIS_FLYINGC_THROTTLE                 0x04039203 /* Throttle */
+#define DIBUTTON_FLYINGC_VIEW                   0x04002401 /* Cycle through view options */
+#define DIBUTTON_FLYINGC_DISPLAY                0x04002402 /* Select next dashboard / heads up display option */
+#define DIBUTTON_FLYINGC_GEAR                   0x04002C03 /* Gear up / down */
+#define DIBUTTON_FLYINGC_MENU                   0x040004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_FLYINGC_GLANCE              0x04004601 /* Look around */
+#define DIAXIS_FLYINGC_BRAKE                    0x04046A04 /* Apply Brake */
+#define DIAXIS_FLYINGC_RUDDER                   0x04025205 /* Yaw ship left/right */
+#define DIAXIS_FLYINGC_FLAPS                    0x04055A06 /* Flaps */
+#define DIBUTTON_FLYINGC_FLAPSUP                0x04006404 /* Increment stepping up until fully retracted */
+#define DIBUTTON_FLYINGC_FLAPSDOWN              0x04006405 /* Decrement stepping down until fully extended */
+#define DIBUTTON_FLYINGC_BRAKE_LINK             0x04046CE0 /* Fallback brake button */
+#define DIBUTTON_FLYINGC_FASTER_LINK            0x0403D4E0 /* Fallback throttle up button */
+#define DIBUTTON_FLYINGC_SLOWER_LINK            0x0403D4E8 /* Fallback throttle down button */
+#define DIBUTTON_FLYINGC_GLANCE_LEFT_LINK       0x0407C4E4 /* Fallback Glance Left button */
+#define DIBUTTON_FLYINGC_GLANCE_RIGHT_LINK      0x0407C4EC /* Fallback Glance Right button */
+#define DIBUTTON_FLYINGC_GLANCE_UP_LINK         0x0407C4E0 /* Fallback Glance Up button */
+#define DIBUTTON_FLYINGC_GLANCE_DOWN_LINK       0x0407C4E8 /* Fallback Glance Down button */
+#define DIBUTTON_FLYINGC_DEVICE                 0x040044FE /* Show input device and controls */
+#define DIBUTTON_FLYINGC_PAUSE                  0x040044FC /* Start / Pause / Restart game */
+
+/*--- Flight Simulator - Military 
+      Aerial combat is the primary objective  ---*/
+#define DIVIRTUAL_FLYING_MILITARY               0x05000000
+#define DIAXIS_FLYINGM_BANK                     0x05008A01 /* Bank - Roll ship left / right */
+#define DIAXIS_FLYINGM_PITCH                    0x05010A02 /* Pitch - Nose up / down */
+#define DIAXIS_FLYINGM_THROTTLE                 0x05039203 /* Throttle - faster / slower */
+#define DIBUTTON_FLYINGM_FIRE                   0x05000C01 /* Fire */
+#define DIBUTTON_FLYINGM_WEAPONS                0x05000C02 /* Select next weapon */
+#define DIBUTTON_FLYINGM_TARGET                 0x05000C03 /* Selects next available target */
+#define DIBUTTON_FLYINGM_MENU                   0x050004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_FLYINGM_GLANCE              0x05004601 /* Look around */
+#define DIBUTTON_FLYINGM_COUNTER                0x05005C04 /* Activate counter measures */
+#define DIAXIS_FLYINGM_RUDDER                   0x05024A04 /* Rudder - Yaw ship left/right */
+#define DIAXIS_FLYINGM_BRAKE                    0x05046205 /* Brake-axis */
+#define DIBUTTON_FLYINGM_VIEW                   0x05006405 /* Cycle through view options */
+#define DIBUTTON_FLYINGM_DISPLAY                0x05006406 /* Select next dashboard option */
+#define DIAXIS_FLYINGM_FLAPS                    0x05055206 /* Flaps */
+#define DIBUTTON_FLYINGM_FLAPSUP                0x05005407 /* Increment stepping up until fully retracted */
+#define DIBUTTON_FLYINGM_FLAPSDOWN              0x05005408 /* Decrement stepping down until fully extended */
+#define DIBUTTON_FLYINGM_FIRESECONDARY          0x05004C09 /* Alternative fire button */
+#define DIBUTTON_FLYINGM_GEAR                   0x0500640A /* Gear up / down */
+#define DIBUTTON_FLYINGM_BRAKE_LINK             0x050464E0 /* Fallback brake button */
+#define DIBUTTON_FLYINGM_FASTER_LINK            0x0503D4E0 /* Fallback throttle up button */
+#define DIBUTTON_FLYINGM_SLOWER_LINK            0x0503D4E8 /* Fallback throttle down button */
+#define DIBUTTON_FLYINGM_GLANCE_LEFT_LINK       0x0507C4E4 /* Fallback Glance Left button */
+#define DIBUTTON_FLYINGM_GLANCE_RIGHT_LINK      0x0507C4EC /* Fallback Glance Right button */
+#define DIBUTTON_FLYINGM_GLANCE_UP_LINK         0x0507C4E0 /* Fallback Glance Up button */
+#define DIBUTTON_FLYINGM_GLANCE_DOWN_LINK       0x0507C4E8 /* Fallback Glance Down button */
+#define DIBUTTON_FLYINGM_DEVICE                 0x050044FE /* Show input device and controls */
+#define DIBUTTON_FLYINGM_PAUSE                  0x050044FC /* Start / Pause / Restart game */
+
+/*--- Flight Simulator - Combat Helicopter
+      Combat from helicopter is primary objective  ---*/
+#define DIVIRTUAL_FLYING_HELICOPTER             0x06000000
+#define DIAXIS_FLYINGH_BANK                     0x06008A01 /* Bank - Roll ship left / right */
+#define DIAXIS_FLYINGH_PITCH                    0x06010A02 /* Pitch - Nose up / down */
+#define DIAXIS_FLYINGH_COLLECTIVE               0x06018A03 /* Collective - Blade pitch/power */
+#define DIBUTTON_FLYINGH_FIRE                   0x06001401 /* Fire */
+#define DIBUTTON_FLYINGH_WEAPONS                0x06001402 /* Select next weapon */
+#define DIBUTTON_FLYINGH_TARGET                 0x06001403 /* Selects next available target */
+#define DIBUTTON_FLYINGH_MENU                   0x060004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_FLYINGH_GLANCE              0x06004601 /* Look around */
+#define DIAXIS_FLYINGH_TORQUE                   0x06025A04 /* Torque - Rotate ship around left / right axis */
+#define DIAXIS_FLYINGH_THROTTLE                 0x0603DA05 /* Throttle */
+#define DIBUTTON_FLYINGH_COUNTER                0x06005404 /* Activate counter measures */
+#define DIBUTTON_FLYINGH_VIEW                   0x06006405 /* Cycle through view options */
+#define DIBUTTON_FLYINGH_GEAR                   0x06006406 /* Gear up / down */
+#define DIBUTTON_FLYINGH_FIRESECONDARY          0x06004C07 /* Alternative fire button */
+#define DIBUTTON_FLYINGH_FASTER_LINK            0x0603DCE0 /* Fallback throttle up button */
+#define DIBUTTON_FLYINGH_SLOWER_LINK            0x0603DCE8 /* Fallback throttle down button */
+#define DIBUTTON_FLYINGH_GLANCE_LEFT_LINK       0x0607C4E4 /* Fallback Glance Left button */
+#define DIBUTTON_FLYINGH_GLANCE_RIGHT_LINK      0x0607C4EC /* Fallback Glance Right button */
+#define DIBUTTON_FLYINGH_GLANCE_UP_LINK         0x0607C4E0 /* Fallback Glance Up button */
+#define DIBUTTON_FLYINGH_GLANCE_DOWN_LINK       0x0607C4E8 /* Fallback Glance Down button */
+#define DIBUTTON_FLYINGH_DEVICE                 0x060044FE /* Show input device and controls */
+#define DIBUTTON_FLYINGH_PAUSE                  0x060044FC /* Start / Pause / Restart game */
+
+/*--- Space Simulator - Combat
+      Space Simulator with weapons  ---*/
+#define DIVIRTUAL_SPACESIM                      0x07000000
+#define DIAXIS_SPACESIM_LATERAL                 0x07008201 /* Move ship left / right */
+#define DIAXIS_SPACESIM_MOVE                    0x07010202 /* Move ship forward/backward */
+#define DIAXIS_SPACESIM_THROTTLE                0x07038203 /* Throttle - Engine speed */
+#define DIBUTTON_SPACESIM_FIRE                  0x07000401 /* Fire */
+#define DIBUTTON_SPACESIM_WEAPONS               0x07000402 /* Select next weapon */
+#define DIBUTTON_SPACESIM_TARGET                0x07000403 /* Selects next available target */
+#define DIBUTTON_SPACESIM_MENU                  0x070004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_SPACESIM_GLANCE             0x07004601 /* Look around */
+#define DIAXIS_SPACESIM_CLIMB                   0x0701C204 /* Climb - Pitch ship up/down */
+#define DIAXIS_SPACESIM_ROTATE                  0x07024205 /* Rotate - Turn ship left/right */
+#define DIBUTTON_SPACESIM_VIEW                  0x07004404 /* Cycle through view options */
+#define DIBUTTON_SPACESIM_DISPLAY               0x07004405 /* Select next dashboard / heads up display option */
+#define DIBUTTON_SPACESIM_RAISE                 0x07004406 /* Raise ship while maintaining current pitch */
+#define DIBUTTON_SPACESIM_LOWER                 0x07004407 /* Lower ship while maintaining current pitch */
+#define DIBUTTON_SPACESIM_GEAR                  0x07004408 /* Gear up / down */
+#define DIBUTTON_SPACESIM_FIRESECONDARY         0x07004409 /* Alternative fire button */
+#define DIBUTTON_SPACESIM_LEFT_LINK             0x0700C4E4 /* Fallback move left button */
+#define DIBUTTON_SPACESIM_RIGHT_LINK            0x0700C4EC /* Fallback move right button */
+#define DIBUTTON_SPACESIM_FORWARD_LINK          0x070144E0 /* Fallback move forward button */
+#define DIBUTTON_SPACESIM_BACKWARD_LINK         0x070144E8 /* Fallback move backwards button */
+#define DIBUTTON_SPACESIM_FASTER_LINK           0x0703C4E0 /* Fallback throttle up button */
+#define DIBUTTON_SPACESIM_SLOWER_LINK           0x0703C4E8 /* Fallback throttle down button */
+#define DIBUTTON_SPACESIM_TURN_LEFT_LINK        0x070244E4 /* Fallback turn left button */
+#define DIBUTTON_SPACESIM_TURN_RIGHT_LINK       0x070244EC /* Fallback turn right button */
+#define DIBUTTON_SPACESIM_GLANCE_LEFT_LINK      0x0707C4E4 /* Fallback Glance Left button */
+#define DIBUTTON_SPACESIM_GLANCE_RIGHT_LINK     0x0707C4EC /* Fallback Glance Right button */
+#define DIBUTTON_SPACESIM_GLANCE_UP_LINK        0x0707C4E0 /* Fallback Glance Up button */
+#define DIBUTTON_SPACESIM_GLANCE_DOWN_LINK      0x0707C4E8 /* Fallback Glance Down button */
+#define DIBUTTON_SPACESIM_DEVICE                0x070044FE /* Show input device and controls */
+#define DIBUTTON_SPACESIM_PAUSE                 0x070044FC /* Start / Pause / Restart game */
+
+/*--- Fighting - First Person 
+      Hand to Hand combat is primary objective  ---*/
+#define DIVIRTUAL_FIGHTING_HAND2HAND            0x08000000
+#define DIAXIS_FIGHTINGH_LATERAL                0x08008201 /* Sidestep left/right */
+#define DIAXIS_FIGHTINGH_MOVE                   0x08010202 /* Move forward/backward */
+#define DIBUTTON_FIGHTINGH_PUNCH                0x08000401 /* Punch */
+#define DIBUTTON_FIGHTINGH_KICK                 0x08000402 /* Kick */
+#define DIBUTTON_FIGHTINGH_BLOCK                0x08000403 /* Block */
+#define DIBUTTON_FIGHTINGH_CROUCH               0x08000404 /* Crouch */
+#define DIBUTTON_FIGHTINGH_JUMP                 0x08000405 /* Jump */
+#define DIBUTTON_FIGHTINGH_SPECIAL1             0x08000406 /* Apply first special move */
+#define DIBUTTON_FIGHTINGH_SPECIAL2             0x08000407 /* Apply second special move */
+#define DIBUTTON_FIGHTINGH_MENU                 0x080004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIBUTTON_FIGHTINGH_SELECT               0x08004408 /* Select special move */
+#define DIHATSWITCH_FIGHTINGH_SLIDE             0x08004601 /* Look around */
+#define DIBUTTON_FIGHTINGH_DISPLAY              0x08004409 /* Shows next on-screen display option */
+#define DIAXIS_FIGHTINGH_ROTATE                 0x08024203 /* Rotate - Turn body left/right */
+#define DIBUTTON_FIGHTINGH_DODGE                0x0800440A /* Dodge */
+#define DIBUTTON_FIGHTINGH_LEFT_LINK            0x0800C4E4 /* Fallback left sidestep button */
+#define DIBUTTON_FIGHTINGH_RIGHT_LINK           0x0800C4EC /* Fallback right sidestep button */
+#define DIBUTTON_FIGHTINGH_FORWARD_LINK         0x080144E0 /* Fallback forward button */
+#define DIBUTTON_FIGHTINGH_BACKWARD_LINK        0x080144E8 /* Fallback backward button */
+#define DIBUTTON_FIGHTINGH_DEVICE               0x080044FE /* Show input device and controls */
+#define DIBUTTON_FIGHTINGH_PAUSE                0x080044FC /* Start / Pause / Restart game */
+
+/*--- Fighting - First Person Shooting
+      Navigation and combat are primary objectives  ---*/
+#define DIVIRTUAL_FIGHTING_FPS                  0x09000000
+#define DIAXIS_FPS_ROTATE                       0x09008201 /* Rotate character left/right */
+#define DIAXIS_FPS_MOVE                         0x09010202 /* Move forward/backward */
+#define DIBUTTON_FPS_FIRE                       0x09000401 /* Fire */
+#define DIBUTTON_FPS_WEAPONS                    0x09000402 /* Select next weapon */
+#define DIBUTTON_FPS_APPLY                      0x09000403 /* Use item */
+#define DIBUTTON_FPS_SELECT                     0x09000404 /* Select next inventory item */
+#define DIBUTTON_FPS_CROUCH                     0x09000405 /* Crouch/ climb down/ swim down */
+#define DIBUTTON_FPS_JUMP                       0x09000406 /* Jump/ climb up/ swim up */
+#define DIAXIS_FPS_LOOKUPDOWN                   0x09018203 /* Look up / down  */
+#define DIBUTTON_FPS_STRAFE                     0x09000407 /* Enable strafing while active */
+#define DIBUTTON_FPS_MENU                       0x090004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_FPS_GLANCE                  0x09004601 /* Look around */
+#define DIBUTTON_FPS_DISPLAY                    0x09004408 /* Shows next on-screen display option/ map */
+#define DIAXIS_FPS_SIDESTEP                     0x09024204 /* Sidestep */
+#define DIBUTTON_FPS_DODGE                      0x09004409 /* Dodge */
+#define DIBUTTON_FPS_GLANCEL                    0x0900440A /* Glance Left */
+#define DIBUTTON_FPS_GLANCER                    0x0900440B /* Glance Right */
+#define DIBUTTON_FPS_FIRESECONDARY              0x0900440C /* Alternative fire button */
+#define DIBUTTON_FPS_ROTATE_LEFT_LINK           0x0900C4E4 /* Fallback rotate left button */
+#define DIBUTTON_FPS_ROTATE_RIGHT_LINK          0x0900C4EC /* Fallback rotate right button */
+#define DIBUTTON_FPS_FORWARD_LINK               0x090144E0 /* Fallback forward button */
+#define DIBUTTON_FPS_BACKWARD_LINK              0x090144E8 /* Fallback backward button */
+#define DIBUTTON_FPS_GLANCE_UP_LINK             0x0901C4E0 /* Fallback look up button */
+#define DIBUTTON_FPS_GLANCE_DOWN_LINK           0x0901C4E8 /* Fallback look down button */
+#define DIBUTTON_FPS_STEP_LEFT_LINK             0x090244E4 /* Fallback step left button */
+#define DIBUTTON_FPS_STEP_RIGHT_LINK            0x090244EC /* Fallback step right button */
+#define DIBUTTON_FPS_DEVICE                     0x090044FE /* Show input device and controls */
+#define DIBUTTON_FPS_PAUSE                      0x090044FC /* Start / Pause / Restart game */
+
+/*--- Fighting - Third Person action
+      Perspective of camera is behind the main character  ---*/
+#define DIVIRTUAL_FIGHTING_THIRDPERSON          0x0A000000
+#define DIAXIS_TPS_TURN                         0x0A020201 /* Turn left/right */
+#define DIAXIS_TPS_MOVE                         0x0A010202 /* Move forward/backward */
+#define DIBUTTON_TPS_RUN                        0x0A000401 /* Run or walk toggle switch */
+#define DIBUTTON_TPS_ACTION                     0x0A000402 /* Action Button */
+#define DIBUTTON_TPS_SELECT                     0x0A000403 /* Select next weapon */
+#define DIBUTTON_TPS_USE                        0x0A000404 /* Use inventory item currently selected */
+#define DIBUTTON_TPS_JUMP                       0x0A000405 /* Character Jumps */
+#define DIBUTTON_TPS_MENU                       0x0A0004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_TPS_GLANCE                  0x0A004601 /* Look around */
+#define DIBUTTON_TPS_VIEW                       0x0A004406 /* Select camera view */
+#define DIBUTTON_TPS_STEPLEFT                   0x0A004407 /* Character takes a left step */
+#define DIBUTTON_TPS_STEPRIGHT                  0x0A004408 /* Character takes a right step */
+#define DIAXIS_TPS_STEP                         0x0A00C203 /* Character steps left/right */
+#define DIBUTTON_TPS_DODGE                      0x0A004409 /* Character dodges or ducks */
+#define DIBUTTON_TPS_INVENTORY                  0x0A00440A /* Cycle through inventory */
+#define DIBUTTON_TPS_TURN_LEFT_LINK             0x0A0244E4 /* Fallback turn left button */
+#define DIBUTTON_TPS_TURN_RIGHT_LINK            0x0A0244EC /* Fallback turn right button */
+#define DIBUTTON_TPS_FORWARD_LINK               0x0A0144E0 /* Fallback forward button */
+#define DIBUTTON_TPS_BACKWARD_LINK              0x0A0144E8 /* Fallback backward button */
+#define DIBUTTON_TPS_GLANCE_UP_LINK             0x0A07C4E0 /* Fallback look up button */
+#define DIBUTTON_TPS_GLANCE_DOWN_LINK           0x0A07C4E8 /* Fallback look down button */
+#define DIBUTTON_TPS_GLANCE_LEFT_LINK           0x0A07C4E4 /* Fallback glance up button */
+#define DIBUTTON_TPS_GLANCE_RIGHT_LINK          0x0A07C4EC /* Fallback glance right button */
+#define DIBUTTON_TPS_DEVICE                     0x0A0044FE /* Show input device and controls */
+#define DIBUTTON_TPS_PAUSE                      0x0A0044FC /* Start / Pause / Restart game */
+
+/*--- Strategy - Role Playing
+      Navigation and problem solving are primary actions  ---*/
+#define DIVIRTUAL_STRATEGY_ROLEPLAYING          0x0B000000
+#define DIAXIS_STRATEGYR_LATERAL                0x0B008201 /* sidestep - left/right */
+#define DIAXIS_STRATEGYR_MOVE                   0x0B010202 /* move forward/backward */
+#define DIBUTTON_STRATEGYR_GET                  0x0B000401 /* Acquire item */
+#define DIBUTTON_STRATEGYR_APPLY                0x0B000402 /* Use selected item */
+#define DIBUTTON_STRATEGYR_SELECT               0x0B000403 /* Select nextitem */
+#define DIBUTTON_STRATEGYR_ATTACK               0x0B000404 /* Attack */
+#define DIBUTTON_STRATEGYR_CAST                 0x0B000405 /* Cast Spell */
+#define DIBUTTON_STRATEGYR_CROUCH               0x0B000406 /* Crouch */
+#define DIBUTTON_STRATEGYR_JUMP                 0x0B000407 /* Jump */
+#define DIBUTTON_STRATEGYR_MENU                 0x0B0004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_STRATEGYR_GLANCE            0x0B004601 /* Look around */
+#define DIBUTTON_STRATEGYR_MAP                  0x0B004408 /* Cycle through map options */
+#define DIBUTTON_STRATEGYR_DISPLAY              0x0B004409 /* Shows next on-screen display option */
+#define DIAXIS_STRATEGYR_ROTATE                 0x0B024203 /* Turn body left/right */
+#define DIBUTTON_STRATEGYR_LEFT_LINK            0x0B00C4E4 /* Fallback sidestep left button */
+#define DIBUTTON_STRATEGYR_RIGHT_LINK           0x0B00C4EC /* Fallback sidestep right button */
+#define DIBUTTON_STRATEGYR_FORWARD_LINK         0x0B0144E0 /* Fallback move forward button */
+#define DIBUTTON_STRATEGYR_BACK_LINK            0x0B0144E8 /* Fallback move backward button */
+#define DIBUTTON_STRATEGYR_ROTATE_LEFT_LINK     0x0B0244E4 /* Fallback turn body left button */
+#define DIBUTTON_STRATEGYR_ROTATE_RIGHT_LINK    0x0B0244EC /* Fallback turn body right button */
+#define DIBUTTON_STRATEGYR_DEVICE               0x0B0044FE /* Show input device and controls */
+#define DIBUTTON_STRATEGYR_PAUSE                0x0B0044FC /* Start / Pause / Restart game */
+
+/*--- Strategy - Turn based
+      Navigation and problem solving are primary actions  ---*/
+#define DIVIRTUAL_STRATEGY_TURN                 0x0C000000
+#define DIAXIS_STRATEGYT_LATERAL                0x0C008201 /* Sidestep left/right */
+#define DIAXIS_STRATEGYT_MOVE                   0x0C010202 /* Move forward/backwards */
+#define DIBUTTON_STRATEGYT_SELECT               0x0C000401 /* Select unit or object */
+#define DIBUTTON_STRATEGYT_INSTRUCT             0x0C000402 /* Cycle through instructions */
+#define DIBUTTON_STRATEGYT_APPLY                0x0C000403 /* Apply selected instruction */
+#define DIBUTTON_STRATEGYT_TEAM                 0x0C000404 /* Select next team / cycle through all */
+#define DIBUTTON_STRATEGYT_TURN                 0x0C000405 /* Indicate turn over */
+#define DIBUTTON_STRATEGYT_MENU                 0x0C0004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIBUTTON_STRATEGYT_ZOOM                 0x0C004406 /* Zoom - in / out */
+#define DIBUTTON_STRATEGYT_MAP                  0x0C004407 /* cycle through map options */
+#define DIBUTTON_STRATEGYT_DISPLAY              0x0C004408 /* shows next on-screen display options */
+#define DIBUTTON_STRATEGYT_LEFT_LINK            0x0C00C4E4 /* Fallback sidestep left button */
+#define DIBUTTON_STRATEGYT_RIGHT_LINK           0x0C00C4EC /* Fallback sidestep right button */
+#define DIBUTTON_STRATEGYT_FORWARD_LINK         0x0C0144E0 /* Fallback move forward button */
+#define DIBUTTON_STRATEGYT_BACK_LINK            0x0C0144E8 /* Fallback move back button */
+#define DIBUTTON_STRATEGYT_DEVICE               0x0C0044FE /* Show input device and controls */
+#define DIBUTTON_STRATEGYT_PAUSE                0x0C0044FC /* Start / Pause / Restart game */
+
+/*--- Sports - Hunting
+      Hunting                ---*/
+#define DIVIRTUAL_SPORTS_HUNTING                0x0D000000
+#define DIAXIS_HUNTING_LATERAL                  0x0D008201 /* sidestep left/right */
+#define DIAXIS_HUNTING_MOVE                     0x0D010202 /* move forward/backwards */
+#define DIBUTTON_HUNTING_FIRE                   0x0D000401 /* Fire selected weapon */
+#define DIBUTTON_HUNTING_AIM                    0x0D000402 /* Select aim/move */
+#define DIBUTTON_HUNTING_WEAPON                 0x0D000403 /* Select next weapon */
+#define DIBUTTON_HUNTING_BINOCULAR              0x0D000404 /* Look through Binoculars */
+#define DIBUTTON_HUNTING_CALL                   0x0D000405 /* Make animal call */
+#define DIBUTTON_HUNTING_MAP                    0x0D000406 /* View Map */
+#define DIBUTTON_HUNTING_SPECIAL                0x0D000407 /* Special game operation */
+#define DIBUTTON_HUNTING_MENU                   0x0D0004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_HUNTING_GLANCE              0x0D004601 /* Look around */
+#define DIBUTTON_HUNTING_DISPLAY                0x0D004408 /* show next on-screen display option */
+#define DIAXIS_HUNTING_ROTATE                   0x0D024203 /* Turn body left/right */
+#define DIBUTTON_HUNTING_CROUCH                 0x0D004409 /* Crouch/ Climb / Swim down */
+#define DIBUTTON_HUNTING_JUMP                   0x0D00440A /* Jump/ Climb up / Swim up */
+#define DIBUTTON_HUNTING_FIRESECONDARY          0x0D00440B /* Alternative fire button */
+#define DIBUTTON_HUNTING_LEFT_LINK              0x0D00C4E4 /* Fallback sidestep left button */
+#define DIBUTTON_HUNTING_RIGHT_LINK             0x0D00C4EC /* Fallback sidestep right button */
+#define DIBUTTON_HUNTING_FORWARD_LINK           0x0D0144E0 /* Fallback move forward button */
+#define DIBUTTON_HUNTING_BACK_LINK              0x0D0144E8 /* Fallback move back button */
+#define DIBUTTON_HUNTING_ROTATE_LEFT_LINK       0x0D0244E4 /* Fallback turn body left button */
+#define DIBUTTON_HUNTING_ROTATE_RIGHT_LINK      0x0D0244EC /* Fallback turn body right button */
+#define DIBUTTON_HUNTING_DEVICE                 0x0D0044FE /* Show input device and controls */
+#define DIBUTTON_HUNTING_PAUSE                  0x0D0044FC /* Start / Pause / Restart game */
+
+/*--- Sports - Fishing
+      Catching Fish is primary objective   ---*/
+#define DIVIRTUAL_SPORTS_FISHING                0x0E000000
+#define DIAXIS_FISHING_LATERAL                  0x0E008201 /* sidestep left/right */
+#define DIAXIS_FISHING_MOVE                     0x0E010202 /* move forward/backwards */
+#define DIBUTTON_FISHING_CAST                   0x0E000401 /* Cast line */
+#define DIBUTTON_FISHING_TYPE                   0x0E000402 /* Select cast type */
+#define DIBUTTON_FISHING_BINOCULAR              0x0E000403 /* Look through Binocular */
+#define DIBUTTON_FISHING_BAIT                   0x0E000404 /* Select type of Bait */
+#define DIBUTTON_FISHING_MAP                    0x0E000405 /* View Map */
+#define DIBUTTON_FISHING_MENU                   0x0E0004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_FISHING_GLANCE              0x0E004601 /* Look around */
+#define DIBUTTON_FISHING_DISPLAY                0x0E004406 /* Show next on-screen display option */
+#define DIAXIS_FISHING_ROTATE                   0x0E024203 /* Turn character left / right */
+#define DIBUTTON_FISHING_CROUCH                 0x0E004407 /* Crouch/ Climb / Swim down */
+#define DIBUTTON_FISHING_JUMP                   0x0E004408 /* Jump/ Climb up / Swim up */
+#define DIBUTTON_FISHING_LEFT_LINK              0x0E00C4E4 /* Fallback sidestep left button */
+#define DIBUTTON_FISHING_RIGHT_LINK             0x0E00C4EC /* Fallback sidestep right button */
+#define DIBUTTON_FISHING_FORWARD_LINK           0x0E0144E0 /* Fallback move forward button */
+#define DIBUTTON_FISHING_BACK_LINK              0x0E0144E8 /* Fallback move back button */
+#define DIBUTTON_FISHING_ROTATE_LEFT_LINK       0x0E0244E4 /* Fallback turn body left button */
+#define DIBUTTON_FISHING_ROTATE_RIGHT_LINK      0x0E0244EC /* Fallback turn body right button */
+#define DIBUTTON_FISHING_DEVICE                 0x0E0044FE /* Show input device and controls */
+#define DIBUTTON_FISHING_PAUSE                  0x0E0044FC /* Start / Pause / Restart game */
+
+/*--- Sports - Baseball - Batting
+      Batter control is primary objective  ---*/
+#define DIVIRTUAL_SPORTS_BASEBALL_BAT           0x0F000000
+#define DIAXIS_BASEBALLB_LATERAL                0x0F008201 /* Aim left / right */
+#define DIAXIS_BASEBALLB_MOVE                   0x0F010202 /* Aim up / down */
+#define DIBUTTON_BASEBALLB_SELECT               0x0F000401 /* cycle through swing options */
+#define DIBUTTON_BASEBALLB_NORMAL               0x0F000402 /* normal swing */
+#define DIBUTTON_BASEBALLB_POWER                0x0F000403 /* swing for the fence */
+#define DIBUTTON_BASEBALLB_BUNT                 0x0F000404 /* bunt */
+#define DIBUTTON_BASEBALLB_STEAL                0x0F000405 /* Base runner attempts to steal a base */
+#define DIBUTTON_BASEBALLB_BURST                0x0F000406 /* Base runner invokes burst of speed */
+#define DIBUTTON_BASEBALLB_SLIDE                0x0F000407 /* Base runner slides into base */
+#define DIBUTTON_BASEBALLB_CONTACT              0x0F000408 /* Contact swing */
+#define DIBUTTON_BASEBALLB_MENU                 0x0F0004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIBUTTON_BASEBALLB_NOSTEAL              0x0F004409 /* Base runner goes back to a base */
+#define DIBUTTON_BASEBALLB_BOX                  0x0F00440A /* Enter or exit batting box */
+#define DIBUTTON_BASEBALLB_LEFT_LINK            0x0F00C4E4 /* Fallback sidestep left button */
+#define DIBUTTON_BASEBALLB_RIGHT_LINK           0x0F00C4EC /* Fallback sidestep right button */
+#define DIBUTTON_BASEBALLB_FORWARD_LINK         0x0F0144E0 /* Fallback move forward button */
+#define DIBUTTON_BASEBALLB_BACK_LINK            0x0F0144E8 /* Fallback move back button */
+#define DIBUTTON_BASEBALLB_DEVICE               0x0F0044FE /* Show input device and controls */
+#define DIBUTTON_BASEBALLB_PAUSE                0x0F0044FC /* Start / Pause / Restart game */
+
+/*--- Sports - Baseball - Pitching
+      Pitcher control is primary objective   ---*/
+#define DIVIRTUAL_SPORTS_BASEBALL_PITCH         0x10000000
+#define DIAXIS_BASEBALLP_LATERAL                0x10008201 /* Aim left / right */
+#define DIAXIS_BASEBALLP_MOVE                   0x10010202 /* Aim up / down */
+#define DIBUTTON_BASEBALLP_SELECT               0x10000401 /* cycle through pitch selections */
+#define DIBUTTON_BASEBALLP_PITCH                0x10000402 /* throw pitch */
+#define DIBUTTON_BASEBALLP_BASE                 0x10000403 /* select base to throw to */
+#define DIBUTTON_BASEBALLP_THROW                0x10000404 /* throw to base */
+#define DIBUTTON_BASEBALLP_FAKE                 0x10000405 /* Fake a throw to a base */
+#define DIBUTTON_BASEBALLP_MENU                 0x100004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIBUTTON_BASEBALLP_WALK                 0x10004406 /* Throw intentional walk / pitch out */
+#define DIBUTTON_BASEBALLP_LOOK                 0x10004407 /* Look at runners on bases */
+#define DIBUTTON_BASEBALLP_LEFT_LINK            0x1000C4E4 /* Fallback sidestep left button */
+#define DIBUTTON_BASEBALLP_RIGHT_LINK           0x1000C4EC /* Fallback sidestep right button */
+#define DIBUTTON_BASEBALLP_FORWARD_LINK         0x100144E0 /* Fallback move forward button */
+#define DIBUTTON_BASEBALLP_BACK_LINK            0x100144E8 /* Fallback move back button */
+#define DIBUTTON_BASEBALLP_DEVICE               0x100044FE /* Show input device and controls */
+#define DIBUTTON_BASEBALLP_PAUSE                0x100044FC /* Start / Pause / Restart game */
+
+/*--- Sports - Baseball - Fielding
+      Fielder control is primary objective  ---*/
+#define DIVIRTUAL_SPORTS_BASEBALL_FIELD         0x11000000
+#define DIAXIS_BASEBALLF_LATERAL                0x11008201 /* Aim left / right */
+#define DIAXIS_BASEBALLF_MOVE                   0x11010202 /* Aim up / down */
+#define DIBUTTON_BASEBALLF_NEAREST              0x11000401 /* Switch to fielder nearest to the ball */
+#define DIBUTTON_BASEBALLF_THROW1               0x11000402 /* Make conservative throw */
+#define DIBUTTON_BASEBALLF_THROW2               0x11000403 /* Make aggressive throw */
+#define DIBUTTON_BASEBALLF_BURST                0x11000404 /* Invoke burst of speed */
+#define DIBUTTON_BASEBALLF_JUMP                 0x11000405 /* Jump to catch ball */
+#define DIBUTTON_BASEBALLF_DIVE                 0x11000406 /* Dive to catch ball */
+#define DIBUTTON_BASEBALLF_MENU                 0x110004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIBUTTON_BASEBALLF_SHIFTIN              0x11004407 /* Shift the infield positioning */
+#define DIBUTTON_BASEBALLF_SHIFTOUT             0x11004408 /* Shift the outfield positioning */
+#define DIBUTTON_BASEBALLF_AIM_LEFT_LINK        0x1100C4E4 /* Fallback aim left button */
+#define DIBUTTON_BASEBALLF_AIM_RIGHT_LINK       0x1100C4EC /* Fallback aim right button */
+#define DIBUTTON_BASEBALLF_FORWARD_LINK         0x110144E0 /* Fallback move forward button */
+#define DIBUTTON_BASEBALLF_BACK_LINK            0x110144E8 /* Fallback move back button */
+#define DIBUTTON_BASEBALLF_DEVICE               0x110044FE /* Show input device and controls */
+#define DIBUTTON_BASEBALLF_PAUSE                0x110044FC /* Start / Pause / Restart game */
+
+/*--- Sports - Basketball - Offense
+      Offense  ---*/
+#define DIVIRTUAL_SPORTS_BASKETBALL_OFFENSE     0x12000000
+#define DIAXIS_BBALLO_LATERAL                   0x12008201 /* left / right */
+#define DIAXIS_BBALLO_MOVE                      0x12010202 /* up / down */
+#define DIBUTTON_BBALLO_SHOOT                   0x12000401 /* shoot basket */
+#define DIBUTTON_BBALLO_DUNK                    0x12000402 /* dunk basket */
+#define DIBUTTON_BBALLO_PASS                    0x12000403 /* throw pass */
+#define DIBUTTON_BBALLO_FAKE                    0x12000404 /* fake shot or pass */
+#define DIBUTTON_BBALLO_SPECIAL                 0x12000405 /* apply special move */
+#define DIBUTTON_BBALLO_PLAYER                  0x12000406 /* select next player */
+#define DIBUTTON_BBALLO_BURST                   0x12000407 /* invoke burst */
+#define DIBUTTON_BBALLO_CALL                    0x12000408 /* call for ball / pass to me */
+#define DIBUTTON_BBALLO_MENU                    0x120004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_BBALLO_GLANCE               0x12004601 /* scroll view */
+#define DIBUTTON_BBALLO_SCREEN                  0x12004409 /* Call for screen */
+#define DIBUTTON_BBALLO_PLAY                    0x1200440A /* Call for specific offensive play */
+#define DIBUTTON_BBALLO_JAB                     0x1200440B /* Initiate fake drive to basket */
+#define DIBUTTON_BBALLO_POST                    0x1200440C /* Perform post move */
+#define DIBUTTON_BBALLO_TIMEOUT                 0x1200440D /* Time Out */
+#define DIBUTTON_BBALLO_SUBSTITUTE              0x1200440E /* substitute one player for another */
+#define DIBUTTON_BBALLO_LEFT_LINK               0x1200C4E4 /* Fallback sidestep left button */
+#define DIBUTTON_BBALLO_RIGHT_LINK              0x1200C4EC /* Fallback sidestep right button */
+#define DIBUTTON_BBALLO_FORWARD_LINK            0x120144E0 /* Fallback move forward button */
+#define DIBUTTON_BBALLO_BACK_LINK               0x120144E8 /* Fallback move back button */
+#define DIBUTTON_BBALLO_DEVICE                  0x120044FE /* Show input device and controls */
+#define DIBUTTON_BBALLO_PAUSE                   0x120044FC /* Start / Pause / Restart game */
+
+/*--- Sports - Basketball - Defense
+      Defense  ---*/
+#define DIVIRTUAL_SPORTS_BASKETBALL_DEFENSE     0x13000000
+#define DIAXIS_BBALLD_LATERAL                   0x13008201 /* left / right */
+#define DIAXIS_BBALLD_MOVE                      0x13010202 /* up / down */
+#define DIBUTTON_BBALLD_JUMP                    0x13000401 /* jump to block shot */
+#define DIBUTTON_BBALLD_STEAL                   0x13000402 /* attempt to steal ball */
+#define DIBUTTON_BBALLD_FAKE                    0x13000403 /* fake block or steal */
+#define DIBUTTON_BBALLD_SPECIAL                 0x13000404 /* apply special move */
+#define DIBUTTON_BBALLD_PLAYER                  0x13000405 /* select next player */
+#define DIBUTTON_BBALLD_BURST                   0x13000406 /* invoke burst */
+#define DIBUTTON_BBALLD_PLAY                    0x13000407 /* call for specific defensive play */
+#define DIBUTTON_BBALLD_MENU                    0x130004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_BBALLD_GLANCE               0x13004601 /* scroll view */
+#define DIBUTTON_BBALLD_TIMEOUT                 0x13004408 /* Time Out */
+#define DIBUTTON_BBALLD_SUBSTITUTE              0x13004409 /* substitute one player for another */
+#define DIBUTTON_BBALLD_LEFT_LINK               0x1300C4E4 /* Fallback sidestep left button */
+#define DIBUTTON_BBALLD_RIGHT_LINK              0x1300C4EC /* Fallback sidestep right button */
+#define DIBUTTON_BBALLD_FORWARD_LINK            0x130144E0 /* Fallback move forward button */
+#define DIBUTTON_BBALLD_BACK_LINK               0x130144E8 /* Fallback move back button */
+#define DIBUTTON_BBALLD_DEVICE                  0x130044FE /* Show input device and controls */
+#define DIBUTTON_BBALLD_PAUSE                   0x130044FC /* Start / Pause / Restart game */
+
+/*--- Sports - Football - Play
+      Play selection  ---*/
+#define DIVIRTUAL_SPORTS_FOOTBALL_FIELD         0x14000000
+#define DIBUTTON_FOOTBALLP_PLAY                 0x14000401 /* cycle through available plays */
+#define DIBUTTON_FOOTBALLP_SELECT               0x14000402 /* select play */
+#define DIBUTTON_FOOTBALLP_HELP                 0x14000403 /* Bring up pop-up help */
+#define DIBUTTON_FOOTBALLP_MENU                 0x140004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIBUTTON_FOOTBALLP_DEVICE               0x140044FE /* Show input device and controls */
+#define DIBUTTON_FOOTBALLP_PAUSE                0x140044FC /* Start / Pause / Restart game */
+
+/*--- Sports - Football - QB
+      Offense: Quarterback / Kicker  ---*/
+#define DIVIRTUAL_SPORTS_FOOTBALL_QBCK          0x15000000
+#define DIAXIS_FOOTBALLQ_LATERAL                0x15008201 /* Move / Aim: left / right */
+#define DIAXIS_FOOTBALLQ_MOVE                   0x15010202 /* Move / Aim: up / down */
+#define DIBUTTON_FOOTBALLQ_SELECT               0x15000401 /* Select */
+#define DIBUTTON_FOOTBALLQ_SNAP                 0x15000402 /* snap ball - start play */
+#define DIBUTTON_FOOTBALLQ_JUMP                 0x15000403 /* jump over defender */
+#define DIBUTTON_FOOTBALLQ_SLIDE                0x15000404 /* Dive/Slide */
+#define DIBUTTON_FOOTBALLQ_PASS                 0x15000405 /* throws pass to receiver */
+#define DIBUTTON_FOOTBALLQ_FAKE                 0x15000406 /* pump fake pass or fake kick */
+#define DIBUTTON_FOOTBALLQ_MENU                 0x150004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIBUTTON_FOOTBALLQ_FAKESNAP             0x15004407 /* Fake snap  */
+#define DIBUTTON_FOOTBALLQ_MOTION               0x15004408 /* Send receivers in motion */
+#define DIBUTTON_FOOTBALLQ_AUDIBLE              0x15004409 /* Change offensive play at line of scrimmage */
+#define DIBUTTON_FOOTBALLQ_LEFT_LINK            0x1500C4E4 /* Fallback sidestep left button */
+#define DIBUTTON_FOOTBALLQ_RIGHT_LINK           0x1500C4EC /* Fallback sidestep right button */
+#define DIBUTTON_FOOTBALLQ_FORWARD_LINK         0x150144E0 /* Fallback move forward button */
+#define DIBUTTON_FOOTBALLQ_BACK_LINK            0x150144E8 /* Fallback move back button */
+#define DIBUTTON_FOOTBALLQ_DEVICE               0x150044FE /* Show input device and controls */
+#define DIBUTTON_FOOTBALLQ_PAUSE                0x150044FC /* Start / Pause / Restart game */
+
+/*--- Sports - Football - Offense
+      Offense - Runner  ---*/
+#define DIVIRTUAL_SPORTS_FOOTBALL_OFFENSE       0x16000000
+#define DIAXIS_FOOTBALLO_LATERAL                0x16008201 /* Move / Aim: left / right */
+#define DIAXIS_FOOTBALLO_MOVE                   0x16010202 /* Move / Aim: up / down */
+#define DIBUTTON_FOOTBALLO_JUMP                 0x16000401 /* jump or hurdle over defender */
+#define DIBUTTON_FOOTBALLO_LEFTARM              0x16000402 /* holds out left arm */
+#define DIBUTTON_FOOTBALLO_RIGHTARM             0x16000403 /* holds out right arm */
+#define DIBUTTON_FOOTBALLO_THROW                0x16000404 /* throw pass or lateral ball to another runner */
+#define DIBUTTON_FOOTBALLO_SPIN                 0x16000405 /* Spin to avoid defenders */
+#define DIBUTTON_FOOTBALLO_MENU                 0x160004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIBUTTON_FOOTBALLO_JUKE                 0x16004406 /* Use special move to avoid defenders */
+#define DIBUTTON_FOOTBALLO_SHOULDER             0x16004407 /* Lower shoulder to run over defenders */
+#define DIBUTTON_FOOTBALLO_TURBO                0x16004408 /* Speed burst past defenders */
+#define DIBUTTON_FOOTBALLO_DIVE                 0x16004409 /* Dive over defenders */
+#define DIBUTTON_FOOTBALLO_ZOOM                 0x1600440A /* Zoom view in / out */
+#define DIBUTTON_FOOTBALLO_SUBSTITUTE           0x1600440B /* substitute one player for another */
+#define DIBUTTON_FOOTBALLO_LEFT_LINK            0x1600C4E4 /* Fallback sidestep left button */
+#define DIBUTTON_FOOTBALLO_RIGHT_LINK           0x1600C4EC /* Fallback sidestep right button */
+#define DIBUTTON_FOOTBALLO_FORWARD_LINK         0x160144E0 /* Fallback move forward button */
+#define DIBUTTON_FOOTBALLO_BACK_LINK            0x160144E8 /* Fallback move back button */
+#define DIBUTTON_FOOTBALLO_DEVICE               0x160044FE /* Show input device and controls */
+#define DIBUTTON_FOOTBALLO_PAUSE                0x160044FC /* Start / Pause / Restart game */
+
+/*--- Sports - Football - Defense
+      Defense     ---*/
+#define DIVIRTUAL_SPORTS_FOOTBALL_DEFENSE       0x17000000
+#define DIAXIS_FOOTBALLD_LATERAL                0x17008201 /* Move / Aim: left / right */
+#define DIAXIS_FOOTBALLD_MOVE                   0x17010202 /* Move / Aim: up / down */
+#define DIBUTTON_FOOTBALLD_PLAY                 0x17000401 /* cycle through available plays */
+#define DIBUTTON_FOOTBALLD_SELECT               0x17000402 /* select player closest to the ball */
+#define DIBUTTON_FOOTBALLD_JUMP                 0x17000403 /* jump to intercept or block */
+#define DIBUTTON_FOOTBALLD_TACKLE               0x17000404 /* tackler runner */
+#define DIBUTTON_FOOTBALLD_FAKE                 0x17000405 /* hold down to fake tackle or intercept */
+#define DIBUTTON_FOOTBALLD_SUPERTACKLE          0x17000406 /* Initiate special tackle */
+#define DIBUTTON_FOOTBALLD_MENU                 0x170004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIBUTTON_FOOTBALLD_SPIN                 0x17004407 /* Spin to beat offensive line */
+#define DIBUTTON_FOOTBALLD_SWIM                 0x17004408 /* Swim to beat the offensive line */
+#define DIBUTTON_FOOTBALLD_BULLRUSH             0x17004409 /* Bull rush the offensive line */
+#define DIBUTTON_FOOTBALLD_RIP                  0x1700440A /* Rip the offensive line */
+#define DIBUTTON_FOOTBALLD_AUDIBLE              0x1700440B /* Change defensive play at the line of scrimmage */
+#define DIBUTTON_FOOTBALLD_ZOOM                 0x1700440C /* Zoom view in / out */
+#define DIBUTTON_FOOTBALLD_SUBSTITUTE           0x1700440D /* substitute one player for another */
+#define DIBUTTON_FOOTBALLD_LEFT_LINK            0x1700C4E4 /* Fallback sidestep left button */
+#define DIBUTTON_FOOTBALLD_RIGHT_LINK           0x1700C4EC /* Fallback sidestep right button */
+#define DIBUTTON_FOOTBALLD_FORWARD_LINK         0x170144E0 /* Fallback move forward button */
+#define DIBUTTON_FOOTBALLD_BACK_LINK            0x170144E8 /* Fallback move back button */
+#define DIBUTTON_FOOTBALLD_DEVICE               0x170044FE /* Show input device and controls */
+#define DIBUTTON_FOOTBALLD_PAUSE                0x170044FC /* Start / Pause / Restart game */
+
+/*--- Sports - Golf
+                                ---*/
+#define DIVIRTUAL_SPORTS_GOLF                   0x18000000
+#define DIAXIS_GOLF_LATERAL                     0x18008201 /* Move / Aim: left / right */
+#define DIAXIS_GOLF_MOVE                        0x18010202 /* Move / Aim: up / down */
+#define DIBUTTON_GOLF_SWING                     0x18000401 /* swing club */
+#define DIBUTTON_GOLF_SELECT                    0x18000402 /* cycle between: club / swing strength / ball arc / ball spin */
+#define DIBUTTON_GOLF_UP                        0x18000403 /* increase selection */
+#define DIBUTTON_GOLF_DOWN                      0x18000404 /* decrease selection */
+#define DIBUTTON_GOLF_TERRAIN                   0x18000405 /* shows terrain detail */
+#define DIBUTTON_GOLF_FLYBY                     0x18000406 /* view the hole via a flyby */
+#define DIBUTTON_GOLF_MENU                      0x180004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_GOLF_SCROLL                 0x18004601 /* scroll view */
+#define DIBUTTON_GOLF_ZOOM                      0x18004407 /* Zoom view in / out */
+#define DIBUTTON_GOLF_TIMEOUT                   0x18004408 /* Call for time out */
+#define DIBUTTON_GOLF_SUBSTITUTE                0x18004409 /* substitute one player for another */
+#define DIBUTTON_GOLF_LEFT_LINK                 0x1800C4E4 /* Fallback sidestep left button */
+#define DIBUTTON_GOLF_RIGHT_LINK                0x1800C4EC /* Fallback sidestep right button */
+#define DIBUTTON_GOLF_FORWARD_LINK              0x180144E0 /* Fallback move forward button */
+#define DIBUTTON_GOLF_BACK_LINK                 0x180144E8 /* Fallback move back button */
+#define DIBUTTON_GOLF_DEVICE                    0x180044FE /* Show input device and controls */
+#define DIBUTTON_GOLF_PAUSE                     0x180044FC /* Start / Pause / Restart game */
+
+/*--- Sports - Hockey - Offense
+      Offense       ---*/
+#define DIVIRTUAL_SPORTS_HOCKEY_OFFENSE         0x19000000
+#define DIAXIS_HOCKEYO_LATERAL                  0x19008201 /* Move / Aim: left / right */
+#define DIAXIS_HOCKEYO_MOVE                     0x19010202 /* Move / Aim: up / down */
+#define DIBUTTON_HOCKEYO_SHOOT                  0x19000401 /* Shoot */
+#define DIBUTTON_HOCKEYO_PASS                   0x19000402 /* pass the puck */
+#define DIBUTTON_HOCKEYO_BURST                  0x19000403 /* invoke speed burst */
+#define DIBUTTON_HOCKEYO_SPECIAL                0x19000404 /* invoke special move */
+#define DIBUTTON_HOCKEYO_FAKE                   0x19000405 /* hold down to fake pass or kick */
+#define DIBUTTON_HOCKEYO_MENU                   0x190004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_HOCKEYO_SCROLL              0x19004601 /* scroll view */
+#define DIBUTTON_HOCKEYO_ZOOM                   0x19004406 /* Zoom view in / out */
+#define DIBUTTON_HOCKEYO_STRATEGY               0x19004407 /* Invoke coaching menu for strategy help */
+#define DIBUTTON_HOCKEYO_TIMEOUT                0x19004408 /* Call for time out */
+#define DIBUTTON_HOCKEYO_SUBSTITUTE             0x19004409 /* substitute one player for another */
+#define DIBUTTON_HOCKEYO_LEFT_LINK              0x1900C4E4 /* Fallback sidestep left button */
+#define DIBUTTON_HOCKEYO_RIGHT_LINK             0x1900C4EC /* Fallback sidestep right button */
+#define DIBUTTON_HOCKEYO_FORWARD_LINK           0x190144E0 /* Fallback move forward button */
+#define DIBUTTON_HOCKEYO_BACK_LINK              0x190144E8 /* Fallback move back button */
+#define DIBUTTON_HOCKEYO_DEVICE                 0x190044FE /* Show input device and controls */
+#define DIBUTTON_HOCKEYO_PAUSE                  0x190044FC /* Start / Pause / Restart game */
+
+/*--- Sports - Hockey - Defense
+      Defense       ---*/
+#define DIVIRTUAL_SPORTS_HOCKEY_DEFENSE         0x1A000000
+#define DIAXIS_HOCKEYD_LATERAL                  0x1A008201 /* Move / Aim: left / right */
+#define DIAXIS_HOCKEYD_MOVE                     0x1A010202 /* Move / Aim: up / down */
+#define DIBUTTON_HOCKEYD_PLAYER                 0x1A000401 /* control player closest to the puck */
+#define DIBUTTON_HOCKEYD_STEAL                  0x1A000402 /* attempt steal */
+#define DIBUTTON_HOCKEYD_BURST                  0x1A000403 /* speed burst or body check */
+#define DIBUTTON_HOCKEYD_BLOCK                  0x1A000404 /* block puck */
+#define DIBUTTON_HOCKEYD_FAKE                   0x1A000405 /* hold down to fake tackle or intercept */
+#define DIBUTTON_HOCKEYD_MENU                   0x1A0004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_HOCKEYD_SCROLL              0x1A004601 /* scroll view */
+#define DIBUTTON_HOCKEYD_ZOOM                   0x1A004406 /* Zoom view in / out */
+#define DIBUTTON_HOCKEYD_STRATEGY               0x1A004407 /* Invoke coaching menu for strategy help */
+#define DIBUTTON_HOCKEYD_TIMEOUT                0x1A004408 /* Call for time out */
+#define DIBUTTON_HOCKEYD_SUBSTITUTE             0x1A004409 /* substitute one player for another */
+#define DIBUTTON_HOCKEYD_LEFT_LINK              0x1A00C4E4 /* Fallback sidestep left button */
+#define DIBUTTON_HOCKEYD_RIGHT_LINK             0x1A00C4EC /* Fallback sidestep right button */
+#define DIBUTTON_HOCKEYD_FORWARD_LINK           0x1A0144E0 /* Fallback move forward button */
+#define DIBUTTON_HOCKEYD_BACK_LINK              0x1A0144E8 /* Fallback move back button */
+#define DIBUTTON_HOCKEYD_DEVICE                 0x1A0044FE /* Show input device and controls */
+#define DIBUTTON_HOCKEYD_PAUSE                  0x1A0044FC /* Start / Pause / Restart game */
+
+/*--- Sports - Hockey - Goalie
+      Goal tending  ---*/
+#define DIVIRTUAL_SPORTS_HOCKEY_GOALIE          0x1B000000
+#define DIAXIS_HOCKEYG_LATERAL                  0x1B008201 /* Move / Aim: left / right */
+#define DIAXIS_HOCKEYG_MOVE                     0x1B010202 /* Move / Aim: up / down */
+#define DIBUTTON_HOCKEYG_PASS                   0x1B000401 /* pass puck */
+#define DIBUTTON_HOCKEYG_POKE                   0x1B000402 /* poke / check / hack */
+#define DIBUTTON_HOCKEYG_STEAL                  0x1B000403 /* attempt steal */
+#define DIBUTTON_HOCKEYG_BLOCK                  0x1B000404 /* block puck */
+#define DIBUTTON_HOCKEYG_MENU                   0x1B0004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_HOCKEYG_SCROLL              0x1B004601 /* scroll view */
+#define DIBUTTON_HOCKEYG_ZOOM                   0x1B004405 /* Zoom view in / out */
+#define DIBUTTON_HOCKEYG_STRATEGY               0x1B004406 /* Invoke coaching menu for strategy help */
+#define DIBUTTON_HOCKEYG_TIMEOUT                0x1B004407 /* Call for time out */
+#define DIBUTTON_HOCKEYG_SUBSTITUTE             0x1B004408 /* substitute one player for another */
+#define DIBUTTON_HOCKEYG_LEFT_LINK              0x1B00C4E4 /* Fallback sidestep left button */
+#define DIBUTTON_HOCKEYG_RIGHT_LINK             0x1B00C4EC /* Fallback sidestep right button */
+#define DIBUTTON_HOCKEYG_FORWARD_LINK           0x1B0144E0 /* Fallback move forward button */
+#define DIBUTTON_HOCKEYG_BACK_LINK              0x1B0144E8 /* Fallback move back button */
+#define DIBUTTON_HOCKEYG_DEVICE                 0x1B0044FE /* Show input device and controls */
+#define DIBUTTON_HOCKEYG_PAUSE                  0x1B0044FC /* Start / Pause / Restart game */
+
+/*--- Sports - Mountain Biking
+                     ---*/
+#define DIVIRTUAL_SPORTS_BIKING_MOUNTAIN        0x1C000000
+#define DIAXIS_BIKINGM_TURN                     0x1C008201 /* left / right */
+#define DIAXIS_BIKINGM_PEDAL                    0x1C010202 /* Pedal faster / slower / brake */
+#define DIBUTTON_BIKINGM_JUMP                   0x1C000401 /* jump over obstacle */
+#define DIBUTTON_BIKINGM_CAMERA                 0x1C000402 /* switch camera view */
+#define DIBUTTON_BIKINGM_SPECIAL1               0x1C000403 /* perform first special move */
+#define DIBUTTON_BIKINGM_SELECT                 0x1C000404 /* Select */
+#define DIBUTTON_BIKINGM_SPECIAL2               0x1C000405 /* perform second special move */
+#define DIBUTTON_BIKINGM_MENU                   0x1C0004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_BIKINGM_SCROLL              0x1C004601 /* scroll view */
+#define DIBUTTON_BIKINGM_ZOOM                   0x1C004406 /* Zoom view in / out */
+#define DIAXIS_BIKINGM_BRAKE                    0x1C044203 /* Brake axis  */
+#define DIBUTTON_BIKINGM_LEFT_LINK              0x1C00C4E4 /* Fallback turn left button */
+#define DIBUTTON_BIKINGM_RIGHT_LINK             0x1C00C4EC /* Fallback turn right button */
+#define DIBUTTON_BIKINGM_FASTER_LINK            0x1C0144E0 /* Fallback pedal faster button */
+#define DIBUTTON_BIKINGM_SLOWER_LINK            0x1C0144E8 /* Fallback pedal slower button */
+#define DIBUTTON_BIKINGM_BRAKE_BUTTON_LINK      0x1C0444E8 /* Fallback brake button */
+#define DIBUTTON_BIKINGM_DEVICE                 0x1C0044FE /* Show input device and controls */
+#define DIBUTTON_BIKINGM_PAUSE                  0x1C0044FC /* Start / Pause / Restart game */
+
+/*--- Sports: Skiing / Snowboarding / Skateboarding
+        ---*/
+#define DIVIRTUAL_SPORTS_SKIING                 0x1D000000
+#define DIAXIS_SKIING_TURN                      0x1D008201 /* left / right */
+#define DIAXIS_SKIING_SPEED                     0x1D010202 /* faster / slower */
+#define DIBUTTON_SKIING_JUMP                    0x1D000401 /* Jump */
+#define DIBUTTON_SKIING_CROUCH                  0x1D000402 /* crouch down */
+#define DIBUTTON_SKIING_CAMERA                  0x1D000403 /* switch camera view */
+#define DIBUTTON_SKIING_SPECIAL1                0x1D000404 /* perform first special move */
+#define DIBUTTON_SKIING_SELECT                  0x1D000405 /* Select */
+#define DIBUTTON_SKIING_SPECIAL2                0x1D000406 /* perform second special move */
+#define DIBUTTON_SKIING_MENU                    0x1D0004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_SKIING_GLANCE               0x1D004601 /* scroll view */
+#define DIBUTTON_SKIING_ZOOM                    0x1D004407 /* Zoom view in / out */
+#define DIBUTTON_SKIING_LEFT_LINK               0x1D00C4E4 /* Fallback turn left button */
+#define DIBUTTON_SKIING_RIGHT_LINK              0x1D00C4EC /* Fallback turn right button */
+#define DIBUTTON_SKIING_FASTER_LINK             0x1D0144E0 /* Fallback increase speed button */
+#define DIBUTTON_SKIING_SLOWER_LINK             0x1D0144E8 /* Fallback decrease speed button */
+#define DIBUTTON_SKIING_DEVICE                  0x1D0044FE /* Show input device and controls */
+#define DIBUTTON_SKIING_PAUSE                   0x1D0044FC /* Start / Pause / Restart game */
+
+/*--- Sports - Soccer - Offense
+      Offense       ---*/
+#define DIVIRTUAL_SPORTS_SOCCER_OFFENSE         0x1E000000
+#define DIAXIS_SOCCERO_LATERAL                  0x1E008201 /* Move / Aim: left / right */
+#define DIAXIS_SOCCERO_MOVE                     0x1E010202 /* Move / Aim: up / down */
+#define DIAXIS_SOCCERO_BEND                     0x1E018203 /* Bend to soccer shot/pass */
+#define DIBUTTON_SOCCERO_SHOOT                  0x1E000401 /* Shoot the ball */
+#define DIBUTTON_SOCCERO_PASS                   0x1E000402 /* Pass  */
+#define DIBUTTON_SOCCERO_FAKE                   0x1E000403 /* Fake */
+#define DIBUTTON_SOCCERO_PLAYER                 0x1E000404 /* Select next player */
+#define DIBUTTON_SOCCERO_SPECIAL1               0x1E000405 /* Apply special move */
+#define DIBUTTON_SOCCERO_SELECT                 0x1E000406 /* Select special move */
+#define DIBUTTON_SOCCERO_MENU                   0x1E0004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_SOCCERO_GLANCE              0x1E004601 /* scroll view */
+#define DIBUTTON_SOCCERO_SUBSTITUTE             0x1E004407 /* Substitute one player for another */
+#define DIBUTTON_SOCCERO_SHOOTLOW               0x1E004408 /* Shoot the ball low */
+#define DIBUTTON_SOCCERO_SHOOTHIGH              0x1E004409 /* Shoot the ball high */
+#define DIBUTTON_SOCCERO_PASSTHRU               0x1E00440A /* Make a thru pass */
+#define DIBUTTON_SOCCERO_SPRINT                 0x1E00440B /* Sprint / turbo boost */
+#define DIBUTTON_SOCCERO_CONTROL                0x1E00440C /* Obtain control of the ball */
+#define DIBUTTON_SOCCERO_HEAD                   0x1E00440D /* Attempt to head the ball */
+#define DIBUTTON_SOCCERO_LEFT_LINK              0x1E00C4E4 /* Fallback sidestep left button */
+#define DIBUTTON_SOCCERO_RIGHT_LINK             0x1E00C4EC /* Fallback sidestep right button */
+#define DIBUTTON_SOCCERO_FORWARD_LINK           0x1E0144E0 /* Fallback move forward button */
+#define DIBUTTON_SOCCERO_BACK_LINK              0x1E0144E8 /* Fallback move back button */
+#define DIBUTTON_SOCCERO_DEVICE                 0x1E0044FE /* Show input device and controls */
+#define DIBUTTON_SOCCERO_PAUSE                  0x1E0044FC /* Start / Pause / Restart game */
+
+/*--- Sports - Soccer - Defense
+      Defense       ---*/
+#define DIVIRTUAL_SPORTS_SOCCER_DEFENSE         0x1F000000
+#define DIAXIS_SOCCERD_LATERAL                  0x1F008201 /* Move / Aim: left / right */
+#define DIAXIS_SOCCERD_MOVE                     0x1F010202 /* Move / Aim: up / down */
+#define DIBUTTON_SOCCERD_BLOCK                  0x1F000401 /* Attempt to block shot */
+#define DIBUTTON_SOCCERD_STEAL                  0x1F000402 /* Attempt to steal ball */
+#define DIBUTTON_SOCCERD_FAKE                   0x1F000403 /* Fake a block or a steal */
+#define DIBUTTON_SOCCERD_PLAYER                 0x1F000404 /* Select next player */
+#define DIBUTTON_SOCCERD_SPECIAL                0x1F000405 /* Apply special move */
+#define DIBUTTON_SOCCERD_SELECT                 0x1F000406 /* Select special move */
+#define DIBUTTON_SOCCERD_SLIDE                  0x1F000407 /* Attempt a slide tackle */
+#define DIBUTTON_SOCCERD_MENU                   0x1F0004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_SOCCERD_GLANCE              0x1F004601 /* scroll view */
+#define DIBUTTON_SOCCERD_FOUL                   0x1F004408 /* Initiate a foul / hard-foul */
+#define DIBUTTON_SOCCERD_HEAD                   0x1F004409 /* Attempt a Header */
+#define DIBUTTON_SOCCERD_CLEAR                  0x1F00440A /* Attempt to clear the ball down the field */
+#define DIBUTTON_SOCCERD_GOALIECHARGE           0x1F00440B /* Make the goalie charge out of the box */
+#define DIBUTTON_SOCCERD_SUBSTITUTE             0x1F00440C /* Substitute one player for another */
+#define DIBUTTON_SOCCERD_LEFT_LINK              0x1F00C4E4 /* Fallback sidestep left button */
+#define DIBUTTON_SOCCERD_RIGHT_LINK             0x1F00C4EC /* Fallback sidestep right button */
+#define DIBUTTON_SOCCERD_FORWARD_LINK           0x1F0144E0 /* Fallback move forward button */
+#define DIBUTTON_SOCCERD_BACK_LINK              0x1F0144E8 /* Fallback move back button */
+#define DIBUTTON_SOCCERD_DEVICE                 0x1F0044FE /* Show input device and controls */
+#define DIBUTTON_SOCCERD_PAUSE                  0x1F0044FC /* Start / Pause / Restart game */
+
+/*--- Sports - Racquet
+      Tennis - Table-Tennis - Squash   ---*/
+#define DIVIRTUAL_SPORTS_RACQUET                0x20000000
+#define DIAXIS_RACQUET_LATERAL                  0x20008201 /* Move / Aim: left / right */
+#define DIAXIS_RACQUET_MOVE                     0x20010202 /* Move / Aim: up / down */
+#define DIBUTTON_RACQUET_SWING                  0x20000401 /* Swing racquet */
+#define DIBUTTON_RACQUET_BACKSWING              0x20000402 /* Swing backhand */
+#define DIBUTTON_RACQUET_SMASH                  0x20000403 /* Smash shot */
+#define DIBUTTON_RACQUET_SPECIAL                0x20000404 /* Special shot */
+#define DIBUTTON_RACQUET_SELECT                 0x20000405 /* Select special shot */
+#define DIBUTTON_RACQUET_MENU                   0x200004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_RACQUET_GLANCE              0x20004601 /* scroll view */
+#define DIBUTTON_RACQUET_TIMEOUT                0x20004406 /* Call for time out */
+#define DIBUTTON_RACQUET_SUBSTITUTE             0x20004407 /* Substitute one player for another */
+#define DIBUTTON_RACQUET_LEFT_LINK              0x2000C4E4 /* Fallback sidestep left button */
+#define DIBUTTON_RACQUET_RIGHT_LINK             0x2000C4EC /* Fallback sidestep right button */
+#define DIBUTTON_RACQUET_FORWARD_LINK           0x200144E0 /* Fallback move forward button */
+#define DIBUTTON_RACQUET_BACK_LINK              0x200144E8 /* Fallback move back button */
+#define DIBUTTON_RACQUET_DEVICE                 0x200044FE /* Show input device and controls */
+#define DIBUTTON_RACQUET_PAUSE                  0x200044FC /* Start / Pause / Restart game */
+
+/*--- Arcade- 2D
+      Side to Side movement        ---*/
+#define DIVIRTUAL_ARCADE_SIDE2SIDE              0x21000000
+#define DIAXIS_ARCADES_LATERAL                  0x21008201 /* left / right */
+#define DIAXIS_ARCADES_MOVE                     0x21010202 /* up / down */
+#define DIBUTTON_ARCADES_THROW                  0x21000401 /* throw object */
+#define DIBUTTON_ARCADES_CARRY                  0x21000402 /* carry object */
+#define DIBUTTON_ARCADES_ATTACK                 0x21000403 /* attack */
+#define DIBUTTON_ARCADES_SPECIAL                0x21000404 /* apply special move */
+#define DIBUTTON_ARCADES_SELECT                 0x21000405 /* select special move */
+#define DIBUTTON_ARCADES_MENU                   0x210004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_ARCADES_VIEW                0x21004601 /* scroll view left / right / up / down */
+#define DIBUTTON_ARCADES_LEFT_LINK              0x2100C4E4 /* Fallback sidestep left button */
+#define DIBUTTON_ARCADES_RIGHT_LINK             0x2100C4EC /* Fallback sidestep right button */
+#define DIBUTTON_ARCADES_FORWARD_LINK           0x210144E0 /* Fallback move forward button */
+#define DIBUTTON_ARCADES_BACK_LINK              0x210144E8 /* Fallback move back button */
+#define DIBUTTON_ARCADES_VIEW_UP_LINK           0x2107C4E0 /* Fallback scroll view up button */
+#define DIBUTTON_ARCADES_VIEW_DOWN_LINK         0x2107C4E8 /* Fallback scroll view down button */
+#define DIBUTTON_ARCADES_VIEW_LEFT_LINK         0x2107C4E4 /* Fallback scroll view left button */
+#define DIBUTTON_ARCADES_VIEW_RIGHT_LINK        0x2107C4EC /* Fallback scroll view right button */
+#define DIBUTTON_ARCADES_DEVICE                 0x210044FE /* Show input device and controls */
+#define DIBUTTON_ARCADES_PAUSE                  0x210044FC /* Start / Pause / Restart game */
+
+/*--- Arcade - Platform Game
+      Character moves around on screen  ---*/
+#define DIVIRTUAL_ARCADE_PLATFORM               0x22000000
+#define DIAXIS_ARCADEP_LATERAL                  0x22008201 /* Left / right */
+#define DIAXIS_ARCADEP_MOVE                     0x22010202 /* Up / down */
+#define DIBUTTON_ARCADEP_JUMP                   0x22000401 /* Jump */
+#define DIBUTTON_ARCADEP_FIRE                   0x22000402 /* Fire */
+#define DIBUTTON_ARCADEP_CROUCH                 0x22000403 /* Crouch */
+#define DIBUTTON_ARCADEP_SPECIAL                0x22000404 /* Apply special move */
+#define DIBUTTON_ARCADEP_SELECT                 0x22000405 /* Select special move */
+#define DIBUTTON_ARCADEP_MENU                   0x220004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_ARCADEP_VIEW                0x22004601 /* Scroll view */
+#define DIBUTTON_ARCADEP_FIRESECONDARY          0x22004406 /* Alternative fire button */
+#define DIBUTTON_ARCADEP_LEFT_LINK              0x2200C4E4 /* Fallback sidestep left button */
+#define DIBUTTON_ARCADEP_RIGHT_LINK             0x2200C4EC /* Fallback sidestep right button */
+#define DIBUTTON_ARCADEP_FORWARD_LINK           0x220144E0 /* Fallback move forward button */
+#define DIBUTTON_ARCADEP_BACK_LINK              0x220144E8 /* Fallback move back button */
+#define DIBUTTON_ARCADEP_VIEW_UP_LINK           0x2207C4E0 /* Fallback scroll view up button */
+#define DIBUTTON_ARCADEP_VIEW_DOWN_LINK         0x2207C4E8 /* Fallback scroll view down button */
+#define DIBUTTON_ARCADEP_VIEW_LEFT_LINK         0x2207C4E4 /* Fallback scroll view left button */
+#define DIBUTTON_ARCADEP_VIEW_RIGHT_LINK        0x2207C4EC /* Fallback scroll view right button */
+#define DIBUTTON_ARCADEP_DEVICE                 0x220044FE /* Show input device and controls */
+#define DIBUTTON_ARCADEP_PAUSE                  0x220044FC /* Start / Pause / Restart game */
+
+/*--- CAD - 2D Object Control
+      Controls to select and move objects in 2D  ---*/
+#define DIVIRTUAL_CAD_2DCONTROL                 0x23000000
+#define DIAXIS_2DCONTROL_LATERAL                0x23008201 /* Move view left / right */
+#define DIAXIS_2DCONTROL_MOVE                   0x23010202 /* Move view up / down */
+#define DIAXIS_2DCONTROL_INOUT                  0x23018203 /* Zoom - in / out */
+#define DIBUTTON_2DCONTROL_SELECT               0x23000401 /* Select Object */
+#define DIBUTTON_2DCONTROL_SPECIAL1             0x23000402 /* Do first special operation */
+#define DIBUTTON_2DCONTROL_SPECIAL              0x23000403 /* Select special operation */
+#define DIBUTTON_2DCONTROL_SPECIAL2             0x23000404 /* Do second special operation */
+#define DIBUTTON_2DCONTROL_MENU                 0x230004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_2DCONTROL_HATSWITCH         0x23004601 /* Hat switch */
+#define DIAXIS_2DCONTROL_ROTATEZ                0x23024204 /* Rotate view clockwise / counterclockwise */
+#define DIBUTTON_2DCONTROL_DISPLAY              0x23004405 /* Shows next on-screen display options */
+#define DIBUTTON_2DCONTROL_DEVICE               0x230044FE /* Show input device and controls */
+#define DIBUTTON_2DCONTROL_PAUSE                0x230044FC /* Start / Pause / Restart game */
+
+/*--- CAD - 3D object control
+      Controls to select and move objects within a 3D environment  ---*/
+#define DIVIRTUAL_CAD_3DCONTROL                 0x24000000
+#define DIAXIS_3DCONTROL_LATERAL                0x24008201 /* Move view left / right */
+#define DIAXIS_3DCONTROL_MOVE                   0x24010202 /* Move view up / down */
+#define DIAXIS_3DCONTROL_INOUT                  0x24018203 /* Zoom - in / out */
+#define DIBUTTON_3DCONTROL_SELECT               0x24000401 /* Select Object */
+#define DIBUTTON_3DCONTROL_SPECIAL1             0x24000402 /* Do first special operation */
+#define DIBUTTON_3DCONTROL_SPECIAL              0x24000403 /* Select special operation */
+#define DIBUTTON_3DCONTROL_SPECIAL2             0x24000404 /* Do second special operation */
+#define DIBUTTON_3DCONTROL_MENU                 0x240004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_3DCONTROL_HATSWITCH         0x24004601 /* Hat switch */
+#define DIAXIS_3DCONTROL_ROTATEX                0x24034204 /* Rotate view forward or up / backward or down */
+#define DIAXIS_3DCONTROL_ROTATEY                0x2402C205 /* Rotate view clockwise / counterclockwise */
+#define DIAXIS_3DCONTROL_ROTATEZ                0x24024206 /* Rotate view left / right */
+#define DIBUTTON_3DCONTROL_DISPLAY              0x24004405 /* Show next on-screen display options */
+#define DIBUTTON_3DCONTROL_DEVICE               0x240044FE /* Show input device and controls */
+#define DIBUTTON_3DCONTROL_PAUSE                0x240044FC /* Start / Pause / Restart game */
+
+/*--- CAD - 3D Navigation - Fly through
+      Controls for 3D modeling  ---*/
+#define DIVIRTUAL_CAD_FLYBY                     0x25000000
+#define DIAXIS_CADF_LATERAL                     0x25008201 /* move view left / right */
+#define DIAXIS_CADF_MOVE                        0x25010202 /* move view up / down */
+#define DIAXIS_CADF_INOUT                       0x25018203 /* in / out */
+#define DIBUTTON_CADF_SELECT                    0x25000401 /* Select Object */
+#define DIBUTTON_CADF_SPECIAL1                  0x25000402 /* do first special operation */
+#define DIBUTTON_CADF_SPECIAL                   0x25000403 /* Select special operation */
+#define DIBUTTON_CADF_SPECIAL2                  0x25000404 /* do second special operation */
+#define DIBUTTON_CADF_MENU                      0x250004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_CADF_HATSWITCH              0x25004601 /* Hat switch */
+#define DIAXIS_CADF_ROTATEX                     0x25034204 /* Rotate view forward or up / backward or down */
+#define DIAXIS_CADF_ROTATEY                     0x2502C205 /* Rotate view clockwise / counterclockwise */
+#define DIAXIS_CADF_ROTATEZ                     0x25024206 /* Rotate view left / right */
+#define DIBUTTON_CADF_DISPLAY                   0x25004405 /* shows next on-screen display options */
+#define DIBUTTON_CADF_DEVICE                    0x250044FE /* Show input device and controls */
+#define DIBUTTON_CADF_PAUSE                     0x250044FC /* Start / Pause / Restart game */
+
+/*--- CAD - 3D Model Control
+      Controls for 3D modeling  ---*/
+#define DIVIRTUAL_CAD_MODEL                     0x26000000
+#define DIAXIS_CADM_LATERAL                     0x26008201 /* move view left / right */
+#define DIAXIS_CADM_MOVE                        0x26010202 /* move view up / down */
+#define DIAXIS_CADM_INOUT                       0x26018203 /* in / out */
+#define DIBUTTON_CADM_SELECT                    0x26000401 /* Select Object */
+#define DIBUTTON_CADM_SPECIAL1                  0x26000402 /* do first special operation */
+#define DIBUTTON_CADM_SPECIAL                   0x26000403 /* Select special operation */
+#define DIBUTTON_CADM_SPECIAL2                  0x26000404 /* do second special operation */
+#define DIBUTTON_CADM_MENU                      0x260004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIHATSWITCH_CADM_HATSWITCH              0x26004601 /* Hat switch */
+#define DIAXIS_CADM_ROTATEX                     0x26034204 /* Rotate view forward or up / backward or down */
+#define DIAXIS_CADM_ROTATEY                     0x2602C205 /* Rotate view clockwise / counterclockwise */
+#define DIAXIS_CADM_ROTATEZ                     0x26024206 /* Rotate view left / right */
+#define DIBUTTON_CADM_DISPLAY                   0x26004405 /* shows next on-screen display options */
+#define DIBUTTON_CADM_DEVICE                    0x260044FE /* Show input device and controls */
+#define DIBUTTON_CADM_PAUSE                     0x260044FC /* Start / Pause / Restart game */
+
+/*--- Control - Media Equipment
+      Remote        ---*/
+#define DIVIRTUAL_REMOTE_CONTROL                0x27000000
+#define DIAXIS_REMOTE_SLIDER                    0x27050201 /* Slider for adjustment: volume / color / bass / etc */
+#define DIBUTTON_REMOTE_MUTE                    0x27000401 /* Set volume on current device to zero */
+#define DIBUTTON_REMOTE_SELECT                  0x27000402 /* Next/previous: channel/ track / chapter / picture / station */
+#define DIBUTTON_REMOTE_PLAY                    0x27002403 /* Start or pause entertainment on current device */
+#define DIBUTTON_REMOTE_CUE                     0x27002404 /* Move through current media */
+#define DIBUTTON_REMOTE_REVIEW                  0x27002405 /* Move through current media */
+#define DIBUTTON_REMOTE_CHANGE                  0x27002406 /* Select next device */
+#define DIBUTTON_REMOTE_RECORD                  0x27002407 /* Start recording the current media */
+#define DIBUTTON_REMOTE_MENU                    0x270004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIAXIS_REMOTE_SLIDER2                   0x27054202 /* Slider for adjustment: volume */
+#define DIBUTTON_REMOTE_TV                      0x27005C08 /* Select TV */
+#define DIBUTTON_REMOTE_CABLE                   0x27005C09 /* Select cable box */
+#define DIBUTTON_REMOTE_CD                      0x27005C0A /* Select CD player */
+#define DIBUTTON_REMOTE_VCR                     0x27005C0B /* Select VCR */
+#define DIBUTTON_REMOTE_TUNER                   0x27005C0C /* Select tuner */
+#define DIBUTTON_REMOTE_DVD                     0x27005C0D /* Select DVD player */
+#define DIBUTTON_REMOTE_ADJUST                  0x27005C0E /* Enter device adjustment menu */
+#define DIBUTTON_REMOTE_DIGIT0                  0x2700540F /* Digit 0 */
+#define DIBUTTON_REMOTE_DIGIT1                  0x27005410 /* Digit 1 */
+#define DIBUTTON_REMOTE_DIGIT2                  0x27005411 /* Digit 2 */
+#define DIBUTTON_REMOTE_DIGIT3                  0x27005412 /* Digit 3 */
+#define DIBUTTON_REMOTE_DIGIT4                  0x27005413 /* Digit 4 */
+#define DIBUTTON_REMOTE_DIGIT5                  0x27005414 /* Digit 5 */
+#define DIBUTTON_REMOTE_DIGIT6                  0x27005415 /* Digit 6 */
+#define DIBUTTON_REMOTE_DIGIT7                  0x27005416 /* Digit 7 */
+#define DIBUTTON_REMOTE_DIGIT8                  0x27005417 /* Digit 8 */
+#define DIBUTTON_REMOTE_DIGIT9                  0x27005418 /* Digit 9 */
+#define DIBUTTON_REMOTE_DEVICE                  0x270044FE /* Show input device and controls */
+#define DIBUTTON_REMOTE_PAUSE                   0x270044FC /* Start / Pause / Restart game */
+
+/*--- Control- Web
+      Help or Browser            ---*/
+#define DIVIRTUAL_BROWSER_CONTROL               0x28000000
+#define DIAXIS_BROWSER_LATERAL                  0x28008201 /* Move on screen pointer */
+#define DIAXIS_BROWSER_MOVE                     0x28010202 /* Move on screen pointer */
+#define DIBUTTON_BROWSER_SELECT                 0x28000401 /* Select current item */
+#define DIAXIS_BROWSER_VIEW                     0x28018203 /* Move view up/down */
+#define DIBUTTON_BROWSER_REFRESH                0x28000402 /* Refresh */
+#define DIBUTTON_BROWSER_MENU                   0x280004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIBUTTON_BROWSER_SEARCH                 0x28004403 /* Use search tool */
+#define DIBUTTON_BROWSER_STOP                   0x28004404 /* Cease current update */
+#define DIBUTTON_BROWSER_HOME                   0x28004405 /* Go directly to "home" location */
+#define DIBUTTON_BROWSER_FAVORITES              0x28004406 /* Mark current site as favorite */
+#define DIBUTTON_BROWSER_NEXT                   0x28004407 /* Select Next page */
+#define DIBUTTON_BROWSER_PREVIOUS               0x28004408 /* Select Previous page */
+#define DIBUTTON_BROWSER_HISTORY                0x28004409 /* Show/Hide History */
+#define DIBUTTON_BROWSER_PRINT                  0x2800440A /* Print current page */
+#define DIBUTTON_BROWSER_DEVICE                 0x280044FE /* Show input device and controls */
+#define DIBUTTON_BROWSER_PAUSE                  0x280044FC /* Start / Pause / Restart game */
+
+/*--- Driving Simulator - Giant Walking Robot
+      Walking tank with weapons  ---*/
+#define DIVIRTUAL_DRIVING_MECHA                 0x29000000
+#define DIAXIS_MECHA_STEER                      0x29008201 /* Turns mecha left/right */
+#define DIAXIS_MECHA_TORSO                      0x29010202 /* Tilts torso forward/backward */
+#define DIAXIS_MECHA_ROTATE                     0x29020203 /* Turns torso left/right */
+#define DIAXIS_MECHA_THROTTLE                   0x29038204 /* Engine Speed */
+#define DIBUTTON_MECHA_FIRE                     0x29000401 /* Fire */
+#define DIBUTTON_MECHA_WEAPONS                  0x29000402 /* Select next weapon group */
+#define DIBUTTON_MECHA_TARGET                   0x29000403 /* Select closest enemy available target */
+#define DIBUTTON_MECHA_REVERSE                  0x29000404 /* Toggles throttle in/out of reverse */
+#define DIBUTTON_MECHA_ZOOM                     0x29000405 /* Zoom in/out targeting reticule */
+#define DIBUTTON_MECHA_JUMP                     0x29000406 /* Fires jump jets */
+#define DIBUTTON_MECHA_MENU                     0x290004FD /* Show menu options */
+/*--- Priority 2 controls                            ---*/
+
+#define DIBUTTON_MECHA_CENTER                   0x29004407 /* Center torso to legs */
+#define DIHATSWITCH_MECHA_GLANCE                0x29004601 /* Look around */
+#define DIBUTTON_MECHA_VIEW                     0x29004408 /* Cycle through view options */
+#define DIBUTTON_MECHA_FIRESECONDARY            0x29004409 /* Alternative fire button */
+#define DIBUTTON_MECHA_LEFT_LINK                0x2900C4E4 /* Fallback steer left button */
+#define DIBUTTON_MECHA_RIGHT_LINK               0x2900C4EC /* Fallback steer right button */
+#define DIBUTTON_MECHA_FORWARD_LINK             0x290144E0 /* Fallback tilt torso forward button */
+#define DIBUTTON_MECHA_BACK_LINK                0x290144E8 /* Fallback tilt toroso backward button */
+#define DIBUTTON_MECHA_ROTATE_LEFT_LINK         0x290244E4 /* Fallback rotate toroso right button */
+#define DIBUTTON_MECHA_ROTATE_RIGHT_LINK        0x290244EC /* Fallback rotate torso left button */
+#define DIBUTTON_MECHA_FASTER_LINK              0x2903C4E0 /* Fallback increase engine speed */
+#define DIBUTTON_MECHA_SLOWER_LINK              0x2903C4E8 /* Fallback decrease engine speed */
+#define DIBUTTON_MECHA_DEVICE                   0x290044FE /* Show input device and controls */
+#define DIBUTTON_MECHA_PAUSE                    0x290044FC /* Start / Pause / Restart game */
+
+/*
+ *  "ANY" semantics can be used as a last resort to get mappings for actions 
+ *  that match nothing in the chosen virtual genre.  These semantics will be 
+ *  mapped at a lower priority that virtual genre semantics.  Also, hardware 
+ *  vendors will not be able to provide sensible mappings for these unless 
+ *  they provide application specific mappings.
+ */
+#define DIAXIS_ANY_X_1                          0xFF00C201 
+#define DIAXIS_ANY_X_2                          0xFF00C202 
+#define DIAXIS_ANY_Y_1                          0xFF014201 
+#define DIAXIS_ANY_Y_2                          0xFF014202 
+#define DIAXIS_ANY_Z_1                          0xFF01C201 
+#define DIAXIS_ANY_Z_2                          0xFF01C202 
+#define DIAXIS_ANY_R_1                          0xFF024201 
+#define DIAXIS_ANY_R_2                          0xFF024202 
+#define DIAXIS_ANY_U_1                          0xFF02C201 
+#define DIAXIS_ANY_U_2                          0xFF02C202 
+#define DIAXIS_ANY_V_1                          0xFF034201 
+#define DIAXIS_ANY_V_2                          0xFF034202 
+#define DIAXIS_ANY_A_1                          0xFF03C201 
+#define DIAXIS_ANY_A_2                          0xFF03C202 
+#define DIAXIS_ANY_B_1                          0xFF044201 
+#define DIAXIS_ANY_B_2                          0xFF044202 
+#define DIAXIS_ANY_C_1                          0xFF04C201 
+#define DIAXIS_ANY_C_2                          0xFF04C202 
+#define DIAXIS_ANY_S_1                          0xFF054201 
+#define DIAXIS_ANY_S_2                          0xFF054202 
+
+#define DIAXIS_ANY_1                            0xFF004201 
+#define DIAXIS_ANY_2                            0xFF004202 
+#define DIAXIS_ANY_3                            0xFF004203 
+#define DIAXIS_ANY_4                            0xFF004204 
+
+#define DIPOV_ANY_1                             0xFF004601 
+#define DIPOV_ANY_2                             0xFF004602 
+#define DIPOV_ANY_3                             0xFF004603 
+#define DIPOV_ANY_4                             0xFF004604 
+
+#define DIBUTTON_ANY(instance)                  ( 0xFF004400 | instance )
+
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif  /* __DINPUT_INCLUDED__ */
+
+/****************************************************************************
+ *
+ *  Definitions for non-IDirectInput (VJoyD) features defined more recently
+ *  than the current sdk files
+ *
+ ****************************************************************************/
+
+#ifdef _INC_MMSYSTEM
+#ifndef MMNOJOY
+
+#ifndef __VJOYDX_INCLUDED__
+#define __VJOYDX_INCLUDED__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Flag to indicate that the dwReserved2 field of the JOYINFOEX structure
+ * contains mini-driver specific data to be passed by VJoyD to the mini-
+ * driver instead of doing a poll.
+ */
+#define JOY_PASSDRIVERDATA          0x10000000l
+
+/*
+ * Informs the joystick driver that the configuration has been changed
+ * and should be reloaded from the registery.
+ * dwFlags is reserved and should be set to zero
+ */
+WINMMAPI MMRESULT WINAPI joyConfigChanged( DWORD dwFlags );
+
+#ifndef DIJ_RINGZERO
+/*
+ * Invoke the joystick control panel directly, using the passed window handle 
+ * as the parent of the dialog.  This API is only supported for compatibility 
+ * purposes; new applications should use the RunControlPanel method of a 
+ * device interface for a game controller.
+ * The API is called by using the function pointer returned by
+ * GetProcAddress( hCPL, TEXT("ShowJoyCPL") ) where hCPL is a HMODULE returned 
+ * by LoadLibrary( TEXT("joy.cpl") ).  The typedef is provided to allow 
+ * declaration and casting of an appropriately typed variable.
+ */
+void WINAPI ShowJoyCPL( HWND hWnd );
+typedef void (WINAPI* LPFNSHOWJOYCPL)( HWND hWnd );
+#endif /* DIJ_RINGZERO */
+
+
+/*
+ * Hardware Setting indicating that the device is a headtracker
+ */
+#define JOY_HWS_ISHEADTRACKER       0x02000000l
+
+/*
+ * Hardware Setting indicating that the VxD is used to replace
+ * the standard analog polling
+ */
+#define JOY_HWS_ISGAMEPORTDRIVER    0x04000000l
+
+/*
+ * Hardware Setting indicating that the driver needs a standard
+ * gameport in order to communicate with the device.
+ */
+#define JOY_HWS_ISANALOGPORTDRIVER  0x08000000l
+
+/*
+ * Hardware Setting indicating that VJoyD should not load this
+ * driver, it will be loaded externally and will register with
+ * VJoyD of it's own accord.
+ */
+#define JOY_HWS_AUTOLOAD            0x10000000l
+
+/*
+ * Hardware Setting indicating that the driver acquires any
+ * resources needed without needing a devnode through VJoyD.
+ */
+#define JOY_HWS_NODEVNODE           0x20000000l
+
+
+/*
+ * Hardware Setting indicating that the device is a gameport bus
+ */
+#define JOY_HWS_ISGAMEPORTBUS       0x80000000l
+#define JOY_HWS_GAMEPORTBUSBUSY     0x00000001l
+
+/*
+ * Usage Setting indicating that the settings are volatile and
+ * should be removed if still present on a reboot.
+ */
+#define JOY_US_VOLATILE             0x00000008L
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif  /* __VJOYDX_INCLUDED__ */
+
+#endif  /* not MMNOJOY */
+#endif  /* _INC_MMSYSTEM */
+
+/****************************************************************************
+ *
+ *  Definitions for non-IDirectInput (VJoyD) features defined more recently
+ *  than the current ddk files
+ *
+ ****************************************************************************/
+
+#ifndef DIJ_RINGZERO
+
+#ifdef _INC_MMDDK
+#ifndef MMNOJOYDEV
+
+#ifndef __VJOYDXD_INCLUDED__
+#define __VJOYDXD_INCLUDED__
+/*
+ * Poll type in which the do_other field of the JOYOEMPOLLDATA
+ * structure contains mini-driver specific data passed from an app.
+ */
+#define JOY_OEMPOLL_PASSDRIVERDATA  7
+
+#endif  /* __VJOYDXD_INCLUDED__ */
+
+#endif  /* not MMNOJOYDEV */
+#endif  /* _INC_MMDDK */
+
+#endif /* DIJ_RINGZERO */
+
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/classfile_constants.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/classfile_constants.h
new file mode 100755
index 0000000..30e839e
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/classfile_constants.h
@@ -0,0 +1,523 @@
+/*
+ * %W% %E%
+ * 
+ * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ * 
+ */
+
+#ifndef CLASSFILE_CONSTANTS_H
+#define CLASSFILE_CONSTANTS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Flags */
+
+enum {
+    JVM_ACC_PUBLIC        = 0x0001,
+    JVM_ACC_PRIVATE       = 0x0002,
+    JVM_ACC_PROTECTED     = 0x0004,
+    JVM_ACC_STATIC        = 0x0008,
+    JVM_ACC_FINAL         = 0x0010,
+    JVM_ACC_SYNCHRONIZED  = 0x0020,
+    JVM_ACC_SUPER         = 0x0020,
+    JVM_ACC_VOLATILE      = 0x0040,
+    JVM_ACC_BRIDGE        = 0x0040,
+    JVM_ACC_TRANSIENT     = 0x0080,
+    JVM_ACC_VARARGS       = 0x0080,
+    JVM_ACC_NATIVE        = 0x0100,
+    JVM_ACC_INTERFACE     = 0x0200,
+    JVM_ACC_ABSTRACT      = 0x0400,
+    JVM_ACC_STRICT        = 0x0800,
+    JVM_ACC_SYNTHETIC     = 0x1000,
+    JVM_ACC_ANNOTATION    = 0x2000,
+    JVM_ACC_ENUM          = 0x4000
+};
+
+/* Used in newarray instruction. */
+
+enum {
+    JVM_T_BOOLEAN = 4,
+    JVM_T_CHAR    = 5,
+    JVM_T_FLOAT   = 6,
+    JVM_T_DOUBLE  = 7,
+    JVM_T_BYTE    = 8,
+    JVM_T_SHORT   = 9,
+    JVM_T_INT     = 10,
+    JVM_T_LONG    = 11
+};
+
+/* Constant Pool Entries */
+
+enum {
+    JVM_CONSTANT_Utf8                   = 1,
+    JVM_CONSTANT_Unicode                = 2, /* unused */
+    JVM_CONSTANT_Integer                = 3,
+    JVM_CONSTANT_Float                  = 4,
+    JVM_CONSTANT_Long                   = 5,      
+    JVM_CONSTANT_Double                 = 6,
+    JVM_CONSTANT_Class                  = 7,
+    JVM_CONSTANT_String                 = 8,
+    JVM_CONSTANT_Fieldref               = 9,
+    JVM_CONSTANT_Methodref              = 10,
+    JVM_CONSTANT_InterfaceMethodref     = 11,
+    JVM_CONSTANT_NameAndType            = 12
+};
+
+/* StackMapTable type item numbers */
+
+enum {
+    JVM_ITEM_Top                = 0,
+    JVM_ITEM_Integer            = 1,
+    JVM_ITEM_Float              = 2,
+    JVM_ITEM_Double             = 3,
+    JVM_ITEM_Long               = 4,
+    JVM_ITEM_Null               = 5,
+    JVM_ITEM_UninitializedThis  = 6,
+    JVM_ITEM_Object             = 7,
+    JVM_ITEM_Uninitialized      = 8
+};
+
+/* Type signatures */
+
+enum {
+    JVM_SIGNATURE_ARRAY         = '[',
+    JVM_SIGNATURE_BYTE          = 'B',
+    JVM_SIGNATURE_CHAR          = 'C',
+    JVM_SIGNATURE_CLASS         = 'L',
+    JVM_SIGNATURE_ENDCLASS      = ';',
+    JVM_SIGNATURE_ENUM          = 'E',
+    JVM_SIGNATURE_FLOAT         = 'F',
+    JVM_SIGNATURE_DOUBLE        = 'D',
+    JVM_SIGNATURE_FUNC          = '(',
+    JVM_SIGNATURE_ENDFUNC       = ')',
+    JVM_SIGNATURE_INT           = 'I',
+    JVM_SIGNATURE_LONG          = 'J',
+    JVM_SIGNATURE_SHORT         = 'S',
+    JVM_SIGNATURE_VOID          = 'V',
+    JVM_SIGNATURE_BOOLEAN       = 'Z'
+};
+
+/* Opcodes */
+
+enum {
+    JVM_OPC_nop                 = 0,
+    JVM_OPC_aconst_null         = 1,
+    JVM_OPC_iconst_m1           = 2,
+    JVM_OPC_iconst_0            = 3,
+    JVM_OPC_iconst_1            = 4,
+    JVM_OPC_iconst_2            = 5,
+    JVM_OPC_iconst_3            = 6,
+    JVM_OPC_iconst_4            = 7,
+    JVM_OPC_iconst_5            = 8,
+    JVM_OPC_lconst_0            = 9,
+    JVM_OPC_lconst_1            = 10,
+    JVM_OPC_fconst_0            = 11,
+    JVM_OPC_fconst_1            = 12,
+    JVM_OPC_fconst_2            = 13,
+    JVM_OPC_dconst_0            = 14,
+    JVM_OPC_dconst_1            = 15,
+    JVM_OPC_bipush              = 16,
+    JVM_OPC_sipush              = 17,
+    JVM_OPC_ldc                 = 18,
+    JVM_OPC_ldc_w               = 19,
+    JVM_OPC_ldc2_w              = 20,
+    JVM_OPC_iload               = 21,
+    JVM_OPC_lload               = 22,
+    JVM_OPC_fload               = 23,
+    JVM_OPC_dload               = 24,
+    JVM_OPC_aload               = 25,
+    JVM_OPC_iload_0             = 26,
+    JVM_OPC_iload_1             = 27,
+    JVM_OPC_iload_2             = 28,
+    JVM_OPC_iload_3             = 29,
+    JVM_OPC_lload_0             = 30,
+    JVM_OPC_lload_1             = 31,
+    JVM_OPC_lload_2             = 32,
+    JVM_OPC_lload_3             = 33,
+    JVM_OPC_fload_0             = 34,
+    JVM_OPC_fload_1             = 35,
+    JVM_OPC_fload_2             = 36,
+    JVM_OPC_fload_3             = 37,
+    JVM_OPC_dload_0             = 38,
+    JVM_OPC_dload_1             = 39,
+    JVM_OPC_dload_2             = 40,
+    JVM_OPC_dload_3             = 41,
+    JVM_OPC_aload_0             = 42,
+    JVM_OPC_aload_1             = 43,
+    JVM_OPC_aload_2             = 44,
+    JVM_OPC_aload_3             = 45,
+    JVM_OPC_iaload              = 46,
+    JVM_OPC_laload              = 47,
+    JVM_OPC_faload              = 48,
+    JVM_OPC_daload              = 49,
+    JVM_OPC_aaload              = 50,
+    JVM_OPC_baload              = 51,
+    JVM_OPC_caload              = 52,
+    JVM_OPC_saload              = 53,
+    JVM_OPC_istore              = 54,
+    JVM_OPC_lstore              = 55,
+    JVM_OPC_fstore              = 56,
+    JVM_OPC_dstore              = 57,
+    JVM_OPC_astore              = 58,
+    JVM_OPC_istore_0            = 59,
+    JVM_OPC_istore_1            = 60,
+    JVM_OPC_istore_2            = 61,
+    JVM_OPC_istore_3            = 62,
+    JVM_OPC_lstore_0            = 63,
+    JVM_OPC_lstore_1            = 64,
+    JVM_OPC_lstore_2            = 65,
+    JVM_OPC_lstore_3            = 66,
+    JVM_OPC_fstore_0            = 67,
+    JVM_OPC_fstore_1            = 68,
+    JVM_OPC_fstore_2            = 69,
+    JVM_OPC_fstore_3            = 70,
+    JVM_OPC_dstore_0            = 71,
+    JVM_OPC_dstore_1            = 72,
+    JVM_OPC_dstore_2            = 73,
+    JVM_OPC_dstore_3            = 74,
+    JVM_OPC_astore_0            = 75,
+    JVM_OPC_astore_1            = 76,
+    JVM_OPC_astore_2            = 77,
+    JVM_OPC_astore_3            = 78,
+    JVM_OPC_iastore             = 79,
+    JVM_OPC_lastore             = 80,
+    JVM_OPC_fastore             = 81,
+    JVM_OPC_dastore             = 82,
+    JVM_OPC_aastore             = 83,
+    JVM_OPC_bastore             = 84,
+    JVM_OPC_castore             = 85,
+    JVM_OPC_sastore             = 86,
+    JVM_OPC_pop                 = 87,
+    JVM_OPC_pop2                = 88,
+    JVM_OPC_dup                 = 89,
+    JVM_OPC_dup_x1              = 90,
+    JVM_OPC_dup_x2              = 91,
+    JVM_OPC_dup2                = 92,
+    JVM_OPC_dup2_x1             = 93,
+    JVM_OPC_dup2_x2             = 94,
+    JVM_OPC_swap                = 95,
+    JVM_OPC_iadd                = 96,
+    JVM_OPC_ladd                = 97,
+    JVM_OPC_fadd                = 98,
+    JVM_OPC_dadd                = 99,
+    JVM_OPC_isub                = 100,
+    JVM_OPC_lsub                = 101,
+    JVM_OPC_fsub                = 102,
+    JVM_OPC_dsub                = 103,
+    JVM_OPC_imul                = 104,
+    JVM_OPC_lmul                = 105,
+    JVM_OPC_fmul                = 106,
+    JVM_OPC_dmul                = 107,
+    JVM_OPC_idiv                = 108,
+    JVM_OPC_ldiv                = 109,
+    JVM_OPC_fdiv                = 110,
+    JVM_OPC_ddiv                = 111,
+    JVM_OPC_irem                = 112,
+    JVM_OPC_lrem                = 113,
+    JVM_OPC_frem                = 114,
+    JVM_OPC_drem                = 115,
+    JVM_OPC_ineg                = 116,
+    JVM_OPC_lneg                = 117,
+    JVM_OPC_fneg                = 118,
+    JVM_OPC_dneg                = 119,
+    JVM_OPC_ishl                = 120,
+    JVM_OPC_lshl                = 121,
+    JVM_OPC_ishr                = 122,
+    JVM_OPC_lshr                = 123,
+    JVM_OPC_iushr               = 124,
+    JVM_OPC_lushr               = 125,
+    JVM_OPC_iand                = 126,
+    JVM_OPC_land                = 127,
+    JVM_OPC_ior                 = 128,
+    JVM_OPC_lor                 = 129,
+    JVM_OPC_ixor                = 130,
+    JVM_OPC_lxor                = 131,
+    JVM_OPC_iinc                = 132,
+    JVM_OPC_i2l                 = 133,
+    JVM_OPC_i2f                 = 134,
+    JVM_OPC_i2d                 = 135,
+    JVM_OPC_l2i                 = 136,
+    JVM_OPC_l2f                 = 137,
+    JVM_OPC_l2d                 = 138,
+    JVM_OPC_f2i                 = 139,
+    JVM_OPC_f2l                 = 140,
+    JVM_OPC_f2d                 = 141,
+    JVM_OPC_d2i                 = 142,
+    JVM_OPC_d2l                 = 143,
+    JVM_OPC_d2f                 = 144,
+    JVM_OPC_i2b                 = 145,
+    JVM_OPC_i2c                 = 146,
+    JVM_OPC_i2s                 = 147,
+    JVM_OPC_lcmp                = 148,
+    JVM_OPC_fcmpl               = 149,
+    JVM_OPC_fcmpg               = 150,
+    JVM_OPC_dcmpl               = 151,
+    JVM_OPC_dcmpg               = 152,
+    JVM_OPC_ifeq                = 153,
+    JVM_OPC_ifne                = 154,
+    JVM_OPC_iflt                = 155,
+    JVM_OPC_ifge                = 156,
+    JVM_OPC_ifgt                = 157,
+    JVM_OPC_ifle                = 158,
+    JVM_OPC_if_icmpeq           = 159,
+    JVM_OPC_if_icmpne           = 160,
+    JVM_OPC_if_icmplt           = 161,
+    JVM_OPC_if_icmpge           = 162,
+    JVM_OPC_if_icmpgt           = 163,
+    JVM_OPC_if_icmple           = 164,
+    JVM_OPC_if_acmpeq           = 165,
+    JVM_OPC_if_acmpne           = 166,
+    JVM_OPC_goto                = 167,
+    JVM_OPC_jsr                 = 168,
+    JVM_OPC_ret                 = 169,
+    JVM_OPC_tableswitch         = 170,
+    JVM_OPC_lookupswitch        = 171,
+    JVM_OPC_ireturn             = 172,
+    JVM_OPC_lreturn             = 173,
+    JVM_OPC_freturn             = 174,
+    JVM_OPC_dreturn             = 175,
+    JVM_OPC_areturn             = 176,
+    JVM_OPC_return              = 177,
+    JVM_OPC_getstatic           = 178,
+    JVM_OPC_putstatic           = 179,
+    JVM_OPC_getfield            = 180,
+    JVM_OPC_putfield            = 181,
+    JVM_OPC_invokevirtual       = 182,
+    JVM_OPC_invokespecial       = 183,
+    JVM_OPC_invokestatic        = 184,
+    JVM_OPC_invokeinterface     = 185,
+    JVM_OPC_xxxunusedxxx        = 186,
+    JVM_OPC_new                 = 187,
+    JVM_OPC_newarray            = 188,
+    JVM_OPC_anewarray           = 189,
+    JVM_OPC_arraylength         = 190,
+    JVM_OPC_athrow              = 191,
+    JVM_OPC_checkcast           = 192,
+    JVM_OPC_instanceof          = 193,
+    JVM_OPC_monitorenter        = 194,
+    JVM_OPC_monitorexit         = 195,
+    JVM_OPC_wide                = 196,
+    JVM_OPC_multianewarray      = 197,
+    JVM_OPC_ifnull              = 198,
+    JVM_OPC_ifnonnull           = 199,
+    JVM_OPC_goto_w              = 200,
+    JVM_OPC_jsr_w               = 201,
+    JVM_OPC_MAX                 = 201
+};
+
+/* Opcode length initializer, use with something like:
+ *   unsigned char opcode_length[JVM_OPC_MAX+1] = JVM_OPCODE_LENGTH_INITIALIZER;
+ */
+#define JVM_OPCODE_LENGTH_INITIALIZER { \
+   1,   /* nop */                       \
+   1,   /* aconst_null */               \
+   1,   /* iconst_m1 */                 \
+   1,   /* iconst_0 */                  \
+   1,   /* iconst_1 */                  \
+   1,   /* iconst_2 */                  \
+   1,   /* iconst_3 */                  \
+   1,   /* iconst_4 */                  \
+   1,   /* iconst_5 */                  \
+   1,   /* lconst_0 */                  \
+   1,   /* lconst_1 */                  \
+   1,   /* fconst_0 */                  \
+   1,   /* fconst_1 */                  \
+   1,   /* fconst_2 */                  \
+   1,   /* dconst_0 */                  \
+   1,   /* dconst_1 */                  \
+   2,   /* bipush */                    \
+   3,   /* sipush */                    \
+   2,   /* ldc */                       \
+   3,   /* ldc_w */                     \
+   3,   /* ldc2_w */                    \
+   2,   /* iload */                     \
+   2,   /* lload */                     \
+   2,   /* fload */                     \
+   2,   /* dload */                     \
+   2,   /* aload */                     \
+   1,   /* iload_0 */                   \
+   1,   /* iload_1 */                   \
+   1,   /* iload_2 */                   \
+   1,   /* iload_3 */                   \
+   1,   /* lload_0 */                   \
+   1,   /* lload_1 */                   \
+   1,   /* lload_2 */                   \
+   1,   /* lload_3 */                   \
+   1,   /* fload_0 */                   \
+   1,   /* fload_1 */                   \
+   1,   /* fload_2 */                   \
+   1,   /* fload_3 */                   \
+   1,   /* dload_0 */                   \
+   1,   /* dload_1 */                   \
+   1,   /* dload_2 */                   \
+   1,   /* dload_3 */                   \
+   1,   /* aload_0 */                   \
+   1,   /* aload_1 */                   \
+   1,   /* aload_2 */                   \
+   1,   /* aload_3 */                   \
+   1,   /* iaload */                    \
+   1,   /* laload */                    \
+   1,   /* faload */                    \
+   1,   /* daload */                    \
+   1,   /* aaload */                    \
+   1,   /* baload */                    \
+   1,   /* caload */                    \
+   1,   /* saload */                    \
+   2,   /* istore */                    \
+   2,   /* lstore */                    \
+   2,   /* fstore */                    \
+   2,   /* dstore */                    \
+   2,   /* astore */                    \
+   1,   /* istore_0 */                  \
+   1,   /* istore_1 */                  \
+   1,   /* istore_2 */                  \
+   1,   /* istore_3 */                  \
+   1,   /* lstore_0 */                  \
+   1,   /* lstore_1 */                  \
+   1,   /* lstore_2 */                  \
+   1,   /* lstore_3 */                  \
+   1,   /* fstore_0 */                  \
+   1,   /* fstore_1 */                  \
+   1,   /* fstore_2 */                  \
+   1,   /* fstore_3 */                  \
+   1,   /* dstore_0 */                  \
+   1,   /* dstore_1 */                  \
+   1,   /* dstore_2 */                  \
+   1,   /* dstore_3 */                  \
+   1,   /* astore_0 */                  \
+   1,   /* astore_1 */                  \
+   1,   /* astore_2 */                  \
+   1,   /* astore_3 */                  \
+   1,   /* iastore */                   \
+   1,   /* lastore */                   \
+   1,   /* fastore */                   \
+   1,   /* dastore */                   \
+   1,   /* aastore */                   \
+   1,   /* bastore */                   \
+   1,   /* castore */                   \
+   1,   /* sastore */                   \
+   1,   /* pop */                       \
+   1,   /* pop2 */                      \
+   1,   /* dup */                       \
+   1,   /* dup_x1 */                    \
+   1,   /* dup_x2 */                    \
+   1,   /* dup2 */                      \
+   1,   /* dup2_x1 */                   \
+   1,   /* dup2_x2 */                   \
+   1,   /* swap */                      \
+   1,   /* iadd */                      \
+   1,   /* ladd */                      \
+   1,   /* fadd */                      \
+   1,   /* dadd */                      \
+   1,   /* isub */                      \
+   1,   /* lsub */                      \
+   1,   /* fsub */                      \
+   1,   /* dsub */                      \
+   1,   /* imul */                      \
+   1,   /* lmul */                      \
+   1,   /* fmul */                      \
+   1,   /* dmul */                      \
+   1,   /* idiv */                      \
+   1,   /* ldiv */                      \
+   1,   /* fdiv */                      \
+   1,   /* ddiv */                      \
+   1,   /* irem */                      \
+   1,   /* lrem */                      \
+   1,   /* frem */                      \
+   1,   /* drem */                      \
+   1,   /* ineg */                      \
+   1,   /* lneg */                      \
+   1,   /* fneg */                      \
+   1,   /* dneg */                      \
+   1,   /* ishl */                      \
+   1,   /* lshl */                      \
+   1,   /* ishr */                      \
+   1,   /* lshr */                      \
+   1,   /* iushr */                     \
+   1,   /* lushr */                     \
+   1,   /* iand */                      \
+   1,   /* land */                      \
+   1,   /* ior */                       \
+   1,   /* lor */                       \
+   1,   /* ixor */                      \
+   1,   /* lxor */                      \
+   3,   /* iinc */                      \
+   1,   /* i2l */                       \
+   1,   /* i2f */                       \
+   1,   /* i2d */                       \
+   1,   /* l2i */                       \
+   1,   /* l2f */                       \
+   1,   /* l2d */                       \
+   1,   /* f2i */                       \
+   1,   /* f2l */                       \
+   1,   /* f2d */                       \
+   1,   /* d2i */                       \
+   1,   /* d2l */                       \
+   1,   /* d2f */                       \
+   1,   /* i2b */                       \
+   1,   /* i2c */                       \
+   1,   /* i2s */                       \
+   1,   /* lcmp */                      \
+   1,   /* fcmpl */                     \
+   1,   /* fcmpg */                     \
+   1,   /* dcmpl */                     \
+   1,   /* dcmpg */                     \
+   3,   /* ifeq */                      \
+   3,   /* ifne */                      \
+   3,   /* iflt */                      \
+   3,   /* ifge */                      \
+   3,   /* ifgt */                      \
+   3,   /* ifle */                      \
+   3,   /* if_icmpeq */                 \
+   3,   /* if_icmpne */                 \
+   3,   /* if_icmplt */                 \
+   3,   /* if_icmpge */                 \
+   3,   /* if_icmpgt */                 \
+   3,   /* if_icmple */                 \
+   3,   /* if_acmpeq */                 \
+   3,   /* if_acmpne */                 \
+   3,   /* goto */                      \
+   3,   /* jsr */                       \
+   2,   /* ret */                       \
+   99,  /* tableswitch */               \
+   99,  /* lookupswitch */              \
+   1,   /* ireturn */                   \
+   1,   /* lreturn */                   \
+   1,   /* freturn */                   \
+   1,   /* dreturn */                   \
+   1,   /* areturn */                   \
+   1,   /* return */                    \
+   3,   /* getstatic */                 \
+   3,   /* putstatic */                 \
+   3,   /* getfield */                  \
+   3,   /* putfield */                  \
+   3,   /* invokevirtual */             \
+   3,   /* invokespecial */             \
+   3,   /* invokestatic */              \
+   5,   /* invokeinterface */           \
+   0,   /* xxxunusedxxx */              \
+   3,   /* new */                       \
+   2,   /* newarray */                  \
+   3,   /* anewarray */                 \
+   1,   /* arraylength */               \
+   1,   /* athrow */                    \
+   3,   /* checkcast */                 \
+   3,   /* instanceof */                \
+   1,   /* monitorenter */              \
+   1,   /* monitorexit */               \
+   0,   /* wide */                      \
+   4,   /* multianewarray */            \
+   3,   /* ifnull */                    \
+   3,   /* ifnonnull */                 \
+   5,   /* goto_w */                    \
+   5    /* jsr_w */                     \
+}
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif /* __cplusplus */
+
+#endif /* CLASSFILE_CONSTANTS */
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/jawt.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/jawt.h
new file mode 100755
index 0000000..87e0b18
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/jawt.h
@@ -0,0 +1,278 @@
+/*
+ * %W% %E%
+ *
+ * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+#ifndef _JAVASOFT_JAWT_H_
+#define _JAVASOFT_JAWT_H_
+
+#include "jni.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * AWT native interface (new in JDK 1.3)
+ *
+ * The AWT native interface allows a native C or C++ application a means
+ * by which to access native structures in AWT.  This is to facilitate moving
+ * legacy C and C++ applications to Java and to target the needs of the
+ * community who, at present, wish to do their own native rendering to canvases
+ * for performance reasons.  Standard extensions such as Java3D also require a
+ * means to access the underlying native data structures of AWT.
+ *
+ * There may be future extensions to this API depending on demand.
+ *
+ * A VM does not have to implement this API in order to pass the JCK.
+ * It is recommended, however, that this API is implemented on VMs that support
+ * standard extensions, such as Java3D.
+ *
+ * Since this is a native API, any program which uses it cannot be considered
+ * 100% pure java.
+ */
+
+/*
+ * AWT Native Drawing Surface (JAWT_DrawingSurface).
+ *
+ * For each platform, there is a native drawing surface structure.  This
+ * platform-specific structure can be found in jawt_md.h.  It is recommended
+ * that additional platforms follow the same model.  It is also recommended
+ * that VMs on Win32 and Solaris support the existing structures in jawt_md.h.
+ *
+ *******************
+ * EXAMPLE OF USAGE:
+ *******************
+ *
+ * In Win32, a programmer wishes to access the HWND of a canvas to perform
+ * native rendering into it.  The programmer has declared the paint() method
+ * for their canvas subclass to be native:
+ *
+ *
+ * MyCanvas.java:
+ *
+ * import java.awt.*;
+ *
+ * public class MyCanvas extends Canvas {
+ *
+ *     static {
+ *         System.loadLibrary("mylib");
+ *     }
+ *
+ *     public native void paint(Graphics g);
+ * }
+ *
+ *
+ * myfile.c:
+ *
+ * #include "jawt_md.h"
+ * #include <assert.h>
+ *
+ * JNIEXPORT void JNICALL
+ * Java_MyCanvas_paint(JNIEnv* env, jobject canvas, jobject graphics)
+ * {
+ *     JAWT awt;
+ *     JAWT_DrawingSurface* ds;
+ *     JAWT_DrawingSurfaceInfo* dsi;
+ *     JAWT_Win32DrawingSurfaceInfo* dsi_win;
+ *     jboolean result;
+ *     jint lock;
+ *
+ *     // Get the AWT
+ *     awt.version = JAWT_VERSION_1_3;
+ *     result = JAWT_GetAWT(env, &awt);
+ *     assert(result != JNI_FALSE);
+ *
+ *     // Get the drawing surface
+ *     ds = awt.GetDrawingSurface(env, canvas);
+ *     assert(ds != NULL);
+ *
+ *     // Lock the drawing surface
+ *     lock = ds->Lock(ds);
+ *     assert((lock & JAWT_LOCK_ERROR) == 0);
+ *
+ *     // Get the drawing surface info
+ *     dsi = ds->GetDrawingSurfaceInfo(ds);
+ *
+ *     // Get the platform-specific drawing info
+ *     dsi_win = (JAWT_Win32DrawingSurfaceInfo*)dsi->platformInfo;
+ *
+ *     //////////////////////////////
+ *     // !!! DO PAINTING HERE !!! //
+ *     //////////////////////////////
+ *
+ *     // Free the drawing surface info
+ *     ds->FreeDrawingSurfaceInfo(dsi);
+ *
+ *     // Unlock the drawing surface
+ *     ds->Unlock(ds);
+ *
+ *     // Free the drawing surface
+ *     awt.FreeDrawingSurface(ds);
+ * }
+ *
+ */
+
+/*
+ * JAWT_Rectangle
+ * Structure for a native rectangle.
+ */
+typedef struct jawt_Rectangle {
+    jint x;
+    jint y;
+    jint width;
+    jint height;
+} JAWT_Rectangle;
+
+struct jawt_DrawingSurface;
+
+/*
+ * JAWT_DrawingSurfaceInfo
+ * Structure for containing the underlying drawing information of a component.
+ */
+typedef struct jawt_DrawingSurfaceInfo {
+    /*
+     * Pointer to the platform-specific information.  This can be safely
+     * cast to a JAWT_Win32DrawingSurfaceInfo on Windows or a
+     * JAWT_X11DrawingSurfaceInfo on Solaris.  See jawt_md.h for details.
+     */
+    void* platformInfo;
+    /* Cached pointer to the underlying drawing surface */
+    struct jawt_DrawingSurface* ds;
+    /* Bounding rectangle of the drawing surface */
+    JAWT_Rectangle bounds;
+    /* Number of rectangles in the clip */
+    jint clipSize;
+    /* Clip rectangle array */
+    JAWT_Rectangle* clip;
+} JAWT_DrawingSurfaceInfo;
+
+#define JAWT_LOCK_ERROR                 0x00000001
+#define JAWT_LOCK_CLIP_CHANGED          0x00000002
+#define JAWT_LOCK_BOUNDS_CHANGED        0x00000004
+#define JAWT_LOCK_SURFACE_CHANGED       0x00000008
+
+/*
+ * JAWT_DrawingSurface
+ * Structure for containing the underlying drawing information of a component.
+ * All operations on a JAWT_DrawingSurface MUST be performed from the same
+ * thread as the call to GetDrawingSurface.
+ */
+typedef struct jawt_DrawingSurface {
+    /*
+     * Cached reference to the Java environment of the calling thread.
+     * If Lock(), Unlock(), GetDrawingSurfaceInfo() or
+     * FreeDrawingSurfaceInfo() are called from a different thread,
+     * this data member should be set before calling those functions.
+     */
+    JNIEnv* env;
+    /* Cached reference to the target object */
+    jobject target;
+    /*
+     * Lock the surface of the target component for native rendering.
+     * When finished drawing, the surface must be unlocked with
+     * Unlock().  This function returns a bitmask with one or more of the
+     * following values:
+     *
+     * JAWT_LOCK_ERROR - When an error has occurred and the surface could not
+     * be locked.
+     *
+     * JAWT_LOCK_CLIP_CHANGED - When the clip region has changed.
+     *
+     * JAWT_LOCK_BOUNDS_CHANGED - When the bounds of the surface have changed.
+     *
+     * JAWT_LOCK_SURFACE_CHANGED - When the surface itself has changed
+     */
+    jint (JNICALL *Lock)
+        (struct jawt_DrawingSurface* ds);
+    /*
+     * Get the drawing surface info.
+     * The value returned may be cached, but the values may change if
+     * additional calls to Lock() or Unlock() are made.
+     * Lock() must be called before this can return a valid value.
+     * Returns NULL if an error has occurred.
+     * When finished with the returned value, FreeDrawingSurfaceInfo must be
+     * called.
+     */
+    JAWT_DrawingSurfaceInfo* (JNICALL *GetDrawingSurfaceInfo)
+        (struct jawt_DrawingSurface* ds);
+    /*
+     * Free the drawing surface info.
+     */
+    void (JNICALL *FreeDrawingSurfaceInfo)
+        (JAWT_DrawingSurfaceInfo* dsi);
+    /* 
+     * Unlock the drawing surface of the target component for native rendering.
+     */
+    void (JNICALL *Unlock)
+        (struct jawt_DrawingSurface* ds);
+} JAWT_DrawingSurface;
+
+/*
+ * JAWT
+ * Structure for containing native AWT functions.
+ */
+typedef struct jawt {
+    /*
+     * Version of this structure.  This must always be set before
+     * calling JAWT_GetAWT()
+     */
+    jint version;
+    /*
+     * Return a drawing surface from a target jobject.  This value
+     * may be cached.
+     * Returns NULL if an error has occurred.
+     * Target must be a java.awt.Component (should be a Canvas
+     * or Window for native rendering).
+     * FreeDrawingSurface() must be called when finished with the
+     * returned JAWT_DrawingSurface.
+     */
+    JAWT_DrawingSurface* (JNICALL *GetDrawingSurface)
+        (JNIEnv* env, jobject target);
+    /*
+     * Free the drawing surface allocated in GetDrawingSurface.
+     */
+    void (JNICALL *FreeDrawingSurface)
+        (JAWT_DrawingSurface* ds);
+    /*
+     * Since 1.4
+     * Locks the entire AWT for synchronization purposes
+     */
+    void (JNICALL *Lock)(JNIEnv* env);
+    /*
+     * Since 1.4
+     * Unlocks the entire AWT for synchronization purposes
+     */
+    void (JNICALL *Unlock)(JNIEnv* env);
+    /*
+     * Since 1.4
+     * Returns a reference to a java.awt.Component from a native
+     * platform handle.  On Windows, this corresponds to an HWND;
+     * on Solaris and Linux, this is a Drawable.  For other platforms,
+     * see the appropriate machine-dependent header file for a description.
+     * The reference returned by this function is a local
+     * reference that is only valid in this environment.
+     * This function returns a NULL reference if no component could be
+     * found with matching platform information.
+     */
+    jobject (JNICALL *GetComponent)(JNIEnv* env, void* platformInfo);
+
+} JAWT;
+
+/*
+ * Get the AWT native structure.  This function returns JNI_FALSE if
+ * an error occurs.
+ */
+_JNI_IMPORT_OR_EXPORT_
+jboolean JNICALL JAWT_GetAWT(JNIEnv* env, JAWT* awt);
+
+#define JAWT_VERSION_1_3 0x00010003
+#define JAWT_VERSION_1_4 0x00010004
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif /* !_JAVASOFT_JAWT_H_ */
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/jdwpTransport.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/jdwpTransport.h
new file mode 100755
index 0000000..eae435a
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/jdwpTransport.h
@@ -0,0 +1,237 @@
+/*
+ * %W% %E%
+ *
+ * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+/*
+ * Java Debug Wire Protocol Transport Service Provider Interface.
+ */
+
+#ifndef JDWPTRANSPORT_H
+#define JDWPTRANSPORT_H
+
+#include "jni.h"
+
+enum {
+    JDWPTRANSPORT_VERSION_1_0 = 0x00010000
+};
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct jdwpTransportNativeInterface_;
+
+struct _jdwpTransportEnv;
+
+#ifdef __cplusplus
+typedef _jdwpTransportEnv jdwpTransportEnv;
+#else
+typedef const struct jdwpTransportNativeInterface_ *jdwpTransportEnv;
+#endif /* __cplusplus */
+
+/*
+ * Errors. Universal errors with JVMTI/JVMDI equivalents keep the
+ * values the same.
+ */
+typedef enum {
+    JDWPTRANSPORT_ERROR_NONE = 0,
+    JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT = 103,
+    JDWPTRANSPORT_ERROR_OUT_OF_MEMORY = 110,
+    JDWPTRANSPORT_ERROR_INTERNAL = 113,
+    JDWPTRANSPORT_ERROR_ILLEGAL_STATE = 201,
+    JDWPTRANSPORT_ERROR_IO_ERROR = 202,
+    JDWPTRANSPORT_ERROR_TIMEOUT = 203,
+    JDWPTRANSPORT_ERROR_MSG_NOT_AVAILABLE = 204
+} jdwpTransportError;
+    
+
+/*
+ * Structure to define capabilities
+ */
+typedef struct {
+    unsigned int can_timeout_attach     :1;
+    unsigned int can_timeout_accept     :1;
+    unsigned int can_timeout_handshake  :1;
+    unsigned int reserved3              :1;
+    unsigned int reserved4              :1;
+    unsigned int reserved5              :1;
+    unsigned int reserved6              :1;
+    unsigned int reserved7              :1;
+    unsigned int reserved8              :1;
+    unsigned int reserved9              :1;
+    unsigned int reserved10             :1;
+    unsigned int reserved11             :1;
+    unsigned int reserved12             :1;
+    unsigned int reserved13             :1;
+    unsigned int reserved14		:1;
+    unsigned int reserved15		:1;
+} JDWPTransportCapabilities;
+
+
+/*
+ * Structures to define packet layout.
+ * 
+ * See: http://java.sun.com/j2se/1.5/docs/guide/jpda/jdwp-spec.html
+ */
+
+enum {
+    JDWPTRANSPORT_FLAGS_NONE	 = 0x0,
+    JDWPTRANSPORT_FLAGS_REPLY	 = 0x80
+};
+
+typedef struct {
+    jint len; 
+    jint id;
+    jbyte flags;
+    jbyte cmdSet;
+    jbyte cmd;
+    jbyte *data;
+} jdwpCmdPacket;
+
+typedef struct {
+    jint len;
+    jint id;
+    jbyte flags;
+    jshort errorCode;
+    jbyte *data;
+} jdwpReplyPacket;
+
+typedef struct {
+    union {
+        jdwpCmdPacket cmd;
+        jdwpReplyPacket reply;
+    } type;
+} jdwpPacket;
+
+/*
+ * JDWP functions called by the transport.
+ */
+typedef struct jdwpTransportCallback {
+    void *(*alloc)(jint numBytes);   /* Call this for all allocations */
+    void (*free)(void *buffer);      /* Call this for all deallocations */
+} jdwpTransportCallback;
+
+typedef jint (JNICALL *jdwpTransport_OnLoad_t)(JavaVM *jvm,
+					       jdwpTransportCallback *callback,
+					       jint version,
+                                      	       jdwpTransportEnv** env);
+
+
+
+/* Function Interface */
+
+struct jdwpTransportNativeInterface_ {
+    /*  1 :  RESERVED */
+    void *reserved1;
+
+    /*	2 : Get Capabilities */
+    jdwpTransportError (JNICALL *GetCapabilities)(jdwpTransportEnv* env,
+	 JDWPTransportCapabilities *capabilities_ptr);
+
+    /*  3 : Attach */
+    jdwpTransportError (JNICALL *Attach)(jdwpTransportEnv* env,
+	const char* address,
+	jlong attach_timeout,
+	jlong handshake_timeout);
+
+    /*  4: StartListening */
+    jdwpTransportError (JNICALL *StartListening)(jdwpTransportEnv* env,
+	const char* address, 
+	char** actual_address);
+
+    /*  5: StopListening */
+    jdwpTransportError (JNICALL *StopListening)(jdwpTransportEnv* env);
+
+    /*  6: Accept */
+    jdwpTransportError (JNICALL *Accept)(jdwpTransportEnv* env,
+	jlong accept_timeout, 
+	jlong handshake_timeout);
+
+    /*  7: IsOpen */
+    jboolean (JNICALL *IsOpen)(jdwpTransportEnv* env);
+
+    /*  8: Close */
+    jdwpTransportError (JNICALL *Close)(jdwpTransportEnv* env);
+
+    /*  9: ReadPacket */
+    jdwpTransportError (JNICALL *ReadPacket)(jdwpTransportEnv* env,
+	jdwpPacket *pkt);
+
+    /*  10: Write Packet */
+    jdwpTransportError (JNICALL *WritePacket)(jdwpTransportEnv* env,
+	const jdwpPacket* pkt);
+
+    /*  11:  GetLastError */
+    jdwpTransportError (JNICALL *GetLastError)(jdwpTransportEnv* env,
+	char** error);
+
+};
+
+
+/*
+ * Use inlined functions so that C++ code can use syntax such as
+ *	env->Attach("mymachine:5000", 10*1000, 0);
+ *
+ * rather than using C's :-
+ *
+ *	(*env)->Attach(env, "mymachine:5000", 10*1000, 0);
+ */
+struct _jdwpTransportEnv {
+    const struct jdwpTransportNativeInterface_ *functions;
+#ifdef __cplusplus
+
+    jdwpTransportError GetCapabilities(JDWPTransportCapabilities *capabilities_ptr) {
+	return functions->GetCapabilities(this, capabilities_ptr);
+    }
+
+    jdwpTransportError Attach(const char* address, jlong attach_timeout,
+        	jlong handshake_timeout) {
+	return functions->Attach(this, address, attach_timeout, handshake_timeout);
+    }
+
+    jdwpTransportError StartListening(const char* address,
+        	char** actual_address) {
+	return functions->StartListening(this, address, actual_address);
+    }
+
+    jdwpTransportError StopListening(void) {
+	return functions->StopListening(this);
+    }
+
+    jdwpTransportError Accept(jlong accept_timeout, jlong handshake_timeout) {
+	return functions->Accept(this, accept_timeout, handshake_timeout);
+    }
+
+    jboolean IsOpen(void) {
+        return functions->IsOpen(this);
+    }
+
+    jdwpTransportError Close(void) {
+        return functions->Close(this);
+    }
+
+    jdwpTransportError ReadPacket(jdwpPacket *pkt) {
+	return functions->ReadPacket(this, pkt);
+    }
+
+    jdwpTransportError WritePacket(const jdwpPacket* pkt) {
+	return functions->WritePacket(this, pkt);
+    }
+
+    jdwpTransportError GetLastError(char** error) {
+	return functions->GetLastError(this, error);
+    }
+
+
+#endif /* __cplusplus */
+};
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif /* __cplusplus */
+
+#endif /* JDWPTRANSPORT_H */
+
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/jni.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/jni.h
new file mode 100755
index 0000000..8160a9e
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/jni.h
@@ -0,0 +1,1944 @@
+/*
+ * @(#)jni.h	1.63 10/03/23
+ *
+ * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * ORACLE PROPRIETARY/CONFIDENTIAL.  Use is subject to license terms.
+ */
+
+/*
+ * We used part of Netscape's Java Runtime Interface (JRI) as the starting
+ * point of our design and implementation.
+ */
+
+/******************************************************************************
+ * Java Runtime Interface
+ * Copyright (c) 1996 Netscape Communications Corporation. All rights reserved.
+ *****************************************************************************/
+
+#ifndef _JAVASOFT_JNI_H_
+#define _JAVASOFT_JNI_H_
+
+#include <stdio.h>
+#include <stdarg.h>
+
+/* jni_md.h contains the machine-dependent typedefs for jbyte, jint
+   and jlong */
+
+#include "jni_md.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * JNI Types
+ */
+
+#ifndef JNI_TYPES_ALREADY_DEFINED_IN_JNI_MD_H
+
+typedef unsigned char	jboolean;
+typedef unsigned short	jchar;
+typedef short		jshort;
+typedef float		jfloat;
+typedef double		jdouble;
+
+typedef jint            jsize;
+
+#ifdef __cplusplus
+
+class _jobject {};
+class _jclass : public _jobject {};
+class _jthrowable : public _jobject {};
+class _jstring : public _jobject {};
+class _jarray : public _jobject {};
+class _jbooleanArray : public _jarray {};
+class _jbyteArray : public _jarray {};
+class _jcharArray : public _jarray {};
+class _jshortArray : public _jarray {};
+class _jintArray : public _jarray {};
+class _jlongArray : public _jarray {};
+class _jfloatArray : public _jarray {};
+class _jdoubleArray : public _jarray {};
+class _jobjectArray : public _jarray {};
+
+typedef _jobject *jobject;
+typedef _jclass *jclass;
+typedef _jthrowable *jthrowable;
+typedef _jstring *jstring;
+typedef _jarray *jarray;
+typedef _jbooleanArray *jbooleanArray;
+typedef _jbyteArray *jbyteArray;
+typedef _jcharArray *jcharArray;
+typedef _jshortArray *jshortArray;
+typedef _jintArray *jintArray;
+typedef _jlongArray *jlongArray;
+typedef _jfloatArray *jfloatArray;
+typedef _jdoubleArray *jdoubleArray;
+typedef _jobjectArray *jobjectArray;
+
+#else
+
+struct _jobject;
+
+typedef struct _jobject *jobject;
+typedef jobject jclass;
+typedef jobject jthrowable;
+typedef jobject jstring;
+typedef jobject jarray;
+typedef jarray jbooleanArray;
+typedef jarray jbyteArray;
+typedef jarray jcharArray;
+typedef jarray jshortArray;
+typedef jarray jintArray;
+typedef jarray jlongArray;
+typedef jarray jfloatArray;
+typedef jarray jdoubleArray;
+typedef jarray jobjectArray;
+
+#endif
+
+typedef jobject jweak;
+
+typedef union jvalue {
+    jboolean z;
+    jbyte    b;
+    jchar    c;
+    jshort   s;
+    jint     i;
+    jlong    j;
+    jfloat   f;
+    jdouble  d;
+    jobject  l;
+} jvalue;
+
+struct _jfieldID;
+typedef struct _jfieldID *jfieldID;
+
+struct _jmethodID;
+typedef struct _jmethodID *jmethodID;
+
+/* Return values from jobjectRefType */
+typedef enum _jobjectType {
+     JNIInvalidRefType    = 0,
+     JNILocalRefType      = 1,
+     JNIGlobalRefType     = 2,
+     JNIWeakGlobalRefType = 3 
+} jobjectRefType;
+
+
+#endif /* JNI_TYPES_ALREADY_DEFINED_IN_JNI_MD_H */
+
+/*
+ * jboolean constants
+ */
+
+#define JNI_FALSE 0
+#define JNI_TRUE 1
+
+/*
+ * possible return values for JNI functions.
+ */
+
+#define JNI_OK           0                 /* success */
+#define JNI_ERR          (-1)              /* unknown error */
+#define JNI_EDETACHED    (-2)              /* thread detached from the VM */
+#define JNI_EVERSION     (-3)              /* JNI version error */
+#define JNI_ENOMEM       (-4)              /* not enough memory */
+#define JNI_EEXIST       (-5)              /* VM already created */
+#define JNI_EINVAL       (-6)              /* invalid arguments */
+
+/*
+ * used in ReleaseScalarArrayElements
+ */
+
+#define JNI_COMMIT 1
+#define JNI_ABORT 2
+
+/*
+ * used in RegisterNatives to describe native method name, signature,
+ * and function pointer.
+ */
+
+typedef struct {
+    char *name;
+    char *signature;
+    void *fnPtr;
+} JNINativeMethod;
+
+/*
+ * JNI Native Method Interface.
+ */
+
+struct JNINativeInterface_;
+
+struct JNIEnv_;
+
+#ifdef __cplusplus
+typedef JNIEnv_ JNIEnv;
+#else
+typedef const struct JNINativeInterface_ *JNIEnv;
+#endif
+
+/*
+ * JNI Invocation Interface.
+ */
+
+struct JNIInvokeInterface_;
+
+struct JavaVM_;
+
+#ifdef __cplusplus
+typedef JavaVM_ JavaVM;
+#else
+typedef const struct JNIInvokeInterface_ *JavaVM;
+#endif
+
+struct JNINativeInterface_ {
+    void *reserved0;
+    void *reserved1;
+    void *reserved2;
+
+    void *reserved3;
+    jint (JNICALL *GetVersion)(JNIEnv *env);
+
+    jclass (JNICALL *DefineClass)
+      (JNIEnv *env, const char *name, jobject loader, const jbyte *buf,
+       jsize len);
+    jclass (JNICALL *FindClass)
+      (JNIEnv *env, const char *name);
+
+    jmethodID (JNICALL *FromReflectedMethod)
+      (JNIEnv *env, jobject method);
+    jfieldID (JNICALL *FromReflectedField)
+      (JNIEnv *env, jobject field);
+
+    jobject (JNICALL *ToReflectedMethod)
+      (JNIEnv *env, jclass cls, jmethodID methodID, jboolean isStatic);
+
+    jclass (JNICALL *GetSuperclass)
+      (JNIEnv *env, jclass sub);
+    jboolean (JNICALL *IsAssignableFrom)
+      (JNIEnv *env, jclass sub, jclass sup);
+
+    jobject (JNICALL *ToReflectedField)
+      (JNIEnv *env, jclass cls, jfieldID fieldID, jboolean isStatic);
+
+    jint (JNICALL *Throw)
+      (JNIEnv *env, jthrowable obj);
+    jint (JNICALL *ThrowNew)
+      (JNIEnv *env, jclass clazz, const char *msg);
+    jthrowable (JNICALL *ExceptionOccurred)
+      (JNIEnv *env);
+    void (JNICALL *ExceptionDescribe)
+      (JNIEnv *env);
+    void (JNICALL *ExceptionClear)
+      (JNIEnv *env);
+    void (JNICALL *FatalError)
+      (JNIEnv *env, const char *msg);
+
+    jint (JNICALL *PushLocalFrame)
+      (JNIEnv *env, jint capacity);
+    jobject (JNICALL *PopLocalFrame)
+      (JNIEnv *env, jobject result);
+
+    jobject (JNICALL *NewGlobalRef)
+      (JNIEnv *env, jobject lobj);
+    void (JNICALL *DeleteGlobalRef)
+      (JNIEnv *env, jobject gref);
+    void (JNICALL *DeleteLocalRef)
+      (JNIEnv *env, jobject obj);
+    jboolean (JNICALL *IsSameObject)
+      (JNIEnv *env, jobject obj1, jobject obj2);
+    jobject (JNICALL *NewLocalRef)
+      (JNIEnv *env, jobject ref);
+    jint (JNICALL *EnsureLocalCapacity)
+      (JNIEnv *env, jint capacity);
+
+    jobject (JNICALL *AllocObject)
+      (JNIEnv *env, jclass clazz);
+    jobject (JNICALL *NewObject)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jobject (JNICALL *NewObjectV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jobject (JNICALL *NewObjectA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+
+    jclass (JNICALL *GetObjectClass)
+      (JNIEnv *env, jobject obj);
+    jboolean (JNICALL *IsInstanceOf)
+      (JNIEnv *env, jobject obj, jclass clazz);
+
+    jmethodID (JNICALL *GetMethodID)
+      (JNIEnv *env, jclass clazz, const char *name, const char *sig);
+
+    jobject (JNICALL *CallObjectMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jobject (JNICALL *CallObjectMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jobject (JNICALL *CallObjectMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);
+
+    jboolean (JNICALL *CallBooleanMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jboolean (JNICALL *CallBooleanMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jboolean (JNICALL *CallBooleanMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);
+
+    jbyte (JNICALL *CallByteMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jbyte (JNICALL *CallByteMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jbyte (JNICALL *CallByteMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);
+
+    jchar (JNICALL *CallCharMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jchar (JNICALL *CallCharMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jchar (JNICALL *CallCharMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);
+
+    jshort (JNICALL *CallShortMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jshort (JNICALL *CallShortMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jshort (JNICALL *CallShortMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);
+
+    jint (JNICALL *CallIntMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jint (JNICALL *CallIntMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jint (JNICALL *CallIntMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);
+
+    jlong (JNICALL *CallLongMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jlong (JNICALL *CallLongMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jlong (JNICALL *CallLongMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);
+
+    jfloat (JNICALL *CallFloatMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jfloat (JNICALL *CallFloatMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jfloat (JNICALL *CallFloatMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);
+
+    jdouble (JNICALL *CallDoubleMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    jdouble (JNICALL *CallDoubleMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    jdouble (JNICALL *CallDoubleMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);
+
+    void (JNICALL *CallVoidMethod)
+      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
+    void (JNICALL *CallVoidMethodV)
+      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
+    void (JNICALL *CallVoidMethodA)
+      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);
+
+    jobject (JNICALL *CallNonvirtualObjectMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jobject (JNICALL *CallNonvirtualObjectMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jobject (JNICALL *CallNonvirtualObjectMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue * args);
+
+    jboolean (JNICALL *CallNonvirtualBooleanMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jboolean (JNICALL *CallNonvirtualBooleanMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jboolean (JNICALL *CallNonvirtualBooleanMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue * args);
+
+    jbyte (JNICALL *CallNonvirtualByteMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jbyte (JNICALL *CallNonvirtualByteMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jbyte (JNICALL *CallNonvirtualByteMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue *args);
+
+    jchar (JNICALL *CallNonvirtualCharMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jchar (JNICALL *CallNonvirtualCharMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jchar (JNICALL *CallNonvirtualCharMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue *args);
+
+    jshort (JNICALL *CallNonvirtualShortMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jshort (JNICALL *CallNonvirtualShortMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jshort (JNICALL *CallNonvirtualShortMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue *args);
+
+    jint (JNICALL *CallNonvirtualIntMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jint (JNICALL *CallNonvirtualIntMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jint (JNICALL *CallNonvirtualIntMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue *args);
+
+    jlong (JNICALL *CallNonvirtualLongMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jlong (JNICALL *CallNonvirtualLongMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jlong (JNICALL *CallNonvirtualLongMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue *args);
+
+    jfloat (JNICALL *CallNonvirtualFloatMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jfloat (JNICALL *CallNonvirtualFloatMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jfloat (JNICALL *CallNonvirtualFloatMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue *args);
+
+    jdouble (JNICALL *CallNonvirtualDoubleMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    jdouble (JNICALL *CallNonvirtualDoubleMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    jdouble (JNICALL *CallNonvirtualDoubleMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue *args);
+
+    void (JNICALL *CallNonvirtualVoidMethod)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
+    void (JNICALL *CallNonvirtualVoidMethodV)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       va_list args);
+    void (JNICALL *CallNonvirtualVoidMethodA)
+      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
+       const jvalue * args);
+
+    jfieldID (JNICALL *GetFieldID)
+      (JNIEnv *env, jclass clazz, const char *name, const char *sig);
+
+    jobject (JNICALL *GetObjectField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jboolean (JNICALL *GetBooleanField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jbyte (JNICALL *GetByteField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jchar (JNICALL *GetCharField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jshort (JNICALL *GetShortField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jint (JNICALL *GetIntField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jlong (JNICALL *GetLongField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jfloat (JNICALL *GetFloatField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+    jdouble (JNICALL *GetDoubleField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID);
+
+    void (JNICALL *SetObjectField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jobject val);
+    void (JNICALL *SetBooleanField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jboolean val);
+    void (JNICALL *SetByteField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jbyte val);
+    void (JNICALL *SetCharField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jchar val);
+    void (JNICALL *SetShortField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jshort val);
+    void (JNICALL *SetIntField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jint val);
+    void (JNICALL *SetLongField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jlong val);
+    void (JNICALL *SetFloatField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jfloat val);
+    void (JNICALL *SetDoubleField)
+      (JNIEnv *env, jobject obj, jfieldID fieldID, jdouble val);
+
+    jmethodID (JNICALL *GetStaticMethodID)
+      (JNIEnv *env, jclass clazz, const char *name, const char *sig);
+
+    jobject (JNICALL *CallStaticObjectMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jobject (JNICALL *CallStaticObjectMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jobject (JNICALL *CallStaticObjectMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+
+    jboolean (JNICALL *CallStaticBooleanMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jboolean (JNICALL *CallStaticBooleanMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jboolean (JNICALL *CallStaticBooleanMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+
+    jbyte (JNICALL *CallStaticByteMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jbyte (JNICALL *CallStaticByteMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jbyte (JNICALL *CallStaticByteMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+
+    jchar (JNICALL *CallStaticCharMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jchar (JNICALL *CallStaticCharMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jchar (JNICALL *CallStaticCharMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+
+    jshort (JNICALL *CallStaticShortMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jshort (JNICALL *CallStaticShortMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jshort (JNICALL *CallStaticShortMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+
+    jint (JNICALL *CallStaticIntMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jint (JNICALL *CallStaticIntMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jint (JNICALL *CallStaticIntMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+
+    jlong (JNICALL *CallStaticLongMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jlong (JNICALL *CallStaticLongMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jlong (JNICALL *CallStaticLongMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+
+    jfloat (JNICALL *CallStaticFloatMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jfloat (JNICALL *CallStaticFloatMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jfloat (JNICALL *CallStaticFloatMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+
+    jdouble (JNICALL *CallStaticDoubleMethod)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
+    jdouble (JNICALL *CallStaticDoubleMethodV)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
+    jdouble (JNICALL *CallStaticDoubleMethodA)
+      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
+
+    void (JNICALL *CallStaticVoidMethod)
+      (JNIEnv *env, jclass cls, jmethodID methodID, ...);
+    void (JNICALL *CallStaticVoidMethodV)
+      (JNIEnv *env, jclass cls, jmethodID methodID, va_list args);
+    void (JNICALL *CallStaticVoidMethodA)
+      (JNIEnv *env, jclass cls, jmethodID methodID, const jvalue * args);
+
+    jfieldID (JNICALL *GetStaticFieldID)
+      (JNIEnv *env, jclass clazz, const char *name, const char *sig);
+    jobject (JNICALL *GetStaticObjectField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jboolean (JNICALL *GetStaticBooleanField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jbyte (JNICALL *GetStaticByteField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jchar (JNICALL *GetStaticCharField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jshort (JNICALL *GetStaticShortField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jint (JNICALL *GetStaticIntField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jlong (JNICALL *GetStaticLongField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jfloat (JNICALL *GetStaticFloatField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+    jdouble (JNICALL *GetStaticDoubleField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID);
+
+    void (JNICALL *SetStaticObjectField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jobject value);
+    void (JNICALL *SetStaticBooleanField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jboolean value);
+    void (JNICALL *SetStaticByteField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jbyte value);
+    void (JNICALL *SetStaticCharField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jchar value);
+    void (JNICALL *SetStaticShortField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jshort value);
+    void (JNICALL *SetStaticIntField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jint value);
+    void (JNICALL *SetStaticLongField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jlong value);
+    void (JNICALL *SetStaticFloatField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jfloat value);
+    void (JNICALL *SetStaticDoubleField)
+      (JNIEnv *env, jclass clazz, jfieldID fieldID, jdouble value);
+
+    jstring (JNICALL *NewString)
+      (JNIEnv *env, const jchar *unicode, jsize len);
+    jsize (JNICALL *GetStringLength)
+      (JNIEnv *env, jstring str);
+    const jchar *(JNICALL *GetStringChars)
+      (JNIEnv *env, jstring str, jboolean *isCopy);
+    void (JNICALL *ReleaseStringChars)
+      (JNIEnv *env, jstring str, const jchar *chars);
+
+    jstring (JNICALL *NewStringUTF)
+      (JNIEnv *env, const char *utf);
+    jsize (JNICALL *GetStringUTFLength)
+      (JNIEnv *env, jstring str);
+    const char* (JNICALL *GetStringUTFChars)
+      (JNIEnv *env, jstring str, jboolean *isCopy);
+    void (JNICALL *ReleaseStringUTFChars)
+      (JNIEnv *env, jstring str, const char* chars);
+
+
+    jsize (JNICALL *GetArrayLength)
+      (JNIEnv *env, jarray array);
+
+    jobjectArray (JNICALL *NewObjectArray)
+      (JNIEnv *env, jsize len, jclass clazz, jobject init);
+    jobject (JNICALL *GetObjectArrayElement)
+      (JNIEnv *env, jobjectArray array, jsize index);
+    void (JNICALL *SetObjectArrayElement)
+      (JNIEnv *env, jobjectArray array, jsize index, jobject val);
+
+    jbooleanArray (JNICALL *NewBooleanArray)
+      (JNIEnv *env, jsize len);
+    jbyteArray (JNICALL *NewByteArray)
+      (JNIEnv *env, jsize len);
+    jcharArray (JNICALL *NewCharArray)
+      (JNIEnv *env, jsize len);
+    jshortArray (JNICALL *NewShortArray)
+      (JNIEnv *env, jsize len);
+    jintArray (JNICALL *NewIntArray)
+      (JNIEnv *env, jsize len);
+    jlongArray (JNICALL *NewLongArray)
+      (JNIEnv *env, jsize len);
+    jfloatArray (JNICALL *NewFloatArray)
+      (JNIEnv *env, jsize len);
+    jdoubleArray (JNICALL *NewDoubleArray)
+      (JNIEnv *env, jsize len);
+
+    jboolean * (JNICALL *GetBooleanArrayElements)
+      (JNIEnv *env, jbooleanArray array, jboolean *isCopy);
+    jbyte * (JNICALL *GetByteArrayElements)
+      (JNIEnv *env, jbyteArray array, jboolean *isCopy);
+    jchar * (JNICALL *GetCharArrayElements)
+      (JNIEnv *env, jcharArray array, jboolean *isCopy);
+    jshort * (JNICALL *GetShortArrayElements)
+      (JNIEnv *env, jshortArray array, jboolean *isCopy);
+    jint * (JNICALL *GetIntArrayElements)
+      (JNIEnv *env, jintArray array, jboolean *isCopy);
+    jlong * (JNICALL *GetLongArrayElements)
+      (JNIEnv *env, jlongArray array, jboolean *isCopy);
+    jfloat * (JNICALL *GetFloatArrayElements)
+      (JNIEnv *env, jfloatArray array, jboolean *isCopy);
+    jdouble * (JNICALL *GetDoubleArrayElements)
+      (JNIEnv *env, jdoubleArray array, jboolean *isCopy);
+
+    void (JNICALL *ReleaseBooleanArrayElements)
+      (JNIEnv *env, jbooleanArray array, jboolean *elems, jint mode);
+    void (JNICALL *ReleaseByteArrayElements)
+      (JNIEnv *env, jbyteArray array, jbyte *elems, jint mode);
+    void (JNICALL *ReleaseCharArrayElements)
+      (JNIEnv *env, jcharArray array, jchar *elems, jint mode);
+    void (JNICALL *ReleaseShortArrayElements)
+      (JNIEnv *env, jshortArray array, jshort *elems, jint mode);
+    void (JNICALL *ReleaseIntArrayElements)
+      (JNIEnv *env, jintArray array, jint *elems, jint mode);
+    void (JNICALL *ReleaseLongArrayElements)
+      (JNIEnv *env, jlongArray array, jlong *elems, jint mode);
+    void (JNICALL *ReleaseFloatArrayElements)
+      (JNIEnv *env, jfloatArray array, jfloat *elems, jint mode);
+    void (JNICALL *ReleaseDoubleArrayElements)
+      (JNIEnv *env, jdoubleArray array, jdouble *elems, jint mode);
+
+    void (JNICALL *GetBooleanArrayRegion)
+      (JNIEnv *env, jbooleanArray array, jsize start, jsize l, jboolean *buf);
+    void (JNICALL *GetByteArrayRegion)
+      (JNIEnv *env, jbyteArray array, jsize start, jsize len, jbyte *buf);
+    void (JNICALL *GetCharArrayRegion)
+      (JNIEnv *env, jcharArray array, jsize start, jsize len, jchar *buf);
+    void (JNICALL *GetShortArrayRegion)
+      (JNIEnv *env, jshortArray array, jsize start, jsize len, jshort *buf);
+    void (JNICALL *GetIntArrayRegion)
+      (JNIEnv *env, jintArray array, jsize start, jsize len, jint *buf);
+    void (JNICALL *GetLongArrayRegion)
+      (JNIEnv *env, jlongArray array, jsize start, jsize len, jlong *buf);
+    void (JNICALL *GetFloatArrayRegion)
+      (JNIEnv *env, jfloatArray array, jsize start, jsize len, jfloat *buf);
+    void (JNICALL *GetDoubleArrayRegion)
+      (JNIEnv *env, jdoubleArray array, jsize start, jsize len, jdouble *buf);
+
+    void (JNICALL *SetBooleanArrayRegion)
+      (JNIEnv *env, jbooleanArray array, jsize start, jsize l, const jboolean *buf);
+    void (JNICALL *SetByteArrayRegion)
+      (JNIEnv *env, jbyteArray array, jsize start, jsize len, const jbyte *buf);
+    void (JNICALL *SetCharArrayRegion)
+      (JNIEnv *env, jcharArray array, jsize start, jsize len, const jchar *buf);
+    void (JNICALL *SetShortArrayRegion)
+      (JNIEnv *env, jshortArray array, jsize start, jsize len, const jshort *buf);
+    void (JNICALL *SetIntArrayRegion)
+      (JNIEnv *env, jintArray array, jsize start, jsize len, const jint *buf);
+    void (JNICALL *SetLongArrayRegion)
+      (JNIEnv *env, jlongArray array, jsize start, jsize len, const jlong *buf);
+    void (JNICALL *SetFloatArrayRegion)
+      (JNIEnv *env, jfloatArray array, jsize start, jsize len, const jfloat *buf);
+    void (JNICALL *SetDoubleArrayRegion)
+      (JNIEnv *env, jdoubleArray array, jsize start, jsize len, const jdouble *buf);
+
+    jint (JNICALL *RegisterNatives)
+      (JNIEnv *env, jclass clazz, const JNINativeMethod *methods,
+       jint nMethods);
+    jint (JNICALL *UnregisterNatives)
+      (JNIEnv *env, jclass clazz);
+
+    jint (JNICALL *MonitorEnter)
+      (JNIEnv *env, jobject obj);
+    jint (JNICALL *MonitorExit)
+      (JNIEnv *env, jobject obj);
+
+    jint (JNICALL *GetJavaVM)
+      (JNIEnv *env, JavaVM **vm);
+
+    void (JNICALL *GetStringRegion)
+      (JNIEnv *env, jstring str, jsize start, jsize len, jchar *buf);
+    void (JNICALL *GetStringUTFRegion)
+      (JNIEnv *env, jstring str, jsize start, jsize len, char *buf);
+
+    void * (JNICALL *GetPrimitiveArrayCritical)
+      (JNIEnv *env, jarray array, jboolean *isCopy);
+    void (JNICALL *ReleasePrimitiveArrayCritical)
+      (JNIEnv *env, jarray array, void *carray, jint mode);
+
+    const jchar * (JNICALL *GetStringCritical)
+      (JNIEnv *env, jstring string, jboolean *isCopy);
+    void (JNICALL *ReleaseStringCritical)
+      (JNIEnv *env, jstring string, const jchar *cstring);
+
+    jweak (JNICALL *NewWeakGlobalRef)
+       (JNIEnv *env, jobject obj);
+    void (JNICALL *DeleteWeakGlobalRef)
+       (JNIEnv *env, jweak ref);
+
+    jboolean (JNICALL *ExceptionCheck)
+       (JNIEnv *env);
+
+    jobject (JNICALL *NewDirectByteBuffer)
+       (JNIEnv* env, void* address, jlong capacity);
+    void* (JNICALL *GetDirectBufferAddress)
+       (JNIEnv* env, jobject buf);
+    jlong (JNICALL *GetDirectBufferCapacity)
+       (JNIEnv* env, jobject buf);
+
+    /* New JNI 1.6 Features */
+
+    jobjectRefType (JNICALL *GetObjectRefType)
+        (JNIEnv* env, jobject obj);
+};
+
+/*
+ * We use inlined functions for C++ so that programmers can write:
+ *
+ *    env->FindClass("java/lang/String")
+ *
+ * in C++ rather than:
+ *
+ *    (*env)->FindClass(env, "java/lang/String")
+ *
+ * in C.
+ */
+
+struct JNIEnv_ {
+    const struct JNINativeInterface_ *functions;
+#ifdef __cplusplus
+
+    jint GetVersion() {
+        return functions->GetVersion(this);
+    }
+    jclass DefineClass(const char *name, jobject loader, const jbyte *buf,
+		       jsize len) {
+        return functions->DefineClass(this, name, loader, buf, len);
+    }
+    jclass FindClass(const char *name) {
+        return functions->FindClass(this, name);
+    }
+    jmethodID FromReflectedMethod(jobject method) {
+        return functions->FromReflectedMethod(this,method);
+    }
+    jfieldID FromReflectedField(jobject field) {
+        return functions->FromReflectedField(this,field);
+    }
+
+    jobject ToReflectedMethod(jclass cls, jmethodID methodID, jboolean isStatic) {
+        return functions->ToReflectedMethod(this, cls, methodID, isStatic);
+    }
+
+    jclass GetSuperclass(jclass sub) {
+        return functions->GetSuperclass(this, sub);
+    }
+    jboolean IsAssignableFrom(jclass sub, jclass sup) {
+        return functions->IsAssignableFrom(this, sub, sup);
+    }
+
+    jobject ToReflectedField(jclass cls, jfieldID fieldID, jboolean isStatic) {
+        return functions->ToReflectedField(this,cls,fieldID,isStatic);
+    }
+
+    jint Throw(jthrowable obj) {
+        return functions->Throw(this, obj);
+    }
+    jint ThrowNew(jclass clazz, const char *msg) {
+        return functions->ThrowNew(this, clazz, msg);
+    }
+    jthrowable ExceptionOccurred() {
+        return functions->ExceptionOccurred(this);
+    }
+    void ExceptionDescribe() {
+        functions->ExceptionDescribe(this);
+    }
+    void ExceptionClear() {
+        functions->ExceptionClear(this);
+    }
+    void FatalError(const char *msg) {
+        functions->FatalError(this, msg);
+    }
+
+    jint PushLocalFrame(jint capacity) {
+        return functions->PushLocalFrame(this,capacity);
+    }
+    jobject PopLocalFrame(jobject result) {
+        return functions->PopLocalFrame(this,result);
+    }
+
+    jobject NewGlobalRef(jobject lobj) {
+        return functions->NewGlobalRef(this,lobj);
+    }
+    void DeleteGlobalRef(jobject gref) {
+        functions->DeleteGlobalRef(this,gref);
+    }
+    void DeleteLocalRef(jobject obj) {
+        functions->DeleteLocalRef(this, obj);
+    }
+
+    jboolean IsSameObject(jobject obj1, jobject obj2) {
+        return functions->IsSameObject(this,obj1,obj2);
+    }
+
+    jobject NewLocalRef(jobject ref) {
+        return functions->NewLocalRef(this,ref);
+    }
+    jint EnsureLocalCapacity(jint capacity) {
+        return functions->EnsureLocalCapacity(this,capacity);
+    }
+
+    jobject AllocObject(jclass clazz) {
+        return functions->AllocObject(this,clazz);
+    }
+    jobject NewObject(jclass clazz, jmethodID methodID, ...) {
+        va_list args;
+	jobject result;
+	va_start(args, methodID);
+        result = functions->NewObjectV(this,clazz,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jobject NewObjectV(jclass clazz, jmethodID methodID,
+		       va_list args) {
+        return functions->NewObjectV(this,clazz,methodID,args);
+    }
+    jobject NewObjectA(jclass clazz, jmethodID methodID,
+		       const jvalue *args) {
+        return functions->NewObjectA(this,clazz,methodID,args);
+    }
+
+    jclass GetObjectClass(jobject obj) {
+        return functions->GetObjectClass(this,obj);
+    }
+    jboolean IsInstanceOf(jobject obj, jclass clazz) {
+        return functions->IsInstanceOf(this,obj,clazz);
+    }
+
+    jmethodID GetMethodID(jclass clazz, const char *name,
+			  const char *sig) {
+        return functions->GetMethodID(this,clazz,name,sig);
+    }
+
+    jobject CallObjectMethod(jobject obj, jmethodID methodID, ...) {
+        va_list args;
+	jobject result;
+	va_start(args,methodID);
+	result = functions->CallObjectMethodV(this,obj,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jobject CallObjectMethodV(jobject obj, jmethodID methodID,
+			va_list args) {
+        return functions->CallObjectMethodV(this,obj,methodID,args);
+    }
+    jobject CallObjectMethodA(jobject obj, jmethodID methodID,
+			const jvalue * args) {
+        return functions->CallObjectMethodA(this,obj,methodID,args);
+    }
+
+    jboolean CallBooleanMethod(jobject obj,
+			       jmethodID methodID, ...) {
+        va_list args;
+	jboolean result;
+	va_start(args,methodID);
+	result = functions->CallBooleanMethodV(this,obj,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jboolean CallBooleanMethodV(jobject obj, jmethodID methodID,
+				va_list args) {
+        return functions->CallBooleanMethodV(this,obj,methodID,args);
+    }
+    jboolean CallBooleanMethodA(jobject obj, jmethodID methodID,
+				const jvalue * args) {
+        return functions->CallBooleanMethodA(this,obj,methodID, args);
+    }
+
+    jbyte CallByteMethod(jobject obj, jmethodID methodID, ...) {
+        va_list args;
+	jbyte result;
+	va_start(args,methodID);
+	result = functions->CallByteMethodV(this,obj,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jbyte CallByteMethodV(jobject obj, jmethodID methodID,
+			  va_list args) {
+        return functions->CallByteMethodV(this,obj,methodID,args);
+    }
+    jbyte CallByteMethodA(jobject obj, jmethodID methodID,
+			  const jvalue * args) {
+        return functions->CallByteMethodA(this,obj,methodID,args);
+    }
+
+    jchar CallCharMethod(jobject obj, jmethodID methodID, ...) {
+        va_list args;
+	jchar result;
+	va_start(args,methodID);
+	result = functions->CallCharMethodV(this,obj,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jchar CallCharMethodV(jobject obj, jmethodID methodID,
+			  va_list args) {
+        return functions->CallCharMethodV(this,obj,methodID,args);
+    }
+    jchar CallCharMethodA(jobject obj, jmethodID methodID,
+			  const jvalue * args) {
+        return functions->CallCharMethodA(this,obj,methodID,args);
+    }
+
+    jshort CallShortMethod(jobject obj, jmethodID methodID, ...) {
+        va_list args;
+	jshort result;
+	va_start(args,methodID);
+	result = functions->CallShortMethodV(this,obj,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jshort CallShortMethodV(jobject obj, jmethodID methodID,
+			    va_list args) {
+        return functions->CallShortMethodV(this,obj,methodID,args);
+    }
+    jshort CallShortMethodA(jobject obj, jmethodID methodID,
+			    const jvalue * args) {
+        return functions->CallShortMethodA(this,obj,methodID,args);
+    }
+
+    jint CallIntMethod(jobject obj, jmethodID methodID, ...) {
+        va_list args;
+	jint result;
+	va_start(args,methodID);
+	result = functions->CallIntMethodV(this,obj,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jint CallIntMethodV(jobject obj, jmethodID methodID,
+			va_list args) {
+        return functions->CallIntMethodV(this,obj,methodID,args);
+    }
+    jint CallIntMethodA(jobject obj, jmethodID methodID,
+			const jvalue * args) {
+        return functions->CallIntMethodA(this,obj,methodID,args);
+    }
+
+    jlong CallLongMethod(jobject obj, jmethodID methodID, ...) {
+        va_list args;
+	jlong result;
+	va_start(args,methodID);
+	result = functions->CallLongMethodV(this,obj,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jlong CallLongMethodV(jobject obj, jmethodID methodID,
+			  va_list args) {
+        return functions->CallLongMethodV(this,obj,methodID,args);
+    }
+    jlong CallLongMethodA(jobject obj, jmethodID methodID,
+			  const jvalue * args) {
+        return functions->CallLongMethodA(this,obj,methodID,args);
+    }
+
+    jfloat CallFloatMethod(jobject obj, jmethodID methodID, ...) {
+        va_list args;
+	jfloat result;
+	va_start(args,methodID);
+	result = functions->CallFloatMethodV(this,obj,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jfloat CallFloatMethodV(jobject obj, jmethodID methodID,
+			    va_list args) {
+        return functions->CallFloatMethodV(this,obj,methodID,args);
+    }
+    jfloat CallFloatMethodA(jobject obj, jmethodID methodID,
+			    const jvalue * args) {
+        return functions->CallFloatMethodA(this,obj,methodID,args);
+    }
+
+    jdouble CallDoubleMethod(jobject obj, jmethodID methodID, ...) {
+        va_list args;
+	jdouble result;
+	va_start(args,methodID);
+	result = functions->CallDoubleMethodV(this,obj,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jdouble CallDoubleMethodV(jobject obj, jmethodID methodID,
+			va_list args) {
+        return functions->CallDoubleMethodV(this,obj,methodID,args);
+    }
+    jdouble CallDoubleMethodA(jobject obj, jmethodID methodID,
+			const jvalue * args) {
+        return functions->CallDoubleMethodA(this,obj,methodID,args);
+    }
+
+    void CallVoidMethod(jobject obj, jmethodID methodID, ...) {
+        va_list args;
+	va_start(args,methodID);
+	functions->CallVoidMethodV(this,obj,methodID,args);
+	va_end(args);
+    }
+    void CallVoidMethodV(jobject obj, jmethodID methodID,
+			 va_list args) {
+        functions->CallVoidMethodV(this,obj,methodID,args);
+    }
+    void CallVoidMethodA(jobject obj, jmethodID methodID,
+			 const jvalue * args) {
+        functions->CallVoidMethodA(this,obj,methodID,args);
+    }
+
+    jobject CallNonvirtualObjectMethod(jobject obj, jclass clazz,
+				       jmethodID methodID, ...) {
+        va_list args;
+	jobject result;
+	va_start(args,methodID);
+	result = functions->CallNonvirtualObjectMethodV(this,obj,clazz,
+							methodID,args);
+	va_end(args);
+	return result;
+    }
+    jobject CallNonvirtualObjectMethodV(jobject obj, jclass clazz,
+					jmethodID methodID, va_list args) {
+        return functions->CallNonvirtualObjectMethodV(this,obj,clazz,
+						      methodID,args);
+    }
+    jobject CallNonvirtualObjectMethodA(jobject obj, jclass clazz,
+					jmethodID methodID, const jvalue * args) {
+        return functions->CallNonvirtualObjectMethodA(this,obj,clazz,
+						      methodID,args);
+    }
+
+    jboolean CallNonvirtualBooleanMethod(jobject obj, jclass clazz,
+					 jmethodID methodID, ...) {
+        va_list args;
+	jboolean result;
+	va_start(args,methodID);
+	result = functions->CallNonvirtualBooleanMethodV(this,obj,clazz,
+							 methodID,args);
+	va_end(args);
+	return result;
+    }
+    jboolean CallNonvirtualBooleanMethodV(jobject obj, jclass clazz,
+					  jmethodID methodID, va_list args) {
+        return functions->CallNonvirtualBooleanMethodV(this,obj,clazz,
+						       methodID,args);
+    }
+    jboolean CallNonvirtualBooleanMethodA(jobject obj, jclass clazz,
+					  jmethodID methodID, const jvalue * args) {
+        return functions->CallNonvirtualBooleanMethodA(this,obj,clazz,
+						       methodID, args);
+    }
+
+    jbyte CallNonvirtualByteMethod(jobject obj, jclass clazz,
+				   jmethodID methodID, ...) {
+        va_list args;
+	jbyte result;
+	va_start(args,methodID);
+	result = functions->CallNonvirtualByteMethodV(this,obj,clazz,
+						      methodID,args);
+	va_end(args);
+	return result;
+    }
+    jbyte CallNonvirtualByteMethodV(jobject obj, jclass clazz,
+				    jmethodID methodID, va_list args) {
+        return functions->CallNonvirtualByteMethodV(this,obj,clazz,
+						    methodID,args);
+    }
+    jbyte CallNonvirtualByteMethodA(jobject obj, jclass clazz,
+				    jmethodID methodID, const jvalue * args) {
+        return functions->CallNonvirtualByteMethodA(this,obj,clazz,
+						    methodID,args);
+    }
+
+    jchar CallNonvirtualCharMethod(jobject obj, jclass clazz,
+				   jmethodID methodID, ...) {
+        va_list args;
+	jchar result;
+	va_start(args,methodID);
+	result = functions->CallNonvirtualCharMethodV(this,obj,clazz,
+						      methodID,args);
+	va_end(args);
+	return result;
+    }
+    jchar CallNonvirtualCharMethodV(jobject obj, jclass clazz,
+				    jmethodID methodID, va_list args) {
+        return functions->CallNonvirtualCharMethodV(this,obj,clazz,
+						    methodID,args);
+    }
+    jchar CallNonvirtualCharMethodA(jobject obj, jclass clazz,
+				    jmethodID methodID, const jvalue * args) {
+        return functions->CallNonvirtualCharMethodA(this,obj,clazz,
+						    methodID,args);
+    }
+
+    jshort CallNonvirtualShortMethod(jobject obj, jclass clazz,
+				     jmethodID methodID, ...) {
+        va_list args;
+	jshort result;
+	va_start(args,methodID);
+	result = functions->CallNonvirtualShortMethodV(this,obj,clazz,
+						       methodID,args);
+	va_end(args);
+	return result;
+    }
+    jshort CallNonvirtualShortMethodV(jobject obj, jclass clazz,
+				      jmethodID methodID, va_list args) {
+        return functions->CallNonvirtualShortMethodV(this,obj,clazz,
+						     methodID,args);
+    }
+    jshort CallNonvirtualShortMethodA(jobject obj, jclass clazz,
+				      jmethodID methodID, const jvalue * args) {
+        return functions->CallNonvirtualShortMethodA(this,obj,clazz,
+						     methodID,args);
+    }
+
+    jint CallNonvirtualIntMethod(jobject obj, jclass clazz,
+				 jmethodID methodID, ...) {
+        va_list args;
+	jint result;
+	va_start(args,methodID);
+	result = functions->CallNonvirtualIntMethodV(this,obj,clazz,
+						     methodID,args);
+	va_end(args);
+	return result;
+    }
+    jint CallNonvirtualIntMethodV(jobject obj, jclass clazz,
+				  jmethodID methodID, va_list args) {
+        return functions->CallNonvirtualIntMethodV(this,obj,clazz,
+						   methodID,args);
+    }
+    jint CallNonvirtualIntMethodA(jobject obj, jclass clazz,
+				  jmethodID methodID, const jvalue * args) {
+        return functions->CallNonvirtualIntMethodA(this,obj,clazz,
+						   methodID,args);
+    }
+
+    jlong CallNonvirtualLongMethod(jobject obj, jclass clazz,
+				   jmethodID methodID, ...) {
+        va_list args;
+	jlong result;
+	va_start(args,methodID);
+	result = functions->CallNonvirtualLongMethodV(this,obj,clazz,
+						      methodID,args);
+	va_end(args);
+	return result;
+    }
+    jlong CallNonvirtualLongMethodV(jobject obj, jclass clazz,
+				    jmethodID methodID, va_list args) {
+        return functions->CallNonvirtualLongMethodV(this,obj,clazz,
+						    methodID,args);
+    }
+    jlong CallNonvirtualLongMethodA(jobject obj, jclass clazz,
+				    jmethodID methodID, const jvalue * args) {
+        return functions->CallNonvirtualLongMethodA(this,obj,clazz,
+						    methodID,args);
+    }
+
+    jfloat CallNonvirtualFloatMethod(jobject obj, jclass clazz,
+				     jmethodID methodID, ...) {
+        va_list args;
+	jfloat result;
+	va_start(args,methodID);
+	result = functions->CallNonvirtualFloatMethodV(this,obj,clazz,
+						       methodID,args);
+	va_end(args);
+	return result;
+    }
+    jfloat CallNonvirtualFloatMethodV(jobject obj, jclass clazz,
+				      jmethodID methodID,
+				      va_list args) {
+        return functions->CallNonvirtualFloatMethodV(this,obj,clazz,
+						     methodID,args);
+    }
+    jfloat CallNonvirtualFloatMethodA(jobject obj, jclass clazz,
+				      jmethodID methodID,
+				      const jvalue * args) {
+        return functions->CallNonvirtualFloatMethodA(this,obj,clazz,
+						     methodID,args);
+    }
+
+    jdouble CallNonvirtualDoubleMethod(jobject obj, jclass clazz,
+				       jmethodID methodID, ...) {
+        va_list args;
+	jdouble result;
+	va_start(args,methodID);
+	result = functions->CallNonvirtualDoubleMethodV(this,obj,clazz,
+							methodID,args);
+	va_end(args);
+	return result;
+    }
+    jdouble CallNonvirtualDoubleMethodV(jobject obj, jclass clazz,
+					jmethodID methodID,
+					va_list args) {
+        return functions->CallNonvirtualDoubleMethodV(this,obj,clazz,
+						      methodID,args);
+    }
+    jdouble CallNonvirtualDoubleMethodA(jobject obj, jclass clazz,
+					jmethodID methodID,
+					const jvalue * args) {
+        return functions->CallNonvirtualDoubleMethodA(this,obj,clazz,
+						      methodID,args);
+    }
+
+    void CallNonvirtualVoidMethod(jobject obj, jclass clazz,
+				  jmethodID methodID, ...) {
+        va_list args;
+	va_start(args,methodID);
+	functions->CallNonvirtualVoidMethodV(this,obj,clazz,methodID,args);
+	va_end(args);
+    }
+    void CallNonvirtualVoidMethodV(jobject obj, jclass clazz,
+				   jmethodID methodID,
+				   va_list args) {
+        functions->CallNonvirtualVoidMethodV(this,obj,clazz,methodID,args);
+    }
+    void CallNonvirtualVoidMethodA(jobject obj, jclass clazz,
+				   jmethodID methodID,
+				   const jvalue * args) {
+        functions->CallNonvirtualVoidMethodA(this,obj,clazz,methodID,args);
+    }
+
+    jfieldID GetFieldID(jclass clazz, const char *name,
+			const char *sig) {
+        return functions->GetFieldID(this,clazz,name,sig);
+    }
+
+    jobject GetObjectField(jobject obj, jfieldID fieldID) {
+        return functions->GetObjectField(this,obj,fieldID);
+    }
+    jboolean GetBooleanField(jobject obj, jfieldID fieldID) {
+        return functions->GetBooleanField(this,obj,fieldID);
+    }
+    jbyte GetByteField(jobject obj, jfieldID fieldID) {
+        return functions->GetByteField(this,obj,fieldID);
+    }
+    jchar GetCharField(jobject obj, jfieldID fieldID) {
+        return functions->GetCharField(this,obj,fieldID);
+    }
+    jshort GetShortField(jobject obj, jfieldID fieldID) {
+        return functions->GetShortField(this,obj,fieldID);
+    }
+    jint GetIntField(jobject obj, jfieldID fieldID) {
+        return functions->GetIntField(this,obj,fieldID);
+    }
+    jlong GetLongField(jobject obj, jfieldID fieldID) {
+        return functions->GetLongField(this,obj,fieldID);
+    }
+    jfloat GetFloatField(jobject obj, jfieldID fieldID) {
+        return functions->GetFloatField(this,obj,fieldID);
+    }
+    jdouble GetDoubleField(jobject obj, jfieldID fieldID) {
+        return functions->GetDoubleField(this,obj,fieldID);
+    }
+
+    void SetObjectField(jobject obj, jfieldID fieldID, jobject val) {
+        functions->SetObjectField(this,obj,fieldID,val);
+    }
+    void SetBooleanField(jobject obj, jfieldID fieldID,
+			 jboolean val) {
+        functions->SetBooleanField(this,obj,fieldID,val);
+    }
+    void SetByteField(jobject obj, jfieldID fieldID,
+		      jbyte val) {
+        functions->SetByteField(this,obj,fieldID,val);
+    }
+    void SetCharField(jobject obj, jfieldID fieldID,
+		      jchar val) {
+        functions->SetCharField(this,obj,fieldID,val);
+    }
+    void SetShortField(jobject obj, jfieldID fieldID,
+		       jshort val) {
+        functions->SetShortField(this,obj,fieldID,val);
+    }
+    void SetIntField(jobject obj, jfieldID fieldID,
+		     jint val) {
+        functions->SetIntField(this,obj,fieldID,val);
+    }
+    void SetLongField(jobject obj, jfieldID fieldID,
+		      jlong val) {
+        functions->SetLongField(this,obj,fieldID,val);
+    }
+    void SetFloatField(jobject obj, jfieldID fieldID,
+		       jfloat val) {
+        functions->SetFloatField(this,obj,fieldID,val);
+    }
+    void SetDoubleField(jobject obj, jfieldID fieldID,
+			jdouble val) {
+        functions->SetDoubleField(this,obj,fieldID,val);
+    }
+
+    jmethodID GetStaticMethodID(jclass clazz, const char *name,
+				const char *sig) {
+        return functions->GetStaticMethodID(this,clazz,name,sig);
+    }
+
+    jobject CallStaticObjectMethod(jclass clazz, jmethodID methodID,
+			     ...) {
+        va_list args;
+	jobject result;
+	va_start(args,methodID);
+	result = functions->CallStaticObjectMethodV(this,clazz,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jobject CallStaticObjectMethodV(jclass clazz, jmethodID methodID,
+			      va_list args) {
+        return functions->CallStaticObjectMethodV(this,clazz,methodID,args);
+    }
+    jobject CallStaticObjectMethodA(jclass clazz, jmethodID methodID,
+			      const jvalue *args) {
+        return functions->CallStaticObjectMethodA(this,clazz,methodID,args);
+    }
+
+    jboolean CallStaticBooleanMethod(jclass clazz,
+				     jmethodID methodID, ...) {
+        va_list args;
+	jboolean result;
+	va_start(args,methodID);
+	result = functions->CallStaticBooleanMethodV(this,clazz,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jboolean CallStaticBooleanMethodV(jclass clazz,
+				      jmethodID methodID, va_list args) {
+        return functions->CallStaticBooleanMethodV(this,clazz,methodID,args);
+    }
+    jboolean CallStaticBooleanMethodA(jclass clazz,
+				      jmethodID methodID, const jvalue *args) {
+        return functions->CallStaticBooleanMethodA(this,clazz,methodID,args);
+    }
+
+    jbyte CallStaticByteMethod(jclass clazz,
+			       jmethodID methodID, ...) {
+        va_list args;
+	jbyte result;
+	va_start(args,methodID);
+	result = functions->CallStaticByteMethodV(this,clazz,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jbyte CallStaticByteMethodV(jclass clazz,
+				jmethodID methodID, va_list args) {
+        return functions->CallStaticByteMethodV(this,clazz,methodID,args);
+    }
+    jbyte CallStaticByteMethodA(jclass clazz,
+				jmethodID methodID, const jvalue *args) {
+        return functions->CallStaticByteMethodA(this,clazz,methodID,args);
+    }
+
+    jchar CallStaticCharMethod(jclass clazz,
+			       jmethodID methodID, ...) {
+        va_list args;
+	jchar result;
+	va_start(args,methodID);
+	result = functions->CallStaticCharMethodV(this,clazz,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jchar CallStaticCharMethodV(jclass clazz,
+				jmethodID methodID, va_list args) {
+        return functions->CallStaticCharMethodV(this,clazz,methodID,args);
+    }
+    jchar CallStaticCharMethodA(jclass clazz,
+				jmethodID methodID, const jvalue *args) {
+        return functions->CallStaticCharMethodA(this,clazz,methodID,args);
+    }
+
+    jshort CallStaticShortMethod(jclass clazz,
+				 jmethodID methodID, ...) {
+        va_list args;
+	jshort result;
+	va_start(args,methodID);
+	result = functions->CallStaticShortMethodV(this,clazz,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jshort CallStaticShortMethodV(jclass clazz,
+				  jmethodID methodID, va_list args) {
+        return functions->CallStaticShortMethodV(this,clazz,methodID,args);
+    }
+    jshort CallStaticShortMethodA(jclass clazz,
+				  jmethodID methodID, const jvalue *args) {
+        return functions->CallStaticShortMethodA(this,clazz,methodID,args);
+    }
+
+    jint CallStaticIntMethod(jclass clazz,
+			     jmethodID methodID, ...) {
+        va_list args;
+	jint result;
+	va_start(args,methodID);
+	result = functions->CallStaticIntMethodV(this,clazz,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jint CallStaticIntMethodV(jclass clazz,
+			      jmethodID methodID, va_list args) {
+        return functions->CallStaticIntMethodV(this,clazz,methodID,args);
+    }
+    jint CallStaticIntMethodA(jclass clazz,
+			      jmethodID methodID, const jvalue *args) {
+        return functions->CallStaticIntMethodA(this,clazz,methodID,args);
+    }
+
+    jlong CallStaticLongMethod(jclass clazz,
+			       jmethodID methodID, ...) {
+        va_list args;
+	jlong result;
+	va_start(args,methodID);
+	result = functions->CallStaticLongMethodV(this,clazz,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jlong CallStaticLongMethodV(jclass clazz,
+				jmethodID methodID, va_list args) {
+        return functions->CallStaticLongMethodV(this,clazz,methodID,args);
+    }
+    jlong CallStaticLongMethodA(jclass clazz,
+				jmethodID methodID, const jvalue *args) {
+        return functions->CallStaticLongMethodA(this,clazz,methodID,args);
+    }
+
+    jfloat CallStaticFloatMethod(jclass clazz,
+				 jmethodID methodID, ...) {
+        va_list args;
+	jfloat result;
+	va_start(args,methodID);
+	result = functions->CallStaticFloatMethodV(this,clazz,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jfloat CallStaticFloatMethodV(jclass clazz,
+				  jmethodID methodID, va_list args) {
+        return functions->CallStaticFloatMethodV(this,clazz,methodID,args);
+    }
+    jfloat CallStaticFloatMethodA(jclass clazz,
+				  jmethodID methodID, const jvalue *args) {
+        return functions->CallStaticFloatMethodA(this,clazz,methodID,args);
+    }
+
+    jdouble CallStaticDoubleMethod(jclass clazz,
+				   jmethodID methodID, ...) {
+        va_list args;
+	jdouble result;
+	va_start(args,methodID);
+	result = functions->CallStaticDoubleMethodV(this,clazz,methodID,args);
+	va_end(args);
+	return result;
+    }
+    jdouble CallStaticDoubleMethodV(jclass clazz,
+				    jmethodID methodID, va_list args) {
+        return functions->CallStaticDoubleMethodV(this,clazz,methodID,args);
+    }
+    jdouble CallStaticDoubleMethodA(jclass clazz,
+				    jmethodID methodID, const jvalue *args) {
+        return functions->CallStaticDoubleMethodA(this,clazz,methodID,args);
+    }
+
+    void CallStaticVoidMethod(jclass cls, jmethodID methodID, ...) {
+        va_list args;
+	va_start(args,methodID);
+	functions->CallStaticVoidMethodV(this,cls,methodID,args);
+	va_end(args);
+    }
+    void CallStaticVoidMethodV(jclass cls, jmethodID methodID,
+			       va_list args) {
+        functions->CallStaticVoidMethodV(this,cls,methodID,args);
+    }
+    void CallStaticVoidMethodA(jclass cls, jmethodID methodID,
+			       const jvalue * args) {
+        functions->CallStaticVoidMethodA(this,cls,methodID,args);
+    }
+
+    jfieldID GetStaticFieldID(jclass clazz, const char *name,
+			      const char *sig) {
+        return functions->GetStaticFieldID(this,clazz,name,sig);
+    }
+    jobject GetStaticObjectField(jclass clazz, jfieldID fieldID) {
+        return functions->GetStaticObjectField(this,clazz,fieldID);
+    }
+    jboolean GetStaticBooleanField(jclass clazz, jfieldID fieldID) {
+        return functions->GetStaticBooleanField(this,clazz,fieldID);
+    }
+    jbyte GetStaticByteField(jclass clazz, jfieldID fieldID) {
+        return functions->GetStaticByteField(this,clazz,fieldID);
+    }
+    jchar GetStaticCharField(jclass clazz, jfieldID fieldID) {
+        return functions->GetStaticCharField(this,clazz,fieldID);
+    }
+    jshort GetStaticShortField(jclass clazz, jfieldID fieldID) {
+        return functions->GetStaticShortField(this,clazz,fieldID);
+    }
+    jint GetStaticIntField(jclass clazz, jfieldID fieldID) {
+        return functions->GetStaticIntField(this,clazz,fieldID);
+    }
+    jlong GetStaticLongField(jclass clazz, jfieldID fieldID) {
+        return functions->GetStaticLongField(this,clazz,fieldID);
+    }
+    jfloat GetStaticFloatField(jclass clazz, jfieldID fieldID) {
+        return functions->GetStaticFloatField(this,clazz,fieldID);
+    }
+    jdouble GetStaticDoubleField(jclass clazz, jfieldID fieldID) {
+        return functions->GetStaticDoubleField(this,clazz,fieldID);
+    }
+
+    void SetStaticObjectField(jclass clazz, jfieldID fieldID,
+			jobject value) {
+      functions->SetStaticObjectField(this,clazz,fieldID,value);
+    }
+    void SetStaticBooleanField(jclass clazz, jfieldID fieldID,
+			jboolean value) {
+      functions->SetStaticBooleanField(this,clazz,fieldID,value);
+    }
+    void SetStaticByteField(jclass clazz, jfieldID fieldID,
+			jbyte value) {
+      functions->SetStaticByteField(this,clazz,fieldID,value);
+    }
+    void SetStaticCharField(jclass clazz, jfieldID fieldID,
+			jchar value) {
+      functions->SetStaticCharField(this,clazz,fieldID,value);
+    }
+    void SetStaticShortField(jclass clazz, jfieldID fieldID,
+			jshort value) {
+      functions->SetStaticShortField(this,clazz,fieldID,value);
+    }
+    void SetStaticIntField(jclass clazz, jfieldID fieldID,
+			jint value) {
+      functions->SetStaticIntField(this,clazz,fieldID,value);
+    }
+    void SetStaticLongField(jclass clazz, jfieldID fieldID,
+			jlong value) {
+      functions->SetStaticLongField(this,clazz,fieldID,value);
+    }
+    void SetStaticFloatField(jclass clazz, jfieldID fieldID,
+			jfloat value) {
+      functions->SetStaticFloatField(this,clazz,fieldID,value);
+    }
+    void SetStaticDoubleField(jclass clazz, jfieldID fieldID,
+			jdouble value) {
+      functions->SetStaticDoubleField(this,clazz,fieldID,value);
+    }
+
+    jstring NewString(const jchar *unicode, jsize len) {
+        return functions->NewString(this,unicode,len);
+    }
+    jsize GetStringLength(jstring str) {
+        return functions->GetStringLength(this,str);
+    }
+    const jchar *GetStringChars(jstring str, jboolean *isCopy) {
+        return functions->GetStringChars(this,str,isCopy);
+    }
+    void ReleaseStringChars(jstring str, const jchar *chars) {
+        functions->ReleaseStringChars(this,str,chars);
+    }
+
+    jstring NewStringUTF(const char *utf) {
+        return functions->NewStringUTF(this,utf);
+    }
+    jsize GetStringUTFLength(jstring str) {
+        return functions->GetStringUTFLength(this,str);
+    }
+    const char* GetStringUTFChars(jstring str, jboolean *isCopy) {
+        return functions->GetStringUTFChars(this,str,isCopy);
+    }
+    void ReleaseStringUTFChars(jstring str, const char* chars) {
+        functions->ReleaseStringUTFChars(this,str,chars);
+    }
+
+    jsize GetArrayLength(jarray array) {
+        return functions->GetArrayLength(this,array);
+    }
+
+    jobjectArray NewObjectArray(jsize len, jclass clazz,
+				jobject init) {
+        return functions->NewObjectArray(this,len,clazz,init);
+    }
+    jobject GetObjectArrayElement(jobjectArray array, jsize index) {
+        return functions->GetObjectArrayElement(this,array,index);
+    }
+    void SetObjectArrayElement(jobjectArray array, jsize index,
+			       jobject val) {
+        functions->SetObjectArrayElement(this,array,index,val);
+    }
+
+    jbooleanArray NewBooleanArray(jsize len) {
+        return functions->NewBooleanArray(this,len);
+    }
+    jbyteArray NewByteArray(jsize len) {
+        return functions->NewByteArray(this,len);
+    }
+    jcharArray NewCharArray(jsize len) {
+        return functions->NewCharArray(this,len);
+    }
+    jshortArray NewShortArray(jsize len) {
+        return functions->NewShortArray(this,len);
+    }
+    jintArray NewIntArray(jsize len) {
+        return functions->NewIntArray(this,len);
+    }
+    jlongArray NewLongArray(jsize len) {
+        return functions->NewLongArray(this,len);
+    }
+    jfloatArray NewFloatArray(jsize len) {
+        return functions->NewFloatArray(this,len);
+    }
+    jdoubleArray NewDoubleArray(jsize len) {
+        return functions->NewDoubleArray(this,len);
+    }
+
+    jboolean * GetBooleanArrayElements(jbooleanArray array, jboolean *isCopy) {
+        return functions->GetBooleanArrayElements(this,array,isCopy);
+    }
+    jbyte * GetByteArrayElements(jbyteArray array, jboolean *isCopy) {
+        return functions->GetByteArrayElements(this,array,isCopy);
+    }
+    jchar * GetCharArrayElements(jcharArray array, jboolean *isCopy) {
+        return functions->GetCharArrayElements(this,array,isCopy);
+    }
+    jshort * GetShortArrayElements(jshortArray array, jboolean *isCopy) {
+        return functions->GetShortArrayElements(this,array,isCopy);
+    }
+    jint * GetIntArrayElements(jintArray array, jboolean *isCopy) {
+        return functions->GetIntArrayElements(this,array,isCopy);
+    }
+    jlong * GetLongArrayElements(jlongArray array, jboolean *isCopy) {
+        return functions->GetLongArrayElements(this,array,isCopy);
+    }
+    jfloat * GetFloatArrayElements(jfloatArray array, jboolean *isCopy) {
+        return functions->GetFloatArrayElements(this,array,isCopy);
+    }
+    jdouble * GetDoubleArrayElements(jdoubleArray array, jboolean *isCopy) {
+        return functions->GetDoubleArrayElements(this,array,isCopy);
+    }
+
+    void ReleaseBooleanArrayElements(jbooleanArray array,
+				     jboolean *elems,
+				     jint mode) {
+        functions->ReleaseBooleanArrayElements(this,array,elems,mode);
+    }
+    void ReleaseByteArrayElements(jbyteArray array,
+				  jbyte *elems,
+				  jint mode) {
+        functions->ReleaseByteArrayElements(this,array,elems,mode);
+    }
+    void ReleaseCharArrayElements(jcharArray array,
+				  jchar *elems,
+				  jint mode) {
+        functions->ReleaseCharArrayElements(this,array,elems,mode);
+    }
+    void ReleaseShortArrayElements(jshortArray array,
+				   jshort *elems,
+				   jint mode) {
+        functions->ReleaseShortArrayElements(this,array,elems,mode);
+    }
+    void ReleaseIntArrayElements(jintArray array,
+				 jint *elems,
+				 jint mode) {
+        functions->ReleaseIntArrayElements(this,array,elems,mode);
+    }
+    void ReleaseLongArrayElements(jlongArray array,
+				  jlong *elems,
+				  jint mode) {
+        functions->ReleaseLongArrayElements(this,array,elems,mode);
+    }
+    void ReleaseFloatArrayElements(jfloatArray array,
+				   jfloat *elems,
+				   jint mode) {
+        functions->ReleaseFloatArrayElements(this,array,elems,mode);
+    }
+    void ReleaseDoubleArrayElements(jdoubleArray array,
+				    jdouble *elems,
+				    jint mode) {
+        functions->ReleaseDoubleArrayElements(this,array,elems,mode);
+    }
+
+    void GetBooleanArrayRegion(jbooleanArray array,
+			       jsize start, jsize len, jboolean *buf) {
+        functions->GetBooleanArrayRegion(this,array,start,len,buf);
+    }
+    void GetByteArrayRegion(jbyteArray array,
+			    jsize start, jsize len, jbyte *buf) {
+        functions->GetByteArrayRegion(this,array,start,len,buf);
+    }
+    void GetCharArrayRegion(jcharArray array,
+			    jsize start, jsize len, jchar *buf) {
+        functions->GetCharArrayRegion(this,array,start,len,buf);
+    }
+    void GetShortArrayRegion(jshortArray array,
+			     jsize start, jsize len, jshort *buf) {
+        functions->GetShortArrayRegion(this,array,start,len,buf);
+    }
+    void GetIntArrayRegion(jintArray array,
+			   jsize start, jsize len, jint *buf) {
+        functions->GetIntArrayRegion(this,array,start,len,buf);
+    }
+    void GetLongArrayRegion(jlongArray array,
+			    jsize start, jsize len, jlong *buf) {
+        functions->GetLongArrayRegion(this,array,start,len,buf);
+    }
+    void GetFloatArrayRegion(jfloatArray array,
+			     jsize start, jsize len, jfloat *buf) {
+        functions->GetFloatArrayRegion(this,array,start,len,buf);
+    }
+    void GetDoubleArrayRegion(jdoubleArray array,
+			      jsize start, jsize len, jdouble *buf) {
+        functions->GetDoubleArrayRegion(this,array,start,len,buf);
+    }
+
+    void SetBooleanArrayRegion(jbooleanArray array, jsize start, jsize len,
+			       const jboolean *buf) {
+        functions->SetBooleanArrayRegion(this,array,start,len,buf);
+    }
+    void SetByteArrayRegion(jbyteArray array, jsize start, jsize len,
+			    const jbyte *buf) {
+        functions->SetByteArrayRegion(this,array,start,len,buf);
+    }
+    void SetCharArrayRegion(jcharArray array, jsize start, jsize len,
+			    const jchar *buf) {
+        functions->SetCharArrayRegion(this,array,start,len,buf);
+    }
+    void SetShortArrayRegion(jshortArray array, jsize start, jsize len,
+			     const jshort *buf) {
+        functions->SetShortArrayRegion(this,array,start,len,buf);
+    }
+    void SetIntArrayRegion(jintArray array, jsize start, jsize len,
+			   const jint *buf) {
+        functions->SetIntArrayRegion(this,array,start,len,buf);
+    }
+    void SetLongArrayRegion(jlongArray array, jsize start, jsize len,
+			    const jlong *buf) {
+        functions->SetLongArrayRegion(this,array,start,len,buf);
+    }
+    void SetFloatArrayRegion(jfloatArray array, jsize start, jsize len,
+			     const jfloat *buf) {
+        functions->SetFloatArrayRegion(this,array,start,len,buf);
+    }
+    void SetDoubleArrayRegion(jdoubleArray array, jsize start, jsize len,
+			      const jdouble *buf) {
+        functions->SetDoubleArrayRegion(this,array,start,len,buf);
+    }
+
+    jint RegisterNatives(jclass clazz, const JNINativeMethod *methods,
+			 jint nMethods) {
+        return functions->RegisterNatives(this,clazz,methods,nMethods);
+    }
+    jint UnregisterNatives(jclass clazz) {
+        return functions->UnregisterNatives(this,clazz);
+    }
+
+    jint MonitorEnter(jobject obj) {
+        return functions->MonitorEnter(this,obj);
+    }
+    jint MonitorExit(jobject obj) {
+        return functions->MonitorExit(this,obj);
+    }
+
+    jint GetJavaVM(JavaVM **vm) {
+        return functions->GetJavaVM(this,vm);
+    }
+
+    void GetStringRegion(jstring str, jsize start, jsize len, jchar *buf) {
+        functions->GetStringRegion(this,str,start,len,buf);
+    }
+    void GetStringUTFRegion(jstring str, jsize start, jsize len, char *buf) {
+        functions->GetStringUTFRegion(this,str,start,len,buf);
+    }
+
+    void * GetPrimitiveArrayCritical(jarray array, jboolean *isCopy) {
+        return functions->GetPrimitiveArrayCritical(this,array,isCopy);
+    }
+    void ReleasePrimitiveArrayCritical(jarray array, void *carray, jint mode) {
+        functions->ReleasePrimitiveArrayCritical(this,array,carray,mode);
+    }
+
+    const jchar * GetStringCritical(jstring string, jboolean *isCopy) {
+        return functions->GetStringCritical(this,string,isCopy);
+    }
+    void ReleaseStringCritical(jstring string, const jchar *cstring) {
+        functions->ReleaseStringCritical(this,string,cstring);
+    }
+
+    jweak NewWeakGlobalRef(jobject obj) {
+        return functions->NewWeakGlobalRef(this,obj);
+    }
+    void DeleteWeakGlobalRef(jweak ref) {
+        functions->DeleteWeakGlobalRef(this,ref);
+    }
+
+    jboolean ExceptionCheck() {
+	return functions->ExceptionCheck(this);
+    }
+
+    jobject NewDirectByteBuffer(void* address, jlong capacity) {
+        return functions->NewDirectByteBuffer(this, address, capacity);
+    }
+    void* GetDirectBufferAddress(jobject buf) {
+        return functions->GetDirectBufferAddress(this, buf);
+    }
+    jlong GetDirectBufferCapacity(jobject buf) {
+        return functions->GetDirectBufferCapacity(this, buf);
+    }
+    jobjectRefType GetObjectRefType(jobject obj) {
+        return functions->GetObjectRefType(this, obj);
+    }
+
+#endif /* __cplusplus */
+};
+
+typedef struct JavaVMOption {
+    char *optionString;
+    void *extraInfo;
+} JavaVMOption;
+
+typedef struct JavaVMInitArgs {
+    jint version;
+
+    jint nOptions;
+    JavaVMOption *options;
+    jboolean ignoreUnrecognized;
+} JavaVMInitArgs;
+
+typedef struct JavaVMAttachArgs {
+    jint version;
+
+    char *name;
+    jobject group;
+} JavaVMAttachArgs;
+
+/* These will be VM-specific. */
+
+#define JDK1_2
+#define JDK1_4
+
+/* End VM-specific. */
+
+struct JNIInvokeInterface_ {
+    void *reserved0;
+    void *reserved1;
+    void *reserved2;
+
+    jint (JNICALL *DestroyJavaVM)(JavaVM *vm);
+
+    jint (JNICALL *AttachCurrentThread)(JavaVM *vm, void **penv, void *args);
+
+    jint (JNICALL *DetachCurrentThread)(JavaVM *vm);
+
+    jint (JNICALL *GetEnv)(JavaVM *vm, void **penv, jint version);
+
+    jint (JNICALL *AttachCurrentThreadAsDaemon)(JavaVM *vm, void **penv, void *args);
+};
+
+struct JavaVM_ {
+    const struct JNIInvokeInterface_ *functions;
+#ifdef __cplusplus
+
+    jint DestroyJavaVM() {
+        return functions->DestroyJavaVM(this);
+    }
+    jint AttachCurrentThread(void **penv, void *args) {
+        return functions->AttachCurrentThread(this, penv, args);
+    }
+    jint DetachCurrentThread() {
+        return functions->DetachCurrentThread(this);
+    }
+
+    jint GetEnv(void **penv, jint version) {
+        return functions->GetEnv(this, penv, version);
+    }
+    jint AttachCurrentThreadAsDaemon(void **penv, void *args) {
+        return functions->AttachCurrentThreadAsDaemon(this, penv, args);
+    }
+#endif
+};
+
+#ifdef _JNI_IMPLEMENTATION_
+#define _JNI_IMPORT_OR_EXPORT_ JNIEXPORT
+#else
+#define _JNI_IMPORT_OR_EXPORT_ JNIIMPORT
+#endif
+_JNI_IMPORT_OR_EXPORT_ jint JNICALL
+JNI_GetDefaultJavaVMInitArgs(void *args);
+
+_JNI_IMPORT_OR_EXPORT_ jint JNICALL
+JNI_CreateJavaVM(JavaVM **pvm, void **penv, void *args);
+
+_JNI_IMPORT_OR_EXPORT_ jint JNICALL
+JNI_GetCreatedJavaVMs(JavaVM **, jsize, jsize *);
+
+/* Defined by native libraries. */
+JNIEXPORT jint JNICALL
+JNI_OnLoad(JavaVM *vm, void *reserved);
+
+JNIEXPORT void JNICALL
+JNI_OnUnload(JavaVM *vm, void *reserved);
+
+#define JNI_VERSION_1_1 0x00010001
+#define JNI_VERSION_1_2 0x00010002
+#define JNI_VERSION_1_4 0x00010004
+#define JNI_VERSION_1_6 0x00010006
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif /* __cplusplus */
+
+#endif /* !_JAVASOFT_JNI_H_ */
+
+
+
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/linux/jawt_md.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/linux/jawt_md.h
new file mode 100755
index 0000000..fa66d21
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/linux/jawt_md.h
@@ -0,0 +1,43 @@
+/*
+ * @(#)jawt_md.h	1.13 10/03/23
+ *
+ * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+#ifndef _JAVASOFT_JAWT_MD_H_
+#define _JAVASOFT_JAWT_MD_H_
+
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/Intrinsic.h>
+#include "jawt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * X11-specific declarations for AWT native interface.
+ * See notes in jawt.h for an example of use.
+ */
+typedef struct jawt_X11DrawingSurfaceInfo {
+    Drawable drawable;
+    Display* display;
+    VisualID visualID;
+    Colormap colormapID;
+    int depth;
+    /*
+     * Since 1.4
+     * Returns a pixel value from a set of RGB values.
+     * This is useful for paletted color (256 color) modes.
+     */
+    int (JNICALL *GetAWTColor)(JAWT_DrawingSurface* ds,
+        int r, int g, int b);
+} JAWT_X11DrawingSurfaceInfo;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_JAVASOFT_JAWT_MD_H_ */
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/linux/jni_md.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/linux/jni_md.h
new file mode 100755
index 0000000..8d4ccdf
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/linux/jni_md.h
@@ -0,0 +1,24 @@
+/*
+ * @(#)jni_md.h	1.20 10/03/23
+ *
+ * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+#ifndef _JAVASOFT_JNI_MD_H_
+#define _JAVASOFT_JNI_MD_H_
+
+#define JNIEXPORT 
+#define JNIIMPORT
+#define JNICALL
+
+typedef int jint;
+#ifdef _LP64 /* 64-bit Solaris */
+typedef long jlong;
+#else
+typedef long long jlong;
+#endif
+
+typedef signed char jbyte;
+
+#endif /* !_JAVASOFT_JNI_MD_H_ */
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/mac/jni_md.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/mac/jni_md.h
new file mode 100755
index 0000000..7a2116f
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/mac/jni_md.h
@@ -0,0 +1,23 @@
+/*
+ * @(#)jni_md.h	1.19 05/11/17
+ *
+ * Copyright 2006 Sun Microsystems, Inc. All rights reserved.
+ * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+#ifndef _JAVASOFT_JNI_MD_H_
+#define _JAVASOFT_JNI_MD_H_
+
+#define JNIEXPORT __attribute__((visibility("default")))
+#define JNIIMPORT
+#define JNICALL
+
+#if __LP64__
+typedef int jint;
+#else
+typedef long jint;
+#endif
+typedef long long jlong;
+typedef signed char jbyte;
+
+#endif /* !_JAVASOFT_JNI_MD_H_ */
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/win32/jawt_md.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/win32/jawt_md.h
new file mode 100755
index 0000000..82ba034
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/win32/jawt_md.h
@@ -0,0 +1,41 @@
+/*
+ * %W% %E%
+ *
+ * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+#ifndef _JAVASOFT_JAWT_MD_H_
+#define _JAVASOFT_JAWT_MD_H_
+
+#include <windows.h>
+#include "jawt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Win32-specific declarations for AWT native interface.
+ * See notes in jawt.h for an example of use.
+ */
+typedef struct jawt_Win32DrawingSurfaceInfo {
+    /* Native window, DDB, or DIB handle */
+    union {
+        HWND hwnd;
+        HBITMAP hbitmap;
+        void* pbits;
+    };
+    /*
+     * This HDC should always be used instead of the HDC returned from
+     * BeginPaint() or any calls to GetDC().
+     */
+    HDC hdc;
+    HPALETTE hpalette;
+} JAWT_Win32DrawingSurfaceInfo;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !_JAVASOFT_JAWT_MD_H_ */
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/win32/jni_md.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/win32/jni_md.h
new file mode 100755
index 0000000..9ac4718
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/jni-headers/win32/jni_md.h
@@ -0,0 +1,19 @@
+/*
+ * %W% %E%
+ *
+ * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+
+#ifndef _JAVASOFT_JNI_MD_H_
+#define _JAVASOFT_JNI_MD_H_
+
+#define JNIEXPORT __declspec(dllexport)
+#define JNIIMPORT __declspec(dllimport)
+#define JNICALL __stdcall
+
+typedef long jint;
+typedef __int64 jlong;
+typedef signed char jbyte;
+
+#endif /* !_JAVASOFT_JNI_MD_H_ */
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/memcpy_wrap.c b/extensions/gdx-controllers/gdx-controllers-desktop/jni/memcpy_wrap.c
new file mode 100755
index 0000000..70a3021
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/memcpy_wrap.c
@@ -0,0 +1,18 @@
+#ifndef __ANDROID__
+#ifdef __linux__
+#ifdef __x86_64__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+__asm__(".symver memcpy,memcpy@GLIBC_2.2.5");
+
+void *__wrap_memcpy(void * destination, const void * source, size_t num)
+{
+        return memcpy(destination, source, num);
+}
+
+#endif
+#endif
+#endif
\ No newline at end of file
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/LinuxCB/ActionMapOgreDemo.cbp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/LinuxCB/ActionMapOgreDemo.cbp
new file mode 100644
index 0000000..4c15f25
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/LinuxCB/ActionMapOgreDemo.cbp
@@ -0,0 +1,69 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
+<CodeBlocks_project_file>
+	<FileVersion major="1" minor="4" />
+	<Project>
+		<Option title="Demo_OgreActionMap" />
+		<Option compiler="gcc" />
+		<Build>
+			<Target title="Release">
+				<Option output="../demos/ogre/common/ActionMapping" />
+				<Option working_dir="../demos/ogre/common" />
+				<Option object_output="../demos/ogre/obj/release" />
+				<Option type="1" />
+				<Option compiler="gcc" />
+				<Option includeInTargetAll="1" />
+				<Option projectResourceIncludeDirsRelation="2" />
+				<Compiler>
+					<Add option="-O3" />
+					<Add directory="../demos/ogre" />
+					<Add directory="../includes" />
+					<Add directory="/usr/local/include/CEGUI" />
+					<Add directory="/usr/local/include/OGRE" />
+					<Add directory="/usr/local/include/CEGUI/elements" />
+				</Compiler>
+				<Linker>
+					<Add library="/usr/local/lib/libCEGUIBase.so" />
+					<Add library="/usr/local/lib/libCEGUIOgreRenderer.so" />
+					<Add library="/usr/local/lib/libOgreMain.so" />
+					<Add library="~/libs/OIS.so" />
+				</Linker>
+			</Target>
+		</Build>
+		<Unit filename="../demos/ogre/ActionConfig.cpp">
+			<Option compilerVar="CPP" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../demos/ogre/ActionConfig.h">
+			<Option compilerVar="CPP" />
+			<Option compile="0" />
+			<Option link="0" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../demos/ogre/ActionMap.cpp">
+			<Option compilerVar="CPP" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../demos/ogre/ActionMap.h">
+			<Option compilerVar="CPP" />
+			<Option compile="0" />
+			<Option link="0" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../demos/ogre/ExampleApplication.h">
+			<Option compilerVar="CPP" />
+			<Option compile="0" />
+			<Option link="0" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../demos/ogre/ExampleFrameListener.h">
+			<Option compilerVar="CPP" />
+			<Option compile="0" />
+			<Option link="0" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../demos/ogre/gui.cpp">
+			<Option compilerVar="CPP" />
+			<Option target="Release" />
+		</Unit>
+	</Project>
+</CodeBlocks_project_file>
\ No newline at end of file
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/LinuxCB/ConsoleDemo.cbp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/LinuxCB/ConsoleDemo.cbp
new file mode 100644
index 0000000..f919096
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/LinuxCB/ConsoleDemo.cbp
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
+<CodeBlocks_project_file>
+	<FileVersion major="1" minor="4" />
+	<Project>
+		<Option title="Demo_Console" />
+		<Option pch_mode="0" />
+		<Option compiler="gcc" />
+		<Build>
+			<Target title="Release">
+				<Option output="../demos/Console" />
+				<Option working_dir="../demos" />
+				<Option object_output="../demos/obj/release" />
+				<Option type="1" />
+				<Option compiler="gcc" />
+				<Option includeInTargetAll="1" />
+				<Option projectResourceIncludeDirsRelation="2" />
+				<Compiler>
+					<Add directory="../includes" />
+				</Compiler>
+			</Target>
+		</Build>
+		<Linker>
+			<Add library="~/libs/OIS.so" />
+		</Linker>
+		<Unit filename="../demos/OISConsole.cpp">
+			<Option compilerVar="CPP" />
+			<Option target="Release" />
+		</Unit>
+	</Project>
+</CodeBlocks_project_file>
\ No newline at end of file
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/LinuxCB/LinuxOIS.workspace b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/LinuxCB/LinuxOIS.workspace
new file mode 100644
index 0000000..67adc82
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/LinuxCB/LinuxOIS.workspace
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
+<CodeBlocks_workspace_file>
+	<Workspace title="OIS Project">
+		<Project filename="OIS.cbp" />
+		<Project filename="ConsoleDemo.cbp">
+			<Depends filename="OIS.cbp" />
+		</Project>
+		<Project filename="ActionMapOgreDemo.cbp" active="1">
+			<Depends filename="OIS.cbp" />
+		</Project>
+	</Workspace>
+</CodeBlocks_workspace_file>
\ No newline at end of file
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/LinuxCB/OIS.cbp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/LinuxCB/OIS.cbp
new file mode 100644
index 0000000..eeec8c6
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/LinuxCB/OIS.cbp
@@ -0,0 +1,212 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
+<CodeBlocks_project_file>
+	<FileVersion major="1" minor="4" />
+	<Project>
+		<Option title="OIS" />
+		<Option pch_mode="0" />
+		<Option default_target="-1" />
+		<Option compiler="gcc" />
+		<Build>
+			<Target title="Debug">
+				<Option output="~/libs/OIS_d.so" />
+				<Option working_dir="~/libs" />
+				<Option object_output="../lib/obj/debug" />
+				<Option type="3" />
+				<Option compiler="gcc" />
+				<Option includeInTargetAll="1" />
+				<Option createDefFile="1" />
+				<Option projectResourceIncludeDirsRelation="2" />
+				<Compiler>
+					<Add option="-Wfatal-errors" />
+					<Add option="-W" />
+					<Add option="-Wall" />
+					<Add option="-pg" />
+					<Add option="-g" />
+					<Add option="-D_DEBUG" />
+					<Add option="-DOIS_JOYEVENTS" />
+					<Add directory="../includes" />
+				</Compiler>
+				<Linker>
+					<Add option="-pg" />
+					<Add library="libXaw" />
+					<Add library="libX11" />
+					<Add directory="/usr/lib" />
+					<Add directory="/usr/lib/X11R6" />
+				</Linker>
+			</Target>
+			<Target title="Release">
+				<Option output="~/libs/OIS.so" />
+				<Option working_dir="~/libs" />
+				<Option object_output="../lib/obj/release" />
+				<Option type="3" />
+				<Option compiler="gcc" />
+				<Option includeInTargetAll="1" />
+				<Option createDefFile="1" />
+				<Option projectResourceIncludeDirsRelation="2" />
+				<Compiler>
+					<Add option="-O3" />
+					<Add option="-DOIS_JOYEVENTS" />
+					<Add directory="../includes" />
+				</Compiler>
+				<Linker>
+					<Add option="-s" />
+					<Add library="libXaw" />
+					<Add library="libX11" />
+					<Add directory="/usr/lib" />
+					<Add directory="/usr/lib/X11R6" />
+				</Linker>
+			</Target>
+		</Build>
+		<Unit filename="../includes/OIS.h">
+			<Option compilerVar="CPP" />
+			<Option compile="0" />
+			<Option link="0" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../includes/OISConfig.h">
+			<Option compilerVar="CPP" />
+			<Option compile="0" />
+			<Option link="0" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../includes/OISEffect.h">
+			<Option compilerVar="CPP" />
+			<Option compile="0" />
+			<Option link="0" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../includes/OISEvents.h">
+			<Option compilerVar="CPP" />
+			<Option compile="0" />
+			<Option link="0" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../includes/OISException.h">
+			<Option compilerVar="CPP" />
+			<Option compile="0" />
+			<Option link="0" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../includes/OISForceFeedback.h">
+			<Option compilerVar="CPP" />
+			<Option compile="0" />
+			<Option link="0" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../includes/OISInputManager.h">
+			<Option compilerVar="" />
+			<Option compile="0" />
+			<Option link="0" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../includes/OISInterface.h">
+			<Option compilerVar="CPP" />
+			<Option compile="0" />
+			<Option link="0" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../includes/OISJoyStick.h">
+			<Option compilerVar="CPP" />
+			<Option compile="0" />
+			<Option link="0" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../includes/OISKeyboard.h">
+			<Option compilerVar="" />
+			<Option compile="0" />
+			<Option link="0" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../includes/OISMouse.h">
+			<Option compilerVar="" />
+			<Option compile="0" />
+			<Option link="0" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../includes/OISObject.h">
+			<Option compilerVar="" />
+			<Option compile="0" />
+			<Option link="0" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../includes/OISPrereqs.h">
+			<Option compilerVar="" />
+			<Option compile="0" />
+			<Option link="0" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../src/OISEffect.cpp">
+			<Option compilerVar="CPP" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../src/OISForceFeedback.cpp">
+			<Option compilerVar="CPP" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../src/OISInputManager.cpp">
+			<Option compilerVar="CPP" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../src/OISJoyStick.cpp">
+			<Option compilerVar="CPP" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../src/OISKeyboard.cpp">
+			<Option compilerVar="CPP" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../src/OISObject.cpp">
+			<Option compilerVar="CPP" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../src/linux/EventHelpers.cpp">
+			<Option compilerVar="CPP" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../src/linux/LinuxForceFeedback.cpp">
+			<Option compilerVar="CPP" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../src/linux/LinuxInputManager.cpp">
+			<Option compilerVar="CPP" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../src/linux/LinuxJoyStickEvents.cpp">
+			<Option compilerVar="CPP" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../src/linux/LinuxKeyboard.cpp">
+			<Option compilerVar="CPP" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+		<Unit filename="../src/linux/LinuxMouse.cpp">
+			<Option compilerVar="CPP" />
+			<Option target="Debug" />
+			<Option target="Release" />
+		</Unit>
+	</Project>
+</CodeBlocks_project_file>
\ No newline at end of file
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Mac/SDL/blank.keepme b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Mac/SDL/blank.keepme
new file mode 100644
index 0000000..e69de29
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Mac/XCode-2.2/ConsoleTest-Info.plist b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Mac/XCode-2.2/ConsoleTest-Info.plist
new file mode 100644
index 0000000..17e6582
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Mac/XCode-2.2/ConsoleTest-Info.plist
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>CFBundleDevelopmentRegion</key>
+	<string>English</string>
+	<key>CFBundleExecutable</key>
+	<string>${EXECUTABLE_NAME}</string>
+	<key>CFBundleIdentifier</key>
+	<string>com.yourcompany.ConsoleTest</string>
+	<key>CFBundleInfoDictionaryVersion</key>
+	<string>6.0</string>
+	<key>CFBundlePackageType</key>
+	<string>APPL</string>
+	<key>CFBundleSignature</key>
+	<string>????</string>
+	<key>CFBundleVersion</key>
+	<string>1.0</string>
+</dict>
+</plist>
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Mac/XCode-2.2/OIS-Info.plist b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Mac/XCode-2.2/OIS-Info.plist
new file mode 100644
index 0000000..2329109
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Mac/XCode-2.2/OIS-Info.plist
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>CFBundleDevelopmentRegion</key>
+	<string>English</string>
+	<key>CFBundleExecutable</key>
+	<string>${EXECUTABLE_NAME}</string>
+	<key>CFBundleIdentifier</key>
+	<string>com.yourcompany.OIS</string>
+	<key>CFBundleInfoDictionaryVersion</key>
+	<string>6.0</string>
+	<key>CFBundlePackageType</key>
+	<string>FMWK</string>
+	<key>CFBundleSignature</key>
+	<string>????</string>
+	<key>CFBundleVersion</key>
+	<string>1.0</string>
+</dict>
+</plist>
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Mac/XCode-2.2/OIS.xcodeproj/project.pbxproj b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Mac/XCode-2.2/OIS.xcodeproj/project.pbxproj
new file mode 100644
index 0000000..fab7f43
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Mac/XCode-2.2/OIS.xcodeproj/project.pbxproj
@@ -0,0 +1,1089 @@
+// !$*UTF8*$!
+{
+	archiveVersion = 1;
+	classes = {
+	};
+	objectVersion = 42;
+	objects = {
+
+/* Begin PBXAggregateTarget section */
+		0043D98F0C356851007ACDF6 /* Build All */ = {
+			isa = PBXAggregateTarget;
+			buildConfigurationList = 0043D99A0C356867007ACDF6 /* Build configuration list for PBXAggregateTarget "Build All" */;
+			buildPhases = (
+			);
+			dependencies = (
+				0043D9950C35685A007ACDF6 /* PBXTargetDependency */,
+				0043D9930C35685A007ACDF6 /* PBXTargetDependency */,
+				0043D9910C35685A007ACDF6 /* PBXTargetDependency */,
+				0082F1CF0C82634200E926BE /* PBXTargetDependency */,
+				4AEB091E0D73DB7D007CD406 /* PBXTargetDependency */,
+			);
+			name = "Build All";
+			productName = "Build All";
+		};
+/* End PBXAggregateTarget section */
+
+/* Begin PBXBuildFile section */
+		0043D87D0C35664A007ACDF6 /* OIS.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8700C35664A007ACDF6 /* OIS.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		0043D87E0C35664A007ACDF6 /* OISConfig.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8710C35664A007ACDF6 /* OISConfig.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		0043D87F0C35664A007ACDF6 /* OISEffect.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8720C35664A007ACDF6 /* OISEffect.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		0043D8800C35664A007ACDF6 /* OISEvents.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8730C35664A007ACDF6 /* OISEvents.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		0043D8810C35664A007ACDF6 /* OISException.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8740C35664A007ACDF6 /* OISException.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		0043D8820C35664A007ACDF6 /* OISForceFeedback.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8750C35664A007ACDF6 /* OISForceFeedback.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		0043D8830C35664A007ACDF6 /* OISInputManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8760C35664A007ACDF6 /* OISInputManager.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		0043D8840C35664A007ACDF6 /* OISInterface.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8770C35664A007ACDF6 /* OISInterface.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		0043D8850C35664A007ACDF6 /* OISJoyStick.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8780C35664A007ACDF6 /* OISJoyStick.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		0043D8860C35664A007ACDF6 /* OISKeyboard.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8790C35664A007ACDF6 /* OISKeyboard.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		0043D8870C35664A007ACDF6 /* OISMouse.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D87A0C35664A007ACDF6 /* OISMouse.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		0043D8880C35664A007ACDF6 /* OISObject.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D87B0C35664A007ACDF6 /* OISObject.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		0043D8890C35664A007ACDF6 /* OISPrereqs.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D87C0C35664A007ACDF6 /* OISPrereqs.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		0043D8960C3566C1007ACDF6 /* OISEffect.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D8900C3566C1007ACDF6 /* OISEffect.cpp */; };
+		0043D8970C3566C1007ACDF6 /* OISForceFeedback.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D8910C3566C1007ACDF6 /* OISForceFeedback.cpp */; };
+		0043D8980C3566C1007ACDF6 /* OISInputManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D8920C3566C1007ACDF6 /* OISInputManager.cpp */; };
+		0043D8990C3566C1007ACDF6 /* OISJoyStick.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D8930C3566C1007ACDF6 /* OISJoyStick.cpp */; };
+		0043D89A0C3566C1007ACDF6 /* OISKeyboard.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D8940C3566C1007ACDF6 /* OISKeyboard.cpp */; };
+		0043D89B0C3566C1007ACDF6 /* OISObject.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D8950C3566C1007ACDF6 /* OISObject.cpp */; };
+		0043D8A00C3566C9007ACDF6 /* MacHelpers.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D89C0C3566C9007ACDF6 /* MacHelpers.cpp */; };
+		0043D8A10C3566C9007ACDF6 /* MacInputManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D89D0C3566C9007ACDF6 /* MacInputManager.cpp */; };
+		0043D8A20C3566C9007ACDF6 /* MacKeyboard.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D89E0C3566C9007ACDF6 /* MacKeyboard.cpp */; };
+		0043D8A30C3566C9007ACDF6 /* MacMouse.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D89F0C3566C9007ACDF6 /* MacMouse.cpp */; };
+		0043D8C70C35680D007ACDF6 /* OIS.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8700C35664A007ACDF6 /* OIS.h */; };
+		0043D8C80C35680D007ACDF6 /* OISConfig.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8710C35664A007ACDF6 /* OISConfig.h */; };
+		0043D8C90C35680D007ACDF6 /* OISEffect.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8720C35664A007ACDF6 /* OISEffect.h */; };
+		0043D8CA0C35680D007ACDF6 /* OISEvents.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8730C35664A007ACDF6 /* OISEvents.h */; };
+		0043D8CB0C35680D007ACDF6 /* OISException.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8740C35664A007ACDF6 /* OISException.h */; };
+		0043D8CC0C35680D007ACDF6 /* OISForceFeedback.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8750C35664A007ACDF6 /* OISForceFeedback.h */; };
+		0043D8CD0C35680D007ACDF6 /* OISInputManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8760C35664A007ACDF6 /* OISInputManager.h */; };
+		0043D8CE0C35680D007ACDF6 /* OISInterface.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8770C35664A007ACDF6 /* OISInterface.h */; };
+		0043D8CF0C35680D007ACDF6 /* OISJoyStick.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8780C35664A007ACDF6 /* OISJoyStick.h */; };
+		0043D8D00C35680D007ACDF6 /* OISKeyboard.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8790C35664A007ACDF6 /* OISKeyboard.h */; };
+		0043D8D10C35680D007ACDF6 /* OISMouse.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D87A0C35664A007ACDF6 /* OISMouse.h */; };
+		0043D8D20C35680D007ACDF6 /* OISObject.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D87B0C35664A007ACDF6 /* OISObject.h */; };
+		0043D8D30C35680D007ACDF6 /* OISPrereqs.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D87C0C35664A007ACDF6 /* OISPrereqs.h */; };
+		0043D8D40C35680D007ACDF6 /* OIS.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8700C35664A007ACDF6 /* OIS.h */; };
+		0043D8D50C35680D007ACDF6 /* OISConfig.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8710C35664A007ACDF6 /* OISConfig.h */; };
+		0043D8D60C35680D007ACDF6 /* OISEffect.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8720C35664A007ACDF6 /* OISEffect.h */; };
+		0043D8D70C35680D007ACDF6 /* OISEvents.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8730C35664A007ACDF6 /* OISEvents.h */; };
+		0043D8D80C35680D007ACDF6 /* OISException.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8740C35664A007ACDF6 /* OISException.h */; };
+		0043D8D90C35680D007ACDF6 /* OISForceFeedback.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8750C35664A007ACDF6 /* OISForceFeedback.h */; };
+		0043D8DA0C35680D007ACDF6 /* OISInputManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8760C35664A007ACDF6 /* OISInputManager.h */; };
+		0043D8DB0C35680D007ACDF6 /* OISInterface.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8770C35664A007ACDF6 /* OISInterface.h */; };
+		0043D8DC0C35680D007ACDF6 /* OISJoyStick.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8780C35664A007ACDF6 /* OISJoyStick.h */; };
+		0043D8DD0C35680D007ACDF6 /* OISKeyboard.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D8790C35664A007ACDF6 /* OISKeyboard.h */; };
+		0043D8DE0C35680D007ACDF6 /* OISMouse.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D87A0C35664A007ACDF6 /* OISMouse.h */; };
+		0043D8DF0C35680D007ACDF6 /* OISObject.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D87B0C35664A007ACDF6 /* OISObject.h */; };
+		0043D8E00C35680D007ACDF6 /* OISPrereqs.h in Headers */ = {isa = PBXBuildFile; fileRef = 0043D87C0C35664A007ACDF6 /* OISPrereqs.h */; };
+		0043D8E10C356819007ACDF6 /* MacHelpers.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D89C0C3566C9007ACDF6 /* MacHelpers.cpp */; };
+		0043D8E20C356819007ACDF6 /* MacInputManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D89D0C3566C9007ACDF6 /* MacInputManager.cpp */; };
+		0043D8E30C356819007ACDF6 /* MacKeyboard.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D89E0C3566C9007ACDF6 /* MacKeyboard.cpp */; };
+		0043D8E40C356819007ACDF6 /* MacMouse.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D89F0C3566C9007ACDF6 /* MacMouse.cpp */; };
+		0043D8E50C356819007ACDF6 /* OISEffect.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D8900C3566C1007ACDF6 /* OISEffect.cpp */; };
+		0043D8E60C356819007ACDF6 /* OISForceFeedback.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D8910C3566C1007ACDF6 /* OISForceFeedback.cpp */; };
+		0043D8E70C356819007ACDF6 /* OISInputManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D8920C3566C1007ACDF6 /* OISInputManager.cpp */; };
+		0043D8E80C356819007ACDF6 /* OISJoyStick.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D8930C3566C1007ACDF6 /* OISJoyStick.cpp */; };
+		0043D8E90C356819007ACDF6 /* OISKeyboard.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D8940C3566C1007ACDF6 /* OISKeyboard.cpp */; };
+		0043D8EA0C356819007ACDF6 /* OISObject.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D8950C3566C1007ACDF6 /* OISObject.cpp */; };
+		0043D8EB0C35681A007ACDF6 /* MacHelpers.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D89C0C3566C9007ACDF6 /* MacHelpers.cpp */; };
+		0043D8EC0C35681A007ACDF6 /* MacInputManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D89D0C3566C9007ACDF6 /* MacInputManager.cpp */; };
+		0043D8ED0C35681A007ACDF6 /* MacKeyboard.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D89E0C3566C9007ACDF6 /* MacKeyboard.cpp */; };
+		0043D8EE0C35681A007ACDF6 /* MacMouse.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D89F0C3566C9007ACDF6 /* MacMouse.cpp */; };
+		0043D8EF0C35681A007ACDF6 /* OISEffect.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D8900C3566C1007ACDF6 /* OISEffect.cpp */; };
+		0043D8F00C35681A007ACDF6 /* OISForceFeedback.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D8910C3566C1007ACDF6 /* OISForceFeedback.cpp */; };
+		0043D8F10C35681A007ACDF6 /* OISInputManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D8920C3566C1007ACDF6 /* OISInputManager.cpp */; };
+		0043D8F20C35681A007ACDF6 /* OISJoyStick.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D8930C3566C1007ACDF6 /* OISJoyStick.cpp */; };
+		0043D8F30C35681A007ACDF6 /* OISKeyboard.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D8940C3566C1007ACDF6 /* OISKeyboard.cpp */; };
+		0043D8F40C35681A007ACDF6 /* OISObject.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0043D8950C3566C1007ACDF6 /* OISObject.cpp */; };
+		0043D8F50C356828007ACDF6 /* OIS-Info.plist in Resources */ = {isa = PBXBuildFile; fileRef = 0043D85F0C356509007ACDF6 /* OIS-Info.plist */; };
+		0043D8F70C356840007ACDF6 /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 0043D8F60C356840007ACDF6 /* Carbon.framework */; };
+		0043D8F80C356840007ACDF6 /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 0043D8F60C356840007ACDF6 /* Carbon.framework */; };
+		0043D8F90C356840007ACDF6 /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 0043D8F60C356840007ACDF6 /* Carbon.framework */; };
+		0082F2890C827BF500E926BE /* OISConsole.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0082F2880C827BF500E926BE /* OISConsole.cpp */; };
+		249631C71066334D00EFD0E1 /* MacJoyStick.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 249631C31066333900EFD0E1 /* MacJoyStick.cpp */; };
+		249631C81066335600EFD0E1 /* MacJoyStick.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 249631C31066333900EFD0E1 /* MacJoyStick.cpp */; };
+		249631C91066335D00EFD0E1 /* MacJoyStick.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 249631C31066333900EFD0E1 /* MacJoyStick.cpp */; };
+		4A04E1A80CEF6B6B00E2B94E /* OISFactoryCreator.h in Headers */ = {isa = PBXBuildFile; fileRef = 4A04E1A70CEF6B6B00E2B94E /* OISFactoryCreator.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		4A04E1A90CEF6B6B00E2B94E /* OISFactoryCreator.h in Headers */ = {isa = PBXBuildFile; fileRef = 4A04E1A70CEF6B6B00E2B94E /* OISFactoryCreator.h */; };
+		4A04E1AA0CEF6B6B00E2B94E /* OISFactoryCreator.h in Headers */ = {isa = PBXBuildFile; fileRef = 4A04E1A70CEF6B6B00E2B94E /* OISFactoryCreator.h */; };
+		4A852C42112256D400A0BC84 /* OISMultiTouch.h in Headers */ = {isa = PBXBuildFile; fileRef = 4A852C41112256D400A0BC84 /* OISMultiTouch.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		4A852C43112256D400A0BC84 /* OISMultiTouch.h in Headers */ = {isa = PBXBuildFile; fileRef = 4A852C41112256D400A0BC84 /* OISMultiTouch.h */; };
+		4A852C44112256D400A0BC84 /* OISMultiTouch.h in Headers */ = {isa = PBXBuildFile; fileRef = 4A852C41112256D400A0BC84 /* OISMultiTouch.h */; };
+		4ACD7A530CEF903600D72CD9 /* OISException.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4ACD7A520CEF903600D72CD9 /* OISException.cpp */; };
+		4ACD7A540CEF903600D72CD9 /* OISException.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4ACD7A520CEF903600D72CD9 /* OISException.cpp */; };
+		4ACD7A550CEF903600D72CD9 /* OISException.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4ACD7A520CEF903600D72CD9 /* OISException.cpp */; };
+		4ADFD0100CDD948B006031E4 /* IOKit.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4AC4C3930CDD840500603F93 /* IOKit.framework */; };
+		4ADFD0110CDD948C006031E4 /* IOKit.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4AC4C3930CDD840500603F93 /* IOKit.framework */; };
+		4ADFD0130CDD94B2006031E4 /* IOKit.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4AC4C3930CDD840500603F93 /* IOKit.framework */; };
+		4ADFD2660CDE7322006031E4 /* MacHIDManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 4ADFD2650CDE7322006031E4 /* MacHIDManager.h */; };
+		4ADFD2670CDE7322006031E4 /* MacHIDManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 4ADFD2650CDE7322006031E4 /* MacHIDManager.h */; };
+		4ADFD2680CDE7322006031E4 /* MacHIDManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 4ADFD2650CDE7322006031E4 /* MacHIDManager.h */; };
+		4ADFD2A90CDE7BAC006031E4 /* MacHIDManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4ADFD2A80CDE7BAC006031E4 /* MacHIDManager.cpp */; };
+		4ADFD2AA0CDE7BAC006031E4 /* MacHIDManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4ADFD2A80CDE7BAC006031E4 /* MacHIDManager.cpp */; };
+		4ADFD2AB0CDE7BAC006031E4 /* MacHIDManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4ADFD2A80CDE7BAC006031E4 /* MacHIDManager.cpp */; };
+		4AEB08E30D73D9D1007CD406 /* OIS.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 0043D85D0C356509007ACDF6 /* OIS.framework */; };
+		4AEB08FC0D73DA81007CD406 /* OISConsole.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 0082F2880C827BF500E926BE /* OISConsole.cpp */; };
+		4AEB090C0D73DABC007CD406 /* OIS.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 0043D85D0C356509007ACDF6 /* OIS.framework */; };
+		4AEB09240D73DBC8007CD406 /* OIS.framework in CopyFiles */ = {isa = PBXBuildFile; fileRef = 0043D85D0C356509007ACDF6 /* OIS.framework */; };
+/* End PBXBuildFile section */
+
+/* Begin PBXContainerItemProxy section */
+		0043D9900C35685A007ACDF6 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 0043D84E0C3564F8007ACDF6 /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 0043D8BF0C3567B2007ACDF6;
+			remoteInfo = OISstatic;
+		};
+		0043D9920C35685A007ACDF6 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 0043D84E0C3564F8007ACDF6 /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 0043D8A70C3566F6007ACDF6;
+			remoteInfo = OISdylib;
+		};
+		0043D9940C35685A007ACDF6 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 0043D84E0C3564F8007ACDF6 /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 0043D85C0C356509007ACDF6;
+			remoteInfo = OIS;
+		};
+		0082F1CE0C82634200E926BE /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 0043D84E0C3564F8007ACDF6 /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 0082F04C0C824FE100E926BE;
+			remoteInfo = ConsoleDemo;
+		};
+		4AEB091D0D73DB7D007CD406 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 0043D84E0C3564F8007ACDF6 /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 4AEB08F50D73DA6D007CD406;
+			remoteInfo = ConsoleTest;
+		};
+/* End PBXContainerItemProxy section */
+
+/* Begin PBXCopyFilesBuildPhase section */
+		4AEB09210D73DBB8007CD406 /* CopyFiles */ = {
+			isa = PBXCopyFilesBuildPhase;
+			buildActionMask = 2147483647;
+			dstPath = "";
+			dstSubfolderSpec = 10;
+			files = (
+				4AEB09240D73DBC8007CD406 /* OIS.framework in CopyFiles */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXCopyFilesBuildPhase section */
+
+/* Begin PBXFileReference section */
+		0043D85D0C356509007ACDF6 /* OIS.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = OIS.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+		0043D85F0C356509007ACDF6 /* OIS-Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = "OIS-Info.plist"; sourceTree = "<group>"; };
+		0043D8700C35664A007ACDF6 /* OIS.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = OIS.h; path = ../../includes/OIS.h; sourceTree = SOURCE_ROOT; };
+		0043D8710C35664A007ACDF6 /* OISConfig.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = OISConfig.h; path = ../../includes/OISConfig.h; sourceTree = SOURCE_ROOT; };
+		0043D8720C35664A007ACDF6 /* OISEffect.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = OISEffect.h; path = ../../includes/OISEffect.h; sourceTree = SOURCE_ROOT; };
+		0043D8730C35664A007ACDF6 /* OISEvents.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = OISEvents.h; path = ../../includes/OISEvents.h; sourceTree = SOURCE_ROOT; };
+		0043D8740C35664A007ACDF6 /* OISException.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = OISException.h; path = ../../includes/OISException.h; sourceTree = SOURCE_ROOT; };
+		0043D8750C35664A007ACDF6 /* OISForceFeedback.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = OISForceFeedback.h; path = ../../includes/OISForceFeedback.h; sourceTree = SOURCE_ROOT; };
+		0043D8760C35664A007ACDF6 /* OISInputManager.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = OISInputManager.h; path = ../../includes/OISInputManager.h; sourceTree = SOURCE_ROOT; };
+		0043D8770C35664A007ACDF6 /* OISInterface.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = OISInterface.h; path = ../../includes/OISInterface.h; sourceTree = SOURCE_ROOT; };
+		0043D8780C35664A007ACDF6 /* OISJoyStick.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = OISJoyStick.h; path = ../../includes/OISJoyStick.h; sourceTree = SOURCE_ROOT; };
+		0043D8790C35664A007ACDF6 /* OISKeyboard.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = OISKeyboard.h; path = ../../includes/OISKeyboard.h; sourceTree = SOURCE_ROOT; };
+		0043D87A0C35664A007ACDF6 /* OISMouse.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = OISMouse.h; path = ../../includes/OISMouse.h; sourceTree = SOURCE_ROOT; };
+		0043D87B0C35664A007ACDF6 /* OISObject.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = OISObject.h; path = ../../includes/OISObject.h; sourceTree = SOURCE_ROOT; };
+		0043D87C0C35664A007ACDF6 /* OISPrereqs.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = OISPrereqs.h; path = ../../includes/OISPrereqs.h; sourceTree = SOURCE_ROOT; };
+		0043D88A0C35665B007ACDF6 /* MacPrereqs.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = MacPrereqs.h; path = ../../includes/mac/MacPrereqs.h; sourceTree = SOURCE_ROOT; };
+		0043D88B0C35665B007ACDF6 /* MacInputManager.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = MacInputManager.h; path = ../../includes/mac/MacInputManager.h; sourceTree = SOURCE_ROOT; };
+		0043D88C0C35665B007ACDF6 /* MacHelpers.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = MacHelpers.h; path = ../../includes/mac/MacHelpers.h; sourceTree = SOURCE_ROOT; };
+		0043D88D0C35665B007ACDF6 /* MacMouse.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = MacMouse.h; path = ../../includes/mac/MacMouse.h; sourceTree = SOURCE_ROOT; };
+		0043D88E0C35665B007ACDF6 /* MacKeyboard.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = MacKeyboard.h; path = ../../includes/mac/MacKeyboard.h; sourceTree = SOURCE_ROOT; };
+		0043D8900C3566C1007ACDF6 /* OISEffect.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = OISEffect.cpp; path = ../../src/OISEffect.cpp; sourceTree = SOURCE_ROOT; };
+		0043D8910C3566C1007ACDF6 /* OISForceFeedback.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = OISForceFeedback.cpp; path = ../../src/OISForceFeedback.cpp; sourceTree = SOURCE_ROOT; };
+		0043D8920C3566C1007ACDF6 /* OISInputManager.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = OISInputManager.cpp; path = ../../src/OISInputManager.cpp; sourceTree = SOURCE_ROOT; };
+		0043D8930C3566C1007ACDF6 /* OISJoyStick.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = OISJoyStick.cpp; path = ../../src/OISJoyStick.cpp; sourceTree = SOURCE_ROOT; };
+		0043D8940C3566C1007ACDF6 /* OISKeyboard.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = OISKeyboard.cpp; path = ../../src/OISKeyboard.cpp; sourceTree = SOURCE_ROOT; };
+		0043D8950C3566C1007ACDF6 /* OISObject.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = OISObject.cpp; path = ../../src/OISObject.cpp; sourceTree = SOURCE_ROOT; };
+		0043D89C0C3566C9007ACDF6 /* MacHelpers.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = MacHelpers.cpp; path = ../../src/mac/MacHelpers.cpp; sourceTree = SOURCE_ROOT; };
+		0043D89D0C3566C9007ACDF6 /* MacInputManager.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = MacInputManager.cpp; path = ../../src/mac/MacInputManager.cpp; sourceTree = SOURCE_ROOT; };
+		0043D89E0C3566C9007ACDF6 /* MacKeyboard.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = MacKeyboard.cpp; path = ../../src/mac/MacKeyboard.cpp; sourceTree = SOURCE_ROOT; };
+		0043D89F0C3566C9007ACDF6 /* MacMouse.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = MacMouse.cpp; path = ../../src/mac/MacMouse.cpp; sourceTree = SOURCE_ROOT; };
+		0043D8A80C3566F6007ACDF6 /* OIS.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = OIS.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
+		0043D8C00C3567B2007ACDF6 /* libOIS.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libOIS.a; sourceTree = BUILT_PRODUCTS_DIR; };
+		0043D8F60C356840007ACDF6 /* Carbon.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; name = Carbon.framework; path = /System/Library/Frameworks/Carbon.framework; sourceTree = "<absolute>"; };
+		0082F04D0C824FE100E926BE /* ConsoleDemo */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = ConsoleDemo; sourceTree = BUILT_PRODUCTS_DIR; };
+		0082F2880C827BF500E926BE /* OISConsole.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = OISConsole.cpp; path = ../../demos/OISConsole.cpp; sourceTree = SOURCE_ROOT; };
+		249631C31066333900EFD0E1 /* MacJoyStick.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MacJoyStick.cpp; path = ../../src/mac/MacJoyStick.cpp; sourceTree = SOURCE_ROOT; };
+		4A04E1A70CEF6B6B00E2B94E /* OISFactoryCreator.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = OISFactoryCreator.h; path = ../../includes/OISFactoryCreator.h; sourceTree = SOURCE_ROOT; };
+		4A852C41112256D400A0BC84 /* OISMultiTouch.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OISMultiTouch.h; path = ../../includes/OISMultiTouch.h; sourceTree = SOURCE_ROOT; };
+		4AC4C3930CDD840500603F93 /* IOKit.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = IOKit.framework; path = /System/Library/Frameworks/IOKit.framework; sourceTree = "<absolute>"; };
+		4ACD7A520CEF903600D72CD9 /* OISException.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = OISException.cpp; path = ../../src/OISException.cpp; sourceTree = SOURCE_ROOT; };
+		4ADFD2650CDE7322006031E4 /* MacHIDManager.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = MacHIDManager.h; path = ../../includes/mac/MacHIDManager.h; sourceTree = SOURCE_ROOT; };
+		4ADFD2A80CDE7BAC006031E4 /* MacHIDManager.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = MacHIDManager.cpp; path = ../../src/mac/MacHIDManager.cpp; sourceTree = SOURCE_ROOT; };
+		4AEB08F60D73DA6D007CD406 /* ConsoleTest.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = ConsoleTest.app; sourceTree = BUILT_PRODUCTS_DIR; };
+		4AEB08F80D73DA6D007CD406 /* ConsoleTest-Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = "ConsoleTest-Info.plist"; sourceTree = "<group>"; };
+/* End PBXFileReference section */
+
+/* Begin PBXFrameworksBuildPhase section */
+		0043D85B0C356509007ACDF6 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				0043D8F70C356840007ACDF6 /* Carbon.framework in Frameworks */,
+				4ADFD0130CDD94B2006031E4 /* IOKit.framework in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		0043D8A60C3566F6007ACDF6 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				0043D8F80C356840007ACDF6 /* Carbon.framework in Frameworks */,
+				4ADFD0100CDD948B006031E4 /* IOKit.framework in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		0043D8BE0C3567B2007ACDF6 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				0043D8F90C356840007ACDF6 /* Carbon.framework in Frameworks */,
+				4ADFD0110CDD948C006031E4 /* IOKit.framework in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4AEB08E10D73D9BF007CD406 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				4AEB08E30D73D9D1007CD406 /* OIS.framework in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4AEB08F40D73DA6D007CD406 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				4AEB090C0D73DABC007CD406 /* OIS.framework in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXFrameworksBuildPhase section */
+
+/* Begin PBXGroup section */
+		0043D84C0C3564F8007ACDF6 = {
+			isa = PBXGroup;
+			children = (
+				0043D8670C3565B2007ACDF6 /* Include */,
+				0043D8680C3565B7007ACDF6 /* Source */,
+				0043D8690C3565BD007ACDF6 /* Resources */,
+				0043D86A0C3565C8007ACDF6 /* External Frameworks and Libraries */,
+				0043D85E0C356509007ACDF6 /* Products */,
+				0043D85F0C356509007ACDF6 /* OIS-Info.plist */,
+				4AEB08F80D73DA6D007CD406 /* ConsoleTest-Info.plist */,
+			);
+			sourceTree = "<group>";
+		};
+		0043D85E0C356509007ACDF6 /* Products */ = {
+			isa = PBXGroup;
+			children = (
+				0043D85D0C356509007ACDF6 /* OIS.framework */,
+				0043D8A80C3566F6007ACDF6 /* OIS.dylib */,
+				0043D8C00C3567B2007ACDF6 /* libOIS.a */,
+				0082F04D0C824FE100E926BE /* ConsoleDemo */,
+				4AEB08F60D73DA6D007CD406 /* ConsoleTest.app */,
+			);
+			name = Products;
+			sourceTree = "<group>";
+		};
+		0043D8670C3565B2007ACDF6 /* Include */ = {
+			isa = PBXGroup;
+			children = (
+				0043D86B0C3565E0007ACDF6 /* OSX */,
+				0043D86C0C3565E5007ACDF6 /* Base */,
+			);
+			name = Include;
+			sourceTree = "<group>";
+		};
+		0043D8680C3565B7007ACDF6 /* Source */ = {
+			isa = PBXGroup;
+			children = (
+				0043D86D0C3565F7007ACDF6 /* OSX */,
+				0043D86E0C3565FB007ACDF6 /* Base */,
+				0082F0410C824E1300E926BE /* Demos */,
+			);
+			name = Source;
+			sourceTree = "<group>";
+		};
+		0043D8690C3565BD007ACDF6 /* Resources */ = {
+			isa = PBXGroup;
+			children = (
+			);
+			name = Resources;
+			sourceTree = "<group>";
+		};
+		0043D86A0C3565C8007ACDF6 /* External Frameworks and Libraries */ = {
+			isa = PBXGroup;
+			children = (
+				4AC4C3930CDD840500603F93 /* IOKit.framework */,
+				0043D8F60C356840007ACDF6 /* Carbon.framework */,
+			);
+			name = "External Frameworks and Libraries";
+			sourceTree = "<group>";
+		};
+		0043D86B0C3565E0007ACDF6 /* OSX */ = {
+			isa = PBXGroup;
+			children = (
+				0043D88A0C35665B007ACDF6 /* MacPrereqs.h */,
+				0043D88B0C35665B007ACDF6 /* MacInputManager.h */,
+				0043D88C0C35665B007ACDF6 /* MacHelpers.h */,
+				4ADFD2650CDE7322006031E4 /* MacHIDManager.h */,
+				0043D88E0C35665B007ACDF6 /* MacKeyboard.h */,
+				0043D88D0C35665B007ACDF6 /* MacMouse.h */,
+			);
+			name = OSX;
+			sourceTree = "<group>";
+		};
+		0043D86C0C3565E5007ACDF6 /* Base */ = {
+			isa = PBXGroup;
+			children = (
+				4A852C41112256D400A0BC84 /* OISMultiTouch.h */,
+				0043D8700C35664A007ACDF6 /* OIS.h */,
+				0043D8710C35664A007ACDF6 /* OISConfig.h */,
+				0043D8720C35664A007ACDF6 /* OISEffect.h */,
+				0043D8730C35664A007ACDF6 /* OISEvents.h */,
+				0043D8740C35664A007ACDF6 /* OISException.h */,
+				4A04E1A70CEF6B6B00E2B94E /* OISFactoryCreator.h */,
+				0043D8750C35664A007ACDF6 /* OISForceFeedback.h */,
+				0043D8760C35664A007ACDF6 /* OISInputManager.h */,
+				0043D8770C35664A007ACDF6 /* OISInterface.h */,
+				0043D8780C35664A007ACDF6 /* OISJoyStick.h */,
+				0043D8790C35664A007ACDF6 /* OISKeyboard.h */,
+				0043D87A0C35664A007ACDF6 /* OISMouse.h */,
+				0043D87B0C35664A007ACDF6 /* OISObject.h */,
+				0043D87C0C35664A007ACDF6 /* OISPrereqs.h */,
+			);
+			name = Base;
+			sourceTree = "<group>";
+		};
+		0043D86D0C3565F7007ACDF6 /* OSX */ = {
+			isa = PBXGroup;
+			children = (
+				249631C31066333900EFD0E1 /* MacJoyStick.cpp */,
+				0043D89C0C3566C9007ACDF6 /* MacHelpers.cpp */,
+				4ADFD2A80CDE7BAC006031E4 /* MacHIDManager.cpp */,
+				0043D89D0C3566C9007ACDF6 /* MacInputManager.cpp */,
+				0043D89E0C3566C9007ACDF6 /* MacKeyboard.cpp */,
+				0043D89F0C3566C9007ACDF6 /* MacMouse.cpp */,
+			);
+			name = OSX;
+			sourceTree = "<group>";
+		};
+		0043D86E0C3565FB007ACDF6 /* Base */ = {
+			isa = PBXGroup;
+			children = (
+				0043D8900C3566C1007ACDF6 /* OISEffect.cpp */,
+				4ACD7A520CEF903600D72CD9 /* OISException.cpp */,
+				0043D8910C3566C1007ACDF6 /* OISForceFeedback.cpp */,
+				0043D8920C3566C1007ACDF6 /* OISInputManager.cpp */,
+				0043D8930C3566C1007ACDF6 /* OISJoyStick.cpp */,
+				0043D8940C3566C1007ACDF6 /* OISKeyboard.cpp */,
+				0043D8950C3566C1007ACDF6 /* OISObject.cpp */,
+			);
+			name = Base;
+			sourceTree = "<group>";
+		};
+		0082F0410C824E1300E926BE /* Demos */ = {
+			isa = PBXGroup;
+			children = (
+				0082F2880C827BF500E926BE /* OISConsole.cpp */,
+			);
+			name = Demos;
+			sourceTree = "<group>";
+		};
+/* End PBXGroup section */
+
+/* Begin PBXHeadersBuildPhase section */
+		0043D8580C356509007ACDF6 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				0043D87D0C35664A007ACDF6 /* OIS.h in Headers */,
+				0043D87E0C35664A007ACDF6 /* OISConfig.h in Headers */,
+				0043D87F0C35664A007ACDF6 /* OISEffect.h in Headers */,
+				0043D8800C35664A007ACDF6 /* OISEvents.h in Headers */,
+				0043D8810C35664A007ACDF6 /* OISException.h in Headers */,
+				0043D8820C35664A007ACDF6 /* OISForceFeedback.h in Headers */,
+				0043D8830C35664A007ACDF6 /* OISInputManager.h in Headers */,
+				0043D8840C35664A007ACDF6 /* OISInterface.h in Headers */,
+				0043D8850C35664A007ACDF6 /* OISJoyStick.h in Headers */,
+				0043D8860C35664A007ACDF6 /* OISKeyboard.h in Headers */,
+				0043D8870C35664A007ACDF6 /* OISMouse.h in Headers */,
+				0043D8880C35664A007ACDF6 /* OISObject.h in Headers */,
+				0043D8890C35664A007ACDF6 /* OISPrereqs.h in Headers */,
+				4ADFD2660CDE7322006031E4 /* MacHIDManager.h in Headers */,
+				4A04E1A80CEF6B6B00E2B94E /* OISFactoryCreator.h in Headers */,
+				4A852C42112256D400A0BC84 /* OISMultiTouch.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		0043D8A40C3566F6007ACDF6 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				0043D8C70C35680D007ACDF6 /* OIS.h in Headers */,
+				0043D8C80C35680D007ACDF6 /* OISConfig.h in Headers */,
+				0043D8C90C35680D007ACDF6 /* OISEffect.h in Headers */,
+				0043D8CA0C35680D007ACDF6 /* OISEvents.h in Headers */,
+				0043D8CB0C35680D007ACDF6 /* OISException.h in Headers */,
+				0043D8CC0C35680D007ACDF6 /* OISForceFeedback.h in Headers */,
+				0043D8CD0C35680D007ACDF6 /* OISInputManager.h in Headers */,
+				0043D8CE0C35680D007ACDF6 /* OISInterface.h in Headers */,
+				0043D8CF0C35680D007ACDF6 /* OISJoyStick.h in Headers */,
+				0043D8D00C35680D007ACDF6 /* OISKeyboard.h in Headers */,
+				0043D8D10C35680D007ACDF6 /* OISMouse.h in Headers */,
+				0043D8D20C35680D007ACDF6 /* OISObject.h in Headers */,
+				0043D8D30C35680D007ACDF6 /* OISPrereqs.h in Headers */,
+				4ADFD2670CDE7322006031E4 /* MacHIDManager.h in Headers */,
+				4A04E1A90CEF6B6B00E2B94E /* OISFactoryCreator.h in Headers */,
+				4A852C43112256D400A0BC84 /* OISMultiTouch.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		0043D8BC0C3567B2007ACDF6 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				0043D8D40C35680D007ACDF6 /* OIS.h in Headers */,
+				0043D8D50C35680D007ACDF6 /* OISConfig.h in Headers */,
+				0043D8D60C35680D007ACDF6 /* OISEffect.h in Headers */,
+				0043D8D70C35680D007ACDF6 /* OISEvents.h in Headers */,
+				0043D8D80C35680D007ACDF6 /* OISException.h in Headers */,
+				0043D8D90C35680D007ACDF6 /* OISForceFeedback.h in Headers */,
+				0043D8DA0C35680D007ACDF6 /* OISInputManager.h in Headers */,
+				0043D8DB0C35680D007ACDF6 /* OISInterface.h in Headers */,
+				0043D8DC0C35680D007ACDF6 /* OISJoyStick.h in Headers */,
+				0043D8DD0C35680D007ACDF6 /* OISKeyboard.h in Headers */,
+				0043D8DE0C35680D007ACDF6 /* OISMouse.h in Headers */,
+				0043D8DF0C35680D007ACDF6 /* OISObject.h in Headers */,
+				0043D8E00C35680D007ACDF6 /* OISPrereqs.h in Headers */,
+				4ADFD2680CDE7322006031E4 /* MacHIDManager.h in Headers */,
+				4A04E1AA0CEF6B6B00E2B94E /* OISFactoryCreator.h in Headers */,
+				4A852C44112256D400A0BC84 /* OISMultiTouch.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXHeadersBuildPhase section */
+
+/* Begin PBXNativeTarget section */
+		0043D85C0C356509007ACDF6 /* OIS */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 0043D8610C356509007ACDF6 /* Build configuration list for PBXNativeTarget "OIS" */;
+			buildPhases = (
+				0043D8580C356509007ACDF6 /* Headers */,
+				0043D8590C356509007ACDF6 /* Resources */,
+				0043D85A0C356509007ACDF6 /* Sources */,
+				0043D85B0C356509007ACDF6 /* Frameworks */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = OIS;
+			productName = OIS;
+			productReference = 0043D85D0C356509007ACDF6 /* OIS.framework */;
+			productType = "com.apple.product-type.framework";
+		};
+		0043D8A70C3566F6007ACDF6 /* OISdylib */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 0043D8B90C35674D007ACDF6 /* Build configuration list for PBXNativeTarget "OISdylib" */;
+			buildPhases = (
+				0043D8A40C3566F6007ACDF6 /* Headers */,
+				0043D8A50C3566F6007ACDF6 /* Sources */,
+				0043D8A60C3566F6007ACDF6 /* Frameworks */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = OISdylib;
+			productName = OISdylib;
+			productReference = 0043D8A80C3566F6007ACDF6 /* OIS.dylib */;
+			productType = "com.apple.product-type.library.dynamic";
+		};
+		0043D8BF0C3567B2007ACDF6 /* OISstatic */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 0043D8C40C356801007ACDF6 /* Build configuration list for PBXNativeTarget "OISstatic" */;
+			buildPhases = (
+				0043D8BC0C3567B2007ACDF6 /* Headers */,
+				0043D8BD0C3567B2007ACDF6 /* Sources */,
+				0043D8BE0C3567B2007ACDF6 /* Frameworks */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = OISstatic;
+			productName = OISstatic;
+			productReference = 0043D8C00C3567B2007ACDF6 /* libOIS.a */;
+			productType = "com.apple.product-type.library.static";
+		};
+		0082F04C0C824FE100E926BE /* ConsoleDemo */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 0082F0530C82502F00E926BE /* Build configuration list for PBXNativeTarget "ConsoleDemo" */;
+			buildPhases = (
+				0082F04A0C824FE100E926BE /* Sources */,
+				4AEB08E10D73D9BF007CD406 /* Frameworks */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = ConsoleDemo;
+			productName = ConsoleDemo;
+			productReference = 0082F04D0C824FE100E926BE /* ConsoleDemo */;
+			productType = "com.apple.product-type.tool";
+		};
+		4AEB08F50D73DA6D007CD406 /* ConsoleTest */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 4AEB08F90D73DA6D007CD406 /* Build configuration list for PBXNativeTarget "ConsoleTest" */;
+			buildPhases = (
+				4AEB08F20D73DA6D007CD406 /* Resources */,
+				4AEB08F30D73DA6D007CD406 /* Sources */,
+				4AEB08F40D73DA6D007CD406 /* Frameworks */,
+				4AEB09210D73DBB8007CD406 /* CopyFiles */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = ConsoleTest;
+			productName = ConsoleTest;
+			productReference = 4AEB08F60D73DA6D007CD406 /* ConsoleTest.app */;
+			productType = "com.apple.product-type.application";
+		};
+/* End PBXNativeTarget section */
+
+/* Begin PBXProject section */
+		0043D84E0C3564F8007ACDF6 /* Project object */ = {
+			isa = PBXProject;
+			buildConfigurationList = 0043D84F0C3564F8007ACDF6 /* Build configuration list for PBXProject "OIS" */;
+			compatibilityVersion = "Xcode 2.4";
+			hasScannedForEncodings = 0;
+			mainGroup = 0043D84C0C3564F8007ACDF6;
+			productRefGroup = 0043D85E0C356509007ACDF6 /* Products */;
+			projectDirPath = "";
+			projectRoot = "";
+			targets = (
+				0043D98F0C356851007ACDF6 /* Build All */,
+				0043D85C0C356509007ACDF6 /* OIS */,
+				0043D8A70C3566F6007ACDF6 /* OISdylib */,
+				0043D8BF0C3567B2007ACDF6 /* OISstatic */,
+				0082F04C0C824FE100E926BE /* ConsoleDemo */,
+				4AEB08F50D73DA6D007CD406 /* ConsoleTest */,
+			);
+		};
+/* End PBXProject section */
+
+/* Begin PBXResourcesBuildPhase section */
+		0043D8590C356509007ACDF6 /* Resources */ = {
+			isa = PBXResourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				0043D8F50C356828007ACDF6 /* OIS-Info.plist in Resources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4AEB08F20D73DA6D007CD406 /* Resources */ = {
+			isa = PBXResourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXResourcesBuildPhase section */
+
+/* Begin PBXSourcesBuildPhase section */
+		0043D85A0C356509007ACDF6 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				0043D8960C3566C1007ACDF6 /* OISEffect.cpp in Sources */,
+				0043D8970C3566C1007ACDF6 /* OISForceFeedback.cpp in Sources */,
+				0043D8980C3566C1007ACDF6 /* OISInputManager.cpp in Sources */,
+				0043D8990C3566C1007ACDF6 /* OISJoyStick.cpp in Sources */,
+				0043D89A0C3566C1007ACDF6 /* OISKeyboard.cpp in Sources */,
+				0043D89B0C3566C1007ACDF6 /* OISObject.cpp in Sources */,
+				0043D8A00C3566C9007ACDF6 /* MacHelpers.cpp in Sources */,
+				0043D8A10C3566C9007ACDF6 /* MacInputManager.cpp in Sources */,
+				0043D8A20C3566C9007ACDF6 /* MacKeyboard.cpp in Sources */,
+				0043D8A30C3566C9007ACDF6 /* MacMouse.cpp in Sources */,
+				4ADFD2A90CDE7BAC006031E4 /* MacHIDManager.cpp in Sources */,
+				249631C71066334D00EFD0E1 /* MacJoyStick.cpp in Sources */,
+				4ACD7A530CEF903600D72CD9 /* OISException.cpp in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		0043D8A50C3566F6007ACDF6 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				0043D8E10C356819007ACDF6 /* MacHelpers.cpp in Sources */,
+				0043D8E20C356819007ACDF6 /* MacInputManager.cpp in Sources */,
+				0043D8E30C356819007ACDF6 /* MacKeyboard.cpp in Sources */,
+				0043D8E40C356819007ACDF6 /* MacMouse.cpp in Sources */,
+				0043D8E50C356819007ACDF6 /* OISEffect.cpp in Sources */,
+				0043D8E60C356819007ACDF6 /* OISForceFeedback.cpp in Sources */,
+				0043D8E70C356819007ACDF6 /* OISInputManager.cpp in Sources */,
+				0043D8E80C356819007ACDF6 /* OISJoyStick.cpp in Sources */,
+				0043D8E90C356819007ACDF6 /* OISKeyboard.cpp in Sources */,
+				0043D8EA0C356819007ACDF6 /* OISObject.cpp in Sources */,
+				4ADFD2AA0CDE7BAC006031E4 /* MacHIDManager.cpp in Sources */,
+				249631C81066335600EFD0E1 /* MacJoyStick.cpp in Sources */,
+				4ACD7A540CEF903600D72CD9 /* OISException.cpp in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		0043D8BD0C3567B2007ACDF6 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				0043D8EB0C35681A007ACDF6 /* MacHelpers.cpp in Sources */,
+				0043D8EC0C35681A007ACDF6 /* MacInputManager.cpp in Sources */,
+				0043D8ED0C35681A007ACDF6 /* MacKeyboard.cpp in Sources */,
+				0043D8EE0C35681A007ACDF6 /* MacMouse.cpp in Sources */,
+				0043D8EF0C35681A007ACDF6 /* OISEffect.cpp in Sources */,
+				0043D8F00C35681A007ACDF6 /* OISForceFeedback.cpp in Sources */,
+				0043D8F10C35681A007ACDF6 /* OISInputManager.cpp in Sources */,
+				0043D8F20C35681A007ACDF6 /* OISJoyStick.cpp in Sources */,
+				0043D8F30C35681A007ACDF6 /* OISKeyboard.cpp in Sources */,
+				0043D8F40C35681A007ACDF6 /* OISObject.cpp in Sources */,
+				4ADFD2AB0CDE7BAC006031E4 /* MacHIDManager.cpp in Sources */,
+				249631C91066335D00EFD0E1 /* MacJoyStick.cpp in Sources */,
+				4ACD7A550CEF903600D72CD9 /* OISException.cpp in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		0082F04A0C824FE100E926BE /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				0082F2890C827BF500E926BE /* OISConsole.cpp in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4AEB08F30D73DA6D007CD406 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				4AEB08FC0D73DA81007CD406 /* OISConsole.cpp in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXSourcesBuildPhase section */
+
+/* Begin PBXTargetDependency section */
+		0043D9910C35685A007ACDF6 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 0043D8BF0C3567B2007ACDF6 /* OISstatic */;
+			targetProxy = 0043D9900C35685A007ACDF6 /* PBXContainerItemProxy */;
+		};
+		0043D9930C35685A007ACDF6 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 0043D8A70C3566F6007ACDF6 /* OISdylib */;
+			targetProxy = 0043D9920C35685A007ACDF6 /* PBXContainerItemProxy */;
+		};
+		0043D9950C35685A007ACDF6 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 0043D85C0C356509007ACDF6 /* OIS */;
+			targetProxy = 0043D9940C35685A007ACDF6 /* PBXContainerItemProxy */;
+		};
+		0082F1CF0C82634200E926BE /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 0082F04C0C824FE100E926BE /* ConsoleDemo */;
+			targetProxy = 0082F1CE0C82634200E926BE /* PBXContainerItemProxy */;
+		};
+		4AEB091E0D73DB7D007CD406 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 4AEB08F50D73DA6D007CD406 /* ConsoleTest */;
+			targetProxy = 4AEB091D0D73DB7D007CD406 /* PBXContainerItemProxy */;
+		};
+/* End PBXTargetDependency section */
+
+/* Begin XCBuildConfiguration section */
+		0043D8500C3564F8007ACDF6 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = (
+					ppc,
+					i386,
+				);
+				COPY_PHASE_STRIP = YES;
+				GCC_SYMBOLS_PRIVATE_EXTERN = YES;
+				SDKROOT = /Developer/SDKs/MacOSX10.4u.sdk;
+				USER_HEADER_SEARCH_PATHS = ../../includes;
+			};
+			name = Debug;
+		};
+		0043D8510C3564F8007ACDF6 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = (
+					ppc,
+					i386,
+				);
+				COPY_PHASE_STRIP = YES;
+				GCC_SYMBOLS_PRIVATE_EXTERN = YES;
+				SDKROOT = /Developer/SDKs/MacOSX10.4u.sdk;
+				USER_HEADER_SEARCH_PATHS = ../../includes;
+			};
+			name = Release;
+		};
+		0043D8620C356509007ACDF6 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1.0;
+				DYLIB_CURRENT_VERSION = 1.0;
+				FRAMEWORK_VERSION = A;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Headers/Carbon.h";
+				GCC_VERSION = 4.0;
+				INFOPLIST_FILE = "OIS-Info.plist";
+				INSTALL_PATH = "@executable_path/../Frameworks";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Carbon,
+				);
+				PREBINDING = NO;
+				PRODUCT_NAME = OIS;
+				ZERO_LINK = YES;
+			};
+			name = Debug;
+		};
+		0043D8630C356509007ACDF6 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1.0;
+				DYLIB_CURRENT_VERSION = 1.0;
+				FRAMEWORK_VERSION = A;
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
+				GCC_MODEL_TUNING = G5;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Headers/Carbon.h";
+				GCC_VERSION = 4.0;
+				INFOPLIST_FILE = "OIS-Info.plist";
+				INSTALL_PATH = "@executable_path/../Frameworks";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Carbon,
+				);
+				PREBINDING = NO;
+				PRODUCT_NAME = OIS;
+				ZERO_LINK = NO;
+			};
+			name = Release;
+		};
+		0043D8BA0C35674D007ACDF6 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1.0;
+				DYLIB_CURRENT_VERSION = 1.0;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Headers/Carbon.h";
+				GCC_VERSION = 4.0;
+				INSTALL_PATH = "@executable_path/../Frameworks";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Carbon,
+				);
+				PREBINDING = NO;
+				PRODUCT_NAME = OIS;
+				ZERO_LINK = NO;
+			};
+			name = Debug;
+		};
+		0043D8BB0C35674D007ACDF6 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1.0;
+				DYLIB_CURRENT_VERSION = 1.0;
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
+				GCC_MODEL_TUNING = G5;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Headers/Carbon.h";
+				GCC_VERSION = 4.0;
+				INSTALL_PATH = "@executable_path/../Frameworks";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Carbon,
+				);
+				PREBINDING = NO;
+				PRODUCT_NAME = OIS;
+				ZERO_LINK = NO;
+			};
+			name = Release;
+		};
+		0043D8C50C356801007ACDF6 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Headers/Carbon.h";
+				GCC_VERSION = 4.0;
+				INSTALL_PATH = /usr/local/lib;
+				OTHER_LDFLAGS = (
+					"-framework",
+					Carbon,
+				);
+				PREBINDING = NO;
+				PRODUCT_NAME = OIS;
+				ZERO_LINK = NO;
+			};
+			name = Debug;
+		};
+		0043D8C60C356801007ACDF6 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
+				GCC_MODEL_TUNING = G5;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Headers/Carbon.h";
+				GCC_VERSION = 4.0;
+				INSTALL_PATH = /usr/local/lib;
+				OTHER_LDFLAGS = (
+					"-framework",
+					Carbon,
+				);
+				PREBINDING = NO;
+				PRODUCT_NAME = OIS;
+				ZERO_LINK = NO;
+			};
+			name = Release;
+		};
+		0043D99B0C356867007ACDF6 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				PRODUCT_NAME = "Build All";
+			};
+			name = Debug;
+		};
+		0043D99C0C356867007ACDF6 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
+				PRODUCT_NAME = "Build All";
+				ZERO_LINK = NO;
+			};
+			name = Release;
+		};
+		0082F0540C82502F00E926BE /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_1 = "\"$(SRCROOT)/build/Release\"";
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Headers/Carbon.h";
+				GCC_VERSION = 4.0;
+				INSTALL_PATH = "$(HOME)/bin";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Carbon,
+				);
+				PREBINDING = NO;
+				PRODUCT_NAME = ConsoleDemo;
+				ZERO_LINK = YES;
+			};
+			name = Debug;
+		};
+		0082F0550C82502F00E926BE /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_1 = "\"$(SRCROOT)/build/Release\"";
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
+				GCC_MODEL_TUNING = G5;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Headers/Carbon.h";
+				GCC_VERSION = 4.0;
+				INSTALL_PATH = "$(HOME)/bin";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Carbon,
+				);
+				PREBINDING = NO;
+				PRODUCT_NAME = ConsoleDemo;
+				ZERO_LINK = NO;
+			};
+			name = Release;
+		};
+		4AEB08FA0D73DA6D007CD406 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_1 = "\"$(SRCROOT)/build/Release\"";
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Headers/Carbon.h";
+				GCC_VERSION = 4.0;
+				INFOPLIST_FILE = "ConsoleTest-Info.plist";
+				INSTALL_PATH = "$(HOME)/Applications";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Carbon,
+				);
+				PREBINDING = NO;
+				PRODUCT_NAME = ConsoleTest;
+				WRAPPER_EXTENSION = app;
+				ZERO_LINK = YES;
+			};
+			name = Debug;
+		};
+		4AEB08FB0D73DA6D007CD406 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_1 = "\"$(SRCROOT)/build/Release\"";
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
+				GCC_MODEL_TUNING = G5;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Headers/Carbon.h";
+				GCC_VERSION = 4.0;
+				INFOPLIST_FILE = "ConsoleTest-Info.plist";
+				INSTALL_PATH = "$(HOME)/Applications";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Carbon,
+				);
+				PREBINDING = NO;
+				PRODUCT_NAME = ConsoleTest;
+				WRAPPER_EXTENSION = app;
+				ZERO_LINK = NO;
+			};
+			name = Release;
+		};
+/* End XCBuildConfiguration section */
+
+/* Begin XCConfigurationList section */
+		0043D84F0C3564F8007ACDF6 /* Build configuration list for PBXProject "OIS" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				0043D8500C3564F8007ACDF6 /* Debug */,
+				0043D8510C3564F8007ACDF6 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		0043D8610C356509007ACDF6 /* Build configuration list for PBXNativeTarget "OIS" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				0043D8620C356509007ACDF6 /* Debug */,
+				0043D8630C356509007ACDF6 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		0043D8B90C35674D007ACDF6 /* Build configuration list for PBXNativeTarget "OISdylib" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				0043D8BA0C35674D007ACDF6 /* Debug */,
+				0043D8BB0C35674D007ACDF6 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		0043D8C40C356801007ACDF6 /* Build configuration list for PBXNativeTarget "OISstatic" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				0043D8C50C356801007ACDF6 /* Debug */,
+				0043D8C60C356801007ACDF6 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		0043D99A0C356867007ACDF6 /* Build configuration list for PBXAggregateTarget "Build All" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				0043D99B0C356867007ACDF6 /* Debug */,
+				0043D99C0C356867007ACDF6 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		0082F0530C82502F00E926BE /* Build configuration list for PBXNativeTarget "ConsoleDemo" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				0082F0540C82502F00E926BE /* Debug */,
+				0082F0550C82502F00E926BE /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		4AEB08F90D73DA6D007CD406 /* Build configuration list for PBXNativeTarget "ConsoleTest" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				4AEB08FA0D73DA6D007CD406 /* Debug */,
+				4AEB08FB0D73DA6D007CD406 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+/* End XCConfigurationList section */
+	};
+	rootObject = 0043D84E0C3564F8007ACDF6 /* Project object */;
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Makefile.am b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Makefile.am
new file mode 100644
index 0000000..66adf66
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Makefile.am
@@ -0,0 +1,4 @@
+SUBDIRS =  src includes demos
+
+pkgconfigdir = $(libdir)/pkgconfig
+pkgconfig_DATA = OIS.pc
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/OIS.pc.in b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/OIS.pc.in
new file mode 100644
index 0000000..aab0b7a
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/OIS.pc.in
@@ -0,0 +1,11 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: OIS
+Description: Cross platform C++ Input Framework
+Version: @VERSION@
+Libs: -L${libdir} -lOIS
+Cflags: -I${includedir}/@PACKAGE@ -I${includedir}
+
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/ReadMe.txt b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/ReadMe.txt
new file mode 100644
index 0000000..9a8a8c9
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/ReadMe.txt
@@ -0,0 +1,76 @@
+======================================================================================
+================ LICENSE =============================================================
+======================================================================================
+
+The zlib/libpng License
+
+Copyright (c) 2005-2010 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no 
+event will the authors be held liable for any damages arising from the use of this 
+software.
+
+Permission is granted to anyone to use this software for any purpose, including 
+commercial applications, and to alter it and redistribute it freely, subject to the 
+following restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated 
+		but is not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+
+
+======================================================================================
+================ LICENSE EXPLAINED ===================================================
+======================================================================================
+In case the license was not clear enough... Basically, you can link with this lib 
+which puts no restrictions on what you have to license your code as. You can modify 
+this lib, and not have release your changes. Though, as explained above, <bold> 
+Altered source versions must be plainly marked as such, and must not be misrepresented
+as being the original software </bold>
+
+This is to allow users the greatest flexibility in what you can use this lib for.
+
+======================================================================================
+================ INFO ================================================================
+======================================================================================
+
+Cross Platform Object Oriented Input Lib System. Meant to be very robust and 
+compatiable with many systems and operating systems
+
+Win32/
+	Contains Visual Studio .Net Solution Files
+	Contains CodeBlocks project files for OIS
+	
+	---- Dependencies ------------------------------------------------------
+	DirectInput 8
+
+
+Linux/
+	---- Dependencies ------------------------------------------------------
+	X11
+        Newer Linux Kernel (2.6+ ?) for Event API
+
+	Steps to build on Linux:
+	./bootstrap
+	./configure
+	./make && make install
+
+	---- Configure build options --------------------------------------------
+	./configure --help              --- List all configure options
+
+
+LinuxCB/
+        Contains CodeBlock files for building OIS and Demos with codeblocks
+        This project file looks for Ogre and other dependencies in /usr/local/lib
+        and /usr/local/include. If installed elsewhere, modify the project
+        settings. It also installs libOIS to ~/libs
+
+Mac/
+	XCode-2.2/
+		Working, mostly complete OSX vackend.
\ No newline at end of file
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/CommandLine/CommandLine.cbp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/CommandLine/CommandLine.cbp
new file mode 100644
index 0000000..8d6162a
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/CommandLine/CommandLine.cbp
@@ -0,0 +1,80 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
+<CodeBlocks_project_file>
+	<FileVersion major="1" minor="6" />
+	<Project>
+		<Option title="Demo Console" />
+		<Option compiler="gcc" />
+		<Build>
+			<Target title="Debug">
+				<Option output="bin\Debug\CommandLine.exe" prefix_auto="0" extension_auto="0" />
+				<Option working_dir="bin\Debug" />
+				<Option object_output=".\obj\Debug" />
+				<Option external_deps="..\lib\libOIS_static_d.a;" />
+				<Option type="1" />
+				<Option compiler="gcc" />
+				<Option projectResourceIncludeDirsRelation="0" />
+				<Compiler>
+					<Add option="-g" />
+					<Add option="-O0" />
+					<Add option="-D_DEBUG" />
+					<Add option="-D_STLP_DEBUG" />
+				</Compiler>
+				<Linker>
+					<Add library="OIS_static_d" />
+					<Add library="dinput8" />
+					<Add library="dxguid" />
+				</Linker>
+			</Target>
+			<Target title="Release">
+				<Option output="bin\Release\CommandLine.exe" prefix_auto="0" extension_auto="0" />
+				<Option working_dir="bin\Release" />
+				<Option object_output=".\obj\Release" />
+				<Option external_deps="..\lib\libOIS_static.a;" />
+				<Option type="1" />
+				<Option compiler="gcc" />
+				<Option projectResourceIncludeDirsRelation="0" />
+				<Compiler>
+					<Add option="-O2" />
+					<Add option="-DNDEBUG" />
+				</Compiler>
+				<Linker>
+					<Add option="-s" />
+					<Add library="OIS_static" />
+					<Add library="dinput8" />
+					<Add library="dxguid" />
+				</Linker>
+			</Target>
+		</Build>
+		<VirtualTargets>
+			<Add alias="All" targets="Debug;Release;" />
+		</VirtualTargets>
+		<Compiler>
+			<Add option="-Wall" />
+			<Add option="-mthreads" />
+			<Add option="-fmessage-length=0" />
+			<Add option="-fexceptions" />
+			<Add option="-fident" />
+			<Add option="-pipe" />
+			<Add option="-DWIN32" />
+			<Add option="-D_CONSOLE" />
+			<Add directory="..\..\includes" />
+			<Add directory="..\CommandLine\" />
+		</Compiler>
+		<Linker>
+			<Add option="-Wl,--enable-auto-image-base" />
+			<Add option="-Wl,--add-stdcall-alias" />
+			<Add directory="..\..\lib" />
+			<Add directory="..\..\dll" />
+		</Linker>
+		<Unit filename="CommandLine.rc">
+			<Option compilerVar="WINDRES" />
+		</Unit>
+		<Unit filename="resource.h" />
+		<Unit filename="..\..\demos\OISConsole.cpp" />
+		<Extensions>
+			<code_completion />
+			<envvars />
+			<debugger />
+		</Extensions>
+	</Project>
+</CodeBlocks_project_file>
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/CommandLine/CommandLine.rc b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/CommandLine/CommandLine.rc
new file mode 100644
index 0000000..02ff5c5
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/CommandLine/CommandLine.rc
@@ -0,0 +1,99 @@
+// Microsoft Visual C++ generated resource script.
+//
+#include "resource.h"
+
+#define APSTUDIO_READONLY_SYMBOLS
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 2 resource.
+//
+#ifndef IDC_STATIC
+#define IDC_STATIC (-1)
+#endif
+#include "winresrc.h"
+//#include "afxres.h"
+
+/////////////////////////////////////////////////////////////////////////////
+#undef APSTUDIO_READONLY_SYMBOLS
+
+/////////////////////////////////////////////////////////////////////////////
+// English (U.S.) resources
+
+#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
+#ifdef _WIN32
+LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
+#pragma code_page(1252)
+#endif //_WIN32
+
+#ifdef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// TEXTINCLUDE
+//
+
+1 TEXTINCLUDE 
+BEGIN
+    "resource.h\0"
+END
+
+2 TEXTINCLUDE 
+BEGIN
+    "#include ""afxres.h""\r\n"
+    "\0"
+END
+
+3 TEXTINCLUDE 
+BEGIN
+    "\r\n"
+    "\0"
+END
+
+#endif    // APSTUDIO_INVOKED
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Dialog
+//
+
+IDD_DIALOG1 DIALOGEX 0, 0, 100, 100
+STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
+CAPTION "Capture Window"
+FONT 8, "MS Shell Dlg", 400, 0, 0x1
+BEGIN
+    LTEXT           "This window is used as Input Capture Window, and to display some info. Press Q or ESC to exit or hit button 1 of joystick",
+                    IDC_STATIC,7,7,82,86
+END
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// DESIGNINFO
+//
+
+#ifdef APSTUDIO_INVOKED
+GUIDELINES DESIGNINFO 
+BEGIN
+    IDD_DIALOG1, DIALOG
+    BEGIN
+        LEFTMARGIN, 7
+        TOPMARGIN, 7
+    END
+END
+#endif    // APSTUDIO_INVOKED
+
+#endif    // English (U.S.) resources
+/////////////////////////////////////////////////////////////////////////////
+
+
+
+#ifndef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 3 resource.
+//
+
+
+/////////////////////////////////////////////////////////////////////////////
+#endif    // not APSTUDIO_INVOKED
+
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/CommandLine/CommandLine.vcproj b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/CommandLine/CommandLine.vcproj
new file mode 100644
index 0000000..8990460
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/CommandLine/CommandLine.vcproj
@@ -0,0 +1,131 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="Demo_Console"
+	ProjectGUID="{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="1"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\includes;..\CommandLine\"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_STLP_DEBUG"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ois_static_d.lib"
+				OutputFile="$(OutDir)/CommandLine.exe"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="..\..\lib;..\..\src\win32\extras\WiiMote\"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/CommandLine.pdb"
+				SubSystem="1"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="1"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				OmitFramePointers="TRUE"
+				AdditionalIncludeDirectories="..\..\includes;..\CommandLine\"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
+				StringPooling="TRUE"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="TRUE"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ois_static.lib"
+				OutputFile="$(OutDir)/CommandLine.exe"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="..\..\lib;..\..\src\win32\extras\WiiMote\"
+				GenerateDebugInformation="TRUE"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="CommandLine.rc">
+		</File>
+		<File
+			RelativePath="..\..\demos\OISConsole.cpp">
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/CommandLine/CommandLine_vc8.vcproj b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/CommandLine/CommandLine_vc8.vcproj
new file mode 100644
index 0000000..c6bcdce
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/CommandLine/CommandLine_vc8.vcproj
@@ -0,0 +1,367 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="Demo_Console"
+	ProjectGUID="{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="1"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\includes;..\CommandLine\"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_STLP_DEBUG"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ois_static_d.lib"
+				OutputFile="$(OutDir)/CommandLine.exe"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="..\..\lib;..\..\src\win32\extras\WiiMote"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile="$(OutDir)/CommandLine.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\includes;..\CommandLine\"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_STLP_DEBUG"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ois_d.lib"
+				OutputFile="$(OutDir)/CommandLine.exe"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="..\..\lib64"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile="$(OutDir)/CommandLine.pdb"
+				SubSystem="1"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="1"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				OmitFramePointers="true"
+				AdditionalIncludeDirectories="..\..\includes;..\CommandLine\"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
+				StringPooling="true"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ois_static.lib"
+				OutputFile="$(OutDir)/CommandLine.exe"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="..\..\lib;..\..\src\win32\extras\WiiMote"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				OmitFramePointers="true"
+				AdditionalIncludeDirectories="..\..\includes;..\CommandLine\"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
+				StringPooling="true"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ois.lib"
+				OutputFile="$(OutDir)/CommandLine.exe"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="..\..\lib64"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="CommandLine.rc"
+			>
+		</File>
+		<File
+			RelativePath="..\..\demos\OISConsole.cpp"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/CommandLine/CommandLine_vc9.vcproj b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/CommandLine/CommandLine_vc9.vcproj
new file mode 100644
index 0000000..f52f0a9
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/CommandLine/CommandLine_vc9.vcproj
@@ -0,0 +1,364 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="Demo_Console"
+	ProjectGUID="{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="1"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\includes;..\CommandLine\"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_STLP_DEBUG"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ois_static_d.lib xinput.lib"
+				OutputFile="$(OutDir)/CommandLine.exe"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="..\..\lib;..\..\src\win32\extras\WiiMote"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile="$(OutDir)/CommandLine.pdb"
+				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="1"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				OmitFramePointers="true"
+				AdditionalIncludeDirectories="..\..\includes;..\CommandLine\"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
+				StringPooling="true"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ois_static.lib xinput.lib"
+				OutputFile="$(OutDir)/CommandLine.exe"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="..\..\lib;..\..\src\win32\extras\WiiMote"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\includes;..\CommandLine\"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_STLP_DEBUG"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ois_d.lib"
+				OutputFile="$(OutDir)/CommandLine.exe"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="..\..\lib64"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile="$(OutDir)/CommandLine.pdb"
+				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				OmitFramePointers="true"
+				AdditionalIncludeDirectories="..\..\includes;..\CommandLine\"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
+				StringPooling="true"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ois.lib"
+				OutputFile="$(OutDir)/CommandLine.exe"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="..\..\lib64"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="CommandLine.rc"
+			>
+		</File>
+		<File
+			RelativePath="..\..\demos\OISConsole.cpp"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/CommandLine/CommandLine_vs2010.vcxproj b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/CommandLine/CommandLine_vs2010.vcxproj
new file mode 100644
index 0000000..d943e20
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/CommandLine/CommandLine_vs2010.vcxproj
@@ -0,0 +1,221 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectName>Demo_Console</ProjectName>
+    <ProjectGuid>{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Debug\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Debug\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Release\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Release\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Platform)\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Platform)\$(Configuration)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Platform)\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Platform)\$(Configuration)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>..\..\includes;..\CommandLine\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_STLP_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>ois_static_d.lib;xinput.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)CommandLine.exe</OutputFile>
+      <AdditionalLibraryDirectories>..\..\lib;..\..\src\win32\extras\WiiMote;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <ProgramDatabaseFile>$(OutDir)CommandLine.pdb</ProgramDatabaseFile>
+      <SubSystem>Console</SubSystem>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+    <PostBuildEvent>
+      <Command>
+      </Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <AdditionalIncludeDirectories>..\..\includes;..\CommandLine\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>ois_static.lib;xinput.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)CommandLine.exe</OutputFile>
+      <AdditionalLibraryDirectories>..\..\lib;..\..\src\win32\extras\WiiMote;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+    <PostBuildEvent>
+      <Command>
+      </Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Midl>
+      <TargetEnvironment>X64</TargetEnvironment>
+    </Midl>
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>..\..\includes;..\CommandLine\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_STLP_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>ois_d.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)CommandLine.exe</OutputFile>
+      <AdditionalLibraryDirectories>..\..\lib64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <ProgramDatabaseFile>$(OutDir)CommandLine.pdb</ProgramDatabaseFile>
+      <SubSystem>Console</SubSystem>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Link>
+    <PostBuildEvent>
+      <Command>
+      </Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Midl>
+      <TargetEnvironment>X64</TargetEnvironment>
+    </Midl>
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <AdditionalIncludeDirectories>..\..\includes;..\CommandLine\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>ois.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)CommandLine.exe</OutputFile>
+      <AdditionalLibraryDirectories>..\..\lib64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Link>
+    <PostBuildEvent>
+      <Command>
+      </Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ResourceCompile Include="CommandLine.rc" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\demos\OISConsole.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\OIS_vc9.vcxproj">
+      <Project>{9cc704cb-4956-4479-bdec-57cbc03f700e}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/CommandLine/resource.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/CommandLine/resource.h
new file mode 100644
index 0000000..9ab3414
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/CommandLine/resource.h
@@ -0,0 +1,17 @@
+//{{NO_DEPENDENCIES}}
+// Microsoft Visual C++ generated include file.
+// Used by CommandLine.rc
+//
+#define IDD_DIALOG1                     101
+#define IDC_BUTTON1                     1001
+
+// Next default values for new objects
+// 
+#ifdef APSTUDIO_INVOKED
+#ifndef APSTUDIO_READONLY_SYMBOLS
+#define _APS_NEXT_RESOURCE_VALUE        102
+#define _APS_NEXT_COMMAND_VALUE         40001
+#define _APS_NEXT_CONTROL_VALUE         1002
+#define _APS_NEXT_SYMED_VALUE           101
+#endif
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/DemoFFTest/DemoFFTest.cbp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/DemoFFTest/DemoFFTest.cbp
new file mode 100644
index 0000000..f951c8a
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/DemoFFTest/DemoFFTest.cbp
@@ -0,0 +1,78 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
+<CodeBlocks_project_file>
+	<FileVersion major="1" minor="6" />
+	<Project>
+		<Option title="Demo FFTest" />
+		<Option compiler="gcc" />
+		<Build>
+			<Target title="Debug">
+				<Option output=".\bin\Debug\DemoFFTest.exe" prefix_auto="0" extension_auto="0" />
+				<Option working_dir=".\bin\Debug" />
+				<Option object_output=".\obj\Debug" />
+				<Option external_deps="..\lib\libOIS_static_d.a;" />
+				<Option type="1" />
+				<Option compiler="gcc" />
+				<Option projectResourceIncludeDirsRelation="0" />
+				<Compiler>
+					<Add option="-g" />
+					<Add option="-O0" />
+					<Add option="-D_DEBUG" />
+				</Compiler>
+				<Linker>
+					<Add library="OIS_static_d" />
+					<Add library="dxguid" />
+					<Add library="dinput8" />
+				</Linker>
+			</Target>
+			<Target title="Release">
+				<Option output=".\bin\Release\DemoFFTest.exe" prefix_auto="0" extension_auto="0" />
+				<Option working_dir=".\bin\Release" />
+				<Option object_output=".\obj\Release" />
+				<Option external_deps="..\lib\libOIS_static.a;" />
+				<Option type="1" />
+				<Option compiler="gcc" />
+				<Option projectResourceIncludeDirsRelation="0" />
+				<Compiler>
+					<Add option="-O2" />
+					<Add option="-DNDEBUG" />
+				</Compiler>
+				<Linker>
+					<Add option="-s" />
+					<Add library="OIS_static" />
+					<Add library="dxguid" />
+					<Add library="dinput8" />
+				</Linker>
+			</Target>
+		</Build>
+		<VirtualTargets>
+			<Add alias="All" targets="Debug;Release;" />
+		</VirtualTargets>
+		<Compiler>
+			<Add option="-Wall" />
+			<Add option="-mthreads" />
+			<Add option="-fmessage-length=0" />
+			<Add option="-fexceptions" />
+			<Add option="-fident" />
+			<Add option="-pipe" />
+			<Add option="-DWIN32" />
+			<Add option="-D_CONSOLE" />
+			<Add directory="..\..\includes" />
+			<Add directory="..\DemoFFTest" />
+		</Compiler>
+		<Linker>
+			<Add option="-Wl,--enable-auto-image-base" />
+			<Add option="-Wl,--add-stdcall-alias" />
+			<Add directory="..\..\lib" />
+			<Add directory="..\..\dll" />
+		</Linker>
+		<Unit filename="FF.rc">
+			<Option compilerVar="WINDRES" />
+		</Unit>
+		<Unit filename="..\..\demos\FFConsoleDemo.cpp" />
+		<Extensions>
+			<code_completion />
+			<envvars />
+			<debugger />
+		</Extensions>
+	</Project>
+</CodeBlocks_project_file>
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/DemoFFTest/DemoFFTest.vcproj b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/DemoFFTest/DemoFFTest.vcproj
new file mode 100644
index 0000000..ad6b1a0
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/DemoFFTest/DemoFFTest.vcproj
@@ -0,0 +1,131 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="Demo_FFTest"
+	ProjectGUID="{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="1"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\includes;..\DemoFFTest"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_STLP_DEBUG"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ois_d.lib"
+				OutputFile="$(OutDir)/DemoFFTest.exe"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="..\..\dll"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/DemoFFTest.pdb"
+				SubSystem="1"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="1"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				OmitFramePointers="TRUE"
+				AdditionalIncludeDirectories="..\..\includes;..\DemoFFTest"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
+				StringPooling="TRUE"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="TRUE"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ois.lib"
+				OutputFile="$(OutDir)/DemoFFTest.exe"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="..\..\dll"
+				GenerateDebugInformation="TRUE"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="FF.rc">
+		</File>
+		<File
+			RelativePath="..\..\demos\FFConsoleDemo.cpp">
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/DemoFFTest/DemoFFTest_vc8.vcproj b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/DemoFFTest/DemoFFTest_vc8.vcproj
new file mode 100644
index 0000000..735d8c2
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/DemoFFTest/DemoFFTest_vc8.vcproj
@@ -0,0 +1,371 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="Demo_FFTest"
+	ProjectGUID="{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="1"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\includes;..\DemoFFTest"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_STLP_DEBUG"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ois_static_d.lib"
+				OutputFile="$(OutDir)/DemoFFTest.exe"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="..\..\lib;..\..\src\win32\extras\WiiMote"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile="$(OutDir)/DemoFFTest.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\includes;..\DemoFFTest"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_STLP_DEBUG"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ois_static_d.lib"
+				OutputFile="$(OutDir)/DemoFFTest.exe"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="..\..\lib64"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile="$(OutDir)/DemoFFTest.pdb"
+				SubSystem="1"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="1"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				OmitFramePointers="true"
+				AdditionalIncludeDirectories="..\..\includes;..\DemoFFTest"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
+				StringPooling="true"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ois_static.lib"
+				OutputFile="$(OutDir)/DemoFFTest.exe"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="..\..\lib;..\..\src\win32\extras\WiiMote"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				OmitFramePointers="true"
+				AdditionalIncludeDirectories="..\..\includes;..\DemoFFTest"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
+				StringPooling="true"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ois_static.lib"
+				OutputFile="$(OutDir)/DemoFFTest.exe"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="..\..\lib64"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="FF.rc"
+			>
+		</File>
+		<File
+			RelativePath="..\..\demos\FFConsoleDemo.cpp"
+			>
+		</File>
+		<File
+			RelativePath=".\resource.h"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/DemoFFTest/DemoFFTest_vc9.vcproj b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/DemoFFTest/DemoFFTest_vc9.vcproj
new file mode 100644
index 0000000..394e5fb
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/DemoFFTest/DemoFFTest_vc9.vcproj
@@ -0,0 +1,364 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="Demo_FFTest"
+	ProjectGUID="{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="1"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\includes;..\DemoFFTest"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_STLP_DEBUG"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ois_static_d.lib xinput.lib"
+				OutputFile="$(OutDir)/DemoFFTest.exe"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="..\..\lib;..\..\src\win32\extras\WiiMote"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile="$(OutDir)/DemoFFTest.pdb"
+				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="1"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				OmitFramePointers="true"
+				AdditionalIncludeDirectories="..\..\includes;..\DemoFFTest"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
+				StringPooling="true"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ois_static.lib  xinput.lib"
+				OutputFile="$(OutDir)/DemoFFTest.exe"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="..\..\lib;..\..\src\win32\extras\WiiMote"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\includes;..\DemoFFTest"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_STLP_DEBUG"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ois_d.lib"
+				OutputFile="$(OutDir)/DemoFFTest.exe"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="..\..\lib64"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile="$(OutDir)/DemoFFTest.pdb"
+				SubSystem="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				OmitFramePointers="true"
+				AdditionalIncludeDirectories="..\..\includes;..\DemoFFTest"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
+				StringPooling="true"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ois.lib"
+				OutputFile="$(OutDir)/DemoFFTest.exe"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="..\..\lib64"
+				GenerateDebugInformation="true"
+				SubSystem="1"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="FF.rc"
+			>
+		</File>
+		<File
+			RelativePath="..\..\demos\FFConsoleDemo.cpp"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/DemoFFTest/DemoFFTest_vs2010.vcxproj b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/DemoFFTest/DemoFFTest_vs2010.vcxproj
new file mode 100644
index 0000000..456653b
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/DemoFFTest/DemoFFTest_vs2010.vcxproj
@@ -0,0 +1,221 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectName>Demo_FFTest</ProjectName>
+    <ProjectGuid>{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Debug\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Debug\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Release\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Release\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Platform)\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Platform)\$(Configuration)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Platform)\$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Platform)\$(Configuration)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>..\..\includes;..\DemoFFTest;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_STLP_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>ois_static_d.lib;xinput.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)DemoFFTest.exe</OutputFile>
+      <AdditionalLibraryDirectories>..\..\lib;..\..\src\win32\extras\WiiMote;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <ProgramDatabaseFile>$(OutDir)DemoFFTest.pdb</ProgramDatabaseFile>
+      <SubSystem>Console</SubSystem>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+    <PostBuildEvent>
+      <Command>
+      </Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <AdditionalIncludeDirectories>..\..\includes;..\DemoFFTest;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>ois_static.lib;xinput.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)DemoFFTest.exe</OutputFile>
+      <AdditionalLibraryDirectories>..\..\lib;..\..\src\win32\extras\WiiMote;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+    <PostBuildEvent>
+      <Command>
+      </Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Midl>
+      <TargetEnvironment>X64</TargetEnvironment>
+    </Midl>
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>..\..\includes;..\DemoFFTest;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_STLP_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>ois_d.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)DemoFFTest.exe</OutputFile>
+      <AdditionalLibraryDirectories>..\..\lib64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <ProgramDatabaseFile>$(OutDir)DemoFFTest.pdb</ProgramDatabaseFile>
+      <SubSystem>Console</SubSystem>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Link>
+    <PostBuildEvent>
+      <Command>
+      </Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Midl>
+      <TargetEnvironment>X64</TargetEnvironment>
+    </Midl>
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <AdditionalIncludeDirectories>..\..\includes;..\DemoFFTest;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>ois.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)DemoFFTest.exe</OutputFile>
+      <AdditionalLibraryDirectories>..\..\lib64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Link>
+    <PostBuildEvent>
+      <Command>
+      </Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ResourceCompile Include="FF.rc" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\demos\FFConsoleDemo.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\OIS_vc9.vcxproj">
+      <Project>{9cc704cb-4956-4479-bdec-57cbc03f700e}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/DemoFFTest/FF.rc b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/DemoFFTest/FF.rc
new file mode 100644
index 0000000..72b4f9f
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/DemoFFTest/FF.rc
@@ -0,0 +1,99 @@
+// Microsoft Visual C++ generated resource script.
+//
+#include "resource.h"
+
+#define APSTUDIO_READONLY_SYMBOLS
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 2 resource.
+//
+//#include "afxres.h"
+#ifndef IDC_STATIC
+#define IDC_STATIC (-1)
+#endif
+#include "winresrc.h" 
+
+/////////////////////////////////////////////////////////////////////////////
+#undef APSTUDIO_READONLY_SYMBOLS
+
+/////////////////////////////////////////////////////////////////////////////
+// English (U.S.) resources
+
+#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
+#ifdef _WIN32
+LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
+#pragma code_page(1252)
+#endif //_WIN32
+
+#ifdef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// TEXTINCLUDE
+//
+
+1 TEXTINCLUDE 
+BEGIN
+    "resource.h\0"
+END
+
+2 TEXTINCLUDE 
+BEGIN
+    "#include ""afxres.h""\r\n"
+    "\0"
+END
+
+3 TEXTINCLUDE 
+BEGIN
+    "\r\n"
+    "\0"
+END
+
+#endif    // APSTUDIO_INVOKED
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Dialog
+//
+
+IDD_DIALOG1 DIALOGEX 0, 0, 100, 100
+STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION
+CAPTION "Capture Window"
+FONT 8, "MS Shell Dlg", 400, 0, 0x1
+BEGIN
+    LTEXT           "This window is used as Input Capture Window, and to display some info. Press Q or ESC to exit or hit button 1 of joystick",
+                    IDC_STATIC,7,7,82,86
+END
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// DESIGNINFO
+//
+
+#ifdef APSTUDIO_INVOKED
+GUIDELINES DESIGNINFO 
+BEGIN
+    IDD_DIALOG1, DIALOG
+    BEGIN
+        LEFTMARGIN, 7
+        TOPMARGIN, 7
+    END
+END
+#endif    // APSTUDIO_INVOKED
+
+#endif    // English (U.S.) resources
+/////////////////////////////////////////////////////////////////////////////
+
+
+
+#ifndef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 3 resource.
+//
+
+
+/////////////////////////////////////////////////////////////////////////////
+#endif    // not APSTUDIO_INVOKED
+
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/DemoFFTest/resource.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/DemoFFTest/resource.h
new file mode 100644
index 0000000..9ab3414
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/DemoFFTest/resource.h
@@ -0,0 +1,17 @@
+//{{NO_DEPENDENCIES}}
+// Microsoft Visual C++ generated include file.
+// Used by CommandLine.rc
+//
+#define IDD_DIALOG1                     101
+#define IDC_BUTTON1                     1001
+
+// Next default values for new objects
+// 
+#ifdef APSTUDIO_INVOKED
+#ifndef APSTUDIO_READONLY_SYMBOLS
+#define _APS_NEXT_RESOURCE_VALUE        102
+#define _APS_NEXT_COMMAND_VALUE         40001
+#define _APS_NEXT_CONTROL_VALUE         1002
+#define _APS_NEXT_SYMED_VALUE           101
+#endif
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS.rc b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS.rc
new file mode 100644
index 0000000..e2c96e2
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS.rc
@@ -0,0 +1,101 @@
+// Microsoft Visual C++ generated resource script.
+//
+#include "resource.h"
+
+#define APSTUDIO_READONLY_SYMBOLS
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 2 resource.
+//
+#include "afxres.h"
+
+/////////////////////////////////////////////////////////////////////////////
+#undef APSTUDIO_READONLY_SYMBOLS
+
+/////////////////////////////////////////////////////////////////////////////
+// English (U.S.) resources
+
+#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
+#ifdef _WIN32
+LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
+#pragma code_page(1252)
+#endif //_WIN32
+
+#ifdef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// TEXTINCLUDE
+//
+
+1 TEXTINCLUDE 
+BEGIN
+    "resource.h\0"
+END
+
+2 TEXTINCLUDE 
+BEGIN
+    "#include ""afxres.h""\r\n"
+    "\0"
+END
+
+3 TEXTINCLUDE 
+BEGIN
+    "\r\n"
+    "\0"
+END
+
+#endif    // APSTUDIO_INVOKED
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION 1,4,0,0
+ PRODUCTVERSION 1,4,0,0
+ FILEFLAGSMASK 0x17L
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS 0x4L
+ FILETYPE 0x2L
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040904b0"
+        BEGIN
+            VALUE "FileDescription", "OIS Library"
+            VALUE "FileVersion", "1.4.0.0"
+            VALUE "InternalName", "OIS"
+            VALUE "LegalCopyright", "Copyright (C) 2010"
+            VALUE "OriginalFilename", "OIS.dll"
+            VALUE "ProductName", "OIS Library"
+            VALUE "ProductVersion", "1.4.0.0"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x409, 1200
+    END
+END
+
+#endif    // English (U.S.) resources
+/////////////////////////////////////////////////////////////////////////////
+
+
+
+#ifndef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 3 resource.
+//
+
+
+/////////////////////////////////////////////////////////////////////////////
+#endif    // not APSTUDIO_INVOKED
+
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS.vcproj b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS.vcproj
new file mode 100644
index 0000000..c5d8b1e
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS.vcproj
@@ -0,0 +1,397 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="OIS"
+	ProjectGUID="{9CC704CB-4956-4479-BDEC-57CBC03F700E}"
+	RootNamespace="OIS"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="..\lib"
+			IntermediateDirectory="..\lib\obj\debug"
+			ConfigurationType="4"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\includes"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_STLP_DEBUG"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				RuntimeTypeInfo="TRUE"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderThrough="StdAfx.h"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"
+				CallingConvention="0"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib"
+				OutputFile="$(OutDir)/OIS_static_d.lib"
+				AdditionalLibraryDirectories="..\src\win32\extras\WiiMote\"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="..\lib"
+			IntermediateDirectory="..\lib\obj\release"
+			ConfigurationType="4"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				OmitFramePointers="TRUE"
+				AdditionalIncludeDirectories="..\includes"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
+				StringPooling="TRUE"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="TRUE"
+				RuntimeTypeInfo="TRUE"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile="$(IntDir)/$(TargetName).pch"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib"
+				OutputFile="$(OutDir)/OIS_static.lib"
+				AdditionalLibraryDirectories="..\src\win32\extras\WiiMote\"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="OIS_ReleaseDll|Win32"
+			OutputDirectory="..\dll"
+			IntermediateDirectory="..\dll\release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				OmitFramePointers="TRUE"
+				AdditionalIncludeDirectories="..\includes"
+				PreprocessorDefinitions="WIN32;NDEBUG;OIS_NONCLIENT_BUILD;OIS_DYNAMIC_LIB"
+				StringPooling="TRUE"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="TRUE"
+				RuntimeTypeInfo="TRUE"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile="$(IntDir)/$(TargetName).pch"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib"
+				AdditionalLibraryDirectories="..\src\win32\extras\WiiMote\"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="OIS_DebugDll|Win32"
+			OutputDirectory="..\dll"
+			IntermediateDirectory="..\dll\debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\includes"
+				PreprocessorDefinitions="WIN32;_DEBUG;_STLP_DEBUG;OIS_NONCLIENT_BUILD;OIS_DYNAMIC_LIB"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				RuntimeTypeInfo="TRUE"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderThrough="StdAfx.h"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"
+				CallingConvention="0"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib"
+				OutputFile="$(OutDir)/OIS_d.dll"
+				AdditionalLibraryDirectories="..\src\win32\extras\WiiMote\"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm">
+			<File
+				RelativePath="..\src\OISEffect.cpp">
+			</File>
+			<File
+				RelativePath="..\src\OISException.cpp">
+			</File>
+			<File
+				RelativePath="..\src\OISForceFeedback.cpp">
+			</File>
+			<File
+				RelativePath="..\src\OISInputManager.cpp">
+			</File>
+			<File
+				RelativePath="..\src\OISJoyStick.cpp">
+			</File>
+			<File
+				RelativePath="..\src\OISKeyboard.cpp">
+			</File>
+			<File
+				RelativePath="..\src\OISObject.cpp">
+			</File>
+			<Filter
+				Name="Win32"
+				Filter="">
+				<File
+					RelativePath="..\src\win32\Win32ForceFeedback.cpp">
+				</File>
+				<File
+					RelativePath="..\src\win32\Win32InputManager.cpp">
+				</File>
+				<File
+					RelativePath="..\src\win32\Win32JoyStick.cpp">
+				</File>
+				<File
+					RelativePath="..\src\win32\Win32KeyBoard.cpp">
+				</File>
+				<File
+					RelativePath="..\src\win32\Win32Mouse.cpp">
+				</File>
+			</Filter>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc">
+			<File
+				RelativePath="..\includes\OIS.h">
+			</File>
+			<File
+				RelativePath="..\includes\OISConfig.h">
+			</File>
+			<File
+				RelativePath="..\includes\OISEvents.h">
+			</File>
+			<File
+				RelativePath="..\includes\OISException.h">
+			</File>
+			<File
+				RelativePath="..\includes\OISFactoryCreator.h">
+			</File>
+			<File
+				RelativePath="..\includes\OISInputManager.h">
+			</File>
+			<File
+				RelativePath="..\includes\OISJoystick.h">
+			</File>
+			<File
+				RelativePath="..\includes\OISKeyboard.h">
+			</File>
+			<File
+				RelativePath="..\includes\OISMouse.h">
+			</File>
+			<File
+				RelativePath="..\includes\OISObject.h">
+			</File>
+			<File
+				RelativePath="..\includes\OISPrereqs.h">
+			</File>
+			<Filter
+				Name="Win32"
+				Filter="">
+				<File
+					RelativePath="..\includes\win32\Win32ForceFeedback.h">
+				</File>
+				<File
+					RelativePath="..\includes\win32\Win32InputManager.h">
+				</File>
+				<File
+					RelativePath="..\includes\win32\Win32JoyStick.h">
+				</File>
+				<File
+					RelativePath="..\includes\win32\Win32KeyBoard.h">
+				</File>
+				<File
+					RelativePath="..\includes\win32\Win32Mouse.h">
+				</File>
+				<File
+					RelativePath="..\includes\win32\Win32Prereqs.h">
+				</File>
+			</Filter>
+			<Filter
+				Name="Interface"
+				Filter="">
+				<File
+					RelativePath="..\includes\OISEffect.h">
+				</File>
+				<File
+					RelativePath="..\includes\OISForceFeedback.h">
+				</File>
+				<File
+					RelativePath="..\includes\OISInterface.h">
+				</File>
+			</Filter>
+		</Filter>
+		<Filter
+			Name="extras"
+			Filter="">
+			<Filter
+				Name="WiiMote"
+				Filter="">
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\hiddevice.cpp">
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\hiddevice.h">
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMote.cpp">
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMote.h">
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMoteFactoryCreator.cpp">
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMoteFactoryCreator.h">
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMoteForceFeedback.cpp">
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMoteForceFeedback.h">
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMoteRingBuffer.cpp">
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMoteRingBuffer.h">
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\wiimote.cpp">
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\wiimote.h">
+				</File>
+			</Filter>
+			<Filter
+				Name="XInput"
+				Filter="">
+			</Filter>
+			<Filter
+				Name="LIRC"
+				Filter="">
+				<File
+					RelativePath="..\src\extras\Lirc\OISLIRC.cpp">
+				</File>
+				<File
+					RelativePath="..\src\extras\Lirc\OISLIRC.h">
+				</File>
+				<File
+					RelativePath="..\src\extras\Lirc\OISLIRCFactoryCreator.cpp">
+				</File>
+				<File
+					RelativePath="..\src\extras\Lirc\OISLIRCFactoryCreator.h">
+				</File>
+				<File
+					RelativePath="..\src\extras\Lirc\OISLIRCRingBuffer.h">
+				</File>
+			</Filter>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS.workspace b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS.workspace
new file mode 100644
index 0000000..6c4756e
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS.workspace
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
+<CodeBlocks_workspace_file>
+	<Workspace title="ois workspace">
+		<Project filename="ois.cbp" active="1" />
+		<Project filename="DemoFFTest\DemoFFTest.cbp">
+			<Depends filename="ois.cbp" />
+		</Project>
+		<Project filename="CommandLine\CommandLine.cbp">
+			<Depends filename="ois.cbp" />
+		</Project>
+	</Workspace>
+</CodeBlocks_workspace_file>
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS_vc8.vcproj b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS_vc8.vcproj
new file mode 100644
index 0000000..ae5f39c
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS_vc8.vcproj
@@ -0,0 +1,887 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="OIS"
+	ProjectGUID="{9CC704CB-4956-4479-BDEC-57CBC03F700E}"
+	RootNamespace="OIS"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="..\lib"
+			IntermediateDirectory="..\lib\obj\debug"
+			ConfigurationType="4"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\includes; ..\src"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_STLP_DEBUG"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderThrough="StdAfx.h"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+				CallingConvention="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib xinput.lib"
+				OutputFile="$(OutDir)/OIS_static_d.lib"
+				AdditionalLibraryDirectories="..\src\win32\extras\WiiMote"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="..\lib64\"
+			IntermediateDirectory="..\lib64\obj\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\includes"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_STLP_DEBUG"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderThrough="StdAfx.h"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+				CallingConvention="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib xinput.lib"
+				OutputFile="$(OutDir)/OIS_d.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="..\lib"
+			IntermediateDirectory="..\lib\obj\release"
+			ConfigurationType="4"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				OmitFramePointers="true"
+				AdditionalIncludeDirectories="..\includes; ..\src"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
+				StringPooling="true"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="false"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile="$(IntDir)/$(TargetName).pch"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib xinput.lib"
+				OutputFile="$(OutDir)/OIS_static.lib"
+				AdditionalLibraryDirectories="..\src\win32\extras\WiiMote"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="..\lib64\"
+			IntermediateDirectory="..\lib64\obj\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="2"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				FavorSizeOrSpeed="1"
+				OmitFramePointers="true"
+				EnableFiberSafeOptimizations="true"
+				WholeProgramOptimization="true"
+				AdditionalIncludeDirectories="..\includes"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
+				StringPooling="true"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="true"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile="$(IntDir)/$(TargetName).pch"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib xinput.lib"
+				OutputFile="$(OutDir)/OIS.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="OIS_ReleaseDll|Win32"
+			OutputDirectory="..\dll"
+			IntermediateDirectory="..\dll\release"
+			ConfigurationType="2"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				OmitFramePointers="true"
+				AdditionalIncludeDirectories="..\includes; ..\src"
+				PreprocessorDefinitions="WIN32;NDEBUG;OIS_NONCLIENT_BUILD;OIS_DYNAMIC_LIB"
+				StringPooling="true"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="false"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile="$(IntDir)/$(TargetName).pch"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib xinput.lib"
+				AdditionalLibraryDirectories="..\src\win32\extras\WiiMote\"
+				GenerateDebugInformation="false"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				OptimizeForWindows98="1"
+				LinkTimeCodeGeneration="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="OIS_ReleaseDll|x64"
+			OutputDirectory="..\dll64"
+			IntermediateDirectory="..\dll64\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="2"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				FavorSizeOrSpeed="1"
+				OmitFramePointers="true"
+				EnableFiberSafeOptimizations="true"
+				WholeProgramOptimization="true"
+				AdditionalIncludeDirectories="..\includes"
+				PreprocessorDefinitions="WIN32;NDEBUG;OIS_NONCLIENT_BUILD;OIS_DYNAMIC_LIB"
+				StringPooling="true"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="true"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile="$(IntDir)/$(TargetName).pch"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib xinput.lib"
+				GenerateDebugInformation="true"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="OIS_DebugDll|Win32"
+			OutputDirectory="..\dll"
+			IntermediateDirectory="..\dll\debug"
+			ConfigurationType="2"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\includes; ..\src"
+				PreprocessorDefinitions="WIN32;_DEBUG;_STLP_DEBUG;OIS_NONCLIENT_BUILD;OIS_DYNAMIC_LIB"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderThrough="StdAfx.h"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+				CallingConvention="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib xinput.lib"
+				OutputFile="$(OutDir)/OIS_d.dll"
+				AdditionalLibraryDirectories="..\src\win32\extras\WiiMote\"
+				GenerateDebugInformation="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="OIS_DebugDll|x64"
+			OutputDirectory="..\dll64"
+			IntermediateDirectory="..\dll64\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\includes"
+				PreprocessorDefinitions="WIN32;_DEBUG;_STLP_DEBUG;OIS_NONCLIENT_BUILD;OIS_DYNAMIC_LIB"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderThrough="StdAfx.h"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+				CallingConvention="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib xinput.lib"
+				OutputFile="$(OutDir)/OIS_d.dll"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm"
+			>
+			<File
+				RelativePath="..\src\OISEffect.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\src\OISException.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\src\OISForceFeedback.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\src\OISInputManager.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\src\OISJoyStick.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\src\OISKeyboard.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\src\OISObject.cpp"
+				>
+			</File>
+			<Filter
+				Name="Win32"
+				>
+				<File
+					RelativePath="..\src\win32\Win32ForceFeedback.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\Win32InputManager.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\Win32JoyStick.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\Win32KeyBoard.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\Win32Mouse.cpp"
+					>
+				</File>
+			</Filter>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc"
+			>
+			<File
+				RelativePath="..\includes\OIS.h"
+				>
+			</File>
+			<File
+				RelativePath="..\includes\OISConfig.h"
+				>
+			</File>
+			<File
+				RelativePath="..\includes\OISEvents.h"
+				>
+			</File>
+			<File
+				RelativePath="..\includes\OISException.h"
+				>
+			</File>
+			<File
+				RelativePath="..\includes\OISFactoryCreator.h"
+				>
+			</File>
+			<File
+				RelativePath="..\includes\OISInputManager.h"
+				>
+			</File>
+			<File
+				RelativePath="..\includes\OISJoystick.h"
+				>
+			</File>
+			<File
+				RelativePath="..\includes\OISKeyboard.h"
+				>
+			</File>
+			<File
+				RelativePath="..\includes\OISMouse.h"
+				>
+			</File>
+			<File
+				RelativePath="..\includes\OISObject.h"
+				>
+			</File>
+			<File
+				RelativePath="..\includes\OISPrereqs.h"
+				>
+			</File>
+			<Filter
+				Name="Win32"
+				>
+				<File
+					RelativePath="..\includes\win32\Win32ForceFeedback.h"
+					>
+				</File>
+				<File
+					RelativePath="..\includes\win32\Win32InputManager.h"
+					>
+				</File>
+				<File
+					RelativePath="..\includes\win32\Win32JoyStick.h"
+					>
+				</File>
+				<File
+					RelativePath="..\includes\win32\Win32KeyBoard.h"
+					>
+				</File>
+				<File
+					RelativePath="..\includes\win32\Win32Mouse.h"
+					>
+				</File>
+				<File
+					RelativePath="..\includes\win32\Win32Prereqs.h"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="Interface"
+				>
+				<File
+					RelativePath="..\includes\OISEffect.h"
+					>
+				</File>
+				<File
+					RelativePath="..\includes\OISForceFeedback.h"
+					>
+				</File>
+				<File
+					RelativePath="..\includes\OISInterface.h"
+					>
+				</File>
+			</Filter>
+		</Filter>
+		<Filter
+			Name="Extras"
+			>
+			<Filter
+				Name="WiiMote"
+				>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\hiddevice.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\hiddevice.h"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMote.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMote.h"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMoteFactoryCreator.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMoteFactoryCreator.h"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMoteForceFeedback.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMoteForceFeedback.h"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMoteRingBuffer.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMoteRingBuffer.h"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\wiimote.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\wiimote.h"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="LIRC"
+				>
+				<File
+					RelativePath="..\src\extras\LIRC\OISLIRC.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\extras\LIRC\OISLIRC.h"
+					>
+				</File>
+				<File
+					RelativePath="..\src\extras\LIRC\OISLIRCFactoryCreator.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\extras\LIRC\OISLIRCFactoryCreator.h"
+					>
+				</File>
+				<File
+					RelativePath="..\src\extras\LIRC\OISLIRCRingBuffer.h"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="XInput"
+				>
+			</Filter>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS_vc9.vcproj b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS_vc9.vcproj
new file mode 100644
index 0000000..e05d65c
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS_vc9.vcproj
@@ -0,0 +1,916 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="OIS"
+	ProjectGUID="{9CC704CB-4956-4479-BDEC-57CBC03F700E}"
+	RootNamespace="OIS"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="..\lib"
+			IntermediateDirectory="..\lib\obj\debug"
+			ConfigurationType="4"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\includes; ..\src"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_STLP_DEBUG"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderThrough="StdAfx.h"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+				CallingConvention="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib"
+				OutputFile="$(OutDir)/OIS_static_d.lib"
+				AdditionalLibraryDirectories="..\src\win32\extras\WiiMote"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="..\lib"
+			IntermediateDirectory="..\lib\obj\release"
+			ConfigurationType="4"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				OmitFramePointers="true"
+				AdditionalIncludeDirectories="..\includes; ..\src"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
+				StringPooling="true"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="false"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile="$(IntDir)/$(TargetName).pch"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib"
+				OutputFile="$(OutDir)/OIS_static.lib"
+				AdditionalLibraryDirectories="..\src\win32\extras\WiiMote"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="OIS_ReleaseDll|Win32"
+			OutputDirectory="..\dll"
+			IntermediateDirectory="..\dll\release"
+			ConfigurationType="2"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				OmitFramePointers="true"
+				AdditionalIncludeDirectories="..\includes; ..\src"
+				PreprocessorDefinitions="WIN32;NDEBUG;OIS_NONCLIENT_BUILD;OIS_DYNAMIC_LIB"
+				StringPooling="true"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="false"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile="$(IntDir)/$(TargetName).pch"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib"
+				AdditionalLibraryDirectories="..\src\win32\extras\WiiMote\"
+				GenerateDebugInformation="false"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				OptimizeForWindows98="1"
+				LinkTimeCodeGeneration="1"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="OIS_DebugDll|Win32"
+			OutputDirectory="..\dll"
+			IntermediateDirectory="..\dll\debug"
+			ConfigurationType="2"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\includes; ..\src"
+				PreprocessorDefinitions="WIN32;_DEBUG;_STLP_DEBUG;OIS_NONCLIENT_BUILD;OIS_DYNAMIC_LIB"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderThrough="StdAfx.h"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+				CallingConvention="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib"
+				OutputFile="$(OutDir)/OIS_d.dll"
+				AdditionalLibraryDirectories="..\src\win32\extras\WiiMote\"
+				GenerateDebugInformation="true"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="..\lib64\"
+			IntermediateDirectory="..\lib64\obj\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\includes"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_STLP_DEBUG"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderThrough="StdAfx.h"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+				CallingConvention="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib xinput.lib"
+				OutputFile="$(OutDir)/OIS_d.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="..\lib64\"
+			IntermediateDirectory="..\lib64\obj\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="2"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				FavorSizeOrSpeed="1"
+				OmitFramePointers="true"
+				EnableFiberSafeOptimizations="true"
+				WholeProgramOptimization="true"
+				AdditionalIncludeDirectories="..\includes"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
+				StringPooling="true"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="true"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile="$(IntDir)/$(TargetName).pch"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib xinput.lib"
+				OutputFile="$(OutDir)/OIS.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="OIS_ReleaseDll|x64"
+			OutputDirectory="..\dll64"
+			IntermediateDirectory="..\dll64\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="2"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				FavorSizeOrSpeed="1"
+				OmitFramePointers="true"
+				EnableFiberSafeOptimizations="true"
+				WholeProgramOptimization="true"
+				AdditionalIncludeDirectories="..\includes"
+				PreprocessorDefinitions="WIN32;NDEBUG;OIS_NONCLIENT_BUILD;OIS_DYNAMIC_LIB"
+				StringPooling="true"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="true"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile="$(IntDir)/$(TargetName).pch"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib xinput.lib"
+				GenerateDebugInformation="true"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="OIS_DebugDll|x64"
+			OutputDirectory="..\dll64"
+			IntermediateDirectory="..\dll64\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\includes"
+				PreprocessorDefinitions="WIN32;_DEBUG;_STLP_DEBUG;OIS_NONCLIENT_BUILD;OIS_DYNAMIC_LIB"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderThrough="StdAfx.h"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+				CallingConvention="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib xinput.lib"
+				OutputFile="$(OutDir)/OIS_d.dll"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm"
+			>
+			<File
+				RelativePath="..\src\OISEffect.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\src\OISException.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\src\OISForceFeedback.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\src\OISInputManager.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\src\OISJoyStick.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\src\OISKeyboard.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\src\OISObject.cpp"
+				>
+			</File>
+			<Filter
+				Name="Win32"
+				>
+				<File
+					RelativePath="..\src\win32\Win32ForceFeedback.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\Win32InputManager.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\Win32JoyStick.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\Win32KeyBoard.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\Win32Mouse.cpp"
+					>
+				</File>
+			</Filter>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc"
+			>
+			<File
+				RelativePath="..\includes\OIS.h"
+				>
+			</File>
+			<File
+				RelativePath="..\includes\OISConfig.h"
+				>
+			</File>
+			<File
+				RelativePath="..\includes\OISEvents.h"
+				>
+			</File>
+			<File
+				RelativePath="..\includes\OISException.h"
+				>
+			</File>
+			<File
+				RelativePath="..\includes\OISFactoryCreator.h"
+				>
+			</File>
+			<File
+				RelativePath="..\includes\OISInputManager.h"
+				>
+			</File>
+			<File
+				RelativePath="..\includes\OISJoystick.h"
+				>
+			</File>
+			<File
+				RelativePath="..\includes\OISKeyboard.h"
+				>
+			</File>
+			<File
+				RelativePath="..\includes\OISMouse.h"
+				>
+			</File>
+			<File
+				RelativePath="..\includes\OISObject.h"
+				>
+			</File>
+			<File
+				RelativePath="..\includes\OISPrereqs.h"
+				>
+			</File>
+			<Filter
+				Name="Win32"
+				>
+				<File
+					RelativePath="..\includes\win32\Win32ForceFeedback.h"
+					>
+				</File>
+				<File
+					RelativePath="..\includes\win32\Win32InputManager.h"
+					>
+				</File>
+				<File
+					RelativePath="..\includes\win32\Win32JoyStick.h"
+					>
+				</File>
+				<File
+					RelativePath="..\includes\win32\Win32KeyBoard.h"
+					>
+				</File>
+				<File
+					RelativePath="..\includes\win32\Win32Mouse.h"
+					>
+				</File>
+				<File
+					RelativePath="..\includes\win32\Win32Prereqs.h"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="Interface"
+				>
+				<File
+					RelativePath="..\includes\OISEffect.h"
+					>
+				</File>
+				<File
+					RelativePath="..\includes\OISForceFeedback.h"
+					>
+				</File>
+				<File
+					RelativePath="..\includes\OISInterface.h"
+					>
+				</File>
+			</Filter>
+		</Filter>
+		<Filter
+			Name="Extras"
+			>
+			<Filter
+				Name="WiiMote"
+				>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\hiddevice.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\hiddevice.h"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMote.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMote.h"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMoteFactoryCreator.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMoteFactoryCreator.h"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMoteForceFeedback.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMoteForceFeedback.h"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMoteRingBuffer.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\OISWiiMoteRingBuffer.h"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\wiimote.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\win32\extras\WiiMote\wiimote.h"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="LIRC"
+				>
+				<File
+					RelativePath="..\src\extras\LIRC\OISLIRC.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\extras\LIRC\OISLIRC.h"
+					>
+				</File>
+				<File
+					RelativePath="..\src\extras\LIRC\OISLIRCFactoryCreator.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\src\extras\LIRC\OISLIRCFactoryCreator.h"
+					>
+				</File>
+				<File
+					RelativePath="..\src\extras\LIRC\OISLIRCRingBuffer.h"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="XInput"
+				>
+			</Filter>
+		</Filter>
+		<File
+			RelativePath=".\OIS.rc"
+			>
+			<FileConfiguration
+				Name="Debug|Win32"
+				ExcludedFromBuild="true"
+				>
+				<Tool
+					Name="VCResourceCompilerTool"
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Release|Win32"
+				ExcludedFromBuild="true"
+				>
+				<Tool
+					Name="VCResourceCompilerTool"
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="OIS_DebugDll|Win32"
+				ExcludedFromBuild="true"
+				>
+				<Tool
+					Name="VCResourceCompilerTool"
+				/>
+			</FileConfiguration>
+		</File>
+		<File
+			RelativePath=".\resource.h"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS_vs2010.sln b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS_vs2010.sln
new file mode 100644
index 0000000..884cc8c
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS_vs2010.sln
@@ -0,0 +1,45 @@
+Microsoft Visual Studio Solution File, Format Version 11.00
+# Visual Studio 2010
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "OIS", "OIS_vs2010.vcxproj", "{9CC704CB-4956-4479-BDEC-57CBC03F700E}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Demo_Console", "CommandLine\CommandLine_vs2010.vcxproj", "{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Demo_FFTest", "DemoFFTest\DemoFFTest_vs2010.vcxproj", "{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Debug|x64 = Debug|x64
+		Release|Win32 = Release|Win32
+		Release|x64 = Release|x64
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Debug|Win32.ActiveCfg = Debug|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Debug|Win32.Build.0 = Debug|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Debug|x64.ActiveCfg = Debug|x64
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Debug|x64.Build.0 = Debug|x64
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Release|Win32.ActiveCfg = Release|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Release|Win32.Build.0 = Release|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Release|x64.ActiveCfg = Release|x64
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Release|x64.Build.0 = Release|x64
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Debug|Win32.ActiveCfg = Debug|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Debug|Win32.Build.0 = Debug|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Debug|x64.ActiveCfg = Debug|x64
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Debug|x64.Build.0 = Debug|x64
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Release|Win32.ActiveCfg = Release|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Release|Win32.Build.0 = Release|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Release|x64.ActiveCfg = Release|x64
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Release|x64.Build.0 = Release|x64
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Debug|Win32.ActiveCfg = Debug|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Debug|Win32.Build.0 = Debug|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Debug|x64.ActiveCfg = Debug|x64
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Debug|x64.Build.0 = Debug|x64
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Release|Win32.ActiveCfg = Release|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Release|Win32.Build.0 = Release|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Release|x64.ActiveCfg = Release|x64
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Release|x64.Build.0 = Release|x64
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS_vs2010.vcxproj b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS_vs2010.vcxproj
new file mode 100644
index 0000000..c94f5fd
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS_vs2010.vcxproj
@@ -0,0 +1,461 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="OIS_DebugDll|Win32">
+      <Configuration>OIS_DebugDll</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="OIS_DebugDll|x64">
+      <Configuration>OIS_DebugDll</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="OIS_ReleaseDll|Win32">
+      <Configuration>OIS_ReleaseDll</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="OIS_ReleaseDll|x64">
+      <Configuration>OIS_ReleaseDll</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectName>OIS</ProjectName>
+    <ProjectGuid>{9CC704CB-4956-4479-BDEC-57CBC03F700E}</ProjectGuid>
+    <RootNamespace>OIS</RootNamespace>
+    <Keyword>Win32Proj</Keyword>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OIS_DebugDll|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OIS_ReleaseDll|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OIS_DebugDll|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='OIS_ReleaseDll|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OIS_DebugDll|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OIS_ReleaseDll|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OIS_DebugDll|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='OIS_ReleaseDll|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\lib\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\lib\obj\debug\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\lib\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\lib\obj\release\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='OIS_ReleaseDll|Win32'">..\dll\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='OIS_ReleaseDll|Win32'">..\dll\release\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='OIS_DebugDll|Win32'">..\dll\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='OIS_DebugDll|Win32'">..\dll\debug\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">..\lib64\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">..\lib64\obj\$(Configuration)\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">..\lib64\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">..\lib64\obj\$(Configuration)\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='OIS_ReleaseDll|x64'">..\dll64\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='OIS_ReleaseDll|x64'">..\dll64\$(Configuration)\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='OIS_DebugDll|x64'">..\dll64\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='OIS_DebugDll|x64'">..\dll64\$(Configuration)\</IntDir>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(DXSDK_DIR)\include;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(DXSDK_DIR)\lib\$(PlatformName);$(DXSDK_DIR)\lib\$(PlatformShortName);$(LibraryPath)</LibraryPath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='OIS_DebugDll|Win32'">$(DXSDK_DIR)\include;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='OIS_DebugDll|Win32'">$(DXSDK_DIR)\lib\$(PlatformName);$(DXSDK_DIR)\lib\$(PlatformShortName);$(LibraryPath)</LibraryPath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='OIS_ReleaseDll|Win32'">$(DXSDK_DIR)\include;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='OIS_ReleaseDll|Win32'">$(DXSDK_DIR)\lib\$(PlatformName);$(DXSDK_DIR)\lib\$(PlatformShortName);$(LibraryPath)</LibraryPath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(DXSDK_DIR)\include;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(DXSDK_DIR)\lib\$(PlatformName);$(DXSDK_DIR)\lib\$(PlatformShortName);$(LibraryPath)</LibraryPath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(DXSDK_DIR)\include;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(DXSDK_DIR)\lib\$(PlatformName);$(DXSDK_DIR)\lib\$(PlatformShortName);$(LibraryPath)</LibraryPath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='OIS_DebugDll|x64'">$(DXSDK_DIR)\include;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='OIS_DebugDll|x64'">$(DXSDK_DIR)\lib\$(PlatformName);$(DXSDK_DIR)\lib\$(PlatformShortName);$(LibraryPath)</LibraryPath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='OIS_ReleaseDll|x64'">$(DXSDK_DIR)\include;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='OIS_ReleaseDll|x64'">$(DXSDK_DIR)\lib\$(PlatformName);$(DXSDK_DIR)\lib\$(PlatformShortName);$(LibraryPath)</LibraryPath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(DXSDK_DIR)\include;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(DXSDK_DIR)\lib\$(PlatformName);$(DXSDK_DIR)\lib\$(PlatformShortName);$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>..\includes; ..\src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;_STLP_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <FloatingPointModel>Fast</FloatingPointModel>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <PrecompiledHeaderFile>StdAfx.h</PrecompiledHeaderFile>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CallingConvention>Cdecl</CallingConvention>
+    </ClCompile>
+    <Lib>
+      <AdditionalDependencies>dxguid.lib;dinput8.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)OIS_static_d.lib</OutputFile>
+      <AdditionalLibraryDirectories>..\src\win32\extras\WiiMote;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+    </Lib>
+    <PostBuildEvent>
+      <Command>
+      </Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <AdditionalIncludeDirectories>..\includes; ..\src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <FloatingPointModel>Fast</FloatingPointModel>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Lib>
+      <AdditionalDependencies>dxguid.lib;dinput8.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)OIS_static.lib</OutputFile>
+      <AdditionalLibraryDirectories>..\src\win32\extras\WiiMote;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+    </Lib>
+    <PostBuildEvent>
+      <Command>
+      </Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OIS_ReleaseDll|Win32'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <AdditionalIncludeDirectories>..\includes; ..\src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;OIS_NONCLIENT_BUILD;OIS_DYNAMIC_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <FloatingPointModel>Fast</FloatingPointModel>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>dxguid.lib;dinput8.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>..\src\win32\extras\WiiMote\;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+    </Link>
+    <PostBuildEvent>
+      <Command>
+      </Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OIS_DebugDll|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>..\includes; ..\src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_STLP_DEBUG;OIS_NONCLIENT_BUILD;OIS_DYNAMIC_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <FloatingPointModel>Fast</FloatingPointModel>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <PrecompiledHeaderFile>StdAfx.h</PrecompiledHeaderFile>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CallingConvention>Cdecl</CallingConvention>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>dxguid.lib;dinput8.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)OIS_d.dll</OutputFile>
+      <AdditionalLibraryDirectories>..\src\win32\extras\WiiMote\;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+    </Link>
+    <PostBuildEvent>
+      <Command>
+      </Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Midl>
+      <TargetEnvironment>X64</TargetEnvironment>
+    </Midl>
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>..\includes;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;_STLP_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <FloatingPointModel>Fast</FloatingPointModel>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <PrecompiledHeaderFile>StdAfx.h</PrecompiledHeaderFile>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CallingConvention>Cdecl</CallingConvention>
+    </ClCompile>
+    <Lib>
+      <AdditionalDependencies>dxguid.lib;dinput8.lib;xinput.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)OIS_d.lib</OutputFile>
+      <AdditionalOptions>/MACHINE:x64 %(AdditionalOptions)</AdditionalOptions>
+    </Lib>
+    <PostBuildEvent>
+      <Command>
+      </Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Midl>
+      <TargetEnvironment>X64</TargetEnvironment>
+    </Midl>
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>true</OmitFramePointers>
+      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <AdditionalIncludeDirectories>..\includes;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <FloatingPointModel>Fast</FloatingPointModel>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Lib>
+      <AdditionalDependencies>dxguid.lib;dinput8.lib;xinput.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)OIS.lib</OutputFile>
+      <AdditionalOptions>/MACHINE:x64 %(AdditionalOptions)</AdditionalOptions>
+    </Lib>
+    <PostBuildEvent>
+      <Command>
+      </Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OIS_ReleaseDll|x64'">
+    <Midl>
+      <TargetEnvironment>X64</TargetEnvironment>
+    </Midl>
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>true</OmitFramePointers>
+      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <AdditionalIncludeDirectories>..\includes;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;OIS_NONCLIENT_BUILD;OIS_DYNAMIC_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <FloatingPointModel>Fast</FloatingPointModel>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>dxguid.lib;dinput8.lib;xinput.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Link>
+    <PostBuildEvent>
+      <Command>
+      </Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='OIS_DebugDll|x64'">
+    <Midl>
+      <TargetEnvironment>X64</TargetEnvironment>
+    </Midl>
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>..\includes;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_STLP_DEBUG;OIS_NONCLIENT_BUILD;OIS_DYNAMIC_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <FloatingPointModel>Fast</FloatingPointModel>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <PrecompiledHeaderFile>StdAfx.h</PrecompiledHeaderFile>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CallingConvention>Cdecl</CallingConvention>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>dxguid.lib;dinput8.lib;xinput.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)OIS_d.dll</OutputFile>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Link>
+    <PostBuildEvent>
+      <Command>
+      </Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\src\OISEffect.cpp" />
+    <ClCompile Include="..\src\OISException.cpp" />
+    <ClCompile Include="..\src\OISForceFeedback.cpp" />
+    <ClCompile Include="..\src\OISInputManager.cpp" />
+    <ClCompile Include="..\src\OISJoyStick.cpp" />
+    <ClCompile Include="..\src\OISKeyboard.cpp" />
+    <ClCompile Include="..\src\OISObject.cpp" />
+    <ClCompile Include="..\src\win32\Win32ForceFeedback.cpp" />
+    <ClCompile Include="..\src\win32\Win32InputManager.cpp" />
+    <ClCompile Include="..\src\win32\Win32JoyStick.cpp" />
+    <ClCompile Include="..\src\win32\Win32KeyBoard.cpp" />
+    <ClCompile Include="..\src\win32\Win32Mouse.cpp" />
+    <ClCompile Include="..\src\win32\extras\WiiMote\hiddevice.cpp" />
+    <ClCompile Include="..\src\win32\extras\WiiMote\OISWiiMote.cpp" />
+    <ClCompile Include="..\src\win32\extras\WiiMote\OISWiiMoteFactoryCreator.cpp" />
+    <ClCompile Include="..\src\win32\extras\WiiMote\OISWiiMoteForceFeedback.cpp" />
+    <ClCompile Include="..\src\win32\extras\WiiMote\OISWiiMoteRingBuffer.cpp" />
+    <ClCompile Include="..\src\win32\extras\WiiMote\wiimote.cpp" />
+    <ClCompile Include="..\src\extras\LIRC\OISLIRC.cpp" />
+    <ClCompile Include="..\src\extras\LIRC\OISLIRCFactoryCreator.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\includes\OIS.h" />
+    <ClInclude Include="..\includes\OISConfig.h" />
+    <ClInclude Include="..\includes\OISEvents.h" />
+    <ClInclude Include="..\includes\OISException.h" />
+    <ClInclude Include="..\includes\OISFactoryCreator.h" />
+    <ClInclude Include="..\includes\OISInputManager.h" />
+    <ClInclude Include="..\includes\OISJoystick.h" />
+    <ClInclude Include="..\includes\OISKeyboard.h" />
+    <ClInclude Include="..\includes\OISMouse.h" />
+    <ClInclude Include="..\includes\OISObject.h" />
+    <ClInclude Include="..\includes\OISPrereqs.h" />
+    <ClInclude Include="..\includes\win32\Win32ForceFeedback.h" />
+    <ClInclude Include="..\includes\win32\Win32InputManager.h" />
+    <ClInclude Include="..\includes\win32\Win32JoyStick.h" />
+    <ClInclude Include="..\includes\win32\Win32KeyBoard.h" />
+    <ClInclude Include="..\includes\win32\Win32Mouse.h" />
+    <ClInclude Include="..\includes\win32\Win32Prereqs.h" />
+    <ClInclude Include="..\includes\OISEffect.h" />
+    <ClInclude Include="..\includes\OISForceFeedback.h" />
+    <ClInclude Include="..\includes\OISInterface.h" />
+    <ClInclude Include="..\src\win32\extras\WiiMote\hiddevice.h" />
+    <ClInclude Include="..\src\win32\extras\WiiMote\OISWiiMote.h" />
+    <ClInclude Include="..\src\win32\extras\WiiMote\OISWiiMoteFactoryCreator.h" />
+    <ClInclude Include="..\src\win32\extras\WiiMote\OISWiiMoteForceFeedback.h" />
+    <ClInclude Include="..\src\win32\extras\WiiMote\OISWiiMoteRingBuffer.h" />
+    <ClInclude Include="..\src\win32\extras\WiiMote\wiimote.h" />
+    <ClInclude Include="..\src\extras\LIRC\OISLIRC.h" />
+    <ClInclude Include="..\src\extras\LIRC\OISLIRCFactoryCreator.h" />
+    <ClInclude Include="..\src\extras\LIRC\OISLIRCRingBuffer.h" />
+    <ClInclude Include="resource.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="OIS.rc">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='OIS_DebugDll|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+    </ResourceCompile>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS_vs2010.vcxproj.filters b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS_vs2010.vcxproj.filters
new file mode 100644
index 0000000..55dd53f
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/OIS_vs2010.vcxproj.filters
@@ -0,0 +1,191 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{48e9228d-369a-4767-bbc5-dafe844c3780}</UniqueIdentifier>
+      <Extensions>cpp;c;cxx;def;odl;idl;hpj;bat;asm</Extensions>
+    </Filter>
+    <Filter Include="Source Files\Win32">
+      <UniqueIdentifier>{389c4208-f6f7-447c-9537-df7dbcd4a91f}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{cf60fc04-520e-40e4-b2cc-9c58dcdcbe00}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl;inc</Extensions>
+    </Filter>
+    <Filter Include="Header Files\Win32">
+      <UniqueIdentifier>{07206dd4-d20f-454a-ae90-b78d6d74dea8}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\Interface">
+      <UniqueIdentifier>{96c6cb0b-fad1-4f7c-a0de-80ed75953da1}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Extras">
+      <UniqueIdentifier>{de71993b-4545-43ce-916e-2fbb4f5cb3dc}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Extras\WiiMote">
+      <UniqueIdentifier>{223c9e08-82c0-4c7f-84a4-2e9dbe330186}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Extras\LIRC">
+      <UniqueIdentifier>{b499da16-36e6-41a3-960a-284308f9d43b}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Extras\XInput">
+      <UniqueIdentifier>{3d9a6bd9-e75b-40d4-bc06-e5ed0bea56ae}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\src\OISEffect.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\OISException.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\OISForceFeedback.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\OISInputManager.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\OISJoyStick.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\OISKeyboard.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\OISObject.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\win32\Win32ForceFeedback.cpp">
+      <Filter>Source Files\Win32</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\win32\Win32InputManager.cpp">
+      <Filter>Source Files\Win32</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\win32\Win32JoyStick.cpp">
+      <Filter>Source Files\Win32</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\win32\Win32KeyBoard.cpp">
+      <Filter>Source Files\Win32</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\win32\Win32Mouse.cpp">
+      <Filter>Source Files\Win32</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\win32\extras\WiiMote\hiddevice.cpp">
+      <Filter>Extras\WiiMote</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\win32\extras\WiiMote\OISWiiMote.cpp">
+      <Filter>Extras\WiiMote</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\win32\extras\WiiMote\OISWiiMoteFactoryCreator.cpp">
+      <Filter>Extras\WiiMote</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\win32\extras\WiiMote\OISWiiMoteForceFeedback.cpp">
+      <Filter>Extras\WiiMote</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\win32\extras\WiiMote\OISWiiMoteRingBuffer.cpp">
+      <Filter>Extras\WiiMote</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\win32\extras\WiiMote\wiimote.cpp">
+      <Filter>Extras\WiiMote</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\extras\LIRC\OISLIRC.cpp">
+      <Filter>Extras\LIRC</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\extras\LIRC\OISLIRCFactoryCreator.cpp">
+      <Filter>Extras\LIRC</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\includes\OIS.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\includes\OISConfig.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\includes\OISEvents.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\includes\OISException.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\includes\OISFactoryCreator.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\includes\OISInputManager.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\includes\OISJoystick.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\includes\OISKeyboard.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\includes\OISMouse.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\includes\OISObject.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\includes\OISPrereqs.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\includes\win32\Win32ForceFeedback.h">
+      <Filter>Header Files\Win32</Filter>
+    </ClInclude>
+    <ClInclude Include="..\includes\win32\Win32InputManager.h">
+      <Filter>Header Files\Win32</Filter>
+    </ClInclude>
+    <ClInclude Include="..\includes\win32\Win32JoyStick.h">
+      <Filter>Header Files\Win32</Filter>
+    </ClInclude>
+    <ClInclude Include="..\includes\win32\Win32KeyBoard.h">
+      <Filter>Header Files\Win32</Filter>
+    </ClInclude>
+    <ClInclude Include="..\includes\win32\Win32Mouse.h">
+      <Filter>Header Files\Win32</Filter>
+    </ClInclude>
+    <ClInclude Include="..\includes\win32\Win32Prereqs.h">
+      <Filter>Header Files\Win32</Filter>
+    </ClInclude>
+    <ClInclude Include="..\includes\OISEffect.h">
+      <Filter>Header Files\Interface</Filter>
+    </ClInclude>
+    <ClInclude Include="..\includes\OISForceFeedback.h">
+      <Filter>Header Files\Interface</Filter>
+    </ClInclude>
+    <ClInclude Include="..\includes\OISInterface.h">
+      <Filter>Header Files\Interface</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\win32\extras\WiiMote\hiddevice.h">
+      <Filter>Extras\WiiMote</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\win32\extras\WiiMote\OISWiiMote.h">
+      <Filter>Extras\WiiMote</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\win32\extras\WiiMote\OISWiiMoteFactoryCreator.h">
+      <Filter>Extras\WiiMote</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\win32\extras\WiiMote\OISWiiMoteForceFeedback.h">
+      <Filter>Extras\WiiMote</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\win32\extras\WiiMote\OISWiiMoteRingBuffer.h">
+      <Filter>Extras\WiiMote</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\win32\extras\WiiMote\wiimote.h">
+      <Filter>Extras\WiiMote</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\extras\LIRC\OISLIRC.h">
+      <Filter>Extras\LIRC</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\extras\LIRC\OISLIRCFactoryCreator.h">
+      <Filter>Extras\LIRC</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\extras\LIRC\OISLIRCRingBuffer.h">
+      <Filter>Extras\LIRC</Filter>
+    </ClInclude>
+    <ClInclude Include="resource.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="OIS.rc" />
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/SDL/OIS_sdl_vc8.vcproj b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/SDL/OIS_sdl_vc8.vcproj
new file mode 100644
index 0000000..620a6c0
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/SDL/OIS_sdl_vc8.vcproj
@@ -0,0 +1,779 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="OIS"
+	ProjectGUID="{9BC704CB-4956-4479-BDEC-57CBC03F700E}"
+	RootNamespace="OIS"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="..\..\lib"
+			IntermediateDirectory="obj\debug"
+			ConfigurationType="4"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\includes"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_STLP_DEBUG;OIS_SDL_PLATFORM"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderThrough="StdAfx.h"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+				CallingConvention="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalDependencies="SDL.lib"
+				OutputFile="$(OutDir)/OIS-SDL_static_d.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="..\lib64\"
+			IntermediateDirectory="..\lib64\obj\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\includes"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_STLP_DEBUG"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderThrough="StdAfx.h"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+				CallingConvention="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib"
+				OutputFile="$(OutDir)/OIS_d.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="..\..\lib"
+			IntermediateDirectory="obj\release"
+			ConfigurationType="4"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				OmitFramePointers="true"
+				AdditionalIncludeDirectories="..\..\includes"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;OIS_SDL_PLATFORM"
+				StringPooling="true"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="false"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile="$(IntDir)/$(TargetName).pch"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalDependencies="SDL.lib"
+				OutputFile="$(OutDir)/OIS-SDL_static.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="..\lib64\"
+			IntermediateDirectory="..\lib64\obj\$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="2"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				FavorSizeOrSpeed="1"
+				OmitFramePointers="true"
+				EnableFiberSafeOptimizations="true"
+				WholeProgramOptimization="true"
+				AdditionalIncludeDirectories="..\includes"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
+				StringPooling="true"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="true"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile="$(IntDir)/$(TargetName).pch"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib"
+				OutputFile="$(OutDir)/OIS.lib"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="OIS_ReleaseDll|Win32"
+			OutputDirectory="..\..\dll"
+			IntermediateDirectory="dll\release"
+			ConfigurationType="2"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				OmitFramePointers="true"
+				AdditionalIncludeDirectories="..\..\includes"
+				PreprocessorDefinitions="WIN32;NDEBUG;OIS_NONCLIENT_BUILD;OIS_DYNAMIC_LIB;OIS_SDL_PLATFORM"
+				StringPooling="true"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="false"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile="$(IntDir)/$(TargetName).pch"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="SDL.lib"
+				OutputFile="$(OutDir)\$(ProjectName)-SDL.dll"
+				GenerateDebugInformation="true"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				OptimizeForWindows98="1"
+				LinkTimeCodeGeneration="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="OIS_ReleaseDll|x64"
+			OutputDirectory="..\dll64"
+			IntermediateDirectory="..\dll64\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="2"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				FavorSizeOrSpeed="1"
+				OmitFramePointers="true"
+				EnableFiberSafeOptimizations="true"
+				WholeProgramOptimization="true"
+				AdditionalIncludeDirectories="..\includes"
+				PreprocessorDefinitions="WIN32;NDEBUG;OIS_NONCLIENT_BUILD;OIS_DYNAMIC_LIB"
+				StringPooling="true"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="true"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderFile="$(IntDir)/$(TargetName).pch"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib"
+				GenerateDebugInformation="true"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="OIS_DebugDll|Win32"
+			OutputDirectory="..\..\dll"
+			IntermediateDirectory="dll\debug"
+			ConfigurationType="2"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\includes"
+				PreprocessorDefinitions="WIN32;_DEBUG;_STLP_DEBUG;OIS_NONCLIENT_BUILD;OIS_DYNAMIC_LIB;OIS_SDL_PLATFORM"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderThrough="StdAfx.h"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+				CallingConvention="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="SDL.lib"
+				OutputFile="$(OutDir)/OIS-SDL_d.dll"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+		<Configuration
+			Name="OIS_DebugDll|x64"
+			OutputDirectory="..\dll64"
+			IntermediateDirectory="..\dll64\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\includes"
+				PreprocessorDefinitions="WIN32;_DEBUG;_STLP_DEBUG;OIS_NONCLIENT_BUILD;OIS_DYNAMIC_LIB"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				FloatingPointModel="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
+				PrecompiledHeaderThrough="StdAfx.h"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+				CallingConvention="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="dxguid.lib dinput8.lib"
+				OutputFile="$(OutDir)/OIS_d.dll"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine=""
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm"
+			>
+			<File
+				RelativePath="..\..\src\OISEffect.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\OISForceFeedback.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\OISInputManager.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\OISJoyStick.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\OISKeyboard.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\OISObject.cpp"
+				>
+			</File>
+			<Filter
+				Name="SDL"
+				>
+				<File
+					RelativePath="..\..\src\SDL\SDLInputManager.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\..\src\SDL\SDLJoyStick.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\..\src\SDL\SDLKeyboard.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\..\src\SDL\SDLMouse.cpp"
+					>
+				</File>
+			</Filter>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc"
+			>
+			<File
+				RelativePath="..\..\includes\OIS.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\includes\OISEvents.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\includes\OISException.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\includes\OISInputManager.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\includes\OISJoystick.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\includes\OISKeyboard.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\includes\OISMouse.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\includes\OISObject.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\includes\OISPrereqs.h"
+				>
+			</File>
+			<Filter
+				Name="SDL"
+				>
+				<File
+					RelativePath="..\..\includes\SDL\SDLInputManager.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\includes\SDL\SDLJoyStick.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\includes\SDL\SDLKeyboard.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\includes\SDL\SDLMouse.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\includes\SDL\SDLPrereqs.h"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="Interface"
+				>
+				<File
+					RelativePath="..\..\includes\OISEffect.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\includes\OISForceFeedback.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\includes\OISInterface.h"
+					>
+				</File>
+			</Filter>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/SDL/SdlDemo/SdlDemo.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/SDL/SdlDemo/SdlDemo.cpp
new file mode 100644
index 0000000..38f2129
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/SDL/SdlDemo/SdlDemo.cpp
@@ -0,0 +1,243 @@
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include <iostream>
+#include <vector>
+#include <sstream>
+#include <OIS.h>
+#include <SDL.h>
+#include "resource.h"
+
+LRESULT DlgProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
+void initSDL();
+void destroySDL();
+void initOIS();
+void destroyOIS();
+
+void OutputMessage( const std::string& message );
+
+//Fun Globals ;-)
+HWND hWnd = 0, hOut = 0, hDisp = 0;
+bool appRunning = true;
+
+using namespace OIS;
+
+//////////// Common Event handler class ////////
+class EventHandler : public KeyListener, public MouseListener
+{
+public:
+	EventHandler() {}
+	~EventHandler() {}
+	bool keyPressed( const KeyEvent &arg ) {
+		std::ostringstream ss;
+		ss << "KeyPressed {" << arg.key	<< ", " << ((Keyboard*)(arg.device))->getAsString(arg.key)
+			<< "} || Text (" << (arg.text > 0 ? (char)arg.text : '?') << ")";
+		OutputMessage(ss.str());
+		return true;
+	}
+	bool keyReleased( const KeyEvent &arg ) {
+		if( arg.key == KC_ESCAPE || arg.key == KC_Q )
+		{
+			appRunning = false;
+			return false;
+		}
+		std::ostringstream ss;
+		ss << "KeyReleased (" << arg.key << ")";
+		OutputMessage(ss.str());
+		return true;
+	}
+	bool mouseMoved( const MouseEvent &arg ) {
+		const MouseState& s = arg.state;
+		std::ostringstream ss;
+		ss << "MouseMoved: Abs("
+		  << s.abX << ", " << s.abY << ", " << s.abZ << ") Rel("
+		  << s.relX << ", " << s.relY << ", " << s.relZ << ")";
+		OutputMessage(ss.str());
+		return true;
+	}
+	bool mousePressed( const MouseEvent &arg, MouseButtonID id ) {
+		std::ostringstream ss;
+		ss << "MousePressed: " << id;
+		OutputMessage(ss.str());
+		return true;
+	}
+	bool mouseReleased( const MouseEvent &arg, MouseButtonID id ) {
+		std::ostringstream ss;
+		ss << "MouseReleased: " << id;
+		OutputMessage(ss.str());
+		return true;
+	}
+};
+
+//More Fun Globals ;-)
+EventHandler gHandler;
+Mouse* gMouse = 0;
+Keyboard* gKeyboard = 0;
+
+//---------------------------------------------------------------------------------//
+INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
+{
+	//Create a capture window for Input Grabbing
+	hWnd = CreateDialog( 0, MAKEINTRESOURCE(IDD_MAIN_WINDOW), 0,(DLGPROC)DlgProc);
+	if( hWnd == 0 ) exit(-1);
+	ShowWindow(hWnd, SW_SHOW);
+	
+	hOut = GetDlgItem(hWnd, IDC_OUTPUT);
+	if(hOut == 0) exit(-1);
+
+	hDisp = GetDlgItem(hWnd, IDC_SDL_WIN);
+	if(hDisp == 0) exit(-1);
+
+	OutputMessage("Initialising Demo Application...");
+
+	try
+	{
+		initSDL();
+		initOIS();
+	}
+	catch(...)
+	{
+		appRunning = false;
+	}
+
+	while(appRunning)
+	{
+		Sleep( 30 );
+		MSG  msg;
+		while( PeekMessage( &msg, NULL, 0U, 0U, PM_REMOVE ) )
+		{
+			if( msg.message == WM_QUIT )
+				appRunning = false;
+
+			TranslateMessage( &msg );
+			DispatchMessage( &msg );
+		}
+
+		if( gKeyboard )
+		{
+			gKeyboard->capture();
+			if( gKeyboard->buffered() == false )
+				if( gKeyboard->isKeyDown( KC_ESCAPE ) )
+					appRunning = false;
+		}
+
+		if( gMouse )
+		{
+			gMouse->capture();
+		}
+	}
+
+	destroyOIS();
+	destroySDL();
+	return 0;
+}
+
+//---------------------------------------------------------------------------------//
+void initSDL()
+{
+	OutputMessage("Initialising SDL...");
+	//I cannot get embedding functioning :/
+	//std::ostringstream ss;
+	//ss << "SDL_WINDOWID=" << hDisp;
+	//_putenv(ss.str().c_str());
+	//_putenv("SDL_VIDEODRIVER=windib");
+	RECT r;
+	GetWindowRect(hDisp, &r);
+
+	if( SDL_Init(SDL_INIT_VIDEO) < 0 )
+		throw("Error!");
+	SDL_Surface *screen = SDL_SetVideoMode( r.right-r.left, r.bottom-r.top, 32, SDL_HWSURFACE );
+	
+	//SDL_Surface *screen = SDL_SetVideoMode( r.right-r.left, r.bottom-r.top, 0, 0 );
+	//SetWindowPos(hDisp, 0, r.left, r.top, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
+	OutputMessage("Success!");
+}
+
+//---------------------------------------------------------------------------------//
+void destroySDL()
+{
+	SDL_Quit();
+}
+
+//---------------------------------------------------------------------------------//
+void initOIS()
+{
+	OutputMessage("Initialising OIS...");
+	InputManager *im = InputManager::createInputSystem(ParamList());
+
+	gKeyboard = static_cast<Keyboard*>(im->createInputObject(OISKeyboard, false));
+	gKeyboard->setEventCallback( &gHandler );
+
+	gMouse = static_cast<Mouse*>(im->createInputObject(OISMouse, false));
+	gMouse->setEventCallback( &gHandler );
+	
+	std::ostringstream temp;
+	unsigned int v = im->getVersionNumber();
+	temp << "Success! >> " << "Version: " << (v>>16 ) << "." << ((v>>8) & 0x000000FF)
+		<< "." << (v & 0x000000FF) << " >> Release Name: "
+		<< im->getVersionName() << " >> Platform: " << im->inputSystemName();
+	OutputMessage(temp.str());
+	OutputMessage("");
+	OutputMessage("***************************************************************");
+	OutputMessage("TIP!: Keep the external SDL window active to recieve events");
+	OutputMessage("TIP!: Git Escape in buffered or unbuffered to quit");
+	OutputMessage("***************************************************************");
+}
+
+//---------------------------------------------------------------------------------//
+void destroyOIS()
+{
+	if( InputManager::getSingletonPtr() )
+	{
+		InputManager::getSingletonPtr()->destroyInputObject(gKeyboard);
+		InputManager::destroyInputSystem();
+	}
+}
+
+//---------------------------------------------------------------------------------//
+LRESULT DlgProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
+{
+	int wmId = LOWORD(wParam), wmEvent = HIWORD(wParam);
+
+	switch(uMsg)
+	{
+		case WM_CLOSE:
+			PostQuitMessage(0);
+			return TRUE;
+		case WM_COMMAND:
+		{
+			switch(wmId)
+			{
+			case ID_EXIT:
+				PostQuitMessage(0);
+				return TRUE;
+			case IDC_BUFF_KEYS:
+			{
+				gKeyboard->setBuffered( !gKeyboard->buffered() );
+				std::ostringstream temp;
+				temp << "** Setting Keyboard buffered Mode to: " << (gKeyboard->buffered() ? "Buffered" : "Unbuffered");
+				OutputMessage(temp.str());
+				return FALSE;
+			}
+			case IDC_BUFF_MOUSE:
+			{
+				gMouse->setBuffered( !gMouse->buffered() );
+				std::ostringstream temp;
+				temp << "** Setting Mouse buffered Mode to: " << (gMouse->buffered() ? "Buffered" : "Unbuffered");
+				OutputMessage(temp.str());
+				return FALSE;
+			}
+			default: break;
+			}
+		}
+	}
+
+	return FALSE;
+}
+
+//---------------------------------------------------------------------------------//
+void OutputMessage( const std::string& message )
+{
+	static std::ostringstream buff;
+	buff << message << "\r\n";
+	SendMessage(hOut, WM_SETTEXT, 0, (LPARAM)buff.str().c_str());
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/SDL/SdlDemo/SdlDemo.rc b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/SDL/SdlDemo/SdlDemo.rc
new file mode 100644
index 0000000..9e0533a
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/SDL/SdlDemo/SdlDemo.rc
@@ -0,0 +1,100 @@
+// Microsoft Visual C++ generated resource script.
+//
+#include "resource.h"
+
+#define APSTUDIO_READONLY_SYMBOLS
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 2 resource.
+//
+#include "afxres.h"
+
+/////////////////////////////////////////////////////////////////////////////
+#undef APSTUDIO_READONLY_SYMBOLS
+
+/////////////////////////////////////////////////////////////////////////////
+// English (U.S.) resources
+
+#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
+#ifdef _WIN32
+LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
+#pragma code_page(1252)
+#endif //_WIN32
+
+#ifdef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// TEXTINCLUDE
+//
+
+1 TEXTINCLUDE 
+BEGIN
+    "resource.h\0"
+END
+
+2 TEXTINCLUDE 
+BEGIN
+    "#include ""afxres.h""\r\n"
+    "\0"
+END
+
+3 TEXTINCLUDE 
+BEGIN
+    "\r\n"
+    "\0"
+END
+
+#endif    // APSTUDIO_INVOKED
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Dialog
+//
+
+IDD_MAIN_WINDOW DIALOGEX 0, 0, 303, 279
+STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
+CAPTION "OIS-SDL Demo"
+FONT 8, "MS Shell Dlg", 400, 0, 0x1
+BEGIN
+    DEFPUSHBUTTON   "Exit",ID_EXIT,242,258,50,14
+    EDITTEXT        IDC_OUTPUT,7,162,289,88,ES_MULTILINE | ES_AUTOHSCROLL | WS_VSCROLL | WS_HSCROLL,WS_EX_STATICEDGE
+    CONTROL         "Buffered Mouse",IDC_BUFF_MOUSE,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,14,258,74,10
+    CONTROL         "Buffered Keyboard",IDC_BUFF_KEYS,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,91,258,88,10
+    CONTROL         "",IDC_SDL_WIN,"Static",SS_BLACKFRAME,32,27,108,86
+END
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// DESIGNINFO
+//
+
+#ifdef APSTUDIO_INVOKED
+GUIDELINES DESIGNINFO 
+BEGIN
+    IDD_MAIN_WINDOW, DIALOG
+    BEGIN
+        LEFTMARGIN, 7
+        RIGHTMARGIN, 296
+        TOPMARGIN, 7
+        BOTTOMMARGIN, 272
+    END
+END
+#endif    // APSTUDIO_INVOKED
+
+#endif    // English (U.S.) resources
+/////////////////////////////////////////////////////////////////////////////
+
+
+
+#ifndef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 3 resource.
+//
+
+
+/////////////////////////////////////////////////////////////////////////////
+#endif    // not APSTUDIO_INVOKED
+
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/SDL/SdlDemo/SdlDemo.vcproj b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/SDL/SdlDemo/SdlDemo.vcproj
new file mode 100644
index 0000000..7ff4338
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/SDL/SdlDemo/SdlDemo.vcproj
@@ -0,0 +1,217 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="SdlDemo"
+	ProjectGUID="{31E76EC7-FE93-4119-8EE1-94F04A077865}"
+	RootNamespace="ConsoleDemo"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="0"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				UseUnicodeResponseFiles="false"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\..\includes"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				UseUnicodeResponseFiles="false"
+				AdditionalDependencies="OIS-SDL_static_d.lib"
+				OutputFile="debug\$(ProjectName).exe"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="..\..\..\lib"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="1"
+			CharacterSet="0"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				UseUnicodeResponseFiles="false"
+				AdditionalIncludeDirectories="..\..\..\includes"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				UseUnicodeResponseFiles="false"
+				AdditionalDependencies="OIS-SDL_static.lib"
+				OutputFile="release\$(ProjectName).exe"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="..\..\..\lib"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath=".\SdlDemo.cpp"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath=".\resource.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+			<File
+				RelativePath=".\SdlDemo.rc"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/SDL/SdlDemo/resource.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/SDL/SdlDemo/resource.h
new file mode 100644
index 0000000..43d1b47
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/SDL/SdlDemo/resource.h
@@ -0,0 +1,22 @@
+//{{NO_DEPENDENCIES}}
+// Microsoft Visual C++ generated include file.
+// Used by SdlDemo.rc
+//
+#define IDD_MAIN_WINDOW                 101
+#define IDC_OUTPUT                      1001
+#define IDC_SDL_WIN                     1002
+#define IDC_BUFF_MOUSE                  1003
+#define IDC_BUFF_KEYS                   1004
+#define ID_EXIT                         1005
+#define IDC_BUTTON1                     1006
+
+// Next default values for new objects
+// 
+#ifdef APSTUDIO_INVOKED
+#ifndef APSTUDIO_READONLY_SYMBOLS
+#define _APS_NEXT_RESOURCE_VALUE        102
+#define _APS_NEXT_COMMAND_VALUE         40001
+#define _APS_NEXT_CONTROL_VALUE         1007
+#define _APS_NEXT_SYMED_VALUE           101
+#endif
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/SDL/ois_sdl_vc8.sln b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/SDL/ois_sdl_vc8.sln
new file mode 100644
index 0000000..4138faf
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/SDL/ois_sdl_vc8.sln
@@ -0,0 +1,36 @@
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "OIS", "OIS_sdl_vc8.vcproj", "{9BC704CB-4956-4479-BDEC-57CBC03F700E}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SdlDemo", "SdlDemo\SdlDemo.vcproj", "{31E76EC7-FE93-4119-8EE1-94F04A077865}"
+	ProjectSection(ProjectDependencies) = postProject
+		{9BC704CB-4956-4479-BDEC-57CBC03F700E} = {9BC704CB-4956-4479-BDEC-57CBC03F700E}
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Debug|x64 = Debug|x64
+		Release|Win32 = Release|Win32
+		Release|x64 = Release|x64
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{9BC704CB-4956-4479-BDEC-57CBC03F700E}.Debug|Win32.ActiveCfg = Debug|Win32
+		{9BC704CB-4956-4479-BDEC-57CBC03F700E}.Debug|Win32.Build.0 = Debug|Win32
+		{9BC704CB-4956-4479-BDEC-57CBC03F700E}.Debug|x64.ActiveCfg = Debug|x64
+		{9BC704CB-4956-4479-BDEC-57CBC03F700E}.Debug|x64.Build.0 = Debug|x64
+		{9BC704CB-4956-4479-BDEC-57CBC03F700E}.Release|Win32.ActiveCfg = Release|Win32
+		{9BC704CB-4956-4479-BDEC-57CBC03F700E}.Release|Win32.Build.0 = Release|Win32
+		{9BC704CB-4956-4479-BDEC-57CBC03F700E}.Release|x64.ActiveCfg = Release|x64
+		{9BC704CB-4956-4479-BDEC-57CBC03F700E}.Release|x64.Build.0 = Release|x64
+		{31E76EC7-FE93-4119-8EE1-94F04A077865}.Debug|Win32.ActiveCfg = Debug|Win32
+		{31E76EC7-FE93-4119-8EE1-94F04A077865}.Debug|Win32.Build.0 = Debug|Win32
+		{31E76EC7-FE93-4119-8EE1-94F04A077865}.Debug|x64.ActiveCfg = Debug|Win32
+		{31E76EC7-FE93-4119-8EE1-94F04A077865}.Release|Win32.ActiveCfg = Release|Win32
+		{31E76EC7-FE93-4119-8EE1-94F04A077865}.Release|Win32.Build.0 = Release|Win32
+		{31E76EC7-FE93-4119-8EE1-94F04A077865}.Release|x64.ActiveCfg = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/ois.cbp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/ois.cbp
new file mode 100644
index 0000000..3bfd599
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/ois.cbp
@@ -0,0 +1,134 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
+<CodeBlocks_project_file>
+	<FileVersion major="1" minor="6" />
+	<Project>
+		<Option title="OIS" />
+		<Option compiler="gcc" />
+		<Build>
+			<Target title="Debug">
+				<Option output="..\lib\libOIS_static_d.a" prefix_auto="0" extension_auto="0" />
+				<Option working_dir="" />
+				<Option object_output="..\lib\obj\debug" />
+				<Option type="2" />
+				<Option compiler="gcc" />
+				<Option createDefFile="1" />
+				<Option projectResourceIncludeDirsRelation="0" />
+				<Compiler>
+					<Add option="-g" />
+					<Add option="-O0" />
+					<Add option="-D_DEBUG" />
+					<Add option="-D_LIB" />
+				</Compiler>
+			</Target>
+			<Target title="Release">
+				<Option output="..\lib\libOIS_static.a" prefix_auto="0" extension_auto="0" />
+				<Option working_dir="" />
+				<Option object_output="..\lib\obj\release" />
+				<Option type="2" />
+				<Option compiler="gcc" />
+				<Option createDefFile="1" />
+				<Option projectResourceIncludeDirsRelation="0" />
+				<Compiler>
+					<Add option="-O3" />
+					<Add option="-DNDEBUG" />
+					<Add option="-D_LIB" />
+				</Compiler>
+				<Linker>
+					<Add option="-s" />
+				</Linker>
+			</Target>
+			<Target title="OIS_DebugDll">
+				<Option output="..\dll\OIS_d.dll" prefix_auto="0" extension_auto="0" />
+				<Option object_output="..\dll\debug" />
+				<Option type="3" />
+				<Option compiler="gcc" />
+				<Option projectResourceIncludeDirsRelation="0" />
+				<Compiler>
+					<Add option="-g" />
+					<Add option="-O0" />
+					<Add option="-D_DEBUG" />
+					<Add option="-DOIS_DYNAMIC_LIB" />
+				</Compiler>
+				<Linker>
+					<Add library="dinput8" />
+					<Add library="dxguid" />
+				</Linker>
+			</Target>
+			<Target title="OIS_ReleaseDll">
+				<Option output="..\dll\OIS.dll" prefix_auto="0" extension_auto="0" />
+				<Option object_output="..\dll\release" />
+				<Option type="3" />
+				<Option compiler="gcc" />
+				<Option projectResourceIncludeDirsRelation="0" />
+				<Compiler>
+					<Add option="-O3" />
+					<Add option="-DNDEBUG" />
+					<Add option="-DOIS_DYNAMIC_LIB" />
+				</Compiler>
+				<Linker>
+					<Add option="-s" />
+					<Add library="dinput8" />
+					<Add library="dxguid" />
+				</Linker>
+			</Target>
+		</Build>
+		<VirtualTargets>
+			<Add alias="All" targets="Debug;Release;OIS_DebugDll;OIS_ReleaseDll;" />
+		</VirtualTargets>
+		<Compiler>
+			<Add option="-Wall" />
+			<Add option="-frtti" />
+			<Add option="-mthreads" />
+			<Add option="-fmessage-length=0" />
+			<Add option="-fexceptions" />
+			<Add option="-fident" />
+			<Add option="-pipe" />
+			<Add option="-DWIN32" />
+			<Add option="-DOIS_NONCLIENT_BUILD" />
+			<Add directory="..\includes" />
+			<Add directory="..\includes\win32" />
+			<Add directory="C:\Program Files\Microsoft DirectX SDK (November 2008)\Include" />
+		</Compiler>
+		<Linker>
+			<Add option="-Wl,--enable-auto-image-base" />
+			<Add option="-Wl,--add-stdcall-alias" />
+		</Linker>
+		<Unit filename="..\includes\OIS.h" />
+		<Unit filename="..\includes\OISConfig.h" />
+		<Unit filename="..\includes\OISEffect.h" />
+		<Unit filename="..\includes\OISEvents.h" />
+		<Unit filename="..\includes\OISException.h" />
+		<Unit filename="..\includes\OISForceFeedback.h" />
+		<Unit filename="..\includes\OISInputManager.h" />
+		<Unit filename="..\includes\OISInterface.h" />
+		<Unit filename="..\includes\OISJoyStick.h" />
+		<Unit filename="..\includes\OISJoystick.h" />
+		<Unit filename="..\includes\OISKeyboard.h" />
+		<Unit filename="..\includes\OISMouse.h" />
+		<Unit filename="..\includes\OISObject.h" />
+		<Unit filename="..\includes\OISPrereqs.h" />
+		<Unit filename="..\includes\win32\Win32ForceFeedback.h" />
+		<Unit filename="..\includes\win32\Win32InputManager.h" />
+		<Unit filename="..\includes\win32\Win32JoyStick.h" />
+		<Unit filename="..\includes\win32\Win32KeyBoard.h" />
+		<Unit filename="..\includes\win32\Win32Mouse.h" />
+		<Unit filename="..\includes\win32\Win32Prereqs.h" />
+		<Unit filename="..\src\OISEffect.cpp" />
+		<Unit filename="..\src\OISException.cpp" />
+		<Unit filename="..\src\OISForceFeedback.cpp" />
+		<Unit filename="..\src\OISInputManager.cpp" />
+		<Unit filename="..\src\OISJoyStick.cpp" />
+		<Unit filename="..\src\OISKeyboard.cpp" />
+		<Unit filename="..\src\OISObject.cpp" />
+		<Unit filename="..\src\win32\Win32ForceFeedback.cpp" />
+		<Unit filename="..\src\win32\Win32InputManager.cpp" />
+		<Unit filename="..\src\win32\Win32JoyStick.cpp" />
+		<Unit filename="..\src\win32\Win32KeyBoard.cpp" />
+		<Unit filename="..\src\win32\Win32Mouse.cpp" />
+		<Extensions>
+			<code_completion />
+			<envvars />
+			<debugger />
+		</Extensions>
+	</Project>
+</CodeBlocks_project_file>
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/ois.sln b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/ois.sln
new file mode 100644
index 0000000..faa2260
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/ois.sln
@@ -0,0 +1,53 @@
+Microsoft Visual Studio Solution File, Format Version 8.00
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "OIS", "OIS.vcproj", "{9CC704CB-4956-4479-BDEC-57CBC03F700E}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+Microsoft Visual Studio Solution File, Format Version 8.00
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "OIS", "OIS.vcproj", "{9CC704CB-4956-4479-BDEC-57CBC03F700E}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+Microsoft Visual Studio Solution File, Format Version 11.00
+# Visual C++ Express 2010
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "OIS", "OIS.vcxproj", "{9CC704CB-4956-4479-BDEC-57CBC03F700E}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Demo_Console", "CommandLine\CommandLine.vcxproj", "{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Demo_FFTest", "DemoFFTest\DemoFFTest.vcxproj", "{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		OIS_DebugDll|Win32 = OIS_DebugDll|Win32
+		OIS_ReleaseDll|Win32 = OIS_ReleaseDll|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Debug|Win32.ActiveCfg = Debug|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Debug|Win32.Build.0 = Debug|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.OIS_DebugDll|Win32.ActiveCfg = OIS_DebugDll|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.OIS_DebugDll|Win32.Build.0 = OIS_DebugDll|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.OIS_ReleaseDll|Win32.ActiveCfg = OIS_ReleaseDll|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.OIS_ReleaseDll|Win32.Build.0 = OIS_ReleaseDll|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Release|Win32.ActiveCfg = Release|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Release|Win32.Build.0 = Release|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Debug|Win32.ActiveCfg = Debug|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Debug|Win32.Build.0 = Debug|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.OIS_DebugDll|Win32.ActiveCfg = Debug|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.OIS_DebugDll|Win32.Build.0 = Debug|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.OIS_ReleaseDll|Win32.ActiveCfg = Release|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.OIS_ReleaseDll|Win32.Build.0 = Release|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Release|Win32.ActiveCfg = Release|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Release|Win32.Build.0 = Release|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Debug|Win32.ActiveCfg = Debug|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Debug|Win32.Build.0 = Debug|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.OIS_DebugDll|Win32.ActiveCfg = Debug|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.OIS_DebugDll|Win32.Build.0 = Debug|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.OIS_ReleaseDll|Win32.ActiveCfg = Release|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.OIS_ReleaseDll|Win32.Build.0 = Release|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Release|Win32.ActiveCfg = Release|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/ois.sln.orig b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/ois.sln.orig
new file mode 100644
index 0000000..da92e25
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/ois.sln.orig
@@ -0,0 +1,87 @@
+<<<<<<< HEAD:extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-3/Win32/ois.sln
+Microsoft Visual Studio Solution File, Format Version 11.00
+# Visual C++ Express 2010
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "OIS", "OIS.vcxproj", "{9CC704CB-4956-4479-BDEC-57CBC03F700E}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Demo_Console", "CommandLine\CommandLine.vcxproj", "{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Demo_FFTest", "DemoFFTest\DemoFFTest.vcxproj", "{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		OIS_DebugDll|Win32 = OIS_DebugDll|Win32
+		OIS_ReleaseDll|Win32 = OIS_ReleaseDll|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Debug|Win32.ActiveCfg = Debug|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Debug|Win32.Build.0 = Debug|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.OIS_DebugDll|Win32.ActiveCfg = OIS_DebugDll|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.OIS_DebugDll|Win32.Build.0 = OIS_DebugDll|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.OIS_ReleaseDll|Win32.ActiveCfg = OIS_ReleaseDll|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.OIS_ReleaseDll|Win32.Build.0 = OIS_ReleaseDll|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Release|Win32.ActiveCfg = Release|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Release|Win32.Build.0 = Release|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Debug|Win32.ActiveCfg = Debug|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Debug|Win32.Build.0 = Debug|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.OIS_DebugDll|Win32.ActiveCfg = Debug|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.OIS_DebugDll|Win32.Build.0 = Debug|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.OIS_ReleaseDll|Win32.ActiveCfg = Release|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.OIS_ReleaseDll|Win32.Build.0 = Release|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Release|Win32.ActiveCfg = Release|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Release|Win32.Build.0 = Release|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Debug|Win32.ActiveCfg = Debug|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Debug|Win32.Build.0 = Debug|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.OIS_DebugDll|Win32.ActiveCfg = Debug|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.OIS_DebugDll|Win32.Build.0 = Debug|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.OIS_ReleaseDll|Win32.ActiveCfg = Release|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.OIS_ReleaseDll|Win32.Build.0 = Release|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Release|Win32.ActiveCfg = Release|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
+=======
+Microsoft Visual Studio Solution File, Format Version 8.00
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "OIS", "OIS.vcproj", "{9CC704CB-4956-4479-BDEC-57CBC03F700E}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Demo_Console", "CommandLine\CommandLine.vcproj", "{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}"
+	ProjectSection(ProjectDependencies) = postProject
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E} = {9CC704CB-4956-4479-BDEC-57CBC03F700E}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Demo_FFTest", "DemoFFTest\DemoFFTest.vcproj", "{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}"
+	ProjectSection(ProjectDependencies) = postProject
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E} = {9CC704CB-4956-4479-BDEC-57CBC03F700E}
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfiguration) = preSolution
+		Debug = Debug
+		Release = Release
+	EndGlobalSection
+	GlobalSection(ProjectConfiguration) = postSolution
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Debug.ActiveCfg = Debug|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Debug.Build.0 = Debug|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Release.ActiveCfg = Release|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Release.Build.0 = Release|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Debug.ActiveCfg = Debug|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Debug.Build.0 = Debug|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Release.ActiveCfg = Release|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Release.Build.0 = Release|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Debug.ActiveCfg = Debug|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Debug.Build.0 = Debug|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Release.ActiveCfg = Release|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Release.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+	EndGlobalSection
+	GlobalSection(ExtensibilityAddIns) = postSolution
+	EndGlobalSection
+EndGlobal
+>>>>>>> a52110c80d18f2ea981078fdbea6850092f79a63:extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/ois.sln
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/ois_vc8.sln b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/ois_vc8.sln
new file mode 100644
index 0000000..326040e
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/ois_vc8.sln
@@ -0,0 +1,51 @@
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "OIS", "OIS_vc8.vcproj", "{9CC704CB-4956-4479-BDEC-57CBC03F700E}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Demo_Console", "CommandLine\CommandLine_vc8.vcproj", "{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}"
+	ProjectSection(ProjectDependencies) = postProject
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E} = {9CC704CB-4956-4479-BDEC-57CBC03F700E}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Demo_FFTest", "DemoFFTest\DemoFFTest_vc8.vcproj", "{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}"
+	ProjectSection(ProjectDependencies) = postProject
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E} = {9CC704CB-4956-4479-BDEC-57CBC03F700E}
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Debug|x64 = Debug|x64
+		Release|Win32 = Release|Win32
+		Release|x64 = Release|x64
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Debug|Win32.ActiveCfg = Debug|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Debug|Win32.Build.0 = Debug|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Debug|x64.ActiveCfg = Debug|x64
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Debug|x64.Build.0 = Debug|x64
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Release|Win32.ActiveCfg = Release|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Release|Win32.Build.0 = Release|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Release|x64.ActiveCfg = Release|x64
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Release|x64.Build.0 = Release|x64
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Debug|Win32.ActiveCfg = Debug|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Debug|Win32.Build.0 = Debug|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Debug|x64.ActiveCfg = Debug|x64
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Debug|x64.Build.0 = Debug|x64
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Release|Win32.ActiveCfg = Release|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Release|Win32.Build.0 = Release|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Release|x64.ActiveCfg = Release|x64
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Release|x64.Build.0 = Release|x64
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Debug|Win32.ActiveCfg = Debug|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Debug|Win32.Build.0 = Debug|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Debug|x64.ActiveCfg = Debug|x64
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Debug|x64.Build.0 = Debug|x64
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Release|Win32.ActiveCfg = Release|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Release|Win32.Build.0 = Release|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Release|x64.ActiveCfg = Release|x64
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Release|x64.Build.0 = Release|x64
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/ois_vc9.sln b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/ois_vc9.sln
new file mode 100644
index 0000000..f363286
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/ois_vc9.sln
@@ -0,0 +1,49 @@
+Microsoft Visual Studio Solution File, Format Version 10.00
+# Visual Studio 2008
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "OIS", "OIS_vc9.vcproj", "{9CC704CB-4956-4479-BDEC-57CBC03F700E}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Demo_Console", "CommandLine\CommandLine_vc9.vcproj", "{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}"
+	ProjectSection(ProjectDependencies) = postProject
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E} = {9CC704CB-4956-4479-BDEC-57CBC03F700E}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Demo_FFTest", "DemoFFTest\DemoFFTest_vc9.vcproj", "{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}"
+	ProjectSection(ProjectDependencies) = postProject
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E} = {9CC704CB-4956-4479-BDEC-57CBC03F700E}
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Debug|x64 = Debug|x64
+		Release|Win32 = Release|Win32
+		Release|x64 = Release|x64
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Debug|Win32.ActiveCfg = Debug|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Debug|Win32.Build.0 = Debug|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Debug|x64.ActiveCfg = Debug|x64
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Debug|x64.Build.0 = Debug|x64
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Release|Win32.ActiveCfg = Release|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Release|Win32.Build.0 = Release|Win32
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Release|x64.ActiveCfg = Release|x64
+		{9CC704CB-4956-4479-BDEC-57CBC03F700E}.Release|x64.Build.0 = Release|x64
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Debug|Win32.ActiveCfg = Debug|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Debug|Win32.Build.0 = Debug|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Debug|x64.ActiveCfg = Debug|x64
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Debug|x64.Build.0 = Debug|x64
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Release|Win32.ActiveCfg = Release|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Release|Win32.Build.0 = Release|Win32
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Release|x64.ActiveCfg = Release|x64
+		{7AC600E2-2B46-4204-8DEB-9E49A9BAF65F}.Release|x64.Build.0 = Release|x64
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Debug|Win32.ActiveCfg = Debug|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Debug|Win32.Build.0 = Debug|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Debug|x64.ActiveCfg = Debug|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Release|Win32.ActiveCfg = Release|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Release|Win32.Build.0 = Release|Win32
+		{D1912D13-C99D-4959-ABDC-62BF71AD5A1A}.Release|x64.ActiveCfg = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/resource.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/resource.h
new file mode 100644
index 0000000..d034a8a
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/Win32/resource.h
@@ -0,0 +1,14 @@
+//{{NO_DEPENDENCIES}}
+// Microsoft Visual C++ generated include file.
+// Used by OIS.rc
+
+// Next default values for new objects
+// 
+#ifdef APSTUDIO_INVOKED
+#ifndef APSTUDIO_READONLY_SYMBOLS
+#define _APS_NEXT_RESOURCE_VALUE        101
+#define _APS_NEXT_COMMAND_VALUE         40001
+#define _APS_NEXT_CONTROL_VALUE         1001
+#define _APS_NEXT_SYMED_VALUE           101
+#endif
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/acinclude.m4 b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/acinclude.m4
new file mode 100644
index 0000000..039ecc7
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/acinclude.m4
@@ -0,0 +1,16 @@
+
+AC_DEFUN([OIS_USE_STLPORT],
+[AC_ARG_WITH(stlport, 
+             AC_HELP_STRING([--with-stlport=PATH],
+                           [the path to STLPort.]),
+             ac_cv_use_stlport=$withval,
+             ac_cv_use_stlport=no)
+ AC_CACHE_CHECK([whether to use STLPort], ac_cv_use_stlport,
+                ac_cv_use_stlport=no)
+ if test x$ac_cv_use_stlport != xno; then
+     STLPORT_CFLAGS="-I$ac_cv_use_stlport/stlport"
+     STLPORT_LIBS="-L$ac_cv_use_stlport/lib -lstlport"
+ fi
+ AC_SUBST(STLPORT_CFLAGS)
+ AC_SUBST(STLPORT_LIBS)
+])
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/bootstrap b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/bootstrap
new file mode 100644
index 0000000..39d2d2a
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/bootstrap
@@ -0,0 +1,15 @@
+#!/bin/sh
+
+# Deal with some gentoo-specific issues
+export WANT_AUTOMAKE='1.7'
+export WANT_AUTOCONF='2.5'
+
+# clean up files which cause confusion when switch versions of auto*
+rm -rf autom4te.cache
+
+# Fire up autotools
+libtoolize --force --copy
+aclocal $ACLOCAL_FLAGS
+autoheader
+automake --include-deps --add-missing --foreign --copy
+autoconf 
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/configure.ac b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/configure.ac
new file mode 100644
index 0000000..37386ba
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/configure.ac
@@ -0,0 +1,35 @@
+#                                               -*- Autoconf -*-
+# Process this file with autoconf to produce a configure script.
+AC_PREREQ(2.50)
+AC_INIT( [OIS], 1.4.0 )
+
+AC_CANONICAL_TARGET
+AM_INIT_AUTOMAKE( [OIS], 1.4.0 )
+AM_CONFIG_HEADER([includes/config.h])
+
+dnl Check for programs
+AC_PROG_CC
+AC_PROG_CXX
+AM_PROG_CC_C_O
+AC_PROG_INSTALL
+AM_PROG_LIBTOOL
+
+dnl Checking for STLPort
+OIS_USE_STLPORT
+
+CFLAGS="$CFLAGS"
+CXXFLAGS="$CXXFLAGS"
+LIBS="$LIBS"
+
+dnl Detect X11
+AC_CHECK_HEADERS([X11/Xlib.h],, [AC_MSG_ERROR("Xlib.h not found - libx11-dev")])
+
+dnl Added for BSD's
+AC_PROG_LIBTOOL
+
+AC_CONFIG_FILES([Makefile
+                 includes/Makefile
+                 src/Makefile
+                 demos/Makefile
+                 OIS.pc])
+AC_OUTPUT
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/demos/FFConsoleDemo.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/demos/FFConsoleDemo.cpp
new file mode 100644
index 0000000..f090603
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/demos/FFConsoleDemo.cpp
@@ -0,0 +1,1146 @@
+#include "OIS.h"
+
+#include <math.h>
+#include <cstdlib>
+#include <iostream>
+#include <iomanip>
+#include <ios>
+#include <sstream>
+#include <vector>
+
+using namespace std;
+
+////////////////////////////////////Needed Windows Headers////////////
+#if defined OIS_WIN32_PLATFORM
+#  define WIN32_LEAN_AND_MEAN
+#  include "windows.h"
+#  include "resource.h"
+
+////////////////////////////////////Needed Linux Headers//////////////
+#elif defined OIS_LINUX_PLATFORM
+#  include <X11/Xlib.h>
+#else
+#  error Sorry, not yet implemented on this platform.
+#endif
+
+
+using namespace OIS;
+
+#if defined OIS_WIN32_PLATFORM
+
+// The dialog proc we have to give to CreateDialog
+LRESULT DlgProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
+{
+	return FALSE;
+}
+
+#endif
+
+//////////// Event handler class declaration ////////////////////////////////////////////////
+class Application;
+class JoystickManager;
+class EffectManager;
+
+class EventHandler : public KeyListener, public JoyStickListener
+{
+  protected:
+
+    Application*     _pApplication;
+    JoystickManager* _pJoystickMgr;
+	EffectManager*   _pEffectMgr;
+
+  public:
+
+    EventHandler(Application* pApp);
+    void initialize(JoystickManager* pJoystickMgr, EffectManager* pEffectMgr);
+
+	bool keyPressed( const KeyEvent &arg );
+	bool keyReleased( const KeyEvent &arg );
+
+	bool buttonPressed( const JoyStickEvent &arg, int button );
+	bool buttonReleased( const JoyStickEvent &arg, int button );
+
+	bool axisMoved( const JoyStickEvent &arg, int axis );
+
+	bool povMoved( const JoyStickEvent &arg, int pov );
+};
+
+//////////// Variable classes ////////////////////////////////////////////////////////
+
+class Variable
+{
+  protected:
+
+    double _dInitValue;
+    double _dValue;
+
+  public:
+
+    Variable(double dInitValue) : _dInitValue(dInitValue) { reset(); }
+
+    double getValue() const { return _dValue; }
+
+    void reset() { _dValue = _dInitValue; }
+
+    virtual void setValue(double dValue) { _dValue = dValue; }
+
+    virtual string toString() const
+    {
+	  ostringstream oss;
+	  oss << _dValue;
+	  return oss.str();
+	}
+
+    virtual void update() {};
+};
+
+class Constant : public Variable
+{
+  public:
+
+    Constant(double dInitValue) : Variable(dInitValue) {}
+
+    virtual void setValue(double dValue) { }
+
+};
+
+class LimitedVariable : public Variable
+{
+  protected:
+
+    double _dMinValue;
+    double _dMaxValue;
+
+  public:
+
+    LimitedVariable(double dInitValue, double dMinValue, double dMaxValue) 
+	: _dMinValue(dMinValue), _dMaxValue(dMaxValue), Variable(dInitValue)
+    {}
+
+    virtual void setValue(double dValue) 
+    { 
+	  _dValue = dValue;
+	  if (_dValue > _dMaxValue)
+		_dValue = _dMaxValue;
+	  else if (_dValue < _dMinValue)
+		_dValue = _dMinValue;
+	}
+
+/*    virtual string toString() const
+    {
+	  ostringstream oss;
+	  oss << setiosflags(ios_base::right) << setw(4) 
+	      << (int)(200.0 * getValue()/(_dMaxValue - _dMinValue)); // [-100%, +100%]
+	  return oss.str();
+	}*/
+};
+
+class TriangleVariable : public LimitedVariable
+{
+  protected:
+
+    double _dDeltaValue;
+
+  public:
+
+    TriangleVariable(double dInitValue, double dDeltaValue, double dMinValue, double dMaxValue) 
+	: LimitedVariable(dInitValue, dMinValue, dMaxValue), _dDeltaValue(dDeltaValue) {};
+
+    virtual void update()
+    {
+	  double dValue = getValue() + _dDeltaValue;
+	  if (dValue > _dMaxValue)
+	  {
+		dValue = _dMaxValue;
+		_dDeltaValue = -_dDeltaValue;
+		//cout << "Decreasing variable towards " << _dMinValue << endl;
+	  }
+	  else if (dValue < _dMinValue)
+	  {
+		dValue = _dMinValue;
+		_dDeltaValue = -_dDeltaValue;
+		//cout << "Increasing variable towards " << _dMaxValue << endl;
+	  }
+	  setValue(dValue);
+      //cout << "TriangleVariable::update : delta=" << _dDeltaValue << ", value=" << dValue << endl;
+	}
+};
+
+//////////// Variable effect class //////////////////////////////////////////////////////////
+
+typedef map<string, Variable*> MapVariables;
+typedef void (*EffectVariablesApplier)(MapVariables& mapVars, Effect* pEffect);
+
+class VariableEffect
+{
+  protected:
+
+    // Effect description
+    const char* _pszDesc;
+
+    // The associate OIS effect
+    Effect* _pEffect;
+
+    // The effect variables.
+    MapVariables _mapVariables;
+
+    // The effect variables applier function.
+    EffectVariablesApplier _pfApplyVariables;
+
+    // True if the effect is currently being played.
+    bool _bActive;
+
+  public:
+
+    VariableEffect(const char* pszDesc, Effect* pEffect, 
+				   const MapVariables& mapVars, const EffectVariablesApplier pfApplyVars)
+	: _pszDesc(pszDesc), _pEffect(pEffect), 
+	  _mapVariables(mapVars), _pfApplyVariables(pfApplyVars), _bActive(false)
+    {}
+
+    ~VariableEffect()
+    {
+	  if (_pEffect)
+		delete _pEffect;
+	  MapVariables::iterator iterVars;
+	  for (iterVars = _mapVariables.begin(); iterVars != _mapVariables.end(); iterVars++)
+		if (iterVars->second)
+		  delete iterVars->second;
+	  
+	}
+
+    void setActive(bool bActive = true)
+    {
+	  reset();
+	  _bActive = bActive;
+	}
+
+    bool isActive()
+    {
+	  return _bActive;
+	}
+
+	Effect* getFFEffect()
+	{
+	  return _pEffect;
+	}
+
+	const char* getDescription() const
+	{
+	  return _pszDesc;
+	}
+
+    void update()
+    {
+	  if (isActive())
+	  {
+		// Update the variables.
+		MapVariables::iterator iterVars;
+		for (iterVars = _mapVariables.begin(); iterVars != _mapVariables.end(); iterVars++)
+		  iterVars->second->update();
+
+		// Apply the updated variable values to the effect.
+		_pfApplyVariables(_mapVariables, _pEffect);
+	  }
+    }
+
+    void reset()
+    {
+	  MapVariables::iterator iterVars;
+	  for (iterVars = _mapVariables.begin(); iterVars != _mapVariables.end(); iterVars++)
+		iterVars->second->reset();
+	  _pfApplyVariables(_mapVariables, _pEffect);
+    }
+
+    string toString() const
+    {
+	  string str;
+	  MapVariables::const_iterator iterVars;
+	  for (iterVars = _mapVariables.begin(); iterVars != _mapVariables.end(); iterVars++)
+		str += iterVars->first + ":" + iterVars->second->toString() + " ";
+	  return str;
+	}
+};
+
+//////////// Joystick manager class ////////////////////////////////////////////////////////
+
+class JoystickManager
+{
+  protected:
+
+    // Input manager.
+    InputManager* _pInputMgr;
+
+    // Vectors to hold joysticks and associated force feedback devices
+    vector<JoyStick*> _vecJoys;
+    vector<ForceFeedback*> _vecFFDev;
+
+    // Selected joystick
+    int _nCurrJoyInd;
+
+    // Force feedback detected ?
+    bool _bFFFound;
+
+    // Selected joystick master gain.
+    float _dMasterGain;
+
+    // Selected joystick auto-center mode.
+    bool _bAutoCenter;
+
+  public:
+
+    JoystickManager(InputManager* pInputMgr, EventHandler* pEventHdlr)
+	: _pInputMgr(pInputMgr), _nCurrJoyInd(-1), _dMasterGain(0.5), _bAutoCenter(true)
+
+    {
+	  _bFFFound = false;
+	  for( int nJoyInd = 0; nJoyInd < pInputMgr->getNumberOfDevices(OISJoyStick); ++nJoyInd ) 
+	  {
+		//Create the stick
+		JoyStick* pJoy = (JoyStick*)pInputMgr->createInputObject( OISJoyStick, true );
+		cout << endl << "Created buffered joystick #" << nJoyInd << " '" << pJoy->vendor() 
+			 << "' (Id=" << pJoy->getID() << ")";
+		
+		// Check for FF, and if so, keep the joy and dump FF info
+		ForceFeedback* pFFDev = (ForceFeedback*)pJoy->queryInterface(Interface::ForceFeedback );
+		if( pFFDev )
+		{
+		  _bFFFound = true;
+
+		  // Keep the joy to play with it.
+		  pJoy->setEventCallback(pEventHdlr);
+		  _vecJoys.push_back(pJoy);
+
+		  // Keep also the associated FF device
+		  _vecFFDev.push_back(pFFDev);
+		  
+		  // Dump FF supported effects and other info.
+		  cout << endl << " * Number of force feedback axes : " 
+			   << pFFDev->getFFAxesNumber() << endl;
+		  const ForceFeedback::SupportedEffectList &lstFFEffects = 
+			pFFDev->getSupportedEffects();
+		  if (lstFFEffects.size() > 0)
+		  {
+			cout << " * Supported effects :";
+			ForceFeedback::SupportedEffectList::const_iterator itFFEff;
+			for(itFFEff = lstFFEffects.begin(); itFFEff != lstFFEffects.end(); ++itFFEff)
+			  cout << " " << Effect::getEffectTypeName(itFFEff->second);
+			cout << endl << endl;
+		  }
+		  else
+			cout << "Warning: no supported effect found !" << endl;
+		}
+		else
+		{
+		  cout << " (no force feedback support detected) => ignored." << endl << endl;
+		  _pInputMgr->destroyInputObject(pJoy);
+		}
+	  }
+	}
+
+    ~JoystickManager()
+    {
+	  for(size_t nJoyInd = 0; nJoyInd < _vecJoys.size(); ++nJoyInd)
+		_pInputMgr->destroyInputObject( _vecJoys[nJoyInd] );
+	}
+
+    size_t getNumberOfJoysticks() const
+    {
+	  return _vecJoys.size();
+	}
+
+    bool wasFFDetected() const
+    {
+	  return _bFFFound;
+	}
+
+	enum EWhichJoystick { ePrevious=-1, eNext=+1 };
+
+    void selectJoystick(EWhichJoystick eWhich)
+    {
+	  // Note: Reset the master gain to half the maximum and autocenter mode to Off,
+	  // when really selecting a new joystick.
+	  if (_nCurrJoyInd < 0)
+	  {
+		_nCurrJoyInd = 0;
+		_dMasterGain = 0.5; // Half the maximum.
+		changeMasterGain(0.0);
+	  }
+	  else
+	  {
+		_nCurrJoyInd += eWhich;
+		if (_nCurrJoyInd < -1 || _nCurrJoyInd >= (int)_vecJoys.size())
+		  _nCurrJoyInd = -1;
+		if (_vecJoys.size() > 1 && _nCurrJoyInd >= 0)
+		{
+		  _dMasterGain = 0.5; // Half the maximum.
+		  changeMasterGain(0.0);
+		}
+	  }
+	}
+
+    ForceFeedback* getCurrentFFDevice()
+    {
+	  return (_nCurrJoyInd >= 0) ? _vecFFDev[_nCurrJoyInd] : 0;
+	}
+
+    void changeMasterGain(float dDeltaPercent)
+    {
+	  if (_nCurrJoyInd >= 0)
+	  {
+		_dMasterGain += dDeltaPercent / 100;
+		if (_dMasterGain > 1.0)
+		  _dMasterGain = 1.0;
+		else if (_dMasterGain < 0.0)
+		  _dMasterGain = 0.0;
+		
+		_vecFFDev[_nCurrJoyInd]->setMasterGain(_dMasterGain);
+	  }
+	}
+
+    enum EAutoCenterHow { eOff, eOn, eToggle };
+
+    void changeAutoCenter(EAutoCenterHow eHow = eToggle)
+    {
+	  if (_nCurrJoyInd >= 0)
+	  {
+		if (eHow == eToggle)
+		  _bAutoCenter = !_bAutoCenter;
+		else
+		  _bAutoCenter = (eHow == eOn ? true : false);
+		_vecFFDev[_nCurrJoyInd]->setAutoCenterMode(_bAutoCenter);
+	  }
+	}
+
+    void captureEvents()
+    {
+	  // This fires off buffered events for each joystick we have
+	  for(size_t nJoyInd = 0; nJoyInd < _vecJoys.size(); ++nJoyInd)
+		if( _vecJoys[nJoyInd] )	
+		  _vecJoys[nJoyInd]->capture();
+	}
+
+    string toString() const
+    {
+	  // Warning: Wrong result if more than 10 joysticks ...
+	  ostringstream oss;
+	  oss << "Joy:" << (_nCurrJoyInd >= 0 ? (char)('0' + _nCurrJoyInd) : '-');
+	  oss << " Gain:" << setiosflags(ios_base::right) << setw(3) << (int)(_dMasterGain*100);
+	  oss << "% Center:" << (_bAutoCenter ? " On " : "Off");
+	  return oss.str();
+	}
+};
+
+//////////// Effect variables applier functions /////////////////////////////////////////////
+// These functions apply the given Variables to the given OIS::Effect
+
+// Variable force "Force" + optional "AttackFactor" constant, on a OIS::ConstantEffect
+void forceVariableApplier(MapVariables& mapVars, Effect* pEffect)
+{
+  double dForce = mapVars["Force"]->getValue();
+  double dAttackFactor = 1.0;
+  if (mapVars.find("AttackFactor") != mapVars.end())
+	dAttackFactor = mapVars["AttackFactor"]->getValue();
+
+  ConstantEffect* pConstForce = dynamic_cast<ConstantEffect*>(pEffect->getForceEffect());
+  pConstForce->level = (int)dForce;
+  pConstForce->envelope.attackLevel = (unsigned short)fabs(dForce*dAttackFactor);
+  pConstForce->envelope.fadeLevel = (unsigned short)fabs(dForce); // Fade never reached, in fact.
+}
+
+// Variable "Period" on an OIS::PeriodicEffect
+void periodVariableApplier(MapVariables& mapVars, Effect* pEffect)
+{
+  double dPeriod = mapVars["Period"]->getValue();
+
+  PeriodicEffect* pPeriodForce = dynamic_cast<PeriodicEffect*>(pEffect->getForceEffect());
+  pPeriodForce->period = (unsigned int)dPeriod;
+}
+
+
+//////////// Effect manager class //////////////////////////////////////////////////////////
+
+class EffectManager
+{
+  protected:
+
+    // The joystick manager
+    JoystickManager* _pJoystickMgr;
+
+    // Vector to hold variable effects
+    vector<VariableEffect*> _vecEffects;
+
+    // Selected effect
+    int _nCurrEffectInd;
+
+    // Update frequency (Hz)
+    unsigned int _nUpdateFreq;
+
+	// Indexes (in _vecEffects) of the variable effects that are playable by the selected joystick.
+	vector<size_t> _vecPlayableEffectInd;
+
+
+  public:
+
+    EffectManager(JoystickManager* pJoystickMgr, unsigned int nUpdateFreq) 
+	: _pJoystickMgr(pJoystickMgr), _nUpdateFreq(nUpdateFreq), _nCurrEffectInd(-1)
+    {
+	  Effect* pEffect;
+	  MapVariables mapVars;
+	  ConstantEffect* pConstForce;
+	  PeriodicEffect* pPeriodForce;
+
+	  // Please don't modify or remove effects (unless there is some bug ...) : 
+	  // add new ones to enhance the test repository.
+	  // And feel free to add any tested device, even when the test failed !
+	  // Tested devices capabilities :
+      // - Logitech G25 Racing wheel : 
+	  //   * Only 1 axis => no directional 2D effect (only left and right)
+	  //   * Full support for constant force under WinXPSP2DX9 and Linux 2.6.22.9
+	  //   * Full support for periodic forces under WinXPSP2DX9 
+	  //     (but poor rendering under 20ms period), and no support under Linux 2.6.22.9
+	  //   * Full support reported (not tested) for all other forces under WinXPSP2DX9, 
+	  //     and no support under Linux 2.6.22.9
+      // - Logitech Rumble pad 2 :
+	  //   * Only 1 axis => no directional 2D effect (only left and right)
+	  //   * Forces amplitude is rendered through the inertia motors rotation frequency
+	  //     (stronger force => quicker rotation)
+	  //   * 2 inertia motors : 1 with small inertia, 1 with "heavy" one.
+	  //     => poor force feedback rendering ...
+	  //   * Support (poor) for all OIS forces under WinXPSP2DX9,
+	  //      and only for Triangle, Square and Sine periodic forces under Linux 2.6.22.9
+	  //      (reported by enumeration, but does not seem to work actually)
+	  // Master gain setting tests:
+      // - Logitech G25 Racing wheel : WinXPSP2DX9=OK, Linux2.6.22.9=OK.
+      // - Logitech Rumble pad 2 : WinXPSP2DX9=OK, Linux2.6.22.9=OK.
+	  // Auto-center mode setting tests:
+      // - Logitech G25 Racing wheel : WinXPSP2DX9=Failed (DINPUT?), Linux2.6.22.9=Reported as not supported.
+      // - Logitech Rumble pad 2 : WinXPSP2DX9=Failed (DINPUT?), Linux2.6.22.9=Reported as not supported.
+
+	  // 1) Constant force on 1 axis with 20s-period triangle oscillations in [-10K, +10K].
+	  // Notes: Linux: replay_length: no way to get it to work if not 0 or Effect::OIS_INFINITE
+	  // Tested devices :
+      // - Logitech G25 Racing wheel : WinXPSP2DX9=OK, Linux2.6.22.9=OK.
+      // - Logitech Rumble pad 2 : WinXPSP2DX9=OK (but only light motor involved), 
+	  //                           Linux2.6.22.9=Not supported
+	  pEffect = new Effect(Effect::ConstantForce, Effect::Constant);
+	  pEffect->direction = Effect::North;
+	  pEffect->trigger_button = 0;
+	  pEffect->trigger_interval = 0;
+	  pEffect->replay_length = Effect::OIS_INFINITE; // Linux/Win32: Same behaviour as 0.
+	  pEffect->replay_delay = 0;
+	  pEffect->setNumAxes(1);
+	  pConstForce = dynamic_cast<ConstantEffect*>(pEffect->getForceEffect());
+	  pConstForce->level = 5000;  //-10K to +10k
+	  pConstForce->envelope.attackLength = 0;
+	  pConstForce->envelope.attackLevel = (unsigned short)pConstForce->level;
+	  pConstForce->envelope.fadeLength = 0;
+	  pConstForce->envelope.fadeLevel = (unsigned short)pConstForce->level;
+
+	  mapVars.clear();
+	  mapVars["Force"] = 
+		new TriangleVariable(0.0, // F0
+							 4*10000/_nUpdateFreq / 20.0, // dF for a 20s-period triangle
+							 -10000.0, // Fmin 
+							 10000.0); // Fmax
+	  mapVars["AttackFactor"] = new Constant(1.0);
+
+	  _vecEffects.push_back
+		(new VariableEffect
+		       ("Constant force on 1 axis with 20s-period triangle oscillations "
+				"of its signed amplitude in [-10K, +10K]",
+				pEffect, mapVars, forceVariableApplier));
+
+	  // 2) Constant force on 1 axis with noticeable attack 
+	  //    with 20s-period triangle oscillations in [-10K, +10K].
+	  // Tested devices :
+      // - Logitech G25 Racing wheel : WinXPSP2DX9=OK, Linux=OK.
+      // - Logitech Rumble pad 2 : WinXPSP2DX9=OK (including attack, but only light motor involved), 
+	  //                           Linux2.6.22.9=Not supported.
+	  pEffect = new Effect(Effect::ConstantForce, Effect::Constant);
+	  pEffect->direction = Effect::North;
+	  pEffect->trigger_button = 0;
+	  pEffect->trigger_interval = 0;
+	  pEffect->replay_length = Effect::OIS_INFINITE; //(unsigned int)(1000000.0/_nUpdateFreq); // Linux: Does not work.
+	  pEffect->replay_delay = 0;
+	  pEffect->setNumAxes(1);
+	  pConstForce = dynamic_cast<ConstantEffect*>(pEffect->getForceEffect());
+	  pConstForce->level = 5000;  //-10K to +10k
+	  pConstForce->envelope.attackLength = (unsigned int)(1000000.0/_nUpdateFreq/2);
+	  pConstForce->envelope.attackLevel = (unsigned short)(pConstForce->level*0.1);
+	  pConstForce->envelope.fadeLength = 0; // Never reached, actually.
+	  pConstForce->envelope.fadeLevel = (unsigned short)pConstForce->level; // Idem
+
+	  mapVars.clear();
+	  mapVars["Force"] = 
+		new TriangleVariable(0.0, // F0
+							 4*10000/_nUpdateFreq / 20.0, // dF for a 20s-period triangle
+							 -10000.0, // Fmin 
+							 10000.0); // Fmax
+	  mapVars["AttackFactor"] = new Constant(0.1);
+
+	  _vecEffects.push_back
+		(new VariableEffect
+		       ("Constant force on 1 axis with noticeable attack (app update period / 2)"
+				"and 20s-period triangle oscillations of its signed amplitude in [-10K, +10K]",
+				pEffect, mapVars, forceVariableApplier));
+
+	  // 3) Triangle periodic force on 1 axis with 40s-period triangle oscillations
+	  //    of its period in [10, 400] ms, and constant amplitude
+	  // Tested devices :
+      // - Logitech G25 Racing wheel : WinXPSP2DX9=OK, Linux=OK.
+      // - Logitech Rumble pad 2 : WinXPSP2DX9=OK but only light motor involved,
+	  //                           Linux2.6.22.9=Failed.
+	  pEffect = new Effect(Effect::PeriodicForce, Effect::Triangle);
+	  pEffect->direction = Effect::North;
+	  pEffect->trigger_button = 0;
+	  pEffect->trigger_interval = 0;
+	  pEffect->replay_length = Effect::OIS_INFINITE;
+	  pEffect->replay_delay = 0;
+	  pEffect->setNumAxes(1);
+	  pPeriodForce = dynamic_cast<PeriodicEffect*>(pEffect->getForceEffect());
+	  pPeriodForce->magnitude = 10000;  // 0 to +10k
+	  pPeriodForce->offset = 0;
+	  pPeriodForce->phase = 0;  // 0 to 35599
+	  pPeriodForce->period = 10000;  // Micro-seconds
+	  pPeriodForce->envelope.attackLength = 0;
+	  pPeriodForce->envelope.attackLevel = (unsigned short)pPeriodForce->magnitude;
+	  pPeriodForce->envelope.fadeLength = 0;
+	  pPeriodForce->envelope.fadeLevel = (unsigned short)pPeriodForce->magnitude;
+
+	  mapVars.clear();
+	  mapVars["Period"] = 
+		new TriangleVariable(1*1000.0, // P0
+							 4*(400-10)*1000.0/_nUpdateFreq / 40.0, // dP for a 40s-period triangle
+							 10*1000.0, // Pmin 
+							 400*1000.0); // Pmax
+	  _vecEffects.push_back
+		(new VariableEffect
+		       ("Periodic force on 1 axis with 40s-period triangle oscillations "
+				"of its period in [10, 400] ms, and constant amplitude",
+				pEffect, mapVars, periodVariableApplier));
+
+	}
+
+    ~EffectManager()
+    {
+	  vector<VariableEffect*>::iterator iterEffs;
+	  for (iterEffs = _vecEffects.begin(); iterEffs != _vecEffects.end(); iterEffs++)
+		delete *iterEffs;
+	}
+
+    void updateActiveEffects()
+    {
+	  vector<VariableEffect*>::iterator iterEffs;
+	  for (iterEffs = _vecEffects.begin(); iterEffs != _vecEffects.end(); iterEffs++)
+		if ((*iterEffs)->isActive())
+		{
+		  (*iterEffs)->update();
+		  _pJoystickMgr->getCurrentFFDevice()->modify((*iterEffs)->getFFEffect());
+		}
+	}
+
+    void checkPlayableEffects()
+    {
+	  // Nothing to do if no joystick currently selected
+	  if (!_pJoystickMgr->getCurrentFFDevice())
+		return;
+
+	  // Get the list of indexes of effects that the selected device can play
+	  _vecPlayableEffectInd.clear();
+	  for (size_t nEffInd = 0; nEffInd < _vecEffects.size(); nEffInd++)
+	  {
+		const Effect::EForce eForce = _vecEffects[nEffInd]->getFFEffect()->force;
+		const Effect::EType eType = _vecEffects[nEffInd]->getFFEffect()->type;
+		if (_pJoystickMgr->getCurrentFFDevice()->supportsEffect(eForce, eType))
+		{
+		  _vecPlayableEffectInd.push_back(nEffInd);
+		}
+	  }
+
+	  // Print details about playable effects
+	  if (_vecPlayableEffectInd.empty())
+	  {
+		cout << endl << endl << "The device can't play any effect of the test set" << endl;
+	  }
+	  else
+	  {
+		cout << endl << endl << "Selected device can play the following effects :" << endl;
+		for (size_t nEffIndInd = 0; nEffIndInd < _vecPlayableEffectInd.size(); nEffIndInd++)
+			printEffect(_vecPlayableEffectInd[nEffIndInd]);
+		cout << endl;
+	  }
+	}
+
+    enum EWhichEffect { ePrevious=-1, eNone=0, eNext=+1 };
+
+    void selectEffect(EWhichEffect eWhich)
+    {
+
+	  // Nothing to do if no joystick currently selected
+	  if (!_pJoystickMgr->getCurrentFFDevice())
+	  {
+		  cout << "\nNo Joystick selected.\n";  
+		return;
+	  }
+
+	  // Nothing to do if joystick cannot play any effect
+	  if (_vecPlayableEffectInd.empty())
+	  {
+		  cout << "\nNo playable effects.\n"; 
+		return;
+	  }
+
+	  // If no effect selected, and next or previous requested, select the first one.
+	  if (eWhich != eNone && _nCurrEffectInd < 0)
+		_nCurrEffectInd = 0;
+
+	  // Otherwise, remove the current one from the device, 
+	  // and then select the requested one if any.
+	  else if (_nCurrEffectInd >= 0)
+	  {
+		_pJoystickMgr->getCurrentFFDevice()
+		  ->remove(_vecEffects[_vecPlayableEffectInd[_nCurrEffectInd]]->getFFEffect());
+		_vecEffects[_vecPlayableEffectInd[_nCurrEffectInd]]->setActive(false);
+		_nCurrEffectInd += eWhich;
+		if (_nCurrEffectInd < -1 || _nCurrEffectInd >= (int)_vecPlayableEffectInd.size())
+		  _nCurrEffectInd = -1;
+	  }
+
+	  // If no effect must be selected, reset the selection index
+	  if (eWhich == eNone)
+	  {
+		_nCurrEffectInd = -1;
+	  }
+
+	  // Otherwise, upload the new selected effect to the device if any.
+	  else if (_nCurrEffectInd >= 0)
+	  {
+		_vecEffects[_vecPlayableEffectInd[_nCurrEffectInd]]->setActive(true);
+		_pJoystickMgr->getCurrentFFDevice()
+		  ->upload(_vecEffects[_vecPlayableEffectInd[_nCurrEffectInd]]->getFFEffect());
+	  }
+	}
+
+    void printEffect(size_t nEffInd)
+    {
+	  cout << "* #" << nEffInd << " : " << _vecEffects[nEffInd]->getDescription() << endl;
+	}
+
+    void printEffects()
+    {
+	  for (size_t nEffInd = 0; nEffInd < _vecEffects.size(); nEffInd++)
+		  printEffect(nEffInd);
+	}
+
+    string toString() const
+    {
+	  ostringstream oss;
+	  oss << "DevMem: " << setiosflags(ios_base::right) << setw(3);
+
+	  //This causes constant exceptions with my device. Not needed for anything other than debugging
+		//if (_pJoystickMgr->getCurrentFFDevice())
+		//	oss << _pJoystickMgr->getCurrentFFDevice()->getFFMemoryLoad() << "%";
+		//else
+		//	oss << "----";
+	  
+		oss << " Effect:" << setw(2);
+	  if (_nCurrEffectInd >= 0)
+		oss << _vecPlayableEffectInd[_nCurrEffectInd] 
+			<< " " << _vecEffects[_vecPlayableEffectInd[_nCurrEffectInd]]->toString();
+	  else
+		oss << "--";
+	  return oss.str();
+	}
+};
+
+//////////// Application class ////////////////////////////////////////////////////////
+
+class Application
+{
+  protected:
+    InputManager*    _pInputMgr;
+    EventHandler*    _pEventHdlr;
+    Keyboard*        _pKeyboard;
+    JoystickManager* _pJoystickMgr;
+	EffectManager*   _pEffectMgr;
+
+#if defined OIS_WIN32_PLATFORM
+    HWND             _hWnd;
+#elif defined OIS_LINUX_PLATFORM
+    Display*         _pXDisp;
+    Window           _xWin;
+#endif
+
+    bool             _bMustStop;
+    bool             _bIsInitialized;
+
+    int _nStatus;
+
+    // App. hart beat frequency.
+    static const unsigned int _nHartBeatFreq = 20; // Hz
+
+    // Effects update frequency (Hz) : Needs to be quite lower than app. hart beat frequency,
+	// if we want to be able to calmly study effect changes ...
+    static const unsigned int _nEffectUpdateFreq = 1; // Hz
+
+  public:
+
+    Application(int argc, const char* argv[])
+    {
+	  _pInputMgr = 0;
+	  _pEventHdlr = 0;
+	  _pKeyboard = 0;
+	  _pJoystickMgr = 0;
+	  _pEffectMgr = 0;
+
+#if defined OIS_WIN32_PLATFORM
+	  _hWnd = 0;
+#elif defined OIS_LINUX_PLATFORM
+	  _pXDisp = 0;
+	  _xWin = 0;
+#endif
+
+	  _bMustStop = false;
+
+	  _bIsInitialized = false;
+	  _nStatus = 0;
+	}
+
+    int initialize()
+    {
+	  ostringstream wnd;
+
+#if defined OIS_WIN32_PLATFORM
+
+	  //Create a capture window for Input Grabbing
+	  _hWnd = CreateDialog( 0, MAKEINTRESOURCE(IDD_DIALOG1), 0,(DLGPROC)DlgProc);
+	  if( _hWnd == NULL )
+		OIS_EXCEPT(E_General, "Failed to create Win32 Window Dialog!");
+
+	  ShowWindow(_hWnd, SW_SHOW);
+
+	  wnd << (size_t)_hWnd; 
+
+#elif defined OIS_LINUX_PLATFORM
+
+	  //Connects to default X window
+	  if( !(_pXDisp = XOpenDisplay(0)) )
+		OIS_EXCEPT(E_General, "Error opening X!");
+
+	  //Create a window
+	  _xWin = XCreateSimpleWindow(_pXDisp,DefaultRootWindow(_pXDisp), 0,0, 100,100, 0, 0, 0);
+
+	  //bind our connection to that window
+	  XMapWindow(_pXDisp, _xWin);
+
+	  //Select what events we want to listen to locally
+	  XSelectInput(_pXDisp, _xWin, StructureNotifyMask);
+
+	  //Wait for Window to show up
+	  XEvent event;
+	  do {	XNextEvent(_pXDisp, &event); } while(event.type != MapNotify);
+
+	  wnd << _xWin;
+
+#endif
+
+	  // Create OIS input manager
+	  ParamList pl;
+	  pl.insert(make_pair(string("WINDOW"), wnd.str()));
+	  _pInputMgr = InputManager::createInputSystem(pl);
+	  cout << _pInputMgr->inputSystemName() << " created." << endl;
+
+	  // Create the event handler.
+	  _pEventHdlr = new EventHandler(this);
+
+	  // Create a simple keyboard
+	  _pKeyboard = (Keyboard*)_pInputMgr->createInputObject( OISKeyboard, true );
+	  _pKeyboard->setEventCallback( _pEventHdlr );
+
+	  // Create the joystick manager.
+	  _pJoystickMgr = new JoystickManager(_pInputMgr, _pEventHdlr);
+	  if( !_pJoystickMgr->wasFFDetected() )
+	  {
+		cout << "No Force Feedback device detected." << endl;
+		_nStatus = 1;
+		return _nStatus;
+	  }
+
+	  // Create force feedback effect manager.
+	  _pEffectMgr = new EffectManager(_pJoystickMgr, _nEffectUpdateFreq);
+
+	  // Initialize the event handler.
+	  _pEventHdlr->initialize(_pJoystickMgr, _pEffectMgr);
+
+	  _bIsInitialized = true;
+
+	  return _nStatus;
+	}
+
+#if defined OIS_LINUX_PLATFORM
+
+    // This is just here to show that you still receive x11 events, 
+    // as the lib only needs mouse/key events
+    void checkX11Events()
+    {
+	  XEvent event;
+	  
+	  //Poll x11 for events
+	  while( XPending(_pXDisp) > 0 )
+	  {
+		XNextEvent(_pXDisp, &event);
+	  }
+	}
+#endif
+
+    int run()
+    {
+	  const unsigned int nMaxEffectUpdateCnt = _nHartBeatFreq / _nEffectUpdateFreq;
+	  unsigned int nEffectUpdateCnt = 0;
+
+	  // Initailize app. if not already done, and exit if something went wrong.
+	  if (!_bIsInitialized)
+		initialize();
+
+	  if (!_bIsInitialized)
+		return _nStatus;
+
+	  try
+	  {
+		//Main polling loop
+		while(!_bMustStop)
+		{
+		  // This fires off buffered events for keyboards
+		  _pKeyboard->capture();
+
+		  // This fires off buffered events for each joystick we have
+		  _pJoystickMgr->captureEvents();
+
+		  // Update currently selected effects if time has come to.
+		  if (!nEffectUpdateCnt)
+		  {
+			_pEffectMgr->updateActiveEffects();
+			nEffectUpdateCnt = nMaxEffectUpdateCnt;
+		  }
+		  else
+			nEffectUpdateCnt--;
+
+		  // Update state line.
+		  cout << "\r" << _pJoystickMgr->toString() << " " << _pEffectMgr->toString()
+			   << "                           ";
+
+		  //Throttle down CPU usage & handle OS events
+#if defined OIS_WIN32_PLATFORM
+		  Sleep( (DWORD)(1000.0/_nHartBeatFreq) );
+		  MSG msg;
+		  while( PeekMessage( &msg, NULL, 0U, 0U, PM_REMOVE ) )
+		  {
+			TranslateMessage( &msg );
+			DispatchMessage( &msg );
+		  }
+#elif defined OIS_LINUX_PLATFORM
+		  checkX11Events();
+		  usleep(1000000.0/_nHartBeatFreq);
+#endif
+		}
+	  }
+	  catch( const Exception &ex )
+	  {
+#if defined OIS_WIN32_PLATFORM
+		MessageBox(0, ex.eText, "Exception Raised!", MB_OK);
+#else
+		cout << endl << "OIS Exception Caught!" << endl 
+			 << "\t" << ex.eText << "[Line " << ex.eLine << " in " << ex.eFile << "]" << endl;
+#endif
+	  }
+
+	  terminate();
+
+	  return _nStatus;
+	}
+
+    void stop()
+    {
+	  _bMustStop = true;
+	}
+
+    void terminate()
+    {
+	  if (_pInputMgr)
+	  {
+		_pInputMgr->destroyInputObject( _pKeyboard );
+		_pKeyboard = 0;
+		if (_pJoystickMgr)
+		{
+		  delete _pJoystickMgr;
+		  _pJoystickMgr = 0;
+		}
+		InputManager::destroyInputSystem(_pInputMgr);
+		_pInputMgr = 0;
+	  }
+	  if (_pEffectMgr)
+	  {
+		delete _pEffectMgr;
+		_pEffectMgr = 0;
+	  }
+	  if (_pEventHdlr)
+	  {
+		delete _pEventHdlr;
+		_pEventHdlr = 0;
+	  }
+
+#if defined OIS_LINUX_PLATFORM
+	  // Be nice to X and clean up the x window
+	  XDestroyWindow(_pXDisp, _xWin);
+	  XCloseDisplay(_pXDisp);
+#endif
+	}
+
+    JoystickManager* getJoystickManager()
+    {
+	  return _pJoystickMgr;
+	}
+
+    EffectManager* getEffectManager()
+    {
+	  return _pEffectMgr;
+	}
+
+	void printHelp()
+	{
+	  cout << endl
+		   << "Keyboard actions :" << endl
+		   << "* Escape      : Exit App" << endl
+		   << "* H           : This help menu" << endl
+		   << "* Right/Left  : Select next/previous joystick among the FF capable detected ones" << endl
+		   << "* Up/Down     : Select next/previous effect for the selected joystick" << endl
+		   << "* PgUp/PgDn   : Increase/decrease from 5% the master gain "
+		   <<                  "for all the joysticks" << endl
+		   << "* Space       : Toggle auto-centering on all the joysticks" << endl;
+	  if (_bIsInitialized)
+	  {
+		cout << endl << "Implemented effects :" << endl << endl;
+		_pEffectMgr->printEffects();
+		cout << endl;
+	  }
+	}
+};
+
+//////////// Event handler class definition ////////////////////////////////////////////////
+
+EventHandler::EventHandler(Application* pApp)
+: _pApplication(pApp)
+{}
+
+void EventHandler::initialize(JoystickManager* pJoystickMgr, EffectManager* pEffectMgr)
+{
+  _pJoystickMgr = pJoystickMgr;
+  _pEffectMgr = pEffectMgr;
+}
+
+bool EventHandler::keyPressed( const KeyEvent &arg )
+{
+  switch (arg.key)
+  {
+	// Quit.
+	case KC_ESCAPE:
+	  _pApplication->stop();
+	  break;
+	  
+	// Help.
+	case KC_H:
+	  _pApplication->printHelp();
+	  break;
+	  
+	// Change current joystick.
+	case KC_RIGHT:
+	  _pEffectMgr->selectEffect(EffectManager::eNone);
+	  _pJoystickMgr->selectJoystick(JoystickManager::eNext);
+	  _pEffectMgr->checkPlayableEffects();
+	  break;
+	case KC_LEFT:
+	  _pEffectMgr->selectEffect(EffectManager::eNone);
+	  _pJoystickMgr->selectJoystick(JoystickManager::ePrevious);
+	  _pEffectMgr->checkPlayableEffects();
+	  break;
+
+	// Change current effect.
+	case KC_UP:
+	  _pEffectMgr->selectEffect(EffectManager::eNext);
+	  break;
+	case KC_DOWN:
+	  _pEffectMgr->selectEffect(EffectManager::ePrevious);
+	  break;
+
+	// Change current master gain.
+	case KC_PGUP:
+	  _pJoystickMgr->changeMasterGain(5.0); // Percent
+	  break;
+	case KC_PGDOWN:
+	  _pJoystickMgr->changeMasterGain(-5.0); // Percent
+	  break;
+	  
+	// Toggle auto-center mode.
+	case KC_SPACE:
+	  _pJoystickMgr->changeAutoCenter();
+	  break;
+	  
+	default:
+	  cout << "Non mapped key: " << arg.key << endl;
+  }
+  return true;
+}
+
+bool EventHandler::keyReleased( const KeyEvent &arg )
+{
+  return true;
+}
+
+bool EventHandler::buttonPressed( const JoyStickEvent &arg, int button )
+{
+  return true;
+}
+bool EventHandler::buttonReleased( const JoyStickEvent &arg, int button )
+{
+  return true;
+}
+bool EventHandler::axisMoved( const JoyStickEvent &arg, int axis )
+{
+  return true;
+}
+bool EventHandler::povMoved( const JoyStickEvent &arg, int pov )
+{
+  return true;
+}
+
+//==========================================================================================
+int main(int argc, const char* argv[])
+{
+
+  cout << endl 
+	   << "This is a simple command line Force Feedback testing demo ..." << endl
+	   << "All connected joystick devices will be created and if FF Support is found," << endl
+	   << "you'll be able to play some predefined variable effects on them." << endl << endl
+	   << "Note: 1 effect can be played on 1 joystick at a time for the moment." << endl << endl;
+
+  Application app(argc, argv);
+  
+  int status = app.initialize();
+
+  if (!status)
+  {
+	app.printHelp();
+
+	status = app.run();
+  }
+  
+  cout << endl << endl << "Exiting ..." << endl << endl;
+
+#if defined OIS_WIN32_PLATFORM && _DEBUG
+  cout << "Click on this window and ..." << endl;
+  system("pause");
+#endif
+
+  exit(status);
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/demos/Makefile.am b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/demos/Makefile.am
new file mode 100644
index 0000000..690e81e
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/demos/Makefile.am
@@ -0,0 +1,11 @@
+INCLUDES = $(STLPORT_CFLAGS) -I$(top_srcdir)/includes $(CFLAGS) -I/usr/X11R6/include
+
+noinst_PROGRAMS = ConsoleApp FFConsoleTest
+
+ConsoleApp_SOURCES = OISConsole.cpp
+ConsoleApp_LDFLAGS = -L$(top_builddir)/src
+ConsoleApp_LDADD = -lOIS
+
+FFConsoleTest_SOURCES = FFConsoleDemo.cpp
+FFConsoleTest_LDFLAGS = -L$(top_builddir)/src
+FFConsoleTest_LDADD = -lOIS
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/demos/OISConsole.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/demos/OISConsole.cpp
new file mode 100644
index 0000000..2d984b6
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/demos/OISConsole.cpp
@@ -0,0 +1,469 @@
+//////////////////////////////// OS Nuetral Headers ////////////////
+#include "OISInputManager.h"
+#include "OISException.h"
+#include "OISKeyboard.h"
+#include "OISMouse.h"
+#include "OISJoyStick.h"
+#include "OISEvents.h"
+
+//Advanced Usage
+#include "OISForceFeedback.h"
+
+#include <iostream>
+#include <vector>
+#include <sstream>
+
+////////////////////////////////////Needed Windows Headers////////////
+#if defined OIS_WIN32_PLATFORM
+#define WIN32_LEAN_AND_MEAN
+#include "windows.h"
+#ifdef min
+#undef min
+#endif
+#include "resource.h"
+LRESULT DlgProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
+//////////////////////////////////////////////////////////////////////
+////////////////////////////////////Needed Linux Headers//////////////
+#elif defined OIS_LINUX_PLATFORM
+#include <X11/Xlib.h>
+#include <X11/Xatom.h>
+void checkX11Events();
+//////////////////////////////////////////////////////////////////////
+////////////////////////////////////Needed Mac Headers//////////////
+#elif defined OIS_APPLE_PLATFORM
+#include <Carbon/Carbon.h>
+void checkMacEvents();
+#endif
+//////////////////////////////////////////////////////////////////////
+using namespace OIS;
+
+//-- Some local prototypes --//
+void doStartup();
+void handleNonBufferedKeys();
+void handleNonBufferedMouse();
+void handleNonBufferedJoy( JoyStick* js );
+
+//-- Easy access globals --//
+bool appRunning = true;				//Global Exit Flag
+
+const char *g_DeviceType[6] = {"OISUnknown", "OISKeyboard", "OISMouse", "OISJoyStick",
+							 "OISTablet", "OISOther"};
+
+InputManager *g_InputManager = 0;	//Our Input System
+Keyboard *g_kb  = 0;				//Keyboard Device
+Mouse	 *g_m   = 0;				//Mouse Device
+JoyStick* g_joys[4] = {0,0,0,0};	//This demo supports up to 4 controllers
+
+//-- OS Specific Globals --//
+#if defined OIS_WIN32_PLATFORM
+  HWND hWnd = 0;
+#elif defined OIS_LINUX_PLATFORM
+  Display *xDisp = 0;
+  Window xWin = 0;
+#elif defined OIS_APPLE_PLATFORM
+  WindowRef mWin = 0;
+#endif
+
+//////////// Common Event handler class ////////
+class EventHandler : public KeyListener, public MouseListener, public JoyStickListener
+{
+public:
+	EventHandler() {}
+	~EventHandler() {}
+	bool keyPressed( const KeyEvent &arg ) {
+		std::cout << " KeyPressed {" << arg.key
+			<< ", " << ((Keyboard*)(arg.device))->getAsString(arg.key)
+			<< "} || Character (" << (char)arg.text << ")" << std::endl;
+		return true;
+	}
+	bool keyReleased( const KeyEvent &arg ) {
+		if( arg.key == KC_ESCAPE || arg.key == KC_Q )
+			appRunning = false;
+		std::cout << "KeyReleased {" << ((Keyboard*)(arg.device))->getAsString(arg.key) << "}\n";
+		return true;
+	}
+	bool mouseMoved( const MouseEvent &arg ) {
+		const OIS::MouseState& s = arg.state;
+		std::cout << "\nMouseMoved: Abs("
+				  << s.X.abs << ", " << s.Y.abs << ", " << s.Z.abs << ") Rel("
+				  << s.X.rel << ", " << s.Y.rel << ", " << s.Z.rel << ")";
+		return true;
+	}
+	bool mousePressed( const MouseEvent &arg, MouseButtonID id ) {
+		const OIS::MouseState& s = arg.state;
+		std::cout << "\nMouse button #" << id << " pressed. Abs("
+				  << s.X.abs << ", " << s.Y.abs << ", " << s.Z.abs << ") Rel("
+				  << s.X.rel << ", " << s.Y.rel << ", " << s.Z.rel << ")";
+		return true;
+	}
+	bool mouseReleased( const MouseEvent &arg, MouseButtonID id ) {
+		const OIS::MouseState& s = arg.state;
+		std::cout << "\nMouse button #" << id << " released. Abs("
+				  << s.X.abs << ", " << s.Y.abs << ", " << s.Z.abs << ") Rel("
+				  << s.X.rel << ", " << s.Y.rel << ", " << s.Z.rel << ")";
+		return true;
+	}
+	bool buttonPressed( const JoyStickEvent &arg, int button ) {
+		std::cout << std::endl << arg.device->vendor() << ". Button Pressed # " << button;
+		return true;
+	}
+	bool buttonReleased( const JoyStickEvent &arg, int button ) {
+		std::cout << std::endl << arg.device->vendor() << ". Button Released # " << button;
+		return true;
+	}
+	bool axisMoved( const JoyStickEvent &arg, int axis )
+	{
+		//Provide a little dead zone
+		if( arg.state.mAxes[axis].abs > 2500 || arg.state.mAxes[axis].abs < -2500 )
+			std::cout << std::endl << arg.device->vendor() << ". Axis # " << axis << " Value: " << arg.state.mAxes[axis].abs;
+		return true;
+	}
+	bool povMoved( const JoyStickEvent &arg, int pov )
+	{
+		std::cout << std::endl << arg.device->vendor() << ". POV" << pov << " ";
+
+		if( arg.state.mPOV[pov].direction & Pov::North ) //Going up
+			std::cout << "North";
+		else if( arg.state.mPOV[pov].direction & Pov::South ) //Going down
+			std::cout << "South";
+
+		if( arg.state.mPOV[pov].direction & Pov::East ) //Going right
+			std::cout << "East";
+		else if( arg.state.mPOV[pov].direction & Pov::West ) //Going left
+			std::cout << "West";
+
+		if( arg.state.mPOV[pov].direction == Pov::Centered ) //stopped/centered out
+			std::cout << "Centered";
+		return true;
+	}
+
+	bool vector3Moved( const JoyStickEvent &arg, int index)
+	{
+		std::cout.precision(2);
+		std::cout.flags(std::ios::fixed | std::ios::right);
+		std::cout << std::endl << arg.device->vendor() << ". Orientation # " << index 
+			<< " X Value: " << arg.state.mVectors[index].x
+			<< " Y Value: " << arg.state.mVectors[index].y
+			<< " Z Value: " << arg.state.mVectors[index].z;
+		std::cout.precision();
+		std::cout.flags();
+		return true;
+	}
+};
+
+//Create a global instance
+EventHandler handler;
+
+int main()
+{
+	std::cout << "\n\n*** OIS Console Demo App is starting up... *** \n";
+	try
+	{
+		doStartup();
+		std::cout << "\nStartup done... Hit 'q' or ESC to exit.\n\n";
+
+		while(appRunning)
+		{
+			//Throttle down CPU usage
+			#if defined OIS_WIN32_PLATFORM
+			  Sleep(90);
+			  MSG  msg;
+			  while( PeekMessage( &msg, NULL, 0U, 0U, PM_REMOVE ) )
+			  {
+				TranslateMessage( &msg );
+				DispatchMessage( &msg );
+			  }
+			#elif defined OIS_LINUX_PLATFORM
+			  checkX11Events();
+			  usleep( 500 );
+            #elif defined OIS_APPLE_PLATFORM
+			  checkMacEvents();
+			  usleep( 500 );
+			#endif
+
+			if( g_kb )
+			{
+				g_kb->capture();
+				if( !g_kb->buffered() )
+					handleNonBufferedKeys();
+			}
+
+			if( g_m )
+			{
+				g_m->capture();
+				if( !g_m->buffered() )
+					handleNonBufferedMouse();
+			}
+
+			for( int i = 0; i < 4 ; ++i )
+			{
+				if( g_joys[i] )
+				{
+					g_joys[i]->capture();
+					if( !g_joys[i]->buffered() )
+						handleNonBufferedJoy( g_joys[i] );
+				}
+			}
+		}
+	}
+	catch( const Exception &ex )
+	{
+		#if defined OIS_WIN32_PLATFORM
+		  MessageBox( NULL, ex.eText, "An exception has occurred!", MB_OK |
+				MB_ICONERROR | MB_TASKMODAL);
+		#else
+		  std::cout << "\nOIS Exception Caught!\n" << "\t" << ex.eText << "[Line "
+			<< ex.eLine << " in " << ex.eFile << "]\nExiting App";
+		#endif
+	}
+	catch(std::exception &ex)
+	{
+		std::cout << "Caught std::exception: what = " << ex.what() << std::endl;
+	}
+
+	//Destroying the manager will cleanup unfreed devices
+	std::cout << "Cleaning up...\n";
+	if( g_InputManager )
+		InputManager::destroyInputSystem(g_InputManager);
+
+#if defined OIS_LINUX_PLATFORM
+	// Be nice to X and clean up the x window
+	XDestroyWindow(xDisp, xWin);
+	XCloseDisplay(xDisp);
+#endif
+
+	std::cout << "\nGoodbye!\n";
+	return 0;
+}
+
+void doStartup()
+{
+	ParamList pl;
+
+#if defined OIS_WIN32_PLATFORM
+	//Create a capture window for Input Grabbing
+	hWnd = CreateDialog( 0, MAKEINTRESOURCE(IDD_DIALOG1), 0,(DLGPROC)DlgProc);
+	if( hWnd == NULL )
+		OIS_EXCEPT(E_General, "Failed to create Win32 Window Dialog!");
+
+	ShowWindow(hWnd, SW_SHOW);
+
+	std::ostringstream wnd;
+	wnd << (size_t)hWnd;
+
+	pl.insert(std::make_pair( std::string("WINDOW"), wnd.str() ));
+
+	//Default mode is foreground exclusive..but, we want to show mouse - so nonexclusive
+//	pl.insert(std::make_pair(std::string("w32_mouse"), std::string("DISCL_FOREGROUND" )));
+//	pl.insert(std::make_pair(std::string("w32_mouse"), std::string("DISCL_NONEXCLUSIVE")));
+#elif defined OIS_LINUX_PLATFORM
+	//Connects to default X window
+	if( !(xDisp = XOpenDisplay(0)) )
+		OIS_EXCEPT(E_General, "Error opening X!");
+	//Create a window
+	xWin = XCreateSimpleWindow(xDisp, DefaultRootWindow(xDisp), 0, 0, 100, 100, 0, 0, 0);
+	//bind our connection to that window
+	XMapWindow(xDisp, xWin);
+	// XInternAtom
+	//Select what events we want to listen to locally
+	XSelectInput(xDisp, xWin, StructureNotifyMask | SubstructureNotifyMask);
+	Atom wmProto = XInternAtom(xDisp, "WM_PROTOCOLS", False);
+	Atom wmDelete = XInternAtom(xDisp, "WM_DELETE_WINDOW", False);
+	XChangeProperty(xDisp, xWin, wmProto, XA_ATOM, 32, 0, (const unsigned char*)&wmDelete, 1);
+	XEvent evtent;
+	do
+	{
+		XNextEvent(xDisp, &evtent);
+	} while(evtent.type != MapNotify);
+
+	std::ostringstream wnd;
+	wnd << xWin;
+
+	pl.insert(std::make_pair(std::string("WINDOW"), wnd.str()));
+
+	//For this demo, show mouse and do not grab (confine to window)
+//	pl.insert(std::make_pair(std::string("x11_mouse_grab"), std::string("false")));
+//	pl.insert(std::make_pair(std::string("x11_mouse_hide"), std::string("false")));
+#elif defined OIS_APPLE_PLATFORM
+    // create the window rect in global coords
+    ::Rect windowRect;
+    windowRect.left = 0;
+    windowRect.top = 0;
+    windowRect.right = 300;
+    windowRect.bottom = 300;
+    
+    // set the default attributes for the window
+    WindowAttributes windowAttrs = kWindowStandardDocumentAttributes
+        | kWindowStandardHandlerAttribute 
+        | kWindowInWindowMenuAttribute
+        | kWindowHideOnFullScreenAttribute;
+    
+    // Create the window
+    CreateNewWindow(kDocumentWindowClass, windowAttrs, &windowRect, &mWin);
+    
+    // Color the window background black
+    SetThemeWindowBackground (mWin, kThemeBrushBlack, true);
+    
+    // Set the title of our window
+    CFStringRef titleRef = CFStringCreateWithCString( kCFAllocatorDefault, "OIS Input", kCFStringEncodingASCII );
+    SetWindowTitleWithCFString( mWin, titleRef );
+    
+    // Center our window on the screen
+    RepositionWindow( mWin, NULL, kWindowCenterOnMainScreen );
+    
+    // Install the event handler for the window
+    InstallStandardEventHandler(GetWindowEventTarget(mWin));
+    
+    // This will give our window focus, and not lock it to the terminal
+    ProcessSerialNumber psn = { 0, kCurrentProcess };
+    TransformProcessType( &psn, kProcessTransformToForegroundApplication );
+	SetFrontProcess(&psn);
+    
+    // Display and select our window
+    ShowWindow(mWin);
+    SelectWindow(mWin);
+
+    std::ostringstream wnd;
+	wnd << (unsigned int)mWin; //cast to int so it gets encoded correctly (else it gets stored as a hex string)
+    std::cout << "WindowRef: " << mWin << " WindowRef as int: " << wnd.str() << "\n";
+	pl.insert(std::make_pair(std::string("WINDOW"), wnd.str()));
+#endif
+
+	//This never returns null.. it will raise an exception on errors
+	g_InputManager = InputManager::createInputSystem(pl);
+
+	//Lets enable all addons that were compiled in:
+	g_InputManager->enableAddOnFactory(InputManager::AddOn_All);
+
+	//Print debugging information
+	unsigned int v = g_InputManager->getVersionNumber();
+	std::cout << "OIS Version: " << (v>>16 ) << "." << ((v>>8) & 0x000000FF) << "." << (v & 0x000000FF)
+		<< "\nRelease Name: " << g_InputManager->getVersionName()
+		<< "\nManager: " << g_InputManager->inputSystemName()
+		<< "\nTotal Keyboards: " << g_InputManager->getNumberOfDevices(OISKeyboard)
+		<< "\nTotal Mice: " << g_InputManager->getNumberOfDevices(OISMouse)
+		<< "\nTotal JoySticks: " << g_InputManager->getNumberOfDevices(OISJoyStick);
+
+	//List all devices
+	DeviceList list = g_InputManager->listFreeDevices();
+	for( DeviceList::iterator i = list.begin(); i != list.end(); ++i )
+		std::cout << "\n\tDevice: " << g_DeviceType[i->first] << " Vendor: " << i->second;
+
+	g_kb = (Keyboard*)g_InputManager->createInputObject( OISKeyboard, true );
+	g_kb->setEventCallback( &handler );
+
+	g_m = (Mouse*)g_InputManager->createInputObject( OISMouse, true );
+	g_m->setEventCallback( &handler );
+	const MouseState &ms = g_m->getMouseState();
+	ms.width = 100;
+	ms.height = 100;
+
+	try
+	{
+		//This demo uses at most 4 joysticks - use old way to create (i.e. disregard vendor)
+		int numSticks = std::min(g_InputManager->getNumberOfDevices(OISJoyStick), 4);
+		for( int i = 0; i < numSticks; ++i )
+		{
+			g_joys[i] = (JoyStick*)g_InputManager->createInputObject( OISJoyStick, true );
+			g_joys[i]->setEventCallback( &handler );
+			std::cout << "\n\nCreating Joystick " << (i + 1)
+				<< "\n\tAxes: " << g_joys[i]->getNumberOfComponents(OIS_Axis)
+				<< "\n\tSliders: " << g_joys[i]->getNumberOfComponents(OIS_Slider)
+				<< "\n\tPOV/HATs: " << g_joys[i]->getNumberOfComponents(OIS_POV)
+				<< "\n\tButtons: " << g_joys[i]->getNumberOfComponents(OIS_Button)
+				<< "\n\tVector3: " << g_joys[i]->getNumberOfComponents(OIS_Vector3);
+		}
+	}
+	catch(OIS::Exception &ex)
+	{
+		std::cout << "\nException raised on joystick creation: " << ex.eText << std::endl;
+	}
+}
+
+void handleNonBufferedKeys()
+{
+	if( g_kb->isKeyDown( KC_ESCAPE ) || g_kb->isKeyDown( KC_Q ) )
+		appRunning = false;
+
+	if( g_kb->isModifierDown(Keyboard::Shift) )
+		std::cout << "Shift is down..\n";
+	if( g_kb->isModifierDown(Keyboard::Alt) )
+		std::cout << "Alt is down..\n";
+	if( g_kb->isModifierDown(Keyboard::Ctrl) )
+		std::cout << "Ctrl is down..\n";
+}
+
+void handleNonBufferedMouse()
+{
+	//Just dump the current mouse state
+	const MouseState &ms = g_m->getMouseState();
+	std::cout << "\nMouse: Abs(" << ms.X.abs << " " << ms.Y.abs << " " << ms.Z.abs
+		<< ") B: " << ms.buttons << " Rel(" << ms.X.rel << " " << ms.Y.rel << " " << ms.Z.rel << ")";
+}
+
+void handleNonBufferedJoy( JoyStick* js )
+{
+	//Just dump the current joy state
+	const JoyStickState &joy = js->getJoyStickState();
+	for( unsigned int i = 0; i < joy.mAxes.size(); ++i )
+		std::cout << "\nAxis " << i << " X: " << joy.mAxes[i].abs;
+}
+
+#if defined OIS_WIN32_PLATFORM
+LRESULT DlgProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
+{
+	return FALSE;
+}
+#endif
+
+#if defined OIS_LINUX_PLATFORM
+//This is just here to show that you still recieve x11 events, as the lib only needs mouse/key events
+void checkX11Events()
+{
+	if(!appRunning)
+		return;
+
+	XEvent event;
+
+	while(XPending(xDisp) > 0)
+	{
+		XNextEvent(xDisp, &event);
+		//Handle Resize events
+		if(event.type == ConfigureNotify)
+		{
+			if(g_m)
+			{
+				const MouseState &ms = g_m->getMouseState();
+				ms.width = event.xconfigure.width;
+				ms.height = event.xconfigure.height;
+			}
+		}
+		else if(event.type == ClientMessage || event.type == DestroyNotify)
+		{	// We only get DestroyNotify for child windows. However, we regeistered earlier to receive WM_DELETE_MESSAGEs
+			std::cout << "Exiting...\n";
+			appRunning = false;
+			return;
+		}
+		else
+		{
+			std::cout << "\nUnknown X Event: " << event.type << std::endl;
+		}
+	}
+}
+#endif
+
+#if defined OIS_APPLE_PLATFORM
+void checkMacEvents()
+{	
+	//TODO - Check for window resize events, and then adjust the members of mousestate
+	EventRef event = NULL;
+	EventTargetRef targetWindow = GetEventDispatcherTarget();
+	
+	if( ReceiveNextEvent( 0, NULL, kEventDurationNoWait, true, &event ) == noErr )
+	{
+		SendEventToEventTarget(event, targetWindow);
+		std::cout << "Event : " << GetEventKind(event) << "\n";
+		ReleaseEvent(event);
+	}
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/Makefile.am b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/Makefile.am
new file mode 100644
index 0000000..9b7eff0
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/Makefile.am
@@ -0,0 +1,15 @@
+pkginclude_HEADERS = OISConfig.h \
+                     OISEffect.h \
+                     OISEvents.h \
+                     OISException.h \
+                     OISForceFeedback.h \
+                     OISInputManager.h \
+                     OISInterface.h \
+                     OISJoyStick.h \
+                     OISKeyboard.h \
+                     OISMouse.h \
+                     OISObject.h \
+                     OISPrereqs.h \
+                     OISFactoryCreator.h \
+                     OISMultiTouch.h \
+                     OIS.h
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OIS.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OIS.h
new file mode 100644
index 0000000..36c77d2
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OIS.h
@@ -0,0 +1,41 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_OISALL_H
+#define OIS_OISALL_H
+
+#include "OISPrereqs.h"
+#include "OISObject.h"
+#include "OISMouse.h"
+#include "OISKeyboard.h"
+#include "OISJoyStick.h"
+#include "OISMultiTouch.h"
+#include "OISInputManager.h"
+#include "OISFactoryCreator.h"
+#include "OISException.h"
+#include "OISEvents.h"
+
+#include "OISEffect.h"
+#include "OISInterface.h"
+#include "OISForceFeedback.h"
+
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISConfig.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISConfig.h
new file mode 100644
index 0000000..207d64c
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISConfig.h
@@ -0,0 +1,75 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_CONFIG_HEADER
+#define OIS_CONFIG_HEADER
+
+//----------------------------------------------------------------------------//
+//* This file contains defines for building certain parts of this Lib
+//*	This file is not meant for External inclusion. However, you can edit this 
+//* file before a build to effect what features are used internally
+//----------------------------------------------------------------------------//
+
+/** 
+@remarks
+	These lines have no bearing on internal build of OIS. This is here for
+	external build settings. Meaning, changing this does not require a
+	rebuild of OIS. This just affects VC dll import settings, as the DLL
+	build already defines this during its build for setting dll exports.
+	The undefine here is here just incase you decide to only use
+	DLL, and want to set it permently and recompile OIS too.. Avoid redefinition
+	from DLL build of OIS.
+
+	So, if wanting to link against DLL version, just uncomment these lines.
+*/
+//#ifdef OIS_DYNAMIC_LIB
+//#  undef OIS_DYNAMIC_LIB
+//#endif
+//#define OIS_DYNAMIC_LIB
+
+/**
+@remarks
+	Build in support for LIRC / WinLIRC - remote control support.
+	Requires Boost::asio
+@notes
+	Experimental - Supports connecting and enumerating. Control does not
+	yet return state or events
+*/
+//#define OIS_LIRC_SUPPORT
+
+/**
+@remarks
+	Build in support for PC Nintendo WiiMote Win32 HID interface.
+	Requires Boost::threads
+@notes
+	Useable, but not quite finished - supports rumble, all buttons, & main orientation axis.
+	Still needs Nunchuck, IR, and LED/Battery support.
+*/
+//#define OIS_WIN32_WIIMOTE_SUPPORT
+
+/**
+@remarks
+	Build in support for Win32 XInput (Xbox 360 Controller)
+*/
+//#define OIS_WIN32_XINPUT_SUPPORT
+
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISEffect.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISEffect.h
new file mode 100644
index 0000000..bdccad5
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISEffect.h
@@ -0,0 +1,278 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that
+		you wrote the original software. If you use this software in a product,
+		an acknowledgment in the product documentation would be appreciated but is
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_Effect_H
+#define OIS_Effect_H
+
+#include "OISPrereqs.h"
+
+namespace OIS
+{
+	//Predeclare some Effect Property structs
+	class ForceEffect;
+	class ConstantEffect;
+	class RampEffect;
+	class PeriodicEffect;
+	class ConditionalEffect;
+
+	/**
+		Force Feedback is a relatively complex set of properties to upload to a device.
+		The best place for information on the different properties, effects, etc is in
+		the DX Documentation and MSDN - there are even pretty graphs ther =)
+		As this class is modeled on the the DX interface you can apply that same
+		knowledge to creating effects via this class on any OS supported by OIS.
+
+		In anycase, this is the main class you will be using. There is *absolutely* no
+		need to instance any of the supporting ForceEffect classes yourself.
+	*/
+	class _OISExport Effect
+	{
+		/**
+			hidden so this class cannot be instanced with default constructor
+		*/
+		Effect();
+	public:
+		//! Type of force
+		enum EForce
+		{
+			UnknownForce = 0,
+			ConstantForce,
+			RampForce,
+			PeriodicForce,
+			ConditionalForce,
+			CustomForce,
+			_ForcesNumber // Always keep in last position.
+		};
+
+		static const char* getForceTypeName(EForce eValue);
+
+		//! Type of effect
+		enum EType
+		{
+			//Type ----- Pairs with force:
+			Unknown = 0, //UnknownForce
+			Constant,    //ConstantForce
+			Ramp,        //RampForce
+			Square,      //PeriodicForce
+			Triangle,    //PeriodicForce
+            Sine,        //PeriodicForce
+			SawToothUp,  //PeriodicForce
+			SawToothDown,//PeriodicForce
+			Friction,    //ConditionalForce
+			Damper,      //ConditionalForce
+			Inertia,     //ConditionalForce
+			Spring,      //ConditionalForce
+			Custom,      //CustomForce
+			_TypesNumber // Always keep in last position.
+		};
+
+		static const char* getEffectTypeName(EType eValue);
+
+		//! Direction of the Force
+		enum EDirection
+		{
+			NorthWest,
+			North,
+			NorthEast,
+			East,
+			SouthEast,
+			South,
+			SouthWest,
+			West,
+			_DirectionsNumber // Always keep in last position.
+		};
+
+		static const char* getDirectionName(EDirection eValue);
+
+		/**
+			This constructor allows you to set the force type and effect.
+		*/
+		Effect(EForce ef, EType et);
+		virtual ~Effect();
+
+		const EForce force;
+		const EType type;
+
+		//Infinite Time
+		static const unsigned int OIS_INFINITE = 0xFFFFFFFF;
+
+		//-------------------------------------------------------------------//
+		//--- Set these variables before uploading or modifying an effect ---//
+
+		//Direction to apply to the force - affects two axes+ effects
+		EDirection direction;
+
+		//Number of button triggering an effect (-1 means no trigger)
+		short trigger_button;
+
+		//Time to wait before an effect can be re-triggered (microseconds)
+		unsigned int trigger_interval;
+
+		//Duration of an effect (microseconds)
+		unsigned int replay_length;
+
+		//Time to wait before to start playing an effect (microseconds)
+		unsigned int replay_delay;
+
+		//Get the specific Force Effect. This should be cast depending on the EForce
+		ForceEffect* getForceEffect() const;
+
+		/**
+		@remarks
+			Set the number of Axes to use before the initial creation of the effect.
+			Can only be done prior to creation! Use the FF interface to determine
+			how many axes can be used (are availiable)
+		*/
+		void setNumAxes(short nAxes);
+
+		/**
+		@remarks
+			Returns the number of axes used in this effect
+		*/
+		short getNumAxes() const;
+
+		//------------- Library Internal -------------------------------------//
+		/**
+			set internally.. do not change or you will not be able to upload/stop
+			this effect any more. It will become lost. It is mutable so even
+			with const reference it can/will be changed by this lib
+		*/
+		mutable int _handle;
+	protected:
+		ForceEffect* effect; //Properties depend on EForce
+		short axes;          //Number of axes to use in effect
+	};
+
+	//-----------------------------------------------------------------------------//
+	/**
+		Base class of all effect property classes
+	*/
+	class _OISExport ForceEffect
+	{
+	public:
+		virtual ~ForceEffect() {}
+	};
+
+	//-----------------------------------------------------------------------------//
+	/**
+		An optional envelope to be applied to the start/end of an effect. If any of
+		these values are nonzero, then the envelope will be used in setting up the
+		effect.
+	*/
+	class _OISExport Envelope : public ForceEffect
+	{
+	public:
+		Envelope() : attackLength(0), attackLevel(0), fadeLength(0), fadeLevel(0) {}
+#if defined(OIS_MSVC_COMPILER)
+  #pragma warning (push)
+  #pragma warning (disable : 4800)
+#endif
+		bool isUsed() const { return attackLength | attackLevel | fadeLength | fadeLevel; }
+#if defined(OIS_MSVC_COMPILER)
+  #pragma warning (pop)
+#endif
+
+		// Duration of the attack (microseconds)
+		unsigned int attackLength;
+
+		// Absolute level at the beginning of the attack (0 to 10K)
+		// (automatically signed when necessary by FF core according to effect level sign)
+		unsigned short attackLevel;
+
+		// Duration of fade (microseconds)
+		unsigned int fadeLength;
+
+		// Absolute level at the end of fade (0 to 10K)
+		// (automatically signed when necessary by FF core according to effect level sign)
+		unsigned short fadeLevel;
+	};
+
+	//-----------------------------------------------------------------------------//
+	/**
+		Use this class when dealing with Force type of Constant
+	*/
+	class _OISExport ConstantEffect : public ForceEffect
+	{
+	public:
+		ConstantEffect() : level(5000) {}
+
+		class Envelope envelope; //Optional envolope
+		signed short level;       //-10K to +10k
+	};
+
+	//-----------------------------------------------------------------------------//
+	/**
+		Use this class when dealing with Force type of Ramp
+	*/
+	class _OISExport RampEffect : public ForceEffect
+	{
+	public:
+		RampEffect() : startLevel(0), endLevel(0) {}
+
+        class Envelope envelope; //Optional envelope
+		signed short startLevel;  //-10K to +10k
+		signed short endLevel;    //-10K to +10k
+	};
+
+	//-----------------------------------------------------------------------------//
+	/**
+		Use this class when dealing with Force type of Periodic
+	*/
+	class _OISExport PeriodicEffect : public ForceEffect
+	{
+	public:
+		PeriodicEffect() : magnitude(0), offset(0), phase(0), period(0) {}
+
+		class Envelope envelope;  //Optional Envelope
+
+		unsigned short magnitude;  //0 to 10,0000
+		signed short   offset;
+		unsigned short phase;      //Position at which playback begins 0 to 35,999
+		unsigned int   period;     //Period of effect (microseconds)
+	};
+
+	//-----------------------------------------------------------------------------//
+	/**
+		Use this class when dealing with Force type of Condional
+	*/
+	class _OISExport ConditionalEffect : public ForceEffect
+	{
+	public:
+		ConditionalEffect() :
+            rightCoeff(0), leftCoeff(0), rightSaturation(0), leftSaturation(0),
+			deadband(0), center(0) {}
+
+		signed short   rightCoeff;      //-10k to +10k (Positive Coeff)
+		signed short   leftCoeff;       //-10k to +10k (Negative Coeff)
+
+		unsigned short rightSaturation; //0 to 10k (Pos Saturation)
+		unsigned short leftSaturation;  //0 to 10k (Neg Saturation)
+
+		//Region around center in which the condition is not active, in the range
+		//from 0 through 10,000
+		unsigned short deadband;
+
+		//(Offset in DX) -10k and 10k
+		signed short center;
+	};
+}
+#endif //OIS_Effect_H
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISEvents.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISEvents.h
new file mode 100644
index 0000000..09bf64e
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISEvents.h
@@ -0,0 +1,43 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef _OIS_EVENTHEADERS_
+#define _OIS_EVENTHEADERS_
+#include "OISPrereqs.h"
+
+namespace OIS
+{
+	/**
+		Base class of all events
+	*/
+	class _OISExport EventArg
+	{
+	public:
+		EventArg( Object* obj ) : device(obj) {}
+		virtual ~EventArg() {}
+
+		//! Pointer to the Input Device
+		const Object* device;
+	};
+}
+
+#endif //_OIS_EVENTHEADERS_
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISException.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISException.h
new file mode 100644
index 0000000..93f700c
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISException.h
@@ -0,0 +1,78 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that
+		you wrote the original software. If you use this software in a product,
+		an acknowledgment in the product documentation would be appreciated but is
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef _OIS_EXCEPTION_HEADER_
+#define _OIS_EXCEPTION_HEADER_
+#include "OISPrereqs.h"
+#include <exception>
+
+namespace OIS
+{
+	//! Simple enum's for dealing with exceptions
+    enum OIS_ERROR
+	{
+		E_InputDisconnected,
+		E_InputDeviceNonExistant,
+		E_InputDeviceNotSupported,
+		E_DeviceFull,
+		E_NotSupported,
+		E_NotImplemented,
+		E_Duplicate,
+		E_InvalidParam,
+		E_General
+	};
+
+	/**
+	@remarks
+		Class for handling OIS exceptions. Much cleaner than checking every method for reurn value.
+		Inherits from std::exception so you can simply log those messages if you want to be generic.
+		Also note that this has a source file now since OSX was not finding the OIS::Exception symbol
+		which would cause program abortion with now correponding exception type.
+	*/
+	class _OISExport Exception : public std::exception
+	{
+		//! Hidden default
+		Exception() : eType(E_General), eLine(0), eFile(0) {}
+	public:
+		//! Creates exception object
+		Exception( OIS_ERROR err, const char* str, int line, const char *file )
+			: eType(err), eLine(line), eFile(file), eText(str) {}
+
+		~Exception() throw() {}
+
+		virtual const char* what() const throw();
+
+		//! The type of exception raised
+		const OIS_ERROR eType;
+		//! The line number it occurred on
+		const int eLine;
+		//! The source file
+		const char* eFile;
+		//! A message passed along when the exception was raised
+		const char* eText;
+	};
+}
+
+//! Use this macro to handle exceptions easily
+#define OIS_EXCEPT( err, str ) throw( OIS::Exception(err, str, __LINE__, __FILE__) )
+
+#endif //_OIS_EXCEPTION_HEADER_
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISFactoryCreator.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISFactoryCreator.h
new file mode 100644
index 0000000..72a4729
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISFactoryCreator.h
@@ -0,0 +1,81 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_FactoryCreator_H
+#define OIS_FactoryCreator_H
+
+#include "OISPrereqs.h"
+
+namespace OIS
+{
+	/**
+		Interface for creating devices - all devices ultimately get enumerated/created via a factory.
+		A factory can create multiple types of objects.
+	*/
+	class _OISExport FactoryCreator
+	{
+	public:
+		/**
+			@remarks Virtual Destructor
+		*/
+		virtual ~FactoryCreator() {};
+
+		/**
+			@remarks Return a list of all unused devices the factory maintains
+		*/
+		virtual DeviceList freeDeviceList() = 0;
+
+		/**
+			@remarks Number of total devices of requested type
+			@param iType Type of devices to check
+		*/
+		virtual int totalDevices(Type iType) = 0;
+
+		/**
+			@remarks Number of free devices of requested type
+			@param iType Type of devices to check
+		*/
+		virtual int freeDevices(Type iType) = 0;
+
+		/**
+			@remarks Does a Type exist with the given vendor name
+			@param iType Type to check
+			@param vendor Vendor name to test
+		*/
+		virtual bool vendorExist(Type iType, const std::string & vendor) = 0;
+
+		/**
+			@remarks Creates the object
+			@param iType Type to create
+			@param bufferMode True to setup for buffered events
+			@param vendor Create a device with the vendor name, "" means vendor name is unimportant
+		*/
+		virtual Object* createObject(InputManager* creator, Type iType, bool bufferMode, const std::string & vendor = "") = 0;
+
+		/**
+			@remarks Destroys object
+			@param obj Object to destroy
+		*/
+		virtual void destroyObject(Object* obj) = 0;
+	};
+}
+#endif //OIS_FactoryCreator_H
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISForceFeedback.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISForceFeedback.h
new file mode 100644
index 0000000..a35e7fd
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISForceFeedback.h
@@ -0,0 +1,120 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_ForceFeedBack_H
+#define OIS_ForceFeedBack_H
+
+#include "OISPrereqs.h"
+#include "OISInterface.h"
+#include "OISEffect.h"
+
+namespace OIS
+{
+	/**
+		Interface class for dealing with Force Feedback devices
+	*/
+	class _OISExport ForceFeedback : public Interface
+	{
+	public:
+		ForceFeedback();
+		virtual ~ForceFeedback() {}
+
+		/**
+		@remarks
+			This is like setting the master volume of an audio device.
+			Individual effects have gain levels; however, this affects all
+			effects at once.
+			Note: If the device does not support master gain setting, nothing is done
+		@param level
+			A value between 0.0 and 1.0 represent the percentage of gain. 1.0
+			being the highest possible force level (means no scaling).
+		*/
+		virtual void setMasterGain( float level ) = 0;
+		
+		/**
+		@remarks
+			If using Force Feedback effects, this should be turned off
+			before uploading any effects. Auto centering is the motor moving
+			the joystick back to center. DirectInput only has an on/off setting,
+			whereas linux has levels.. Though, we go with DI's on/off mode only
+			Note: If the device does not support auto-centering, nothing is done
+		@param auto_on
+			true to turn auto centering on, false to turn off.
+		*/
+		virtual void setAutoCenterMode( bool auto_on ) = 0;
+
+		/**
+		@remarks
+			Creates and Plays the effect immediately. If the device is full
+			of effects, it will fail to be uploaded. You will know this by
+			an invalid Effect Handle
+		*/
+		virtual void upload( const Effect* effect ) = 0;
+
+		/**
+		@remarks
+			Modifies an effect that is currently playing
+		*/
+		virtual void modify( const Effect* effect ) = 0;
+
+		/**
+		@remarks
+			Remove the effect from the device
+		*/
+		virtual void remove( const Effect* effect ) = 0;
+
+		/**
+		@remarks
+			Get the number of supported Axes for FF usage
+		*/
+        virtual short getFFAxesNumber() = 0;
+
+		/**
+		@remarks
+			Get the current load (%, in [0, 100] of the FF device memory 
+		*/
+		virtual unsigned short getFFMemoryLoad() = 0;
+
+		typedef std::multimap<Effect::EForce, Effect::EType> SupportedEffectList;
+		/**
+		@remarks
+			Get a list of all supported effects
+		*/
+		const SupportedEffectList& getSupportedEffects() const;
+
+		/**
+		@remarks
+			Tell if a given force / effect type pair is supported
+		*/
+		bool supportsEffect(Effect::EForce force, Effect::EType type) const;
+
+		void _addEffectTypes( Effect::EForce force, Effect::EType type );
+		void _setGainSupport( bool on );
+		void _setAutoCenterSupport( bool on );
+
+	protected:
+		SupportedEffectList mSupportedEffects;
+		bool mSetGainSupport;
+		bool mSetAutoCenterSupport;
+	};
+}
+#endif //OIS_ForceFeedBack_H
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISInputManager.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISInputManager.h
new file mode 100644
index 0000000..113b710
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISInputManager.h
@@ -0,0 +1,205 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_InputManager_H
+#define OIS_InputManager_H
+
+#include "OISPrereqs.h"
+
+namespace OIS
+{
+	//Forward declare a couple of classes we might use later
+	class LIRCFactoryCreator;
+	class WiiMoteFactoryCreator;
+
+	/**
+		Base Manager class. No longer a Singleton; so feel free to create as many InputManager's as you have
+		windows.
+	*/
+	class _OISExport InputManager
+	{
+	public:
+		/**
+		@remarks
+			Returns version number (useful in DLL/SO libs)
+		@returns
+			Bits: 1-8 Patch number, 9-16 Minor version, 17-32 Major version
+		*/
+		static unsigned int getVersionNumber();
+
+		/**
+		@remarks
+			Returns version string (useful in DLL/SO libs)
+		@returns
+			Version name
+		*/
+		const std::string &getVersionName();
+
+		/**
+		@remarks
+			Creates appropriate input system dependent on platform. 
+		@param winHandle
+			Contains OS specific window handle (such as HWND or X11 Window)
+		@returns
+			A pointer to the created manager, or raises Exception
+		*/
+		static InputManager* createInputSystem( std::size_t winHandle );
+
+		/**
+		@remarks
+			Creates appropriate input system dependent on platform. 
+		@param paramList
+			ParamList contains OS specific info (such as HWND and HINSTANCE for window apps),
+			and access mode.
+		@returns
+			A pointer to the created manager, or raises Exception
+		*/
+		static InputManager* createInputSystem( ParamList &paramList );
+
+		/**
+		@remarks
+			Destroys the InputManager
+		@param manager
+			Manager to destroy
+		*/
+		static void destroyInputSystem(InputManager* manager);
+
+		/**
+		@remarks Gets the name of the current platform input system
+		*/
+		const std::string& inputSystemName();
+
+		/**
+		@remarks
+			Returns the number of the specified OIS::Type devices discovered by OIS
+		@param iType
+			Type that you are interested in
+		*/
+		int getNumberOfDevices( Type iType );
+
+		/**
+		@remarks
+			Lists all unused devices
+		@returns
+			DeviceList which contains Type and vendor of device
+		*/
+		DeviceList listFreeDevices();
+
+		/**
+		@remarks
+			Tries to create an object with the specified vendor. If you have no
+			preference of vendor, leave vender as default (""). Raises exception on failure
+		*/
+		Object* createInputObject( Type iType, bool bufferMode, const std::string &vendor = "");
+
+		/**
+		@remarks Destroys Input Object
+		*/
+		void destroyInputObject( Object* obj );
+
+		/**
+		@remarks
+			Add a custom object factory to allow for user controls.
+		@param factory
+			Factory instance to add
+		@notes
+			Make sure you do not delete the factory before devices created from
+			the factory are destroyed (either by calling RemoveFactoryCreator, or shutting down
+			the input system). Order should be something like the following:
+				* Create Input System
+				* Create Factory Instance
+				* AddFactoryCreator(factory)
+				* Create a device from the InputManager (device created by factory)
+				* One of the follwoing:
+					* removeFactoryCreator(factory)
+					* inputManager->destroyInputObject(obj)
+				* destroyInputSystem(inputManager)
+				* destroy Factory Instance
+			You can safely delete the factory instance once you have removed it or shut down the
+			input manager.
+		*/
+		void addFactoryCreator( FactoryCreator* factory );
+
+		/**
+		@remarks
+			Remove a previously added object factory
+		@param factory
+			Factory object to remove.
+		@notes
+			Removing a factory will automatically destroy any Objects created from the factory
+		*/
+		void removeFactoryCreator( FactoryCreator* factory );
+
+		//! All generic devices OIS supports internally (if they are compiled in)
+		enum AddOnFactories
+		{
+			AddOn_All = 0,		//All Devices
+			AddOn_LIRC = 1,		//PC Linux Infrared Remote Control
+			AddOn_WiiMote = 2	//PC WiiMote Support
+		};
+
+		/**
+		@remarks
+			Enable an addon FactoryCreator extension. By default, none are activated.
+			If the desired support was not compiled in, this has no effect. Calling
+			multiple times has no effect. Once activated, there is no way to deactivate -
+			simply destroy and recreate input manager.
+		*/
+		void enableAddOnFactory(AddOnFactories factory);
+
+	protected:
+		/**
+		@remarks
+			Called from createInputSystem, gives derived input class a chance to setup after it is created
+		*/
+		virtual void _initialize(ParamList &paramList) = 0;
+
+		/**
+		@remarks
+			Derived classes must provide input system name
+		*/
+		InputManager(const std::string& name);
+
+		/**
+		@remarks
+			Virtual Destructor - this base class will clean up all devices still opened in mFactoryObjects list
+		*/
+		virtual ~InputManager();
+
+		//! OIS Version name
+		const std::string m_VersionName;
+
+		//! FactoryCreator list	
+		FactoryList mFactories;
+
+		//! Factory created objects - useful so we can find creator to send destruction request to
+		FactoryCreatedObject mFactoryObjects;
+
+		//! Name of the input system
+		const std::string mInputSystemName;
+
+		//! Extra factory (not enabled by default)
+		LIRCFactoryCreator *m_lircSupport;
+		WiiMoteFactoryCreator *m_wiiMoteSupport;
+	};
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISInterface.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISInterface.h
new file mode 100644
index 0000000..9c356b1
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISInterface.h
@@ -0,0 +1,47 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_Interface_H
+#define OIS_Interface_H
+
+#include "OISPrereqs.h"
+
+namespace OIS
+{
+	/**
+		An Object's interface is a way to gain write access to devices which support
+		it. For example, force feedack.
+	*/
+	class _OISExport Interface
+	{
+	public:
+		virtual ~Interface() {};
+
+		//! Type of Interface
+		enum IType
+		{
+			ForceFeedback,
+			Reserved
+		};
+	};
+}
+#endif //OIS_Interface_H
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISJoyStick.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISJoyStick.h
new file mode 100644
index 0000000..bfdbfb5
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISJoyStick.h
@@ -0,0 +1,228 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that
+		you wrote the original software. If you use this software in a product,
+		an acknowledgment in the product documentation would be appreciated but is
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_Joystick_H
+#define OIS_Joystick_H
+#include "OISObject.h"
+#include "OISEvents.h"
+
+namespace OIS
+{
+	/** @remarks default sensitivity for vector3 component of joystick */
+	#define OIS_JOYSTICK_VECTOR3_DEFAULT 2.28f
+
+	//! POV / HAT Joystick component
+	class _OISExport Pov : public Component
+	{
+	public:
+		Pov() : Component(OIS_POV), direction(0) {}
+
+		static const int Centered  = 0x00000000;
+		static const int North     = 0x00000001;
+		static const int South     = 0x00000010;
+		static const int East      = 0x00000100;
+		static const int West      = 0x00001000;
+		static const int NorthEast = 0x00000101;
+		static const int SouthEast = 0x00000110;
+		static const int NorthWest = 0x00001001;
+		static const int SouthWest = 0x00001010;
+
+		int direction;
+	};
+
+	//! A sliding axis - only used in Win32 Right Now
+	class _OISExport Slider : public Component
+	{
+	public:
+		Slider() : Component(OIS_Slider), abX(0), abY(0) {};
+		//! true if pushed, false otherwise
+		int abX, abY;
+	};
+
+	/**
+		Represents the state of the joystick
+		All members are valid for both buffered and non buffered mode
+		Sticks with zero values are not present on the device
+	*/
+	class _OISExport JoyStickState
+	{
+	public:
+		//! Constructor
+		JoyStickState() { clear(); }
+
+		//! Represents all the buttons (uses a bitset)
+		std::vector<bool> mButtons;
+
+		//! Represents all the single axes on the device
+		std::vector<Axis> mAxes;
+
+		//! Represents the value of a POV. Maximum of 4
+		Pov mPOV[4];
+
+		//! Represent the max sliders
+		Slider mSliders[4];
+
+		//! Represents all Vector type controls the device exports
+		std::vector<Vector3> mVectors;
+
+		//! internal method to reset all variables to initial values
+		void clear()
+		{
+			for( std::vector<bool>::iterator i = mButtons.begin(), e = mButtons.end(); i != e; ++i )
+			{
+				(*i) = false;
+			}
+
+			for( std::vector<Axis>::iterator i = mAxes.begin(), e = mAxes.end(); i != e; ++i )
+			{
+				i->absOnly = true; //Currently, joysticks only report Absolute values
+				i->clear();
+			}
+
+			for( std::vector<Vector3>::iterator i = mVectors.begin(), e = mVectors.end(); i != e; ++i )
+			{
+				i->clear();
+			}
+
+			for( int i = 0; i < 4; ++i )
+			{
+				mPOV[i].direction = Pov::Centered;
+				mSliders[i].abX = mSliders[i].abY = 0;
+			}
+		}
+	};
+
+	/** Specialised for joystick events */
+	class _OISExport JoyStickEvent : public EventArg
+	{
+	public:
+		JoyStickEvent( Object* obj, const JoyStickState &st ) : EventArg(obj), state(st) {}
+		virtual ~JoyStickEvent() {}
+
+		const JoyStickState &state;
+	};
+
+	/**
+		To recieve buffered joystick input, derive a class from this, and implement the
+		methods here. Then set the call back to your JoyStick instance with JoyStick::setEventCallback
+		Each JoyStick instance can use the same callback class, as a devID number will be provided
+		to differentiate between connected joysticks. Of course, each can have a seperate
+		callback instead.
+	*/
+	class _OISExport JoyStickListener
+	{
+	public:
+		virtual ~JoyStickListener() {}
+		/** @remarks Joystick button down event */
+		virtual bool buttonPressed( const JoyStickEvent &arg, int button ) = 0;
+		
+		/** @remarks Joystick button up event */
+		virtual bool buttonReleased( const JoyStickEvent &arg, int button ) = 0;
+
+		/** @remarks Joystick axis moved event */
+		virtual bool axisMoved( const JoyStickEvent &arg, int axis ) = 0;
+
+		//-- Not so common control events, so are not required --//
+		//! Joystick Event, and sliderID
+		virtual bool sliderMoved( const JoyStickEvent &, int index) {return true;}
+		
+		//! Joystick Event, and povID
+		virtual bool povMoved( const JoyStickEvent &arg, int index) {return true;}
+
+		//! Joystick Event, and Vector3ID
+		virtual bool vector3Moved( const JoyStickEvent &arg, int index) {return true;}
+	};
+
+	/**
+		Joystick base class. To be implemented by specific system (ie. DirectX joystick)
+		This class is useful as you remain OS independent using this common interface.
+	*/
+	class _OISExport JoyStick : public Object
+	{
+	public:
+		virtual ~JoyStick() {}
+
+		/**
+		@remarks
+			Returns the number of requested components
+		@param cType
+			The ComponentType you are interested in knowing about
+		*/
+		int getNumberOfComponents(ComponentType cType) const;
+
+		/**
+		@remarks
+			Sets a cutoff limit for changes in the Vector3 component for movement to 
+			be ignored. Helps reduce much event traffic for frequent small/sensitive
+			changes
+		@param degrees
+			The degree under which Vector3 events should be discarded
+		*/
+		void setVector3Sensitivity(float degrees = OIS_JOYSTICK_VECTOR3_DEFAULT);
+
+		/**
+		@remarks
+			Returns the sensitivity cutoff for Vector3 Component
+		*/
+		float getVector3Sensitivity() const;
+
+		/**
+		@remarks
+			Register/unregister a JoyStick Listener - Only one allowed for simplicity. If broadcasting
+			is neccessary, just broadcast from the callback you registered.
+		@param joyListener
+			Send a pointer to a class derived from JoyStickListener or 0 to clear the callback
+		*/
+		virtual void setEventCallback( JoyStickListener *joyListener );
+
+		/** @remarks Returns currently set callback.. or null */
+		JoyStickListener* getEventCallback() const;
+
+		/** @remarks Returns the state of the joystick - is valid for both buffered and non buffered mode */
+		const JoyStickState& getJoyStickState() const { return mState; }
+
+		//! The minimal axis value
+		static const int MIN_AXIS = -32768;
+
+		//! The maximum axis value
+		static const int MAX_AXIS = 32767;
+
+	protected:
+		JoyStick(const std::string &vendor, bool buffered, int devID, InputManager* creator);
+
+		//! Number of sliders
+		int mSliders;
+
+		//! Number of POVs
+		int mPOVs;
+
+		//! The JoyStickState structure (contains all component values)
+		JoyStickState mState;
+
+		//! The callback listener
+		JoyStickListener *mListener;
+
+		//! Adjustment factor for orientation vector accuracy
+		float mVector3Sensitivity;
+	};
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISKeyboard.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISKeyboard.h
new file mode 100644
index 0000000..1a88d3a
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISKeyboard.h
@@ -0,0 +1,312 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_Keyboard_H
+#define OIS_Keyboard_H
+#include "OISObject.h"
+#include "OISEvents.h"
+
+namespace OIS
+{
+	//! Keyboard scan codes
+	enum KeyCode
+	{
+		KC_UNASSIGNED  = 0x00,
+		KC_ESCAPE      = 0x01,
+		KC_1           = 0x02,
+		KC_2           = 0x03,
+		KC_3           = 0x04,
+		KC_4           = 0x05,
+		KC_5           = 0x06,
+		KC_6           = 0x07,
+		KC_7           = 0x08,
+		KC_8           = 0x09,
+		KC_9           = 0x0A,
+		KC_0           = 0x0B,
+		KC_MINUS       = 0x0C,    // - on main keyboard
+		KC_EQUALS      = 0x0D,
+		KC_BACK        = 0x0E,    // backspace
+		KC_TAB         = 0x0F,
+		KC_Q           = 0x10,
+		KC_W           = 0x11,
+		KC_E           = 0x12,
+		KC_R           = 0x13,
+		KC_T           = 0x14,
+		KC_Y           = 0x15,
+		KC_U           = 0x16,
+		KC_I           = 0x17,
+		KC_O           = 0x18,
+		KC_P           = 0x19,
+		KC_LBRACKET    = 0x1A,
+		KC_RBRACKET    = 0x1B,
+		KC_RETURN      = 0x1C,    // Enter on main keyboard
+		KC_LCONTROL    = 0x1D,
+		KC_A           = 0x1E,
+		KC_S           = 0x1F,
+		KC_D           = 0x20,
+		KC_F           = 0x21,
+		KC_G           = 0x22,
+		KC_H           = 0x23,
+		KC_J           = 0x24,
+		KC_K           = 0x25,
+		KC_L           = 0x26,
+		KC_SEMICOLON   = 0x27,
+		KC_APOSTROPHE  = 0x28,
+		KC_GRAVE       = 0x29,    // accent
+		KC_LSHIFT      = 0x2A,
+		KC_BACKSLASH   = 0x2B,
+		KC_Z           = 0x2C,
+		KC_X           = 0x2D,
+		KC_C           = 0x2E,
+		KC_V           = 0x2F,
+		KC_B           = 0x30,
+		KC_N           = 0x31,
+		KC_M           = 0x32,
+		KC_COMMA       = 0x33,
+		KC_PERIOD      = 0x34,    // . on main keyboard
+		KC_SLASH       = 0x35,    // / on main keyboard
+		KC_RSHIFT      = 0x36,
+		KC_MULTIPLY    = 0x37,    // * on numeric keypad
+		KC_LMENU       = 0x38,    // left Alt
+		KC_SPACE       = 0x39,
+		KC_CAPITAL     = 0x3A,
+		KC_F1          = 0x3B,
+		KC_F2          = 0x3C,
+		KC_F3          = 0x3D,
+		KC_F4          = 0x3E,
+		KC_F5          = 0x3F,
+		KC_F6          = 0x40,
+		KC_F7          = 0x41,
+		KC_F8          = 0x42,
+		KC_F9          = 0x43,
+		KC_F10         = 0x44,
+		KC_NUMLOCK     = 0x45,
+		KC_SCROLL      = 0x46,    // Scroll Lock
+		KC_NUMPAD7     = 0x47,
+		KC_NUMPAD8     = 0x48,
+		KC_NUMPAD9     = 0x49,
+		KC_SUBTRACT    = 0x4A,    // - on numeric keypad
+		KC_NUMPAD4     = 0x4B,
+		KC_NUMPAD5     = 0x4C,
+		KC_NUMPAD6     = 0x4D,
+		KC_ADD         = 0x4E,    // + on numeric keypad
+		KC_NUMPAD1     = 0x4F,
+		KC_NUMPAD2     = 0x50,
+		KC_NUMPAD3     = 0x51,
+		KC_NUMPAD0     = 0x52,
+		KC_DECIMAL     = 0x53,    // . on numeric keypad
+		KC_OEM_102     = 0x56,    // < > | on UK/Germany keyboards
+		KC_F11         = 0x57,
+		KC_F12         = 0x58,
+		KC_F13         = 0x64,    //                     (NEC PC98)
+		KC_F14         = 0x65,    //                     (NEC PC98)
+		KC_F15         = 0x66,    //                     (NEC PC98)
+		KC_KANA        = 0x70,    // (Japanese keyboard)
+		KC_ABNT_C1     = 0x73,    // / ? on Portugese (Brazilian) keyboards
+		KC_CONVERT     = 0x79,    // (Japanese keyboard)
+		KC_NOCONVERT   = 0x7B,    // (Japanese keyboard)
+		KC_YEN         = 0x7D,    // (Japanese keyboard)
+		KC_ABNT_C2     = 0x7E,    // Numpad . on Portugese (Brazilian) keyboards
+		KC_NUMPADEQUALS= 0x8D,    // = on numeric keypad (NEC PC98)
+		KC_PREVTRACK   = 0x90,    // Previous Track (KC_CIRCUMFLEX on Japanese keyboard)
+		KC_AT          = 0x91,    //                     (NEC PC98)
+		KC_COLON       = 0x92,    //                     (NEC PC98)
+		KC_UNDERLINE   = 0x93,    //                     (NEC PC98)
+		KC_KANJI       = 0x94,    // (Japanese keyboard)
+		KC_STOP        = 0x95,    //                     (NEC PC98)
+		KC_AX          = 0x96,    //                     (Japan AX)
+		KC_UNLABELED   = 0x97,    //                        (J3100)
+		KC_NEXTTRACK   = 0x99,    // Next Track
+		KC_NUMPADENTER = 0x9C,    // Enter on numeric keypad
+		KC_RCONTROL    = 0x9D,
+		KC_MUTE        = 0xA0,    // Mute
+		KC_CALCULATOR  = 0xA1,    // Calculator
+		KC_PLAYPAUSE   = 0xA2,    // Play / Pause
+		KC_MEDIASTOP   = 0xA4,    // Media Stop
+		KC_VOLUMEDOWN  = 0xAE,    // Volume -
+		KC_VOLUMEUP    = 0xB0,    // Volume +
+		KC_WEBHOME     = 0xB2,    // Web home
+		KC_NUMPADCOMMA = 0xB3,    // , on numeric keypad (NEC PC98)
+		KC_DIVIDE      = 0xB5,    // / on numeric keypad
+		KC_SYSRQ       = 0xB7,
+		KC_RMENU       = 0xB8,    // right Alt
+		KC_PAUSE       = 0xC5,    // Pause
+		KC_HOME        = 0xC7,    // Home on arrow keypad
+		KC_UP          = 0xC8,    // UpArrow on arrow keypad
+		KC_PGUP        = 0xC9,    // PgUp on arrow keypad
+		KC_LEFT        = 0xCB,    // LeftArrow on arrow keypad
+		KC_RIGHT       = 0xCD,    // RightArrow on arrow keypad
+		KC_END         = 0xCF,    // End on arrow keypad
+		KC_DOWN        = 0xD0,    // DownArrow on arrow keypad
+		KC_PGDOWN      = 0xD1,    // PgDn on arrow keypad
+		KC_INSERT      = 0xD2,    // Insert on arrow keypad
+		KC_DELETE      = 0xD3,    // Delete on arrow keypad
+		KC_LWIN        = 0xDB,    // Left Windows key
+		KC_RWIN        = 0xDC,    // Right Windows key
+		KC_APPS        = 0xDD,    // AppMenu key
+		KC_POWER       = 0xDE,    // System Power
+		KC_SLEEP       = 0xDF,    // System Sleep
+		KC_WAKE        = 0xE3,    // System Wake
+		KC_WEBSEARCH   = 0xE5,    // Web Search
+		KC_WEBFAVORITES= 0xE6,    // Web Favorites
+		KC_WEBREFRESH  = 0xE7,    // Web Refresh
+		KC_WEBSTOP     = 0xE8,    // Web Stop
+		KC_WEBFORWARD  = 0xE9,    // Web Forward
+		KC_WEBBACK     = 0xEA,    // Web Back
+		KC_MYCOMPUTER  = 0xEB,    // My Computer
+		KC_MAIL        = 0xEC,    // Mail
+		KC_MEDIASELECT = 0xED     // Media Select
+	};
+
+	/**
+		Specialised for key events
+	*/
+	class _OISExport KeyEvent : public EventArg
+	{
+	public:
+		KeyEvent(Object* obj, KeyCode kc, unsigned int txt) : EventArg(obj), key(kc), text(txt) {}
+		virtual ~KeyEvent() {}
+
+		//! KeyCode of event
+		const KeyCode key;
+		//! Text character, depends on current TextTranslationMode
+		unsigned int text;
+	};
+
+	/**
+		To recieve buffered keyboard input, derive a class from this, and implement the
+		methods here. Then set the call back to your Keyboard instance with Keyboard::setEventCallback
+	*/
+	class _OISExport KeyListener
+	{
+	public:
+		virtual ~KeyListener() {}
+		virtual bool keyPressed(const KeyEvent &arg) = 0;
+		virtual bool keyReleased(const KeyEvent &arg) = 0;		
+	};
+
+	/**
+		Keyboard base class. To be implemented by specific system (ie. DirectX Keyboard)
+		This class is useful as you remain OS independent using this common interface.
+	*/
+	class _OISExport Keyboard : public Object
+	{
+	public:
+		virtual ~Keyboard() {};
+		
+		/**
+		@remarks
+			Returns true if key is donwn
+		@param key
+			A KeyCode to check
+		*/
+		virtual bool isKeyDown(KeyCode key) const = 0;
+
+		/**
+		@remarks
+			Register/unregister a Keyboard Listener - Only one allowed for simplicity. If broadcasting
+			is neccessary, just broadcast from the callback you registered.
+		@param keyListener
+			Send a pointer to a class derived from KeyListener or 0 to clear the callback
+		*/
+		virtual void setEventCallback(KeyListener *keyListener) { mListener = keyListener;}
+
+		/**
+		@remarks
+			Returns currently set callback.. or 0
+		*/
+		KeyListener* getEventCallback() const {return mListener;}
+
+		//! TextTranslation Mode
+		enum TextTranslationMode
+		{
+			Off,
+			Unicode,
+			Ascii
+		};
+
+		/**
+		@remarks
+			Enable extra processing to translate KC_*** to an
+			actual text character based off of locale. Different 
+			managers may implement none or all. Check the 
+			translation mode after setting to be sure
+		@param mode
+			Off, Unicode, Ascii
+		*/
+		virtual void setTextTranslation(TextTranslationMode mode);
+
+		/**
+		@remarks
+			Returns current translation mode
+		*/
+		TextTranslationMode getTextTranslation() const {return mTextMode;}
+		
+		/**
+		@remarks
+			Translates KeyCode to string representation.
+			For example, KC_ENTER will be "Enter" - Locale
+			specific of course.
+		@param kc
+			KeyCode to convert
+		@returns
+			The string as determined from the current locale
+		*/
+		virtual const std::string& getAsString(KeyCode kc) = 0;
+
+		//! Enum of bit position of modifer
+		enum Modifier
+		{
+			Shift = 0x0000001,
+			Ctrl  = 0x0000010,
+			Alt   = 0x0000100
+		};
+
+		/**
+		@remarks
+			Check modifier status
+		*/
+		bool isModifierDown(Modifier mod) const;
+
+		/**
+		@remarks
+			Copies the state of the keys into the sent buffer
+			(in the form of 1 is down and 0 is up)
+		*/
+		virtual void copyKeyStates(char keys[256]) const = 0;
+		
+	protected:
+		Keyboard(const std::string &vendor, bool buffered, int devID, InputManager* creator)
+			: Object(vendor, OISKeyboard, buffered, devID, creator),
+			mModifiers(0), mListener(0), mTextMode(Unicode) {}
+
+		//! Bit field that holds status of Alt, Ctrl, Shift
+		unsigned int mModifiers;
+
+		//! Used for buffered/actionmapping callback
+		KeyListener *mListener;
+
+		//! The current translation mode
+		TextTranslationMode mTextMode;
+	};
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISMouse.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISMouse.h
new file mode 100644
index 0000000..6735d14
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISMouse.h
@@ -0,0 +1,138 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that
+		you wrote the original software. If you use this software in a product,
+		an acknowledgment in the product documentation would be appreciated but is
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_Mouse_H
+#define OIS_Mouse_H
+#include "OISObject.h"
+#include "OISEvents.h"
+
+namespace OIS
+{
+	//! Button ID for mouse devices
+	enum MouseButtonID
+	{
+		MB_Left = 0, MB_Right, MB_Middle,
+		MB_Button3, MB_Button4,	MB_Button5, MB_Button6,	MB_Button7
+	};
+
+	/**
+		Represents the state of the mouse
+		All members are valid for both buffered and non buffered mode
+	*/
+	class _OISExport MouseState
+	{
+	public:
+		MouseState() : width(50), height(50), buttons(0) {};
+
+		/** Represents the height/width of your display area.. used if mouse clipping
+		or mouse grabbed in case of X11 - defaults to 50.. Make sure to set this
+		and change when your size changes.. */
+		mutable int width, height;
+
+		//! X Axis component
+		Axis X;
+
+		//! Y Axis Component
+		Axis Y;
+
+		//! Z Axis Component
+		Axis Z;
+
+		//! represents all buttons - bit position indicates button down
+		int buttons;
+
+		//! Button down test
+		inline bool buttonDown( MouseButtonID button ) const
+		{
+			return ((buttons & ( 1L << button )) == 0) ? false : true;
+		}
+
+		//! Clear all the values
+		void clear()
+		{
+			X.clear();
+			Y.clear();
+			Z.clear();
+			buttons = 0;
+		}
+	};
+
+	/** Specialised for mouse events */
+	class _OISExport MouseEvent : public EventArg
+	{
+	public:
+		MouseEvent( Object *obj, const MouseState &ms )	: EventArg(obj), state(ms) {}
+		virtual ~MouseEvent() {}
+
+		//! The state of the mouse - including buttons and axes
+		const MouseState &state;
+	};
+
+	/**
+		To recieve buffered mouse input, derive a class from this, and implement the
+		methods here. Then set the call back to your Mouse instance with Mouse::setEventCallback
+	*/
+	class _OISExport MouseListener
+	{
+	public:
+		virtual ~MouseListener() {}
+		virtual bool mouseMoved( const MouseEvent &arg ) = 0;
+		virtual bool mousePressed( const MouseEvent &arg, MouseButtonID id ) = 0;
+		virtual bool mouseReleased( const MouseEvent &arg, MouseButtonID id ) = 0;
+	};
+
+	/**
+		Mouse base class. To be implemented by specific system (ie. DirectX Mouse)
+		This class is useful as you remain OS independent using this common interface.
+	*/
+	class _OISExport Mouse : public Object
+	{
+	public:
+		virtual ~Mouse() {}
+
+		/**
+		@remarks
+			Register/unregister a Mouse Listener - Only one allowed for simplicity. If broadcasting
+			is neccessary, just broadcast from the callback you registered.
+		@param mouseListener
+			Send a pointer to a class derived from MouseListener or 0 to clear the callback
+		*/
+		virtual void setEventCallback( MouseListener *mouseListener ) {mListener = mouseListener;}
+
+		/** @remarks Returns currently set callback.. or 0 */
+		MouseListener* getEventCallback() const {return mListener;}
+
+		/** @remarks Returns the state of the mouse - is valid for both buffered and non buffered mode */
+		const MouseState& getMouseState() const { return mState; }
+
+	protected:
+		Mouse(const std::string &vendor, bool buffered, int devID, InputManager* creator)
+			: Object(vendor, OISMouse, buffered, devID, creator), mListener(0) {}
+
+		//! The state of the mouse
+		MouseState mState;
+
+		//! Used for buffered/actionmapping callback
+		MouseListener *mListener;
+	};
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISMultiTouch.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISMultiTouch.h
new file mode 100644
index 0000000..3abbd43
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISMultiTouch.h
@@ -0,0 +1,169 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that
+		you wrote the original software. If you use this software in a product,
+		an acknowledgment in the product documentation would be appreciated but is
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_MultiTouch_H
+#define OIS_MultiTouch_H
+#include "OISObject.h"
+#include "OISEvents.h"
+
+#include <set>
+#include <vector>
+
+#define OIS_MAX_NUM_TOUCHES 4   // 4 finger touches are probably the highest we'll ever get
+
+namespace OIS
+{
+	/**
+		Represents the state of the multi-touch device
+		All members are valid for both buffered and non buffered mode
+	*/
+    
+	//! Touch Event type
+	enum MultiTypeEventTypeID
+	{
+		MT_None = 0, MT_Pressed, MT_Released, MT_Moved, MT_Cancelled
+	};
+
+	class _OISExport MultiTouchState
+	{
+	public:
+		MultiTouchState() : width(50), height(50), touchType(MT_None) {};
+
+		/** Represents the height/width of your display area.. used if touch clipping
+		or touch grabbed in case of X11 - defaults to 50.. Make sure to set this
+		and change when your size changes.. */
+		mutable int width, height;
+
+		//! X Axis component
+		Axis X;
+
+		//! Y Axis Component
+		Axis Y;
+
+		//! Z Axis Component
+		Axis Z;
+
+        int touchType;
+
+        inline bool touchIsType( MultiTypeEventTypeID touch ) const
+		{
+			return ((touchType & ( 1L << touch )) == 0) ? false : true;
+		}
+        
+		//! Clear all the values
+		void clear()
+		{
+			X.clear();
+			Y.clear();
+			Z.clear();
+            touchType = MT_None;
+		}
+	};
+
+	/** Specialised for multi-touch events */
+	class _OISExport MultiTouchEvent : public EventArg
+	{
+	public:
+		MultiTouchEvent( Object *obj, const MultiTouchState &ms ) : EventArg(obj), state(ms) {}
+		virtual ~MultiTouchEvent() {}
+
+		//! The state of the touch - including axes
+		const MultiTouchState &state;
+	};
+
+	/**
+		To receive buffered touch input, derive a class from this, and implement the
+		methods here. Then set the call back to your MultiTouch instance with MultiTouch::setEventCallback
+	*/
+	class _OISExport MultiTouchListener
+	{
+	public:
+		virtual ~MultiTouchListener() {}
+		virtual bool touchMoved( const MultiTouchEvent &arg ) = 0;
+		virtual bool touchPressed( const MultiTouchEvent &arg ) = 0;
+		virtual bool touchReleased( const MultiTouchEvent &arg ) = 0;
+		virtual bool touchCancelled( const MultiTouchEvent &arg ) = 0;
+	};
+
+	/**
+		MultiTouch base class. To be implemented by specific system (ie. iPhone UITouch)
+		This class is useful as you remain OS independent using this common interface.
+	*/
+	class _OISExport MultiTouch : public Object
+	{
+	public:
+		virtual ~MultiTouch() {}
+
+		/**
+		@remarks
+			Register/unregister a MultiTouch Listener - Only one allowed for simplicity. If broadcasting
+			is necessary, just broadcast from the callback you registered.
+		@param touchListener
+			Send a pointer to a class derived from MultiTouchListener or 0 to clear the callback
+		*/
+		virtual void setEventCallback( MultiTouchListener *touchListener ) {mListener = touchListener;}
+
+		/** @remarks Returns currently set callback.. or 0 */
+		MultiTouchListener* getEventCallback() {return mListener;}
+
+		/** @remarks Clear out the set of input states.  Should be called after input has been processed by the application */
+        void clearStates(void) { mStates.clear(); }
+
+		/** @remarks Returns the state of the touch - is valid for both buffered and non buffered mode */
+		std::vector<MultiTouchState> getMultiTouchStates() const { return mStates; }
+        
+        /** @remarks Returns the first n touch states.  Useful if you know your app only needs to 
+                process n touches.  The return value is a vector to allow random access */
+        const std::vector<MultiTouchState> getFirstNTouchStates(int n) {
+            std::vector<MultiTouchState> states;
+            for( unsigned int i = 0; i < mStates.size(); i++ ) {
+                if(!(mStates[i].touchIsType(MT_None))) {
+                    states.push_back(mStates[i]);
+                }
+            }
+            return states;
+        }
+
+        /** @remarks Returns the first n touch states.  Useful if you know your app only needs to 
+         process n touches.  The return value is a vector to allow random access */
+        const std::vector<MultiTouchState> getMultiTouchStatesOfType(MultiTypeEventTypeID type) {
+            std::vector<MultiTouchState> states;
+            for( unsigned int i = 0; i < mStates.size(); i++ ) {
+                if(mStates[i].touchIsType(type)) {
+                    states.push_back(mStates[i]);
+                }
+            }
+            return states;
+        }
+        
+	protected:
+		MultiTouch(const std::string &vendor, bool buffered, int devID, InputManager* creator)
+			: Object(vendor, OISMultiTouch, buffered, devID, creator), mListener(0) {}
+
+		//! The state of the touch device, implemented in a vector to store the state from each finger touch
+        std::vector<MultiTouchState> mStates;
+
+		//! Used for buffered/actionmapping callback
+		MultiTouchListener *mListener;
+	};
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISObject.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISObject.h
new file mode 100644
index 0000000..3b32df3
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISObject.h
@@ -0,0 +1,95 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_Object_H
+#define OIS_Object_H
+
+#include "OISPrereqs.h"
+#include "OISInterface.h"
+
+namespace OIS
+{
+	/**	The base class of all input types. */
+	class _OISExport Object
+	{
+	public:
+		virtual ~Object() {}
+
+		/**	@remarks Get the type of device	*/
+		Type type() const { return mType; }
+
+		/**	@remarks Get the vender string name	*/
+		const std::string& vendor() const { return mVendor; }
+
+		/**	@remarks Get buffered mode - true is buffered, false otherwise */
+		virtual bool buffered() const { return mBuffered; }
+
+		/** @remarks Returns this input object's creator */
+		InputManager* getCreator() const { return mCreator; }
+
+		/** @remarks Sets buffered mode	*/
+		virtual void setBuffered(bool buffered) = 0;
+
+		/**	@remarks Used for updating call once per frame before checking state or to update events */
+		virtual void capture() = 0;
+
+		/**	@remarks This may/may not) differentiate the different controllers based on (for instance) a port number (useful for console InputManagers) */
+		virtual int getID() const {return mDevID;}
+
+		/**
+		@remarks
+			If available, get an interface to write to some devices.
+			Examples include, turning on and off LEDs, ForceFeedback, etc
+		@param type
+			The type of interface you are looking for
+		*/
+		virtual Interface* queryInterface(Interface::IType type) = 0;
+
+		/**	@remarks Internal... Do not call this directly. */
+		virtual void _initialize() = 0;
+
+	protected:
+		Object(const std::string &vendor, Type iType, bool buffered,
+			   int devID, InputManager* creator) :
+					mVendor(vendor),
+					mType(iType),
+					mBuffered(buffered),
+					mDevID(devID),
+					mCreator(creator) {}
+
+		//! Vendor name if applicable/known
+		std::string mVendor;
+
+		//! Type of controller object
+		Type mType;
+
+		//! Buffered flag
+		bool mBuffered;
+
+		//! Not fully implemented yet
+		int mDevID;
+
+		//! The creator who created this object
+		InputManager* mCreator;
+	};
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISPrereqs.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISPrereqs.h
new file mode 100644
index 0000000..12efd8d
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/OISPrereqs.h
@@ -0,0 +1,227 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that
+		you wrote the original software. If you use this software in a product,
+		an acknowledgment in the product documentation would be appreciated but is
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_Prereqs_H
+#define OIS_Prereqs_H
+//----------------------------------------------------------------------------//
+// This Header File contains: forward declared classes
+//  * Forward Declarations of all public API classes
+//  * Several typedef's used around the library
+//  * Base class component types
+//  * Preprocessor definitons
+//----------------------------------------------------------------------------//
+
+//-------------- Common STL Containers ---------------------------------------//
+#include <vector>
+#include <string>
+#include <map>
+#include "OISConfig.h"
+
+// Default is blank for most OS's
+#define _OISExport
+
+//-------------- Determine Compiler ---------------------------------
+#if defined( _MSC_VER )
+#	define OIS_MSVC_COMPILER
+#elif defined( __GNUC__ )
+#	if defined( __WIN32__ ) || defined( _WIN32 )
+#		define OIS_MINGW_COMPILER
+#	else
+#		define OIS_GCC_COMPILER
+#	endif
+#elif defined( __BORLANDC__ )
+#	define OIS_BORLAND_COMPILER
+#else
+#	error No Recognized Compiler!
+#endif
+
+// --------------- Determine Operating System Platform ---------------
+#if defined( __WIN32__ ) || defined( _WIN32 ) // Windows 2000, XP, ETC
+#	if defined ( _XBOX )
+#		define OIS_XBOX_PLATFORM
+#	else
+#		define OIS_WIN32_PLATFORM
+#		if defined( OIS_DYNAMIC_LIB )
+#			undef _OISExport
+			//Ignorable Dll interface warning...
+#           if !defined(OIS_MINGW_COMPILER)
+#			    pragma warning (disable : 4251)
+#           endif
+#			if defined( OIS_NONCLIENT_BUILD )
+#				define _OISExport __declspec( dllexport )
+#			else
+#               if defined(OIS_MINGW_COMPILER)
+#                   define _OISExport
+#               else
+#				    define _OISExport __declspec( dllimport )
+#               endif
+#			endif
+#		endif
+#	endif
+#elif defined( __APPLE_CC__ ) // Apple OS X
+    // Device                                       Simulator
+#   if __IPHONE_OS_VERSION_MIN_REQUIRED >= 20201 || __IPHONE_OS_VERSION_MIN_REQUIRED >= 20000
+//#   if __IPHONE_OS_VERSION_MIN_REQUIRED >= 30000 || __IPHONE_OS_VERSION_MIN_REQUIRED >= 30000
+#       define OIS_IPHONE_PLATFORM
+#   else
+#       define OIS_APPLE_PLATFORM
+#   endif
+#   undef _OISExport
+#   define _OISExport __attribute__((visibility("default")))
+#else //Probably Linux
+#	define OIS_LINUX_PLATFORM
+#	include <unistd.h>
+#endif
+
+//Is Processor 32 or 64 bits...
+#if defined(__x86_64__)
+#	define OIS_ARCH_64
+#else
+#	define OIS_ARCH_32
+#endif
+
+//-------------- Common Classes, Enums, and Typdef's -------------------------//
+#define OIS_VERSION_MAJOR 1
+#define OIS_VERSION_MINOR 4
+#define OIS_VERSION_PATCH 0
+#define OIS_VERSION_NAME "1.4.0"
+
+#define OIS_VERSION ((OIS_VERSION_MAJOR << 16) | (OIS_VERSION_MINOR << 8) | OIS_VERSION_PATCH)
+
+namespace OIS
+{
+	//Forward Declarations
+	class InputManager;
+	class FactoryCreator;
+	class Object;
+	class Keyboard;
+	class Mouse;
+	class JoyStick;
+	class MultiTouch;
+	class KeyListener;
+	class MouseListener;
+	class MultiTouchListener;
+	class JoyStickListener;
+	class Interface;
+	class ForceFeedback;
+	class Effect;
+	class Exception;
+
+	//! Way to send OS nuetral parameters.. ie OS Window handles, modes, flags
+	typedef std::multimap<std::string, std::string> ParamList;
+
+	//! List of FactoryCreator's
+	typedef std::vector<FactoryCreator*> FactoryList;
+
+	//! Map of FactoryCreator created Objects
+	typedef std::map<Object*, FactoryCreator*> FactoryCreatedObject;
+
+	//! Each Input class has a General Type variable, a form of RTTI
+	enum Type
+	{
+		OISUnknown       = 0,
+		OISKeyboard      = 1,
+		OISMouse         = 2,
+		OISJoyStick      = 3,
+		OISTablet        = 4,
+		OISMultiTouch    = 5
+	};
+
+	//! Map of device objects connected and their respective vendors
+	typedef std::multimap<Type, std::string> DeviceList;
+
+	//--------     Shared common components    ------------------------//
+
+	//! Base type for all device components (button, axis, etc)
+	enum ComponentType
+	{
+		OIS_Unknown = 0,
+		OIS_Button  = 1, //ie. Key, mouse button, joy button, etc
+		OIS_Axis    = 2, //ie. A joystick or mouse axis
+		OIS_Slider  = 3, //
+		OIS_POV     = 4, //ie. Arrow direction keys
+		OIS_Vector3 = 5  //ie. WiiMote orientation
+	};
+
+	//! Base of all device components (button, axis, etc)
+	class _OISExport Component
+	{
+	public:
+		Component() : cType(OIS_Unknown) {};
+		Component(ComponentType type) : cType(type) {};
+		//! Indicates what type of coponent this is
+		ComponentType cType;
+	};
+
+	//! Button can be a keyboard key, mouse button, etc
+	class _OISExport Button : public Component
+	{
+	public:
+		Button() : Component(OIS_Button), pushed(false) {}
+		Button(bool bPushed) : Component(OIS_Button), pushed(bPushed) {}
+		//! true if pushed, false otherwise
+		bool pushed;
+	};
+
+	//! Axis component
+	class _OISExport Axis : public Component
+	{
+	public:
+		Axis() : Component(OIS_Axis), abs(0), rel(0), absOnly(false) {};
+
+		//! Absoulte and Relative value components
+		int abs, rel;
+
+		//! Indicates if this Axis only supports Absoulte (ie JoyStick)
+		bool absOnly;
+
+		//! Used internally by OIS
+		void clear()
+		{
+			abs = rel = 0;
+		}
+	};
+
+	//! A 3D Vector component (perhaps an orientation, as in the WiiMote)
+	class _OISExport Vector3 : public Component
+	{
+	public:
+		Vector3() {}
+		Vector3(float _x, float _y, float _z) : Component(OIS_Vector3), x(_x), y(_y), z(_z) {};
+		
+		//! X component of vector
+		float x;
+		
+		//! Y component of vector
+		float y;
+
+		//! Z component of vector
+		float z;
+
+		void clear()
+		{
+			x = y = z = 0.0f;
+		}
+	};
+}
+
+#endif //end if prereq header defined
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/SDL/SDLInputManager.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/SDL/SDLInputManager.h
new file mode 100644
index 0000000..2be1ad3
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/SDL/SDLInputManager.h
@@ -0,0 +1,73 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_SDLInputManager_H
+#define OIS_SDLInputManager_H
+
+#include "OISInputManager.h"
+#include "SDL/SDLPrereqs.h"
+
+namespace OIS
+{
+	/**
+		SDL Input Manager wrapper
+	*/
+	class SDLInputManager : public InputManager
+	{
+	public:
+		SDLInputManager();
+		virtual ~SDLInputManager();
+
+		/** @copydoc InputManager::inputSystemName */
+		virtual const std::string& inputSystemName() { return iName; }
+		
+		/** @copydoc InputManager::numJoysticks */
+		virtual int numJoySticks();
+		/** @copydoc InputManager::numMice */
+		virtual int numMice();
+		/** @copydoc InputManager::numKeyBoards */
+		virtual int numKeyboards();
+		
+		/** @copydoc InputManager::createInputObject */
+		Object* createInputObject( Type iType, bool bufferMode );
+		/** @copydoc InputManager::destroyInputObject */
+		void destroyInputObject( Object* obj );
+
+		/** @copydoc InputManager::_initialize */
+		void _initialize( ParamList &paramList );
+
+		//Utility methods to coordinate between mouse and keyboard grabbing
+		bool _getGrabMode() {return mGrabbed;};
+		void _setGrabMode(bool grabbed) {mGrabbed = grabbed;}
+
+	protected:
+		//! internal class method for dealing with param list
+		void _parseConfigSettings( ParamList &paramList );
+		//! internal class method for finding attached devices
+		void _enumerateDevices();
+
+		static const std::string iName;
+
+		bool mGrabbed;
+	};
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/SDL/SDLJoyStick.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/SDL/SDLJoyStick.h
new file mode 100644
index 0000000..e69de29
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/SDL/SDLKeyboard.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/SDL/SDLKeyboard.h
new file mode 100644
index 0000000..193d311
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/SDL/SDLKeyboard.h
@@ -0,0 +1,79 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef _OIS_SDLKEYBOARD_H
+#define _OIS_SDLKEYBOARD_H
+
+#include "OISKeyboard.h"
+#include "SDL/SDLPrereqs.h"
+
+namespace OIS
+{
+	class SDLKeyboard : public Keyboard
+	{
+	public:
+		/**
+		@remarks
+			Constructor
+		@param buffered
+			True for buffered input mode
+		*/
+		SDLKeyboard( bool buffered );
+		virtual ~SDLKeyboard();
+
+		/** @copydoc Keyboard::isKeyDown */
+		virtual bool isKeyDown( KeyCode key );
+
+		/** @copydoc Keyboard::getAsString */
+		virtual const std::string& getAsString( KeyCode kc );
+
+		/** @copydoc Keyboard::copyKeyStates */
+		virtual void copyKeyStates( char keys[256] );
+
+		/** @copydoc Object::setBuffered */
+		virtual void setBuffered(bool buffered);
+
+		/** @copydoc Object::capture */
+		virtual void capture();
+
+		/** @copydoc Object::queryInterface */
+		virtual Interface* queryInterface(Interface::IType type) {return 0;}
+
+		/** @copydoc Object::_initialize */
+		virtual void _initialize();
+
+		/** @copydoc Object::setTextTranslation */
+		virtual void setTextTranslation( TextTranslationMode mode );
+
+	protected:
+		SDLKeyboard() {}
+
+		typedef std::map<SDLKey, KeyCode> KeyMap;
+        KeyMap mKeyMap;
+
+		unsigned char KeyBuffer[256];
+		Uint8* mSDLBuff;
+
+		std::string mGetString;
+	};
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/SDL/SDLMouse.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/SDL/SDLMouse.h
new file mode 100644
index 0000000..58a3e4e
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/SDL/SDLMouse.h
@@ -0,0 +1,59 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+	1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+	2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+	3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef _OIS_SDLMOUSE_H
+#define _OIS_SDLMOUSE_H
+
+#include "OISMouse.h"
+#include "SDL/SDLPrereqs.h"
+
+namespace OIS
+{
+	class SDLMouse : public Mouse
+	{
+	public:
+		SDLMouse( bool buffered );
+		virtual ~SDLMouse();
+		
+		/** @copydoc Object::setBuffered */
+		virtual void setBuffered(bool buffered);
+
+		/** @copydoc Object::capture */
+		virtual void capture();
+
+		/** @copydoc Object::queryInterface */
+		virtual Interface* queryInterface(Interface::IType type) {return 0;}
+
+		/** @copydoc Object::_initialize */
+		virtual void _initialize();
+
+		void _setGrab(bool grabbed);
+		void _setVisible(bool visible);
+
+	protected:
+		SDLMouse() {}
+
+		bool mGrabbed;
+		bool mRegainFocus;
+	};
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/SDL/SDLPrereqs.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/SDL/SDLPrereqs.h
new file mode 100644
index 0000000..2b25c2a
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/SDL/SDLPrereqs.h
@@ -0,0 +1,38 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_SDLPrereqs_H
+#define OIS_SDLPrereqs_H
+
+#include "OISPrereqs.h"
+
+#ifdef OIS_APPLE_PLATFORM
+#  include <SDL/SDL.h>
+#else
+#  include <SDL.h>
+#endif
+
+#define OIS_SDL_KEY_BUFF   16
+#define OIS_SDL_MOUSE_BUFF 50
+#define OIS_SDL_JOY_BUFF   80
+
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/iphone/iPhoneAccelerometer.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/iphone/iPhoneAccelerometer.h
new file mode 100644
index 0000000..adc11a3
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/iphone/iPhoneAccelerometer.h
@@ -0,0 +1,50 @@
+#ifndef OIS_iPhoneAccelerometer_H
+#define OIS_iPhoneAccelerometer_H
+
+#include "OISJoystick.h"
+#include "iphone/iPhonePrereqs.h"
+
+#import <UIKit/UIKit.h>
+@class iPhoneAccelerometerDelegate;
+
+class JoyStickState;
+
+namespace OIS
+{
+	class iPhoneAccelerometer : public JoyStick
+    {
+	public:
+		iPhoneAccelerometer(InputManager* creator, bool buffered);
+		virtual ~iPhoneAccelerometer();
+		
+		/** @copydoc Object::setBuffered */
+		virtual void setBuffered(bool buffered);
+
+        void setUpdateInterval(float interval) { 
+            mUpdateInterval = interval;
+            [[UIAccelerometer sharedAccelerometer] setUpdateInterval:(1.0f / mUpdateInterval)];
+        }
+        
+        Vector3 getAccelerometerVector3(void) { return mState.mVectors[0]; }
+		/** @copydoc Object::capture */
+		virtual void capture();
+
+		/** @copydoc Object::queryInterface */
+		virtual Interface* queryInterface(Interface::IType type) {return 0;}
+
+		/** @copydoc Object::_initialize */
+		virtual void _initialize();
+
+        void didAccelerate(UIAcceleration *acceleration);
+
+    protected:
+        iPhoneAccelerometerDelegate *accelerometerDelegate;
+
+        /** The update frequency of the accelerometer.  Represented in times per second. */
+        float mUpdateInterval;
+        Vector3 mTempState;
+	};
+}
+
+
+#endif // OIS_iPhoneAccelerometer_H
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/iphone/iPhoneHelpers.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/iphone/iPhoneHelpers.h
new file mode 100644
index 0000000..6c0dbc5
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/iphone/iPhoneHelpers.h
@@ -0,0 +1,56 @@
+/*
+ The zlib/libpng License
+ 
+ Copyright (c) 2006 Chris Snyder 
+ 
+ This software is provided 'as-is', without any express or implied warranty. In no event will
+ the authors be held liable for any damages arising from the use of this software.
+ 
+ Permission is granted to anyone to use this software for any purpose, including commercial 
+ applications, and to alter it and redistribute it freely, subject to the following
+ restrictions:
+ 
+ 1. The origin of this software must not be misrepresented; you must not claim that 
+ you wrote the original software. If you use this software in a product, 
+ an acknowledgment in the product documentation would be appreciated but is 
+ not required.
+ 
+ 2. Altered source versions must be plainly marked as such, and must not be 
+ misrepresented as being the original software.
+ 
+ 3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_iPhoneHelpers_H
+#define OIS_iPhoneHelpers_H
+
+#include "iphone/iPhonePrereqs.h"
+#include "OISMultiTouch.h"
+
+// This is needed for keeping an event stack for keyboard and mouse
+namespace OIS
+{
+    // used in the eventStack to store the type
+    enum iPhone_EventType { iPhone_KEYUP = 0,
+                         iPhone_KEYDOWN = 1,
+                         iPhone_KEYREPEAT,
+                         iPhone_MOUSEDOWN,
+                         iPhone_MOUSEUP,
+                         iPhone_MOUSEMOVED,
+                         iPhone_MOUSESCROLL};
+    typedef enum iPhone_EventType iPhoneEventType;
+
+    // only used by iPhoneMultiTouch
+    typedef class iPhoneMultiTouchStackEvent
+    {
+        friend class iPhoneMultiTouch;
+        
+    private:
+        iPhoneMultiTouchStackEvent( MultiTouchEvent event, iPhoneEventType type) : Event(event), Type(type) {}
+        
+        iPhoneEventType Type;
+        MultiTouchEvent Event;
+        
+    } iPhoneMultiTouchStackEvent;
+}
+
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/iphone/iPhoneInputManager.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/iphone/iPhoneInputManager.h
new file mode 100644
index 0000000..3f9f88d
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/iphone/iPhoneInputManager.h
@@ -0,0 +1,110 @@
+/*
+ The zlib/libpng License
+ 
+ Copyright (c) 2006 Chris Snyder 
+ 
+ This software is provided 'as-is', without any express or implied warranty. In no event will
+ the authors be held liable for any damages arising from the use of this software.
+ 
+ Permission is granted to anyone to use this software for any purpose, including commercial 
+ applications, and to alter it and redistribute it freely, subject to the following
+ restrictions:
+ 
+ 1. The origin of this software must not be misrepresented; you must not claim that 
+ you wrote the original software. If you use this software in a product, 
+ an acknowledgment in the product documentation would be appreciated but is 
+ not required.
+ 
+ 2. Altered source versions must be plainly marked as such, and must not be 
+ misrepresented as being the original software.
+ 
+ 3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_iPhoneInputManager_H
+#define OIS_iPhoneInputManager_H
+
+#include "OISInputManager.h"
+#include "OISFactoryCreator.h"
+#include "iphone/iPhonePrereqs.h"
+
+#import <UIKit/UIKit.h>
+namespace OIS {
+    class iPhoneAccelerometer;
+    class iPhoneMultiTouch;
+}
+
+@interface InputDelegate : UIView <UIAccelerometerDelegate> {
+    OIS::iPhoneAccelerometer    *accelerometerObject;
+    OIS::iPhoneMultiTouch       *touchObject;
+}
+
+@property (assign) OIS::iPhoneAccelerometer     *accelerometerObject;
+@property (assign) OIS::iPhoneMultiTouch        *touchObject;
+
+@end
+
+namespace OIS
+{
+
+    class iPhoneInputManager : public InputManager, public FactoryCreator
+    {
+    public:
+        iPhoneInputManager();
+        virtual ~iPhoneInputManager();
+        
+		//InputManager Overrides
+		/** @copydoc InputManager::_initialize */
+		void _initialize( ParamList &paramList );
+
+		//FactoryCreator Overrides
+		/** @copydoc FactoryCreator::deviceList */
+		DeviceList freeDeviceList();
+
+		/** @copydoc FactoryCreator::totalDevices */
+		int totalDevices(Type iType);
+
+		/** @copydoc FactoryCreator::freeDevices */
+		int freeDevices(Type iType);
+
+		/** @copydoc FactoryCreator::vendorExist */
+		bool vendorExist(Type iType, const std::string & vendor);
+
+		/** @copydoc FactoryCreator::createObject */
+		Object* createObject(InputManager* creator, Type iType, bool bufferMode, const std::string & vendor = "");
+
+		/** @copydoc FactoryCreator::destroyObject */
+		void destroyObject(Object* obj);
+
+		//Internal Items
+
+		//! Internal method, used for flagging multi-touch as available/unavailable for creation
+		void _setMultiTouchUsed(bool used) { bMultiTouchUsed = used; }
+
+        //! Internal method, used for flagging accelerometer as available/unavailable for creation
+		void _setAccelerometerUsed(bool used) { bAccelerometerUsed = used; }
+
+        //! methodfor getting the delegate
+        InputDelegate * _getDelegate() { return mDelegate; }
+
+        //! method for getting window
+        UIWindow * _getWindow() { return mWindow; }
+
+    protected:        
+        void _parseConfigSettings( ParamList& paramList );
+
+        // iPhone stuff
+		UIWindow *mWindow;
+        InputDelegate *mDelegate;
+
+        // settings
+        bool mHideMouse;
+
+		//! Used to know if we used up multi-touch device
+		bool bMultiTouchUsed;
+
+        //! Used to know if we used up accelerometer
+		bool bAccelerometerUsed;
+    };
+}
+
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/iphone/iPhoneMultiTouch.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/iphone/iPhoneMultiTouch.h
new file mode 100644
index 0000000..56acede
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/iphone/iPhoneMultiTouch.h
@@ -0,0 +1,64 @@
+/*
+ The zlib/libpng License
+ 
+ Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+ 
+ This software is provided 'as-is', without any express or implied warranty. In no event will
+ the authors be held liable for any damages arising from the use of this software.
+ 
+ Permission is granted to anyone to use this software for any purpose, including commercial
+ applications, and to alter it and redistribute it freely, subject to the following
+ restrictions:
+ 
+ 1. The origin of this software must not be misrepresented; you must not claim that
+ you wrote the original software. If you use this software in a product,
+ an acknowledgment in the product documentation would be appreciated but is
+ not required.
+ 
+ 2. Altered source versions must be plainly marked as such, and must not be
+ misrepresented as being the original software.
+ 
+ 3. This notice may not be removed or altered from any source distribution.
+ */
+#ifndef OIS_iPhoneMultiTouch_H
+#define OIS_iPhoneMultiTouch_H
+
+#include "OISMultiTouch.h"
+#include "iphone/iPhonePrereqs.h"
+
+#import <UIKit/UIKit.h>
+
+struct CGPoint;
+
+namespace OIS
+{
+	class iPhoneMultiTouch : public MultiTouch
+    {
+	public:
+		iPhoneMultiTouch( InputManager* creator, bool buffered );
+		virtual ~iPhoneMultiTouch();
+		
+		/** @copydoc Object::setBuffered */
+		virtual void setBuffered(bool buffered);
+
+		/** @copydoc Object::capture */
+		virtual void capture();
+
+		/** @copydoc Object::queryInterface */
+		virtual Interface* queryInterface(Interface::IType type) {return 0;}
+
+		/** @copydoc Object::_initialize */
+		virtual void _initialize();
+
+        void _touchBegan(UITouch *touch);
+        void _touchEnded(UITouch *touch);
+        void _touchMoved(UITouch *touch);
+        void _touchCancelled(UITouch *touch);
+        
+	protected:
+		MultiTouchState mTempState;
+	};
+}
+
+
+#endif // OIS_iPhoneTouch_H
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/iphone/iPhonePrereqs.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/iphone/iPhonePrereqs.h
new file mode 100644
index 0000000..a492561
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/iphone/iPhonePrereqs.h
@@ -0,0 +1,56 @@
+/*
+ The zlib/libpng License
+ 
+ Copyright (c) 2006 Chris Snyder 
+ 
+ This software is provided 'as-is', without any express or implied warranty. In no event will
+ the authors be held liable for any damages arising from the use of this software.
+ 
+ Permission is granted to anyone to use this software for any purpose, including commercial 
+ applications, and to alter it and redistribute it freely, subject to the following
+ restrictions:
+ 
+ 1. The origin of this software must not be misrepresented; you must not claim that 
+ you wrote the original software. If you use this software in a product, 
+ an acknowledgment in the product documentation would be appreciated but is 
+ not required.
+ 
+ 2. Altered source versions must be plainly marked as such, and must not be 
+ misrepresented as being the original software.
+ 
+ 3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_iPhonePrereqs_H
+#define OIS_iPhonePrereqs_H
+
+#include <string>
+#include <list>
+#include <CoreFoundation/CoreFoundation.h>
+
+namespace OIS
+{
+    class iPhoneInputManager;
+    class iPhoneAccelerometer;
+	class iPhoneMouse;
+
+	/** 
+		Simple wrapper class for CFString which will create a valid CFString and retain ownership until class instance is outof scope
+		To Access the CFStringRef instance, simply cast to void*, pass into a function expecting a void* CFStringRef object, or access via cf_str() method
+	*/
+	class OIS_CFString
+	{
+	public:
+		OIS_CFString() { m_StringRef = CFStringCreateWithCString(NULL, "", kCFStringEncodingUTF8); }
+		OIS_CFString(const char* c_str) { m_StringRef = CFStringCreateWithCString(NULL, c_str, kCFStringEncodingUTF8); }
+		OIS_CFString(const std::string &s_str) { m_StringRef = CFStringCreateWithCString(NULL, s_str.c_str(), kCFStringEncodingUTF8); }
+		~OIS_CFString() { CFRelease(m_StringRef); }
+
+		//Allow this class to be autoconverted to base class of StringRef (void*)
+		operator void*() { return (void*)m_StringRef; }
+		CFStringRef cf_str() { return m_StringRef; }
+	
+	private:
+		CFStringRef m_StringRef;
+	};
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/linux/EventHelpers.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/linux/EventHelpers.h
new file mode 100644
index 0000000..05a5671
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/linux/EventHelpers.h
@@ -0,0 +1,49 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that
+		you wrote the original software. If you use this software in a product,
+		an acknowledgment in the product documentation would be appreciated but is
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef _LINUX_OISEVENT_HEADER_
+#define _LINUX_OISEVENT_HEADER_
+
+#include "linux/LinuxPrereqs.h"
+
+#define OIS_MAX_DEVICES 32
+#define OIS_DEVICE_NAME 128
+
+namespace OIS
+{
+	class EventUtils
+	{
+	public:
+		static bool isJoyStick( int deviceID, JoyStickInfo &js );
+		static bool isMouse( int ) {return false;}
+		static bool isKeyboard( int ) {return false;}
+
+		//Double pointer is so that we can set the value of the sent pointer
+		static void enumerateForceFeedback( int deviceID, LinuxForceFeedback** ff );
+		static void removeForceFeedback( LinuxForceFeedback** ff );
+
+		static std::string getName( int deviceID );
+		static std::string getUniqueId( int deviceID );
+		static std::string getPhysicalLocation( int deviceID );
+	};
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/linux/LinuxForceFeedback.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/linux/LinuxForceFeedback.h
new file mode 100644
index 0000000..d803c67
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/linux/LinuxForceFeedback.h
@@ -0,0 +1,85 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_LinuxForceFeedBack_H
+#define OIS_LinuxForceFeedBack_H
+
+#include "linux/LinuxPrereqs.h"
+#include "OISForceFeedback.h"
+#include <linux/input.h>
+
+namespace OIS
+{
+	class LinuxForceFeedback : public ForceFeedback
+	{
+	public:
+		LinuxForceFeedback(int deviceID);
+		~LinuxForceFeedback();
+
+		/** @copydoc ForceFeedback::setMasterGain */
+		void setMasterGain(float);
+		
+		/** @copydoc ForceFeedback::setAutoCenterMode */
+		void setAutoCenterMode(bool);
+
+		/** @copydoc ForceFeedback::upload */
+		void upload( const Effect* effect );
+
+		/** @copydoc ForceFeedback::modify */
+		void modify( const Effect* effect );
+
+		/** @copydoc ForceFeedback::remove */
+		void remove( const Effect* effect );
+
+		/** FF is not yet implemented fully on Linux.. just return -1 for now. todo, xxx */
+		short int getFFAxesNumber() { return -1; }
+
+		/** @copydoc ForceFeedback::getFFMemoryLoad */
+		unsigned short getFFMemoryLoad();
+
+	protected:
+
+		//Sets the common properties to all effects
+		void _setCommonProperties(struct ff_effect *event, struct ff_envelope *ffenvelope, 
+								  const Effect* effect, const Envelope *envelope );
+
+		//Specific Effect Settings
+		void _updateConstantEffect( const Effect* effect );
+		void _updateRampEffect( const Effect* effect );
+		void _updatePeriodicEffect( const Effect* effect );
+		void _updateConditionalEffect( const Effect* effect );
+		//void _updateCustomEffect( const Effect* effect );
+
+		void _upload( struct ff_effect* ffeffect, const Effect* effect);
+		void _stop( int handle);
+		void _start( int handle);
+		void _unload( int handle);
+
+		// Map of currently uploaded effects (handle => effect)
+		typedef std::map<int, struct ff_effect *> EffectList;
+		EffectList mEffectList;
+
+		// Joystick device (file) descriptor.
+		int mJoyStick;
+	};
+}
+#endif //OIS_LinuxForceFeedBack_H
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/linux/LinuxInputManager.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/linux/LinuxInputManager.h
new file mode 100644
index 0000000..a3a5f0b
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/linux/LinuxInputManager.h
@@ -0,0 +1,105 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_LinuxInputManager_H
+#define OIS_LinuxInputManager_H
+
+#include "linux/LinuxPrereqs.h"
+#include "OISFactoryCreator.h"
+#include "OISInputManager.h"
+#include <X11/Xlib.h>
+
+namespace OIS
+{
+	/**
+		Linux X11 InputManager specialization - Using lowlevel joys
+	*/
+	class LinuxInputManager : public InputManager, public FactoryCreator
+	{
+	public:
+		LinuxInputManager();
+		virtual ~LinuxInputManager();
+
+		//InputManager Overrides
+		/** @copydoc InputManager::_initialize */
+		void _initialize( ParamList &paramList );
+
+		//FactoryCreator Overrides
+		/** @copydoc FactoryCreator::deviceList */
+		DeviceList freeDeviceList();
+
+		/** @copydoc FactoryCreator::totalDevices */
+		int totalDevices(Type iType);
+
+		/** @copydoc FactoryCreator::freeDevices */
+		int freeDevices(Type iType);
+
+		/** @copydoc FactoryCreator::vendorExist */
+		bool vendorExist(Type iType, const std::string & vendor);
+
+		/** @copydoc FactoryCreator::createObject */
+		Object* createObject(InputManager *creator, Type iType, bool bufferMode, const std::string & vendor = "");
+
+		/** @copydoc FactoryCreator::destroyObject */
+		void destroyObject(Object* obj);
+
+		//Internal Items
+		//! Method for retrieving the XWindow Handle
+		Window _getWindow() {return window;}
+
+		//! Internal method for checking if regrabbing is needed
+		void _setGrabState(bool grab) {mGrabs = grab;}
+		bool _getGrabState() {return mGrabs;}
+
+		//! Internal method, used for flaggin keyboard as available/unavailable for creation
+		void _setKeyboardUsed(bool used) {keyboardUsed = used; }
+
+		//! Internal method, used for flaggin mouse as available/unavailable for creation
+		void _setMouseUsed(bool used) { mouseUsed = used; }
+		
+	protected:
+		//! internal class method for dealing with param list
+		void _parseConfigSettings( ParamList &paramList );
+		//! internal class method for finding attached devices
+		void _enumerateDevices();
+
+		//! List of unused joysticks ready to be used
+		JoyStickInfoList unusedJoyStickList;
+		//! Number of joysticks found
+		char joySticks;
+
+		//! Used to know if we used up keyboard
+		bool keyboardUsed;
+
+		//! Used to know if we used up mouse
+		bool mouseUsed;
+
+		//! X11 Stuff
+		Window window;
+		
+		/// Keyboard, Mouse Settings
+		bool grabMouse, grabKeyboard;
+		bool mGrabs;
+		bool hideMouse;
+	};
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/linux/LinuxJoyStickEvents.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/linux/LinuxJoyStickEvents.h
new file mode 100644
index 0000000..105b678
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/linux/LinuxJoyStickEvents.h
@@ -0,0 +1,72 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef _LINUX_JOYSTICK_H_EADER_
+#define _LINUX_JOYSTICK_H_EADER_
+
+#include "linux/LinuxPrereqs.h"
+#include "OISJoyStick.h"
+
+namespace OIS
+{
+	/**
+		Linux specialization of JoyStick class.. This version is favored over the other.. and has the
+		*possibility* of Force Feedback.. notice I say possibility, i make no gaurantees under linux,
+		as FF support is sketchy at best AFAIK.
+	*/
+	class LinuxJoyStick : public JoyStick
+	{
+	public:
+		LinuxJoyStick(InputManager* creator, bool buffered, const JoyStickInfo& js);
+		virtual ~LinuxJoyStick();
+
+		/** @copydoc Object::setBuffered */
+		virtual void setBuffered(bool buffered);
+
+		/** @copydoc Object::capture */
+		virtual void capture();
+
+		/** @copydoc Object::queryInterface */
+		virtual Interface* queryInterface(Interface::IType type);
+
+		/** @copydoc Object::_initialize */
+		virtual void _initialize();
+
+		/**
+		@remarks
+			For internal use only... Returns a structure to the manager, to make the device
+			availiable for use again
+		*/
+		JoyStickInfo _getJoyInfo();
+
+		static JoyStickInfoList _scanJoys();
+		static void _clearJoys(JoyStickInfoList &joys);
+	protected:
+
+		int mJoyStick;
+		LinuxForceFeedback* ff_effect;
+		std::map <int, int> mButtonMap;
+		std::map <int, int> mAxisMap;
+		std::map <int, Range> mRanges;
+	};
+}
+#endif //_LINUX_JOYSTICK_H_EADER_
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/linux/LinuxKeyboard.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/linux/LinuxKeyboard.h
new file mode 100644
index 0000000..9821094
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/linux/LinuxKeyboard.h
@@ -0,0 +1,98 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that
+		you wrote the original software. If you use this software in a product,
+		an acknowledgment in the product documentation would be appreciated but is
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef _LINUX_KEYBOARD_H_EADER_
+#define _LINUX_KEYBOARD_H_EADER_
+
+#include "linux/LinuxPrereqs.h"
+#include "OISKeyboard.h"
+#include <X11/Xlib.h>
+
+namespace OIS
+{
+	/** Linux implementation of Keyboard object - uses x11 */
+	class LinuxKeyboard : public Keyboard
+	{
+	public:
+		LinuxKeyboard(InputManager* creator, bool buffered, bool grab);
+		virtual ~LinuxKeyboard();
+
+		/** @copydoc Keyboard::isKeyDown */
+		virtual bool isKeyDown( KeyCode key ) const;
+
+		/** @copydoc Keyboard::getAsString */
+		virtual const std::string& getAsString( KeyCode kc );
+
+		/** @copydoc Keyboard::copyKeyStates */
+		virtual void copyKeyStates( char keys[256] ) const;
+
+		/** @copydoc Object::setBuffered */
+		virtual void setBuffered(bool buffered);
+
+		/** @copydoc Object::capture */
+		virtual void capture();
+
+		/** @copydoc Object::queryInterface */
+		virtual Interface* queryInterface(Interface::IType) {return 0;}
+
+		/** @copydoc Object::_initialize */
+		virtual void _initialize();
+
+	protected:
+		inline bool _isKeyRepeat(XEvent &event)
+		{
+			//When a key is repeated, there will be two events: released, followed by another immediate pressed. So check to see if another pressed is present	
+			if(!XPending(display))
+				return false;
+
+			XEvent e;
+			XPeekEvent(display, &e);
+			if(e.type == KeyPress && e.xkey.keycode == event.xkey.keycode && (e.xkey.time - event.xkey.time) < 2)
+			{
+				XNextEvent(display, &e);
+				return true;
+			}
+
+			return false;
+		}
+
+		bool _injectKeyDown( KeySym key, int text );
+		bool _injectKeyUp( KeySym key );
+
+		//! 1:1 Conversion Map between X Key Events and OIS KeyCodes
+		typedef std::map<KeySym, KeyCode> XtoOIS_KeyMap;
+		XtoOIS_KeyMap keyConversion;
+
+		//! Depressed Key List
+		char KeyBuffer[256];
+
+		//! X11 Stuff
+		Window window;
+		Display *display;
+		bool grabKeyboard;
+		bool keyFocusLost;
+
+		std::string mGetString;
+	};
+}
+
+#endif //_LINUX_KEYBOARD_H_EADER_
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/linux/LinuxMouse.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/linux/LinuxMouse.h
new file mode 100644
index 0000000..f6a0660
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/linux/LinuxMouse.h
@@ -0,0 +1,75 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that
+		you wrote the original software. If you use this software in a product,
+		an acknowledgment in the product documentation would be appreciated but is
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef _LINUX_MOUSE_H_EADER_
+#define _LINUX_MOUSE_H_EADER_
+
+#include "linux/LinuxPrereqs.h"
+#include "OISMouse.h"
+#include <X11/Xlib.h>
+
+namespace OIS
+{
+	class LinuxMouse : public Mouse
+	{
+	public:
+		LinuxMouse(InputManager* creator, bool buffered, bool grab, bool hide);
+		virtual ~LinuxMouse();
+
+		/** @copydoc Object::setBuffered */
+		virtual void setBuffered(bool buffered);
+
+		/**
+		@remarks
+			Note: Calling this will also update the keyboard (X11 updates in a single
+			event queue). Updates State and/or raises event for buffered mode..
+		*/
+		virtual void capture();
+
+		/** @copydoc Object::queryInterface */
+		virtual Interface* queryInterface(Interface::IType) {return 0;}
+
+		/** @copydoc Object::_initialize */
+		virtual void _initialize();
+
+		void grab(bool grab);
+		void hide(bool hide);
+
+	protected:
+		void _processXEvents();
+
+		bool mMoved, mWarped;
+
+		//Since X11 provides us with absolute values, we need to keep track of relative values
+		long oldXMouseX, oldXMouseY, oldXMouseZ;
+
+		Window window;		//The X Window
+		Display *display;	//The X display
+		Cursor cursor;		//A blank cursor
+
+		bool grabMouse;		//Are we grabbing the mouse to the window?
+		bool hideMouse;		//Are we hiding OS mouse?
+		bool mouseFocusLost;//Has the mouse just lost focus?
+	};
+}
+
+#endif //_LINUX_MOUSE_H_EADER_
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/linux/LinuxPrereqs.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/linux/LinuxPrereqs.h
new file mode 100644
index 0000000..a705115
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/linux/LinuxPrereqs.h
@@ -0,0 +1,82 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef _LINUX_INPUTSYSTEM_PREREQS_H
+#define _LINUX_INPUTSYSTEM_PREREQS_H
+
+//Bring in any auto generated config files
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "OISPrereqs.h"
+
+//! Max number of elements to collect from buffered input
+#define JOY_BUFFERSIZE 64
+
+namespace OIS
+{
+	class LinuxInputManager;
+	class LinuxKeyboard;
+	class LinuxJoyStick;
+	class LinuxMouse;
+	
+	class LinuxForceFeedback;
+
+	class Range
+	{
+	public:
+		Range() {};
+		Range(int _min, int _max) : min(_min), max(_max) {};
+		int min, max;
+	};
+
+	class JoyStickInfo
+	{
+	public:
+		JoyStickInfo(): devId(-1),joyFileD(-1),version(0),axes(0),buttons(0),hats(0) {}
+		//! Device number (/dev/input/j#) or /dev/input/event#
+		int devId;
+		//! File descriptor
+		int joyFileD;
+		//! Driver version
+		int version;
+		//! Joy vendor
+		std::string vendor;
+		//! Number of axes
+		unsigned char axes;
+		//! Number of buttons
+		unsigned char buttons;
+		//! Number of hats
+		unsigned char hats;
+		//! Maps Linux button values to OIS buttons values
+		std::map<int, int> button_map;
+		//! Maps Linux axis values to OIS axis
+		std::map<int, int> axis_map;
+		//! Maps OIS axis values to it's range
+		std::map<int, Range> axis_range;
+	};
+
+	typedef std::vector< JoyStickInfo > JoyStickInfoList;
+}
+
+#endif //_LINUX_INPUTSYSTEM_PREREQS_H
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/mac/MacHIDManager.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/mac/MacHIDManager.h
new file mode 100644
index 0000000..db195fe
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/mac/MacHIDManager.h
@@ -0,0 +1,103 @@
+/*
+ The zlib/libpng License
+ 
+ Copyright (c) 2007 Phillip
+ 
+ This software is provided 'as-is', without any express or implied warranty. In no event will
+ the authors be held liable for any damages arising from the use of this software.
+ 
+ Permission is granted to anyone to use this software for any purpose, including commercial 
+ applications, and to alter it and redistribute it freely, subject to the following
+ restrictions:
+ 
+ 1. The origin of this software must not be misrepresented; you must not claim that 
+ you wrote the original software. If you use this software in a product, 
+ an acknowledgment in the product documentation would be appreciated but is 
+ not required.
+ 
+ 2. Altered source versions must be plainly marked as such, and must not be 
+ misrepresented as being the original software.
+ 
+ 3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_MacHIDManager_Header
+#define OIS_MacHIDManager_Header
+
+#include "OISPrereqs.h"
+#include "mac/MacPrereqs.h"
+#include "OISFactoryCreator.h"
+
+#import <CoreFoundation/CFString.h>
+#import <IOKit/IOKitLib.h>
+#import <IOKit/IOCFPlugIn.h>
+#import <IOKit/hid/IOHIDLib.h>
+#import <IOKit/hid/IOHIDKeys.h>
+#import <Kernel/IOKit/hidsystem/IOHIDUsageTables.h>
+
+namespace OIS
+{
+	//Information needed to create Mac HID Devices
+	class HidInfo
+	{
+	public:
+		HidInfo() : type(OISUnknown), numButtons(0), numHats(0), numAxes(0), inUse(false), interface(0)
+		{
+		}
+
+		//Useful tracking information
+		Type type;
+		std::string vendor;
+		std::string productKey;
+		std::string combinedKey;
+
+		//Retain some count information for recreating devices without having to reparse
+		int numButtons;
+		int numHats;
+		int numAxes;
+		bool inUse;
+
+		//Used for opening a read/write/tracking interface to device
+		IOHIDDeviceInterface **interface;
+	};
+
+	typedef std::vector<HidInfo*> HidInfoList;
+		
+	class MacHIDManager : public FactoryCreator
+	{
+	public:
+		MacHIDManager();
+		~MacHIDManager();
+
+		void initialize();
+		
+		void iterateAndOpenDevices(io_iterator_t iterator);
+		io_iterator_t lookUpDevices(int usage, int page);
+
+		//FactoryCreator Overrides
+		/** @copydoc FactoryCreator::deviceList */
+		DeviceList freeDeviceList();
+
+		/** @copydoc FactoryCreator::totalDevices */
+		int totalDevices(Type iType);
+
+		/** @copydoc FactoryCreator::freeDevices */
+		int freeDevices(Type iType);
+
+		/** @copydoc FactoryCreator::vendorExist */
+		bool vendorExist(Type iType, const std::string & vendor);
+
+		/** @copydoc FactoryCreator::createObject */
+		Object* createObject(InputManager* creator, Type iType, bool bufferMode, const std::string & vendor = "");
+
+		/** @copydoc FactoryCreator::destroyObject */
+		void destroyObject(Object* obj);
+
+	private:
+		HidInfo* enumerateDeviceProperties(CFMutableDictionaryRef propertyMap);
+		void parseDeviceProperties(CFDictionaryRef properties);
+		void parseDevicePropertiesGroup(CFDictionaryRef properties);
+
+		HidInfoList mDeviceList;		
+	};
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/mac/MacHelpers.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/mac/MacHelpers.h
new file mode 100644
index 0000000..b457763
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/mac/MacHelpers.h
@@ -0,0 +1,94 @@
+/*
+ The zlib/libpng License
+ 
+ Copyright (c) 2006 Chris Snyder 
+ 
+ This software is provided 'as-is', without any express or implied warranty. In no event will
+ the authors be held liable for any damages arising from the use of this software.
+ 
+ Permission is granted to anyone to use this software for any purpose, including commercial 
+ applications, and to alter it and redistribute it freely, subject to the following
+ restrictions:
+ 
+ 1. The origin of this software must not be misrepresented; you must not claim that 
+ you wrote the original software. If you use this software in a product, 
+ an acknowledgment in the product documentation would be appreciated but is 
+ not required.
+ 
+ 2. Altered source versions must be plainly marked as such, and must not be 
+ misrepresented as being the original software.
+ 
+ 3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_MacHelpers_H
+#define OIS_MacHelpers_H
+
+#include "mac/MacPrereqs.h"
+#include "OISEvents.h"
+#include "OISKeyboard.h"
+#include "OISMouse.h"
+
+#include <Carbon/Carbon.h>
+
+// This is a hack needed to get the event handler working. 
+// The carbon lib expects a "OSStatus (*)(EventHandlerCallRef, EventRef, void*)",
+// so I cannot give it a class member function (unless it is static which is pointless)
+// Instead, I just pass the class* through the last paramter that gets passed to the
+// callback every time an event occurs. Then I dereference it and call the member function.
+OSStatus KeyDownWrapper( EventHandlerCallRef nextHandler, EventRef theEvent, void* callClass );
+
+OSStatus KeyUpWrapper( EventHandlerCallRef nextHandler, EventRef theEvent, void* callClass );
+
+OSStatus KeyModWrapper( EventHandlerCallRef nextHandler, EventRef theEvent, void* callClass );
+
+OSStatus MouseWrapper( EventHandlerCallRef nextHandler, EventRef theEvent, void* callClass );
+
+
+// This is needed for keeping an event stack for keyboard and mouse
+namespace OIS
+{
+    
+    // used in the eventStack to store the type
+    enum Mac_EventType { MAC_KEYUP = 0,
+                         MAC_KEYDOWN = 1,
+                         MAC_KEYREPEAT,
+                         MAC_MOUSEDOWN,
+                         MAC_MOUSEUP,
+                         MAC_MOUSEMOVED,
+                         MAC_MOUSESCROLL};
+    typedef enum Mac_EventType MacEventType;
+    
+    
+    // only used by MacKeyboard
+    typedef class Mac_KeyStackEvent
+    {
+        friend class MacKeyboard;
+        
+        
+    private:
+        Mac_KeyStackEvent( KeyEvent event, MacEventType type ) : Event(event), Type(type) {}
+        
+        MacEventType Type;
+        KeyEvent Event;
+    } MacKeyStackEvent;
+ 
+    
+
+    // only used by MacMouse
+    typedef class Mac_MouseStackEvent
+    {
+        friend class MacMouse;
+        
+    private:
+        Mac_MouseStackEvent( MouseEvent event, MacEventType type,  MouseButtonID button) : Event(event), Type(type), Button(button) {}
+        
+        MacEventType Type;
+        MouseEvent Event;
+		MouseButtonID Button;
+        
+    } MacMouseStackEvent;
+        
+}
+
+
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/mac/MacInputManager.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/mac/MacInputManager.h
new file mode 100644
index 0000000..278ec54
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/mac/MacInputManager.h
@@ -0,0 +1,101 @@
+/*
+ The zlib/libpng License
+ 
+ Copyright (c) 2006 Chris Snyder 
+ 
+ This software is provided 'as-is', without any express or implied warranty. In no event will
+ the authors be held liable for any damages arising from the use of this software.
+ 
+ Permission is granted to anyone to use this software for any purpose, including commercial 
+ applications, and to alter it and redistribute it freely, subject to the following
+ restrictions:
+ 
+ 1. The origin of this software must not be misrepresented; you must not claim that 
+ you wrote the original software. If you use this software in a product, 
+ an acknowledgment in the product documentation would be appreciated but is 
+ not required.
+ 
+ 2. Altered source versions must be plainly marked as such, and must not be 
+ misrepresented as being the original software.
+ 
+ 3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_MacInputManager_H
+#define OIS_MacInputManager_H
+
+#include "OISInputManager.h"
+#include "OISFactoryCreator.h"
+#include "mac/MacPrereqs.h"
+#include <Carbon/Carbon.h>
+
+namespace OIS
+{
+    
+    class MacInputManager : public InputManager, public FactoryCreator
+    {
+    public:
+        MacInputManager();
+        virtual ~MacInputManager();
+        
+		//InputManager Overrides
+		/** @copydoc InputManager::_initialize */
+		void _initialize( ParamList &paramList );
+
+		//FactoryCreator Overrides
+		/** @copydoc FactoryCreator::deviceList */
+		DeviceList freeDeviceList();
+
+		/** @copydoc FactoryCreator::totalDevices */
+		int totalDevices(Type iType);
+
+		/** @copydoc FactoryCreator::freeDevices */
+		int freeDevices(Type iType);
+
+		/** @copydoc FactoryCreator::vendorExist */
+		bool vendorExist(Type iType, const std::string & vendor);
+
+		/** @copydoc FactoryCreator::createObject */
+		Object* createObject(InputManager* creator, Type iType, bool bufferMode, const std::string & vendor = "");
+
+		/** @copydoc FactoryCreator::destroyObject */
+		void destroyObject(Object* obj);
+
+		//Internal Items
+		//! Internal method, used for flaggin keyboard as available/unavailable for creation
+		void _setKeyboardUsed(bool used) {keyboardUsed = used; }
+
+		//! Internal method, used for flaggin mouse as available/unavailable for creation
+		void _setMouseUsed(bool used) { mouseUsed = used; }
+        
+        //! methodfor getting the event target
+        EventTargetRef _getEventTarget() {return mEventTargetRef;}
+        
+        //! method for getting window
+        WindowRef _getWindow() {return mWindow;}
+        
+    protected:        
+        void _parseConfigSettings( ParamList& paramList );
+        
+        void _enumerateDevices();
+        
+        static const std::string iName;
+        
+        // Mac stuff
+		EventTargetRef mEventTargetRef;
+		WindowRef mWindow;
+        
+        // settings
+        bool mHideMouse;
+        bool mUseRepeat;
+
+		//! Used to know if we used up keyboard
+		bool keyboardUsed;
+
+		//! Used to know if we used up mouse
+		bool mouseUsed;
+		
+		//! HID Manager class handling devices other than keyboard/mouse
+		MacHIDManager *mHIDManager;
+    };
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/mac/MacJoyStick.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/mac/MacJoyStick.h
new file mode 100644
index 0000000..2786819
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/mac/MacJoyStick.h
@@ -0,0 +1,76 @@
+/*
+ The zlib/libpng License
+ 
+ Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+ 
+ This software is provided 'as-is', without any express or implied warranty. In no event will
+ the authors be held liable for any damages arising from the use of this software.
+ 
+ Permission is granted to anyone to use this software for any purpose, including commercial
+ applications, and to alter it and redistribute it freely, subject to the following
+ restrictions:
+ 
+ 1. The origin of this software must not be misrepresented; you must not claim that
+ you wrote the original software. If you use this software in a product,
+ an acknowledgment in the product documentation would be appreciated but is
+ not required.
+ 
+ 2. Altered source versions must be plainly marked as such, and must not be
+ misrepresented as being the original software.
+ 
+ 3. This notice may not be removed or altered from any source distribution.
+ */
+#ifndef MAC_Joystick_H
+#define MAC_Joystick_H
+#include "OISJoyStick.h"
+#include "mac/MacPrereqs.h"
+#include "mac/MacHIDManager.h"
+
+namespace OIS
+{
+	struct AxisInfo
+	{
+		int min;
+		int max;
+		
+		AxisInfo(int min, int max)
+			: min(min), max(max) {}
+	};
+	
+	typedef struct cookie_struct 
+	{ 
+		std::map<IOHIDElementCookie, AxisInfo> axisCookies; 			
+		std::vector<IOHIDElementCookie> buttonCookies; 
+	} cookie_struct_t; 
+	
+	//class HidDeviceInfo
+	
+	class MacJoyStick : public JoyStick
+	{
+	public:
+		MacJoyStick(const std::string& vendor, bool buffered, HidInfo* info, InputManager* creator, int devID);
+		
+		virtual ~MacJoyStick();
+		
+		/** @copydoc Object::setBuffered */
+		virtual void setBuffered(bool buffered);
+		
+		/** @copydoc Object::capture */
+		virtual void capture();
+		
+		/** @copydoc Object::queryInterface */
+		virtual Interface* queryInterface(Interface::IType type);
+		
+		/** @copydoc Object::_initialize */
+		virtual void _initialize();
+		
+		void _enumerateCookies();
+		
+		IOHIDQueueInterface** _createQueue(unsigned int depth = 8);
+	protected:
+		HidInfo* mInfo;
+		cookie_struct_t mCookies;
+		IOHIDQueueInterface** mQueue;
+	};
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/mac/MacKeyboard.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/mac/MacKeyboard.h
new file mode 100644
index 0000000..8b63b5c
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/mac/MacKeyboard.h
@@ -0,0 +1,102 @@
+/*
+ The zlib/libpng License
+ 
+ Copyright (c) 2006 Chris Snyder 
+ 
+ This software is provided 'as-is', without any express or implied warranty. In no event will
+ the authors be held liable for any damages arising from the use of this software.
+ 
+ Permission is granted to anyone to use this software for any purpose, including commercial 
+ applications, and to alter it and redistribute it freely, subject to the following
+ restrictions:
+ 
+ 1. The origin of this software must not be misrepresented; you must not claim that 
+ you wrote the original software. If you use this software in a product, 
+ an acknowledgment in the product documentation would be appreciated but is 
+ not required.
+ 
+ 2. Altered source versions must be plainly marked as such, and must not be 
+ misrepresented as being the original software.
+ 
+ 3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_MacKeyboard_H
+#define OIS_MacKeyboard_H
+
+#include "OISKeyboard.h"
+#include "mac/MacHelpers.h"
+#include "mac/MacPrereqs.h"
+
+#include <Carbon/Carbon.h>
+
+namespace OIS
+{
+    
+    class MacKeyboard : public Keyboard
+    {
+    public:
+        MacKeyboard( InputManager* creator, bool buffered, bool repeat );
+        virtual ~MacKeyboard();
+        
+        // Sets buffered mode
+        virtual void setBuffered( bool buffered );
+        
+        // unbuffered keydown check
+        virtual bool isKeyDown( KeyCode key ) const;
+        
+        // This will send listener events if buffered is on.
+        // Note that in the mac implementation, unbuffered input is
+        // automatically updated without calling this.
+        virtual void capture();
+        
+        // Copies the current key buffer
+        virtual void copyKeyStates( char keys[256] ) const;
+        
+        // Returns a description of the given key
+        virtual std::string& getAsString( KeyCode key );
+        
+        virtual Interface* queryInterface( Interface::IType type ) { return 0; }
+        
+        
+        // Public but reserved for internal use:
+        virtual void _initialize();
+        void _keyDownCallback( EventRef theEvent );
+        void _keyUpCallback( EventRef theEvent );
+        void _modChangeCallback( EventRef theEvent );
+        
+
+    protected:
+        // just to get this out of the way
+        void populateKeyConversion();
+        
+        // updates the keybuffer and optionally the eventStack
+        void injectEvent(KeyCode kc, unsigned int time, MacEventType type, unsigned int txt = 0 );
+                
+        typedef std::map<UInt32, KeyCode> VirtualtoOIS_KeyMap;
+        VirtualtoOIS_KeyMap keyConversion;
+        
+        std::string getString;
+        
+        char KeyBuffer[256];
+        UInt32 prevModMask;
+        
+        
+        // "universal procedure pointers" - required reference for callbacks
+        EventHandlerUPP keyDownUPP;
+        EventHandlerUPP keyUpUPP;
+        EventHandlerUPP keyModUPP;
+        
+        // so we can delete the handlers on destruction
+        EventHandlerRef keyDownEventRef;
+        EventHandlerRef keyUpEventRef;
+        EventHandlerRef keyModEventRef;
+        
+        // buffered events, fifo stack
+        typedef std::list<MacKeyStackEvent> eventStack;
+        eventStack pendingEvents;
+        
+        bool useRepeat;
+        
+    };
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/mac/MacMouse.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/mac/MacMouse.h
new file mode 100644
index 0000000..6fbd9bd
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/mac/MacMouse.h
@@ -0,0 +1,51 @@
+#ifndef OIS_MacMouse_H
+#define OIS_MacMouse_H
+
+#include "OISMouse.h"
+#include "mac/MacHelpers.h"
+#include "mac/MacPrereqs.h"
+
+#include <Carbon/Carbon.h>
+
+namespace OIS
+{
+	class MacMouse : public Mouse
+    {
+	public:
+		MacMouse( InputManager* creator, bool buffered );
+		virtual ~MacMouse();
+		
+		/** @copydoc Object::setBuffered */
+		virtual void setBuffered(bool buffered);
+
+		/** @copydoc Object::capture */
+		virtual void capture();
+
+		/** @copydoc Object::queryInterface */
+		virtual Interface* queryInterface(Interface::IType type) {return 0;}
+
+		/** @copydoc Object::_initialize */
+		virtual void _initialize();
+        
+	public:
+        void _mouseCallback( EventRef theEvent );
+
+	protected:
+		static OSStatus WindowFocusChanged(EventHandlerCallRef nextHandler, EventRef event, void* macMouse);
+        
+        // "universal procedure pointers" - required reference for callbacks
+		EventHandlerUPP mouseUPP;
+		EventHandlerRef mouseEventRef;
+		
+		EventHandlerUPP mWindowFocusListener;
+		EventHandlerRef mWindowFocusHandler;
+		
+		bool mNeedsToRegainFocus;
+		bool mMouseWarped;
+		
+		MouseState mTempState;
+	};
+}
+
+
+#endif // OIS_MacMouse_H
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/mac/MacPrereqs.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/mac/MacPrereqs.h
new file mode 100644
index 0000000..790e9c1
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/mac/MacPrereqs.h
@@ -0,0 +1,57 @@
+/*
+ The zlib/libpng License
+ 
+ Copyright (c) 2006 Chris Snyder 
+ 
+ This software is provided 'as-is', without any express or implied warranty. In no event will
+ the authors be held liable for any damages arising from the use of this software.
+ 
+ Permission is granted to anyone to use this software for any purpose, including commercial 
+ applications, and to alter it and redistribute it freely, subject to the following
+ restrictions:
+ 
+ 1. The origin of this software must not be misrepresented; you must not claim that 
+ you wrote the original software. If you use this software in a product, 
+ an acknowledgment in the product documentation would be appreciated but is 
+ not required.
+ 
+ 2. Altered source versions must be plainly marked as such, and must not be 
+ misrepresented as being the original software.
+ 
+ 3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_MacPrereqs_H
+#define OIS_MacPrereqs_H
+
+#include <string>
+#include <list>
+#include <CoreFoundation/CoreFoundation.h>
+
+namespace OIS
+{
+    class MacInputManager;
+	class MacHIDManager;
+	class MacMouse;
+    class MacKeyboard;
+
+	/** 
+		Simple wrapper class for CFString which will create a valid CFString and retain ownership until class instance is outof scope
+		To Access the CFStringRef instance, simply cast to void*, pass into a function expecting a void* CFStringRef object, or access via cf_str() method
+	*/
+	class OIS_CFString
+	{
+	public:
+		OIS_CFString() { m_StringRef = CFStringCreateWithCString(NULL, "", kCFStringEncodingUTF8); }
+		OIS_CFString(const char* c_str) { m_StringRef = CFStringCreateWithCString(NULL, c_str, kCFStringEncodingUTF8); }
+		OIS_CFString(const std::string &s_str) { m_StringRef = CFStringCreateWithCString(NULL, s_str.c_str(), kCFStringEncodingUTF8); }
+		~OIS_CFString() { CFRelease(m_StringRef); }
+
+		//Allow this class to be autoconverted to base class of StringRef (void*)
+		operator void*() { return (void*)m_StringRef; }
+		CFStringRef cf_str() { return m_StringRef; }
+	
+	private:
+		CFStringRef m_StringRef;
+	};
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/win32/Win32ForceFeedback.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/win32/Win32ForceFeedback.h
new file mode 100644
index 0000000..2aa9e6d
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/win32/Win32ForceFeedback.h
@@ -0,0 +1,108 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_Win32ForceFeedBack_H
+#define OIS_Win32ForceFeedBack_H
+
+#include "OISPrereqs.h"
+#include "OISForceFeedback.h"
+#include "win32/Win32Prereqs.h"
+
+namespace OIS
+{
+	class Win32ForceFeedback : public ForceFeedback
+	{
+		Win32ForceFeedback() {}
+	public:
+		Win32ForceFeedback(IDirectInputDevice8* pDIJoy, const DIDEVCAPS* pDIJoyCaps);
+		~Win32ForceFeedback();
+
+		/** @copydoc ForceFeedback::upload */
+		void upload( const Effect* effect );
+
+		/** @copydoc ForceFeedback::modify */
+		void modify( const Effect* effect );
+
+		/** @copydoc ForceFeedback::remove */
+		void remove( const Effect* effect );
+
+		/** @copydoc ForceFeedback::setMasterGain */
+		void setMasterGain( float level );
+		
+		/** @copydoc ForceFeedback::setAutoCenterMode */
+		void setAutoCenterMode( bool auto_on );
+
+		/** @copydoc ForceFeedback::getFFAxesNumber */
+		short getFFAxesNumber();
+
+		/** @copydoc ForceFeedback::getFFMemoryLoad */
+		unsigned short getFFMemoryLoad();
+
+		/**
+			@remarks
+			Internal use.. Used during enumeration to build a list of a devices
+			support effects.
+		*/
+		void _addEffectSupport( LPCDIEFFECTINFO pdei );
+
+		/**
+			@remarks
+			Internal use.. Used during axis enumeration to get number of FF axes
+			support effects.
+		*/
+		void _addFFAxis();
+
+	protected:
+
+		//Specific Effect Settings
+		void _updateConstantEffect( const Effect* effect );
+		void _updateRampEffect( const Effect* effect );
+		void _updatePeriodicEffect( const Effect* effect );
+		void _updateConditionalEffect( const Effect* effect );
+		void _updateCustomEffect( const Effect* effect );
+
+		//Sets the common properties to all effects
+		void _setCommonProperties( DIEFFECT* diEffect, DWORD* rgdwAxes,
+									LONG* rglDirection, DIENVELOPE* diEnvelope, DWORD struct_size, 
+									LPVOID struct_type, const Effect* effect, const Envelope* envelope );
+		//Actually do the upload
+		void _upload( GUID, DIEFFECT*, const Effect* );
+
+		// Map of currently uploaded effects (handle => effect)
+		typedef std::map<int,LPDIRECTINPUTEFFECT> EffectList;
+		EffectList mEffectList;
+
+		//Simple unique handle creation - allows for upto 2+ billion effects
+		//during the lifetime of application. Hopefully, that is enough.
+		int mHandles;
+
+		// Joystick device descriptor.
+		IDirectInputDevice8* mJoyStick;
+		
+		// Joystick capabilities.
+		const DIDEVCAPS* mpDIJoyCaps;
+
+		// Number of axis supporting FF.
+		short mFFAxes;
+	};
+}
+#endif //OIS_Win32ForceFeedBack_H
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/win32/Win32InputManager.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/win32/Win32InputManager.h
new file mode 100644
index 0000000..d451feb
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/win32/Win32InputManager.h
@@ -0,0 +1,113 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_Win32InputManager_H
+#define OIS_Win32InputManager_H
+
+#include "OISInputManager.h"
+#include "OISFactoryCreator.h"
+#include "win32/Win32Prereqs.h"
+
+namespace OIS
+{
+	/**	Win32InputManager specialization - Using DirectInput8 */
+	class Win32InputManager : public InputManager, public FactoryCreator
+	{
+	public:
+		Win32InputManager();
+		virtual ~Win32InputManager();
+
+		//InputManager Overrides
+		/** @copydoc InputManager::_initialize */
+		void _initialize( ParamList &paramList );
+
+		//FactoryCreator Overrides
+		/** @copydoc FactoryCreator::deviceList */
+		DeviceList freeDeviceList();
+
+		/** @copydoc FactoryCreator::totalDevices */
+		int totalDevices(Type iType);
+
+		/** @copydoc FactoryCreator::freeDevices */
+		int freeDevices(Type iType);
+
+		/** @copydoc FactoryCreator::vendorExist */
+		bool vendorExist(Type iType, const std::string & vendor);
+
+		/** @copydoc FactoryCreator::createObject */
+		Object* createObject(InputManager* creator, Type iType, bool bufferMode, const std::string & vendor = "");
+
+		/** @copydoc FactoryCreator::destroyObject */
+		void destroyObject(Object* obj);
+
+		//Internal Items
+		//! Internal method, used for flaggin keyboard as available/unavailable for creation
+		void _setKeyboardUsed(bool used) {keyboardUsed = used; }
+
+		//! Internal method, used for flaggin mouse as available/unavailable for creation
+		void _setMouseUsed(bool used) { mouseUsed = used; }
+		
+		//! Internal method, return unused joystick to queue
+		void _returnJoyStick(const JoyStickInfo& joystick);
+
+		//! Returns HWND needed by DirectInput Device Object
+		HWND getWindowHandle() { return hWnd; }
+
+	protected:
+		//! internal class method for dealing with param list
+		void _parseConfigSettings( ParamList &paramList );
+		
+		//! internal class method for finding attached devices
+		void _enumerateDevices();
+
+		//! Used during device enumeration
+		static BOOL CALLBACK _DIEnumDevCallback(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef);
+
+		//! Keep a list of all joysticks enumerated, but not in use
+		JoyStickInfoList unusedJoyStickList;
+
+		//! The window handle we are using
+		HWND hWnd;
+
+		//! Direct Input Interface
+		IDirectInput8* mDirectInput;
+
+		//! Used for keyboard device settings
+		DWORD kbSettings;
+
+		//! Used for mouse device settings
+		DWORD mouseSettings;
+
+		//! Used for joystick device settings
+		DWORD joySettings;
+
+		//! Number of total joysticks (inuse or not)
+		char joySticks;
+
+		//! Used to know if we used up keyboard
+		bool keyboardUsed;
+
+		//! Used to know if we used up mouse
+		bool mouseUsed;
+	};
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/win32/Win32JoyStick.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/win32/Win32JoyStick.h
new file mode 100644
index 0000000..b33c0d5
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/win32/Win32JoyStick.h
@@ -0,0 +1,88 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef _WIN32_JOYSTICK_H_EADER_
+#define _WIN32_JOYSTICK_H_EADER_
+
+#include "OISJoyStick.h"
+#include "win32/Win32Prereqs.h"
+
+namespace OIS
+{
+	class Win32JoyStick : public JoyStick
+	{
+	public:
+		Win32JoyStick( InputManager* creator, IDirectInput8* pDI, bool buffered, DWORD coopSettings, const JoyStickInfo &info );
+		virtual ~Win32JoyStick();
+		
+		/** @copydoc Object::setBuffered */
+		virtual void setBuffered(bool buffered);
+		
+		/** @copydoc Object::capture */
+		virtual void capture();
+
+		//! hanlde xinput
+		void captureXInput();
+
+		/** @copydoc Object::queryInterface */
+		virtual Interface* queryInterface(Interface::IType type);
+
+		/** @copydoc Object::_initialize */
+		virtual void _initialize();
+
+#ifdef OIS_WIN32_XINPUT_SUPPORT
+		/**
+		@remarks
+			Enum each PNP device using WMI and check each device ID to see if it contains 
+			"IG_" (ex. "VID_045E&PID_028E&IG_00").  If it does, then it's an XInput device
+			Unfortunately this information can not be found by just using DirectInput 
+		*/
+		static void CheckXInputDevices(JoyStickInfoList &joys);
+#endif
+
+	protected:
+		//! Enumerates all things
+		void _enumerate();
+		//! Enumerate axis callback
+		static BOOL CALLBACK DIEnumDeviceObjectsCallback(LPCDIDEVICEOBJECTINSTANCE lpddoi, LPVOID pvRef);
+		//! Enumerate Force Feedback callback
+		static BOOL CALLBACK DIEnumEffectsCallback(LPCDIEFFECTINFO pdei, LPVOID pvRef);
+
+		bool _doButtonClick( int button, DIDEVICEOBJECTDATA& di );
+		bool _changePOV( int pov, DIDEVICEOBJECTDATA& di );
+
+		IDirectInput8* mDirectInput;
+		IDirectInputDevice8* mJoyStick;
+		DIDEVCAPS mDIJoyCaps;
+		DWORD coopSetting;
+
+        JoyStickInfo mJoyInfo;
+
+		//! A force feedback device
+		Win32ForceFeedback* mFfDevice;
+
+		//! Mapping
+		int _AxisNumber;
+	};
+}
+
+#endif //_WIN32_JOYSTICK_H_EADER_
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/win32/Win32KeyBoard.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/win32/Win32KeyBoard.h
new file mode 100644
index 0000000..b3ce2f6
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/win32/Win32KeyBoard.h
@@ -0,0 +1,87 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef _WIN32_KEYBOARD_H_EADER_
+#define _WIN32_KEYBOARD_H_EADER_
+
+#include "OISKeyboard.h"
+#include "win32/Win32Prereqs.h"
+
+namespace OIS
+{
+	class Win32Keyboard : public Keyboard
+	{
+	public:
+		/**
+		@remarks
+			Constructor
+		@param pDI
+			Valid DirectInput8 Interface
+		@param buffered
+			True for buffered input mode
+		@param coopSettings
+			A combination of DI Flags (see DX Help for info on input device settings)
+		*/
+		Win32Keyboard(InputManager* creator, IDirectInput8* pDI, bool buffered, DWORD coopSettings);
+		virtual ~Win32Keyboard();
+
+		/** @copydoc Keyboard::isKeyDown */
+		virtual bool isKeyDown(KeyCode key) const;
+		
+		/** @copydoc Keyboard::getAsString */
+		virtual const std::string& getAsString(KeyCode kc);
+
+		/** @copydoc Keyboard::copyKeyStates */
+		virtual void copyKeyStates(char keys[256]) const;
+
+		/** @copydoc Object::setBuffered */
+		virtual void setBuffered(bool buffered);
+		
+		/** @copydoc Object::capture */
+		virtual void capture();
+
+		/** @copydoc Object::queryInterface */
+		virtual Interface* queryInterface(Interface::IType type) {return 0;}
+		
+		/** @copydoc Object::_initialize */
+		virtual void _initialize();
+	protected:
+		void _readBuffered();
+		void _read();
+
+		IDirectInput8* mDirectInput;
+		IDirectInputDevice8* mKeyboard;
+		DWORD coopSetting;
+
+		unsigned char KeyBuffer[256];
+		
+		//! Internal method for translating KeyCodes to Text
+		int _translateText( KeyCode kc );
+
+		//! Stored dead key from last translation
+		WCHAR deadKey;
+
+		//! used for getAsString
+		std::string mGetString;
+	};
+}
+#endif //_WIN32_KEYBOARD_H_EADER_
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/win32/Win32Mouse.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/win32/Win32Mouse.h
new file mode 100644
index 0000000..17a23dc
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/win32/Win32Mouse.h
@@ -0,0 +1,59 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+	1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+	2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+	3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef _WIN32_MOUSE_H_EADER_
+#define _WIN32_MOUSE_H_EADER_
+
+#include "OISMouse.h"
+#include "win32/Win32Prereqs.h"
+
+namespace OIS
+{
+	class Win32Mouse : public Mouse
+	{
+	public:
+		Win32Mouse( InputManager* creator, IDirectInput8* pDI, bool buffered, DWORD coopSettings );
+		virtual ~Win32Mouse();
+		
+		/** @copydoc Object::setBuffered */
+		virtual void setBuffered(bool buffered);
+
+		/** @copydoc Object::capture */
+		virtual void capture();
+
+		/** @copydoc Object::queryInterface */
+		virtual Interface* queryInterface(Interface::IType type) {return 0;}
+
+		/** @copydoc Object::_initialize */
+		virtual void _initialize();
+
+	protected:
+		bool _doMouseClick( int mouseButton, DIDEVICEOBJECTDATA& di );
+
+		IDirectInput8* mDirectInput;
+		IDirectInputDevice8* mMouse;
+		DWORD coopSetting;
+		HWND mHwnd;
+	};
+}
+
+#endif //_WIN32_MOUSE_H_EADER_
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/win32/Win32Prereqs.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/win32/Win32Prereqs.h
new file mode 100644
index 0000000..d514c27
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/includes/win32/Win32Prereqs.h
@@ -0,0 +1,71 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef _WIN32_INPUTSYSTEM_PREREQS_H
+#define _WIN32_INPUTSYSTEM_PREREQS_H
+
+#include <cstddef>
+#define WIN32_LEAN_AND_MEAN
+#define DIRECTINPUT_VERSION 0x0800
+#include <windows.h>
+#include <dinput.h>
+
+#ifdef OIS_WIN32_XINPUT_SUPPORT
+#	include <XInput.h>
+#endif
+
+//Max number of elements to collect from buffered DirectInput
+#define KEYBOARD_DX_BUFFERSIZE 17
+#define MOUSE_DX_BUFFERSIZE 128
+#define JOYSTICK_DX_BUFFERSIZE 129
+
+//MinGW defines
+#if defined(OIS_MINGW_COMPILER)
+#	undef FIELD_OFFSET
+#	define FIELD_OFFSET offsetof
+#endif
+
+namespace OIS
+{
+	//Local Forward declarations
+	class Win32InputManager;
+	class Win32Keyboard;
+	class Win32JoyStick;
+	class Win32Mouse;
+	class Win32ForceFeedback;
+
+	//Information needed to create DirectInput joysticks
+	class JoyStickInfo
+	{
+	public:
+		int devId;
+		GUID deviceID;
+		GUID productGuid;
+		std::string vendor;
+        bool isXInput;
+		int xInputDev;
+	};
+
+	typedef std::vector<JoyStickInfo> JoyStickInfoList;
+}
+
+#endif //_WIN32_INPUTSYSTEM_PREREQS_H
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/Makefile.am b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/Makefile.am
new file mode 100644
index 0000000..83892d2
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/Makefile.am
@@ -0,0 +1,25 @@
+INCLUDES = $(STLPORT_CFLAGS) -I$(top_srcdir)/includes $(CFLAGS) -I/usr/X11R6/include
+
+
+
+lib_LTLIBRARIES=libOIS.la
+libOIS_la_SOURCES = OISInputManager.cpp \
+	OISObject.cpp \
+	OISEffect.cpp \
+	OISJoyStick.cpp \
+	OISKeyboard.cpp \
+	OISForceFeedback.cpp \
+	OISException.cpp \
+	./linux/EventHelpers.cpp \
+	./linux/LinuxInputManager.cpp \
+        ./linux/LinuxJoyStickEvents.cpp \
+        ./linux/LinuxForceFeedback.cpp \
+	./linux/LinuxKeyboard.cpp \
+	./linux/LinuxMouse.cpp
+
+libOIS_la_LDFLAGS = -release @PACKAGE_VERSION@
+#libOIS_la_LDFLAGS = -version-info $(shell echo "@PACKAGE_VERSION@" | tr '.' ':')
+
+libOIS_la_LIBADD = $(STLPORT_LIBS) -L/usr/X11R6/lib -lX11
+
+#eof "$Id: Makefile.am,v 1.15.2.1 2008/02/14 03:33:36 pjcast Exp $"
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/OISEffect.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/OISEffect.cpp
new file mode 100644
index 0000000..5a94efe
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/OISEffect.cpp
@@ -0,0 +1,128 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "OISEffect.h"
+#include "OISException.h"
+
+using namespace OIS;
+
+//VC7.1 had a problem with these not getting included.. 
+//Perhaps a case of a crazy extreme optimizer :/ (moved to header)
+//const unsigned int Effect::OIS_INFINITE = 0xFFFFFFFF;
+
+//------------------------------------------------------------------------------//
+static const char* pszEForceString[] = 
+  { "UnknownForce",
+    "ConstantForce", 
+    "RampForce", 
+    "PeriodicForce", 
+    "ConditionalForce", 
+    "CustomForce" };
+
+const char* Effect::getForceTypeName(Effect::EForce eValue)
+{
+  return (eValue >= 0 && eValue < _ForcesNumber) ? pszEForceString[eValue] : "<Bad force type>";
+}
+
+static const char* pszETypeString[] = 
+  { "Unknown",
+    "Constant",
+    "Ramp",
+    "Square", "Triangle", "Sine", "SawToothUp", "SawToothDown",
+    "Friction", "Damper", "Inertia", "Spring",
+    "Custom" };
+
+const char* Effect::getEffectTypeName(Effect::EType eValue)
+{
+  return (eValue >= 0 && eValue < _TypesNumber) ? pszETypeString[eValue] : "<Bad effect type>";
+}
+
+static const char* pszEDirectionString[] = 
+  { "NorthWest", "North", "NorthEast", "East", "SouthEast", "South", "SouthWest", "West"};
+
+const char* Effect::getDirectionName(Effect::EDirection eValue)
+{
+  return (eValue >= 0 && eValue < _DirectionsNumber) ? pszEDirectionString[eValue] : "<Bad direction>";
+}
+
+//------------------------------------------------------------------------------//
+Effect::Effect() : 
+	force(UnknownForce), 
+	type(Unknown),
+	effect(0),
+	axes(1)
+{
+}
+
+//------------------------------------------------------------------------------//
+Effect::Effect(EForce ef, EType et) : 
+	force(ef), 
+	type(et),
+	direction(North), 
+	trigger_button(-1),
+	trigger_interval(0),
+	replay_length(Effect::OIS_INFINITE),
+	replay_delay(0),
+	_handle(-1),
+	axes(1)
+{
+	effect = 0;
+
+	switch( ef )
+	{
+	case ConstantForce:    effect = new ConstantEffect(); break;
+	case RampForce:	       effect = new RampEffect(); break;
+	case PeriodicForce:    effect = new PeriodicEffect(); break;
+	case ConditionalForce: effect = new ConditionalEffect(); break;
+	default: break;
+	}
+}
+
+//------------------------------------------------------------------------------//
+Effect::~Effect()
+{
+	delete effect;
+}
+
+//------------------------------------------------------------------------------//
+ForceEffect* Effect::getForceEffect() const
+{
+	//If no effect was created in constructor, then we raise an error here
+	if( effect == 0 )
+		OIS_EXCEPT( E_NotSupported, "Requested ForceEffect is null!" );
+
+	return effect;
+}
+
+//------------------------------------------------------------------------------//
+void Effect::setNumAxes(short nAxes)
+{
+	//Can only be set before a handle was assigned (effect created)
+	if( _handle != -1 )
+        axes = nAxes;
+}
+
+//------------------------------------------------------------------------------//
+short Effect::getNumAxes() const
+{
+	return axes;
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/OISException.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/OISException.cpp
new file mode 100644
index 0000000..119070c
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/OISException.cpp
@@ -0,0 +1,32 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that
+		you wrote the original software. If you use this software in a product,
+		an acknowledgment in the product documentation would be appreciated but is
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "OISException.h"
+
+using namespace OIS;
+
+//----------------------------------------------------------------------------//
+const char* Exception::what() const throw()
+{
+	return eText;
+}
+
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/OISForceFeedback.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/OISForceFeedback.cpp
new file mode 100644
index 0000000..3f48c42
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/OISForceFeedback.cpp
@@ -0,0 +1,74 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "OISForceFeedback.h"
+#include "OISException.h"
+
+using namespace OIS;
+
+//-------------------------------------------------------------//
+ForceFeedback::ForceFeedback() : mSetGainSupport(false), mSetAutoCenterSupport(false)
+{
+}
+
+//-------------------------------------------------------------//
+void ForceFeedback::_addEffectTypes( Effect::EForce force, Effect::EType type )
+{
+	if( force <= Effect::UnknownForce || force >= Effect::_ForcesNumber
+		|| type <= Effect::Unknown || type >= Effect::_TypesNumber )
+		OIS_EXCEPT( E_General, "Can't add unknown effect Force/Type to the supported list" );
+
+	mSupportedEffects.insert(std::pair<Effect::EForce, Effect::EType>(force, type));
+}
+
+//-------------------------------------------------------------//
+void ForceFeedback::_setGainSupport( bool on )
+{
+	mSetGainSupport = on;
+}
+
+//-------------------------------------------------------------//
+void ForceFeedback::_setAutoCenterSupport( bool on )
+{
+	mSetAutoCenterSupport = on;
+}
+
+//-------------------------------------------------------------//
+const ForceFeedback::SupportedEffectList& ForceFeedback::getSupportedEffects() const
+{
+	return mSupportedEffects;
+}
+
+//-------------------------------------------------------------//
+bool ForceFeedback::supportsEffect(Effect::EForce force, Effect::EType type) const
+{
+    const std::pair<SupportedEffectList::const_iterator, SupportedEffectList::const_iterator> 
+	    iterRange = mSupportedEffects.equal_range(force);
+	SupportedEffectList::const_iterator iter;
+	for (iter = iterRange.first; iter != iterRange.second; iter++)
+	{
+	  if ((*iter).second == type)
+		return true;
+	}
+
+	return false;
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/OISInputManager.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/OISInputManager.cpp
new file mode 100644
index 0000000..8767f15
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/OISInputManager.cpp
@@ -0,0 +1,290 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "OISInputManager.h"
+#include "OISException.h"
+#include "OISFactoryCreator.h"
+#include "OISObject.h"
+#include <sstream>
+#include <algorithm>
+
+//Bring in correct Header / InputManager for current build platform
+#if defined OIS_SDL_PLATFORM
+#  include "SDL/SDLInputManager.h"
+#elif defined OIS_WIN32_PLATFORM
+#  include "win32/Win32InputManager.h"
+#elif defined OIS_LINUX_PLATFORM
+#  include "linux/LinuxInputManager.h"
+#elif defined OIS_APPLE_PLATFORM
+#  include "mac/MacInputManager.h"
+#elif defined OIS_IPHONE_PLATFORM
+#  include "iphone/iPhoneInputManager.h"
+#elif defined OIS_XBOX_PLATFORM
+#  include "xbox/XBoxInputManager.h"
+#endif
+
+//Bring in extra controls
+#if defined OIS_LIRC_SUPPORT
+#  include "extras/LIRC/OISLIRCFactoryCreator.h"
+#endif
+#if defined OIS_WIN32_WIIMOTE_SUPPORT
+#  include "win32/extras/WiiMote/OISWiiMoteFactoryCreator.h"
+#endif
+
+
+using namespace OIS;
+
+//----------------------------------------------------------------------------//
+InputManager::InputManager(const std::string& name) :
+	m_VersionName(OIS_VERSION_NAME),
+	mInputSystemName(name),
+	m_lircSupport(0),
+	m_wiiMoteSupport(0)
+{
+    mFactories.clear();
+    mFactoryObjects.clear();
+}
+
+//----------------------------------------------------------------------------//
+InputManager::~InputManager()
+{
+#if defined OIS_LIRC_SUPPORT
+	delete m_lircSupport;
+#endif
+
+#if defined OIS_WIN32_WIIMOTE_SUPPORT
+	delete m_wiiMoteSupport;
+#endif
+}
+
+//----------------------------------------------------------------------------//
+unsigned int InputManager::getVersionNumber()
+{
+	return OIS_VERSION;
+}
+
+//----------------------------------------------------------------------------//
+const std::string &InputManager::getVersionName()
+{
+	return m_VersionName;
+}
+
+//----------------------------------------------------------------------------//
+InputManager* InputManager::createInputSystem( std::size_t windowhandle )
+{
+	ParamList pl;
+	std::ostringstream wnd;
+	wnd << windowhandle;
+	pl.insert(std::make_pair( std::string("WINDOW"), wnd.str() ));
+
+	return createInputSystem( pl );
+}
+
+//----------------------------------------------------------------------------//
+InputManager* InputManager::createInputSystem( ParamList &paramList )
+{
+	InputManager* im = 0;
+
+#if defined OIS_SDL_PLATFORM
+	im = new SDLInputManager();
+#elif defined OIS_WIN32_PLATFORM
+	im = new Win32InputManager();
+#elif defined OIS_XBOX_PLATFORM
+	im = new XBoxInputManager();
+#elif defined OIS_LINUX_PLATFORM
+	im = new LinuxInputManager();
+#elif defined OIS_APPLE_PLATFORM
+	im = new MacInputManager();
+#elif defined OIS_IPHONE_PLATFORM
+	im = new iPhoneInputManager();
+#else
+	OIS_EXCEPT(E_General, "No platform library.. check build platform defines!");
+#endif 
+
+	try
+	{
+		im->_initialize(paramList);
+	}
+	catch(...)
+	{
+		delete im;
+		throw; //rethrow
+	}
+
+	return im;
+}
+
+//----------------------------------------------------------------------------//
+void InputManager::destroyInputSystem(InputManager* manager)
+{
+	if( manager == 0 )
+		return;
+
+	//Cleanup before deleting...
+	for( FactoryCreatedObject::iterator i = manager->mFactoryObjects.begin(); 
+		i != manager->mFactoryObjects.end(); ++i )
+	{
+		i->second->destroyObject( i->first );
+	}
+
+	manager->mFactoryObjects.clear();
+	delete manager;
+}
+
+//--------------------------------------------------------------------------------//
+const std::string& InputManager::inputSystemName()
+{
+	return mInputSystemName;
+}
+
+//--------------------------------------------------------------------------------//
+int InputManager::getNumberOfDevices( Type iType )
+{
+	//Count up all the factories devices
+	int factoyObjects = 0;
+	FactoryList::iterator i = mFactories.begin(), e = mFactories.end();
+	for( ; i != e; ++i )
+		factoyObjects += (*i)->totalDevices(iType);
+
+	return factoyObjects;
+}
+
+//----------------------------------------------------------------------------//
+DeviceList InputManager::listFreeDevices()
+{
+	DeviceList list;
+	FactoryList::iterator i = mFactories.begin(), e = mFactories.end();
+	for( ; i != e; ++i )
+	{
+		DeviceList temp = (*i)->freeDeviceList();
+		list.insert(temp.begin(), temp.end());
+	}
+
+	return list;
+}
+
+//----------------------------------------------------------------------------//
+Object* InputManager::createInputObject( Type iType, bool bufferMode, const std::string &vendor )
+{
+	Object* obj = 0;
+	FactoryList::iterator i = mFactories.begin(), e = mFactories.end();
+	for( ; i != e; ++i)
+	{
+		if( (*i)->freeDevices(iType) > 0 )
+		{
+			if( vendor == "" || (*i)->vendorExist(iType, vendor) )
+			{
+				obj = (*i)->createObject(this, iType, bufferMode, vendor);
+				mFactoryObjects[obj] = (*i);
+				break;
+			}
+		}
+	}
+
+	if(!obj)
+		OIS_EXCEPT(E_InputDeviceNonExistant, "No devices match requested type.");
+
+	try
+	{	//Intialize device
+		obj->_initialize();
+	}
+	catch(...)
+	{	//Somekind of error, cleanup and rethrow
+		destroyInputObject(obj);
+		throw;
+	}
+
+	return obj;
+}
+
+//----------------------------------------------------------------------------//
+void InputManager::destroyInputObject( Object* obj )
+{
+	if( obj == 0 )
+		return;
+
+	FactoryCreatedObject::iterator i = mFactoryObjects.find(obj);
+	if( i != mFactoryObjects.end() )
+	{
+		i->second->destroyObject(obj);
+		mFactoryObjects.erase(i);
+	}
+	else
+	{
+		OIS_EXCEPT(E_General, "Object creator not known.");
+	}
+}
+
+//----------------------------------------------------------------------------//
+void InputManager::addFactoryCreator( FactoryCreator* factory )
+{
+	if(factory != 0)
+		mFactories.push_back(factory);
+}
+
+//----------------------------------------------------------------------------//
+void InputManager::removeFactoryCreator( FactoryCreator* factory )
+{
+	if(factory != 0)
+	{
+		//First, destroy all devices created with the factory
+		for( FactoryCreatedObject::iterator i = mFactoryObjects.begin(); i != mFactoryObjects.end(); ++i )
+		{
+			if( i->second == factory )
+			{
+				i->second->destroyObject(i->first);
+				mFactoryObjects.erase(i++);
+			}
+		}
+
+		//Now, remove the factory itself
+		FactoryList::iterator fact = std::find(mFactories.begin(), mFactories.end(), factory);
+		if( fact != mFactories.end() )
+			mFactories.erase(fact);
+	}
+}
+
+//----------------------------------------------------------------------------//
+void InputManager::enableAddOnFactory(AddOnFactories factory)
+{
+#if defined OIS_LIRC_SUPPORT
+	if( factory == AddOn_LIRC || factory == AddOn_All )
+	{
+		if( m_lircSupport == 0 )
+		{
+			m_lircSupport = new LIRCFactoryCreator();
+			addFactoryCreator(m_lircSupport);
+		}
+	}
+#endif
+
+#if defined OIS_WIN32_WIIMOTE_SUPPORT
+	if( factory == AddOn_WiiMote || factory == AddOn_All )
+	{
+		if( m_wiiMoteSupport == 0 )
+		{
+			m_wiiMoteSupport = new WiiMoteFactoryCreator();
+			addFactoryCreator(m_wiiMoteSupport);
+		}
+	}
+#endif
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/OISJoyStick.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/OISJoyStick.cpp
new file mode 100644
index 0000000..b560cb4
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/OISJoyStick.cpp
@@ -0,0 +1,73 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "OISJoyStick.h"
+
+using namespace OIS;
+
+//----------------------------------------------------------------------------//
+JoyStick::JoyStick(const std::string &vendor, bool buffered, int devID, InputManager* creator) :
+	Object(vendor, OISJoyStick, buffered, devID, creator),
+	mSliders(0),
+	mPOVs(0),
+	mListener(0),
+	mVector3Sensitivity(OIS_JOYSTICK_VECTOR3_DEFAULT)
+{
+}
+
+//----------------------------------------------------------------------------//
+int JoyStick::getNumberOfComponents(ComponentType cType) const
+{
+	switch( cType )
+	{
+	case OIS_Button:	return (int)mState.mButtons.size();
+	case OIS_Axis:		return (int)mState.mAxes.size();
+	case OIS_Slider:	return mSliders;
+	case OIS_POV:		return mPOVs;
+	case OIS_Vector3:	return (int)mState.mVectors.size();
+	default:			return 0;
+	}
+}
+
+//----------------------------------------------------------------------------//
+void JoyStick::setVector3Sensitivity(float degrees)
+{
+	mVector3Sensitivity = degrees;
+}
+
+//----------------------------------------------------------------------------//
+float JoyStick::getVector3Sensitivity() const
+{
+	return mVector3Sensitivity;
+}
+
+//----------------------------------------------------------------------------//
+void JoyStick::setEventCallback( JoyStickListener *joyListener )
+{
+	mListener = joyListener;
+}
+
+//----------------------------------------------------------------------------//
+JoyStickListener* JoyStick::getEventCallback() const
+{
+	return mListener;
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/OISKeyboard.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/OISKeyboard.cpp
new file mode 100644
index 0000000..3cbfb72
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/OISKeyboard.cpp
@@ -0,0 +1,45 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that
+		you wrote the original software. If you use this software in a product,
+		an acknowledgment in the product documentation would be appreciated but is
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "OISKeyboard.h"
+#include "OISException.h"
+
+using namespace OIS;
+
+//----------------------------------------------------------------------//
+void Keyboard::setTextTranslation( TextTranslationMode mode )
+{
+	mTextMode = mode;
+}
+
+//----------------------------------------------------------------------//
+bool Keyboard::isModifierDown( Modifier mod ) const
+{
+#if defined(OIS_MSVC_COMPILER)
+  #pragma warning (push)
+  #pragma warning (disable : 4800)
+#endif
+	return (mModifiers & mod);
+#if defined(OIS_MSVC_COMPILER)
+  #pragma warning (pop)
+#endif
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/OISObject.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/OISObject.cpp
new file mode 100644
index 0000000..550687a
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/OISObject.cpp
@@ -0,0 +1,23 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that
+		you wrote the original software. If you use this software in a product,
+		an acknowledgment in the product documentation would be appreciated but is
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+//#include "OISObject.h"
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/SDL/SDLInputManager.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/SDL/SDLInputManager.cpp
new file mode 100644
index 0000000..276703d
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/SDL/SDLInputManager.cpp
@@ -0,0 +1,114 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "SDL/SDLInputManager.h"
+#include "SDL/SDLKeyboard.h"
+#include "SDL/SDLMouse.h"
+#include "SDL/SDLJoyStick.h"
+#include "OISException.h"
+#include "OISObject.h"
+
+using namespace OIS;
+
+const std::string SDLInputManager::iName = "SDL Input Wrapper";
+
+//--------------------------------------------------------------------------------//
+SDLInputManager::SDLInputManager() : mGrabbed(false)
+{
+}
+
+//--------------------------------------------------------------------------------//
+SDLInputManager::~SDLInputManager()
+{
+}
+
+//--------------------------------------------------------------------------------//
+void SDLInputManager::_initialize( ParamList &paramList )
+{
+	Uint32 flags = SDL_WasInit(0);
+	if( flags == 0 )
+		OIS_EXCEPT( E_General, "SDLInputManager::SDLInputManager >> SDL Not Initialized already!");
+
+	//Ok, now we have DirectInput, parse whatever extra settings were sent to us
+	_parseConfigSettings( paramList );
+	_enumerateDevices();
+}
+
+//--------------------------------------------------------------------------------//
+void SDLInputManager::_parseConfigSettings( ParamList &paramList )
+{
+}
+
+//--------------------------------------------------------------------------------//
+void SDLInputManager::_enumerateDevices()
+{
+}
+
+//--------------------------------------------------------------------------------//
+int SDLInputManager::numJoySticks()
+{
+	return 0;
+}
+
+//--------------------------------------------------------------------------------//
+int SDLInputManager::numMice()
+{
+	return 1;
+}
+
+//--------------------------------------------------------------------------------//
+int SDLInputManager::numKeyboards()
+{
+	return 1;
+}
+
+//----------------------------------------------------------------------------//
+Object* SDLInputManager::createInputObject( Type iType, bool bufferMode )
+{
+	Object* obj = 0;
+	
+	switch( iType )
+	{
+		case OISKeyboard: obj = new SDLKeyboard( bufferMode ); break;
+		case OISMouse: obj = new SDLMouse( bufferMode ); break;
+		case OISJoyStick: 
+		default: OIS_EXCEPT( E_InputDeviceNotSupported, "Type not implemented");
+	}
+
+	try	{
+		obj->_initialize();
+	}
+	catch(...) {
+		delete obj;
+		throw; //rethrow
+	}
+
+	return obj;
+}
+
+//----------------------------------------------------------------------------//
+void SDLInputManager::destroyInputObject( Object* obj )
+{
+	if( obj == 0 ) return;
+
+	delete obj;
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/SDL/SDLJoyStick.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/SDL/SDLJoyStick.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/SDL/SDLKeyboard.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/SDL/SDLKeyboard.cpp
new file mode 100644
index 0000000..fa1cbf3
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/SDL/SDLKeyboard.cpp
@@ -0,0 +1,377 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "SDL/SDLKeyboard.h"
+#include "SDL/SDLInputManager.h"
+#include "OISException.h"
+#include "OISEvents.h"
+#include <sstream>
+
+using namespace OIS;
+
+//-------------------------------------------------------------------//
+SDLKeyboard::SDLKeyboard( bool buffered )
+{
+	mBuffered = buffered;
+	mType = OISKeyboard;
+	listener = 0;
+
+	//Clear our keyboard state buffer
+	memset( &KeyBuffer, 0, 256 );
+}
+
+//-------------------------------------------------------------------//
+void SDLKeyboard::_initialize()
+{
+	mModifiers = 0;
+	mSDLBuff = 0;
+
+	mKeyMap.insert( KeyMap::value_type(SDLK_ESCAPE,KC_ESCAPE) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_1, KC_1) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_2, KC_2) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_3, KC_3) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_4, KC_4) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_5, KC_5) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_6, KC_6) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_7, KC_7) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_8, KC_8) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_9, KC_9) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_0, KC_0) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_MINUS, KC_MINUS) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_EQUALS, KC_EQUALS) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_BACKSPACE, KC_BACK) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_TAB, KC_TAB) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_q, KC_Q) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_w, KC_W) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_e, KC_E) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_r, KC_R) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_t, KC_T) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_y, KC_Y) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_u, KC_U) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_i, KC_I) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_o, KC_O) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_p, KC_P) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_RETURN, KC_RETURN) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_LCTRL, KC_LCONTROL));
+	mKeyMap.insert( KeyMap::value_type(SDLK_a, KC_A) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_s, KC_S) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_d, KC_D) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_f, KC_F) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_g, KC_G) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_h, KC_H) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_j, KC_J) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_k, KC_K) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_l, KC_L) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_SEMICOLON, KC_SEMICOLON) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_COLON, KC_COLON) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_QUOTE, KC_APOSTROPHE) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_BACKQUOTE, KC_GRAVE)  );
+	mKeyMap.insert( KeyMap::value_type(SDLK_LSHIFT, KC_LSHIFT) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_BACKSLASH, KC_BACKSLASH) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_SLASH, KC_SLASH) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_z, KC_Z) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_x, KC_X) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_c, KC_C) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_v, KC_V) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_b, KC_B) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_n, KC_N) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_m, KC_M) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_COMMA, KC_COMMA)  );
+	mKeyMap.insert( KeyMap::value_type(SDLK_PERIOD, KC_PERIOD));
+	mKeyMap.insert( KeyMap::value_type(SDLK_RSHIFT, KC_RSHIFT));
+	mKeyMap.insert( KeyMap::value_type(SDLK_KP_MULTIPLY, KC_MULTIPLY) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_LALT, KC_LMENU) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_SPACE, KC_SPACE));
+	mKeyMap.insert( KeyMap::value_type(SDLK_CAPSLOCK, KC_CAPITAL) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_F1, KC_F1) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_F2, KC_F2) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_F3, KC_F3) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_F4, KC_F4) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_F5, KC_F5) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_F6, KC_F6) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_F7, KC_F7) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_F8, KC_F8) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_F9, KC_F9) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_F10, KC_F10) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_NUMLOCK, KC_NUMLOCK) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_SCROLLOCK, KC_SCROLL));
+	mKeyMap.insert( KeyMap::value_type(SDLK_KP7, KC_NUMPAD7) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_KP8, KC_NUMPAD8) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_KP9, KC_NUMPAD9) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_KP_MINUS, KC_SUBTRACT) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_KP4, KC_NUMPAD4) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_KP5, KC_NUMPAD5) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_KP6, KC_NUMPAD6) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_KP_PLUS, KC_ADD) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_KP1, KC_NUMPAD1) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_KP2, KC_NUMPAD2) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_KP3, KC_NUMPAD3) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_KP0, KC_NUMPAD0) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_KP_PERIOD, KC_DECIMAL) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_F11, KC_F11) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_F12, KC_F12) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_F13, KC_F13) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_F14, KC_F14) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_F15, KC_F15) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_KP_EQUALS, KC_NUMPADEQUALS) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_KP_DIVIDE, KC_DIVIDE) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_SYSREQ, KC_SYSRQ) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_RALT, KC_RMENU) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_HOME, KC_HOME) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_UP, KC_UP) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_PAGEUP, KC_PGUP) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_LEFT, KC_LEFT) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_RIGHT, KC_RIGHT) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_END, KC_END) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_DOWN, KC_DOWN) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_PAGEDOWN, KC_PGDOWN) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_INSERT, KC_INSERT) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_DELETE, KC_DELETE) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_LSUPER, KC_LWIN) );
+	mKeyMap.insert( KeyMap::value_type(SDLK_RSUPER, KC_RWIN) );
+
+	SDL_EnableUNICODE(1);
+}
+
+//-------------------------------------------------------------------//
+SDLKeyboard::~SDLKeyboard()
+{
+}
+
+//-------------------------------------------------------------------//
+void SDLKeyboard::capture()
+{
+	SDL_Event events[OIS_SDL_KEY_BUFF];
+	int count = SDL_PeepEvents(events, OIS_SDL_KEY_BUFF, SDL_GETEVENT, 
+		SDL_EVENTMASK(SDL_KEYDOWN) | SDL_EVENTMASK(SDL_KEYUP));
+
+	for( int i = 0; i < count; ++i )
+	{
+		KeyCode kc = mKeyMap[events[i].key.keysym.sym];
+		KeyBuffer[kc] = events[i].key.state;
+
+		if( mBuffered && listener )
+		{
+			if( events[i].key.state == SDL_PRESSED )
+			{
+				if( listener->keyPressed(KeyEvent(this, 0, kc, events[i].key.keysym.unicode)) == false )
+					break;
+			}
+			else
+			{
+				if( listener->keyReleased(KeyEvent(this, 0, kc, events[i].key.keysym.unicode)) == false )
+					break;
+			}
+		}
+	}
+
+	//Release Grab mode on Alt-Tab combinations (for non-window systems)
+	if( KeyBuffer[KC_RMENU] || KeyBuffer[KC_LMENU])
+	{
+		if( KeyBuffer[KC_TAB] )
+			static_cast<SDLInputManager*>(InputManager::getSingletonPtr())->_setGrabMode(false);
+	}
+}
+
+//-------------------------------------------------------------------//
+bool SDLKeyboard::isKeyDown( KeyCode key )
+{
+	return KeyBuffer[key] == 1 ? true : false;
+}
+
+//-------------------------------------------------------------------//
+const std::string& SDLKeyboard::getAsString( KeyCode kc )
+{
+    switch(kc)
+    {
+    case KC_ESCAPE: mGetString = SDL_GetKeyName(SDLK_ESCAPE); break;
+    case KC_1: mGetString = SDL_GetKeyName(SDLK_1); break;
+    case KC_2: mGetString = SDL_GetKeyName(SDLK_2); break;
+    case KC_3: mGetString = SDL_GetKeyName(SDLK_3); break;
+    case KC_4: mGetString = SDL_GetKeyName(SDLK_4); break;
+    case KC_5: mGetString = SDL_GetKeyName(SDLK_5); break;
+    case KC_6: mGetString = SDL_GetKeyName(SDLK_6); break;
+    case KC_7: mGetString = SDL_GetKeyName(SDLK_7); break;
+    case KC_8: mGetString = SDL_GetKeyName(SDLK_8); break;
+    case KC_9: mGetString = SDL_GetKeyName(SDLK_9); break;
+    case KC_0: mGetString = SDL_GetKeyName(SDLK_0); break;
+    case KC_MINUS: mGetString = SDL_GetKeyName(SDLK_MINUS); break;
+    case KC_EQUALS: mGetString = SDL_GetKeyName(SDLK_EQUALS); break;
+    case KC_BACK: mGetString = SDL_GetKeyName(SDLK_BACKSPACE); break;
+    case KC_TAB: mGetString = SDL_GetKeyName(SDLK_TAB); break;
+    case KC_Q: mGetString = SDL_GetKeyName(SDLK_q); break;
+    case KC_W: mGetString = SDL_GetKeyName(SDLK_w); break;
+    case KC_E: mGetString = SDL_GetKeyName(SDLK_e); break;
+    case KC_R: mGetString = SDL_GetKeyName(SDLK_r); break;
+    case KC_T: mGetString = SDL_GetKeyName(SDLK_t); break;
+    case KC_Y: mGetString = SDL_GetKeyName(SDLK_y); break;
+    case KC_U: mGetString = SDL_GetKeyName(SDLK_u); break;
+    case KC_I: mGetString = SDL_GetKeyName(SDLK_i); break;
+    case KC_O: mGetString = SDL_GetKeyName(SDLK_o); break;
+    case KC_P: mGetString = SDL_GetKeyName(SDLK_p); break;
+    case KC_LBRACKET: mGetString = "["; break;
+    case KC_RBRACKET: mGetString = "]"; break;
+    case KC_RETURN: mGetString = SDL_GetKeyName(SDLK_RETURN); break;
+    case KC_LCONTROL: mGetString = SDL_GetKeyName(SDLK_LCTRL); break;
+    case KC_A: mGetString = SDL_GetKeyName(SDLK_a); break;
+    case KC_S: mGetString = SDL_GetKeyName(SDLK_s); break;
+    case KC_D: mGetString = SDL_GetKeyName(SDLK_d); break;
+    case KC_F: mGetString = SDL_GetKeyName(SDLK_f); break;
+    case KC_G: mGetString = SDL_GetKeyName(SDLK_g); break;
+    case KC_H: mGetString = SDL_GetKeyName(SDLK_h); break;
+    case KC_J: mGetString = SDL_GetKeyName(SDLK_j); break;
+    case KC_K: mGetString = SDL_GetKeyName(SDLK_k); break;
+    case KC_L: mGetString = SDL_GetKeyName(SDLK_l); break;
+    case KC_SEMICOLON: mGetString = SDL_GetKeyName(SDLK_SEMICOLON); break;
+    case KC_APOSTROPHE: mGetString = SDL_GetKeyName(SDLK_QUOTE); break;
+    case KC_GRAVE: mGetString = SDL_GetKeyName(SDLK_BACKQUOTE); break;
+    case KC_LSHIFT: mGetString = SDL_GetKeyName(SDLK_LSHIFT); break;
+    case KC_BACKSLASH: mGetString = SDL_GetKeyName(SDLK_BACKSLASH); break;
+    case KC_Z: mGetString = SDL_GetKeyName(SDLK_z); break;
+    case KC_X: mGetString = SDL_GetKeyName(SDLK_x); break;
+    case KC_C: mGetString = SDL_GetKeyName(SDLK_c); break;
+    case KC_V: mGetString = SDL_GetKeyName(SDLK_v); break;
+    case KC_B: mGetString = SDL_GetKeyName(SDLK_b); break;
+    case KC_N: mGetString = SDL_GetKeyName(SDLK_n); break;
+    case KC_M: mGetString = SDL_GetKeyName(SDLK_m); break;
+    case KC_COMMA: mGetString = SDL_GetKeyName(SDLK_COMMA); break;
+    case KC_PERIOD: mGetString = SDL_GetKeyName(SDLK_PERIOD); break;
+    case KC_SLASH: mGetString = SDL_GetKeyName(SDLK_SLASH); break;
+    case KC_RSHIFT: mGetString = SDL_GetKeyName(SDLK_RSHIFT); break;
+    case KC_MULTIPLY: mGetString = SDL_GetKeyName(SDLK_KP_MULTIPLY); break;
+    case KC_LMENU: mGetString = SDL_GetKeyName(SDLK_LALT); break;
+    case KC_SPACE: mGetString = SDL_GetKeyName(SDLK_SPACE); break;
+    case KC_CAPITAL: mGetString = SDL_GetKeyName(SDLK_CAPSLOCK); break;
+    case KC_F1: mGetString = SDL_GetKeyName(SDLK_F1); break;
+    case KC_F2: mGetString = SDL_GetKeyName(SDLK_F2); break;
+    case KC_F3: mGetString = SDL_GetKeyName(SDLK_F3); break;
+    case KC_F4: mGetString = SDL_GetKeyName(SDLK_F4); break;
+    case KC_F5: mGetString = SDL_GetKeyName(SDLK_F5); break;
+    case KC_F6: mGetString = SDL_GetKeyName(SDLK_F6); break;
+    case KC_F7: mGetString = SDL_GetKeyName(SDLK_F7); break;
+    case KC_F8: mGetString = SDL_GetKeyName(SDLK_F8); break;
+    case KC_F9: mGetString = SDL_GetKeyName(SDLK_F9); break;
+    case KC_F10: mGetString = SDL_GetKeyName(SDLK_F10); break;
+    case KC_NUMLOCK: mGetString = SDL_GetKeyName(SDLK_NUMLOCK); break;
+    case KC_SCROLL: mGetString = SDL_GetKeyName(SDLK_SCROLLOCK); break;
+    case KC_NUMPAD7: mGetString = SDL_GetKeyName(SDLK_KP7); break;
+    case KC_NUMPAD8: mGetString = SDL_GetKeyName(SDLK_KP8); break;
+    case KC_NUMPAD9: mGetString = SDL_GetKeyName(SDLK_KP9); break;
+    case KC_SUBTRACT: mGetString = SDL_GetKeyName(SDLK_KP_MINUS); break;
+    case KC_NUMPAD4: mGetString = SDL_GetKeyName(SDLK_KP4); break;
+    case KC_NUMPAD5: mGetString = SDL_GetKeyName(SDLK_KP5); break;
+    case KC_NUMPAD6: mGetString = SDL_GetKeyName(SDLK_KP6); break;
+    case KC_ADD: mGetString = SDL_GetKeyName(SDLK_KP_PLUS); break;
+    case KC_NUMPAD1: mGetString = SDL_GetKeyName(SDLK_KP1); break;
+    case KC_NUMPAD2: mGetString = SDL_GetKeyName(SDLK_KP2); break;
+    case KC_NUMPAD3: mGetString = SDL_GetKeyName(SDLK_KP3); break;
+    case KC_NUMPAD0: mGetString = SDL_GetKeyName(SDLK_KP0); break;
+    case KC_DECIMAL: mGetString = SDL_GetKeyName(SDLK_KP_PERIOD); break;
+    case KC_OEM_102: mGetString = "OEM_102"; break;
+    case KC_F11: mGetString = SDL_GetKeyName(SDLK_F11); break;
+    case KC_F12: mGetString = SDL_GetKeyName(SDLK_F12); break;
+    case KC_F13: mGetString = SDL_GetKeyName(SDLK_F13); break;
+    case KC_F14: mGetString = SDL_GetKeyName(SDLK_F14); break;
+    case KC_F15: mGetString = SDL_GetKeyName(SDLK_F15); break;
+    case KC_KANA: mGetString = "Kana"; break;
+    case KC_ABNT_C1: mGetString = "ABNT_C1"; break;
+    case KC_CONVERT: mGetString = "CONVERT"; break;
+    case KC_NOCONVERT: mGetString = "NOCONVERT"; break;
+    case KC_YEN: mGetString = "YEN"; break;
+    case KC_ABNT_C2: mGetString = "ABNT_C2"; break;
+    case KC_NUMPADEQUALS: mGetString = SDL_GetKeyName(SDLK_KP_EQUALS); break;
+    case KC_PREVTRACK: mGetString = "KC_PREVTRACK"; break;
+    case KC_AT: mGetString = "KC_AT"; break;
+    case KC_COLON: mGetString = SDL_GetKeyName(SDLK_COLON); break;
+    case KC_UNDERLINE: mGetString = "KC_UNDERLINE"; break;
+    case KC_KANJI: mGetString = "KC_KANJI"; break;
+    case KC_STOP: mGetString = "KC_STOP"; break;
+    case KC_AX: mGetString = "KC_AX"; break;
+    case KC_UNLABELED: mGetString = "KC_UNLABELED"; break;
+    case KC_NEXTTRACK: mGetString = "KC_NEXTTRACK"; break;
+    case KC_NUMPADENTER: mGetString = "KC_NUMPADENTER"; break;
+    case KC_RCONTROL: mGetString = "KC_RCONTROL"; break;
+    case KC_MUTE: mGetString = "KC_MUTE"; break;
+    case KC_CALCULATOR: mGetString = "KC_CALCULATOR"; break;
+    case KC_PLAYPAUSE: mGetString = "KC_PLAYPAUSE"; break;
+    case KC_MEDIASTOP: mGetString = "KC_MEDIASTOP"; break;
+    case KC_VOLUMEDOWN: mGetString = "KC_VOLUMEDOWN"; break;
+    case KC_VOLUMEUP: mGetString = "KC_VOLUMEUP"; break;
+    case KC_WEBHOME: mGetString = "KC_WEBHOME"; break;
+    case KC_NUMPADCOMMA: mGetString = "KC_NUMPADCOMMA"; break;
+    case KC_DIVIDE: mGetString = SDL_GetKeyName(SDLK_KP_DIVIDE); break;
+    case KC_SYSRQ: mGetString = SDL_GetKeyName(SDLK_SYSREQ); break;
+    case KC_RMENU: mGetString = SDL_GetKeyName(SDLK_RALT); break;
+    case KC_PAUSE: mGetString = "Pause"; break;
+    case KC_HOME: mGetString = SDL_GetKeyName(SDLK_HOME); break;
+    case KC_UP: mGetString = SDL_GetKeyName(SDLK_UP); break;
+    case KC_PGUP: mGetString = SDL_GetKeyName(SDLK_PAGEUP); break;
+    case KC_LEFT: mGetString = SDL_GetKeyName(SDLK_LEFT); break;
+    case KC_RIGHT: mGetString = SDL_GetKeyName(SDLK_RIGHT); break;
+    case KC_END:  mGetString = SDL_GetKeyName(SDLK_END); break;
+    case KC_DOWN: mGetString = SDL_GetKeyName(SDLK_DOWN); break;
+    case KC_PGDOWN: mGetString = SDL_GetKeyName(SDLK_PAGEDOWN); break;
+    case KC_INSERT: mGetString = SDL_GetKeyName(SDLK_INSERT); break;
+    case KC_DELETE: mGetString = SDL_GetKeyName(SDLK_DELETE); break;
+    case KC_LWIN: mGetString = SDL_GetKeyName(SDLK_LSUPER); break;
+    case KC_RWIN: mGetString = SDL_GetKeyName(SDLK_RSUPER); break;
+    case KC_APPS: mGetString = "KC_APPS"; break;
+    case KC_POWER: mGetString = "KC_POWER"; break;
+    case KC_SLEEP: mGetString = "KC_SLEEP"; break;
+    case KC_WAKE: mGetString = "KC_WAKE"; break;
+    case KC_WEBSEARCH: mGetString = "KC_WEBSEARCH"; break;
+    case KC_WEBFAVORITES: mGetString = "KC_WEBFAVORITES"; break;
+    case KC_WEBREFRESH: mGetString = "KC_WEBREFRESH"; break;
+    case KC_WEBSTOP: mGetString = "KC_WEBSTOP"; break;
+    case KC_WEBFORWARD: mGetString = "KC_WEBFORWARD"; break;
+    case KC_WEBBACK: mGetString = "KC_WEBBACK"; break;
+    case KC_MYCOMPUTER: mGetString = "KC_MYCOMPUTER"; break;
+    case KC_MAIL: mGetString = "KC_MAIL"; break;
+    case KC_MEDIASELECT: mGetString = "KC_MEDIASELECT"; break;
+    default: mGetString = "Unknown"; break;
+    };
+
+	return mGetString;
+}
+
+//-------------------------------------------------------------------//
+void SDLKeyboard::copyKeyStates( char keys[256] )
+{
+	for(int i = 0; i < 256; ++i)
+		keys[i] = KeyBuffer[i];
+}
+
+//-------------------------------------------------------------------//
+void SDLKeyboard::setBuffered(bool buffered)
+{
+	mBuffered = buffered;
+}
+
+//-------------------------------------------------------------------//
+void SDLKeyboard::setTextTranslation( TextTranslationMode mode )
+{
+	mTextMode = mode;
+	if( mode == Off || mode == Ascii )
+		SDL_EnableUNICODE(0);
+	else if( mode == Unicode )
+		SDL_EnableUNICODE(1);
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/SDL/SDLMouse.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/SDL/SDLMouse.cpp
new file mode 100644
index 0000000..7c2d36f
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/SDL/SDLMouse.cpp
@@ -0,0 +1,174 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "SDL/SDLMouse.h"
+#include "SDL/SDLInputManager.h"
+#include "OISException.h"
+#include "OISEvents.h"
+
+using namespace OIS;
+
+//-------------------------------------------------------------------//
+SDLMouse::SDLMouse( bool buffered ) : mGrabbed(false), mRegainFocus(false)
+{
+	mBuffered = buffered;
+	mType = OISMouse;
+	listener = 0;
+}
+
+//-------------------------------------------------------------------//
+void SDLMouse::_initialize()
+{
+	//Clear old state
+	mState.clear();
+	mRegainFocus = false;
+
+	_setGrab(true);
+	_setVisible(false);
+	static_cast<SDLInputManager*>(InputManager::getSingletonPtr())->_setGrabMode(true);
+}
+
+//-------------------------------------------------------------------//
+SDLMouse::~SDLMouse()
+{
+	_setGrab(true);
+	_setVisible(true);
+
+	static_cast<SDLInputManager*>(InputManager::getSingletonPtr())->_setGrabMode(false);
+}
+
+//-------------------------------------------------------------------//
+void SDLMouse::capture()
+{
+	//Used for going from SDL Button to OIS button
+	static const MouseButtonID ButtonMask[4] = {MB_Left, MB_Left, MB_Middle, MB_Right};
+
+	//Clear old relative values
+	mState.relX = mState.relY = mState.relZ = 0;
+
+	SDL_Event events[OIS_SDL_MOUSE_BUFF];
+	int count = SDL_PeepEvents(events, OIS_SDL_MOUSE_BUFF, SDL_GETEVENT, SDL_MOUSEEVENTMASK);
+
+	bool mouseXYMoved = false;
+	bool mouseZMoved = false;
+	for( int i = 0; i < count; ++i )
+	{
+		switch( events[i].type )
+		{
+			case SDL_MOUSEMOTION: mouseXYMoved = true; break;				
+			case SDL_MOUSEBUTTONDOWN:
+			{
+				mRegainFocus = true;
+				int sdlButton = events[i].button.button;
+				if( sdlButton <= SDL_BUTTON_RIGHT )
+				{	//Left, Right, or Middle
+					mState.buttons |= (1 << ButtonMask[sdlButton]);
+					if( mBuffered && listener )
+						if( listener->mousePressed(MouseEvent(this,0,mState), ButtonMask[sdlButton]) == false )
+							return;
+				}
+				else
+				{	//mouse Wheel
+					mouseZMoved = true;
+					if( sdlButton == SDL_BUTTON_WHEELUP )
+						mState.relZ += 120;
+					else if( sdlButton == SDL_BUTTON_WHEELDOWN )
+						mState.relZ -= 120;
+				}
+				break;
+			}
+			case SDL_MOUSEBUTTONUP:
+			{
+				int sdlButton = events[i].button.button;
+				if( sdlButton <= SDL_BUTTON_RIGHT )
+				{	//Left, Right, or Middle
+					mState.buttons &= ~(1 << ButtonMask[sdlButton]);
+					if( mBuffered && listener )
+						if( listener->mouseReleased(MouseEvent(this,0,mState), ButtonMask[sdlButton]) == false )
+							return;
+				}
+				break;
+			}
+		}
+	}
+
+	//Handle X/Y axis move
+	if( mouseXYMoved )
+	{
+		SDL_GetMouseState( &mState.abX, &mState.abY );
+		SDL_GetRelativeMouseState( &mState.relX, &mState.relY );
+
+		if( mBuffered && listener )
+			listener->mouseMoved(MouseEvent(this, 0, mState));
+	}
+	//Handle Z Motion
+	if( mouseZMoved )
+	{
+		mState.abZ += mState.relZ;
+		if( mBuffered && listener )
+			listener->mouseMoved(MouseEvent(this, 0, mState));
+	}
+
+	//Handle Alt-Tabbing
+	SDLInputManager* man = static_cast<SDLInputManager*>(InputManager::getSingletonPtr());
+	if( man->_getGrabMode() == false )
+	{
+		if( mRegainFocus == false && mGrabbed == true )
+		{	//We had focus, but must release it now
+			_setGrab(false);
+			_setVisible(true);
+		}
+		else if( mRegainFocus == true && mGrabbed == false )
+		{	//We are gaining focus back (mouse clicked in window)
+			_setGrab(true);
+			_setVisible(false);
+			man->_setGrabMode(true);	//Notify manager
+		}
+	}
+}
+
+//-------------------------------------------------------------------//
+void SDLMouse::setBuffered(bool buffered)
+{
+	mBuffered = buffered;
+}
+
+//-------------------------------------------------------------------//
+void SDLMouse::_setGrab(bool grabbed)
+{
+	if( grabbed )
+		SDL_WM_GrabInput(SDL_GRAB_ON);
+	else
+		SDL_WM_GrabInput(SDL_GRAB_OFF);
+
+	mGrabbed = grabbed;
+}
+
+//-------------------------------------------------------------------//
+void SDLMouse::_setVisible(bool visible)
+{
+
+	if( visible )
+		SDL_ShowCursor(SDL_ENABLE);
+	else
+		SDL_ShowCursor(SDL_DISABLE);
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/extras/LIRC/OISLIRC.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/extras/LIRC/OISLIRC.cpp
new file mode 100644
index 0000000..ba1e4d4
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/extras/LIRC/OISLIRC.cpp
@@ -0,0 +1,107 @@
+#include "OISConfig.h"
+#ifdef OIS_LIRC_SUPPORT
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that
+		you wrote the original software. If you use this software in a product,
+		an acknowledgment in the product documentation would be appreciated but is
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "OISLIRC.h"
+#include "OISLIRCFactoryCreator.h"
+#include "OISException.h"
+
+using namespace OIS;
+
+//-----------------------------------------------------------------------------------//
+LIRCControl::LIRCControl(InputManager* creator, int id, bool buffered, LIRCFactoryCreator* local_creator, RemoteInfo &info) :
+	JoyStick("Generic LIRC", buffered, id, creator),
+	mLIRCCreator(local_creator),
+	mRingBuffer(OIS_LIRC_EVENT_BUFFER),
+	mInfo(info)
+{
+	//Fill in joystick information
+	mState.mButtons.resize(mInfo.buttons);
+}
+
+//-----------------------------------------------------------------------------------//
+LIRCControl::~LIRCControl()
+{
+}
+
+//-----------------------------------------------------------------------------------//
+void LIRCControl::_initialize()
+{
+	mState.clear();
+}
+
+//-----------------------------------------------------------------------------------//
+void LIRCControl::setBuffered(bool buffered)
+{
+	mBuffered = buffered;
+}
+
+//-----------------------------------------------------------------------------------//
+void LIRCControl::capture()
+{
+	//Anything to read?
+	int entries = mRingBuffer.GetReadAvailable();
+	if( entries <= 0 )
+		return;
+
+	LIRCEvent events[OIS_LIRC_EVENT_BUFFER];
+	if( entries > OIS_LIRC_EVENT_BUFFER )
+		entries = OIS_LIRC_EVENT_BUFFER;
+	
+	mRingBuffer.Read(events, entries);
+
+	//Loop through each event
+	for( int i = 0; i < entries; ++i )
+	{
+		if( mBuffered && mListener )
+		{
+			//Quickly send off button events (there is no real stored state)
+			//As, even a held down button will kep generating button presses
+			mState.mButtons[events[i].button] = true;
+			if( !mListener->buttonPressed(JoyStickEvent(this, mState), events[i].button) )
+				return;
+
+			mState.mButtons[events[i].button] = false;
+			if( !mListener->buttonReleased(JoyStickEvent(this, mState), events[i].button) )
+				return;
+		}
+	}
+}
+
+//-----------------------------------------------------------------------------------//
+void LIRCControl::queueButtonPressed(const std::string &id)
+{
+	if( mRingBuffer.GetWriteAvailable() > 0 )
+	{
+		LIRCEvent evt;
+		evt.button = mInfo.buttonMap[id];
+		mRingBuffer.Write(&evt, 1);
+	}
+}
+
+//-----------------------------------------------------------------------------------//
+Interface* LIRCControl::queryInterface(Interface::IType type)
+{
+	return 0;
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/extras/LIRC/OISLIRC.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/extras/LIRC/OISLIRC.h
new file mode 100644
index 0000000..8b819ae
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/extras/LIRC/OISLIRC.h
@@ -0,0 +1,88 @@
+#include "OISConfig.h"
+#ifdef OIS_LIRC_SUPPORT
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that
+		you wrote the original software. If you use this software in a product,
+		an acknowledgment in the product documentation would be appreciated but is
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_LIRC_H
+#define OIS_LIRC_H
+#include "OISJoyStick.h"
+#include "OISLIRCRingBuffer.h"
+
+namespace OIS
+{
+	class LIRCFactoryCreator;
+
+	struct RemoteInfo
+	{
+		RemoteInfo() : buttons(0) {}
+
+		RemoteInfo( const RemoteInfo &other )
+		{
+			buttons = other.buttons;
+			buttonMap = other.buttonMap;
+		}
+
+		int buttons;
+		std::map<std::string, int> buttonMap;
+	};
+
+	//Number of ring buffer events. should be nice sized (the structure is not very big)
+	//Will be rounded up to power of two automatically
+	#define OIS_LIRC_EVENT_BUFFER 16
+
+	/**	Specialty joystick - Linux Infrared Remote Support */
+	class _OISExport LIRCControl : public JoyStick
+	{
+		friend class LIRCFactoryCreator;
+	public:
+		LIRCControl(InputManager* creator, int id, bool buffered, LIRCFactoryCreator* local_creator, RemoteInfo &info);
+		~LIRCControl();
+
+		//Overrides of Object
+		/** copydoc Object::setBuffered */
+		void setBuffered(bool buffered);
+
+		/** copydoc Object::capture */
+		void capture();
+
+		/** copydoc Object::queryInterface */
+		Interface* queryInterface(Interface::IType type);
+
+		/** copydoc Object::_intialize */
+		void _initialize();
+
+	protected:
+		//! Internal method used to add a button press to the queue (called from thread)
+		void queueButtonPressed(const std::string &id);
+
+		//! The creator who created us
+		LIRCFactoryCreator *mLIRCCreator;
+
+		//! Ringbuffer is used to store events from thread and be read from capture
+		LIRCRingBuffer mRingBuffer;
+
+		//! Information about remote
+		RemoteInfo mInfo;
+	};
+}
+#endif //OIS_LIRC_H
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/extras/LIRC/OISLIRCFactoryCreator.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/extras/LIRC/OISLIRCFactoryCreator.cpp
new file mode 100644
index 0000000..cb02d29
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/extras/LIRC/OISLIRCFactoryCreator.cpp
@@ -0,0 +1,405 @@
+#include "OISConfig.h"
+#ifdef OIS_LIRC_SUPPORT
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "OISLIRCFactoryCreator.h"
+#include "OISException.h"
+#include <assert.h>
+#include <stdlib.h>
+
+#ifdef OIS_WIN32_PLATFORM
+#  pragma warning (disable : 4996)
+#  pragma warning (disable : 4267)
+#  pragma warning (disable : 4554)
+#  pragma warning (disable : 4996)
+#  define _WIN32_WINNT 0x0500
+#endif
+#include <boost/asio.hpp>
+#include <boost/bind.hpp>
+#include <boost/thread.hpp>
+
+#include <istream>
+#include <sstream>
+
+using namespace OIS;
+
+//---------------------------------------------------------------------------------//
+class LIRCFactoryCreator::BoostWrapper
+{
+public:
+	LIRCFactoryCreator::BoostWrapper() : mSocket(mIOService), mThreadHandler(0)
+	{
+	}
+
+	//TCP stuff
+	boost::asio::io_service mIOService;
+	boost::asio::ip::tcp::socket mSocket;
+
+	//Thread Stuff
+	//! Boost thread execution object (only alive when at least 1 lirc is alive)
+	boost::thread *mThreadHandler;
+		
+	//! Gaurds access to the active lirc list
+	boost::mutex mLircListMutex;
+
+};
+
+//---------------------------------------------------------------------------------//
+LIRCFactoryCreator::LIRCFactoryCreator() :
+	mConnected(false),
+	mThreadRunning(false),
+	mCount(0),
+	mWrapped(0)
+{
+	mWrapped = new BoostWrapper();
+
+	mIP   = (getenv("OIS_LIRC_IP") != 0) ? getenv("OIS_LIRC_IP") : "127.0.0.1";
+	mPort = (getenv("OIS_LIRC_PORT") != 0) ? getenv("OIS_LIRC_PORT") : "8765";
+
+	try
+	{
+		enableConnection(true);
+		discoverRemotes();
+	}
+	catch(...)
+	{
+		mCount = 0;
+	}
+
+	//Regardless of if there is remotes or not, we will close the conenction now.
+	enableConnection(false);
+}
+
+//---------------------------------------------------------------------------------//
+LIRCFactoryCreator::~LIRCFactoryCreator()
+{
+	enableConnectionThread(false);
+	enableConnection(false);
+
+	delete mWrapped;
+}
+
+//---------------------------------------------------------------------------------//
+void LIRCFactoryCreator::discoverRemotes()
+{
+	//http://www.lirc.org/html/technical.html#applications
+	mCount = 0;
+
+	mWrapped->mSocket.write_some(boost::asio::buffer("LIST\n"));
+
+	boost::asio::streambuf buffer;
+
+	//Read all remotes
+	bool start = false;
+	bool data = false;
+	for(;;)
+	{
+		boost::asio::read_until(mWrapped->mSocket, buffer, '\n');
+
+		std::istream str(&buffer);
+		std::string res;
+		str >> res;
+
+		if( res == "" )				//If nothing left, we are done
+			break;
+		else if( res == "ERROR" )	//If any errors, we leave immediately
+			return;
+		else if( res == "END" )		//We have reached the end block
+			start = false;
+		else if( res == "DATA" )	//After Data will be a list of remote names
+		{
+			start = true;
+			data = true;
+			continue;
+		}
+
+		//Have we  gotten the DATA word yet?
+		if( start == false )
+			continue;
+
+		if( data ) //How many?
+			mCount = atoi(res.c_str());
+		else //What follows should now be a list of remote names
+			mUnusedRemotes.push_back(res);
+
+		data = false;
+	}
+
+	//Read information about each remote
+	boost::asio::streambuf buffer2;
+	for( int i = 0; i < mCount; ++i )
+	{
+		std::ostringstream istr;
+		istr << "LIST " << mUnusedRemotes[i] << "\n";
+		
+		mWrapped->mSocket.write_some(boost::asio::buffer(istr.str()));
+		RemoteInfo information;
+		int buttonCount = 0;
+
+		start = data = false;
+		
+		for(;;)
+		{
+			boost::asio::read_until(mWrapped->mSocket, buffer, '\n');
+
+			std::istream str(&buffer);
+			std::string res;
+			str >> res;
+
+			if( res == "" )				//If nothing left, we are done
+				break;
+			else if( res == "ERROR" )	//If error, bail out
+				return;
+			else if( res == "END" )		//We have reached the end block
+				start = false;
+			else if( res == "DATA" )	//After Data will be button count
+			{
+				start = true;
+				data = true;
+				continue;
+			}
+
+			//Have we  gotten the DATA word yet?
+			if( start == false )
+				continue;
+
+			if( data ) //After button count, there will be a list of button names
+				information.buttons = atoi(res.c_str());
+			else
+				information.buttonMap[res] = buttonCount++;
+
+			data = false;
+		}
+
+		mJoyStickInformation[mUnusedRemotes[i]] = information;
+	}
+}
+
+//---------------------------------------------------------------------------------//
+void LIRCFactoryCreator::enableConnection(bool enable, bool blocking)
+{
+	if( enable == true && mConnected == false )
+	{
+		boost::asio::ip::tcp::resolver resolver(mWrapped->mIOService);
+		boost::asio::ip::tcp::resolver::query query(mIP, mPort);
+		boost::asio::ip::tcp::resolver::iterator endpoint_iterator = resolver.resolve(query);
+		boost::asio::ip::tcp::resolver::iterator end;
+
+		//Connect (trying all found connections - ip4/ip6)
+		boost::asio::error result = boost::asio::error::host_not_found;
+		while (result && endpoint_iterator != end)
+		{
+			mWrapped->mSocket.close();
+			mWrapped->mSocket.connect(*endpoint_iterator++, boost::asio::assign_error(result));
+		}
+
+		if (result != boost::asio::error::success)
+			throw (result);
+
+		if( blocking == false )
+		{
+			mWrapped->mSocket.io_control(boost::asio::socket_base::non_blocking_io(true));
+		}
+
+		mConnected = true;
+	}
+	else if( enable == false )
+	{
+		mWrapped->mSocket.close();
+		mConnected = false;
+	}
+}
+
+//---------------------------------------------------------------------------------//
+void LIRCFactoryCreator::enableConnectionThread(bool enable)
+{
+	if( enable == true && mThreadRunning == false )
+	{
+		mThreadRunning = true;
+		mWrapped->mThreadHandler = new boost::thread(boost::bind(&LIRCFactoryCreator::threadUpdate, this));
+	}
+	else if( enable == false && mThreadRunning == true )
+	{
+		mThreadRunning = false;
+		mWrapped->mThreadHandler->join();
+		delete mWrapped->mThreadHandler;
+		mWrapped->mThreadHandler = 0;
+	}
+}
+
+//---------------------------------------------------------------------------------//
+void LIRCFactoryCreator::threadUpdate()
+{
+	boost::xtime timer;
+	boost::asio::streambuf buffer;
+	std::istream stream(&buffer);
+	std::string code, repeat, button, remote;
+
+
+	while( mThreadRunning )
+	{
+		try
+		{
+			while(  mWrapped->mSocket.in_avail() > 0 )
+			{
+				boost::asio::read_until(mWrapped->mSocket, buffer, '\n');
+				
+				stream >> code;   //64 bit value, ignorable
+				stream >> repeat; //Repeat rate starting at zero (we ignore, for now)
+				stream >> button; //Button name
+				stream >> remote; //Remote name
+
+				{	//Lock object, find out which remote sent event
+					boost::mutex::scoped_lock arrayLock(mWrapped->mLircListMutex);
+					std::map<std::string, LIRCControl*>::iterator i = mUpdateRemotes.find(remote);
+					if( i != mUpdateRemotes.end() )
+					{
+						i->second->queueButtonPressed(button);
+					}
+				}
+			}
+		}
+		catch(...)
+		{	//Hmm, what should we do if we get a socket error here.. Ignore it I suppose,
+		}	//and wait till the used remote objects get shutdown. We could try to 
+			//reconnect, but how do we know if we will even get the same remotes.
+
+		boost::xtime_get(&timer, boost::TIME_UTC);
+		timer.nsec += 300000000; // 100 000 000 ~= .3 sec
+		boost::thread::sleep(timer);
+	}
+}
+
+//---------------------------------------------------------------------------------//
+DeviceList LIRCFactoryCreator::freeDeviceList()
+{
+	DeviceList list;
+	for( std::vector<std::string>::iterator i = mUnusedRemotes.begin(); i != mUnusedRemotes.end(); ++i )
+		list.insert(std::make_pair(OISJoyStick, *i));
+
+	return list;
+}
+
+//---------------------------------------------------------------------------------//
+int LIRCFactoryCreator::totalDevices(Type iType)
+{
+	if( iType == OISJoyStick )
+		return mCount;
+	else
+		return 0;
+}
+
+//---------------------------------------------------------------------------------//
+int LIRCFactoryCreator::freeDevices(Type iType)
+{
+	if( iType == OISJoyStick )
+		return (int)mUnusedRemotes.size();
+	else
+		return 0;
+}
+
+//---------------------------------------------------------------------------------//
+bool LIRCFactoryCreator::vendorExist(Type iType, const std::string & vendor)
+{
+	if( iType == OISJoyStick && std::find(mUnusedRemotes.begin(), mUnusedRemotes.end(), vendor) != mUnusedRemotes.end() )
+		return true;
+	else
+		return false;
+}
+
+//---------------------------------------------------------------------------------//
+Object* LIRCFactoryCreator::createObject(InputManager* creator, Type iType, bool bufferMode, const std::string & vendor)
+{
+	if( mUnusedRemotes.size() > 0 )
+	{
+		std::vector<std::string>::iterator remote = mUnusedRemotes.end();
+		if( vendor == "" )
+			remote = mUnusedRemotes.begin();
+		else
+			remote = std::find(mUnusedRemotes.begin(), mUnusedRemotes.end(), vendor);
+
+		if( remote != mUnusedRemotes.end() )
+		{
+			//Make sure connection is established
+			enableConnection(true, false);
+
+			//Make sure connection thread is alive
+			enableConnectionThread(true);
+
+			//Create device
+			LIRCControl *obj = new LIRCControl(creator, 0, bufferMode, this, mJoyStickInformation[*remote]);
+
+			//Add to used list, and then remove from unused list
+			{
+				boost::mutex::scoped_lock arrayLock(mWrapped->mLircListMutex);
+				mUpdateRemotes[*remote] = obj;
+			}
+			mUnusedRemotes.erase(remote);
+
+			return obj;
+		}
+	}
+	
+	OIS_EXCEPT(E_InputDeviceNonExistant, "No Device found which matches description!");
+}
+
+//---------------------------------------------------------------------------------//
+void LIRCFactoryCreator::destroyObject(Object* obj)
+{
+	if( obj == 0 )
+		return;
+
+	int remotes_alive = 0;
+
+	{	//Scope lock
+		boost::mutex::scoped_lock arrayLock(mWrapped->mLircListMutex);
+
+		//Find object
+		std::map<std::string, LIRCControl*>::iterator i = mUpdateRemotes.begin(), e = mUpdateRemotes.end();
+		bool found = false;
+		for(; i != e; ++i)
+		{
+			if( i->second == obj )
+			{
+				found = true;
+				break;
+			}
+		}
+
+		if( found == false )
+			OIS_EXCEPT(E_General, "Device not found in LIRC remote collection!");
+
+		//Move from used to unused list
+		mUnusedRemotes.push_back(i->first);
+		mUpdateRemotes.erase(i);
+		
+		delete obj;
+
+		remotes_alive = (int)mUpdateRemotes.size();
+	}
+
+	//Destroy thread if no longer in use (we do this after unlocking mutex!)
+	if( remotes_alive == 0 )
+		enableConnectionThread(false);
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/extras/LIRC/OISLIRCFactoryCreator.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/extras/LIRC/OISLIRCFactoryCreator.h
new file mode 100644
index 0000000..3103329
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/extras/LIRC/OISLIRCFactoryCreator.h
@@ -0,0 +1,98 @@
+#include "OISConfig.h"
+#ifdef OIS_LIRC_SUPPORT
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_LIRCFactoryCreator_H
+#define OIS_LIRCFactoryCreator_H
+
+#include "OISPrereqs.h"
+#include "OISFactoryCreator.h"
+#include "OISLIRC.h"
+
+namespace OIS
+{
+	//Forward declare local classes
+	class LIRCControl;
+
+	/** LIRC Factory Creator Class */
+	class _OISExport LIRCFactoryCreator : public FactoryCreator
+	{
+	public:
+		LIRCFactoryCreator();
+		~LIRCFactoryCreator();
+
+		//FactoryCreator Overrides
+		/** @copydoc FactoryCreator::deviceList */
+		DeviceList freeDeviceList();
+
+		/** @copydoc FactoryCreator::totalDevices */
+		int totalDevices(Type iType);
+
+		/** @copydoc FactoryCreator::freeDevices */
+		int freeDevices(Type iType);
+
+		/** @copydoc FactoryCreator::vendorExist */
+		bool vendorExist(Type iType, const std::string & vendor);
+
+		/** @copydoc FactoryCreator::createObject */
+		Object* createObject(InputManager* creator, Type iType, bool bufferMode, const std::string & vendor = "");
+
+		/** @copydoc FactoryCreator::destroyObject */
+		void destroyObject(Object* obj);
+
+	protected:
+		//! Gets a list of all remotes available
+		void discoverRemotes();
+
+		//! Connects to LIRC server
+		void enableConnection(bool enable, bool blocking = true);
+
+		//! Creates/destroys threaded read
+		void enableConnectionThread(bool enable);
+
+		void threadUpdate();
+
+		std::string mIP;
+		std::string mPort;
+		bool mConnected;
+		volatile bool mThreadRunning;
+		std::map<std::string, LIRCControl*> mUpdateRemotes;
+
+		//! List of vendor named remotes that are not used yet
+		std::vector<std::string> mUnusedRemotes;
+		
+		//! Information about enumerated remotes
+		std::map<std::string, RemoteInfo> mJoyStickInformation;
+
+		//! Number of total found remotes
+		int mCount;
+
+		//! Get the slow boost header includes from this header by using a proxy wrapper
+		class BoostWrapper;
+
+		//! Wrapped objects
+		BoostWrapper *mWrapped;
+	};
+}
+#endif //OIS_LIRCFactoryCreator_H
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/extras/LIRC/OISLIRCRingBuffer.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/extras/LIRC/OISLIRCRingBuffer.h
new file mode 100644
index 0000000..e215779
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/extras/LIRC/OISLIRCRingBuffer.h
@@ -0,0 +1,269 @@
+#include "OISConfig.h"
+#ifdef OIS_LIRC_SUPPORT
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+
+ # ------------------------#
+ # Original License follows:
+ # ------------------------#
+
+ * PortAudio Portable Real-Time Audio Library
+ * Latest version at: http://www.audiomulch.com/portaudio/
+ * <platform> Implementation
+ * Copyright (c) 1999-2000 <author(s)>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files
+ * (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * Any person wishing to distribute modifications to the Software is
+ * requested to send the modifications to the original developer so that
+ * they can be incorporated into the canonical version.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef OIS_LIRCRingBuffer_H
+#define OIS_LIRCRingBuffer_H
+
+#include "OISPrereqs.h"
+
+namespace OIS
+{
+	struct LIRCEvent
+	{
+		//! high bit (0x80000000) will be on if button pushed, else it was released
+		unsigned int button;
+	};
+
+	/// <summary>
+	/// Ring Buffer (fifo) used to store 16bit pcm data
+	/// </summary>
+	class LIRCRingBuffer
+	{
+	private:
+		//! Number of bytes in FIFO. Power of 2. Set by RingBuffer_Init
+		int bufferSize;
+		//! Used for wrapping indices with extra bit to distinguish full/empty.
+		int bigMask;
+		// Used for fitting indices to buffer.
+		int smallMask;
+
+		// Buffer holding the actual event buffers
+		LIRCEvent *buffer;
+
+		//! Index of next writable byte. Set by RingBuffer_AdvanceWriteIndex.
+		volatile int writeIndex; 
+		
+		//! Index of next readable byte. Set by RingBuffer_AdvanceReadIndex.
+		volatile int readIndex;	
+
+	public:
+		LIRCRingBuffer( unsigned int numEntries )
+		{
+			numEntries = RoundUpToNextPowerOf2( numEntries );
+
+			//2 bytes per short
+			bufferSize = (int)numEntries;
+			buffer = new LIRCEvent[numEntries];
+
+			Flush();
+
+			bigMask = (int)(numEntries*2)-1;
+			smallMask = (int)(numEntries)-1;
+		}
+
+		~LIRCRingBuffer()
+		{
+			delete buffer;
+		}
+
+		unsigned int RoundUpToNextPowerOf2( unsigned int n )
+		{
+			int numBits = 0;
+			if( ((n-1) & n) == 0) 
+			return n; //Already Power of two.
+
+			while( n > 0 )
+			{
+				n= n>>1;
+				numBits++;
+			}
+			return (unsigned int)(1<<numBits);
+		}
+
+
+		int GetReadAvailable( )
+		{
+			return ( (writeIndex - readIndex) & bigMask );
+		}
+
+
+		int GetWriteAvailable( )
+		{
+			return ( bufferSize - GetReadAvailable());
+		}
+
+
+		int Write( LIRCEvent *data, int numEntries )
+		{
+			int size1 = 0, size2 = 0, numWritten;
+			int data1Ptr = 0, data2Ptr = 0;
+			
+			numWritten = GetWriteRegions( numEntries, data1Ptr, size1, data2Ptr, size2 );
+
+			if( size2 > 0 )
+			{
+				//copy to two parts
+				memcpy( &buffer[data1Ptr], data, sizeof(LIRCEvent) * size1 );
+				//Array.Copy( data, offsetPtr, buffer, data1Ptr, size1 );
+				memcpy( &buffer[data2Ptr], &data[size1], sizeof(LIRCEvent) * size2 );
+				//Array.Copy( data, offsetPtr + size1, buffer, data2Ptr, size2 );
+			}
+			else
+			{	//Copy all continous
+				memcpy( &buffer[data1Ptr], data, sizeof(LIRCEvent) * size1 );
+				//Array.Copy( data, offsetPtr, buffer, data1Ptr, size1 );
+			}
+			AdvanceWriteIndex( numWritten );
+			return numWritten;
+		}
+
+
+		/// <summary>
+		/// Reads requested number of entries into sent array.
+		/// Returns number written
+		/// </summary>
+		int Read( LIRCEvent *data, int numEntries )
+		{
+			int size1 = 0, size2 = 0, numRead, data1Ptr = 0, data2Ptr = 0;
+			
+			numRead = GetReadRegions( numEntries, data1Ptr, size1, data2Ptr, size2 );
+			
+			if( size2 > 0 )
+			{
+				memcpy( data, &buffer[data1Ptr], sizeof(LIRCEvent) * size1 );
+				//Array.Copy( buffer, data1Ptr, data, 0, size1 );
+				memcpy( &data[size1], &buffer[data2Ptr], sizeof(LIRCEvent) * size2 );
+				//Array.Copy( buffer, data2Ptr, data, size1, size2 );
+			}
+			else
+				memcpy( data, &buffer[data1Ptr], sizeof(LIRCEvent) * size1 );
+				//Array.Copy( buffer, data1Ptr, data, 0, size1 );
+
+			AdvanceReadIndex( numRead );
+			return numRead;
+		}
+
+	private:
+
+		int GetWriteRegions( int numEntries, int &dataPtr1, int &sizePtr1,
+							 int &dataPtr2, int &sizePtr2 )
+		{
+			int   index;
+			int   available = GetWriteAvailable();
+			if( numEntries > available ) 
+				numEntries = available;
+		
+			//Check to see if write is not contiguous.
+			index = writeIndex & smallMask;
+			if( (index + numEntries) > bufferSize )
+			{
+				//Write data in two blocks that wrap the buffer.
+				int   firstHalf = bufferSize - index;
+				dataPtr1 = index;//&buffer[index];
+				sizePtr1 = firstHalf;
+				dataPtr2 = 0;//&buffer[0];
+				sizePtr2 = numEntries - firstHalf;
+			}
+			else
+			{
+				dataPtr1 = index;//&buffer[index];
+				sizePtr1 = numEntries;
+				dataPtr2 = 0;
+				sizePtr2 = 0;
+			}
+			return numEntries;
+		}
+	
+
+		int GetReadRegions( int numEntries, int &dataPtr1, int &sizePtr1, int &dataPtr2, int &sizePtr2 )
+		{
+			int   index;
+			int   available = GetReadAvailable( );
+			if( numEntries > available ) 
+				numEntries = available;
+			
+			// Check to see if read is not contiguous
+			index = readIndex & smallMask;
+			if( (index + numEntries) > bufferSize )
+			{
+				// Write data in two blocks that wrap the buffer
+				int firstHalf = bufferSize - index;
+				dataPtr1 = index;//&buffer[index];
+				sizePtr1 = firstHalf;
+				dataPtr2 = 0;//&buffer[0];
+				sizePtr2 = numEntries - firstHalf;
+			}
+			else
+			{
+				dataPtr1 = index;//&buffer[index];
+				sizePtr1 = numEntries;
+				dataPtr2 = 0;
+				sizePtr2 = 0;
+			}
+			return numEntries;
+		}
+
+
+		int AdvanceWriteIndex( int numEntries )
+		{
+			 return writeIndex = (writeIndex + numEntries) & bigMask;
+		}
+
+
+		int AdvanceReadIndex( int numEntries )
+		{
+			return readIndex = (readIndex + numEntries) & bigMask;
+		}
+
+
+		void Flush( )
+		{
+			writeIndex = readIndex = 0;
+		}
+	};
+}
+#endif //#define OIS_LIRCRingBuffer_H
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/iphone/iPhoneAccelerometer.mm b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/iphone/iPhoneAccelerometer.mm
new file mode 100644
index 0000000..7cdb15c
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/iphone/iPhoneAccelerometer.mm
@@ -0,0 +1,80 @@
+/*
+ The zlib/libpng License
+ 
+ Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+ 
+ This software is provided 'as-is', without any express or implied warranty. In no event will
+ the authors be held liable for any damages arising from the use of this software.
+ 
+ Permission is granted to anyone to use this software for any purpose, including commercial 
+ applications, and to alter it and redistribute it freely, subject to the following
+ restrictions:
+ 
+ 1. The origin of this software must not be misrepresented; you must not claim that 
+ you wrote the original software. If you use this software in a product, 
+ an acknowledgment in the product documentation would be appreciated but is 
+ not required.
+ 
+ 2. Altered source versions must be plainly marked as such, and must not be 
+ misrepresented as being the original software.
+ 
+ 3. This notice may not be removed or altered from any source distribution.
+ */
+#include "iphone/iPhoneAccelerometer.h"
+#include "iphone/iPhoneInputManager.h"
+
+using namespace OIS;
+
+//-------------------------------------------------------------------//
+iPhoneAccelerometer::iPhoneAccelerometer( InputManager* creator, bool buffered )
+	: JoyStick(creator->inputSystemName(), buffered, 0, creator)
+{
+    iPhoneInputManager *man = static_cast<iPhoneInputManager*>(mCreator);
+    
+    man->_setAccelerometerUsed(true);
+    [man->_getDelegate() setAccelerometerObject:this];
+    [[UIAccelerometer sharedAccelerometer] setDelegate:man->_getDelegate()];
+    mUpdateInterval = 60.0f;
+}
+
+iPhoneAccelerometer::~iPhoneAccelerometer()
+{
+    iPhoneInputManager *man = static_cast<iPhoneInputManager*>(mCreator);
+    
+    man->_setAccelerometerUsed(false);
+    [man->_getDelegate() setAccelerometerObject:nil];
+}
+
+void iPhoneAccelerometer::_initialize()
+{
+	// Clear old joy state
+    mState.mVectors.resize(1);
+	mState.clear();
+	mTempState.clear();
+
+    // Set the update interval
+    [[UIAccelerometer sharedAccelerometer] setUpdateInterval:(1.0 / mUpdateInterval)];
+}
+
+void iPhoneAccelerometer::setBuffered( bool buffered )
+{
+	mBuffered = buffered;
+}
+
+void iPhoneAccelerometer::didAccelerate(UIAcceleration *acceleration)
+{
+    mTempState.clear();
+    
+    mTempState.x = acceleration.x;
+    mTempState.y = acceleration.y;
+    mTempState.z = acceleration.z;
+}
+
+void iPhoneAccelerometer::capture()
+{
+    mState.clear();
+    mState.mVectors[0] = mTempState;
+
+    if(mListener && mBuffered)
+        mListener->axisMoved(JoyStickEvent(this, mState), 0);
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/iphone/iPhoneInputManager.mm b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/iphone/iPhoneInputManager.mm
new file mode 100644
index 0000000..2d36fc1
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/iphone/iPhoneInputManager.mm
@@ -0,0 +1,224 @@
+/*
+ The zlib/libpng License
+ 
+ Copyright (c) 2006 Chris Snyder 
+ 
+ This software is provided 'as-is', without any express or implied warranty. In no event will
+ the authors be held liable for any damages arising from the use of this software.
+ 
+ Permission is granted to anyone to use this software for any purpose, including commercial 
+ applications, and to alter it and redistribute it freely, subject to the following
+ restrictions:
+ 
+ 1. The origin of this software must not be misrepresented; you must not claim that 
+ you wrote the original software. If you use this software in a product, 
+ an acknowledgment in the product documentation would be appreciated but is 
+ not required.
+ 
+ 2. Altered source versions must be plainly marked as such, and must not be 
+ misrepresented as being the original software.
+ 
+ 3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "iphone/iPhoneInputManager.h"
+#include "iphone/iPhoneHelpers.h"
+#include "iphone/iPhoneAccelerometer.h"
+#include "iphone/iPhoneMultiTouch.h"
+#include "OISException.h"
+
+using namespace std;
+using namespace OIS;
+
+@implementation InputDelegate
+
+@synthesize touchObject;
+@synthesize accelerometerObject;
+
+- (id)init {
+    if((self = [super init])) {
+        touchObject = nil;
+        accelerometerObject = nil;
+    }
+    return self;
+}
+
+- (void)dealloc {
+    delete touchObject; touchObject = NULL;
+    delete accelerometerObject; accelerometerObject = NULL;
+
+    [super dealloc];
+}
+
+- (BOOL)canBecomeFirstResponder
+{
+    return YES;
+}
+
+#pragma mark Accelerator Event Handling
+- (void)accelerometer:(UIAccelerometer *)accelerometer didAccelerate:(UIAcceleration *)acceleration {
+    accelerometerObject->didAccelerate(acceleration);
+}
+
+#pragma mark Touch Event Handling
+- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
+    for(UITouch *touch in touches) {
+        touchObject->_touchEnded(touch);
+    }
+}
+
+- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {
+    for(UITouch *touch in touches) {
+        touchObject->_touchMoved(touch);
+    }
+}
+
+- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event {
+    for(UITouch *touch in touches) {
+        touchObject->_touchCancelled(touch);
+    }
+}
+
+- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
+    for(UITouch *touch in touches) {
+        touchObject->_touchBegan(touch);
+    }
+}
+
+@end
+
+//--------------------------------------------------------------------------------//
+iPhoneInputManager::iPhoneInputManager() : InputManager("iPhone Input Manager")
+{
+    mHideMouse = true;
+	bAccelerometerUsed = bMultiTouchUsed = false;
+
+	// Setup our internal factories
+	mFactories.push_back(this);
+}
+
+//--------------------------------------------------------------------------------//
+iPhoneInputManager::~iPhoneInputManager()
+{
+    [mDelegate release]; mDelegate = nil;
+    [mWindow release]; mWindow = nil;
+}
+
+//--------------------------------------------------------------------------------//
+void iPhoneInputManager::_initialize( ParamList &paramList )
+{
+	_parseConfigSettings( paramList );
+    
+    mDelegate = [[InputDelegate alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
+    
+    // Set flags that we want to accept multiple finger touches and be the only one to receive touch events
+    [mDelegate setMultipleTouchEnabled:YES];
+    [mDelegate setExclusiveTouch:YES];
+    [mDelegate becomeFirstResponder];
+
+    [mWindow addSubview:mDelegate];
+}
+
+//--------------------------------------------------------------------------------//
+void iPhoneInputManager::_parseConfigSettings( ParamList &paramList )
+{
+    // Some carbon apps are running in a window, however full screen apps
+	// do not have a window, so we need to account for that too.
+	ParamList::iterator i = paramList.find("WINDOW");
+	if(i != paramList.end())
+	{
+		mWindow = (UIWindow *)strtoul(i->second.c_str(), 0, 10);
+		if(mWindow == 0)
+			mWindow = nil;
+    }
+	else
+	{
+		// else get the main active window.. user might not have access to it through some
+		// graphics libraries, if that fails then try at the application level.
+        mWindow = [[UIApplication sharedApplication] keyWindow];
+	}
+	
+	if(mWindow == nil)
+		OIS_EXCEPT( E_General, "iPhoneInputManager::_parseConfigSettings >> Unable to find a window or event target" );
+}
+
+//--------------------------------------------------------------------------------//
+DeviceList iPhoneInputManager::freeDeviceList()
+{
+	DeviceList ret;
+
+	if( bAccelerometerUsed == false )
+		ret.insert(std::make_pair(OISJoyStick, mInputSystemName));
+
+	if( bMultiTouchUsed == false )
+		ret.insert(std::make_pair(OISMultiTouch, mInputSystemName));
+
+	return ret;
+}
+
+//--------------------------------------------------------------------------------//
+int iPhoneInputManager::totalDevices(Type iType)
+{
+	switch(iType)
+	{
+        case OISJoyStick: return 1;
+        case OISMultiTouch: return 1;
+        default: return 0;
+	}
+}
+
+//--------------------------------------------------------------------------------//
+int iPhoneInputManager::freeDevices(Type iType)
+{
+	switch(iType)
+	{
+        case OISJoyStick: return bAccelerometerUsed ? 0 : 1;
+        case OISMultiTouch: return bMultiTouchUsed ? 0 : 1;
+        default: return 0;
+	}
+}
+
+//--------------------------------------------------------------------------------//
+bool iPhoneInputManager::vendorExist(Type iType, const std::string & vendor)
+{
+	if( ( iType == OISMultiTouch || iType == OISJoyStick ) && vendor == mInputSystemName )
+		return true;
+
+	return false;
+}
+
+//--------------------------------------------------------------------------------//
+Object* iPhoneInputManager::createObject(InputManager* creator, Type iType, bool bufferMode, 
+									  const std::string & vendor)
+{
+	Object *obj = 0;
+
+	switch(iType)
+	{
+        case OISJoyStick:
+        {
+            if( bAccelerometerUsed == false )
+                obj = new iPhoneAccelerometer(this, bufferMode);
+            break;
+        }
+        case OISMultiTouch:
+        {
+            if( bMultiTouchUsed == false )
+                obj = new iPhoneMultiTouch(this, bufferMode);
+            break;
+        }
+        default:
+            break;
+	}
+
+	if( obj == 0 )
+		OIS_EXCEPT(E_InputDeviceNonExistant, "No devices match requested type.");
+
+	return obj;
+}
+
+//--------------------------------------------------------------------------------//
+void iPhoneInputManager::destroyObject(Object* obj)
+{
+	delete obj;
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/iphone/iPhoneMultiTouch.mm b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/iphone/iPhoneMultiTouch.mm
new file mode 100644
index 0000000..718eb20
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/iphone/iPhoneMultiTouch.mm
@@ -0,0 +1,177 @@
+/*
+ The zlib/libpng License
+ 
+ Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+ 
+ This software is provided 'as-is', without any express or implied warranty. In no event will
+ the authors be held liable for any damages arising from the use of this software.
+ 
+ Permission is granted to anyone to use this software for any purpose, including commercial 
+ applications, and to alter it and redistribute it freely, subject to the following
+ restrictions:
+ 
+ 1. The origin of this software must not be misrepresented; you must not claim that 
+ you wrote the original software. If you use this software in a product, 
+ an acknowledgment in the product documentation would be appreciated but is 
+ not required.
+ 
+ 2. Altered source versions must be plainly marked as such, and must not be 
+ misrepresented as being the original software.
+ 
+ 3. This notice may not be removed or altered from any source distribution.
+ */
+#include "iphone/iPhoneMultiTouch.h"
+#include "iphone/iPhoneInputManager.h"
+
+using namespace OIS;
+
+//-------------------------------------------------------------------//
+iPhoneMultiTouch::iPhoneMultiTouch( InputManager* creator, bool buffered )
+	: MultiTouch(creator->inputSystemName(), buffered, 0, creator)
+{
+	iPhoneInputManager *man = static_cast<iPhoneInputManager*>(mCreator);
+
+    man->_setMultiTouchUsed(true);
+    [man->_getDelegate() setTouchObject:this];
+}
+
+iPhoneMultiTouch::~iPhoneMultiTouch()
+{
+	iPhoneInputManager *man = static_cast<iPhoneInputManager*>(mCreator);
+    
+    man->_setMultiTouchUsed(false);
+    [man->_getDelegate() setTouchObject:nil];
+}
+
+void iPhoneMultiTouch::_initialize()
+{
+//    mTempState.clear();
+}
+
+void iPhoneMultiTouch::setBuffered( bool buffered )
+{
+	mBuffered = buffered;
+}
+
+void iPhoneMultiTouch::capture()
+{
+#if 0
+    for( std::multiset<MultiTouchState *>::iterator i = mStates.begin(), e = mStates.end(); i != e; ++i )
+    {
+        // Clear the state first
+        dynamic_cast<MultiTouchState *>(*i)->clear();
+
+        if(mTempState.X.rel || mTempState.Y.rel || mTempState.Z.rel)
+        {
+            MultiTouchState *iState = dynamic_cast<MultiTouchState *>(*i);
+    //		NSLog(@"%i %i %i", mTempState.X.rel, mTempState.Y.rel, mTempState.Z.rel);
+
+            // Set new relative motion values
+            iState->X.rel = mTempState.X.rel;
+            iState->Y.rel = mTempState.Y.rel;
+            iState->Z.rel = mTempState.Z.rel;
+            
+            // Update absolute position
+            iState->X.abs += mTempState.X.rel;
+            iState->Y.abs += mTempState.Y.rel;
+            
+            if(iState->X.abs > iState->width)
+                iState->X.abs = iState->width;
+            else if(iState->X.abs < 0)
+                iState->X.abs = 0;
+
+            if(iState->Y.abs > iState->height)
+                iState->Y.abs = iState->height;
+            else if(iState->Y.abs < 0)
+                iState->Y.abs = 0;
+                
+            iState->Z.abs += mTempState.Z.rel;
+            
+            //Fire off event
+            if(mListener && mBuffered)
+                mListener->touchMoved(MultiTouchEvent(this, *iState));
+        }
+    }
+
+	mTempState.clear();
+#endif
+}
+
+void iPhoneMultiTouch::_touchBegan(UITouch *touch)
+{
+    CGPoint location = [touch locationInView:static_cast<iPhoneInputManager*>(mCreator)->_getDelegate()];
+
+    MultiTouchState newState;
+    newState.X.abs = location.x;
+    newState.Y.abs = location.y;
+    newState.touchType |= 1 << MT_Pressed;
+
+    if( mListener && mBuffered )
+    {
+        mListener->touchPressed(MultiTouchEvent(this, newState));
+    }
+    else
+    {
+        mStates.push_back(newState);
+    }
+}
+
+void iPhoneMultiTouch::_touchEnded(UITouch *touch)
+{
+    CGPoint location = [touch locationInView:static_cast<iPhoneInputManager*>(mCreator)->_getDelegate()];
+
+    MultiTouchState newState;
+    newState.X.abs = location.x;
+    newState.Y.abs = location.y;
+    newState.touchType |= 1 << MT_Released;
+
+    if( mListener && mBuffered )
+    {
+        mListener->touchReleased(MultiTouchEvent(this, newState));
+    }
+    else
+    {
+        mStates.push_back(newState);
+    }
+}
+
+void iPhoneMultiTouch::_touchMoved(UITouch *touch)
+{
+    CGPoint location = [touch locationInView:static_cast<iPhoneInputManager*>(mCreator)->_getDelegate()];
+    CGPoint previousLocation = [touch previousLocationInView:static_cast<iPhoneInputManager*>(mCreator)->_getDelegate()];
+
+    MultiTouchState newState;
+    newState.X.rel = (location.x - previousLocation.x);
+    newState.Y.rel = (location.y - previousLocation.y);
+    newState.X.abs = location.x;
+    newState.Y.abs = location.y;
+    newState.touchType |= 1 << MT_Moved;
+
+    if( mListener && mBuffered )
+    {
+        mListener->touchMoved(MultiTouchEvent(this, newState));
+    }
+    else
+    {
+        mStates.push_back(newState);
+    }
+}
+
+void iPhoneMultiTouch::_touchCancelled(UITouch *touch)
+{
+    CGPoint location = [touch locationInView:static_cast<iPhoneInputManager*>(mCreator)->_getDelegate()];
+
+    MultiTouchState newState;
+    newState.X.abs = location.x;
+    newState.Y.abs = location.y;
+    newState.touchType |= 1 << MT_Cancelled;
+
+    if( mListener && mBuffered )
+    {
+        mListener->touchCancelled(MultiTouchEvent(this, newState));
+    }
+    else
+    {
+        mStates.push_back(newState);
+    }
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/linux/EventHelpers.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/linux/EventHelpers.cpp
new file mode 100644
index 0000000..3bf5448
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/linux/EventHelpers.cpp
@@ -0,0 +1,377 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that
+		you wrote the original software. If you use this software in a product,
+		an acknowledgment in the product documentation would be appreciated but is
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "linux/EventHelpers.h"
+#include "linux/LinuxPrereqs.h"
+#include "linux/LinuxForceFeedback.h"
+#include "OISException.h"
+#include "OISJoyStick.h"
+
+#include <linux/input.h>
+#include <cstring>
+
+//#define OIS_LINUX_JOY_DEBUG
+
+#ifdef OIS_LINUX_JOY_DEBUG
+# include <iostream>
+#endif
+
+using namespace std;
+using namespace OIS;
+
+class DeviceComponentInfo
+{
+public:
+	vector<int> buttons, relAxes, absAxes, hats;
+};
+
+bool inline isBitSet(unsigned char bits[], unsigned int bit)
+{
+  return (bits[(bit)/(sizeof(unsigned char)*8)] >> ((bit)%(sizeof(unsigned char)*8))) & 1;
+}
+
+//-----------------------------------------------------------------------------//
+DeviceComponentInfo getComponentInfo( int deviceID )
+{
+	unsigned char ev_bits[1 + EV_MAX/8/sizeof(unsigned char)];
+	memset( ev_bits, 0, sizeof(ev_bits) );
+
+	//Read "all" (hence 0) components of the device
+#ifdef OIS_LINUX_JOY_DEBUG
+	cout << "EventUtils::getComponentInfo(" << deviceID 
+		 << ") : Reading device events features" << endl;
+#endif
+	if (ioctl(deviceID, EVIOCGBIT(0, sizeof(ev_bits)), ev_bits) == -1)
+		OIS_EXCEPT( E_General, "Could not read device events features");
+
+	DeviceComponentInfo components;
+
+	for (int i = 0; i < EV_MAX; i++)
+	{
+		if( isBitSet(ev_bits, i) )
+		{
+		    // Absolute axis.
+		    if(i == EV_ABS)
+			{
+			    unsigned char abs_bits[1 + ABS_MAX/8/sizeof(unsigned char)];
+			    memset( abs_bits, 0, sizeof(abs_bits) );
+
+#ifdef OIS_LINUX_JOY_DEBUG
+				cout << "EventUtils::getComponentInfo(" << deviceID 
+					 << ") : Reading device absolute axis features" << endl;
+#endif
+
+				if (ioctl(deviceID, EVIOCGBIT(i, sizeof(abs_bits)), abs_bits) == -1)
+				    OIS_EXCEPT( E_General, "Could not read device absolute axis features");
+
+				for (int j = 0; j < ABS_MAX; j++)
+				{
+				    if( isBitSet(abs_bits, j) )
+					{
+						//input_absinfo abInfo;
+						//ioctl( fd, EVIOCGABS(j), abInfo );
+						if( j >= ABS_HAT0X && j <= ABS_HAT3Y )
+						{
+							components.hats.push_back(j);
+						}
+						else
+						{
+							components.absAxes.push_back(j);
+							//input_absinfo absinfo;
+							//ioctl(deviceID, EVIOCGABS(j), &absinfo);
+							//We cannot actually change these values :|
+							//absinfo.minimum = JoyStick::MIN_AXIS;
+							//absinfo.maximum = JoyStick::MAX_AXIS;
+							//ioctl(deviceID, EVIOCSABS(j), &absinfo);
+						}
+					}
+				}
+			}
+			else if(i == EV_REL)
+			{
+			    unsigned char rel_bits[1 + REL_MAX/8/sizeof(unsigned char)];
+				memset( rel_bits, 0, sizeof(rel_bits) );
+				
+#ifdef OIS_LINUX_JOY_DEBUG
+				cout << "EventUtils::getComponentInfo(" << deviceID 
+					 << ") : Reading device relative axis features" << endl;
+#endif
+
+				if (ioctl(deviceID, EVIOCGBIT(i, sizeof(rel_bits)), rel_bits) == -1)
+				    OIS_EXCEPT( E_General, "Could not read device relative axis features");
+				
+				for (int j = 0; j < REL_MAX; j++)
+				{
+				    if( isBitSet(rel_bits, j) )
+					{
+					    components.relAxes.push_back(j);
+					}
+				}
+			}
+			else if(i == EV_KEY)
+			{
+			    unsigned char key_bits[1 + KEY_MAX/8/sizeof(unsigned char)];
+				memset( key_bits, 0, sizeof(key_bits) );
+				
+#ifdef OIS_LINUX_JOY_DEBUG
+				cout << "EventUtils::getComponentInfo(" << deviceID 
+					 << ") : Reading device buttons features" << endl;
+#endif
+
+				if (ioctl(deviceID, EVIOCGBIT(i, sizeof(key_bits)), key_bits) == -1)
+				    OIS_EXCEPT( E_General, "Could not read device buttons features");
+				
+				for (int j = 0; j < KEY_MAX; j++)
+				{
+				    if( isBitSet(key_bits, j) )
+					{
+					    components.buttons.push_back(j);
+					}
+				}
+			}
+		}
+	}
+
+	return components;
+}
+
+//-----------------------------------------------------------------------------//
+bool EventUtils::isJoyStick( int deviceID, JoyStickInfo &js )
+{
+	if( deviceID == -1 ) 
+		OIS_EXCEPT( E_General, "Error with File Descriptor" );
+
+	DeviceComponentInfo info = getComponentInfo( deviceID );
+
+	int buttons = 0;
+	bool joyButtonFound = false;
+	js.button_map.clear();
+
+	#ifdef OIS_LINUX_JOY_DEBUG
+	cout << endl << "Displaying ButtonMapping Status:" << endl;
+	#endif
+	for(vector<int>::iterator i = info.buttons.begin(), e = info.buttons.end(); i != e; ++i )
+	{
+		//Check to ensure we find at least one joy only button
+		if( (*i >= BTN_JOYSTICK && *i < BTN_GAMEPAD)  
+			|| (*i >= BTN_GAMEPAD && *i < BTN_DIGI)
+			|| (*i >= BTN_WHEEL && *i < KEY_OK) )
+			joyButtonFound = true;
+
+		js.button_map[*i] = buttons++;
+
+		#ifdef OIS_LINUX_JOY_DEBUG
+		  cout << "Button Mapping ID (hex): " << hex << *i 
+			   << " OIS Button Num: " << dec << buttons-1 << endl;
+		#endif
+	}
+	#ifdef OIS_LINUX_JOY_DEBUG
+	cout << endl;
+	#endif
+
+	//Joy Buttons found, so it must be a joystick or pad
+	if( joyButtonFound )
+	{
+		js.joyFileD = deviceID;
+		js.vendor = getName(deviceID);
+		js.buttons = buttons;
+		js.axes = info.relAxes.size() + info.absAxes.size();
+		js.hats = info.hats.size();
+		#ifdef OIS_LINUX_JOY_DEBUG
+		  cout << endl << "Device name:" << js.vendor << endl;
+		  cout << "Device unique Id:" << getUniqueId(deviceID) << endl;
+		  cout << "Device physical location:" << getPhysicalLocation(deviceID) << endl;
+		#endif
+
+		//Map the Axes
+		#ifdef OIS_LINUX_JOY_DEBUG
+		  cout << endl << "Displaying AxisMapping Status:" << endl;
+		#endif
+		int axes = 0;
+		for(vector<int>::iterator i = info.absAxes.begin(), e = info.absAxes.end(); i != e; ++i )
+		{
+			js.axis_map[*i] = axes;
+
+#ifdef OIS_LINUX_JOY_DEBUG
+			cout << "EventUtils::isJoyStick(" << deviceID 
+					  << ") : Reading device absolute axis #" << *i << " features" << endl;
+#endif
+
+			input_absinfo absinfo;
+			if (ioctl(deviceID, EVIOCGABS(*i), &absinfo) == -1)
+				OIS_EXCEPT( E_General, "Could not read device absolute axis features");
+			js.axis_range[axes] = Range(absinfo.minimum, absinfo.maximum);
+
+			#ifdef OIS_LINUX_JOY_DEBUG
+			  cout << "Axis Mapping ID (hex): " << hex << *i 
+				   << " OIS Axis Num: " << dec << axes << endl;
+			#endif
+
+			++axes;
+		}
+	}
+
+	return joyButtonFound;
+}
+
+//-----------------------------------------------------------------------------//
+string EventUtils::getName( int deviceID )
+{
+#ifdef OIS_LINUX_JOY_DEBUG
+	cout << "EventUtils::getName(" << deviceID 
+		 << ") : Reading device name" << endl;
+#endif
+
+	char name[OIS_DEVICE_NAME];
+	if (ioctl(deviceID, EVIOCGNAME(OIS_DEVICE_NAME), name) == -1)
+		OIS_EXCEPT( E_General, "Could not read device name");
+	return string(name);
+}
+
+//-----------------------------------------------------------------------------//
+string EventUtils::getUniqueId( int deviceID )
+{
+#ifdef OIS_LINUX_JOY_DEBUG
+	cout << "EventUtils::getUniqueId(" << deviceID 
+		 << ") : Reading device unique Id" << endl;
+#endif
+
+#define OIS_DEVICE_UNIQUE_ID 128
+	char uId[OIS_DEVICE_UNIQUE_ID];
+	if (ioctl(deviceID, EVIOCGUNIQ(OIS_DEVICE_UNIQUE_ID), uId) == -1)
+		OIS_EXCEPT( E_General, "Could not read device unique Id");
+	return string(uId);
+}
+
+//-----------------------------------------------------------------------------//
+string EventUtils::getPhysicalLocation( int deviceID )
+{
+#ifdef OIS_LINUX_JOY_DEBUG
+	cout << "EventUtils::getPhysicalLocation(" << deviceID 
+		 << ") : Reading device physical location" << endl;
+#endif
+
+#define OIS_DEVICE_PHYSICAL_LOCATION 128
+	char physLoc[OIS_DEVICE_PHYSICAL_LOCATION];
+	if (ioctl(deviceID, EVIOCGPHYS(OIS_DEVICE_PHYSICAL_LOCATION), physLoc) == -1)
+		OIS_EXCEPT( E_General, "Could not read device physical location");
+	return string(physLoc);
+}
+
+//-----------------------------------------------------------------------------//
+void EventUtils::enumerateForceFeedback( int deviceID, LinuxForceFeedback** ff )
+{
+	//Linux Event to OIS Event Mappings
+	map<int, Effect::EType> typeMap;
+	typeMap[FF_CONSTANT] = Effect::Constant;
+	typeMap[FF_RAMP]     = Effect::Ramp;
+	typeMap[FF_SPRING]   = Effect::Spring;
+	typeMap[FF_FRICTION] = Effect::Friction;
+	typeMap[FF_SQUARE]   = Effect::Square;
+	typeMap[FF_TRIANGLE] = Effect::Triangle;
+	typeMap[FF_SINE]     = Effect::Sine;
+	typeMap[FF_SAW_UP]   = Effect::SawToothUp;
+	typeMap[FF_SAW_DOWN] = Effect::SawToothDown;
+	typeMap[FF_DAMPER]   = Effect::Damper;
+	typeMap[FF_INERTIA]  = Effect::Inertia;
+	typeMap[FF_CUSTOM]   = Effect::Custom;
+
+	map<int, Effect::EForce> forceMap;
+	forceMap[FF_CONSTANT] = Effect::ConstantForce;
+	forceMap[FF_RAMP]     = Effect::RampForce;
+	forceMap[FF_SPRING]   = Effect::ConditionalForce;
+	forceMap[FF_FRICTION] = Effect::ConditionalForce;
+	forceMap[FF_SQUARE]   = Effect::PeriodicForce;
+	forceMap[FF_TRIANGLE] = Effect::PeriodicForce;
+	forceMap[FF_SINE]     = Effect::PeriodicForce;
+	forceMap[FF_SAW_UP]   = Effect::PeriodicForce;
+	forceMap[FF_SAW_DOWN] = Effect::PeriodicForce;
+	forceMap[FF_DAMPER]   = Effect::ConditionalForce;
+	forceMap[FF_INERTIA]  = Effect::ConditionalForce;
+	forceMap[FF_CUSTOM]   = Effect::CustomForce;
+
+	//Remove any previously existing memory and create fresh
+	removeForceFeedback( ff );
+	*ff = new LinuxForceFeedback(deviceID);
+
+	//Read overall force feedback features
+	unsigned char ff_bits[1 + FF_MAX/8/sizeof(unsigned char)];
+	memset(ff_bits, 0, sizeof(ff_bits));
+
+#ifdef OIS_LINUX_JOY_DEBUG
+	cout << "EventUtils::enumerateForceFeedback(" << deviceID 
+		 << ") : Reading device force feedback features" << endl;
+#endif
+
+	if (ioctl(deviceID, EVIOCGBIT(EV_FF, sizeof(ff_bits)), ff_bits) == -1)
+		OIS_EXCEPT( E_General, "Could not read device force feedback features");
+
+
+    #ifdef OIS_LINUX_JOY_DEBUG
+	cout << "FF bits: " << hex;
+	for (int i = 0; i < sizeof(ff_bits); i++)
+		cout << (int)ff_bits[i];
+	cout << endl << dec;
+    #endif
+
+	//FF Axes
+	//if( isBitSet(ff_bits, ABS_X) ) //X Axis
+	//if( isBitSet(ff_bits, ABS_Y) ) //Y Axis
+	//if( isBitSet(ff_bits, ABS_WHEEL) ) //Wheel
+
+	//FF Effects
+	for( int effect = FF_EFFECT_MIN; effect <= FF_WAVEFORM_MAX; effect++ )
+	{
+		// The RUMBLE force type is ignored, as periodic force one is more powerfull.
+		// The PERIODIC force type is processed later, for each associated periodic effect type.
+		if (effect == FF_RUMBLE || effect == FF_PERIODIC)
+			continue;
+
+		if(isBitSet(ff_bits, effect))
+		{
+			#ifdef OIS_LINUX_JOY_DEBUG
+		    cout << "  Effect Type: " << Effect::getEffectTypeName(typeMap[effect]) << endl;
+			#endif
+
+			(*ff)->_addEffectTypes( forceMap[effect], typeMap[effect] );
+		}
+	}
+
+	//FF device properties
+	if (isBitSet(ff_bits, FF_GAIN))
+		(*ff)->_setGainSupport(true);
+		
+	if (isBitSet(ff_bits, FF_AUTOCENTER))
+		(*ff)->_setAutoCenterSupport(true);
+
+	//Check to see if any effects were added, else destroy the pointer
+	const ForceFeedback::SupportedEffectList &list = (*ff)->getSupportedEffects();
+	if( list.size() == 0 )
+		removeForceFeedback( ff );
+}
+
+//-----------------------------------------------------------------------------//
+void EventUtils::removeForceFeedback( LinuxForceFeedback** ff )
+{
+	delete *ff;
+	*ff = 0;
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/linux/LinuxForceFeedback.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/linux/LinuxForceFeedback.cpp
new file mode 100644
index 0000000..a412a4f
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/linux/LinuxForceFeedback.cpp
@@ -0,0 +1,559 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that
+		you wrote the original software. If you use this software in a product,
+		an acknowledgment in the product documentation would be appreciated but is
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "linux/LinuxForceFeedback.h"
+#include "OISException.h"
+
+#include <cstdlib>
+#include <errno.h>
+#include <memory.h>
+
+using namespace OIS;
+
+// 0 = No trace; 1 = Important traces; 2 = Debug traces
+#define OIS_LINUX_JOYFF_DEBUG 1
+
+#ifdef OIS_LINUX_JOYFF_DEBUG
+# include <iostream>
+  using namespace std;
+#endif
+
+//--------------------------------------------------------------//
+LinuxForceFeedback::LinuxForceFeedback(int deviceID) :
+	ForceFeedback(), mJoyStick(deviceID)
+{
+}
+
+//--------------------------------------------------------------//
+LinuxForceFeedback::~LinuxForceFeedback()
+{
+	// Unload all effects.
+	for(EffectList::iterator i = mEffectList.begin(); i != mEffectList.end(); ++i )
+	{
+		struct ff_effect *linEffect = i->second;
+		if( linEffect )
+			_unload(linEffect->id);
+	}
+
+	mEffectList.clear();
+}
+
+//--------------------------------------------------------------//
+unsigned short LinuxForceFeedback::getFFMemoryLoad()
+{
+	int nEffects = -1;
+	if (ioctl(mJoyStick, EVIOCGEFFECTS, &nEffects) == -1)
+		OIS_EXCEPT(E_General, "Unknown error reading max number of uploaded effects.");
+#if (OIS_LINUX_JOYFF_DEBUG > 1)
+	cout << "LinuxForceFeedback("<< mJoyStick  
+		 << ") : Read device max number of uploaded effects : " << nEffects << endl;
+#endif
+
+	return (unsigned short int)(nEffects > 0 ? 100.0*mEffectList.size()/nEffects : 100);
+}
+
+//--------------------------------------------------------------//
+void LinuxForceFeedback::setMasterGain(float value)
+{
+	if (!mSetGainSupport)
+	{
+#if (OIS_LINUX_JOYFF_DEBUG > 0)
+		cout << "LinuxForceFeedback("<< mJoyStick << ") : Setting master gain " 
+			 << "is not supported by the device" << endl;
+#endif
+		return;
+	}
+
+	struct input_event event;
+
+	memset(&event, 0, sizeof(event));
+	event.type = EV_FF;
+	event.code = FF_GAIN;
+	if (value < 0.0)
+		value = 0.0;
+	else if (value > 1.0)
+		value = 1.0;
+	event.value = (__s32)(value * 0xFFFFUL);
+
+#if (OIS_LINUX_JOYFF_DEBUG > 0)
+	cout << "LinuxForceFeedback("<< mJoyStick << ") : Setting master gain to " 
+		 << value << " => " << event.value << endl;
+#endif
+
+	if (write(mJoyStick, &event, sizeof(event)) != sizeof(event)) {
+		OIS_EXCEPT(E_General, "Unknown error changing master gain.");
+	}
+}
+
+//--------------------------------------------------------------//
+void LinuxForceFeedback::setAutoCenterMode(bool enabled)
+{
+	if (!mSetAutoCenterSupport)
+	{
+#if (OIS_LINUX_JOYFF_DEBUG > 0)
+		cout << "LinuxForceFeedback("<< mJoyStick << ") : Setting auto-center mode " 
+			 << "is not supported by the device" << endl;
+#endif
+		return;
+	}
+
+	struct input_event event;
+
+	memset(&event, 0, sizeof(event));
+	event.type = EV_FF;
+	event.code = FF_AUTOCENTER;
+	event.value = (__s32)(enabled*0xFFFFFFFFUL);
+
+#if (OIS_LINUX_JOYFF_DEBUG > 0)
+	cout << "LinuxForceFeedback("<< mJoyStick << ") : Toggling auto-center to " 
+		 << enabled << " => 0x" << hex << event.value << dec << endl;
+#endif
+
+	if (write(mJoyStick, &event, sizeof(event)) != sizeof(event)) {
+		OIS_EXCEPT(E_General, "Unknown error toggling auto-center.");
+	}
+}
+
+//--------------------------------------------------------------//
+void LinuxForceFeedback::upload( const Effect* effect )
+{
+	switch( effect->force )
+	{
+		case OIS::Effect::ConstantForce: 
+			_updateConstantEffect(effect);	
+			break;
+		case OIS::Effect::ConditionalForce: 
+			_updateConditionalEffect(effect);
+			break;
+		case OIS::Effect::PeriodicForce: 
+			_updatePeriodicEffect(effect);
+			break;
+		case OIS::Effect::RampForce: 
+			_updateRampEffect(effect);	
+			break;
+		case OIS::Effect::CustomForce: 
+			//_updateCustomEffect(effect);
+			//break;
+		default: 
+			OIS_EXCEPT(E_NotImplemented, "Requested force not implemented yet, sorry!"); 
+			break;
+	}
+}
+
+//--------------------------------------------------------------//
+void LinuxForceFeedback::modify( const Effect* effect )
+{
+	upload(effect);
+}
+
+//--------------------------------------------------------------//
+void LinuxForceFeedback::remove( const Effect* effect )
+{
+	//Get the effect - if it exists
+	EffectList::iterator i = mEffectList.find(effect->_handle);
+	if( i != mEffectList.end() )
+	{
+		struct ff_effect *linEffect = i->second;
+		if( linEffect )
+		{
+			_stop(effect->_handle);
+
+			_unload(effect->_handle);
+
+			free(linEffect);
+
+			mEffectList.erase(i);
+		}
+		else
+			mEffectList.erase(i);
+	}
+}
+
+//--------------------------------------------------------------//
+// To Signed16/Unsigned15 safe conversions
+#define MaxUnsigned15Value 0x7FFF
+#define toUnsigned15(value) \
+	(__u16)((value) < 0 ? 0 : ((value) > MaxUnsigned15Value ? MaxUnsigned15Value : (value)))
+
+#define MaxSigned16Value  0x7FFF
+#define MinSigned16Value -0x7FFF
+#define toSigned16(value) \
+  (__s16)((value) < MinSigned16Value ? MinSigned16Value : ((value) > MaxSigned16Value ? MaxSigned16Value : (value)))
+
+// OIS to Linux duration
+#define LinuxInfiniteDuration 0xFFFF
+#define OISDurationUnitMS 1000 // OIS duration unit (microseconds), expressed in milliseconds (theLinux duration unit)
+
+// linux/input.h : All duration values are expressed in ms. Values above 32767 ms (0x7fff)
+//                 should not be used and have unspecified results.
+#define LinuxDuration(oisDuration) ((oisDuration) == Effect::OIS_INFINITE ? LinuxInfiniteDuration \
+									: toUnsigned15((oisDuration)/OISDurationUnitMS))
+
+
+// OIS to Linux levels
+#define OISMaxLevel 10000
+#define LinuxMaxLevel 0x7FFF
+
+// linux/input.h : Valid range for the attack and fade levels is 0x0000 - 0x7fff
+#define LinuxPositiveLevel(oisLevel) toUnsigned15(LinuxMaxLevel*(long)(oisLevel)/OISMaxLevel)
+
+#define LinuxSignedLevel(oisLevel) toSigned16(LinuxMaxLevel*(long)(oisLevel)/OISMaxLevel)
+
+
+//--------------------------------------------------------------//
+void LinuxForceFeedback::_setCommonProperties(struct ff_effect *event, 
+											  struct ff_envelope *ffenvelope, 
+											  const Effect* effect, const Envelope *envelope )
+{
+	memset(event, 0, sizeof(struct ff_effect));
+
+	if (envelope && ffenvelope && envelope->isUsed()) {
+		ffenvelope->attack_length = LinuxDuration(envelope->attackLength);
+		ffenvelope->attack_level = LinuxPositiveLevel(envelope->attackLevel);
+		ffenvelope->fade_length = LinuxDuration(envelope->fadeLength);
+		ffenvelope->fade_level = LinuxPositiveLevel(envelope->fadeLevel);
+	}
+	
+#if (OIS_LINUX_JOYFF_DEBUG > 1)
+	cout << endl;
+	if (envelope && ffenvelope)
+	{
+		cout << "  Enveloppe :" << endl
+			 << "    AttackLen : " << envelope->attackLength
+			 << " => " << ffenvelope->attack_length << endl 
+			 << "    AttackLvl : " << envelope->attackLevel
+			 << " => " << ffenvelope->attack_level << endl 
+			 << "    FadeLen   : " << envelope->fadeLength
+			 << " => " << ffenvelope->fade_length << endl
+			 << "    FadeLvl   : " << envelope->fadeLevel
+			 << " => " << ffenvelope->fade_level << endl;
+	}
+#endif
+	
+	event->direction = (__u16)(1 + (effect->direction*45.0+135.0)*0xFFFFUL/360.0);
+
+#if (OIS_LINUX_JOYFF_DEBUG > 1)
+	cout << "  Direction : " << Effect::getDirectionName(effect->direction)
+		 << " => 0x" << hex << event->direction << dec << endl;
+#endif
+
+	// TODO trigger_button 0 vs. -1
+	event->trigger.button = effect->trigger_button; // < 0 ? 0 : effect->trigger_button;
+	event->trigger.interval = LinuxDuration(effect->trigger_interval);
+
+#if (OIS_LINUX_JOYFF_DEBUG > 1)
+	cout << "  Trigger :" << endl
+		 << "    Button   : " << effect->trigger_button 
+		 << " => " << event->trigger.button << endl
+		 << "    Interval : " << effect->trigger_interval 
+		 << " => " << event->trigger.interval << endl;
+#endif
+
+	event->replay.length = LinuxDuration(effect->replay_length);
+	event->replay.delay = LinuxDuration(effect->replay_delay);
+
+#if (OIS_LINUX_JOYFF_DEBUG > 1)
+	cout << "  Replay :" << endl
+		 << "    Length : " << effect->replay_length 
+		 << " => " << event->replay.length << endl
+		 << "    Delay  : " << effect->replay_delay 
+		 << " => " << event->replay.delay << endl;
+#endif
+}
+
+//--------------------------------------------------------------//
+void LinuxForceFeedback::_updateConstantEffect( const Effect* eff )
+{
+	struct ff_effect event;
+
+	ConstantEffect *effect = static_cast<ConstantEffect*>(eff->getForceEffect());
+
+	_setCommonProperties(&event, &event.u.constant.envelope, eff, &effect->envelope);
+
+	event.type = FF_CONSTANT;
+	event.id = -1;
+
+	event.u.constant.level = LinuxSignedLevel(effect->level);
+
+#if (OIS_LINUX_JOYFF_DEBUG > 1)
+	cout << "  Level : " << effect->level
+		 << " => " << event.u.constant.level << endl;
+#endif
+
+	_upload(&event, eff);
+}
+
+//--------------------------------------------------------------//
+void LinuxForceFeedback::_updateRampEffect( const Effect* eff )
+{
+	struct ff_effect event;
+
+	RampEffect *effect = static_cast<RampEffect*>(eff->getForceEffect());
+
+	_setCommonProperties(&event, &event.u.constant.envelope, eff, &effect->envelope);
+
+	event.type = FF_RAMP;
+	event.id = -1;
+
+	event.u.ramp.start_level = LinuxSignedLevel(effect->startLevel);
+	event.u.ramp.end_level = LinuxSignedLevel(effect->endLevel);
+
+#if (OIS_LINUX_JOYFF_DEBUG > 1)
+	cout << "  StartLevel : " << effect->startLevel
+		 << " => " << event.u.ramp.start_level << endl
+		 << "  EndLevel   : " << effect->endLevel
+		 << " => " << event.u.ramp.end_level << endl;
+#endif
+
+	_upload(&event, eff);
+}
+
+//--------------------------------------------------------------//
+void LinuxForceFeedback::_updatePeriodicEffect( const Effect* eff )
+{
+	struct ff_effect event;
+
+	PeriodicEffect *effect = static_cast<PeriodicEffect*>(eff->getForceEffect());
+
+	_setCommonProperties(&event, &event.u.periodic.envelope, eff, &effect->envelope);
+
+	event.type = FF_PERIODIC;
+	event.id = -1;
+
+	switch( eff->type )
+	{
+		case OIS::Effect::Square:
+			event.u.periodic.waveform = FF_SQUARE;
+			break;
+		case OIS::Effect::Triangle:
+			event.u.periodic.waveform = FF_TRIANGLE;
+			break;
+		case OIS::Effect::Sine:
+			event.u.periodic.waveform = FF_SINE;
+			break;
+		case OIS::Effect::SawToothUp:
+			event.u.periodic.waveform = FF_SAW_UP;
+			break;
+		case OIS::Effect::SawToothDown:
+			event.u.periodic.waveform = FF_SAW_DOWN;
+			break;
+		// Note: No support for Custom periodic force effect for the moment
+		//case OIS::Effect::Custom:
+			//event.u.periodic.waveform = FF_CUSTOM;
+			//break;
+		default:
+			OIS_EXCEPT(E_General, "No such available effect for Periodic force!"); 
+			break;
+	}
+
+	event.u.periodic.period    = LinuxDuration(effect->period);
+	event.u.periodic.magnitude = LinuxPositiveLevel(effect->magnitude);
+	event.u.periodic.offset    = LinuxPositiveLevel(effect->offset);
+	event.u.periodic.phase     = (__u16)(effect->phase*event.u.periodic.period/36000.0); // ?????
+
+	// Note: No support for Custom periodic force effect for the moment
+	event.u.periodic.custom_len = 0;
+	event.u.periodic.custom_data = 0;
+
+#if (OIS_LINUX_JOYFF_DEBUG > 1)
+	cout << "  Magnitude : " << effect->magnitude
+		 << " => " << event.u.periodic.magnitude << endl
+		 << "  Period    : " << effect->period
+		 << " => " << event.u.periodic.period  << endl
+		 << "  Offset    : " << effect->offset
+		 << " => " << event.u.periodic.offset << endl
+		 << "  Phase     : " << effect->phase
+		 << " => " << event.u.periodic.phase << endl;
+#endif
+
+	_upload(&event, eff);
+}
+
+//--------------------------------------------------------------//
+void LinuxForceFeedback::_updateConditionalEffect( const Effect* eff )
+{
+	struct ff_effect event;
+
+	ConditionalEffect *effect = static_cast<ConditionalEffect*>(eff->getForceEffect());
+
+	_setCommonProperties(&event, NULL, eff, NULL);
+
+	switch( eff->type )
+	{
+		case OIS::Effect::Friction:
+			event.type = FF_FRICTION; 
+			break;
+		case OIS::Effect::Damper:
+			event.type = FF_DAMPER; 
+			break;
+		case OIS::Effect::Inertia:
+			event.type = FF_INERTIA; 
+			break;
+		case OIS::Effect::Spring:
+			event.type = FF_SPRING;
+			break;
+		default:
+			OIS_EXCEPT(E_General, "No such available effect for Conditional force!"); 
+			break;
+	}
+
+	event.id = -1;
+
+	event.u.condition[0].right_saturation = LinuxSignedLevel(effect->rightSaturation);
+	event.u.condition[0].left_saturation  = LinuxSignedLevel(effect->leftSaturation);
+	event.u.condition[0].right_coeff      = LinuxSignedLevel(effect->rightCoeff);
+	event.u.condition[0].left_coeff       = LinuxSignedLevel(effect->leftCoeff);
+	event.u.condition[0].deadband         = LinuxPositiveLevel(effect->deadband);// Unit ?? 
+	event.u.condition[0].center           = LinuxSignedLevel(effect->center); // Unit ?? TODO ?
+
+	// TODO support for second condition
+	event.u.condition[1] = event.u.condition[0];
+
+#if (OIS_LINUX_JOYFF_DEBUG > 1)
+	cout << "  Condition[0] : " << endl
+		 << "    RightSaturation  : " << effect->rightSaturation
+		 << " => " << event.u.condition[0].right_saturation << endl
+		 << "    LeftSaturation   : " << effect->leftSaturation
+		 << " => " << event.u.condition[0]. left_saturation << endl
+		 << "    RightCoefficient : " << effect->rightCoeff
+		 << " => " << event.u.condition[0].right_coeff << endl
+		 << "    LeftCoefficient : " << effect->leftCoeff
+		 << " => " << event.u.condition[0].left_coeff << endl
+		 << "    DeadBand        : " << effect->deadband
+		 << " => " << event.u.condition[0].deadband  << endl
+		 << "    Center          : " << effect->center
+		 << " => " << event.u.condition[0].center << endl;
+	cout << "  Condition[1] : Not implemented" << endl;
+#endif
+	_upload(&event, eff);
+}
+
+//--------------------------------------------------------------//
+void LinuxForceFeedback::_upload( struct ff_effect* ffeffect, const Effect* effect)
+{
+	struct ff_effect *linEffect = 0;
+
+	//Get the effect - if it exists
+	EffectList::iterator i = mEffectList.find(effect->_handle);
+	//It has been created already
+	if( i != mEffectList.end() )
+		linEffect = i->second;
+
+	if( linEffect == 0 )
+	{
+#if (OIS_LINUX_JOYFF_DEBUG > 1)
+		cout << endl << "LinuxForceFeedback("<< mJoyStick << ") : Adding new effect : " 
+			 << Effect::getEffectTypeName(effect->type) << endl;
+#endif
+
+		//This effect has not yet been created, so create it in the device
+		if (ioctl(mJoyStick, EVIOCSFF, ffeffect) == -1) {
+			// TODO device full check
+			// OIS_EXCEPT(E_DeviceFull, "Remove an effect before adding more!");
+			OIS_EXCEPT(E_General, "Unknown error creating effect (may be the device is full)->..");
+		}
+
+		// Save returned effect handle
+		effect->_handle = ffeffect->id;
+
+		// Save a copy of the uploaded effect for later simple modifications
+		linEffect = (struct ff_effect *)calloc(1, sizeof(struct ff_effect));
+		memcpy(linEffect, ffeffect, sizeof(struct ff_effect));
+
+		mEffectList[effect->_handle] = linEffect;
+
+		// Start playing the effect.
+		_start(effect->_handle);
+	}
+	else
+	{
+#if (OIS_LINUX_JOYFF_DEBUG > 1)
+		cout << endl << "LinuxForceFeedback("<< mJoyStick << ") : Replacing effect : " 
+			 << Effect::getEffectTypeName(effect->type) << endl;
+#endif
+
+		// Keep same id/handle, as this is just an update in the device.
+		ffeffect->id = effect->_handle;
+
+		// Update effect in the device.
+		if (ioctl(mJoyStick, EVIOCSFF, ffeffect) == -1) {
+			OIS_EXCEPT(E_General, "Unknown error updating an effect->..");
+		}
+
+		// Update local linEffect for next time.
+		memcpy(linEffect, ffeffect, sizeof(struct ff_effect));
+	}
+
+#if (OIS_LINUX_JOYFF_DEBUG > 1)
+	cout << "LinuxForceFeedback("<< mJoyStick 
+		 << ") : Effect handle : " << effect->_handle << endl;
+#endif
+}
+
+//--------------------------------------------------------------//
+void LinuxForceFeedback::_stop( int handle) {
+	struct input_event stop;
+
+	stop.type = EV_FF;
+	stop.code = handle;
+	stop.value = 0;
+
+#if (OIS_LINUX_JOYFF_DEBUG > 1)
+	cout << endl << "LinuxForceFeedback("<< mJoyStick 
+		 << ") : Stopping effect with handle " << handle << endl;
+#endif
+
+	if (write(mJoyStick, &stop, sizeof(stop)) != sizeof(stop)) {
+		OIS_EXCEPT(E_General, "Unknown error stopping effect->..");
+	}
+}
+
+//--------------------------------------------------------------//
+void LinuxForceFeedback::_start( int handle) {
+	struct input_event play;
+
+	play.type = EV_FF;
+	play.code = handle;
+	play.value = 1; // Play once.
+
+#if (OIS_LINUX_JOYFF_DEBUG > 1)
+	cout << endl << "LinuxForceFeedback("<< mJoyStick 
+		 << ") : Starting effect with handle " << handle << endl;
+#endif
+
+	if (write(mJoyStick, &play, sizeof(play)) != sizeof(play)) {
+		OIS_EXCEPT(E_General, "Unknown error playing effect->..");
+	}
+}
+
+//--------------------------------------------------------------//
+void LinuxForceFeedback::_unload( int handle)
+{
+#if (OIS_LINUX_JOYFF_DEBUG > 1)
+	cout << endl << "LinuxForceFeedback("<< mJoyStick 
+		 << ") : Removing effect with handle " << handle << endl;
+#endif
+
+	if (ioctl(mJoyStick, EVIOCRMFF, handle) == -1) {
+		OIS_EXCEPT(E_General, "Unknown error removing effect->..");
+	}
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/linux/LinuxInputManager.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/linux/LinuxInputManager.cpp
new file mode 100644
index 0000000..20489e6
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/linux/LinuxInputManager.cpp
@@ -0,0 +1,220 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "linux/LinuxInputManager.h"
+#include "linux/LinuxKeyboard.h"
+#include "linux/LinuxJoyStickEvents.h"
+#include "linux/LinuxMouse.h"
+#include "OISException.h"
+#include <cstdlib>
+#include <stdio.h>
+
+using namespace OIS;
+
+//--------------------------------------------------------------------------------//
+LinuxInputManager::LinuxInputManager() : InputManager("X11InputManager")
+{
+	window = 0;
+
+	//Default settings
+	grabMouse = true;
+	grabKeyboard = true;
+	hideMouse = true;
+	mGrabs = true;
+	keyboardUsed = mouseUsed = false;
+
+	//Setup our internal factories
+	mFactories.push_back(this);
+}
+
+//--------------------------------------------------------------------------------//
+LinuxInputManager::~LinuxInputManager()
+{
+	//Close all joysticks
+	LinuxJoyStick::_clearJoys(unusedJoyStickList);
+}
+
+//--------------------------------------------------------------------------------//
+void LinuxInputManager::_initialize( ParamList &paramList )
+{
+	_parseConfigSettings( paramList );
+
+	//Enumerate all devices attached
+	_enumerateDevices();
+}
+
+//--------------------------------------------------------------------------------//
+void LinuxInputManager::_parseConfigSettings( ParamList &paramList )
+{
+	ParamList::iterator i = paramList.find("WINDOW");
+	if( i == paramList.end() ) 
+		{
+			printf("OIS: No Window specified... Not using x11 keyboard/mouse\n");
+			return;
+		}
+
+		window = strtoull(i->second.c_str(), 0, 10);
+
+	//--------- Keyboard Settings ------------//
+	i = paramList.find("x11_keyboard_grab");
+	if( i != paramList.end() )
+		if( i->second == "false" )
+			grabKeyboard = false;
+
+	//--------- Mouse Settings ------------//
+	i = paramList.find("x11_mouse_grab");
+	if( i != paramList.end() )
+		if( i->second == "false" )
+			grabMouse = false;
+
+	i = paramList.find("x11_mouse_hide");
+	if( i != paramList.end() )
+		if( i->second == "false" )
+			hideMouse = false;
+}
+
+//--------------------------------------------------------------------------------//
+void LinuxInputManager::_enumerateDevices()
+{
+	//Enumerate all attached devices
+	unusedJoyStickList = LinuxJoyStick::_scanJoys();
+	joySticks = unusedJoyStickList.size();
+}
+
+//----------------------------------------------------------------------------//
+DeviceList LinuxInputManager::freeDeviceList()
+{
+	DeviceList ret;
+
+	if(window)
+	{
+		if(keyboardUsed == false)
+			ret.insert(std::make_pair(OISKeyboard, mInputSystemName));
+
+		if(mouseUsed == false)
+			ret.insert(std::make_pair(OISMouse, mInputSystemName));
+	}
+
+	for(JoyStickInfoList::iterator i = unusedJoyStickList.begin(); i != unusedJoyStickList.end(); ++i)
+		ret.insert(std::make_pair(OISJoyStick, i->vendor));
+
+	return ret;
+}
+
+//----------------------------------------------------------------------------//
+int LinuxInputManager::totalDevices(Type iType)
+{
+	switch(iType)
+	{
+	case OISKeyboard: return window ? 1 : 0;
+	case OISMouse: return window ? 1 : 0;
+	case OISJoyStick: return joySticks;
+	default: return 0;
+	}
+}
+
+//----------------------------------------------------------------------------//
+int LinuxInputManager::freeDevices(Type iType)
+{
+	switch(iType)
+	{
+	case OISKeyboard: return window ? (keyboardUsed ? 0 : 1) : 0;
+	case OISMouse: return window ? (mouseUsed ? 0 : 1) : 0;
+	case OISJoyStick: return (int)unusedJoyStickList.size();
+	default: return 0;
+	}
+}
+
+//----------------------------------------------------------------------------//
+bool LinuxInputManager::vendorExist(Type iType, const std::string & vendor)
+{
+	if((iType == OISKeyboard || iType == OISMouse) && vendor == mInputSystemName)
+	{
+		return window ? true : false;
+	}
+	else if( iType == OISJoyStick )
+	{
+		for(JoyStickInfoList::iterator i = unusedJoyStickList.begin(); i != unusedJoyStickList.end(); ++i)
+			if(i->vendor == vendor)
+				return true;
+	}
+
+	return false;
+}
+
+//----------------------------------------------------------------------------//
+Object* LinuxInputManager::createObject(InputManager *creator, Type iType, bool bufferMode, const std::string & vendor)
+{
+	Object *obj = 0;
+
+	switch(iType)
+	{
+	case OISKeyboard:
+	{
+		if(window && keyboardUsed == false)
+			obj = new LinuxKeyboard(this, bufferMode, grabKeyboard);
+
+		break;
+	}
+	case OISMouse:
+	{
+		if(window && mouseUsed == false)
+			obj = new LinuxMouse(this, bufferMode, grabMouse, hideMouse);
+
+		break;
+	}
+	case OISJoyStick:
+	{
+		for(JoyStickInfoList::iterator i = unusedJoyStickList.begin(); i != unusedJoyStickList.end(); ++i)
+		{
+			if(vendor == "" || i->vendor == vendor)
+			{
+				obj = new LinuxJoyStick(this, bufferMode, *i);
+				unusedJoyStickList.erase(i);
+				break;
+			}
+		}
+		break;
+	}
+	default:
+		break;
+	}
+
+	if(obj == 0)
+		OIS_EXCEPT(E_InputDeviceNonExistant, "No devices match requested type.");
+
+	return obj;
+}
+
+//----------------------------------------------------------------------------//
+void LinuxInputManager::destroyObject( Object* obj )
+{
+	if(obj)
+	{
+		if(obj->type() == OISJoyStick)
+		{
+			unusedJoyStickList.push_back( ((LinuxJoyStick*)obj)->_getJoyInfo() );
+		}
+
+		delete obj;
+	}
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/linux/LinuxJoyStickEvents.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/linux/LinuxJoyStickEvents.cpp
new file mode 100644
index 0000000..a32142d
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/linux/LinuxJoyStickEvents.cpp
@@ -0,0 +1,305 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that
+		you wrote the original software. If you use this software in a product,
+		an acknowledgment in the product documentation would be appreciated but is
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "OISConfig.h"
+
+#include "linux/LinuxJoyStickEvents.h"
+#include "linux/LinuxInputManager.h"
+#include "linux/LinuxForceFeedback.h"
+#include "linux/EventHelpers.h"
+
+#include "OISEvents.h"
+#include "OISException.h"
+
+#include <fcntl.h>        //Needed to Open a file descriptor
+#include <cassert>	
+#include <linux/input.h>
+
+
+#include <sstream>
+# include <iostream>
+using namespace std;
+
+using namespace OIS;
+
+//#define OIS_LINUX_JOY_DEBUG
+
+//-------------------------------------------------------------------//
+LinuxJoyStick::LinuxJoyStick(InputManager* creator, bool buffered, const JoyStickInfo& js)
+	: JoyStick(js.vendor, buffered, js.devId, creator)
+{
+	mJoyStick = js.joyFileD;
+
+	mState.mAxes.clear();
+	mState.mAxes.resize(js.axes);
+	mState.mButtons.clear();
+	mState.mButtons.resize(js.buttons);
+
+	mPOVs = js.hats;
+
+	mButtonMap = js.button_map;
+	mAxisMap = js.axis_map;
+	mRanges = js.axis_range;
+
+	ff_effect = 0;
+}
+
+//-------------------------------------------------------------------//
+LinuxJoyStick::~LinuxJoyStick()
+{
+	EventUtils::removeForceFeedback( &ff_effect );
+}
+
+//-------------------------------------------------------------------//
+void LinuxJoyStick::_initialize()
+{
+	//Clear old joy state
+	mState.mAxes.resize(mAxisMap.size());
+	mState.clear();
+
+	//This will create and new us a force feedback structure if it exists
+	EventUtils::enumerateForceFeedback( mJoyStick, &ff_effect );
+
+	if( mJoyStick == -1 )
+		OIS_EXCEPT(E_InputDeviceNonExistant, "LinuxJoyStick::_initialize() >> JoyStick Not Found!");
+}
+
+//-------------------------------------------------------------------//
+void LinuxJoyStick::capture()
+{
+	static const short POV_MASK[8] = {0,0,1,1,2,2,3,3};
+
+	//Used to determine if an axis has been changed and needs an event
+	bool axisMoved[32] = {false, false, false, false, false, false, false, false, false, false, false, false, false,
+						  false, false, false, false, false, false, false, false, false, false, false, false, false,
+						  false, false, false, false, false, false};
+
+	//We are in non blocking mode - we just read once, and try to fill up buffer
+	input_event js[JOY_BUFFERSIZE];
+	while(true)
+	{
+		int ret = read(mJoyStick, &js, sizeof(struct input_event) * JOY_BUFFERSIZE);
+        if( ret < 0 )
+			break;
+
+		//Determine how many whole events re read up
+		ret /= sizeof(struct input_event);
+		for(int i = 0; i < ret; ++i)
+		{
+			switch(js[i].type)
+			{
+			case EV_KEY:  //Button
+			{
+				int button = mButtonMap[js[i].code];
+
+				#ifdef OIS_LINUX_JOY_DEBUG
+				  cout << "\nButton Code: " << js[i].code << ", OIS Value: " << button << endl;
+				#endif
+
+				//Check to see whether push or released event...
+				if(js[i].value)
+				{
+					mState.mButtons[button] = true;
+					if( mBuffered && mListener )
+						if(!mListener->buttonPressed(JoyStickEvent(this,mState), button)) return;
+				}
+				else
+				{
+					mState.mButtons[button] = false;
+					if( mBuffered && mListener )
+						if(!mListener->buttonReleased(JoyStickEvent(this,mState), button)) return;
+				}
+				break;
+			}
+
+			case EV_ABS:  //Absolute Axis
+			{
+				//A Stick (BrakeDefine is the highest possible Axis)
+				if( js[i].code <= ABS_BRAKE )
+				{
+					int axis = mAxisMap[js[i].code];
+					assert( axis < 32 && "Too many axes (Max supported is 32). Report this to OIS forums!" );
+
+					axisMoved[axis] = true;
+
+					//check for rescaling:
+					if( mRanges[axis].min == JoyStick::MIN_AXIS && mRanges[axis].max != JoyStick::MAX_AXIS )
+					{	//Scale is perfect
+						mState.mAxes[axis].abs = js[i].value;
+					}
+					else
+					{	//Rescale
+						float proportion = (float)(js[i].value-mRanges[axis].max)/(float)(mRanges[axis].min-mRanges[axis].max);
+						mState.mAxes[axis].abs = (int)(32767.0f - (65535.0f * proportion));
+					}
+				}
+				else if( js[i].code <= ABS_HAT3Y ) //A POV - Max four POVs allowed
+				{
+					//Normalise the POV to between 0-7
+					//Even is X Axis, Odd is Y Axis
+					unsigned char LinuxPovNumber = js[i].code - 16;
+					short OIS_POVIndex = POV_MASK[LinuxPovNumber];
+
+					//Handle X Axis first (Even) (left right)
+					if((LinuxPovNumber & 0x0001) == 0)
+					{
+						//Why do this? Because, we use a bit field, and when this axis is east,
+						//it can't possibly be west too. So clear out the two X axes, then refil
+						//it in with the new direction bit.
+						//Clear the East/West Bit Flags first
+						mState.mPOV[OIS_POVIndex].direction &= 0x11110011;
+						if( js[i].value == -1 )	//Left
+							mState.mPOV[OIS_POVIndex].direction |= Pov::West;
+						else if( js[i].value == 1 ) //Right
+							mState.mPOV[OIS_POVIndex].direction |= Pov::East;
+					}
+					//Handle Y Axis (Odd) (up down)
+					else
+					{
+						//Clear the North/South Bit Flags first
+						mState.mPOV[OIS_POVIndex].direction &= 0x11111100;
+						if( js[i].value == -1 )	//Up
+							mState.mPOV[OIS_POVIndex].direction |= Pov::North;
+						else if( js[i].value == 1 ) //Down
+							mState.mPOV[OIS_POVIndex].direction |= Pov::South;
+					}
+
+					if( mBuffered && mListener )
+						if( mListener->povMoved( JoyStickEvent(this,mState), OIS_POVIndex) == false )
+							return;
+				}
+				break;
+			}
+
+			
+			case EV_REL: //Relative Axes (Do any joystick actually have a relative axis?)
+	#ifdef OIS_LINUX_JOY_DEBUG
+				cout << "\nWarning: Relatives axes not supported yet" << endl;
+	#endif
+				break;
+			default: break;
+			}
+		}
+	}
+
+	//All axes and POVs are combined into one movement per pair per captured frame
+	if( mBuffered && mListener )
+	{
+		for( int i = 0; i < 32; ++i )
+			if( axisMoved[i] )
+				if( mListener->axisMoved( JoyStickEvent(this,mState), i) == false )
+					return;
+	}
+}
+
+//-------------------------------------------------------------------//
+void LinuxJoyStick::setBuffered(bool buffered)
+{
+	if( buffered != mBuffered )
+	{
+		mBuffered = buffered;
+		_initialize();
+	}
+}
+
+//-------------------------------------------------------------------//
+JoyStickInfo LinuxJoyStick::_getJoyInfo()
+{
+	JoyStickInfo js;
+
+	js.devId = mDevID;
+	js.joyFileD = mJoyStick;
+	js.vendor = mVendor;
+	js.axes = (int)mState.mAxes.size();
+	js.buttons = (int)mState.mButtons.size();
+	js.hats = mPOVs;
+	js.button_map = mButtonMap;
+	js.axis_map = mAxisMap;
+	js.axis_range = mRanges;
+
+	return js;
+}
+
+//-------------------------------------------------------------------//
+JoyStickInfoList LinuxJoyStick::_scanJoys()
+{
+	JoyStickInfoList joys;
+
+	//Search through all of the event devices.. and identify which ones are joysticks
+	//xxx move this to InputManager, as it can also scan all other events
+	for(int i = 0; i < 64; ++i )
+	{
+		stringstream s;
+		s << "/dev/input/event" << i;
+		int fd = open( s.str().c_str(), O_RDWR |O_NONBLOCK );
+		if(fd == -1)
+			continue;
+
+        #ifdef OIS_LINUX_JOY_DEBUG
+		  cout << "Opening " << s.str() << "..." << endl;
+        #endif
+		try
+		{
+			JoyStickInfo js;
+			if( EventUtils::isJoyStick(fd, js) )
+			{
+				joys.push_back(js);
+                #ifdef OIS_LINUX_JOY_DEBUG
+                  cout << "=> Joystick added to list." << endl;
+                #endif
+			}
+			else
+			{
+                #ifdef OIS_LINUX_JOY_DEBUG
+                  cout << "=> Not a joystick." << endl;
+                #endif
+				close(fd);
+			}
+		}
+		catch(...)
+		{
+            #ifdef OIS_LINUX_JOY_DEBUG
+              cout << "Exception caught!!" << endl;
+            #endif
+			close(fd);
+		}
+	}
+
+	return joys;
+}
+
+//-------------------------------------------------------------------//
+void LinuxJoyStick::_clearJoys(JoyStickInfoList &joys)
+{
+	for(JoyStickInfoList::iterator i = joys.begin(); i != joys.end(); ++i)
+		close(i->joyFileD);
+	joys.clear();
+}
+
+//-------------------------------------------------------------------//
+Interface* LinuxJoyStick::queryInterface(Interface::IType type)
+{
+	if( ff_effect && type == Interface::ForceFeedback )
+		return ff_effect;
+
+	return 0;
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/linux/LinuxKeyboard.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/linux/LinuxKeyboard.cpp
new file mode 100644
index 0000000..1c35f5e
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/linux/LinuxKeyboard.cpp
@@ -0,0 +1,429 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that
+		you wrote the original software. If you use this software in a product,
+		an acknowledgment in the product documentation would be appreciated but is
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "linux/LinuxInputManager.h"
+#include "linux/LinuxKeyboard.h"
+#include "OISException.h"
+#include "OISEvents.h"
+
+#include <X11/keysym.h>
+#include <X11/Xutil.h>
+#include <cstring>
+
+using namespace OIS;
+#include <iostream>
+//-------------------------------------------------------------------//
+LinuxKeyboard::LinuxKeyboard(InputManager* creator, bool buffered, bool grab)
+	: Keyboard(creator->inputSystemName(), buffered, 0, creator)
+{
+	setlocale(LC_CTYPE, ""); //Set the locale to (hopefully) the users LANG UTF-8 Env var
+
+	display = 0;
+	window = 0;
+
+	grabKeyboard = grab;
+	keyFocusLost = false;
+
+	//X Key Map to KeyCode
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_1, KC_1));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_2, KC_2));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_3, KC_3));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_4, KC_4));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_5, KC_5));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_6, KC_6));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_7, KC_7));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_8, KC_8));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_9, KC_9));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_0, KC_0));
+
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_BackSpace, KC_BACK));
+
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_minus, KC_MINUS));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_equal, KC_EQUALS));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_space, KC_SPACE));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_comma, KC_COMMA));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_period, KC_PERIOD));
+
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_backslash, KC_BACKSLASH));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_slash, KC_SLASH));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_bracketleft, KC_LBRACKET));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_bracketright, KC_RBRACKET));
+
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Escape,KC_ESCAPE));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Caps_Lock, KC_CAPITAL));
+
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Tab, KC_TAB));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Return, KC_RETURN));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Control_L, KC_LCONTROL));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Control_R, KC_RCONTROL));
+
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_colon, KC_COLON));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_semicolon, KC_SEMICOLON));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_apostrophe, KC_APOSTROPHE));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_grave, KC_GRAVE));
+
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_b, KC_B));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_a, KC_A));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_c, KC_C));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_d, KC_D));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_e, KC_E));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_f, KC_F));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_g, KC_G));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_h, KC_H));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_i, KC_I));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_j, KC_J));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_k, KC_K));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_l, KC_L));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_m, KC_M));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_n, KC_N));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_o, KC_O));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_p, KC_P));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_q, KC_Q));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_r, KC_R));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_s, KC_S));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_t, KC_T));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_u, KC_U));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_v, KC_V));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_w, KC_W));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_x, KC_X));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_y, KC_Y));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_z, KC_Z));
+
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_F1, KC_F1));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_F2, KC_F2));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_F3, KC_F3));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_F4, KC_F4));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_F5, KC_F5));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_F6, KC_F6));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_F7, KC_F7));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_F8, KC_F8));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_F9, KC_F9));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_F10, KC_F10));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_F11, KC_F11));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_F12, KC_F12));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_F13, KC_F13));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_F14, KC_F14));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_F15, KC_F15));
+
+	//Keypad
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_0, KC_NUMPAD0));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_1, KC_NUMPAD1));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_2, KC_NUMPAD2));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_3, KC_NUMPAD3));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_4, KC_NUMPAD4));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_5, KC_NUMPAD5));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_6, KC_NUMPAD6));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_7, KC_NUMPAD7));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_8, KC_NUMPAD8));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_9, KC_NUMPAD9));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_Add, KC_ADD));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_Subtract, KC_SUBTRACT));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_Decimal, KC_DECIMAL));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_Equal, KC_NUMPADEQUALS));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_Divide, KC_DIVIDE));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_Multiply, KC_MULTIPLY));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_Enter, KC_NUMPADENTER));
+
+	//Keypad with numlock off
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_Home, KC_NUMPAD7));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_Up, KC_NUMPAD8));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_Page_Up, KC_NUMPAD9));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_Left, KC_NUMPAD4));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_Begin, KC_NUMPAD5));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_Right, KC_NUMPAD6));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_End, KC_NUMPAD1));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_Down, KC_NUMPAD2));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_Page_Down, KC_NUMPAD3));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_Insert, KC_NUMPAD0));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_KP_Delete, KC_DECIMAL));
+
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Up, KC_UP));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Down, KC_DOWN));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Left, KC_LEFT));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Right, KC_RIGHT));
+
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Page_Up, KC_PGUP));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Page_Down, KC_PGDOWN));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Home, KC_HOME));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_End, KC_END));
+
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Num_Lock, KC_NUMLOCK));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Print, KC_SYSRQ));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Scroll_Lock, KC_SCROLL));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Pause, KC_PAUSE));
+
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Shift_R, KC_RSHIFT));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Shift_L, KC_LSHIFT));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Alt_R, KC_RMENU));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Alt_L, KC_LMENU));
+
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Insert, KC_INSERT));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Delete, KC_DELETE));
+
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Super_L, KC_LWIN));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Super_R, KC_RWIN));
+	keyConversion.insert(XtoOIS_KeyMap::value_type(XK_Menu, KC_APPS));
+
+	static_cast<LinuxInputManager*>(mCreator)->_setKeyboardUsed(true);
+}
+
+//-------------------------------------------------------------------//
+void LinuxKeyboard::_initialize()
+{
+	//Clear our keyboard state buffer
+	memset( &KeyBuffer, 0, 256 );
+	mModifiers = 0;
+
+	if( display ) XCloseDisplay(display);
+	display = 0;
+	window = static_cast<LinuxInputManager*>(mCreator)->_getWindow();
+
+	//Create our local X mListener connection
+	if( !(display = XOpenDisplay(0)) )
+		OIS_EXCEPT(E_General, "LinuxKeyboard::_initialize >> Error opening X!");
+
+	//Set it to recieve Input events
+	if( XSelectInput(display, window, KeyPressMask | KeyReleaseMask) == BadWindow )
+		OIS_EXCEPT(E_General, "LinuxKeyboard::_initialize: X error!");
+
+	if( grabKeyboard )
+		XGrabKeyboard(display,window,True,GrabModeAsync,GrabModeAsync,CurrentTime);
+
+	keyFocusLost = false;
+}
+
+//-------------------------------------------------------------------//
+LinuxKeyboard::~LinuxKeyboard()
+{
+	if( display )
+	{
+		if( grabKeyboard )
+			XUngrabKeyboard(display, CurrentTime);
+
+		XCloseDisplay(display);
+	}
+
+	static_cast<LinuxInputManager*>(mCreator)->_setKeyboardUsed(true);
+}
+
+//-------------------------------------------------------------------//
+unsigned int UTF8ToUTF32(unsigned char* buf)
+{
+	unsigned char &FirstChar = buf[0];
+
+	if(FirstChar < 128)
+		return FirstChar;
+
+	unsigned int val = 0;
+	unsigned int len = 0;
+
+	if((FirstChar & 0xE0) == 0xC0) //2 Chars
+	{
+		len = 2;
+		val = FirstChar & 0x1F;
+	}
+	else if((FirstChar & 0xF0) == 0xE0) //3 Chars
+	{
+		len = 3;
+		val = FirstChar & 0x0F;
+	}
+	else if((FirstChar & 0xF8) == 0xF0) //4 Chars
+	{
+		len = 4;
+		val = FirstChar & 0x07;
+	}
+	else if((FirstChar & 0xFC) == 0xF8) //5 Chars
+	{
+		len = 5;
+		val = FirstChar & 0x03;
+	}
+	else // if((FirstChar & 0xFE) == 0xFC) //6 Chars
+	{
+		len = 6;
+		val = FirstChar & 0x01;
+	}
+
+	for(int i = 1; i < len; i++)
+		val = (val << 6) | (buf[i] & 0x3F);
+
+	return val;
+}
+
+//-------------------------------------------------------------------//
+bool LinuxKeyboard::isKeyDown( KeyCode key ) const
+{
+	return (KeyBuffer[key]);
+}
+
+//-------------------------------------------------------------------//
+void LinuxKeyboard::capture()
+{
+	KeySym key;
+	XEvent event;
+	LinuxInputManager* linMan = static_cast<LinuxInputManager*>(mCreator);
+
+	while( XPending(display) > 0 )
+	{
+		XNextEvent(display, &event);
+		if(KeyPress == event.type)
+		{
+			unsigned int character = 0;
+
+			if(mTextMode != Off)
+			{
+				unsigned char buffer[6] = {0,0,0,0,0,0};
+				XLookupString(&event.xkey, (char*)buffer, 6, &key, 0);
+
+				if( mTextMode == Unicode )
+					character = UTF8ToUTF32(buffer);
+				else if( mTextMode == Ascii)
+					character = buffer[0];
+			}
+
+			//Mask out the modifier states X11 sets and read again
+			event.xkey.state &= ~ShiftMask;
+			event.xkey.state &= ~LockMask;
+			XLookupString(&event.xkey, 0, 0,&key, 0);
+
+			_injectKeyDown(key, character);
+
+			//Just printing out some debugging info.. to verify all chars are mapped
+			//std::cout << "KEY PRESSED X=" << event.xkey.keycode;
+			//std::cout << "\n KeySym=" << key << std::endl;
+
+			//Check for Alt-Tab
+			if( event.xkey.state & Mod1Mask && key == XK_Tab )
+				linMan->_setGrabState(false);
+		}
+		else if(KeyRelease == event.type)
+		{
+			if(!_isKeyRepeat(event))
+			{
+				//Mask out the modifier states X sets.. or we will get improper values
+				event.xkey.state &= ~ShiftMask;
+				event.xkey.state &= ~LockMask;
+
+				XLookupString(&event.xkey,NULL,0,&key,NULL);
+				_injectKeyUp(key);			}
+		}
+	}
+
+	//If grabbing mode is on.. Handle focus lost/gained via Alt-Tab and mouse clicks
+	if( grabKeyboard )
+	{
+		if( linMan->_getGrabState() == false )
+		{
+			// are no longer grabbing
+			if( keyFocusLost == false )
+			{
+				//UnGrab KeyBoard
+				XUngrabKeyboard(display, CurrentTime);
+				keyFocusLost = true;
+			}
+		}
+		else
+		{
+			//We are grabbing - and regained focus
+			if( keyFocusLost == true )
+			{
+				//ReGrab KeyBoard
+				XGrabKeyboard(display, window, True, GrabModeAsync, GrabModeAsync, CurrentTime);
+				keyFocusLost = false;
+			}
+		}
+	}
+}
+
+//-------------------------------------------------------------------//
+void LinuxKeyboard::setBuffered(bool buffered)
+{
+	mBuffered = buffered;
+}
+
+//-------------------------------------------------------------------//
+bool LinuxKeyboard::_injectKeyDown( KeySym key, int text )
+{
+	KeyCode kc = keyConversion[key];
+	KeyBuffer[kc] = 1;
+
+	//Turn on modifier flags
+	if( kc == KC_LCONTROL || kc == KC_RCONTROL)
+		mModifiers |= Ctrl;
+	else if( kc == KC_LSHIFT || kc == KC_RSHIFT )
+		mModifiers |= Shift;
+	else if( kc == KC_LMENU || kc == KC_RMENU )
+		mModifiers |= Alt;
+
+	if( mBuffered && mListener )
+		return mListener->keyPressed(KeyEvent(this,kc,text));
+
+	return true;
+}
+
+//-------------------------------------------------------------------//
+bool LinuxKeyboard::_injectKeyUp( KeySym key )
+{
+	KeyCode kc = keyConversion[key];
+	KeyBuffer[kc] = 0;
+
+	//Turn off modifier flags
+	if( kc == KC_LCONTROL || kc == KC_RCONTROL)
+		mModifiers &= ~Ctrl;
+	else if( kc == KC_LSHIFT || kc == KC_RSHIFT )
+		mModifiers &= ~Shift;
+	else if( kc == KC_LMENU || kc == KC_RMENU )
+		mModifiers &= ~Alt;
+
+	if( mBuffered && mListener )
+		return mListener->keyReleased(KeyEvent(this, kc, 0));
+
+	return true;
+}
+
+//-------------------------------------------------------------------//
+const std::string& LinuxKeyboard::getAsString( KeyCode kc )
+{
+	mGetString = "Unknown";
+	char *temp = 0;
+
+	XtoOIS_KeyMap::iterator i = keyConversion.begin(),
+				e = keyConversion.end();
+
+	for( ; i != e; ++i )
+	{
+		if( i->second == kc )
+		{
+			temp = XKeysymToString(i->first);
+			if( temp )
+				mGetString = temp;
+			break;
+		}
+	}
+
+	return mGetString;
+}
+
+//-------------------------------------------------------------------//
+void LinuxKeyboard::copyKeyStates( char keys[256] ) const
+{
+	memcpy( keys, KeyBuffer, 256 );
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/linux/LinuxMouse.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/linux/LinuxMouse.cpp
new file mode 100644
index 0000000..3741a66
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/linux/LinuxMouse.cpp
@@ -0,0 +1,272 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered friosom any source distribution.
+*/
+#include "linux/LinuxMouse.h"
+#include "linux/LinuxInputManager.h"
+#include "OISException.h"
+#include "OISEvents.h"
+
+using namespace OIS;
+
+//-------------------------------------------------------------------//
+LinuxMouse::LinuxMouse(InputManager* creator, bool buffered, bool grab, bool hide)
+	: Mouse(creator->inputSystemName(), buffered, 0, creator)
+{
+	display = 0;
+	window = 0;
+	cursor = 0;
+
+	grabMouse = grab;
+	hideMouse = hide;
+
+	static_cast<LinuxInputManager*>(mCreator)->_setMouseUsed(true);
+}
+
+//-------------------------------------------------------------------//
+void LinuxMouse::_initialize()
+{
+	//Clear old state
+	mState.clear();
+	mMoved  = false;
+	mWarped = false;
+
+	//6 is just some random value... hardly ever would anyone have a window smaller than 6
+	oldXMouseX = oldXMouseY = 6;
+	oldXMouseZ = 0;
+
+	if( display ) XCloseDisplay(display);
+	display = 0;
+	window = static_cast<LinuxInputManager*>(mCreator)->_getWindow();
+
+	//Create our local X mListener connection
+	if( !(display = XOpenDisplay(0)) )
+		OIS_EXCEPT(E_General, "LinuxMouse::_initialize >> Error opening X!");
+
+	//Set it to recieve Mouse Input events
+	if( XSelectInput(display, window, ButtonPressMask | ButtonReleaseMask | PointerMotionMask) == BadWindow )
+		OIS_EXCEPT(E_General, "LinuxMouse::_initialize >> X error!");
+
+	//Warp mouse inside window
+	XWarpPointer(display,None,window,0,0,0,0, 6,6);
+
+	//Create a blank cursor:
+	Pixmap bm_no;
+	XColor black, dummy;
+	Colormap colormap;
+	static char no_data[] = { 0,0,0,0,0,0,0,0 };
+
+	colormap = DefaultColormap( display, DefaultScreen(display) );
+	XAllocNamedColor( display, colormap, "black", &black, &dummy );
+	bm_no = XCreateBitmapFromData( display, window, no_data, 8, 8 );
+	cursor = XCreatePixmapCursor( display, bm_no, bm_no, &black, &black, 0, 0 );
+
+	grab( grabMouse );
+	hide( hideMouse );
+
+	mouseFocusLost = false;
+}
+
+//-------------------------------------------------------------------//
+LinuxMouse::~LinuxMouse()
+{
+	if( display )
+	{
+		grab(false);
+		hide(false);
+		XFreeCursor(display, cursor);
+		XCloseDisplay(display);
+	}
+
+	static_cast<LinuxInputManager*>(mCreator)->_setMouseUsed(false);
+}
+
+//-------------------------------------------------------------------//
+void LinuxMouse::setBuffered(bool buffered)
+{
+	mBuffered = buffered;
+}
+
+//-------------------------------------------------------------------//
+void LinuxMouse::capture()
+{
+	//Clear out last frames values
+	mState.X.rel = 0;
+	mState.Y.rel = 0;
+	mState.Z.rel = 0;
+
+	_processXEvents();
+
+	mWarped = false;
+
+	if( mMoved == true )
+	{
+		if( mBuffered && mListener )
+			mListener->mouseMoved( MouseEvent( this, mState ) );
+
+		mMoved = false;
+	}
+
+	//Check for losing/gaining mouse grab focus (alt-tab, etc)
+	if( grabMouse )
+	{
+		if( static_cast<LinuxInputManager*>(mCreator)->_getGrabState() )
+		{
+			if( mouseFocusLost )	//We just regained mouse grab focus
+			{
+				grab( true );
+				hide( hideMouse );
+				mouseFocusLost = false;
+			}
+		}
+		else
+		{
+			if( mouseFocusLost == false )	//We just lost mouse grab focus
+			{
+				grab( false );
+				hide( false );
+				mouseFocusLost = true;
+			}
+		}
+	}
+}
+
+//-------------------------------------------------------------------//
+void LinuxMouse::_processXEvents()
+{
+	//X11 Button Events: 1=left 2=middle 3=right; Our Bit Postion: 1=Left 2=Right 3=Middle
+	char mask[4] = {0,1,4,2};
+	XEvent event;
+
+	//Poll x11 for events mouse events
+	while( XPending(display) > 0 ) 
+	{
+		XNextEvent(display, &event);
+
+		if( event.type == MotionNotify )
+		{	//Mouse moved
+			//Ignore out of bounds mouse if we just warped
+			if( mWarped )
+			{
+				if(event.xmotion.x < 5 || event.xmotion.x > mState.width - 5 ||
+				   event.xmotion.y < 5 || event.xmotion.y > mState.height - 5)
+					continue;
+			}
+
+			//Compute this frames Relative X & Y motion
+			int dx = event.xmotion.x - oldXMouseX;
+			int dy = event.xmotion.y - oldXMouseY;
+		
+			//Store old values for next time to compute relative motion
+			oldXMouseX = event.xmotion.x;
+			oldXMouseY = event.xmotion.y;
+
+			mState.X.abs += dx;
+			mState.Y.abs += dy;
+			mState.X.rel += dx;
+			mState.Y.rel += dy;
+
+			//Check to see if we are grabbing the mouse to the window (requires clipping and warping)
+			if( grabMouse )
+			{
+				if( mState.X.abs < 0 )
+					mState.X.abs = 0;
+				else if( mState.X.abs > mState.width )
+					mState.X.abs = mState.width;
+
+				if( mState.Y.abs < 0 )
+					mState.Y.abs = 0;
+				else if( mState.Y.abs > mState.height )
+					mState.Y.abs = mState.height;
+
+				if( mouseFocusLost == false )
+				{
+					//Keep mouse in window (fudge factor)
+					if(event.xmotion.x < 5 || event.xmotion.x > mState.width - 5 ||
+					   event.xmotion.y < 5 || event.xmotion.y > mState.height - 5 )
+					{
+						oldXMouseX = mState.width >> 1;  //center x
+						oldXMouseY = mState.height >> 1; //center y
+						XWarpPointer(display, None, window, 0, 0, 0, 0, oldXMouseX, oldXMouseY);
+						mWarped = true;
+					}
+				}
+			}
+			mMoved = true;
+		}
+		else if( event.type == ButtonPress )
+		{	//Button down
+			static_cast<LinuxInputManager*>(mCreator)->_setGrabState(true);
+
+			if( event.xbutton.button < 4 )
+			{
+				mState.buttons |= mask[event.xbutton.button];
+				if( mBuffered && mListener )
+					if( mListener->mousePressed( MouseEvent( this, mState ),
+						(MouseButtonID)(mask[event.xbutton.button] >> 1)) == false )
+						return;
+			}
+		}
+		else if( event.type == ButtonRelease )
+		{	//Button up
+			if( event.xbutton.button < 4 )
+			{
+				mState.buttons &= ~mask[event.xbutton.button];
+				if( mBuffered && mListener )
+					if( mListener->mouseReleased( MouseEvent( this, mState ),
+						(MouseButtonID)(mask[event.xbutton.button] >> 1)) == false )
+						return;
+			}
+			//The Z axis gets pushed/released pair message (this is up)
+			else if( event.xbutton.button == 4 )
+			{
+				mState.Z.rel += 120;
+				mState.Z.abs += 120;
+				mMoved = true;
+			}
+			//The Z axis gets pushed/released pair message (this is down)
+			else if( event.xbutton.button == 5 )
+			{
+				mState.Z.rel -= 120;
+				mState.Z.abs -= 120;
+				mMoved = true;
+			}
+		}
+	}
+}
+
+//-------------------------------------------------------------------//
+void LinuxMouse::grab(bool grab)
+{
+	if( grab )
+		XGrabPointer(display, window, True, 0, GrabModeAsync, GrabModeAsync, window, None, CurrentTime);
+	else
+		XUngrabPointer(display, CurrentTime);
+}
+
+//-------------------------------------------------------------------//
+void LinuxMouse::hide(bool hide)
+{
+	if( hide )
+		XDefineCursor(display, window, cursor);
+	else
+		XUndefineCursor(display, window);
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/mac/MacHIDManager.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/mac/MacHIDManager.cpp
new file mode 100644
index 0000000..7d9cbe3
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/mac/MacHIDManager.cpp
@@ -0,0 +1,432 @@
+/*
+ The zlib/libpng License
+ 
+ Copyright (c) 2006 Phillip Castaneda
+ 
+ This software is provided 'as-is', without any express or implied warranty. In no event will
+ the authors be held liable for any damages arising from the use of this software.
+ 
+ Permission is granted to anyone to use this software for any purpose, including commercial 
+ applications, and to alter it and redistribute it freely, subject to the following
+ restrictions:
+ 
+ 1. The origin of this software must not be misrepresented; you must not claim that 
+ you wrote the original software. If you use this software in a product, 
+ an acknowledgment in the product documentation would be appreciated but is 
+ not required.
+ 
+ 2. Altered source versions must be plainly marked as such, and must not be 
+ misrepresented as being the original software.
+ 
+ 3. This notice may not be removed or altered from any source distribution.
+ */
+#include "mac/MacHIDManager.h"
+#include "mac/MacJoyStick.h"
+#include "OISException.h"
+#include "OISObject.h"
+
+#include <iostream>
+using namespace std;
+
+using namespace OIS;
+
+//------------------------------------------------------------------------------------------------------//
+//------------------------------------------------------------------------------------------------------//
+template<typename T>
+T getDictionaryItemAsRef(CFDictionaryRef dict, const char* keyName)
+{
+	return CFDictionaryGetValue(dict, OIS_CFString(keyName));
+}
+
+template<>
+CFArrayRef getDictionaryItemAsRef(CFDictionaryRef dict, const char* keyName)
+{
+	CFTypeRef temp = CFDictionaryGetValue(dict, OIS_CFString(keyName));
+	
+	if(temp && CFGetTypeID(temp) == CFArrayGetTypeID())
+		return (CFArrayRef)temp;
+	else
+		return 0;
+}
+
+template<>
+CFStringRef getDictionaryItemAsRef(CFDictionaryRef dict, const char* keyName)
+{
+	CFTypeRef temp = CFDictionaryGetValue(dict, OIS_CFString(keyName));
+	
+	if(temp && CFGetTypeID(temp) == CFStringGetTypeID())
+		return (CFStringRef)temp;
+	else
+		return 0;
+}
+
+template<>
+CFNumberRef getDictionaryItemAsRef(CFDictionaryRef dict, const char* keyName)
+{
+	CFTypeRef temp = CFDictionaryGetValue(dict, OIS_CFString(keyName));
+	
+	if(temp && CFGetTypeID(temp) == CFNumberGetTypeID())
+		return (CFNumberRef)temp;
+	else
+		return 0;
+}
+
+//------------------------------------------------------------------------------------------------------//
+//------------------------------------------------------------------------------------------------------//
+template<typename T>
+T getArrayItemAsRef(CFArrayRef array, CFIndex idx)
+{
+	return CFArrayGetValueAtIndex(array, idx);
+}
+
+template<>
+CFDictionaryRef getArrayItemAsRef(CFArrayRef array, CFIndex idx)
+{
+	CFTypeRef temp = CFArrayGetValueAtIndex(array, idx);
+	
+	if(temp && CFGetTypeID(temp) == CFDictionaryGetTypeID())
+		return (CFDictionaryRef)temp;
+	else
+		return 0;
+}
+
+//------------------------------------------------------------------------------------------------------//
+int getInt32(CFNumberRef ref)
+{
+	int r = 0;
+	if (r) 
+		CFNumberGetValue(ref, kCFNumberIntType, &r);
+	return r;
+}
+
+//--------------------------------------------------------------------------------//
+MacHIDManager::MacHIDManager()
+{
+}
+
+//--------------------------------------------------------------------------------//
+MacHIDManager::~MacHIDManager()
+{
+}
+
+//------------------------------------------------------------------------------------------------------//
+void MacHIDManager::initialize()
+{
+	//Make the search more specific by adding usage flags
+	int usage = kHIDUsage_GD_Joystick;
+	int page = kHIDPage_GenericDesktop;
+	
+	io_iterator_t iterator = lookUpDevices(usage, page);
+	
+	if(iterator)
+		iterateAndOpenDevices(iterator);
+	
+	//Doesn't support multiple usage flags, iterate twice
+	usage = kHIDUsage_GD_GamePad;
+	iterator = lookUpDevices(usage, page);
+	
+	if(iterator)
+		iterateAndOpenDevices(iterator);
+}
+
+//------------------------------------------------------------------------------------------------------//
+io_iterator_t MacHIDManager::lookUpDevices(int usage, int page)
+{
+	CFMutableDictionaryRef deviceLookupMap = IOServiceMatching(kIOHIDDeviceKey);
+	if(!deviceLookupMap)
+		OIS_EXCEPT(E_General, "Could not setup HID device search parameters");
+	
+	CFNumberRef usageRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &usage);
+	CFNumberRef pageRef  = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &page);
+	
+	CFDictionarySetValue(deviceLookupMap, CFSTR(kIOHIDPrimaryUsageKey), usageRef);
+	CFDictionarySetValue(deviceLookupMap, CFSTR(kIOHIDPrimaryUsagePageKey), pageRef);
+	
+	//IOServiceGetMatchingServices consumes the map so we do not have to release it ourself
+	io_iterator_t iterator = 0;
+	IOReturn result = IOServiceGetMatchingServices(kIOMasterPortDefault, deviceLookupMap, &iterator);
+	
+	CFRelease(usageRef);
+	CFRelease(pageRef);
+	
+	if(result == kIOReturnSuccess)
+	{
+		return iterator;
+	}
+	//TODO: Throw exception instead?
+	else
+	{
+		return 0;
+	}
+}
+
+//------------------------------------------------------------------------------------------------------//
+void MacHIDManager::iterateAndOpenDevices(io_iterator_t iterator)
+{
+	io_object_t hidDevice = 0;
+	while ((hidDevice = IOIteratorNext(iterator)) !=0)
+	{
+		//Get the current registry items property map
+		CFMutableDictionaryRef propertyMap = 0;
+		if (IORegistryEntryCreateCFProperties(hidDevice, &propertyMap, kCFAllocatorDefault, kNilOptions) == KERN_SUCCESS && propertyMap)
+		{
+			//Go through device to find all needed info
+			HidInfo* hid = enumerateDeviceProperties(propertyMap);
+			
+			if(hid)
+			{
+				//todo - we need to hold an open interface so we do not have to enumerate again later
+				//should be able to watch for device removals also
+				
+				// Testing opening / closing interface
+				IOCFPlugInInterface **pluginInterface = NULL;
+				SInt32 score = 0;
+				if (IOCreatePlugInInterfaceForService(hidDevice, kIOHIDDeviceUserClientTypeID, kIOCFPlugInInterfaceID, &pluginInterface, &score) == kIOReturnSuccess)
+				{
+					IOHIDDeviceInterface **interface;
+					
+					HRESULT pluginResult = (*pluginInterface)->QueryInterface(pluginInterface, CFUUIDGetUUIDBytes(kIOHIDDeviceInterfaceID), (void **)&(interface));
+					
+					if(pluginResult != S_OK)
+						OIS_EXCEPT(E_General, "Not able to create plugin interface");
+					
+					IODestroyPlugInInterface(pluginInterface);
+					
+					hid->interface = interface;
+					
+					//Check for duplicates - some devices have multiple usage
+					if(std::find(mDeviceList.begin(), mDeviceList.end(), hid) == mDeviceList.end())
+						mDeviceList.push_back(hid);
+				}
+			}
+		}
+	}
+	
+	IOObjectRelease(iterator);
+}
+
+//------------------------------------------------------------------------------------------------------//
+HidInfo* MacHIDManager::enumerateDeviceProperties(CFMutableDictionaryRef propertyMap)
+{
+	HidInfo* info = new HidInfo();
+	
+	info->type = OISJoyStick;
+	
+	CFStringRef str = getDictionaryItemAsRef<CFStringRef>(propertyMap, kIOHIDManufacturerKey);
+	if (str)
+		info->vendor = CFStringGetCStringPtr(str, CFStringGetSystemEncoding());
+	
+	str = getDictionaryItemAsRef<CFStringRef>(propertyMap, kIOHIDProductKey);
+	if (str)
+		info->productKey = CFStringGetCStringPtr(str, CFStringGetSystemEncoding());
+	
+	info->combinedKey = info->vendor + " " + info->productKey;
+	
+	//Go through all items in this device (i.e. buttons, hats, sticks, axes, etc)
+	CFArrayRef array = getDictionaryItemAsRef<CFArrayRef>(propertyMap, kIOHIDElementKey);
+	if (array)
+		for (int i = 0; i < CFArrayGetCount(array); i++)
+			parseDeviceProperties(getArrayItemAsRef<CFDictionaryRef>(array, i));
+	
+	return info;
+}
+
+//------------------------------------------------------------------------------------------------------//
+void MacHIDManager::parseDeviceProperties(CFDictionaryRef properties)
+{
+	if(!properties)
+		return;
+	
+	CFArrayRef array = getDictionaryItemAsRef<CFArrayRef>(properties, kIOHIDElementKey);
+	if (array)
+	{
+		for (int i = 0; i < CFArrayGetCount(array); i++)
+		{
+			CFDictionaryRef element = getArrayItemAsRef<CFDictionaryRef>(array, i);
+			if (element)
+			{
+				if(getInt32(getDictionaryItemAsRef<CFNumberRef>(element, kIOHIDElementTypeKey)) == kIOHIDElementTypeCollection) 
+				{	//Check if we need to recurse further intoi another collection
+					if(getInt32(getDictionaryItemAsRef<CFNumberRef>(element, kIOHIDElementUsagePageKey)) == kHIDPage_GenericDesktop)
+						parseDeviceProperties(element);
+				}
+				else
+				{
+					switch(getInt32(getDictionaryItemAsRef<CFNumberRef>(element, kIOHIDElementUsagePageKey)))
+					{
+						case kHIDPage_GenericDesktop:
+							switch(getInt32(getDictionaryItemAsRef<CFNumberRef>(element, kIOHIDElementUsageKey)))
+						{
+							case kHIDUsage_GD_Pointer:
+								cout << "\tkHIDUsage_GD_Pointer\n";
+								parseDevicePropertiesGroup(element);
+								break;
+							case kHIDUsage_GD_X:
+							case kHIDUsage_GD_Y:
+							case kHIDUsage_GD_Z:
+							case kHIDUsage_GD_Rx:
+							case kHIDUsage_GD_Ry:
+							case kHIDUsage_GD_Rz:
+								cout << "\tAxis\n";
+								break;
+							case kHIDUsage_GD_Slider:
+							case kHIDUsage_GD_Dial:
+							case kHIDUsage_GD_Wheel:
+								cout << "\tUnsupported kHIDUsage_GD_Wheel\n";
+								break;
+							case kHIDUsage_GD_Hatswitch:
+								cout << "\tUnsupported - kHIDUsage_GD_Hatswitch\n";
+								break;
+						}
+							break;
+						case kHIDPage_Button:
+							cout << "\tkHIDPage_Button\n";
+							break;
+					}
+				}
+			}
+		}
+	}
+}
+
+//------------------------------------------------------------------------------------------------------//
+void MacHIDManager::parseDevicePropertiesGroup(CFDictionaryRef properties)
+{
+	if(!properties)
+		return;
+	
+	CFArrayRef array = getDictionaryItemAsRef<CFArrayRef>(properties, kIOHIDElementKey);
+	if(array)
+	{
+		for (int i = 0; i < CFArrayGetCount(array); i++)
+		{
+			CFDictionaryRef element = getArrayItemAsRef<CFDictionaryRef>(array, i);
+			if (element)
+			{
+				switch(getInt32(getDictionaryItemAsRef<CFNumberRef>(element, kIOHIDElementUsagePageKey)))
+				{
+					case kHIDPage_GenericDesktop:
+						switch(getInt32(getDictionaryItemAsRef<CFNumberRef>(element, kIOHIDElementUsageKey)))
+					{
+						case kHIDUsage_GD_X:
+						case kHIDUsage_GD_Y:
+						case kHIDUsage_GD_Z:
+						case kHIDUsage_GD_Rx:
+						case kHIDUsage_GD_Ry:
+						case kHIDUsage_GD_Rz:
+							cout << "\t\tAxis\n";
+							break;
+						case kHIDUsage_GD_Slider:
+						case kHIDUsage_GD_Dial:
+						case kHIDUsage_GD_Wheel:
+							cout << "\tUnsupported - kHIDUsage_GD_Wheel\n";
+							break;
+						case kHIDUsage_GD_Hatswitch:
+							cout << "\tUnsupported - kHIDUsage_GD_Hatswitch\n";
+							break;
+					}
+						break;
+					case kHIDPage_Button:
+						break;
+				}
+			}
+		}
+	}
+}
+
+//--------------------------------------------------------------------------------//
+DeviceList MacHIDManager::freeDeviceList()
+{
+	DeviceList ret;
+	HidInfoList::iterator it = mDeviceList.begin(), end = mDeviceList.end();
+	for(; it != end; ++it)
+	{
+		if((*it)->inUse == false)
+			ret.insert(std::make_pair((*it)->type, (*it)->combinedKey));
+	}
+	
+	return ret;
+}
+
+//--------------------------------------------------------------------------------//
+int MacHIDManager::totalDevices(Type iType)
+{
+	int ret = 0;
+	HidInfoList::iterator it = mDeviceList.begin(), end = mDeviceList.end();
+	
+	for(; it != end; ++it)
+	{
+		if((*it)->type == iType)
+			ret++;
+	}
+	
+	return ret;
+}
+
+//--------------------------------------------------------------------------------//
+int MacHIDManager::freeDevices(Type iType)
+{
+	int ret = 0;
+	HidInfoList::iterator it = mDeviceList.begin(), end = mDeviceList.end();
+	
+	for(; it != end; ++it)
+	{
+		if((*it)->inUse == false && (*it)->type == iType)
+			ret++;
+	}
+	
+	return ret;
+}
+
+//--------------------------------------------------------------------------------//
+bool MacHIDManager::vendorExist(Type iType, const std::string & vendor)
+{
+	HidInfoList::iterator it = mDeviceList.begin(), end = mDeviceList.end();
+	
+	for(; it != end; ++it)
+	{
+		if((*it)->type == iType && (*it)->combinedKey == vendor)
+			return true;
+	}
+	
+	return false;
+}
+
+//--------------------------------------------------------------------------------//
+Object* MacHIDManager::createObject(InputManager* creator, Type iType, bool bufferMode, 
+									const std::string & vendor)
+{
+	Object *obj = 0;
+	
+	HidInfoList::iterator it = mDeviceList.begin(), end = mDeviceList.end();
+	for(; it != end; ++it)
+	{
+		if((*it)->inUse == false && (*it)->type == iType && (vendor == "" || (*it)->combinedKey == vendor))
+		{
+			switch(iType)
+			{
+				case OISJoyStick:
+					int totalDevs = totalDevices(iType);
+					int freeDevs = freeDevices(iType);
+					int devID = totalDevs - freeDevs;
+					
+					obj = new MacJoyStick((*it)->combinedKey, bufferMode, *it, creator, devID);
+					(*it)->inUse = true;
+					return obj;
+				case OISTablet:
+					//Create MacTablet
+					break;
+				default:
+					break;
+			}
+		}
+	}
+	
+	return obj;
+}
+
+//--------------------------------------------------------------------------------//
+void MacHIDManager::destroyObject(Object* obj)
+{
+	delete obj;
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/mac/MacHelpers.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/mac/MacHelpers.cpp
new file mode 100644
index 0000000..11d6da3
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/mac/MacHelpers.cpp
@@ -0,0 +1,158 @@
+/*
+ The zlib/libpng License
+ 
+ Copyright (c) 2006 Chris Snyder 
+ 
+ This software is provided 'as-is', without any express or implied warranty. In no event will
+ the authors be held liable for any damages arising from the use of this software.
+ 
+ Permission is granted to anyone to use this software for any purpose, including commercial 
+ applications, and to alter it and redistribute it freely, subject to the following
+ restrictions:
+ 
+ 1. The origin of this software must not be misrepresented; you must not claim that 
+ you wrote the original software. If you use this software in a product, 
+ an acknowledgment in the product documentation would be appreciated but is 
+ not required.
+ 
+ 2. Altered source versions must be plainly marked as such, and must not be 
+ misrepresented as being the original software.
+ 
+ 3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "mac/MacHelpers.h"
+#include "mac/MacKeyboard.h"
+#include "mac/MacMouse.h"
+#include "OISException.h"
+
+#include <Carbon/Carbon.h>
+
+using namespace OIS;
+    
+//-------------------------------------------------------------------//
+OSStatus KeyDownWrapper( EventHandlerCallRef nextHandler,
+                        EventRef               theEvent,
+                        void*                  callClass )
+{
+    // TODO find a better way. This cast isn't very safe
+    if (callClass != NULL) {
+        ((MacKeyboard*)callClass)->_keyDownCallback( theEvent );
+        
+        // propagate the event down the chain
+        return CallNextEventHandler( nextHandler, theEvent );
+    }
+    else {
+        OIS_EXCEPT(E_General, "KeyDownWrapper >> Being called by something other than our event handler!");
+        return noErr;
+    }
+}
+
+
+//-------------------------------------------------------------------//
+OSStatus KeyUpWrapper( EventHandlerCallRef nextHandler,
+                       EventRef               theEvent,
+                       void*                  callClass )
+{
+    if (callClass != NULL) {
+        ((MacKeyboard*)callClass)->_keyUpCallback( theEvent );
+        
+        // propagate the event down the chain
+        return CallNextEventHandler( nextHandler, theEvent );
+    }
+    else {
+        OIS_EXCEPT(E_General, "KeyUpWrapper >> Being called by something other than our event handler!");
+        return noErr;
+    }
+}
+
+
+//-------------------------------------------------------------------//
+OSStatus KeyModWrapper( EventHandlerCallRef nextHandler,
+                        EventRef               theEvent,
+                        void*                  callClass )
+{
+    if (callClass != NULL) {
+        ((MacKeyboard*)callClass)->_modChangeCallback( theEvent );
+        
+        // propagate the event down the chain
+        return CallNextEventHandler( nextHandler, theEvent );
+        
+    }
+    else {
+        OIS_EXCEPT(E_General, "KeyModWrapper >> Being called by something other than our event handler!");
+        return noErr;
+    }
+}
+
+/*
+//-------------------------------------------------------------------//
+OSStatus MouseMoveWrapper( EventHandlerCallRef nextHandler,
+                           EventRef            theEvent,
+                           void*               callClass )
+{
+    if (callClass != NULL) {
+        ((MacMouse*)callClass)->_mouseMoveCallback( theEvent );
+        
+        // propagate the event down the chain
+        return CallNextEventHandler( nextHandler, theEvent );
+        
+    }
+    else {
+        OIS_EXCEPT(E_General, "MouseMoveWrapper >> Being called by something other than our event handler!");
+        return noErr;
+    }
+}
+
+
+//-------------------------------------------------------------------//
+OSStatus MouseScrollWrapper( EventHandlerCallRef nextHandler,
+                             EventRef            theEvent,
+                             void*               callClass )
+{
+    if (callClass != NULL) {
+        ((MacMouse*)callClass)->_mouseScrollCallback( theEvent );
+        
+        // propagate the event down the chain
+        return CallNextEventHandler( nextHandler, theEvent );
+        
+    }
+    else {
+        OIS_EXCEPT(E_General, "MouseScrollWrapper >> Being called by something other than our event handler!");
+        return noErr;
+    }
+}
+
+
+//-------------------------------------------------------------------//
+OSStatus MouseButtonWrapper( EventHandlerCallRef nextHandler,
+                             EventRef            theEvent,
+                             void*               callClass )
+{
+    if (callClass != NULL) {
+        ((MacMouse*)callClass)->_mouseButtonCallback( theEvent );
+        
+        // propagate the event down the chain
+        return CallNextEventHandler( nextHandler, theEvent );
+        
+    }
+    else {
+        OIS_EXCEPT(E_General, "MouseButtonWrapper >> Being called by something other than our event handler!");
+        return noErr;
+    }
+}
+*/
+
+//-------------------------------------------------------------------//
+OSStatus MouseWrapper( EventHandlerCallRef nextHandler, EventRef theEvent, void* callClass )
+{
+    if (callClass != NULL)
+	{
+        ((MacMouse*)callClass)->_mouseCallback( theEvent );
+
+        // propagate the event down the chain
+        return CallNextEventHandler( nextHandler, theEvent );        
+    }
+    else
+        OIS_EXCEPT(E_General, "MouseWrapper >> Being called by something other than our event handler!");
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/mac/MacInputManager.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/mac/MacInputManager.cpp
new file mode 100644
index 0000000..382fdde
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/mac/MacInputManager.cpp
@@ -0,0 +1,206 @@
+/*
+ The zlib/libpng License
+ 
+ Copyright (c) 2006 Chris Snyder 
+ 
+ This software is provided 'as-is', without any express or implied warranty. In no event will
+ the authors be held liable for any damages arising from the use of this software.
+ 
+ Permission is granted to anyone to use this software for any purpose, including commercial 
+ applications, and to alter it and redistribute it freely, subject to the following
+ restrictions:
+ 
+ 1. The origin of this software must not be misrepresented; you must not claim that 
+ you wrote the original software. If you use this software in a product, 
+ an acknowledgment in the product documentation would be appreciated but is 
+ not required.
+ 
+ 2. Altered source versions must be plainly marked as such, and must not be 
+ misrepresented as being the original software.
+ 
+ 3. This notice may not be removed or altered from any source distribution.
+*/
+#include "mac/MacInputManager.h"
+#include "mac/MacKeyboard.h"
+#include "mac/MacMouse.h"
+#include "mac/MacHIDManager.h"
+#include "OISException.h"
+
+#include <Carbon/Carbon.h>
+
+#include <iostream>
+using namespace std;
+
+using namespace OIS;
+
+//--------------------------------------------------------------------------------//
+MacInputManager::MacInputManager() : InputManager("Mac OSX Input Manager")
+{
+    mHideMouse = true;
+    mUseRepeat = false;
+    mEventTargetRef = NULL;
+	mWindow = NULL;
+
+	keyboardUsed = mouseUsed = false;
+
+	//Setup our internal factories
+	mFactories.push_back(this);
+
+	mHIDManager = new MacHIDManager();
+	mFactories.push_back(mHIDManager);
+}
+
+//--------------------------------------------------------------------------------//
+MacInputManager::~MacInputManager()
+{
+	delete mHIDManager;
+}
+
+//--------------------------------------------------------------------------------//
+void MacInputManager::_initialize( ParamList &paramList )
+{
+	_parseConfigSettings( paramList );
+    
+	//Enumerate all devices attached
+	_enumerateDevices();
+	
+	mHIDManager->initialize();
+}
+
+//--------------------------------------------------------------------------------//
+void MacInputManager::_parseConfigSettings( ParamList &paramList )
+{
+    // Some carbon apps are running in a window, however full screen apps
+	// do not have a window, so we need to account for that too.
+	ParamList::iterator i = paramList.find("WINDOW");
+	if(i != paramList.end())
+	{
+		mWindow = (WindowRef)strtoul(i->second.c_str(), 0, 10);
+		if(mWindow == 0)
+		{
+			mWindow = NULL;
+			mEventTargetRef = GetApplicationEventTarget();
+		}
+		else
+		{
+			//mEventTargetRef = GetWindowEventTarget(mWindow);
+			mEventTargetRef = GetApplicationEventTarget();
+		}
+    }
+	else
+	{
+		// else get the main active window.. user might not have access to it through some
+		// graphics libraries, if that fails then try at the application level.
+		mWindow = ActiveNonFloatingWindow();
+		if(mWindow == NULL)
+		{
+			mEventTargetRef = GetApplicationEventTarget();
+		}
+		else
+		{
+			//mEventTargetRef = GetWindowEventTarget(mWindow);
+			mEventTargetRef = GetApplicationEventTarget();
+		}
+	}
+	
+	if(mEventTargetRef == NULL)
+		OIS_EXCEPT( E_General, "MacInputManager::_parseConfigSettings >> Unable to find a window or event target" );
+    
+    // Keyboard
+    if(paramList.find("MacAutoRepeatOn") != paramList.end())
+	{
+        if(paramList.find("MacAutoRepeatOn")->second == "true")
+		{
+            mUseRepeat = true;
+        }
+    }
+}
+
+//--------------------------------------------------------------------------------//
+void MacInputManager::_enumerateDevices()
+{
+}
+
+//--------------------------------------------------------------------------------//
+DeviceList MacInputManager::freeDeviceList()
+{
+	DeviceList ret;
+
+	if( keyboardUsed == false )
+		ret.insert(std::make_pair(OISKeyboard, mInputSystemName));
+
+	if( mouseUsed == false )
+		ret.insert(std::make_pair(OISMouse, mInputSystemName));
+
+	return ret;
+}
+
+//--------------------------------------------------------------------------------//
+int MacInputManager::totalDevices(Type iType)
+{
+	switch(iType)
+	{
+	case OISKeyboard: return 1;
+	case OISMouse: return 1;
+	default: return 0;
+	}
+}
+
+//--------------------------------------------------------------------------------//
+int MacInputManager::freeDevices(Type iType)
+{
+	switch(iType)
+	{
+	case OISKeyboard: return keyboardUsed ? 0 : 1;
+	case OISMouse: return mouseUsed ? 0 : 1;
+	default: return 0;
+	}
+}
+
+//--------------------------------------------------------------------------------//
+bool MacInputManager::vendorExist(Type iType, const std::string & vendor)
+{
+	if( (iType == OISKeyboard || iType == OISMouse) && vendor == mInputSystemName )
+		return true;
+
+	return false;
+}
+
+//--------------------------------------------------------------------------------//
+Object* MacInputManager::createObject(InputManager* creator, Type iType, bool bufferMode, 
+									  const std::string & vendor)
+{
+	Object *obj = 0;
+
+	switch(iType)
+	{
+	case OISKeyboard: 
+	{
+		if( keyboardUsed == false )
+			obj = new MacKeyboard(this, bufferMode, mUseRepeat);
+		break;
+	}
+	case OISMouse:
+	{
+		if( mouseUsed == false )
+			obj = new MacMouse(this, bufferMode);
+		break;
+	}
+	default:
+	{
+		obj = mHIDManager->createObject(creator, iType, bufferMode, vendor);
+		break;
+	}
+	}
+
+	if( obj == 0 )
+		OIS_EXCEPT(E_InputDeviceNonExistant, "No devices match requested type.");
+
+	return obj;
+}
+
+//--------------------------------------------------------------------------------//
+void MacInputManager::destroyObject(Object* obj)
+{
+	delete obj;
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/mac/MacJoyStick.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/mac/MacJoyStick.cpp
new file mode 100644
index 0000000..c6cfa0d
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/mac/MacJoyStick.cpp
@@ -0,0 +1,325 @@
+/*
+ The zlib/libpng License
+ 
+ Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+ 
+ This software is provided 'as-is', without any express or implied warranty. In no event will
+ the authors be held liable for any damages arising from the use of this software.
+ 
+ Permission is granted to anyone to use this software for any purpose, including commercial
+ applications, and to alter it and redistribute it freely, subject to the following
+ restrictions:
+ 
+ 1. The origin of this software must not be misrepresented; you must not claim that
+ you wrote the original software. If you use this software in a product,
+ an acknowledgment in the product documentation would be appreciated but is
+ not required.
+ 
+ 2. Altered source versions must be plainly marked as such, and must not be
+ misrepresented as being the original software.
+ 
+ 3. This notice may not be removed or altered from any source distribution.
+ */
+
+#include "mac/MacJoyStick.h"
+#include "mac/MacHIDManager.h"
+#include "mac/MacInputManager.h"
+#include "OISEvents.h"
+#include "OISException.h"
+
+#include <cassert>
+
+using namespace OIS;
+
+//--------------------------------------------------------------------------------------------------//
+MacJoyStick::MacJoyStick(const std::string &vendor, bool buffered, HidInfo* info, InputManager* creator, int devID) : 
+JoyStick(vendor, buffered, devID, creator), mInfo(info)
+{
+	
+}
+
+//--------------------------------------------------------------------------------------------------//
+MacJoyStick::~MacJoyStick()
+{
+	//TODO: check if the queue has been started first?
+	//(*mQueue)->stop(mQueue); 
+	(*mQueue)->dispose(mQueue); 
+	(*mQueue)->Release(mQueue); 
+	
+	
+	//TODO: check if the interface has been opened first?
+	(*mInfo->interface)->close(mInfo->interface);
+	(*mInfo->interface)->Release(mInfo->interface); 
+}
+
+//--------------------------------------------------------------------------------------------------//
+void MacJoyStick::_initialize()
+{
+	assert(mInfo && "Given HidInfo invalid");
+	assert(mInfo->interface && "Joystick interface invalid");
+	
+	//TODO: Is this necessary?
+	//Clear old state
+	mState.mAxes.clear();
+	
+	if ((*mInfo->interface)->open(mInfo->interface, 0) != KERN_SUCCESS)
+		OIS_EXCEPT(E_General, "MacJoyStick::_initialize() >> Could not initialize joy device!");
+	
+	mState.clear();
+	
+	_enumerateCookies();
+	
+	mState.mButtons.resize(mInfo->numButtons);
+	mState.mAxes.resize(mInfo->numAxes);
+	
+	mQueue = _createQueue();
+}
+
+class FindAxisCookie : public std::unary_function<std::pair<IOHIDElementCookie, AxisInfo>&, bool>
+{
+public:
+	FindAxisCookie(IOHIDElementCookie cookie) : m_Cookie(cookie) {}
+	bool operator()(const std::pair<IOHIDElementCookie, AxisInfo>& pair) const
+	{
+		return pair.first == m_Cookie;
+	}
+private:
+	IOHIDElementCookie m_Cookie;
+};
+
+//--------------------------------------------------------------------------------------------------//
+void MacJoyStick::capture()
+{
+	assert(mQueue && "Queue must be initialized before calling MacJoyStick::capture()");
+	
+	AbsoluteTime zeroTime = {0,0}; 
+	
+	IOHIDEventStruct event; 
+	IOReturn result = (*mQueue)->getNextEvent(mQueue, &event, zeroTime, 0); 
+	while(result == kIOReturnSuccess)
+	{
+		switch(event.type)
+		{
+			case kIOHIDElementTypeInput_Button:
+			{
+				std::vector<IOHIDElementCookie>::iterator buttonIt = std::find(mCookies.buttonCookies.begin(), mCookies.buttonCookies.end(), event.elementCookie);
+				int button = std::distance(mCookies.buttonCookies.begin(), buttonIt);
+				mState.mButtons[button] = (event.value == 1);
+				
+				if(mBuffered && mListener)
+				{
+					if(event.value == 0)
+						mListener->buttonPressed(JoyStickEvent(this, mState), button);
+					else if(event.value == 1)
+						mListener->buttonReleased(JoyStickEvent(this, mState), button);
+				}
+				break;
+			}
+			case kIOHIDElementTypeInput_Misc:
+				//TODO: It's an axis! - kind of - for gamepads - or should this be a pov?
+			case kIOHIDElementTypeInput_Axis:
+				std::map<IOHIDElementCookie, AxisInfo>::iterator axisIt = std::find_if(mCookies.axisCookies.begin(), mCookies.axisCookies.end(), FindAxisCookie(event.elementCookie));
+				int axis = std::distance(mCookies.axisCookies.begin(), axisIt);
+				
+				//Copied from LinuxJoyStickEvents.cpp, line 149
+				const AxisInfo& axisInfo = axisIt->second;
+				float proportion = (float) (event.value - axisInfo.max) / (float) (axisInfo.min - axisInfo.max);
+				mState.mAxes[axis].abs = -JoyStick::MIN_AXIS - (JoyStick::MAX_AXIS * 2 * proportion);
+				
+				if(mBuffered && mListener) mListener->axisMoved(JoyStickEvent(this, mState), axis);
+				break;
+		}
+		
+		result = (*mQueue)->getNextEvent(mQueue, &event, zeroTime, 0);
+	}
+}
+
+//--------------------------------------------------------------------------------------------------//
+void MacJoyStick::setBuffered(bool buffered)
+{
+	mBuffered = buffered;
+}
+
+//--------------------------------------------------------------------------------------------------//
+Interface* MacJoyStick::queryInterface(Interface::IType type)
+{
+	//Thought about using covariant return type here.. however,
+	//some devices may allow LED light changing, or other interface stuff
+	
+	//f( ff_device && type == Interface::ForceFeedback )
+	//return ff_device;
+	//else
+	return 0;
+}
+
+//--------------------------------------------------------------------------------------------------//
+void MacJoyStick::_enumerateCookies()
+{
+	assert(mInfo && "Given HidInfo invalid");
+	assert(mInfo->interface && "Joystick interface invalid");
+	
+	CFTypeRef                               object; 
+	long                                    number; 
+	IOHIDElementCookie                      cookie; 
+	long                                    usage; 
+	long                                    usagePage;
+	int										min;
+	int										max;
+
+	CFDictionaryRef                         element; 
+	
+	// Copy all elements, since we're grabbing most of the elements 
+	// for this device anyway, and thus, it's faster to iterate them 
+	// ourselves. When grabbing only one or two elements, a matching 
+	// dictionary should be passed in here instead of NULL. 
+	CFArrayRef elements; 
+	IOReturn success = reinterpret_cast<IOHIDDeviceInterface122*>(*mInfo->interface)->copyMatchingElements(mInfo->interface, NULL, &elements); 
+	
+	if (success == kIOReturnSuccess)
+	{ 
+		const CFIndex numOfElements = CFArrayGetCount(elements);
+		for (CFIndex i = 0; i < numOfElements; ++i) 
+		{ 
+			element = static_cast<CFDictionaryRef>(CFArrayGetValueAtIndex(elements, i));
+			
+			//Get cookie 
+			object = (CFDictionaryGetValue(element, 
+										   CFSTR(kIOHIDElementCookieKey))); 
+			if (object == 0 || CFGetTypeID(object) != CFNumberGetTypeID()) 
+				continue; 
+			if(!CFNumberGetValue((CFNumberRef) object, kCFNumberLongType, 
+								 &number)) 
+				continue; 
+			cookie = (IOHIDElementCookie) number; 
+			
+			//Get usage 
+			object = CFDictionaryGetValue(element, 
+										  CFSTR(kIOHIDElementUsageKey)); 
+			if (object == 0 || CFGetTypeID(object) != CFNumberGetTypeID()) 
+				continue; 
+			if (!CFNumberGetValue((CFNumberRef) object, kCFNumberLongType, 
+								  &number)) 
+				continue; 
+			usage = number; 
+			
+			//Get min
+			object = CFDictionaryGetValue(element,
+										  CFSTR(kIOHIDElementMinKey)); // kIOHIDElementMinKey or kIOHIDElementScaledMinKey?, no idea ...
+			if (object == 0 || CFGetTypeID(object) != CFNumberGetTypeID())
+				continue;
+			if (!CFNumberGetValue((CFNumberRef) object, kCFNumberIntType,
+								  &number))
+				continue;
+			min = number;
+			
+			//Get max
+			object = CFDictionaryGetValue(element,
+										  CFSTR(kIOHIDElementMaxKey)); // kIOHIDElementMaxKey or kIOHIDElementScaledMaxKey?, no idea ...
+			if (object == 0 || CFGetTypeID(object) != CFNumberGetTypeID())
+				continue;
+			if (!CFNumberGetValue((CFNumberRef) object, kCFNumberIntType,
+								  &number))
+				continue;
+			max = number;			
+			
+			//Get usage page 
+			object = CFDictionaryGetValue(element, 
+										  CFSTR(kIOHIDElementUsagePageKey)); 
+			
+			if (object == 0 || CFGetTypeID(object) != CFNumberGetTypeID()) 
+				continue; 
+			
+			if (!CFNumberGetValue((CFNumberRef) object, kCFNumberLongType, 
+								  &number)) 
+				continue; 
+			
+			usagePage = number;
+			switch(usagePage)
+			{
+				case kHIDPage_GenericDesktop:
+					switch(usage)
+				{
+					case kHIDUsage_GD_Pointer:
+						break;
+					case kHIDUsage_GD_X:
+					case kHIDUsage_GD_Y:
+					case kHIDUsage_GD_Z:
+					case kHIDUsage_GD_Rx:
+					case kHIDUsage_GD_Ry:
+					case kHIDUsage_GD_Rz:
+						mCookies.axisCookies.insert(std::make_pair(cookie, AxisInfo(min, max)));
+						break;
+					case kHIDUsage_GD_Slider:
+					case kHIDUsage_GD_Dial:
+					case kHIDUsage_GD_Wheel:
+						break;
+					case kHIDUsage_GD_Hatswitch:
+						break;
+				}
+					break;
+				case kHIDPage_Button:
+					mCookies.buttonCookies.push_back(cookie);
+					break;
+			}		
+		}
+		
+		mInfo->numButtons = mCookies.buttonCookies.size();
+		mInfo->numAxes = mCookies.axisCookies.size();
+
+	} 
+	else 
+	{ 
+		OIS_EXCEPT(E_General, "JoyStick elements could not be copied: copyMatchingElements failed with error: " + success); 
+	}
+	
+}
+
+//--------------------------------------------------------------------------------------------------//
+IOHIDQueueInterface** MacJoyStick::_createQueue(unsigned int depth)
+{	
+	assert(mInfo && "Given HidInfo invalid");
+	assert(mInfo->interface && "Joystick interface invalid");
+	
+	IOHIDQueueInterface** queue = (*mInfo->interface)->allocQueue(mInfo->interface); 
+	
+	if (queue) 
+	{		
+		//create the queue 
+		IOReturn result = (*queue)->create(queue, 0, depth); 
+		
+		if(result == kIOReturnSuccess)
+		{		
+			//add elements to the queue
+			std::map<IOHIDElementCookie, AxisInfo>::iterator axisIt = mCookies.axisCookies.begin();
+			for(; axisIt != mCookies.axisCookies.end(); ++axisIt)
+			{
+				result = (*queue)->addElement(queue, axisIt->first, 0);
+			}
+			
+			std::vector<IOHIDElementCookie>::iterator buttonIt = mCookies.buttonCookies.begin();
+			for(; buttonIt != mCookies.buttonCookies.end(); ++buttonIt)
+			{
+				result = (*queue)->addElement(queue, (*buttonIt), 0);
+			}
+
+			//start data delivery to queue 
+			result = (*queue)->start(queue); 
+			if(result == kIOReturnSuccess)
+			{
+				return queue;
+			}
+			else
+			{
+				OIS_EXCEPT(E_General, "Queue could not be started.");
+			}
+		}
+		else
+		{
+			OIS_EXCEPT(E_General, "Queue could not be created.");
+		}
+	}
+	else
+	{
+		OIS_EXCEPT(E_General, "Queue allocation failed.");
+	}
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/mac/MacKeyboard.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/mac/MacKeyboard.cpp
new file mode 100644
index 0000000..8bfaad8
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/mac/MacKeyboard.cpp
@@ -0,0 +1,467 @@
+/*
+ The zlib/libpng License
+ 
+ Copyright (c) 2006 Chris Snyder 
+ 
+ This software is provided 'as-is', without any express or implied warranty. In no event will
+ the authors be held liable for any damages arising from the use of this software.
+ 
+ Permission is granted to anyone to use this software for any purpose, including commercial 
+ applications, and to alter it and redistribute it freely, subject to the following
+ restrictions:
+ 
+ 1. The origin of this software must not be misrepresented; you must not claim that 
+ you wrote the original software. If you use this software in a product, 
+ an acknowledgment in the product documentation would be appreciated but is 
+ not required.
+ 
+ 2. Altered source versions must be plainly marked as such, and must not be 
+ misrepresented as being the original software.
+ 
+ 3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "mac/MacKeyboard.h"
+#include "mac/MacInputManager.h"
+#include "mac/MacHelpers.h"
+#include "OISException.h"
+#include "OISEvents.h"
+
+#include <Carbon/Carbon.h>
+
+#include <list>
+#include <string>
+
+const EventTypeSpec DownSpec[] = {{kEventClassKeyboard, kEventRawKeyDown},	//non - repeats
+							{kEventClassKeyboard, kEventRawKeyRepeat}}; //repeats
+const EventTypeSpec UpSpec = {kEventClassKeyboard, kEventRawKeyUp},
+			  ModSpec = {kEventClassKeyboard, kEventRawKeyModifiersChanged};
+
+const EventTypeSpec AllSpecs[] = {{kEventClassKeyboard, kEventRawKeyDown},
+						  {kEventClassKeyboard, kEventRawKeyRepeat},
+						  {kEventClassKeyboard, kEventRawKeyUp},
+						  {kEventClassKeyboard, kEventRawKeyModifiersChanged}};
+
+using namespace OIS;
+
+//-------------------------------------------------------------------//
+MacKeyboard::MacKeyboard( InputManager* creator, bool buffered, bool repeat )
+	: Keyboard(creator->inputSystemName(), buffered, 0, creator)
+{
+	keyDownEventRef = NULL;
+	keyUpEventRef = NULL;
+	keyModEventRef = NULL;
+	
+	useRepeat = repeat;
+
+	// Get a so-called "Univeral procedure pointer" for our callback
+	keyDownUPP = NewEventHandlerUPP( KeyDownWrapper );
+	keyUpUPP   = NewEventHandlerUPP( KeyUpWrapper );
+	keyModUPP  = NewEventHandlerUPP( KeyModWrapper );
+	
+	// populate the conversion map
+	populateKeyConversion();
+
+	static_cast<MacInputManager*>(mCreator)->_setKeyboardUsed(true);
+}
+
+//-------------------------------------------------------------------//
+MacKeyboard::~MacKeyboard()
+{
+	// Remove our handlers so that this instance doesn't get called
+	// after it is deleted
+	if (keyDownEventRef != NULL)
+		RemoveEventHandler(keyDownEventRef);
+		
+	if (keyUpEventRef != NULL)
+		RemoveEventHandler(keyUpEventRef);
+	
+	if (keyModEventRef != NULL)
+		RemoveEventHandler(keyModEventRef);
+	
+	// dispose of our UPPs
+	DisposeEventHandlerUPP(keyDownUPP);
+	DisposeEventHandlerUPP(keyUpUPP);
+	DisposeEventHandlerUPP(keyModUPP);
+
+	//Free the input managers keyboard
+	static_cast<MacInputManager*>(mCreator)->_setKeyboardUsed(false);
+}
+
+//-------------------------------------------------------------------//
+void MacKeyboard::_initialize()
+{
+	EventTargetRef event = ((MacInputManager*)mCreator)->_getEventTarget();
+
+	memset( &KeyBuffer, 0, 256 );
+	mModifiers = 0;
+	prevModMask = 0;
+	
+	// just in case this gets called after the first time.. better safe
+	if (keyDownEventRef != NULL)
+		RemoveEventHandler(keyDownEventRef);
+		
+	if (keyUpEventRef != NULL)
+		RemoveEventHandler(keyUpEventRef);
+		
+	if (keyModEventRef != NULL)
+		RemoveEventHandler(keyModEventRef);
+   
+	keyDownEventRef = NULL;
+	keyUpEventRef = NULL;
+	keyModEventRef = NULL;
+
+	OSStatus status;
+	// send both elements of downspec array... second index is for repeat events
+	if ( useRepeat )
+		status = InstallEventHandler( event, keyDownUPP, 2, DownSpec, this, &keyDownEventRef );
+	else
+		status = InstallEventHandler( event, keyDownUPP, 1, DownSpec, this, &keyDownEventRef );
+		
+	if (status != noErr)
+		OIS_EXCEPT( E_General, "MacKeyboard::_initialize >> Error loading KeyDown event handler" );
+
+	if (InstallEventHandler( event, keyUpUPP, 1, &UpSpec, this, &keyUpEventRef ) != noErr)
+		OIS_EXCEPT( E_General, "MacKeyboard::_initialize >> Error loading KeyUp event handler" );
+
+	if (InstallEventHandler( event, keyModUPP, 1, &ModSpec, this, &keyModEventRef ) != noErr )
+		OIS_EXCEPT( E_General, "MacKeyboard::_initialize >> Error loading Keymods event handler" );
+}
+
+//-------------------------------------------------------------------//
+bool MacKeyboard::isKeyDown( KeyCode key ) const
+{
+	return (bool)KeyBuffer[key];
+}
+
+
+//-------------------------------------------------------------------//
+void MacKeyboard::capture()
+{
+	// if not buffered just return, we update the unbuffered automatically
+	if ( !mBuffered || !mListener )
+		return;
+	
+	//If the mListener returns false, that means that we are probably deleted...
+	//send no more events and just leave as the this pointer is invalid now...
+	bool ret = true;
+	
+	// run through our event stack
+	eventStack::iterator cur_it;
+	
+	for (cur_it = pendingEvents.begin(); cur_it != pendingEvents.end(); cur_it++)
+	{
+		
+		if ( (*cur_it).Type == MAC_KEYDOWN || (*cur_it).Type == MAC_KEYREPEAT)
+			mListener->keyPressed( (*cur_it).Event );
+		else if ( (*cur_it).Type == MAC_KEYUP )
+			mListener->keyReleased( (*cur_it).Event );
+	}
+	
+	pendingEvents.clear();
+}
+
+
+//-------------------------------------------------------------------//
+std::string& MacKeyboard::getAsString( KeyCode key )
+{
+	getString = "";
+	
+	return getString;
+}
+
+//-------------------------------------------------------------------//
+void MacKeyboard::setBuffered( bool buffered )
+{
+	mBuffered = buffered;
+}
+
+#include <iostream>
+//-------------------------------------------------------------------//
+void MacKeyboard::_keyDownCallback( EventRef theEvent )
+{
+	
+	UInt32 virtualKey;
+	OSStatus status;
+	
+	unsigned int time = (unsigned int)GetEventTime(theEvent);
+	
+	status = GetEventParameter(theEvent,
+					'kcod',			// get it in virtual keycode
+					typeUInt32, NULL,	// desired return type
+					sizeof(UInt32), NULL, 	// bufsize
+					&virtualKey );
+	
+	KeyCode kc = keyConversion[virtualKey];
+
+	// record what kind of text we should pass the KeyEvent
+	UniChar text[10];
+	char macChar;
+	
+	// TODO clean this up
+	if (mTextMode == Unicode)
+	{
+		//get string size
+		UInt32 stringsize;
+		//status = GetEventParameter( theEvent, 'kuni', typeUnicodeText, NULL, 0, &stringsize, NULL);
+		//status = GetEventParameter( theEvent, 'kuni', typeUnicodeText, NULL, sizeof(UniChar)*10, NULL, &text );
+		status = GetEventParameter( theEvent, 'kuni', typeUnicodeText, NULL, sizeof(UniChar) * 10, &stringsize, &text );
+		std::cout << "String length: " << stringsize << std::endl;
+		
+		//wstring unitext;
+		//for (int i=0;i<10;i++) unitext += (wchar_t)text[i];
+		//wcout << "Unicode out: " << unitext << endl;
+		
+		if(stringsize > 0)
+		{
+			// for each unicode char, send an event
+			stringsize--; // no termination char
+			for ( int i = 0; i < stringsize; i++ )
+			{
+				injectEvent( kc, time, MAC_KEYDOWN, (unsigned int)text[i] );
+			}
+		}
+	} 
+	else if (mTextMode == Ascii)
+	{
+		 
+		status = GetEventParameter( theEvent, 'kchr', typeChar, NULL, sizeof(char), NULL, &macChar );
+		injectEvent( kc, time, MAC_KEYDOWN, (unsigned int)macChar );
+	}
+	else
+	{
+		injectEvent( kc, time, MAC_KEYDOWN );
+	}
+}
+
+//-------------------------------------------------------------------//
+void MacKeyboard::_keyUpCallback( EventRef theEvent )
+{
+	UInt32 virtualKey;
+	
+	OSStatus status;
+	status = GetEventParameter( theEvent, kEventParamKeyCode, typeUInt32,
+								NULL, sizeof(UInt32), NULL, &virtualKey );
+	
+	KeyCode kc = keyConversion[virtualKey];
+	injectEvent( kc, (int)GetEventTime(theEvent), MAC_KEYUP );
+	
+}
+
+//-------------------------------------------------------------------//
+void MacKeyboard::_modChangeCallback( EventRef theEvent )
+{
+	UInt32 mods;
+	
+	OSStatus status;
+	status = GetEventParameter( theEvent, kEventParamKeyModifiers,
+								typeUInt32, NULL, sizeof(UInt32), NULL, &mods );
+	
+	// find the changed bit
+	UInt32 change = prevModMask ^ mods;
+	MacEventType newstate = ((change & prevModMask) > 0) ? MAC_KEYUP : MAC_KEYDOWN;
+	unsigned int time = (int)GetEventTime( theEvent );
+	
+	//cout << "preMask: " << hex << prevModMask << endl;
+	//cout << "ModMask: " << hex << mods << endl;
+	//cout << "Change:  " << hex << (change & prevModMask) << endl << endl;
+	
+	// TODO test modifiers on a full keyboard to check if different mask for left/right
+	switch (change)
+	{
+		case (shiftKey): // shift
+			mModifiers &= (newstate == MAC_KEYDOWN) ? Shift : ~Shift;
+			injectEvent( KC_LSHIFT, time, newstate );
+			//injectEvent( KC_RSHIFT, time, newstate );
+			break;
+			
+		case (optionKey): // option (alt)
+			mModifiers &= (newstate == MAC_KEYDOWN) ? Alt : -Alt;
+			//injectEvent( KC_RMENU, time, newstate );
+			injectEvent( KC_LMENU, time, newstate );
+			break;
+			
+		case (controlKey): // Ctrl
+			mModifiers += (newstate == MAC_KEYDOWN) ? Ctrl : -Ctrl;
+			//injectEvent( KC_RCONTROL, time, newstate );
+			injectEvent( KC_LCONTROL, time, newstate );
+			break;
+	
+		case (cmdKey): // apple
+			//injectEvent( KC_RWIN, time, newstate );
+			injectEvent( KC_LWIN, time, newstate );
+			break;
+	
+		case (kEventKeyModifierFnMask): // fn key
+			injectEvent( KC_APPS, time, newstate );
+			break;
+			
+		case (kEventKeyModifierNumLockMask): // numlock
+			injectEvent( KC_NUMLOCK, time, newstate );
+			break;
+			
+		case (alphaLock): // caps lock
+			injectEvent( KC_CAPITAL, time, newstate );
+			break;
+	}
+	
+	prevModMask = mods;
+}
+
+//-------------------------------------------------------------------//
+void MacKeyboard::injectEvent( KeyCode kc, unsigned int time, MacEventType type, unsigned int txt )
+{
+	// set to 1 if this is either a keydown or repeat
+	KeyBuffer[kc] = ( type == MAC_KEYUP ) ? 0 : 1;
+	
+	if ( mBuffered && mListener )
+		pendingEvents.push_back( MacKeyStackEvent( KeyEvent(this, kc, txt), type) );
+}
+
+
+//-------------------------------------------------------------------//
+void MacKeyboard::copyKeyStates( char keys[256] ) const
+{
+	memcpy( keys, KeyBuffer, 256 );
+}
+
+
+
+//-------------------------------------------------------------------//
+void MacKeyboard::populateKeyConversion()
+{
+	// TODO finish the key mapping
+	
+	// Virtual Key Map to KeyCode
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x12, KC_1));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x13, KC_2));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x14, KC_3));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x15, KC_4));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x17, KC_5));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x16, KC_6));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x1A, KC_7));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x1C, KC_8));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x19, KC_9));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x1D, KC_0));
+	
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x33, KC_BACK));  // might be wrong
+	
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x1B, KC_MINUS));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x18, KC_EQUALS));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x31, KC_SPACE));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x2B, KC_COMMA));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x2F, KC_PERIOD));
+	
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x2A, KC_BACKSLASH));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x2C, KC_SLASH));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x21, KC_LBRACKET));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x1E, KC_RBRACKET));
+	
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x35, KC_ESCAPE));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x39, KC_CAPITAL));
+	
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x30, KC_TAB));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x24, KC_RETURN));  // double check return/enter
+	
+	//keyConversion.insert(VirtualtoOIS_KeyMap::value_type(XK_colon, KC_COLON));	 // no colon?
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x29, KC_SEMICOLON));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x27, KC_APOSTROPHE));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x32, KC_GRAVE));
+	
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x0B, KC_B));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x00, KC_A));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x08, KC_C));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x02, KC_D));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x0E, KC_E));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x03, KC_F));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x05, KC_G));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x04, KC_H));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x22, KC_I));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x26, KC_J));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x28, KC_K));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x25, KC_L));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x2E, KC_M));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x2D, KC_N));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x1F, KC_O));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x23, KC_P));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x0C, KC_Q));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x0F, KC_R));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x01, KC_S));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x11, KC_T));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x20, KC_U));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x09, KC_V));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x0D, KC_W));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x07, KC_X));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x10, KC_Y));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x06, KC_Z));
+	
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x7A, KC_F1));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x78, KC_F2));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x63, KC_F3));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x76, KC_F4));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x60, KC_F5));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x61, KC_F6));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x62, KC_F7));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x64, KC_F8));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x65, KC_F9));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x6D, KC_F10));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x67, KC_F11));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x6F, KC_F12));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x69, KC_F13));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x6B, KC_F14));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x71, KC_F15));
+	
+	//Keypad
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x52, KC_NUMPAD0));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x53, KC_NUMPAD1));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x54, KC_NUMPAD2));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x55, KC_NUMPAD3));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x56, KC_NUMPAD4));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x57, KC_NUMPAD5));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x58, KC_NUMPAD6));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x59, KC_NUMPAD7));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x5B, KC_NUMPAD8));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x5C, KC_NUMPAD9));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x45, KC_ADD));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x4E, KC_SUBTRACT));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x41, KC_DECIMAL));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x51, KC_NUMPADEQUALS));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x4B, KC_DIVIDE));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x43, KC_MULTIPLY));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x4C, KC_NUMPADENTER));
+	
+	//Keypad with numlock off
+	//keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x73, KC_NUMPAD7));  // not sure of these
+	//keyConversion.insert(VirtualtoOIS_KeyMap::value_type(XK_KP_Up, KC_NUMPAD8)); // check on a non-laptop
+	//keyConversion.insert(VirtualtoOIS_KeyMap::value_type(XK_KP_Page_Up, KC_NUMPAD9));
+	//keyConversion.insert(VirtualtoOIS_KeyMap::value_type(XK_KP_Left, KC_NUMPAD4));
+	//keyConversion.insert(VirtualtoOIS_KeyMap::value_type(XK_KP_Begin, KC_NUMPAD5));
+	//keyConversion.insert(VirtualtoOIS_KeyMap::value_type(XK_KP_Right, KC_NUMPAD6));
+	//keyConversion.insert(VirtualtoOIS_KeyMap::value_type(XK_KP_End, KC_NUMPAD1));
+	//keyConversion.insert(VirtualtoOIS_KeyMap::value_type(XK_KP_Down, KC_NUMPAD2));
+	//keyConversion.insert(VirtualtoOIS_KeyMap::value_type(XK_KP_Page_Down, KC_NUMPAD3));
+	//keyConversion.insert(VirtualtoOIS_KeyMap::value_type(XK_KP_Insert, KC_NUMPAD0));
+	//keyConversion.insert(VirtualtoOIS_KeyMap::value_type(XK_KP_Delete, KC_DECIMAL));
+	
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x7E, KC_UP));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x7D, KC_DOWN));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x7B, KC_LEFT));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x7C, KC_RIGHT));
+	
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x74, KC_PGUP));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x79, KC_PGDOWN));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x73, KC_HOME));
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x77, KC_END));
+	
+	//keyConversion.insert(VirtualtoOIS_KeyMap::value_type(XK_Print, KC_SYSRQ));		// ??
+	//keyConversion.insert(VirtualtoOIS_KeyMap::value_type(XK_Scroll_Lock, KC_SCROLL)); // ??
+	//keyConversion.insert(VirtualtoOIS_KeyMap::value_type(XK_Pause, KC_PAUSE));		// ??
+	
+	
+	//keyConversion.insert(VirtualtoOIS_KeyMap::value_type(XK_Insert, KC_INSERT));	  // ??
+	keyConversion.insert(VirtualtoOIS_KeyMap::value_type(0x75, KC_DELETE)); // del under help key?
+}
+
+
+
+
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/mac/MacMouse.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/mac/MacMouse.cpp
new file mode 100644
index 0000000..d3737d5
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/mac/MacMouse.cpp
@@ -0,0 +1,346 @@
+#include "mac/MacMouse.h"
+#include "mac/MacInputManager.h"
+#include "mac/MacHelpers.h"
+#include "OISException.h"
+#include "OISEvents.h"
+
+#include <Carbon/Carbon.h>
+
+#include <list>
+
+#include <iostream>
+
+using namespace OIS;
+
+//Events we subscribe to and remove from queue
+const EventTypeSpec mouseEvents[] = {
+	{ kEventClassMouse, kEventMouseDown },
+	{ kEventClassMouse, kEventMouseUp },
+	{ kEventClassMouse, kEventMouseMoved },
+	{ kEventClassMouse, kEventMouseDragged },
+	{ kEventClassMouse, kEventMouseWheelMoved }		
+};
+
+const EventTypeSpec WinFocusAcquired [] = {{kEventClassApplication, kEventAppDeactivated}};
+
+//-------------------------------------------------------------------//
+MacMouse::MacMouse( InputManager* creator, bool buffered )
+	: Mouse(creator->inputSystemName(), buffered, 0, creator), mNeedsToRegainFocus( false )
+{
+    mouseEventRef = NULL;
+	mWindowFocusHandler = NULL;
+
+    // Get a "Univeral procedure pointer" for our callback
+    mouseUPP = NewEventHandlerUPP(MouseWrapper);
+	mWindowFocusListener = NewEventHandlerUPP(WindowFocusChanged);
+
+	static_cast<MacInputManager*>(mCreator)->_setMouseUsed(true);
+}
+
+MacMouse::~MacMouse()
+{
+    if(mouseEventRef != NULL)
+		RemoveEventHandler(mouseEventRef);
+
+	if(mWindowFocusHandler != NULL)
+		RemoveEventHandler(mWindowFocusHandler);
+	
+	DisposeEventHandlerUPP(mouseUPP);
+	DisposeEventHandlerUPP(mWindowFocusListener);
+	
+	// Restore Mouse
+	CGAssociateMouseAndMouseCursorPosition(TRUE);
+	CGDisplayShowCursor(kCGDirectMainDisplay);
+
+	static_cast<MacInputManager*>(mCreator)->_setMouseUsed(false);
+}
+
+void MacMouse::_initialize()
+{
+	mState.clear();
+	mTempState.clear();
+	mMouseWarped = false;
+	
+	// Hide OS Mouse
+ 	CGDisplayHideCursor(kCGDirectMainDisplay);
+
+	MacInputManager* im = static_cast<MacInputManager*>(mCreator);
+	WindowRef win = im->_getWindow();
+	
+	if(win)
+	{
+		Rect clipRect = {0.0f, 0.0f, 0.0f, 0.0f};
+		GetWindowBounds(win, kWindowContentRgn, &clipRect);
+		
+		CGPoint warpPoint;
+		warpPoint.x = ((clipRect.right - clipRect.left) / 2) + clipRect.left;
+		warpPoint.y = ((clipRect.bottom - clipRect.top) / 2) + clipRect.top;
+		CGDisplayMoveCursorToPoint(kCGDirectMainDisplay, warpPoint); //Place at display origin
+		
+		mMouseWarped = true;
+	}
+
+	//Now that mouse is warped, start listening for events
+	EventTargetRef event = ((MacInputManager*)mCreator)->_getEventTarget();
+    
+	if(mouseEventRef != NULL)
+		RemoveEventHandler(mouseEventRef);
+		
+	if(mWindowFocusHandler != NULL)
+		RemoveEventHandler(mWindowFocusHandler);
+
+	mouseEventRef = mWindowFocusHandler = NULL;
+
+	if(InstallEventHandler(event, mouseUPP, GetEventTypeCount(mouseEvents), mouseEvents, this, &mouseEventRef) != noErr)
+		OIS_EXCEPT( E_General, "MacMouse::_initialize >> Error loading Mouse event handler" );
+
+	if(InstallEventHandler(event, mWindowFocusListener, GetEventTypeCount(WinFocusAcquired), WinFocusAcquired, this, &mWindowFocusHandler) != noErr)
+		OIS_EXCEPT( E_General, "MacMouse::_initialize >> Error loading Mouse event handler" );		
+
+	//Lock OS Mouse movement
+	mNeedsToRegainFocus = false;
+	CGAssociateMouseAndMouseCursorPosition(FALSE);
+}
+
+OSStatus MacMouse::WindowFocusChanged(EventHandlerCallRef nextHandler, EventRef event, void* macMouse)
+{
+	//std::cout << "Window Focus Changed\n";
+
+	MacMouse* _this = static_cast<MacMouse*>(macMouse);
+    if (_this)
+	{
+		_this->mNeedsToRegainFocus = true;
+		CGAssociateMouseAndMouseCursorPosition(TRUE);
+
+        // propagate the event down the chain
+        return CallNextEventHandler(nextHandler, event);
+    }
+    else
+        OIS_EXCEPT(E_General, "MouseWrapper >> Being called by something other than our event handler!");
+}
+
+void MacMouse::setBuffered( bool buffered )
+{
+	mBuffered = buffered;
+}
+
+void MacMouse::capture()
+{
+	mState.X.rel = 0;
+	mState.Y.rel = 0;
+	mState.Z.rel = 0;
+	    
+	if(mTempState.X.rel || mTempState.Y.rel || mTempState.Z.rel)
+	{
+		//printf("%i %i %i\n\n", mTempState.X.rel, mTempState.Y.rel, mTempState.Z.rel);
+
+		//Set new relative motion values
+		mState.X.rel = mTempState.X.rel;
+		mState.Y.rel = mTempState.Y.rel;
+		mState.Z.rel = mTempState.Z.rel;
+		
+		//Update absolute position
+		mState.X.abs += mTempState.X.rel;
+		mState.Y.abs += mTempState.Y.rel;
+		
+		if(mState.X.abs > mState.width)
+			mState.X.abs = mState.width;
+		else if(mState.X.abs < 0)
+			mState.X.abs = 0;
+
+		if(mState.Y.abs > mState.height)
+			mState.Y.abs = mState.height;
+		else if(mState.Y.abs < 0)
+			mState.Y.abs = 0;
+			
+		mState.Z.abs += mTempState.Z.rel;
+		
+		//Fire off event
+		if(mListener && mBuffered)
+			mListener->mouseMoved(MouseEvent(this, mState));
+	}
+
+	mTempState.clear();
+}
+
+void MacMouse::_mouseCallback( EventRef theEvent )
+{
+	OSStatus result = eventNotHandledErr;
+    UInt32 kind = GetEventKind (theEvent);
+
+	switch(kind)
+	{
+		case kEventMouseDragged:
+		case kEventMouseMoved:
+		{
+			//HIPoint location = {0.0f, 0.0f};
+			HIPoint delta = {0.0f, 0.0f};
+			//Rect clipRect = {0.0f, 0.0f, 0.0f, 0.0f};
+			
+			if(mNeedsToRegainFocus)
+				break;
+
+			// Capture the parameters
+			// TODO: Look into HIViewNewTrackingArea
+			//GetEventParameter(theEvent, kEventParamMouseLocation, typeHIPoint, NULL, sizeof(HIPoint), NULL, &location);
+			GetEventParameter(theEvent, kEventParamMouseDelta, typeHIPoint, NULL, sizeof(HIPoint), NULL, &delta);
+			
+			// Mouse X and Y are the position on the screen, 
+			// startng from top-left at 0,0 caps at full monitor resolution
+			
+			// If we have a window we need to return adjusted coordinates
+			// If not, just use raw coordinates - only do this if showing OS mouse
+			//MacInputManager* im = static_cast<MacInputManager*>(mCreator);
+			//WindowRef win = im->_getWindow();
+			
+			//if(win != NULL)
+			//{
+			//	GetWindowBounds(win, kWindowContentRgn, &clipRect);
+			//}
+            //else
+            //{
+            //    clipRect.right = mState.width;
+            //    clipRect.bottom = mState.height;
+            //}
+                
+            // clip the mouse, absolute positioning
+            //if (location.x <= clipRect.left)
+			//	mState.X.abs = 0;
+			//else if(location.x >= clipRect.right)
+			//	mState.X.abs = clipRect.right - clipRect.left;
+			//else
+			//	mState.X.abs = location.x - clipRect.left;
+			
+			//if (location.y <= clipRect.top)
+			//	mState.Y.abs = 0;
+			//else if(location.y >= clipRect.bottom)
+			//	mState.Y.abs = clipRect.bottom - clipRect.top;
+			//else
+			//	mState.Y.abs = location.y - clipRect.top;
+			
+			// relative positioning
+			if(!mMouseWarped)
+			{
+				mTempState.X.rel += delta.x;
+				mTempState.Y.rel += delta.y;
+			}
+			
+			mMouseWarped = false;
+
+			break;
+		}
+		case kEventMouseDown:
+		{
+			EventMouseButton button = 0;
+			int mouseButton = 3;
+			UInt32 modifiers = 0;
+			
+			if(mNeedsToRegainFocus)
+				break;
+
+			// Capture parameters
+			GetEventParameter(theEvent, kEventParamMouseButton, typeMouseButton, NULL, sizeof(EventMouseButton), NULL, &button);
+			GetEventParameter(theEvent, kEventParamKeyModifiers, typeUInt32, NULL, sizeof(UInt32), NULL, &modifiers);
+			
+			if((button == kEventMouseButtonTertiary) || ((button == kEventMouseButtonPrimary) && (modifiers & optionKey)))
+			{
+				mouseButton = 2;
+				mState.buttons |= 1 << mouseButton;
+			}
+            else if((button == kEventMouseButtonSecondary) || ((button == kEventMouseButtonPrimary) && (modifiers & controlKey)))
+            {	
+                mouseButton = 1;
+                mState.buttons |= 1 << mouseButton;
+            }
+            else if(button == kEventMouseButtonPrimary)
+            {
+                mouseButton = 0;
+                mState.buttons |= 1 << mouseButton;
+            }
+
+            if( mListener && mBuffered )
+                mListener->mousePressed( MouseEvent( this, mState ), (MouseButtonID)mouseButton );
+
+            break;
+		}
+		case kEventMouseUp:
+		{
+			EventMouseButton button = 0;
+			int mouseButton = 3;
+			UInt32 modifiers = 0;
+			
+			if(mNeedsToRegainFocus)
+			{
+				mNeedsToRegainFocus = false;
+				CGAssociateMouseAndMouseCursorPosition(false);
+				
+				MacInputManager* im = static_cast<MacInputManager*>(mCreator);
+				WindowRef win = im->_getWindow();
+				
+				if(win)
+				{
+					Rect clipRect = {0.0f, 0.0f, 0.0f, 0.0f};
+					GetWindowBounds(win, kWindowContentRgn, &clipRect);
+					
+					CGPoint warpPoint;
+					warpPoint.x = ((clipRect.right - clipRect.left) / 2) + clipRect.left;
+					warpPoint.y = ((clipRect.bottom - clipRect.top) / 2) + clipRect.top;
+					CGDisplayMoveCursorToPoint(kCGDirectMainDisplay, warpPoint); //Place at display origin
+					
+					CGDisplayHideCursor(kCGDirectMainDisplay);
+					
+					mMouseWarped = true;
+				}
+				
+				//Once we regain focus, we do not really know what state all the buttons are in - for now, set to not pressed. todo, check current status
+				//compare against old status, and send off any needed events
+				mState.buttons = 0;
+				
+				break;
+			}
+			
+			// Capture parameters
+			GetEventParameter(theEvent, kEventParamMouseButton, typeMouseButton, NULL, sizeof(EventMouseButton), NULL, &button);
+			GetEventParameter(theEvent, kEventParamKeyModifiers, typeUInt32, NULL, sizeof(UInt32), NULL, &modifiers);
+			
+			if ((button == kEventMouseButtonTertiary) || ((button == kEventMouseButtonPrimary) && (modifiers & optionKey)))
+			{
+				mouseButton = 2;
+				mState.buttons &= ~(1 << mouseButton);
+			}
+            else if ((button == kEventMouseButtonSecondary) || ((button == kEventMouseButtonPrimary) && (modifiers & controlKey)))
+            {	
+                mouseButton = 1;
+                mState.buttons &= ~(1 << mouseButton);
+            }
+            else if (button == kEventMouseButtonPrimary)
+            {
+                mouseButton = 0;
+                mState.buttons &= ~(1 << mouseButton);
+            }
+
+            if( mListener && mBuffered )
+                mListener->mouseReleased( MouseEvent( this, mState ), (MouseButtonID)mouseButton );
+
+            break;
+		}
+		case kEventMouseWheelMoved:
+		{
+			SInt32 wheelDelta = 0;
+			EventMouseWheelAxis	wheelAxis = 0; 
+
+			// Capture parameters
+			GetEventParameter(theEvent, kEventParamMouseWheelAxis, typeMouseWheelAxis, NULL, sizeof(EventMouseWheelAxis), NULL, &wheelAxis);
+			GetEventParameter(theEvent, kEventParamMouseWheelDelta, typeSInt32, NULL, sizeof(SInt32), NULL, &wheelDelta);
+			
+			// If the Y axis of the wheel changed, then update the Z
+			// Does OIS care about the X wheel axis?
+			if(wheelAxis == kEventMouseWheelAxisY)
+				mTempState.Z.rel += (wheelDelta * 60);
+
+            break;
+		}
+		default:
+			break;
+	}    
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/Win32ForceFeedback.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/Win32ForceFeedback.cpp
new file mode 100644
index 0000000..9f86b5b
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/Win32ForceFeedback.cpp
@@ -0,0 +1,543 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that
+		you wrote the original software. If you use this software in a product,
+		an acknowledgment in the product documentation would be appreciated but is
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "win32/Win32ForceFeedback.h"
+#include "OISException.h"
+#include <math.h>
+
+// 0 = No trace; 1 = Important traces; 2 = Debug traces
+#define OIS_WIN32_JOYFF_DEBUG 1
+
+#if (defined (_DEBUG) || defined(OIS_WIN32_JOYFF_DEBUG))
+  #include <iostream>
+  #include <sstream>
+  using namespace std;
+#endif
+
+using namespace OIS;
+
+//--------------------------------------------------------------//
+Win32ForceFeedback::Win32ForceFeedback(IDirectInputDevice8* pDIJoy, const DIDEVCAPS* pDIJoyCaps) :
+  mHandles(0), mJoyStick(pDIJoy), mFFAxes(0), mpDIJoyCaps(pDIJoyCaps)
+{
+#if (OIS_WIN32_JOYFF_DEBUG > 0)
+  cout << "FFSamplePeriod      : " << mpDIJoyCaps->dwFFSamplePeriod << " mu-s, "
+	   << "FFMinTimeResolution : " << mpDIJoyCaps->dwFFMinTimeResolution << " mu-s,"
+	   << "" << endl;
+#endif
+}
+
+//--------------------------------------------------------------//
+Win32ForceFeedback::~Win32ForceFeedback()
+{
+	//Get the effect - if it exists
+	for(EffectList::iterator i = mEffectList.begin(); i != mEffectList.end(); ++i )
+	{
+		LPDIRECTINPUTEFFECT dxEffect = i->second;
+		if( dxEffect )
+		{
+			dxEffect->Unload();
+			dxEffect->Release();
+		}
+	}
+
+	mEffectList.clear();
+}
+
+//--------------------------------------------------------------//
+short Win32ForceFeedback::getFFAxesNumber()
+{
+	return mFFAxes;
+}
+
+//--------------------------------------------------------------//
+unsigned short Win32ForceFeedback::getFFMemoryLoad()
+{
+    DIPROPDWORD dipdw;  // DIPROPDWORD contains a DIPROPHEADER structure. 
+	dipdw.diph.dwSize       = sizeof(DIPROPDWORD); 
+	dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER); 
+	dipdw.diph.dwObj        = 0; // device property 
+	dipdw.diph.dwHow        = DIPH_DEVICE;
+	dipdw.dwData            = 0; // In case of any error.
+
+	const HRESULT hr = mJoyStick->GetProperty(DIPROP_FFLOAD, &dipdw.diph);
+	if(FAILED(hr))
+	{
+	    if (hr == DIERR_NOTEXCLUSIVEACQUIRED)
+		    OIS_EXCEPT(E_General, "Can't query FF memory load as device was not acquired in exclusive mode");
+		else
+		    OIS_EXCEPT(E_General, "Unknown error querying FF memory load ->..");
+	}
+
+	return (unsigned short)dipdw.dwData;
+}
+
+//--------------------------------------------------------------//
+void Win32ForceFeedback::upload( const Effect* effect )
+{
+	switch( effect->force )
+	{
+		case OIS::Effect::ConstantForce: _updateConstantEffect(effect);	break;
+		case OIS::Effect::RampForce: _updateRampEffect(effect);	break;
+		case OIS::Effect::PeriodicForce: _updatePeriodicEffect(effect);	break;
+		case OIS::Effect::ConditionalForce:	_updateConditionalEffect(effect); break;
+		//case OIS::Effect::CustomForce: _updateCustomEffect(effect); break;
+		default: OIS_EXCEPT(E_NotImplemented, "Requested Force not Implemented yet, sorry!"); break;
+	}
+}
+
+//--------------------------------------------------------------//
+void Win32ForceFeedback::modify( const Effect* eff )
+{
+	//Modifying is essentially the same as an upload, so, just reuse that function
+	upload(eff);
+}
+
+//--------------------------------------------------------------//
+void Win32ForceFeedback::remove( const Effect* eff )
+{
+	//Get the effect - if it exists
+	EffectList::iterator i = mEffectList.find(eff->_handle);
+	if( i != mEffectList.end() )
+	{
+		LPDIRECTINPUTEFFECT dxEffect = i->second;
+		if( dxEffect )
+		{
+			dxEffect->Stop();
+			//We care about the return value - as the effect might not
+			//have been unlaoded
+			if( SUCCEEDED(dxEffect->Unload()) )
+			{
+			    dxEffect->Release();
+				mEffectList.erase(i);
+			}
+		}
+		else
+			mEffectList.erase(i);
+	}
+}
+
+//--------------------------------------------------------------//
+void Win32ForceFeedback::setMasterGain( float level )
+{
+	//Between 0 - 10,000
+	int gain_level = (int)(10000.0f * level);
+
+	if( gain_level > 10000 )
+		gain_level = 10000;
+	else if( gain_level < 0 )
+		gain_level = 0;
+
+	DIPROPDWORD DIPropGain;
+	DIPropGain.diph.dwSize       = sizeof(DIPropGain);
+	DIPropGain.diph.dwHeaderSize = sizeof(DIPROPHEADER);
+	DIPropGain.diph.dwObj        = 0;
+	DIPropGain.diph.dwHow        = DIPH_DEVICE;
+	DIPropGain.dwData            = gain_level;
+
+#if (OIS_WIN32_JOYFF_DEBUG > 0)
+	cout << "Win32ForceFeedback("<< mJoyStick << ") : Setting master gain to " 
+		 << level << " => " << DIPropGain.dwData << endl;
+#endif
+
+	const HRESULT hr = mJoyStick->SetProperty(DIPROP_FFGAIN, &DIPropGain.diph);
+
+#if defined (_DEBUG)
+	if(FAILED(hr))
+	    cout << "Failed to change master gain" << endl;
+#endif
+}
+
+//--------------------------------------------------------------//
+void Win32ForceFeedback::setAutoCenterMode( bool auto_on )
+{
+	DIPROPDWORD DIPropAutoCenter;
+	DIPropAutoCenter.diph.dwSize       = sizeof(DIPropAutoCenter);
+	DIPropAutoCenter.diph.dwHeaderSize = sizeof(DIPROPHEADER);
+	DIPropAutoCenter.diph.dwObj        = 0;
+	DIPropAutoCenter.diph.dwHow        = DIPH_DEVICE;
+	DIPropAutoCenter.dwData            = (auto_on ? DIPROPAUTOCENTER_ON : DIPROPAUTOCENTER_OFF);
+
+#if (OIS_WIN32_JOYFF_DEBUG > 0)
+	cout << "Win32ForceFeedback("<< mJoyStick << ") : Setting auto-center mode to " 
+		 << auto_on << " => " << DIPropAutoCenter.dwData << endl;
+#endif
+
+	const HRESULT hr = mJoyStick->SetProperty(DIPROP_AUTOCENTER, &DIPropAutoCenter.diph);
+
+#if defined (_DEBUG)
+	if(FAILED(hr))
+	    cout << "Failed to change auto-center mode" << endl;
+#endif
+}
+
+//--------------------------------------------------------------//
+void Win32ForceFeedback::_updateConstantEffect( const Effect* effect )
+{
+	ConstantEffect *eff = static_cast<ConstantEffect*>(effect->getForceEffect());
+
+	DWORD           rgdwAxes[2]     = { DIJOFS_X, DIJOFS_Y };
+	LONG            rglDirection[2] = { 0, 0 };
+	DIENVELOPE      diEnvelope;
+	DICONSTANTFORCE cf;
+	DIEFFECT        diEffect;
+
+	//Currently only support 1 axis
+	//if( effect->getNumAxes() == 1 )
+	cf.lMagnitude = eff->level;
+
+#if (OIS_WIN32_JOYFF_DEBUG > 1)
+	cout << "  Level : " << eff->level
+		 << " => " << cf.lMagnitude << endl;
+#endif
+
+	_setCommonProperties(&diEffect, rgdwAxes, rglDirection, &diEnvelope, sizeof(DICONSTANTFORCE), &cf, effect, &eff->envelope);
+	_upload(GUID_ConstantForce, &diEffect, effect);
+}
+
+//--------------------------------------------------------------//
+void Win32ForceFeedback::_updateRampEffect( const Effect* effect )
+{
+	RampEffect *eff = static_cast<RampEffect*>(effect->getForceEffect());
+
+	DWORD           rgdwAxes[2]     = { DIJOFS_X, DIJOFS_Y };
+	LONG            rglDirection[2] = { 0, 0 };
+	DIENVELOPE      diEnvelope;
+	DIRAMPFORCE     rf;
+	DIEFFECT        diEffect;
+
+	//Currently only support 1 axis
+	rf.lStart = eff->startLevel;
+	rf.lEnd = eff->endLevel;
+
+	_setCommonProperties(&diEffect, rgdwAxes, rglDirection, &diEnvelope, sizeof(DIRAMPFORCE), &rf, effect, &eff->envelope );
+	_upload(GUID_RampForce, &diEffect, effect);
+}
+
+//--------------------------------------------------------------//
+void Win32ForceFeedback::_updatePeriodicEffect( const Effect* effect )
+{
+	PeriodicEffect *eff = static_cast<PeriodicEffect*>(effect->getForceEffect());
+
+	DWORD           rgdwAxes[2]     = { DIJOFS_X, DIJOFS_Y };
+	LONG            rglDirection[2] = { 0, 0 };
+	DIENVELOPE      diEnvelope;
+	DIPERIODIC      pf;
+	DIEFFECT        diEffect;
+
+	//Currently only support 1 axis
+	pf.dwMagnitude = eff->magnitude;
+	pf.lOffset = eff->offset;
+	pf.dwPhase = eff->phase;
+	pf.dwPeriod = eff->period;
+
+	_setCommonProperties(&diEffect, rgdwAxes, rglDirection, &diEnvelope, sizeof(DIPERIODIC), &pf, effect, &eff->envelope );
+
+	switch( effect->type )
+	{
+	case OIS::Effect::Square: _upload(GUID_Square, &diEffect, effect); break;
+	case OIS::Effect::Triangle: _upload(GUID_Triangle, &diEffect, effect); break;
+	case OIS::Effect::Sine: _upload(GUID_Sine, &diEffect, effect); break;
+	case OIS::Effect::SawToothUp: _upload(GUID_SawtoothUp, &diEffect, effect); break;
+	case OIS::Effect::SawToothDown:	_upload(GUID_SawtoothDown, &diEffect, effect); break;
+	default: break;
+	}
+}
+
+//--------------------------------------------------------------//
+void Win32ForceFeedback::_updateConditionalEffect( const Effect* effect )
+{
+	ConditionalEffect *eff = static_cast<ConditionalEffect*>(effect->getForceEffect());
+
+	DWORD           rgdwAxes[2]     = { DIJOFS_X, DIJOFS_Y };
+	LONG            rglDirection[2] = { 0, 0 };
+	DIENVELOPE      diEnvelope;
+	DICONDITION     cf;
+	DIEFFECT        diEffect;
+
+	cf.lOffset = eff->deadband;
+	cf.lPositiveCoefficient = eff->rightCoeff;
+	cf.lNegativeCoefficient = eff->leftCoeff;
+	cf.dwPositiveSaturation = eff->rightSaturation;
+	cf.dwNegativeSaturation = eff->leftSaturation;
+	cf.lDeadBand = eff->deadband;
+
+	_setCommonProperties(&diEffect, rgdwAxes, rglDirection, &diEnvelope, sizeof(DICONDITION), &cf, effect, 0 );
+
+	switch( effect->type )
+	{
+	case OIS::Effect::Friction:	_upload(GUID_Friction, &diEffect, effect); break;
+	case OIS::Effect::Damper: _upload(GUID_Damper, &diEffect, effect); break;
+	case OIS::Effect::Inertia: _upload(GUID_Inertia, &diEffect, effect); break;
+	case OIS::Effect::Spring: _upload(GUID_Spring, &diEffect, effect); break;
+	default: break;
+	}
+}
+
+//--------------------------------------------------------------//
+void Win32ForceFeedback::_updateCustomEffect( const Effect* /*effect*/ )
+{
+    //CustomEffect *eff = static_cast<CustomEffect*>(effect->getForceEffect());
+    //
+	//DWORD           rgdwAxes[2]     = { DIJOFS_X, DIJOFS_Y };
+	//LONG            rglDirection[2] = { 0, 0 };
+	//DIENVELOPE      diEnvelope;
+	//DICUSTOMFORCE cf;
+	//DIEFFECT        diEffect;
+	//cf.cChannels = 0;
+	//cf.dwSamplePeriod = 0;
+	//cf.cSamples = 0;
+	//cf.rglForceData = 0;
+	//_setCommonProperties(&diEffect, rgdwAxes, rglDirection, &diEnvelope, sizeof(DICUSTOMFORCE), &cf, effect, &eff->envelope);
+	//_upload(GUID_CustomForce, &diEffect, effect);
+}
+
+//--------------------------------------------------------------//
+void Win32ForceFeedback::_setCommonProperties(
+		DIEFFECT* diEffect, DWORD* rgdwAxes,
+		LONG* rglDirection, DIENVELOPE* diEnvelope, DWORD struct_size,
+		LPVOID struct_type, const Effect* effect, const Envelope* envelope )
+{
+	ZeroMemory(diEffect, sizeof(DIEFFECT));
+
+	diEffect->dwSize                  = sizeof(DIEFFECT);
+	diEffect->dwFlags                 = DIEFF_CARTESIAN | DIEFF_OBJECTOFFSETS;
+	diEffect->dwGain                  = DI_FFNOMINALMAX;
+
+	diEffect->dwTriggerButton         = DIEB_NOTRIGGER; // effect->trigger_button; // TODO: Conversion
+	diEffect->dwTriggerRepeatInterval = effect->trigger_interval;
+
+#if (OIS_WIN32_JOYFF_DEBUG > 1)
+	cout << "  Trigger :" << endl
+		 << "    Button   : " << effect->trigger_button 
+		 << " => " << diEffect->dwTriggerButton << endl
+		 << "    Interval : " << effect->trigger_interval 
+		 << " => " << diEffect->dwTriggerRepeatInterval << endl;
+#endif
+
+	diEffect->cAxes                   = 1; // effect->getNumAxes();
+	diEffect->rgdwAxes                = rgdwAxes;
+
+	diEffect->rglDirection            = rglDirection; // TODO: conversion from effect->direction
+
+#if (OIS_WIN32_JOYFF_DEBUG > 1)
+	cout << "  Direction : " << Effect::getDirectionName(effect->direction)
+		 << " => {";
+	for (int iDir=0; iDir < (int)diEffect->cAxes; iDir++)
+	  cout << " " << diEffect->rglDirection[iDir];
+	cout << "}" << endl;
+#endif
+
+	if (diEnvelope && envelope && envelope->isUsed())
+	{
+	    diEnvelope->dwSize = sizeof(DIENVELOPE);
+	    diEnvelope->dwAttackLevel = envelope->attackLevel;
+	    diEnvelope->dwAttackTime  = envelope->attackLength;
+	    diEnvelope->dwFadeLevel   = envelope->fadeLevel;
+	    diEnvelope->dwFadeTime    = envelope->fadeLength;
+	    diEffect->lpEnvelope = diEnvelope;
+	}
+	else
+	    diEffect->lpEnvelope = 0;
+
+#if (OIS_WIN32_JOYFF_DEBUG > 1)
+	if (diEnvelope && envelope && envelope->isUsed())
+	{
+		cout << "  Enveloppe :" << endl
+			 << "    AttackLen : " << envelope->attackLength
+			 << " => " << diEnvelope->dwAttackTime << endl 
+			 << "    AttackLvl : " << envelope->attackLevel
+			 << " => " << diEnvelope->dwAttackLevel << endl 
+			 << "    FadeLen   : " << envelope->fadeLength
+			 << " => " << diEnvelope->dwFadeTime << endl
+			 << "    FadeLvl   : " << envelope->fadeLevel
+			 << " => " << diEnvelope->dwFadeLevel << endl;
+	}
+#endif
+
+	diEffect->dwSamplePeriod          = 0;
+	diEffect->dwDuration              = effect->replay_length;
+	diEffect->dwStartDelay            = effect->replay_delay;
+
+#if (OIS_WIN32_JOYFF_DEBUG > 1)
+	cout << "  Replay :" << endl
+		 << "    Length : " << effect->replay_length 
+		 << " => " << diEffect->dwDuration << endl
+		 << "    Delay  : " << effect->replay_delay 
+		 << " => " << diEffect->dwStartDelay << endl;
+#endif
+
+	diEffect->cbTypeSpecificParams    = struct_size;
+	diEffect->lpvTypeSpecificParams   = struct_type;
+}
+
+//--------------------------------------------------------------//
+void Win32ForceFeedback::_upload( GUID guid, DIEFFECT* diEffect, const Effect* effect)
+{
+	LPDIRECTINPUTEFFECT dxEffect = 0;
+
+	//Get the effect - if it exists
+	EffectList::iterator i = mEffectList.find(effect->_handle);
+	//It has been created already
+	if( i != mEffectList.end() )
+		dxEffect = i->second;
+	else //This effect has not yet been created - generate a handle
+		effect->_handle = mHandles++;
+
+	if( dxEffect == 0 )
+	{
+		//This effect has not yet been created, so create it
+		HRESULT hr = mJoyStick->CreateEffect(guid, diEffect, &dxEffect, NULL);
+		if(SUCCEEDED(hr))
+		{
+			mEffectList[effect->_handle] = dxEffect;
+			dxEffect->Start(INFINITE,0);
+		}
+		else if( hr == DIERR_DEVICEFULL )
+			OIS_EXCEPT(E_DeviceFull, "Remove an effect before adding more!");
+		else
+			OIS_EXCEPT(E_General, "Unknown error creating effect->..");
+	}
+	else
+	{
+		//ToDo -- Update the Effect
+		HRESULT hr = dxEffect->SetParameters( diEffect, DIEP_DIRECTION |
+			DIEP_DURATION | DIEP_ENVELOPE | DIEP_STARTDELAY | DIEP_TRIGGERBUTTON |
+			DIEP_TRIGGERREPEATINTERVAL | DIEP_TYPESPECIFICPARAMS | DIEP_START );
+
+		if(FAILED(hr)) OIS_EXCEPT(E_InvalidParam, "Error updating device!");
+	}
+}
+
+//--------------------------------------------------------------//
+void Win32ForceFeedback::_addEffectSupport( LPCDIEFFECTINFO pdei )
+{
+#if (OIS_WIN32_JOYFF_DEBUG > 0)
+    // Dump some usefull information about the effect type.
+    cout << "Adding support for '" << pdei->tszName << "' effect type" << endl;
+	cout << "  Supported static params: ";
+	if (pdei->dwStaticParams & DIEP_AXES) cout << " Axes";
+	if (pdei->dwStaticParams & DIEP_DIRECTION) cout << " Direction";
+	if (pdei->dwStaticParams & DIEP_DURATION) cout << " Duration";
+	if (pdei->dwStaticParams & DIEP_ENVELOPE) cout << " Envelope";
+	if (pdei->dwStaticParams & DIEP_GAIN) cout << " Gain";
+	if (pdei->dwStaticParams & DIEP_SAMPLEPERIOD) cout << " SamplePeriod";
+	if (pdei->dwStaticParams & DIEP_STARTDELAY) cout << " StartDelay";
+	if (pdei->dwStaticParams & DIEP_TRIGGERBUTTON) cout << " TriggerButton";
+	if (pdei->dwStaticParams & DIEP_TRIGGERREPEATINTERVAL) cout << " TriggerRepeatInterval";
+	if (pdei->dwStaticParams & DIEP_TYPESPECIFICPARAMS) cout << " TypeSpecificParams";
+	cout << endl;
+	cout << "  Supported dynamic params: ";
+	if (pdei->dwDynamicParams & DIEP_AXES) cout << " Axes";
+	if (pdei->dwDynamicParams & DIEP_DIRECTION) cout << " Direction";
+	if (pdei->dwDynamicParams & DIEP_DURATION) cout << " Duration";
+	if (pdei->dwDynamicParams & DIEP_ENVELOPE) cout << " Envelope";
+	if (pdei->dwDynamicParams & DIEP_GAIN) cout << " Gain";
+	if (pdei->dwDynamicParams & DIEP_SAMPLEPERIOD) cout << " SamplePeriod";
+	if (pdei->dwDynamicParams & DIEP_STARTDELAY) cout << " StartDelay";
+	if (pdei->dwDynamicParams & DIEP_TRIGGERBUTTON) cout << " TriggerButton";
+	if (pdei->dwDynamicParams & DIEP_TRIGGERREPEATINTERVAL) cout << " TriggerRepeatInterval";
+	if (pdei->dwDynamicParams & DIEP_TYPESPECIFICPARAMS) cout << " TypeSpecificParams";
+	cout << endl;
+	cout << "  More details about supported parameters support: ";
+	if (pdei->dwEffType & DIEFT_STARTDELAY) cout << " StartDelay";
+	if (pdei->dwEffType & DIEFT_FFATTACK) cout << " Attack";
+	if (pdei->dwEffType & DIEFT_FFFADE) cout << " Fade";
+	if (pdei->dwEffType & DIEFT_DEADBAND) cout << " DeadBand";
+	if (pdei->dwEffType & DIEFT_SATURATION) cout << " Saturation";
+	if (pdei->dwEffType & DIEFT_POSNEGSATURATION) cout << " PosNegaturation";
+	if (pdei->dwEffType & DIEFT_POSNEGCOEFFICIENTS) cout << " PosNegCoefficients";
+	if (pdei->dwEffType & DIEFT_HARDWARE) cout << " HardwareSpecific";
+	cout << endl;
+#endif
+
+    Effect::EForce eForce;
+	switch (DIEFT_GETTYPE(pdei->dwEffType))
+	{
+	    case DIEFT_CONSTANTFORCE:
+		    eForce = Effect::ConstantForce;
+			break;
+	    case DIEFT_RAMPFORCE:
+		    eForce = Effect::RampForce;
+			break;
+	    case DIEFT_PERIODIC:
+		    eForce = Effect::PeriodicForce;
+			break;
+	    case DIEFT_CONDITION:
+		    eForce = Effect::ConditionalForce;
+			break;
+	    case DIEFT_CUSTOMFORCE:
+		    eForce = Effect::CustomForce;
+			break;
+	    default:
+		    eForce = Effect::UnknownForce;
+#if defined (_DEBUG)
+			cout << "Win32ForceFeedback: DirectInput8 Effect type support not implemented: " 
+				 << "DIEFT_GETTYPE="<< (int)DIEFT_GETTYPE(pdei->dwEffType) << endl;
+#endif
+			return;
+	}
+
+	//Determine what the effect type is and how it corresponds to our OIS's Enums
+	//We could save the GUIDs too, however, we will just use the predefined ones later
+	if( pdei->guid == GUID_ConstantForce )
+		_addEffectTypes(eForce, Effect::Constant );
+	else if( pdei->guid == GUID_Triangle )
+		_addEffectTypes(eForce, Effect::Triangle );
+	else if( pdei->guid == GUID_Spring )
+		_addEffectTypes(eForce, Effect::Spring );
+	else if( pdei->guid == GUID_Friction )
+		_addEffectTypes(eForce, Effect::Friction );
+	else if( pdei->guid == GUID_Square )
+		_addEffectTypes(eForce, Effect::Square );
+	else if( pdei->guid == GUID_Sine )
+		_addEffectTypes(eForce, Effect::Sine );
+	else if( pdei->guid == GUID_SawtoothUp )
+		_addEffectTypes(eForce, Effect::SawToothUp );
+	else if( pdei->guid == GUID_SawtoothDown )
+		_addEffectTypes(eForce, Effect::SawToothDown );
+	else if( pdei->guid == GUID_Damper )
+		_addEffectTypes(eForce, Effect::Damper );
+	else if( pdei->guid == GUID_Inertia )
+		_addEffectTypes(eForce, Effect::Inertia );
+	else if( pdei->guid == GUID_CustomForce )
+		_addEffectTypes(eForce, Effect::Custom );
+	else if( pdei->guid == GUID_RampForce )
+		_addEffectTypes(eForce, Effect::Ramp );
+
+#if defined (_DEBUG)
+	//Only care about this for Debugging Purposes
+	//else
+	//{
+	//	std::ostringstream ss;
+	//	ss << "Win32ForceFeedback, DirectInput8 Effect not found. Reported as: "
+	//	   << pdei->tszName;
+	//	OIS_EXCEPT( E_General, ss.str().c_str());
+	//}
+#endif
+}
+
+//--------------------------------------------------------------//
+void Win32ForceFeedback::_addFFAxis()
+{
+	mFFAxes++;
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/Win32InputManager.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/Win32InputManager.cpp
new file mode 100644
index 0000000..be4b8d5
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/Win32InputManager.cpp
@@ -0,0 +1,280 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "win32/Win32InputManager.h"
+#include "win32/Win32KeyBoard.h"
+#include "win32/Win32Mouse.h"
+#include "win32/Win32JoyStick.h"
+#include "OISException.h"
+
+using namespace OIS;
+
+//--------------------------------------------------------------------------------//
+Win32InputManager::Win32InputManager() : InputManager("Win32InputManager")
+{
+	hWnd = 0;
+	mDirectInput = 0;
+
+	kbSettings    = 0;
+	mouseSettings = 0;
+	joySettings   = 0;
+
+	joySticks = 0;
+	keyboardUsed = mouseUsed = false;
+
+	//Setup our internal factories
+	mFactories.push_back(this);
+}
+
+//--------------------------------------------------------------------------------//
+Win32InputManager::~Win32InputManager()
+{
+	if( mDirectInput )
+	{
+		mDirectInput->Release();
+		mDirectInput = 0;
+	}
+}
+
+//--------------------------------------------------------------------------------//
+void Win32InputManager::_initialize( ParamList &paramList )
+{
+	HINSTANCE hInst = 0;
+	HRESULT hr;
+
+
+	//First of all, get the Windows Handle and Instance
+	ParamList::iterator i = paramList.find("WINDOW");
+	if( i == paramList.end() ) 
+		OIS_EXCEPT( E_InvalidParam, "Win32InputManager::Win32InputManager >> No HWND found!" );
+
+	// Get number as 64 bit and then convert. Handles the case of 32 or 64 bit HWND
+#ifdef _MSC_VER
+	unsigned __int64 handle = _strtoui64(i->second.c_str(), 0, 10);
+#else
+	unsigned __int64 handle = strtoull(i->second.c_str(), 0, 10);
+#endif
+	hWnd  = (HWND)handle;
+
+	if( IsWindow(hWnd) == 0 )
+		OIS_EXCEPT( E_General, "Win32InputManager::Win32InputManager >> The sent HWND is not valid!");
+
+	hInst = GetModuleHandle(0);
+
+	//Create the device
+	hr = DirectInput8Create( hInst, DIRECTINPUT_VERSION, IID_IDirectInput8, (VOID**)&mDirectInput, NULL );
+    if (FAILED(hr))	
+		OIS_EXCEPT( E_General, "Win32InputManager::Win32InputManager >> Not able to init DirectX8 Input!");
+
+	//Ok, now we have DirectInput, parse whatever extra settings were sent to us
+	_parseConfigSettings( paramList );
+
+	// Enumerate devices ...
+	_enumerateDevices();
+}
+
+//--------------------------------------------------------------------------------//
+void Win32InputManager::_parseConfigSettings( ParamList &paramList )
+{
+	//Here we pick up settings such as a device's cooperation mode
+	std::map<std::string, DWORD> temp;
+	temp["DISCL_BACKGROUND"]	= DISCL_BACKGROUND;
+	temp["DISCL_EXCLUSIVE"]		= DISCL_EXCLUSIVE;
+	temp["DISCL_FOREGROUND"]	= DISCL_FOREGROUND;
+	temp["DISCL_NONEXCLUSIVE"]	= DISCL_NONEXCLUSIVE;
+	temp["DISCL_NOWINKEY"]		= DISCL_NOWINKEY;
+
+	//Check for pairs: ie. ("w32_keyboard","DISCL_NOWINKEY")("w32_keyboard","DISCL_FOREGROUND")
+	ParamList::iterator i = paramList.begin(), e = paramList.end();
+	for( ; i != e; ++i ) 
+	{
+		if( i->first == "w32_keyboard" )
+				kbSettings |= temp[i->second];
+		else if( i->first == "w32_mouse" )
+				mouseSettings |= temp[i->second];
+		else if( i->first == "w32_joystick" )
+				joySettings |= temp[i->second];
+	}
+	if( kbSettings == 0 ) kbSettings = DISCL_FOREGROUND | DISCL_NONEXCLUSIVE | DISCL_NOWINKEY;
+	if( mouseSettings == 0 ) mouseSettings = DISCL_FOREGROUND | DISCL_EXCLUSIVE;
+	if( joySettings == 0 ) joySettings = DISCL_FOREGROUND | DISCL_EXCLUSIVE;
+}
+
+//--------------------------------------------------------------------------------//
+void Win32InputManager::_enumerateDevices()
+{
+	//Enumerate all attached devices
+	mDirectInput->EnumDevices(NULL, _DIEnumDevCallback, this, DIEDFL_ATTACHEDONLY);
+
+#ifdef OIS_WIN32_XINPUT_SUPPORT
+	//let's check how many possible XInput devices we may have (max 4)... 
+	for(int i = 0; i < 3; ++i)
+	{
+		XINPUT_STATE state;
+		if(XInputGetState(i, &state) != ERROR_DEVICE_NOT_CONNECTED)
+		{	//Once we found 1, just check our whole list against devices
+			Win32JoyStick::CheckXInputDevices(unusedJoyStickList);
+			break;
+		}
+	}
+#endif
+}
+
+//--------------------------------------------------------------------------------//
+BOOL CALLBACK Win32InputManager::_DIEnumDevCallback(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef)
+{
+	Win32InputManager *_this_ = static_cast<Win32InputManager*>(pvRef);
+
+	// Register only game devices (keyboard and mouse are managed differently).
+	if( GET_DIDEVICE_TYPE(lpddi->dwDevType) == DI8DEVTYPE_JOYSTICK ||
+		GET_DIDEVICE_TYPE(lpddi->dwDevType) == DI8DEVTYPE_GAMEPAD ||
+		GET_DIDEVICE_TYPE(lpddi->dwDevType) == DI8DEVTYPE_1STPERSON ||
+		GET_DIDEVICE_TYPE(lpddi->dwDevType) == DI8DEVTYPE_DRIVING ||
+		GET_DIDEVICE_TYPE(lpddi->dwDevType) == DI8DEVTYPE_FLIGHT ||
+		GET_DIDEVICE_TYPE(lpddi->dwDevType) == DI8DEVTYPE_SUPPLEMENTAL)
+	{
+		JoyStickInfo jsInfo;
+		jsInfo.isXInput = false;
+		jsInfo.productGuid = lpddi->guidProduct;
+		jsInfo.deviceID = lpddi->guidInstance;
+		jsInfo.vendor = lpddi->tszInstanceName;
+		jsInfo.devId = _this_->joySticks;
+
+		_this_->joySticks++;
+		
+		_this_->unusedJoyStickList.push_back( jsInfo );
+	}
+
+	return DIENUM_CONTINUE;
+}
+
+//----------------------------------------------------------------------------//
+void Win32InputManager::_returnJoyStick(const JoyStickInfo& joystick)
+{
+	unusedJoyStickList.push_back(joystick);
+}
+
+//----------------------------------------------------------------------------//
+DeviceList Win32InputManager::freeDeviceList()
+{
+	DeviceList ret;
+
+	if( keyboardUsed == false )
+		ret.insert(std::make_pair(OISKeyboard, mInputSystemName));
+
+	if( mouseUsed == false )
+		ret.insert(std::make_pair(OISMouse, mInputSystemName));
+
+	for(JoyStickInfoList::iterator i = unusedJoyStickList.begin(); i != unusedJoyStickList.end(); ++i)
+		ret.insert(std::make_pair(OISJoyStick, i->vendor));
+
+	return ret;
+}
+
+//----------------------------------------------------------------------------//
+int Win32InputManager::totalDevices(Type iType)
+{
+	switch(iType)
+	{
+	case OISKeyboard: return 1;
+	case OISMouse: return 1;
+	case OISJoyStick: return joySticks;
+	default: return 0;
+	}
+}
+
+//----------------------------------------------------------------------------//
+int Win32InputManager::freeDevices(Type iType)
+{
+	switch(iType)
+	{
+	case OISKeyboard: return keyboardUsed ? 0 : 1;
+	case OISMouse: return mouseUsed ? 0 : 1;
+	case OISJoyStick: return (int)unusedJoyStickList.size();
+	default: return 0;
+	}
+}
+
+//----------------------------------------------------------------------------//
+bool Win32InputManager::vendorExist(Type iType, const std::string & vendor)
+{
+	if( (iType == OISKeyboard || iType == OISMouse) && vendor == mInputSystemName )
+	{
+		return true;
+	}
+	else if( iType == OISJoyStick )
+	{
+		for(JoyStickInfoList::iterator i = unusedJoyStickList.begin(); i != unusedJoyStickList.end(); ++i)
+			if(i->vendor == vendor)
+				return true;
+	}
+
+	return false;
+}
+
+//----------------------------------------------------------------------------//
+Object* Win32InputManager::createObject(InputManager* creator, Type iType, bool bufferMode, const std::string & vendor)
+{
+	Object *obj = 0;
+
+	switch(iType)
+	{
+	case OISKeyboard: 
+	{
+		if( keyboardUsed == false )
+			obj = new Win32Keyboard(this, mDirectInput, bufferMode, kbSettings);
+		break;
+	}
+	case OISMouse:
+	{
+		if( mouseUsed == false )
+			obj = new Win32Mouse(this, mDirectInput, bufferMode, mouseSettings);
+		break;
+	}
+	case OISJoyStick:
+	{
+		for(JoyStickInfoList::iterator i = unusedJoyStickList.begin(); i != unusedJoyStickList.end(); ++i)
+		{
+			if(vendor == "" || i->vendor == vendor)
+			{
+				obj = new Win32JoyStick(this, mDirectInput, bufferMode, joySettings, *i);
+				unusedJoyStickList.erase(i);
+				break;
+			}
+		}
+		break;
+	}
+	default:
+		break;
+	}
+
+	if( obj == 0 )
+		OIS_EXCEPT(E_InputDeviceNonExistant, "No devices match requested type.");
+
+	return obj;
+}
+
+//----------------------------------------------------------------------------//
+void Win32InputManager::destroyObject(Object* obj)
+{
+	delete obj;
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/Win32JoyStick.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/Win32JoyStick.cpp
new file mode 100644
index 0000000..af8227a
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/Win32JoyStick.cpp
@@ -0,0 +1,688 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that
+		you wrote the original software. If you use this software in a product,
+		an acknowledgment in the product documentation would be appreciated but is
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "win32/Win32JoyStick.h"
+#include "win32/Win32InputManager.h"
+#include "win32/Win32ForceFeedback.h"
+#include "OISEvents.h"
+#include "OISException.h"
+
+#include <cassert>
+
+// Only if xinput support is enabled
+#ifdef OIS_WIN32_XINPUT_SUPPORT
+#include <wbemidl.h>
+#include <oleauto.h>
+//#include <wmsstd.h>
+#ifndef SAFE_RELEASE
+#define SAFE_RELEASE(x) \
+   if(x != NULL)        \
+   {                    \
+      x->Release();     \
+      x = NULL;         \
+   }
+#endif
+
+#pragma comment(lib, "xinput.lib")
+#endif
+
+//DX Only defines macros for the JOYSTICK not JOYSTICK2, so fix it
+#undef DIJOFS_BUTTON
+#undef DIJOFS_POV
+
+#define DIJOFS_BUTTON(n)  (FIELD_OFFSET(DIJOYSTATE2, rgbButtons) + (n))
+#define DIJOFS_POV(n)     (FIELD_OFFSET(DIJOYSTATE2, rgdwPOV)+(n)*sizeof(DWORD))
+#define DIJOFS_SLIDER0(n) (FIELD_OFFSET(DIJOYSTATE2, rglSlider)+(n) * sizeof(LONG))
+#define DIJOFS_SLIDER1(n) (FIELD_OFFSET(DIJOYSTATE2, rglVSlider)+(n) * sizeof(LONG))
+#define DIJOFS_SLIDER2(n) (FIELD_OFFSET(DIJOYSTATE2, rglASlider)+(n) * sizeof(LONG))
+#define DIJOFS_SLIDER3(n) (FIELD_OFFSET(DIJOYSTATE2, rglFSlider)+(n) * sizeof(LONG))
+
+#define XINPUT_TRANSLATED_BUTTON_COUNT 12
+#define XINPUT_TRANSLATED_AXIS_COUNT 6
+
+using namespace OIS;
+
+//--------------------------------------------------------------------------------------------------//
+Win32JoyStick::Win32JoyStick( InputManager* creator, IDirectInput8* pDI, bool buffered, DWORD coopSettings, const JoyStickInfo &info ) :
+	JoyStick(info.vendor, buffered, info.devId, creator),
+	mDirectInput(pDI),
+	coopSetting(coopSettings),
+	mJoyStick(0),
+	mJoyInfo(info),
+	mFfDevice(0)
+{
+}
+
+//--------------------------------------------------------------------------------------------------//
+Win32JoyStick::~Win32JoyStick()
+{
+	delete mFfDevice;
+
+	if(mJoyStick)
+	{
+		mJoyStick->Unacquire();
+		mJoyStick->Release();
+		mJoyStick = 0;
+	}
+
+	//Return joystick to pool
+	static_cast<Win32InputManager*>(mCreator)->_returnJoyStick(mJoyInfo);
+}
+
+//--------------------------------------------------------------------------------------------------//
+void Win32JoyStick::_initialize()
+{
+    if (mJoyInfo.isXInput)
+    {
+        _enumerate();
+    }
+    else
+    {
+	    //Clear old state
+	    mState.mAxes.clear();
+
+	    delete mFfDevice;
+	    mFfDevice = 0;
+
+	    DIPROPDWORD dipdw;
+
+	    dipdw.diph.dwSize       = sizeof(DIPROPDWORD);
+	    dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
+	    dipdw.diph.dwObj        = 0;
+	    dipdw.diph.dwHow        = DIPH_DEVICE;
+	    dipdw.dwData            = JOYSTICK_DX_BUFFERSIZE;
+
+	    if(FAILED(mDirectInput->CreateDevice(mJoyInfo.deviceID, &mJoyStick, NULL)))
+		    OIS_EXCEPT( E_General, "Win32JoyStick::_initialize() >> Could not initialize joy device!");
+
+	    if(FAILED(mJoyStick->SetDataFormat(&c_dfDIJoystick2)))
+		    OIS_EXCEPT( E_General, "Win32JoyStick::_initialize() >> data format error!");
+
+	    HWND hwin = ((Win32InputManager*)mCreator)->getWindowHandle();
+
+	    if(FAILED(mJoyStick->SetCooperativeLevel( hwin, coopSetting)))
+		    OIS_EXCEPT( E_General, "Win32JoyStick::_initialize() >> failed to set cooperation level!");
+
+	    if( FAILED(mJoyStick->SetProperty(DIPROP_BUFFERSIZE, &dipdw.diph)) )
+		    OIS_EXCEPT( E_General, "Win32Mouse::Win32Mouse >> Failed to set buffer size property" );
+
+	    //Enumerate all axes/buttons/sliders/etc before aquiring
+	    _enumerate();
+
+	    mState.clear();
+
+	    capture();
+    }
+}
+
+//--------------------------------------------------------------------------------------------------//
+void Win32JoyStick::_enumerate()
+{
+    if (mJoyInfo.isXInput)
+    {
+        mPOVs = 1;
+
+        mState.mButtons.resize(XINPUT_TRANSLATED_BUTTON_COUNT);
+	    mState.mAxes.resize(XINPUT_TRANSLATED_AXIS_COUNT);
+    }
+    else
+    {
+		// Get joystick capabilities.
+		mDIJoyCaps.dwSize = sizeof(DIDEVCAPS);
+		if( FAILED(mJoyStick->GetCapabilities(&mDIJoyCaps)) )
+			OIS_EXCEPT( E_General, "Win32JoyStick::_enumerate >> Failed to get capabilities" );
+
+	    mPOVs = (short)mDIJoyCaps.dwPOVs;
+
+	    mState.mButtons.resize(mDIJoyCaps.dwButtons);
+	    mState.mAxes.resize(mDIJoyCaps.dwAxes);
+
+	    //Reset the axis mapping enumeration value
+	    _AxisNumber = 0;
+
+	    //Enumerate Force Feedback (if any)
+	    mJoyStick->EnumEffects(DIEnumEffectsCallback, this, DIEFT_ALL);
+
+	    //Enumerate and set axis constraints (and check FF Axes)
+	    mJoyStick->EnumObjects(DIEnumDeviceObjectsCallback, this, DIDFT_AXIS);
+    }
+}
+
+//--------------------------------------------------------------------------------------------------//
+BOOL CALLBACK Win32JoyStick::DIEnumDeviceObjectsCallback(LPCDIDEVICEOBJECTINSTANCE lpddoi, LPVOID pvRef)
+{
+	Win32JoyStick* _this = (Win32JoyStick*)pvRef;
+
+	//Setup mappings
+	DIPROPPOINTER diptr;
+	diptr.diph.dwSize       = sizeof(DIPROPPOINTER);
+	diptr.diph.dwHeaderSize = sizeof(DIPROPHEADER);
+	diptr.diph.dwHow        = DIPH_BYID;
+	diptr.diph.dwObj        = lpddoi->dwType;
+	//Add a magic number to recognise we set seomthing
+	diptr.uData             = 0x13130000 | _this->_AxisNumber;
+
+	//Check if axis is slider, if so, do not treat as regular axis
+	if(GUID_Slider == lpddoi->guidType)
+	{
+		++_this->mSliders;
+
+		//Decrease Axes, since this slider shows up in a different place
+		_this->mState.mAxes.pop_back();
+	}
+	else if (FAILED(_this->mJoyStick->SetProperty(DIPROP_APPDATA, &diptr.diph)))
+	{	//If for some reason we could not set needed user data, just ignore this axis
+		return DIENUM_CONTINUE;
+	}
+
+	//Increase for next time through
+	if(GUID_Slider != lpddoi->guidType)
+		_this->_AxisNumber += 1;
+
+	//Set range
+	DIPROPRANGE diprg;
+	diprg.diph.dwSize       = sizeof(DIPROPRANGE);
+	diprg.diph.dwHeaderSize = sizeof(DIPROPHEADER);
+	diprg.diph.dwHow        = DIPH_BYID;
+	diprg.diph.dwObj        = lpddoi->dwType;
+	diprg.lMin              = MIN_AXIS;
+	diprg.lMax              = MAX_AXIS;
+
+	if (FAILED(_this->mJoyStick->SetProperty(DIPROP_RANGE, &diprg.diph)))
+		OIS_EXCEPT( E_General, "Win32JoyStick::_DIEnumDeviceObjectsCallback >> Failed to set min/max range property" );
+
+	//Check if FF Axes, and if so, increment counter
+	if((lpddoi->dwFlags & DIDOI_FFACTUATOR) != 0 )
+	{
+		if( _this->mFfDevice )
+		{
+			_this->mFfDevice->_addFFAxis();
+		}
+	}
+
+	//Force the flags for gain and auto-center support to true,
+	//as DInput has no API to query the device for these capabilities
+	//(the only way to know is to try them ...)
+	if( _this->mFfDevice )
+	{
+	    _this->mFfDevice->_setGainSupport(true);
+	    _this->mFfDevice->_setAutoCenterSupport(true);
+	}
+
+	return DIENUM_CONTINUE;
+}
+
+//--------------------------------------------------------------------------------------------------//
+BOOL CALLBACK Win32JoyStick::DIEnumEffectsCallback(LPCDIEFFECTINFO pdei, LPVOID pvRef)
+{
+	Win32JoyStick* _this = (Win32JoyStick*)pvRef;
+
+	//Create the FF instance only after we know there is at least one effect type
+	if( _this->mFfDevice == 0 )
+		_this->mFfDevice = new Win32ForceFeedback(_this->mJoyStick, &_this->mDIJoyCaps);
+
+	_this->mFfDevice->_addEffectSupport(pdei);
+
+	return DIENUM_CONTINUE;
+}
+
+//--------------------------------------------------------------------------------------------------//
+void Win32JoyStick::capture()
+{
+#ifdef OIS_WIN32_XINPUT_SUPPORT
+	//handle xbox controller differently
+    if (mJoyInfo.isXInput)
+	{
+		captureXInput();
+		return;
+	}
+#endif
+
+	//handle directinput based devices
+	DIDEVICEOBJECTDATA diBuff[JOYSTICK_DX_BUFFERSIZE];
+	DWORD entries = JOYSTICK_DX_BUFFERSIZE;
+
+	// Poll the device to read the current state
+	HRESULT hr = mJoyStick->Poll();
+	if( hr == DI_OK )
+		hr = mJoyStick->GetDeviceData( sizeof(DIDEVICEOBJECTDATA), diBuff, &entries, 0 );
+
+	if( hr != DI_OK )
+	{
+		hr = mJoyStick->Acquire();
+		while( hr == DIERR_INPUTLOST )
+			hr = mJoyStick->Acquire();
+
+		// Poll the device to read the current state
+		mJoyStick->Poll();
+		hr = mJoyStick->GetDeviceData( sizeof(DIDEVICEOBJECTDATA), diBuff, &entries, 0 );
+		//Perhaps the user just tabbed away
+		if( FAILED(hr) )
+			return;
+	}
+
+	bool axisMoved[24] = {false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,
+						  false,false,false,false,false,false,false,false};
+	bool sliderMoved[4] = {false,false,false,false};
+
+	//Loop through all the events
+	for(unsigned int i = 0; i < entries; ++i)
+	{
+		//This may seem outof order, but is in order of the way these variables
+		//are declared in the JoyStick State 2 structure.
+		switch(diBuff[i].dwOfs)
+		{
+		//------ slider -//
+		case DIJOFS_SLIDER0(0):
+			sliderMoved[0] = true;
+			mState.mSliders[0].abX = diBuff[i].dwData;
+			break;
+		case DIJOFS_SLIDER0(1):
+			sliderMoved[0] = true;
+			mState.mSliders[0].abY = diBuff[i].dwData;
+			break;
+		//----- Max 4 POVs Next ---------------//
+		case DIJOFS_POV(0):
+			if(!_changePOV(0,diBuff[i]))
+				return;
+			break;
+		case DIJOFS_POV(1):
+			if(!_changePOV(1,diBuff[i]))
+				return;
+			break;
+		case DIJOFS_POV(2):
+			if(!_changePOV(2,diBuff[i]))
+				return;
+			break;
+		case DIJOFS_POV(3):
+			if(!_changePOV(3,diBuff[i]))
+				return;
+			break;
+		case DIJOFS_SLIDER1(0):
+			sliderMoved[1] = true;
+			mState.mSliders[1].abX = diBuff[i].dwData;
+			break;
+		case DIJOFS_SLIDER1(1):
+			sliderMoved[1] = true;
+			mState.mSliders[1].abY = diBuff[i].dwData;
+			break;
+		case DIJOFS_SLIDER2(0):
+			sliderMoved[2] = true;
+			mState.mSliders[2].abX = diBuff[i].dwData;
+			break;
+		case DIJOFS_SLIDER2(1):
+			sliderMoved[2] = true;
+			mState.mSliders[2].abY = diBuff[i].dwData;
+			break;
+		case DIJOFS_SLIDER3(0):
+			sliderMoved[3] = true;
+			mState.mSliders[3].abX = diBuff[i].dwData;
+			break;
+		case DIJOFS_SLIDER3(1):
+			sliderMoved[3] = true;
+			mState.mSliders[3].abY = diBuff[i].dwData;
+			break;
+		//-----------------------------------------//
+		default:
+			//Handle Button Events Easily using the DX Offset Macros
+			if( diBuff[i].dwOfs >= DIJOFS_BUTTON(0) && diBuff[i].dwOfs < DIJOFS_BUTTON(128) )
+			{
+				if(!_doButtonClick((diBuff[i].dwOfs - DIJOFS_BUTTON(0)), diBuff[i]))
+					return;
+			}
+			else if((short)(diBuff[i].uAppData >> 16) == 0x1313)
+			{	//If it was nothing else, might be axis enumerated earlier (determined by magic number)
+				int axis = (int)(0x0000FFFF & diBuff[i].uAppData); //Mask out the high bit
+				assert( axis >= 0 && axis < (int)mState.mAxes.size() && "Axis out of range!");
+
+				if(axis >= 0 && axis < (int)mState.mAxes.size())
+				{
+					mState.mAxes[axis].abs = diBuff[i].dwData;
+					axisMoved[axis] = true;
+				}
+			}
+
+			break;
+		} //end case
+	} //end for
+
+	//Check to see if any of the axes values have changed.. if so send events
+	if( mBuffered && mListener && entries > 0 )
+	{
+		JoyStickEvent temp(this, mState);
+
+		//Update axes
+		for( int i = 0; i < 24; ++i )
+			if( axisMoved[i] )
+				if( mListener->axisMoved( temp, i ) == false )
+					return;
+
+		//Now update sliders
+		for( int i = 0; i < 4; ++i )
+			if( sliderMoved[i] )
+				if( mListener->sliderMoved( temp, i ) == false )
+					return;
+	}
+}
+
+//--------------------------------------------------------------------------------------------------//
+void Win32JoyStick::captureXInput()
+{
+#ifdef OIS_WIN32_XINPUT_SUPPORT
+    XINPUT_STATE inputState;
+	if (XInputGetState((DWORD)mJoyInfo.xInputDev, &inputState) != ERROR_SUCCESS)
+        memset(&inputState, 0, sizeof(inputState));
+
+    //Sticks and triggers
+	int value;
+    bool axisMoved[XINPUT_TRANSLATED_AXIS_COUNT] = {false,false,false,false,false,false};
+
+	//LeftY
+	value = -(int)inputState.Gamepad.sThumbLY;
+	mState.mAxes[0].rel = value - mState.mAxes[0].abs;
+	mState.mAxes[0].abs = value;
+	if(mState.mAxes[0].rel != 0)
+        axisMoved[0] = true;
+
+	//LeftX
+    mState.mAxes[1].rel = inputState.Gamepad.sThumbLX - mState.mAxes[1].abs;
+    mState.mAxes[1].abs = inputState.Gamepad.sThumbLX;
+
+	if(mState.mAxes[1].rel != 0)
+        axisMoved[1] = true;
+
+	//RightY
+	value = -(int)inputState.Gamepad.sThumbRY;           
+    mState.mAxes[2].rel = value - mState.mAxes[2].abs;
+    mState.mAxes[2].abs = value;
+	if(mState.mAxes[2].rel != 0)
+        axisMoved[2] = true;
+
+	//RightX
+    mState.mAxes[3].rel = inputState.Gamepad.sThumbRX - mState.mAxes[3].abs;
+    mState.mAxes[3].abs = inputState.Gamepad.sThumbRX;
+	if(mState.mAxes[3].rel != 0)
+		axisMoved[3] = true;
+
+	//Left trigger
+    value = inputState.Gamepad.bLeftTrigger * 129;
+	if(value > JoyStick::MAX_AXIS)
+		value = JoyStick::MAX_AXIS;
+
+    mState.mAxes[4].rel = value - mState.mAxes[4].abs;
+    mState.mAxes[4].abs = value;
+	if(mState.mAxes[4].rel != 0)
+		axisMoved[4] = true;
+
+	//Right trigger
+    value = (int)inputState.Gamepad.bRightTrigger * 129;
+	if(value > JoyStick::MAX_AXIS)
+		value = JoyStick::MAX_AXIS;
+
+	mState.mAxes[5].rel = value - mState.mAxes[5].abs;
+    mState.mAxes[5].abs = value;
+	if(mState.mAxes[5].rel != 0)
+		axisMoved[5] = true;
+    
+    //POV
+    int previousPov = mState.mPOV[0].direction;        
+    int& pov = mState.mPOV[0].direction;
+    pov = Pov::Centered;        
+    if (inputState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP)
+        pov |= Pov::North;
+    else if (inputState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN)
+        pov |= Pov::South;
+    if (inputState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT)
+        pov |= Pov::West;
+    else if (inputState.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT)
+        pov |= Pov::East;
+    
+    //Buttons - The first 4 buttons don't need to be checked since they represent the dpad
+    bool previousButtons[XINPUT_TRANSLATED_BUTTON_COUNT];
+    std::copy(mState.mButtons.begin(), mState.mButtons.end(), previousButtons);
+    for (size_t i = 0; i < XINPUT_TRANSLATED_BUTTON_COUNT; i++)
+        mState.mButtons[i] = (inputState.Gamepad.wButtons & (1 << (i + 4))) != 0;
+
+    //Send events
+    if (mBuffered && mListener)
+    {
+	    JoyStickEvent joystickEvent(this, mState);
+
+	    //Axes
+	    for (int i = 0; i < XINPUT_TRANSLATED_AXIS_COUNT; i++)
+        {
+		    if (axisMoved[i] && !mListener->axisMoved(joystickEvent, i))
+			    return;
+        }
+
+        //POV
+        if (previousPov != pov && !mListener->povMoved(joystickEvent, 0))
+            return;
+
+        //Buttons
+        for (int i = 0; i < XINPUT_TRANSLATED_BUTTON_COUNT; i++)
+        {
+            if (!previousButtons[i] && mState.mButtons[i])
+            {
+                if (!mListener->buttonPressed(joystickEvent, i))
+                    return;
+            }
+            else if (previousButtons[i] && !mState.mButtons[i])
+            {
+                if (!mListener->buttonReleased(joystickEvent, i))
+                    return;
+            }
+        }
+    }
+#endif
+}
+
+//--------------------------------------------------------------------------------------------------//
+bool Win32JoyStick::_doButtonClick( int button, DIDEVICEOBJECTDATA& di )
+{
+	if( di.dwData & 0x80 )
+	{
+		mState.mButtons[button] = true;
+		if( mBuffered && mListener )
+			return mListener->buttonPressed( JoyStickEvent( this, mState ), button );
+	}
+	else
+	{
+		mState.mButtons[button] = false;
+		if( mBuffered && mListener )
+			return mListener->buttonReleased( JoyStickEvent( this, mState ), button );
+	}
+
+	return true;
+}
+
+//--------------------------------------------------------------------------------------------------//
+bool Win32JoyStick::_changePOV( int pov, DIDEVICEOBJECTDATA& di )
+{
+	//Some drivers report a value of 65,535, instead of 1,
+	//for the center position
+	if(LOWORD(di.dwData) == 0xFFFF)
+	{
+		mState.mPOV[pov].direction = Pov::Centered;
+	}
+	else
+	{
+		switch(di.dwData)
+		{
+			case 0: mState.mPOV[pov].direction = Pov::North; break;
+			case 4500: mState.mPOV[pov].direction = Pov::NorthEast; break;
+			case 9000: mState.mPOV[pov].direction = Pov::East; break;
+			case 13500: mState.mPOV[pov].direction = Pov::SouthEast; break;
+			case 18000: mState.mPOV[pov].direction = Pov::South; break;
+			case 22500: mState.mPOV[pov].direction = Pov::SouthWest; break;
+			case 27000: mState.mPOV[pov].direction = Pov::West; break;
+			case 31500: mState.mPOV[pov].direction = Pov::NorthWest; break;
+		}
+	}
+
+	if( mBuffered && mListener )
+		return mListener->povMoved( JoyStickEvent( this, mState ), pov );
+
+	return true;
+}
+
+//--------------------------------------------------------------------------------------------------//
+void Win32JoyStick::setBuffered(bool buffered)
+{
+	mBuffered = buffered;
+}
+
+//--------------------------------------------------------------------------------------------------//
+Interface* Win32JoyStick::queryInterface(Interface::IType type)
+{
+	if( mFfDevice && type == Interface::ForceFeedback )
+		return mFfDevice;
+	else
+		return 0;
+}
+
+//--------------------------------------------------------------------------------------------------//
+#ifdef OIS_WIN32_XINPUT_SUPPORT
+void Win32JoyStick::CheckXInputDevices(JoyStickInfoList &joys)
+{
+    IWbemLocator*           pIWbemLocator  = NULL;
+    IEnumWbemClassObject*   pEnumDevices   = NULL;
+    IWbemClassObject*       pDevices[20]   = {0};
+    IWbemServices*          pIWbemServices = NULL;
+    BSTR                    bstrNamespace  = NULL;
+    BSTR                    bstrDeviceID   = NULL;
+    BSTR                    bstrClassName  = NULL;
+    DWORD                   uReturned      = 0;
+    bool                    bIsXinputDevice= false;
+	DWORD                   iDevice        = 0;
+	int                     xDevice        = 0;
+    VARIANT                 var;
+    HRESULT                 hr;
+
+	if(joys.size() == 0)
+		return;
+
+    // CoInit if needed
+    hr = CoInitialize(NULL);
+    bool bCleanupCOM = SUCCEEDED(hr);
+
+    // Create WMI
+    hr = CoCreateInstance(__uuidof(WbemLocator), NULL, CLSCTX_INPROC_SERVER, __uuidof(IWbemLocator), (LPVOID*)&pIWbemLocator);
+    if( FAILED(hr) || pIWbemLocator == NULL )
+        goto LCleanup;
+
+    bstrNamespace = SysAllocString( L"\\\\.\\root\\cimv2" );
+	if( bstrNamespace == NULL )
+		goto LCleanup;
+
+    bstrClassName = SysAllocString( L"Win32_PNPEntity" );
+	if( bstrClassName == NULL )
+		goto LCleanup;
+
+    bstrDeviceID  = SysAllocString( L"DeviceID" );
+	if( bstrDeviceID == NULL )
+		goto LCleanup;
+    
+    // Connect to WMI 
+    hr = pIWbemLocator->ConnectServer( bstrNamespace, NULL, NULL, 0L, 0L, NULL, NULL, &pIWbemServices );
+    if( FAILED(hr) || pIWbemServices == NULL )
+        goto LCleanup;
+
+    // Switch security level to IMPERSONATE. 
+    CoSetProxyBlanket(pIWbemServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL, RPC_C_AUTHN_LEVEL_CALL, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );                    
+
+    hr = pIWbemServices->CreateInstanceEnum( bstrClassName, 0, NULL, &pEnumDevices ); 
+    if( FAILED(hr) || pEnumDevices == NULL )
+        goto LCleanup;
+
+    // Loop over all devices
+    for( ;; )
+    {
+        // Get 20 at a time
+        hr = pEnumDevices->Next(5000, 20, pDevices, &uReturned);
+        if( FAILED(hr) )
+            goto LCleanup;
+
+        if( uReturned == 0 )
+            break;
+
+        for(iDevice = 0; iDevice < uReturned; iDevice++)
+        {
+            // For each device, get its device ID
+            hr = pDevices[iDevice]->Get(bstrDeviceID, 0L, &var, NULL, NULL);
+            if(SUCCEEDED(hr) && var.vt == VT_BSTR && var.bstrVal != NULL)
+            {
+                // Check if the device ID contains "IG_".  If it does, then it's an XInput device - This information can not be found from DirectInput 
+                if(wcsstr(var.bstrVal, L"IG_"))
+                {
+                    // If it does, then get the VID/PID from var.bstrVal
+                    DWORD dwPid = 0, dwVid = 0;
+                    WCHAR* strVid = wcsstr( var.bstrVal, L"VID_" );
+                    if(strVid && swscanf_s( strVid, L"VID_%4X", &dwVid ) != 1)
+						dwVid = 0;
+
+                    WCHAR* strPid = wcsstr( var.bstrVal, L"PID_" );
+                    if(strPid && swscanf_s( strPid, L"PID_%4X", &dwPid ) != 1)
+                        dwPid = 0;
+
+                    // Compare the VID/PID to the DInput device
+                    DWORD dwVidPid = MAKELONG(dwVid, dwPid);
+					for(JoyStickInfoList::iterator i = joys.begin(); i != joys.end(); ++i)
+					{
+						if(!i->isXInput && dwVidPid == i->productGuid.Data1)
+						{
+							i->isXInput = true;
+							i->xInputDev = xDevice;
+							++xDevice;
+						}
+					}
+
+					if(joys.size() == 0)
+						goto LCleanup;
+                }
+            }
+
+            SAFE_RELEASE(pDevices[iDevice]);
+        }
+    }
+
+LCleanup:
+    if(bstrNamespace)
+        SysFreeString(bstrNamespace);
+
+    if(bstrDeviceID)
+        SysFreeString(bstrDeviceID);
+
+    if(bstrClassName)
+        SysFreeString(bstrClassName);
+
+    for(iDevice=0; iDevice < 20; iDevice++)
+        SAFE_RELEASE(pDevices[iDevice]);
+
+    SAFE_RELEASE(pEnumDevices);
+    SAFE_RELEASE(pIWbemLocator);
+    SAFE_RELEASE(pIWbemServices);
+
+    if(bCleanupCOM)
+        CoUninitialize();
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/Win32KeyBoard.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/Win32KeyBoard.cpp
new file mode 100644
index 0000000..9cf3893
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/Win32KeyBoard.cpp
@@ -0,0 +1,333 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "win32/Win32InputManager.h"
+#include "win32/Win32KeyBoard.h"
+#include "OISException.h"
+#include "OISEvents.h"
+#include <sstream>
+
+using namespace OIS;
+
+//--------------------------------------------------------------------------------------------------//
+Win32Keyboard::Win32Keyboard( InputManager* creator, IDirectInput8* pDI, bool buffered, DWORD coopSettings )
+	: Keyboard(creator->inputSystemName(), buffered, 0, creator)
+{
+	mKeyboard = 0;
+	mDirectInput = pDI;
+	coopSetting = coopSettings;
+
+	//Clear our keyboard state buffer
+	memset( &KeyBuffer, 0, 256 );
+	deadKey = '\0';
+	static_cast<Win32InputManager*>(mCreator)->_setKeyboardUsed(true);
+}
+
+//--------------------------------------------------------------------------------------------------//
+void Win32Keyboard::_initialize()
+{
+	mModifiers = 0;
+	deadKey = '\0';
+
+	if(FAILED(mDirectInput->CreateDevice(GUID_SysKeyboard, &mKeyboard, NULL)))
+		OIS_EXCEPT( E_General, "Win32Keyboard::Win32Keyboard >> Could not init device!");
+
+	if(FAILED(mKeyboard->SetDataFormat(&c_dfDIKeyboard)))
+		OIS_EXCEPT( E_General, "Win32Keyboard::Win32Keyboard >> format error!");
+
+	HWND hwin = ((Win32InputManager*)mCreator)->getWindowHandle();
+
+	if(FAILED(mKeyboard->SetCooperativeLevel( hwin, coopSetting)))
+		OIS_EXCEPT( E_General, "Win32Keyboard::Win32Keyboard >> coop error!");
+
+	if( mBuffered )
+	{
+		DIPROPDWORD dipdw;
+		dipdw.diph.dwSize       = sizeof(DIPROPDWORD);
+		dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
+		dipdw.diph.dwObj        = 0;
+		dipdw.diph.dwHow        = DIPH_DEVICE;
+		dipdw.dwData            = KEYBOARD_DX_BUFFERSIZE;
+
+		if (FAILED(mKeyboard->SetProperty( DIPROP_BUFFERSIZE, &dipdw.diph )))
+			OIS_EXCEPT( E_General, "Win32Keyboard::Win32Keyboard >> buffer error!");
+	}
+
+	HRESULT hr = mKeyboard->Acquire();
+	if(FAILED(hr) && hr != DIERR_OTHERAPPHASPRIO)
+		OIS_EXCEPT( E_General, "Win32Keyboard::Win32Keyboard >> aquire error!");
+}
+
+//--------------------------------------------------------------------------------------------------//
+Win32Keyboard::~Win32Keyboard()
+{
+	if(mKeyboard)
+	{
+		mKeyboard->Unacquire();
+		mKeyboard->Release();
+		mKeyboard = 0;
+	}
+	static_cast<Win32InputManager*>(mCreator)->_setKeyboardUsed(false);
+}
+
+//--------------------------------------------------------------------------------------------------//
+void Win32Keyboard::capture()
+{
+	if( mBuffered )
+		_readBuffered();
+	else
+		_read();
+}
+
+//--------------------------------------------------------------------------------------------------//
+void Win32Keyboard::_readBuffered()
+{
+	DIDEVICEOBJECTDATA diBuff[KEYBOARD_DX_BUFFERSIZE];
+	DWORD entries = KEYBOARD_DX_BUFFERSIZE;
+	HRESULT hr;
+	//Only one keyboard allowed per app, so static is ok
+	static bool verifyAfterAltTab = false;
+
+	hr = mKeyboard->GetDeviceData( sizeof(DIDEVICEOBJECTDATA), diBuff, &entries, 0 );
+	if( hr != DI_OK )
+	{
+		hr = mKeyboard->Acquire();
+		if (hr == E_ACCESSDENIED)
+			verifyAfterAltTab = true;
+
+		while( hr == DIERR_INPUTLOST )
+			hr = mKeyboard->Acquire();
+
+		return;
+	}
+
+	if( FAILED(hr) )
+		OIS_EXCEPT( E_General, "Win32Keyboard::_readBuffered() >> Problem with Device!" );
+
+	//Update keyboard and modifier states.. And, if mListener, fire events
+	for(unsigned int i = 0; i < entries; ++i )
+	{
+		//If the listener returns false, that means that we are probably deleted...
+		//send no more events and just leave as the this pointer is invalid now...
+		bool ret = true;
+		KeyCode kc = (KeyCode)diBuff[ i ].dwOfs;
+			
+		//Store result in our keyBuffer too
+		KeyBuffer[kc] = static_cast<unsigned char>(diBuff[ i ].dwData);
+			
+		if( diBuff[ i ].dwData & 0x80 )
+		{
+			//Turn on modifier
+			if( kc == KC_LCONTROL || kc == KC_RCONTROL )
+				mModifiers |= Ctrl;
+			else if( kc == KC_LSHIFT || kc == KC_RSHIFT )
+				mModifiers |= Shift;
+			else if( kc == KC_LMENU || kc == KC_RMENU )
+				mModifiers |= Alt;
+
+			if( mListener )
+				ret = mListener->keyPressed( KeyEvent( this, kc, _translateText(kc) ) );
+		}
+		else
+		{
+			//Turn off modifier
+			if( kc == KC_LCONTROL || kc == KC_RCONTROL )
+				mModifiers &= ~Ctrl;
+			else if( kc == KC_LSHIFT || kc == KC_RSHIFT )
+				mModifiers &= ~Shift;
+			else if( kc == KC_LMENU || kc == KC_RMENU )
+				mModifiers &= ~Alt;
+
+			//Fire off event
+			if( mListener )
+				ret = mListener->keyReleased( KeyEvent( this, kc, 0 ) );
+		}
+
+		if(ret == false)
+			break;
+	}
+
+	// If a lost device/access denied was detected, recover gracefully with new events
+	if(verifyAfterAltTab)
+	{
+		bool ret = true;
+		
+		//Copy old buffer to temp location to compare against
+		unsigned char keyBufferCopy[256];
+		memcpy(keyBufferCopy, KeyBuffer, 256);
+
+		//Update new state
+		_read();
+
+		for (unsigned i = 0; i < 256; i++)
+		{
+			if (keyBufferCopy[i] != KeyBuffer[i])
+			{
+				if (mListener)
+				{
+					if (KeyBuffer[i])
+						ret = mListener->keyPressed( KeyEvent( this, (KeyCode)i, _translateText((KeyCode)i) ) );
+					else
+						ret = mListener->keyReleased( KeyEvent( this, (KeyCode)i, 0 ) );
+				}
+			}
+
+			//If user returned false from callback, return immediately
+			if(ret == false)
+				return;
+		}
+
+		verifyAfterAltTab = false;
+	}
+}
+
+//--------------------------------------------------------------------------------------------------//
+void Win32Keyboard::_read()
+{
+    HRESULT  hr = mKeyboard->GetDeviceState( sizeof(KeyBuffer), &KeyBuffer );
+
+	if( hr == DIERR_INPUTLOST || hr == DIERR_NOTACQUIRED )
+	{
+		hr = mKeyboard->Acquire();
+		if (hr != DIERR_OTHERAPPHASPRIO)
+			mKeyboard->GetDeviceState(sizeof(KeyBuffer), &KeyBuffer);
+	}
+
+	//Set Shift, Ctrl, Alt
+	mModifiers = 0;
+	if( isKeyDown(KC_LCONTROL) || isKeyDown(KC_RCONTROL) )
+		mModifiers |= Ctrl;
+	if( isKeyDown(KC_LSHIFT) || isKeyDown(KC_RSHIFT) )
+		mModifiers |= Shift;
+	if( isKeyDown(KC_LMENU) || isKeyDown(KC_RMENU) )
+		mModifiers |= Alt;
+}
+
+//--------------------------------------------------------------------------------------------------//
+int Win32Keyboard::_translateText( KeyCode kc )
+{
+	if( mTextMode == Off )
+		return 0;
+
+	BYTE keyState[256];
+	HKL  layout = GetKeyboardLayout(0);
+	if( GetKeyboardState(keyState) == 0 )
+		return 0;
+
+	unsigned int vk = MapVirtualKeyEx(kc, 3, layout);
+	if( vk == 0 )
+		return 0;
+
+	WCHAR buff[3] = {0};
+	int ascii = ToUnicodeEx(vk, kc, keyState, buff, 3, 0, layout);
+
+	if(ascii == 1 && deadKey != '\0' )
+	{
+		// A dead key is stored and we have just converted a character key
+		// Combine the two into a single character
+		WCHAR wcBuff[3] = {buff[0], deadKey, '\0'};
+		WCHAR out[3];
+		
+		deadKey = '\0';
+		if(FoldStringW(MAP_PRECOMPOSED, (LPWSTR)wcBuff, 3, (LPWSTR)out, 3))
+			return out[0];
+	}
+	else if (ascii == 1)
+	{	// We have a single character
+		deadKey = '\0';
+		return buff[0];
+	}
+	else if(ascii == 2)
+	{	// Convert a non-combining diacritical mark into a combining diacritical mark
+		// Combining versions range from 0x300 to 0x36F; only 5 (for French) have been mapped below
+		// http://www.fileformat.info/info/unicode/block/combining_diacritical_marks/images.htm
+		switch(buff[0])	{
+		case 0x5E: // Circumflex accent: 
+			deadKey = 0x302; break;
+		case 0x60: // Grave accent: 
+			deadKey = 0x300; break;
+		case 0xA8: // Diaeresis: 
+			deadKey = 0x308; break;
+		case 0xB4: // Acute accent: 
+			deadKey = 0x301; break;
+		case 0xB8: // Cedilla: 
+			deadKey = 0x327; break;
+		default:
+			deadKey = buff[0]; break;
+		}
+	}
+
+	return 0;
+}
+
+//--------------------------------------------------------------------------------------------------//
+bool Win32Keyboard::isKeyDown( KeyCode key ) const
+{
+	return (KeyBuffer[key] & 0x80) != 0;
+}
+
+//--------------------------------------------------------------------------------------------------//
+const std::string& Win32Keyboard::getAsString(KeyCode kc)
+{
+	char temp[256];
+
+	DIPROPSTRING prop;
+	prop.diph.dwSize = sizeof(DIPROPSTRING);
+	prop.diph.dwHeaderSize = sizeof(DIPROPHEADER);
+	prop.diph.dwObj = static_cast<DWORD>(kc);
+	prop.diph.dwHow = DIPH_BYOFFSET;
+
+	if (SUCCEEDED(mKeyboard->GetProperty(DIPROP_KEYNAME, &prop.diph)))
+	{
+		// convert the WCHAR in "wsz" to multibyte
+		if (WideCharToMultiByte(CP_ACP, 0, prop.wsz, -1, temp, sizeof(temp), NULL, NULL))
+			return mGetString.assign(temp);
+	}
+
+	std::stringstream ss;
+	ss << "Key_" << (int)kc;
+	return mGetString.assign(ss.str());
+}
+
+//--------------------------------------------------------------------------------------------------//
+void Win32Keyboard::copyKeyStates( char keys[256] ) const
+{
+	for(int i = 0; i < 256; ++i)
+		keys[i] = KeyBuffer[i] > 0; //Normalise the DX values (0x80)
+}
+
+//--------------------------------------------------------------------------------------------------//
+void Win32Keyboard::setBuffered(bool buffered)
+{
+	if( buffered != mBuffered )
+	{
+		if(mKeyboard)
+		{
+			mKeyboard->Unacquire();
+			mKeyboard->Release();
+			mKeyboard = 0;
+		}
+		
+		mBuffered = buffered;
+		_initialize();
+	}
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/Win32Mouse.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/Win32Mouse.cpp
new file mode 100644
index 0000000..6489825
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/Win32Mouse.cpp
@@ -0,0 +1,216 @@
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "win32/Win32Mouse.h"
+#include "win32/Win32InputManager.h"
+#include "OISException.h"
+#include "OISEvents.h"
+
+using namespace OIS;
+
+//--------------------------------------------------------------------------------------------------//
+Win32Mouse::Win32Mouse( InputManager* creator, IDirectInput8* pDI, bool buffered, DWORD coopSettings )
+	: Mouse(creator->inputSystemName(), buffered, 0, creator)
+{
+	mMouse = 0;
+	mDirectInput = pDI;
+	coopSetting = coopSettings;
+	mHwnd = 0;
+
+	static_cast<Win32InputManager*>(mCreator)->_setMouseUsed(true);
+}
+
+//--------------------------------------------------------------------------------------------------//
+void Win32Mouse::_initialize()
+{
+	DIPROPDWORD dipdw;
+
+	//Clear old state
+	mState.clear();
+
+    dipdw.diph.dwSize       = sizeof(DIPROPDWORD);
+    dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
+    dipdw.diph.dwObj        = 0;
+    dipdw.diph.dwHow        = DIPH_DEVICE;
+	dipdw.dwData            = MOUSE_DX_BUFFERSIZE;
+	
+	if( FAILED(mDirectInput->CreateDevice(GUID_SysMouse, &mMouse, NULL)) )
+		OIS_EXCEPT( E_General, "Win32Mouse::Win32Mouse >> Failed to create device" );
+
+	if( FAILED(mMouse->SetDataFormat(&c_dfDIMouse2)) )
+		OIS_EXCEPT( E_General, "Win32Mouse::Win32Mouse >> Failed to set format" );
+	
+	mHwnd = ((Win32InputManager*)mCreator)->getWindowHandle();
+
+	if( FAILED(mMouse->SetCooperativeLevel(mHwnd, coopSetting)) )
+		OIS_EXCEPT( E_General, "Win32Mouse::Win32Mouse >> Failed to set coop level" );
+	
+	if( FAILED(mMouse->SetProperty(DIPROP_BUFFERSIZE, &dipdw.diph )) )
+		OIS_EXCEPT( E_General, "Win32Mouse::Win32Mouse >> Failed to set property" );
+
+	HRESULT hr = mMouse->Acquire();
+	if (FAILED(hr) && hr != DIERR_OTHERAPPHASPRIO)
+		OIS_EXCEPT( E_General, "Win32Mouse::Win32Mouse >> Failed to aquire mouse!" );
+}
+
+//--------------------------------------------------------------------------------------------------//
+Win32Mouse::~Win32Mouse()
+{
+	if (mMouse)
+	{
+		mMouse->Unacquire();
+		mMouse->Release();
+		mMouse = 0;
+	}
+
+	static_cast<Win32InputManager*>(mCreator)->_setMouseUsed(false);
+}
+
+//--------------------------------------------------------------------------------------------------//
+void Win32Mouse::capture()
+{
+	//Clear old relative values
+	mState.X.rel = mState.Y.rel = mState.Z.rel = 0;
+
+	DIDEVICEOBJECTDATA diBuff[MOUSE_DX_BUFFERSIZE];
+	DWORD entries = MOUSE_DX_BUFFERSIZE;
+
+	HRESULT hr = mMouse->GetDeviceData( sizeof(DIDEVICEOBJECTDATA), diBuff, &entries, 0 );
+	if( hr != DI_OK )
+	{
+		hr = mMouse->Acquire();
+		while( hr == DIERR_INPUTLOST ) 
+			hr = mMouse->Acquire();
+
+		hr = mMouse->GetDeviceData( sizeof(DIDEVICEOBJECTDATA), diBuff, &entries, 0 );
+		
+		//Perhaps the user just tabbed away, and coop settings
+		//are nonexclusive..so just ignore
+		if( FAILED(hr) )
+			return;
+	}
+
+	bool axesMoved = false;
+	//Accumulate all axis movements for one axesMove message..
+	//Buttons are fired off as they are found
+	for(unsigned int i = 0; i < entries; ++i )
+	{
+		switch( diBuff[i].dwOfs )
+		{
+			case DIMOFS_BUTTON0:
+				if(!_doMouseClick(0, diBuff[i])) return;
+				break;
+			case DIMOFS_BUTTON1:
+				if(!_doMouseClick(1, diBuff[i])) return;
+				break;
+			case DIMOFS_BUTTON2:
+				if(!_doMouseClick(2, diBuff[i])) return;
+				break;
+			case DIMOFS_BUTTON3:
+				if(!_doMouseClick(3, diBuff[i])) return;
+				break;
+			case DIMOFS_BUTTON4:
+				if(!_doMouseClick(4, diBuff[i])) return;
+				break;	
+			case DIMOFS_BUTTON5:
+				if(!_doMouseClick(5, diBuff[i])) return;
+				break;
+			case DIMOFS_BUTTON6:
+				if(!_doMouseClick(6, diBuff[i])) return;
+				break;
+			case DIMOFS_BUTTON7:
+				if(!_doMouseClick(7, diBuff[i])) return;
+				break;
+			case DIMOFS_X:
+				mState.X.rel += diBuff[i].dwData;
+				axesMoved = true;
+				break;
+			case DIMOFS_Y:
+				mState.Y.rel += diBuff[i].dwData;
+				axesMoved = true;
+				break;
+			case DIMOFS_Z:
+				mState.Z.rel += diBuff[i].dwData;
+				axesMoved = true;
+				break;
+			default: break;
+		} //end switch
+	}//end for
+
+	if( axesMoved )
+	{
+		if( coopSetting & DISCL_NONEXCLUSIVE )
+		{
+			//DirectInput provides us with meaningless values, so correct that
+			POINT point;
+			GetCursorPos(&point);
+			ScreenToClient(mHwnd, &point);
+			mState.X.abs = point.x;
+			mState.Y.abs = point.y;
+		}
+		else
+		{
+			mState.X.abs +=  mState.X.rel;
+			mState.Y.abs +=  mState.Y.rel;
+		}
+		mState.Z.abs +=  mState.Z.rel;
+
+		//Clip values to window
+		if( mState.X.abs < 0 )
+			mState.X.abs = 0;
+		else if( mState.X.abs > mState.width )
+			mState.X.abs = mState.width;
+		if( mState.Y.abs < 0 )
+			mState.Y.abs = 0;
+		else if( mState.Y.abs > mState.height )
+			mState.Y.abs = mState.height;
+
+		//Do the move
+		if( mListener && mBuffered )
+			mListener->mouseMoved( MouseEvent( this, mState ) );
+	}
+}
+
+//--------------------------------------------------------------------------------------------------//
+bool Win32Mouse::_doMouseClick( int mouseButton, DIDEVICEOBJECTDATA& di )
+{
+	if( di.dwData & 0x80 )
+	{
+		mState.buttons |= 1 << mouseButton; //turn the bit flag on
+		if( mListener && mBuffered )
+			return mListener->mousePressed( MouseEvent( this, mState ), (MouseButtonID)mouseButton );
+	}
+	else
+	{
+		mState.buttons &= ~(1 << mouseButton); //turn the bit flag off
+		if( mListener && mBuffered )
+			return mListener->mouseReleased( MouseEvent( this, mState ), (MouseButtonID)mouseButton );
+	}
+
+	return true;
+}
+
+//--------------------------------------------------------------------------------------------------//
+void Win32Mouse::setBuffered(bool buffered)
+{
+	mBuffered = buffered;
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/OISWiiMote.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/OISWiiMote.cpp
new file mode 100644
index 0000000..93de94c
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/OISWiiMote.cpp
@@ -0,0 +1,373 @@
+#include "OISConfig.h"
+#ifdef OIS_WIN32_WIIMOTE_SUPPORT
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that
+		you wrote the original software. If you use this software in a product,
+		an acknowledgment in the product documentation would be appreciated but is
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "OISWiiMote.h"
+#include "OISWiiMoteFactoryCreator.h"
+#include "OISException.h"
+#include "OISWiiMoteForceFeedback.h"
+#define _USE_MATH_DEFINES
+#include <math.h>
+#include <limits.h>
+
+using namespace OIS;
+
+//-----------------------------------------------------------------------------------//
+WiiMote::WiiMote(InputManager* creator, int id, bool buffered, WiiMoteFactoryCreator* local_creator) :
+	JoyStick("cWiiMote", buffered, id, creator),
+	mWiiCreator(local_creator),
+	mtInitialized(false),
+	mRingBuffer(OIS_WII_EVENT_BUFFER),
+	mtLastButtonStates(0),
+	mtLastPOVState(0),
+	mtLastX(0.0f),
+	mtLastY(1.0f),
+	mtLastZ(0.0f),
+	mtLastNunChuckX(0.0f),
+	mtLastNunChuckY(1.0f),
+	mtLastNunChuckZ(0.0f),
+	mLastNunChuckXAxis(0),
+	mLastNunChuckYAxis(0),
+	_mWiiMoteMotionDelay(5),
+	mRumble(0)
+{
+	mRumble = new WiiMoteForceFeedback(mWiiMote);
+}
+
+//-----------------------------------------------------------------------------------//
+WiiMote::~WiiMote()
+{
+	delete mRumble;
+
+	if( mWiiMote.IsConnected() )
+	{
+		mWiiMote.StopDataStream();
+		mWiiMote.Disconnect();
+	}
+	mWiiCreator->_returnWiiMote(mDevID);
+}
+
+//-----------------------------------------------------------------------------------//
+void WiiMote::_initialize()
+{
+	if( mWiiMote.ConnectToDevice(mDevID) == false )
+		OIS_EXCEPT(E_InputDisconnected, "Error connecting to WiiMote!");
+
+	if( mWiiMote.StartDataStream() == false )
+		OIS_EXCEPT(E_InputDisconnected, "Error starting WiiMote data stream!");
+
+	//Fill in joystick information
+	mState.mVectors.clear();
+	mState.mButtons.clear();
+	mState.mAxes.clear();
+
+	if( mWiiMote.IsNunChuckAttached() )
+	{	//Setup for WiiMote + nunChuck
+		mState.mVectors.resize(2);
+		mState.mButtons.resize(9);
+		mState.mAxes.resize(2);
+		mState.mAxes[0].absOnly = true;
+		mState.mAxes[1].absOnly = true;
+	}
+	else
+	{	//Setup for WiiMote
+		mState.mVectors.resize(1);
+		mState.mButtons.resize(7);
+	}
+
+	mPOVs = 1;
+	mState.clear();
+	mtInitialized = true;
+}
+
+//-----------------------------------------------------------------------------------//
+void WiiMote::_threadUpdate()
+{
+	//Leave early if nothing is setup yet
+	if( mtInitialized == false )
+		return;
+
+	//Oops, no room left in ring buffer.. have to wait for client app to call Capture()
+	if( mRingBuffer.GetWriteAvailable() == 0 )
+		return;
+
+	WiiMoteEvent newEvent;
+	newEvent.clear();
+
+	//Update read
+	mWiiMote.HeartBeat();
+
+	//Get & check current button states
+	const cWiiMote::tButtonStatus &bState = mWiiMote.GetLastButtonStatus();
+	_doButtonCheck(bState.m1, 0, newEvent.pushedButtons, newEvent.releasedButtons);	//1
+	_doButtonCheck(bState.m2, 1, newEvent.pushedButtons, newEvent.releasedButtons);	//2
+	_doButtonCheck(bState.mA, 2, newEvent.pushedButtons, newEvent.releasedButtons);	//A
+	_doButtonCheck(bState.mB, 3, newEvent.pushedButtons, newEvent.releasedButtons);	//B
+	_doButtonCheck(bState.mPlus, 4, newEvent.pushedButtons, newEvent.releasedButtons);//+
+	_doButtonCheck(bState.mMinus, 5, newEvent.pushedButtons, newEvent.releasedButtons);//-
+	_doButtonCheck(bState.mHome, 6, newEvent.pushedButtons, newEvent.releasedButtons);//Home
+
+	//Check POV
+	newEvent.povChanged = _doPOVCheck(bState, newEvent.povDirection);
+
+	//Do motion check on main orientation - accounting for sensitivity factor
+	mWiiMote.GetCalibratedAcceleration(newEvent.x, newEvent.y, newEvent.z);
+	//Normalize new vector (old vector is already normalized)
+	float len = sqrt((newEvent.x*newEvent.x) + (newEvent.y*newEvent.y) + (newEvent.z*newEvent.z));
+	newEvent.x /= len;
+	newEvent.y /= len;
+	newEvent.z /= len;
+	
+	//Get new angle
+	float angle = acos((newEvent.x * mtLastX) + (newEvent.y * mtLastY) + (newEvent.z * mtLastZ));
+	if( angle > (mVector3Sensitivity * (M_PI / 180.0)) )
+	{	//Store for next check
+		mtLastX = newEvent.x;
+		mtLastY = newEvent.y;
+		mtLastZ = newEvent.z;
+
+		if( _mWiiMoteMotionDelay <= 0 )
+			newEvent.movement = true; //Set flag as moved
+		else
+			--_mWiiMoteMotionDelay;
+	}
+
+	//Act on NunChuck Data
+	if( mWiiMote.IsNunChuckAttached() )
+	{
+		const cWiiMote::tChuckReport &bState = mWiiMote.GetLastChuckReport();
+		_doButtonCheck(bState.mButtonC, 7, newEvent.pushedButtons, newEvent.releasedButtons); //C
+		_doButtonCheck(bState.mButtonZ, 8, newEvent.pushedButtons, newEvent.releasedButtons); //Z
+
+		mWiiMote.GetCalibratedChuckAcceleration(newEvent.nunChuckx, newEvent.nunChucky, newEvent.nunChuckz);
+		//Normalize new vector (old vector is already normalized)
+		float len = sqrt((newEvent.nunChuckx*newEvent.nunChuckx) + 
+			             (newEvent.nunChucky*newEvent.nunChucky) +
+						 (newEvent.nunChuckz*newEvent.nunChuckz));
+
+		newEvent.nunChuckx /= len;
+		newEvent.nunChucky /= len;
+		newEvent.nunChuckz /= len;
+
+		float angle = acos((newEvent.nunChuckx * mtLastNunChuckX) + 
+			               (newEvent.nunChucky * mtLastNunChuckY) +
+						   (newEvent.nunChuckz * mtLastNunChuckZ));
+
+		if( angle > (mVector3Sensitivity * (M_PI / 180.0)) )
+		{	//Store for next check
+			mtLastNunChuckX = newEvent.nunChuckx;
+			mtLastNunChuckY = newEvent.nunChucky;
+			mtLastNunChuckZ = newEvent.nunChuckz;
+
+			if( _mWiiMoteMotionDelay <= 0 )
+				newEvent.movementChuck = true;
+		}
+
+		//Ok, Now check both NunChuck Joystick axes for movement
+		float tempX = 0.0f, tempY = 0.0f;
+		mWiiMote.GetCalibratedChuckStick(tempX, tempY);
+		
+		//Convert to int and clip
+		newEvent.nunChuckXAxis = (int)(tempX * JoyStick::MAX_AXIS);
+		if( newEvent.nunChuckXAxis > JoyStick::MAX_AXIS )
+			newEvent.nunChuckXAxis = JoyStick::MAX_AXIS;
+		else if( newEvent.nunChuckXAxis < JoyStick::MIN_AXIS )
+			newEvent.nunChuckXAxis = JoyStick::MIN_AXIS;
+
+		newEvent.nunChuckYAxis = (int)(tempY * JoyStick::MAX_AXIS);
+		if( newEvent.nunChuckYAxis > JoyStick::MAX_AXIS )
+			newEvent.nunChuckYAxis = JoyStick::MAX_AXIS;
+		else if( newEvent.nunChuckYAxis < JoyStick::MIN_AXIS )
+			newEvent.nunChuckYAxis = JoyStick::MIN_AXIS;
+
+		//Apply a little dead-zone dampner
+		int xDiff = newEvent.nunChuckXAxis - mLastNunChuckXAxis;
+		if( xDiff > 1500 || xDiff < -1500 )
+		{
+			mLastNunChuckXAxis = newEvent.nunChuckXAxis;
+			newEvent.nunChuckXAxisMoved = true;
+		}
+
+		int yDiff = newEvent.nunChuckYAxis - mLastNunChuckYAxis;
+		if( yDiff > 1500 || yDiff < -1500 )
+		{
+			mLastNunChuckYAxis = newEvent.nunChuckYAxis;
+			newEvent.nunChuckYAxisMoved = true;
+		}
+	}
+
+	//Ok, put entry in ringbuffer if something changed
+	if(newEvent.pushedButtons || newEvent.releasedButtons || newEvent.povChanged || newEvent.movement ||
+	   newEvent.movementChuck || newEvent.nunChuckXAxisMoved || newEvent.nunChuckYAxisMoved)
+	{
+		mRingBuffer.Write(&newEvent, 1);
+	}
+
+	//mWiiMote.PrintStatus();
+}
+
+//-----------------------------------------------------------------------------------//
+void WiiMote::_doButtonCheck(bool new_state, int ois_button, unsigned int &pushed, unsigned int &released)
+{
+	const bool old_state = ((mtLastButtonStates & ( 1L << ois_button )) == 0) ? false : true;
+	
+	//Check to see if new state and old state are the same, and hence, need no change
+	if( new_state == old_state )
+		return;
+
+	//Ok, so it changed... but how?
+	if( new_state )
+	{	//Ok, new state is pushed, old state was not pushed.. so send button press
+		mtLastButtonStates |= 1 << ois_button; //turn the bit flag on
+		pushed |= 1 << ois_button;
+	}
+	else
+	{	//Ok, so new state is not pushed, and old state was pushed.. So, send release
+		mtLastButtonStates &= ~(1 << ois_button); //turn the bit flag off
+		released |= 1 << ois_button;
+	}
+}
+
+//-----------------------------------------------------------------------------------//
+bool WiiMote::_doPOVCheck(const cWiiMote::tButtonStatus &bState, unsigned int &newPosition)
+{
+	newPosition = Pov::Centered;
+
+	if( bState.mUp )
+		newPosition |= Pov::North;
+	else if( bState.mDown )
+		newPosition |= Pov::South;
+
+	if( bState.mLeft )
+		newPosition |= Pov::West;
+	else if( bState.mRight )
+		newPosition |= Pov::East;
+
+	//Was there a change?
+	if( mtLastPOVState != newPosition )
+	{
+		mtLastPOVState = newPosition;
+		return true;
+	}
+
+	return false;
+}
+
+//-----------------------------------------------------------------------------------//
+void WiiMote::setBuffered(bool buffered)
+{
+	mBuffered = buffered;
+}
+
+//-----------------------------------------------------------------------------------//
+void WiiMote::capture()
+{
+	//Anything to read?
+	int entries = mRingBuffer.GetReadAvailable();
+	if( entries <= 0 )
+		return;
+
+	WiiMoteEvent events[OIS_WII_EVENT_BUFFER];
+	if( entries > OIS_WII_EVENT_BUFFER )
+		entries = OIS_WII_EVENT_BUFFER;
+	
+	mRingBuffer.Read(events, entries);
+
+	//Loop through each event
+	for( int i = 0; i < entries; ++i )
+	{
+		//Any movement changes in the main accellerometers?
+		if( events[i].movement )
+		{
+			mState.mVectors[0].x = events[i].x;
+			mState.mVectors[0].y = events[i].y;
+			mState.mVectors[0].z = events[i].z;
+			if( mBuffered && mListener )
+				if( !mListener->vector3Moved( JoyStickEvent( this, mState ), 0 ) ) return;
+		}
+
+		//Check NunChuck movements
+		if( events[i].movementChuck )
+		{
+			mState.mVectors[1].x = events[i].nunChuckx;
+			mState.mVectors[1].y = events[i].nunChucky;
+			mState.mVectors[1].z = events[i].nunChuckz;
+			if( mBuffered && mListener )
+				if( !mListener->vector3Moved( JoyStickEvent( this, mState ), 1 ) ) return;
+		}
+
+		if( events[i].nunChuckXAxisMoved )
+		{
+			mState.mAxes[0].abs = events[i].nunChuckXAxis;
+
+			if( mBuffered && mListener )
+				if( !mListener->axisMoved( JoyStickEvent( this, mState ), 0 ) ) return;
+		}
+
+		if( events[i].nunChuckYAxisMoved )
+		{
+			mState.mAxes[1].abs = events[i].nunChuckYAxis;
+
+			if( mBuffered && mListener )
+				if( !mListener->axisMoved( JoyStickEvent( this, mState ), 1 ) ) return;
+		}
+
+		//Has the hat swtich changed?
+		if( events[i].povChanged )
+		{
+			mState.mPOV[0].direction = events[i].povDirection;
+			if( mBuffered && mListener )
+				if( !mListener->povMoved( JoyStickEvent( this, mState ), 0 ) ) return;
+		}
+
+		//Check for any pushed/released events for each button bit
+		int buttons = (int)mState.mButtons.size();
+		for( int b = 0; b < buttons; ++b )
+		{
+			unsigned bit_flag = 1 << b;
+			if( (events[i].pushedButtons & bit_flag) != 0 )
+			{	//send event
+				mState.mButtons[b] = true;
+				if( mBuffered && mListener )
+					if( !mListener->buttonPressed( JoyStickEvent( this, mState ), b ) ) return;
+			}
+
+			if( (events[i].releasedButtons & bit_flag) != 0 )
+			{	//send event
+				mState.mButtons[b] = false;
+				if( mBuffered && mListener )
+					if( !mListener->buttonReleased( JoyStickEvent( this, mState ), b ) ) return;
+			}
+		}
+	}
+}
+
+//-----------------------------------------------------------------------------------//
+Interface* WiiMote::queryInterface(Interface::IType type)
+{
+	if( type == Interface::ForceFeedback && mtInitialized )
+		return mRumble;
+
+	return 0;
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/OISWiiMote.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/OISWiiMote.h
new file mode 100644
index 0000000..7141398
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/OISWiiMote.h
@@ -0,0 +1,89 @@
+#include "OISConfig.h"
+#ifdef OIS_WIN32_WIIMOTE_SUPPORT
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that
+		you wrote the original software. If you use this software in a product,
+		an acknowledgment in the product documentation would be appreciated but is
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_WiiMote_H
+#define OIS_WiiMote_H
+#include "OISJoyStick.h"
+#include "OISWiiMoteRingBuffer.h"
+#include "wiimote.h"
+
+namespace OIS
+{
+	class WiiMoteFactoryCreator;
+	class WiiMoteForceFeedback;
+
+	//Number of ring buffer events. should be nice sized (the structure is not very big)
+	//Will be rounded up to power of two automatically
+	#define OIS_WII_EVENT_BUFFER 32
+
+	/**	Specialty joystick - WiiMote controller */
+	class _OISExport WiiMote : public JoyStick
+	{
+	public:
+		WiiMote(InputManager* creator, int id, bool buffered, WiiMoteFactoryCreator* local_creator);
+		~WiiMote();
+
+		//Overrides of Object
+		void setBuffered(bool buffered);
+
+		void capture();
+
+		Interface* queryInterface(Interface::IType type);
+
+		void _initialize();
+
+		void _threadUpdate();
+
+	protected:
+		void _doButtonCheck(bool new_state, int ois_button, unsigned int &pushed, unsigned int &released);
+		bool _doPOVCheck(const cWiiMote::tButtonStatus &bState, unsigned int &newPosition);
+
+		//! The creator who created us
+		WiiMoteFactoryCreator *mWiiCreator;
+
+		//! Actual WiiMote HID device
+		cWiiMote mWiiMote;
+
+		//! Used to signal thread that remote is ready
+		volatile bool mtInitialized;
+
+		//! Ringbuffer is used to store events from thread and be read from capture
+		WiiMoteRingBuffer mRingBuffer;
+
+		//Following variables are used entirely within threaded context
+		int mtLastButtonStates;
+		unsigned int mtLastPOVState;
+		float mtLastX, mtLastY, mtLastZ;
+		float mtLastNunChuckX, mtLastNunChuckY, mtLastNunChuckZ;
+		int mLastNunChuckXAxis, mLastNunChuckYAxis;
+
+		//Small workaround for slow calibration of wiimote data
+		int _mWiiMoteMotionDelay;
+
+		//Simple rumble force
+		WiiMoteForceFeedback *mRumble;
+	};
+}
+#endif //OIS_WiiMote_H
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/OISWiiMoteFactoryCreator.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/OISWiiMoteFactoryCreator.cpp
new file mode 100644
index 0000000..1f0b2d0
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/OISWiiMoteFactoryCreator.cpp
@@ -0,0 +1,206 @@
+#include "OISConfig.h"
+#ifdef OIS_WIN32_WIIMOTE_SUPPORT
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "OISWiiMoteFactoryCreator.h"
+#include "OISException.h"
+#include "OISWiiMote.h"
+#include <assert.h>
+#include <boost/thread.hpp>   //include here, keep compilation times down
+#include <boost/function.hpp>
+#include <boost/bind.hpp>
+
+
+using namespace OIS;
+
+//---------------------------------------------------------------------------------//
+WiiMoteFactoryCreator::WiiMoteFactoryCreator() :
+	mVendorName("cWiiMote"),
+	mCount(0),
+	mtThreadHandler(0),
+	mtWiiMoteListMutex(0),
+	mtThreadRunning(0)
+{
+	//Discover how many Wii's there are
+	for( ; mCount < OIS_cWiiMote_MAX_WIIS; ++mCount )
+	{
+		cWiiMote wii;
+		if( wii.ConnectToDevice(mCount) == false )
+			break;
+	}
+
+	//Store how many WiiMotes there were in the form of integer handles
+	for(int i = 0; i < mCount; ++i)
+		mFreeWiis.push_back(i);
+
+	//The mutex lasts the whole life of this class. The thread does not.
+	mtWiiMoteListMutex = new boost::mutex();
+}
+
+//---------------------------------------------------------------------------------//
+WiiMoteFactoryCreator::~WiiMoteFactoryCreator()
+{
+	//Thread (once all objects destroyed) should be killed off already
+	assert( (mtThreadRunning == false && mtThreadHandler == 0) && 
+		"~WiiMoteFactoryCreator(): invalid state.. Some objects left dangling!");
+
+	delete mtWiiMoteListMutex;
+}
+
+//---------------------------------------------------------------------------------//
+DeviceList WiiMoteFactoryCreator::freeDeviceList()
+{
+	DeviceList list;
+	for( std::deque<int>::iterator i = mFreeWiis.begin(); i != mFreeWiis.end(); ++i )
+	{
+		list.insert(std::make_pair(OISJoyStick, mVendorName));
+	}
+	return list;
+}
+
+//---------------------------------------------------------------------------------//
+int WiiMoteFactoryCreator::totalDevices(Type iType)
+{
+	if( iType == OISJoyStick )
+		return mCount;
+	else
+		return 0;
+}
+
+//---------------------------------------------------------------------------------//
+int WiiMoteFactoryCreator::freeDevices(Type iType)
+{
+	if( iType == OISJoyStick )
+		return (int)mFreeWiis.size();
+	else
+		return 0;
+}
+
+//---------------------------------------------------------------------------------//
+bool WiiMoteFactoryCreator::vendorExist(Type iType, const std::string & vendor)
+{
+	if( iType == OISJoyStick && mVendorName == vendor )
+		return true;
+	else
+		return false;
+}
+
+//---------------------------------------------------------------------------------//
+Object* WiiMoteFactoryCreator::createObject(InputManager* creator, Type iType, bool bufferMode, const std::string & vendor)
+{
+	if( mFreeWiis.size() > 0 && (vendor == "" || vendor == mVendorName ) )
+	{
+		int id = mFreeWiis.front();
+		mFreeWiis.pop_front();
+		WiiMote *wii = new WiiMote(creator, id, bufferMode, this);
+
+		if( mtThreadRunning == false )
+		{	//Create common thread manager (this is the first wiimote created)
+			mtThreadRunning = true;
+			mtThreadHandler = new boost::thread(boost::bind(&WiiMoteFactoryCreator::_updateWiiMotesThread, this));
+		}
+		
+		//Now, add new WiiMote to thread manager for polling
+		{	//Get an auto lock on the list of active wiimotes
+			boost::mutex::scoped_lock arrayLock(*mtWiiMoteListMutex);
+			mtInUseWiiMotes.push_back(wii);
+		}
+
+		return wii;
+	}
+	else
+		OIS_EXCEPT(E_InputDeviceNonExistant, "No Device found which matches description!");
+}
+
+//---------------------------------------------------------------------------------//
+void WiiMoteFactoryCreator::destroyObject(Object* obj)
+{
+	if( obj == 0 )
+		return;
+
+	int wiis_alive = 0;
+
+	{	//Get an auto lock on the list of active wiimotes
+		boost::mutex::scoped_lock arrayLock(*mtWiiMoteListMutex);
+
+		//Find object
+		std::vector<WiiMote*>::iterator i = std::find(mtInUseWiiMotes.begin(), mtInUseWiiMotes.end(), obj);
+		if( i == mtInUseWiiMotes.end() )
+			OIS_EXCEPT(E_General, "Device not found in wimote collection!");
+
+		//Erase opject
+		mtInUseWiiMotes.erase(i);
+
+		//Delete object
+		delete obj;
+
+		wiis_alive = (int)mtInUseWiiMotes.size();
+	}
+
+	//Destroy thread if no longer in use (we do this after unlocking mutex!)
+	if( wiis_alive == 0 && mtThreadRunning )
+	{
+		mtThreadRunning = false;
+		mtThreadHandler->join();
+		delete mtThreadHandler;
+		mtThreadHandler = 0;
+	}
+
+}
+
+//---------------------------------------------------------------------------------//
+void WiiMoteFactoryCreator::_returnWiiMote(int id)
+{	//Restore ID to controller pool
+	mFreeWiis.push_front(id);
+}
+
+//---------------------------------------------------------------------------------//
+bool WiiMoteFactoryCreator::_updateWiiMotesThread()
+{
+	boost::xtime timer;
+
+	while(mtThreadRunning)
+	{
+		int numMotes = 0;
+		{	//Get an auto lock on the list of active wiimotes
+			boost::mutex::scoped_lock arrayLock(*mtWiiMoteListMutex);
+			numMotes = (int)mtInUseWiiMotes.size();
+			for( std::vector<WiiMote*>::iterator i = mtInUseWiiMotes.begin(), e = mtInUseWiiMotes.end(); i != e; ++i )
+			{	//Update it
+				(*i)->_threadUpdate();
+			}
+		}
+
+		//ok, we have updated all wiimotes, let us rest a bit
+		//sleep time = 30 / 1000 
+		//boost::thread::sleep(xtime) todo xxx wip use sleep instead??
+		//boost::thread::yield();
+		boost::xtime_get(&timer, boost::TIME_UTC);
+		timer.nsec += 20000000; //20 000 000 ~= 1/50 sec
+		boost::thread::sleep(timer);
+	}
+
+	return true;
+}
+
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/OISWiiMoteFactoryCreator.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/OISWiiMoteFactoryCreator.h
new file mode 100644
index 0000000..1089c35
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/OISWiiMoteFactoryCreator.h
@@ -0,0 +1,103 @@
+#include "OISConfig.h"
+#ifdef OIS_WIN32_WIIMOTE_SUPPORT
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_WiiMoteFactoryCreator_H
+#define OIS_WiiMoteFactoryCreator_H
+
+#include "OISPrereqs.h"
+#include "OISFactoryCreator.h"
+#include <deque>
+
+//Forward declare boost classes used
+namespace boost
+{
+	class thread;
+	class mutex;
+}
+
+namespace OIS
+{
+	//Forward declare local classes
+	class WiiMote;
+
+	//! Max amount of Wiis we will attempt to find
+	#define OIS_cWiiMote_MAX_WIIS 4
+
+	/** WiiMote Factory Creator Class */
+	class _OISExport WiiMoteFactoryCreator : public FactoryCreator
+	{
+	public:
+		WiiMoteFactoryCreator();
+		~WiiMoteFactoryCreator();
+
+		//FactoryCreator Overrides
+		/** @copydoc FactoryCreator::deviceList */
+		DeviceList freeDeviceList();
+
+		/** @copydoc FactoryCreator::totalDevices */
+		int totalDevices(Type iType);
+
+		/** @copydoc FactoryCreator::freeDevices */
+		int freeDevices(Type iType);
+
+		/** @copydoc FactoryCreator::vendorExist */
+		bool vendorExist(Type iType, const std::string & vendor);
+
+		/** @copydoc FactoryCreator::createObject */
+		Object* createObject(InputManager* creator, Type iType, bool bufferMode, const std::string & vendor = "");
+
+		/** @copydoc FactoryCreator::destroyObject */
+		void destroyObject(Object* obj);
+
+		//! Local method used to return controller to pool
+		void _returnWiiMote(int id);
+
+	protected:
+		//! Internal - threaded method
+		bool _updateWiiMotesThread();
+
+		//! String name of this vendor
+		std::string mVendorName;
+
+		//! queue of open wiimotes (int represents index into hid device)
+		std::deque<int> mFreeWiis;
+
+		//! Number of total wiimotes
+		int mCount;
+
+		//! Boost thread execution object (only alive when at least 1 wiimote is alive)
+		boost::thread *mtThreadHandler;
+		
+		//! Gaurds access to the Active WiiMote List
+		boost::mutex *mtWiiMoteListMutex;
+
+		//! List of created (active) WiiMotes
+		std::vector<WiiMote*> mtInUseWiiMotes;
+
+		//! Used to signal thread running or not
+		volatile bool mtThreadRunning;
+	};
+}
+#endif //OIS_WiiMoteFactoryCreator_H
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/OISWiiMoteForceFeedback.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/OISWiiMoteForceFeedback.cpp
new file mode 100644
index 0000000..a78010d
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/OISWiiMoteForceFeedback.cpp
@@ -0,0 +1,76 @@
+#include "OISConfig.h"
+#ifdef OIS_WIN32_WIIMOTE_SUPPORT
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#include "OISWiiMoteForceFeedback.h"
+#include "OISEffect.h"
+
+using namespace OIS;
+
+//-----------------------------------------------------------------------------------//
+WiiMoteForceFeedback::WiiMoteForceFeedback(cWiiMote &wiiMote) : mWiiMote(wiiMote), mHandle(-1)
+{
+	//One and only supported effect
+	_addEffectTypes( OIS::Effect::ConstantForce, OIS::Effect::Constant );
+}
+
+//-----------------------------------------------------------------------------------//
+WiiMoteForceFeedback::~WiiMoteForceFeedback()
+{
+	mWiiMote.SetVibration(false);
+}
+
+//-----------------------------------------------------------------------------------//
+void WiiMoteForceFeedback::upload( const Effect* effect )
+{
+	if( effect )
+	{
+		//Multiple effects are useless, just return
+		if( mHandle != -1 || effect->_handle != -1) return;
+		
+		//Ok, so we are uploading a fresh effect
+		effect->_handle = mHandle = 1;
+
+		mWiiMote.SetVibration(true);
+	}
+}
+
+//-----------------------------------------------------------------------------------//
+void WiiMoteForceFeedback::modify( const Effect* effect )
+{
+	//Nothing to modify
+}
+
+//-----------------------------------------------------------------------------------//
+void WiiMoteForceFeedback::remove( const Effect* effect )
+{
+	//We have no effects uploaded, so just return
+	if( mHandle == -1 || effect == 0) return;
+
+	if( mHandle == effect->_handle )
+	{
+		mWiiMote.SetVibration(false);
+		mHandle = effect->_handle = -1;
+	}
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/OISWiiMoteForceFeedback.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/OISWiiMoteForceFeedback.h
new file mode 100644
index 0000000..834ab02
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/OISWiiMoteForceFeedback.h
@@ -0,0 +1,67 @@
+#include "OISConfig.h"
+#ifdef OIS_WIN32_WIIMOTE_SUPPORT
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+*/
+#ifndef OIS_WiiMoteForceFeedBack_H
+#define OIS_WiiMoteForceFeedBack_H
+
+#include "OISPrereqs.h"
+#include "OISForceFeedback.h"
+#include "wiimote.h"
+
+namespace OIS
+{
+	class WiiMoteForceFeedback : public ForceFeedback
+	{
+	public:
+		WiiMoteForceFeedback(cWiiMote &wiiMote);
+		~WiiMoteForceFeedback();
+
+		/** @copydoc ForceFeedback::upload */
+		void upload( const Effect* effect );
+
+		/** @copydoc ForceFeedback::modify */
+		void modify( const Effect* effect );
+
+		/** @copydoc ForceFeedback::remove */
+		void remove( const Effect* effect );
+
+		/** @copydoc ForceFeedback::setMasterGain */
+		void setMasterGain( float level ) {}
+		
+		/** @copydoc ForceFeedback::setAutoCenterMode */
+		void setAutoCenterMode( bool auto_on ) {}
+
+		/** @copydoc ForceFeedback::getFFAxesNumber */
+		short getFFAxesNumber() { return 1; }
+
+	protected:
+		//! The WiiMote associated with this effect interface
+		cWiiMote &mWiiMote;
+
+		//! The handle of the one and only allowed effect
+		int mHandle;
+	};
+}
+#endif //OIS_WiiMoteForceFeedBack_H
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/OISWiiMoteRingBuffer.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/OISWiiMoteRingBuffer.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/OISWiiMoteRingBuffer.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/OISWiiMoteRingBuffer.h
new file mode 100644
index 0000000..caf4356
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/OISWiiMoteRingBuffer.h
@@ -0,0 +1,313 @@
+#include "OISConfig.h"
+#ifdef OIS_WIN32_WIIMOTE_SUPPORT
+/*
+The zlib/libpng License
+
+Copyright (c) 2005-2007 Phillip Castaneda (pjcast -- www.wreckedgames.com)
+
+This software is provided 'as-is', without any express or implied warranty. In no event will
+the authors be held liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose, including commercial 
+applications, and to alter it and redistribute it freely, subject to the following
+restrictions:
+
+    1. The origin of this software must not be misrepresented; you must not claim that 
+		you wrote the original software. If you use this software in a product, 
+		an acknowledgment in the product documentation would be appreciated but is 
+		not required.
+
+    2. Altered source versions must be plainly marked as such, and must not be 
+		misrepresented as being the original software.
+
+    3. This notice may not be removed or altered from any source distribution.
+
+ # ------------------------#
+ # Original License follows:
+ # ------------------------#
+
+ * PortAudio Portable Real-Time Audio Library
+ * Latest version at: http://www.audiomulch.com/portaudio/
+ * <platform> Implementation
+ * Copyright (c) 1999-2000 <author(s)>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files
+ * (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * Any person wishing to distribute modifications to the Software is
+ * requested to send the modifications to the original developer so that
+ * they can be incorporated into the canonical version.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef OIS_WiiMoteRingBuffer_H
+#define OIS_WiiMoteRingBuffer_H
+
+#include "OISPrereqs.h"
+
+namespace OIS
+{
+	struct WiiMoteEvent
+	{
+		//! (7 buttons) If a button was just pressed, the bit will be set
+		unsigned int pushedButtons;
+
+		//! (7 buttons) If a button was just released, the bit will be set
+		unsigned int releasedButtons;
+
+		//! Will be true if POV changed this event
+		bool povChanged;
+
+		//! Will be valid if povChanged = true
+		unsigned int povDirection;
+
+		//! Will be valid if a movement just occurred on main motion sensing
+		bool movement;
+
+		//Values of main orientation vector
+		float x, y, z;
+
+		//! Will be valid if a movement just occurred on main motion sensing
+		bool movementChuck;
+
+		//Values of main orientation vector
+		float nunChuckx, nunChucky, nunChuckz;
+
+		//Used to flag when a Nunchuck axis moved
+		bool nunChuckXAxisMoved, nunChuckYAxisMoved;
+
+		//Values of NunChuck JoyStick
+		int nunChuckXAxis, nunChuckYAxis;
+
+		//! clear initial state
+		void clear()
+		{
+			pushedButtons = releasedButtons = 0;
+			povChanged = false;
+			povDirection = 0;
+
+			movement = false;
+			x = y = z = 0.0f;
+
+			nunChuckx = nunChucky = nunChuckz = 0;
+			movementChuck = false;
+
+			nunChuckXAxisMoved = nunChuckYAxisMoved = false;
+			nunChuckXAxis = nunChuckYAxis = 0;
+		}
+	};
+
+	/// <summary>
+	/// Ring Buffer (fifo) used to store 16bit pcm data
+	/// </summary>
+	class WiiMoteRingBuffer
+	{
+	private:
+		//! Number of bytes in FIFO. Power of 2. Set by RingBuffer_Init
+		int bufferSize;
+		//! Used for wrapping indices with extra bit to distinguish full/empty.
+		int bigMask;
+		// Used for fitting indices to buffer.
+		int smallMask;
+
+		// Buffer holding the actual event buffers
+		WiiMoteEvent *buffer;
+
+		//! Index of next writable byte. Set by RingBuffer_AdvanceWriteIndex.
+		volatile int writeIndex; 
+		
+		//! Index of next readable byte. Set by RingBuffer_AdvanceReadIndex.
+		volatile int readIndex;	
+
+	public:
+		WiiMoteRingBuffer( unsigned int numEntries )
+		{
+			numEntries = RoundUpToNextPowerOf2( numEntries );
+
+			//2 bytes per short
+			bufferSize = (int)numEntries;
+			buffer = new WiiMoteEvent[numEntries];
+		
+			Flush();
+		
+			bigMask = (int)(numEntries*2)-1;
+			smallMask = (int)(numEntries)-1;
+		}
+
+		~WiiMoteRingBuffer()
+		{
+			delete buffer;
+		}
+
+		unsigned int RoundUpToNextPowerOf2( unsigned int n )
+		{
+			int numBits = 0;
+			if( ((n-1) & n) == 0) 
+			return n; //Already Power of two.
+
+			while( n > 0 )
+			{
+				n= n>>1;
+				numBits++;
+			}
+			return (unsigned int)(1<<numBits);
+		}
+
+
+		int GetReadAvailable( )
+		{
+			return ( (writeIndex - readIndex) & bigMask );
+		}
+
+
+		int GetWriteAvailable( )
+		{
+			return ( bufferSize - GetReadAvailable());
+		}
+
+
+		int Write( WiiMoteEvent *data, int numEntries )
+		{
+			int size1 = 0, size2 = 0, numWritten;
+			int data1Ptr = 0, data2Ptr = 0;
+			
+			numWritten = GetWriteRegions( numEntries, data1Ptr, size1, data2Ptr, size2 );
+
+			if( size2 > 0 )
+			{
+				//copy to two parts
+				memcpy( &buffer[data1Ptr], data, sizeof(WiiMoteEvent) * size1 );
+				//Array.Copy( data, offsetPtr, buffer, data1Ptr, size1 );
+				memcpy( &buffer[data2Ptr], &data[size1], sizeof(WiiMoteEvent) * size2 );
+				//Array.Copy( data, offsetPtr + size1, buffer, data2Ptr, size2 );
+			}
+			else
+			{	//Copy all continous
+				memcpy( &buffer[data1Ptr], data, sizeof(WiiMoteEvent) * size1 );
+				//Array.Copy( data, offsetPtr, buffer, data1Ptr, size1 );
+			}
+			AdvanceWriteIndex( numWritten );
+			return numWritten;
+		}
+
+
+		/// <summary>
+		/// Reads requested number of entries into sent array.
+		/// Returns number written
+		/// </summary>
+		int Read( WiiMoteEvent *data, int numEntries )
+		{
+			int size1 = 0, size2 = 0, numRead, data1Ptr = 0, data2Ptr = 0;
+			
+			numRead = GetReadRegions( numEntries, data1Ptr, size1, data2Ptr, size2 );
+			
+			if( size2 > 0 )
+			{
+				memcpy( data, &buffer[data1Ptr], sizeof(WiiMoteEvent) * size1 );
+				//Array.Copy( buffer, data1Ptr, data, 0, size1 );
+				memcpy( &data[size1], &buffer[data2Ptr], sizeof(WiiMoteEvent) * size2 );
+				//Array.Copy( buffer, data2Ptr, data, size1, size2 );
+			}
+			else
+				memcpy( data, &buffer[data1Ptr], sizeof(WiiMoteEvent) * size1 );
+				//Array.Copy( buffer, data1Ptr, data, 0, size1 );
+
+			AdvanceReadIndex( numRead );
+			return numRead;
+		}
+
+	private:
+
+		int GetWriteRegions( int numEntries, int &dataPtr1, int &sizePtr1,
+							 int &dataPtr2, int &sizePtr2 )
+		{
+			int   index;
+			int   available = GetWriteAvailable();
+			if( numEntries > available ) 
+				numEntries = available;
+		
+			//Check to see if write is not contiguous.
+			index = writeIndex & smallMask;
+			if( (index + numEntries) > bufferSize )
+			{
+				//Write data in two blocks that wrap the buffer.
+				int   firstHalf = bufferSize - index;
+				dataPtr1 = index;//&buffer[index];
+				sizePtr1 = firstHalf;
+				dataPtr2 = 0;//&buffer[0];
+				sizePtr2 = numEntries - firstHalf;
+			}
+			else
+			{
+				dataPtr1 = index;//&buffer[index];
+				sizePtr1 = numEntries;
+				dataPtr2 = 0;
+				sizePtr2 = 0;
+			}
+			return numEntries;
+		}
+	
+
+		int GetReadRegions( int numEntries, int &dataPtr1, int &sizePtr1, int &dataPtr2, int &sizePtr2 )
+		{
+			int   index;
+			int   available = GetReadAvailable( );
+			if( numEntries > available ) 
+				numEntries = available;
+			
+			// Check to see if read is not contiguous
+			index = readIndex & smallMask;
+			if( (index + numEntries) > bufferSize )
+			{
+				// Write data in two blocks that wrap the buffer
+				int firstHalf = bufferSize - index;
+				dataPtr1 = index;//&buffer[index];
+				sizePtr1 = firstHalf;
+				dataPtr2 = 0;//&buffer[0];
+				sizePtr2 = numEntries - firstHalf;
+			}
+			else
+			{
+				dataPtr1 = index;//&buffer[index];
+				sizePtr1 = numEntries;
+				dataPtr2 = 0;
+				sizePtr2 = 0;
+			}
+			return numEntries;
+		}
+
+
+		int AdvanceWriteIndex( int numEntries )
+		{
+			 return writeIndex = (writeIndex + numEntries) & bigMask;
+		}
+
+
+		int AdvanceReadIndex( int numEntries )
+		{
+			return readIndex = (readIndex + numEntries) & bigMask;
+		}
+
+
+		void Flush( )
+		{
+			writeIndex = readIndex = 0;
+		}
+	};
+}
+#endif //#define OIS_WiiMoteRingBuffer_H
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/hiddevice.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/hiddevice.cpp
new file mode 100644
index 0000000..d484426
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/hiddevice.cpp
@@ -0,0 +1,205 @@
+#include "OISConfig.h"
+#ifdef OIS_WIN32_WIIMOTE_SUPPORT
+//cWiimote 0.2 by Kevin Forbes (http://simulatedcomicproduct.com)
+//This code is public domain, and comes with no warranty. The user takes full responsibility for anything that happens as a result from using this code.
+//This was based in part on Alan Macek <www.alanmacek.com>'s USB interface library
+
+//Edited for Toshiba Stack support (hopefully also all others) by 
+//Sean Stellingwerff (http://sean.stellingwerff.com) using information
+//gathered from http://www.lvr.com/hidpage.htm (Thanks a million! :D) 
+
+//#include "stdafx.h"
+#include "hiddevice.h"
+
+extern "C" 
+{
+	#include "hidsdi.h"
+	#include <Setupapi.h>
+}
+#pragma comment(lib, "setupapi.lib")
+#pragma comment(lib, "hid.lib")
+
+HIDP_CAPS							Capabilities;
+PSP_DEVICE_INTERFACE_DETAIL_DATA	detailData;
+
+cHIDDevice::cHIDDevice() : mConnected(false), mHandle(NULL), mEvent(NULL)
+{
+}
+
+
+cHIDDevice::~cHIDDevice()
+{
+	if (mConnected)
+	{
+		Disconnect();
+	}
+}
+
+bool cHIDDevice::Disconnect()
+{
+	bool retval = false;
+	if (mConnected)
+	{
+		retval = (CloseHandle(mHandle) == TRUE && CloseHandle(mEvent) == TRUE);
+	
+		mConnected = false;
+	}
+
+	return retval;
+}
+
+bool cHIDDevice::Connect(unsigned short device_id, unsigned short vendor_id, int index)
+{
+	if (mConnected)
+	{
+		if (!Disconnect())
+		{
+			return false;
+		}
+	}
+
+	// Find the wiimote(s)
+	//for (int i = 0; i <= index; i++)
+	OpenDevice( device_id, vendor_id, index );
+
+	return mConnected;
+}
+
+bool cHIDDevice::OpenDevice(unsigned short device_id, unsigned short vendor_id, int index)
+{
+	//Use a series of API calls to find a HID with a specified Vendor IF and Product ID.
+	HIDD_ATTRIBUTES						Attributes;
+	SP_DEVICE_INTERFACE_DATA			devInfoData;
+	bool								LastDevice = FALSE;
+	bool								MyDeviceDetected = FALSE; 
+	int									MemberIndex = 0;
+	int									MembersFound = 0;
+	GUID								HidGuid;
+	ULONG								Length;
+	LONG								Result;
+	HANDLE								hDevInfo;
+	ULONG								Required;
+
+	Length = 0;
+	detailData = NULL;
+	mHandle=NULL;
+
+	HidD_GetHidGuid(&HidGuid);	
+	hDevInfo=SetupDiGetClassDevs(&HidGuid, NULL, NULL, DIGCF_PRESENT|DIGCF_INTERFACEDEVICE);
+		
+	devInfoData.cbSize = sizeof(devInfoData);
+
+	MemberIndex = 0;
+	MembersFound = 0;
+	LastDevice = FALSE;
+
+	do
+	{
+		Result=SetupDiEnumDeviceInterfaces(hDevInfo, 0, &HidGuid, MemberIndex, &devInfoData);
+		if (Result != 0)
+		{
+			Result = SetupDiGetDeviceInterfaceDetail(hDevInfo, &devInfoData, NULL, 0, &Length, NULL);
+
+			detailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)malloc(Length);
+			detailData -> cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
+			Result = SetupDiGetDeviceInterfaceDetail(hDevInfo, &devInfoData, detailData, Length, &Required, NULL);
+
+			mHandle=CreateFile(detailData->DevicePath, 0, FILE_SHARE_READ|FILE_SHARE_WRITE, (LPSECURITY_ATTRIBUTES)NULL,OPEN_EXISTING, 0, NULL);
+			Attributes.Size = sizeof(Attributes);
+
+			Result = HidD_GetAttributes(mHandle, &Attributes);
+			//Is it the desired device?
+
+			MyDeviceDetected = FALSE;
+
+			if (Attributes.VendorID == vendor_id)
+			{
+				if (Attributes.ProductID == device_id)
+				{
+					if (MembersFound == index)
+					{
+						//Both the Vendor ID and Product ID match.
+						//printf("Wiimote found!\n");
+						mConnected = true;
+						GetCapabilities();
+
+						WriteHandle=CreateFile(detailData->DevicePath, GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, (LPSECURITY_ATTRIBUTES)NULL, OPEN_EXISTING, 0, NULL);
+						MyDeviceDetected = TRUE;
+
+						PrepareForOverlappedTransfer();
+
+						mEvent = CreateEvent(NULL, TRUE, TRUE, "");
+						mOverlapped.Offset = 0;
+						mOverlapped.OffsetHigh = 0;
+						mOverlapped.hEvent = mEvent;
+					
+					} else { 
+						//The Product ID doesn't match.
+						CloseHandle(mHandle);
+					}
+
+					MembersFound++;
+				}
+			} else {
+				CloseHandle(mHandle);
+			}
+			free(detailData);
+		} else {
+			LastDevice=TRUE;
+		}
+		MemberIndex = MemberIndex + 1;
+	} while ((LastDevice == FALSE) && (MyDeviceDetected == FALSE));
+
+	SetupDiDestroyDeviceInfoList(hDevInfo);
+	return MyDeviceDetected;
+}
+
+bool cHIDDevice::WriteToDevice(unsigned const char * OutputReport, int num_bytes)
+{
+	bool retval = false;
+	if (mConnected)
+	{
+		DWORD bytes_written;
+		retval = (WriteFile( WriteHandle, OutputReport, num_bytes, &bytes_written, &mOverlapped) == TRUE); 
+		retval = retval && bytes_written == num_bytes;
+	}
+	return retval;
+}
+
+void cHIDDevice::PrepareForOverlappedTransfer()
+{
+	//Get a handle to the device for the overlapped ReadFiles.
+	ReadHandle=CreateFile(detailData->DevicePath, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE, (LPSECURITY_ATTRIBUTES)NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
+}
+
+void cHIDDevice::GetCapabilities()
+{
+	//Get the Capabilities structure for the device.
+	PHIDP_PREPARSED_DATA PreparsedData;
+	HidD_GetPreparsedData(mHandle, &PreparsedData);
+	HidP_GetCaps(PreparsedData, &Capabilities);
+
+	//No need for PreparsedData any more, so free the memory it's using.
+	HidD_FreePreparsedData(PreparsedData);
+}
+
+bool cHIDDevice::ReadFromDevice(unsigned const char * buffer, int max_bytes, int & bytes_read, int timeout)
+{
+	bool retval = false;
+	if (mConnected)
+	{
+		ReadFile( ReadHandle, (LPVOID)buffer,max_bytes,(LPDWORD)&bytes_read,(LPOVERLAPPED) &mOverlapped); 
+		DWORD Result = WaitForSingleObject(mEvent, timeout);
+		if (Result == WAIT_OBJECT_0) 
+		{		
+			retval = true;
+		}
+		else 
+		{
+			CancelIo(mHandle);			
+		}
+		ResetEvent(mEvent);
+	}
+	return retval;
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/hiddevice.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/hiddevice.h
new file mode 100644
index 0000000..2867421
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/hiddevice.h
@@ -0,0 +1,41 @@
+#include "OISConfig.h"
+#ifdef OIS_WIN32_WIIMOTE_SUPPORT
+//cWiimote 0.2 by Kevin Forbes (http://simulatedcomicproduct.com)
+//This code is public domain, and comes with no warranty. The user takes full responsibility for anything that happens as a result from using this code.
+
+#ifndef HIDDEVICE_H
+#define HIDDEVICE_H
+
+#include <windows.h>
+
+class cHIDDevice
+{
+public:
+	cHIDDevice();
+	~cHIDDevice();
+	bool Disconnect();
+	bool Connect(unsigned short device_id, unsigned short vendor_id, int index=0);
+	bool IsConnected() const {return mConnected;}
+
+	bool WriteToDevice(unsigned const char * OutputReport, int num_bytes);
+	bool ReadFromDevice(unsigned const char * buffer, int max_bytes, int & bytes_read, int timeout=50);
+private:
+
+	//bool OpenDevice(int index, unsigned short device_id, unsigned short vendor_id);
+	bool OpenDevice(unsigned short device_id, unsigned short vendor_id, int index);
+	//bool FindWiimote();
+	void GetCapabilities();
+	void PrepareForOverlappedTransfer();
+	
+	HANDLE mHandle;
+	HANDLE mEvent;
+	HANDLE WriteHandle;
+	HANDLE ReadHandle;
+	OVERLAPPED mOverlapped;
+	OVERLAPPED HIDOverlapped;
+//	HIDP_CAPS Capabilities;
+	bool mConnected;
+
+};
+#endif
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/main.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/main.cpp
new file mode 100644
index 0000000..28f2f70
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/main.cpp
@@ -0,0 +1,45 @@
+//cWiimote 0.2 by Kevin Forbes (http://simulatedcomicproduct.com)
+//This code is public domain, and comes with no warranty. The user takes full responsibility for anything that happens as a result from using this code.
+
+//#include "wiimote.h"
+//#include <stdio.h>
+
+//Features:
+// Read Accelerometer, button values from the wiimote
+// Read Accelerometer, stick, and button values from the nunchuck
+// Preliminary IR support
+
+//Known issues:
+// The IR support is spotty at best. It tends to kick out if you plug your 'chuck in and out too many times
+// Reading 'chuck calibration data doesn't seem to work, so the code just uses defaults
+// Multiple Wiimote support not yet tested
+// May only work with Bluesoleil stack?
+
+//Instructions:
+// See below for how to connect to a device and start the data stream.
+// It is up to the user to call heartbeat fast enough - if you're too slow, you will loose data. Ideally, this would be done in a separate thread
+// There are several public functions for getting the values from the wiimote. Look in cWiiMote::PrintStatus for examples.
+
+//Version History:
+//0.1 Preliminary Release
+//0.2 Added nunchuck, IR support
+
+/*
+int main(int nargs, const char * cargs)
+{
+	cWiiMote wiimote;
+	
+	if (wiimote.ConnectToDevice() &&
+		wiimote.StartDataStream())
+	{
+		for (;;)
+		{
+			wiimote.HeartBeat();
+			wiimote.PrintStatus();
+		}
+	}
+	return 0;
+}
+*/
+
+//#eof "$Id: main.cpp,v 1.1.2.1 2008/02/14 03:33:36 pjcast Exp $"
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/wiimote.cpp b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/wiimote.cpp
new file mode 100644
index 0000000..2a0d292
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/wiimote.cpp
@@ -0,0 +1,794 @@
+#include "OISConfig.h"
+#ifdef OIS_WIN32_WIIMOTE_SUPPORT
+//cWiimote 0.2 by Kevin Forbes (http://simulatedcomicproduct.com)
+//This code is public domain, and comes with no warranty. The user takes full responsibility for anything that happens as a result from using this code.
+
+//Edited for Toshiba Stack support (hopefully also all others) by 
+//Sean Stellingwerff (http://sean.stellingwerff.com) using information
+//gathered from http://www.lvr.com/hidpage.htm (Thanks a million! :D) 
+
+//#include "stdafx.h"
+#include "wiimote.h"
+#include <stdio.h>
+
+//output channels
+const unsigned char OUTPUT_CHANNEL_FORCE_FEEDBACK = 0x13;
+const unsigned char OUTPUT_CHANNEL_LED = 0x11;
+const unsigned char OUTPUT_CHANNEL_REPORT = 0x12;
+const unsigned char OUTPUT_READ_MEMORY = 0x17;
+const unsigned char OUTPUT_WRITE_MEMORY = 0x16;
+
+const unsigned char OUTPUT_ENABLE_IR = 0x13;
+const unsigned char OUTPUT_ENABLE_IR2 = 0x1a;
+
+//report request types
+const unsigned char REQUEST_CONTINUOUS_REPORTS = 0x4;
+const unsigned char REQUEST_SINGLE_REPORTS = 0x0;
+
+//input channels
+const unsigned char INPUT_CHANNEL_BUTTONS_ONLY = 0x30;
+const unsigned char INPUT_CHANNEL_BUTTONS_MOTION = 0x31;
+const unsigned char INPUT_CHANNEL_WRITE_CONFIRM = 0x22;
+const unsigned char INPUT_CHANNEL_EXPANSION_PORT = 0x20;
+
+const unsigned char INPUT_CHANNEL_MOTION_IR = 0x33;
+const unsigned char INPUT_CHANNEL_MOTION_CHUCK_IR = 0x37;
+const unsigned char INPUT_CHANNEL_MOTION_CHUCK = 0x35;
+
+//the ID values for a wiimote
+const unsigned short mVendorID = 0x057E;
+const unsigned short mDeviceID = 0x0306;
+
+//how to find the calibration data for the wiimote
+const unsigned short CALIBRATION_ADDRESS = 0x16;
+const unsigned short CALIBRATION_DATA_LENGTH = 7;
+
+//nunchuck constants
+const unsigned long NUNCHUCK_STATUS_ADDRESS = 0x04A40000;
+const unsigned long NUNCHUCK_CALIBRATION_ADDRESS = 0x04A40020;
+const unsigned long NUNCHUCK_CALIBRATION_ADDRESS_2 = 0x04A40030;
+const unsigned long NUNCHUCK_INIT_ADDRESS= 0x04A40040;
+const unsigned long NUNCHUK_ID_ADDRESS = 0x04a400f0;
+const unsigned char NUNCHUCK_INIT_VAL= 0x0;
+
+//IR constants
+const unsigned long IR_REG_1 = 0x04b00030;
+const unsigned long IR_REG_2 = 0x04b00033;
+const unsigned long IR_SENS_ADDR_1 = 0x04b00000;
+const unsigned long IR_SENS_ADDR_2 = 0x04b0001a;
+
+const unsigned char IR_SENS_MIDRANGE_PART1[] = {0x02, 0x00, 0x00, 0x71, 0x01, 0x00, 0xaa, 0x00, 0x64};
+const unsigned char IR_SENS_MIDRANGE_PART2[] = {0x63, 0x03};
+
+const unsigned char IR_MODE_OFF = 0;
+const unsigned char IR_MODE_STD = 1;
+const unsigned char IR_MODE_EXP = 3;
+const unsigned char IR_MODE_FULL = 5;
+
+cWiiMote::cWiiMote()
+{
+	Init();
+}
+
+cWiiMote::~cWiiMote()
+{
+	Disconnect();
+}
+
+void cWiiMote::Init()
+{
+	mReportMode = REPORT_MODE_EVENT_BUTTONS;
+	mLastButtonStatus.Init();
+	mLastExpansionReport.Init();
+	mLastMotionReport.Init();
+	mOutputControls.Init();
+	mReadInfo.Init();
+	mAccelCalibrationData.Init();
+	mNunchuckAccelCalibrationData.Init();
+	mNunchuckStickCalibrationData.Init();
+	mLastIRReport.Init();
+	mNunchuckAttached = false;
+	mIRRunning = false;
+	mDataStreamRunning = false;
+}
+
+bool cWiiMote::SetReportMode(eReportMode mode)
+{
+	mReportMode = mode;
+	return SendReportMode();
+}
+
+bool cWiiMote::SendReportMode()
+{
+	bool continuous = true;
+	unsigned char channel = INPUT_CHANNEL_BUTTONS_ONLY;
+	bool check_chuck = false;
+	
+	switch (mReportMode)
+	{
+	case REPORT_MODE_MOTION_IR:
+		channel = INPUT_CHANNEL_MOTION_IR;
+		break;
+	case REPORT_MODE_MOTION_CHUCK_IR:
+		channel = INPUT_CHANNEL_MOTION_CHUCK_IR;
+		check_chuck = true;
+		break;
+	case REPORT_MODE_MOTION_CHUCK:
+		channel = INPUT_CHANNEL_MOTION_CHUCK;
+		check_chuck = true;
+		break;
+	case REPORT_MODE_MOTION:
+		channel = INPUT_CHANNEL_BUTTONS_MOTION;
+		break;
+	case REPORT_MODE_EVENT_BUTTONS:
+		channel = INPUT_CHANNEL_BUTTONS_ONLY;
+		continuous = false;
+		break;
+	default:
+		break;
+	}
+
+	//check to make sure that there is a chuck attached
+//	if (check_chuck && !mNunchuckAttached)
+//	{
+//		printf("Supposed to check for nunchuck, but couldn't find one!");
+//		return false;
+//	}
+
+	bool retval = SelectInputChannel(continuous,channel);
+	return retval;
+}
+
+bool cWiiMote::ConnectToDevice(int index)
+{
+	Init();
+	const bool retval = mHIDDevice.Connect(mDeviceID,mVendorID,index) && 
+						SetReportMode(REPORT_MODE_MOTION_CHUCK_IR) && 
+						UpdateOutput() &&
+						ReadCalibrationData();
+
+	if (retval)
+	{
+		InitNunchuck();
+	}
+	return retval;
+}
+
+bool cWiiMote::Disconnect()
+{
+	bool retval = false;
+	StopDataStream();
+	
+	if (mHIDDevice.IsConnected())
+	{
+		retval = mHIDDevice.Disconnect();
+	}
+
+	return retval;
+}
+
+bool cWiiMote::SetVibration(bool vib_on)
+{
+	bool retval = true;
+	if (mOutputControls.mVibration != vib_on)
+	{
+		mOutputControls.mVibration = vib_on;
+		retval = UpdateOutput();
+	}
+	return retval;
+}
+
+void cWiiMote::ClearBuffer()
+{
+	memset(mOutputBuffer,0, mOutputBufferSize);
+}
+
+bool cWiiMote::SetLEDs(bool led1, bool led2, bool led3, bool led4)
+{
+	const bool no_change = mOutputControls.mLED1 == led1 &&
+							mOutputControls.mLED2 == led2 &&
+							mOutputControls.mLED3 == led3 &&
+							mOutputControls.mLED4 == led4;
+
+	if (no_change)
+	{
+		return true;
+	}
+
+	mOutputControls.mLED1 = led1;
+	mOutputControls.mLED2 = led2;	
+	mOutputControls.mLED3 = led3;
+	mOutputControls.mLED4 = led4;
+	return UpdateOutput();
+}
+
+bool cWiiMote::UpdateOutput()
+{
+	ClearBuffer();
+	mOutputBuffer[0] = OUTPUT_CHANNEL_LED;
+	mOutputBuffer[1] =  (mOutputControls.mVibration ? 0x1 : 0x0) |
+						(mOutputControls.mLED1 ? 0x1 : 0x0) << 4 | 
+						(mOutputControls.mLED2 ? 0x1 : 0x0) << 5 | 
+						(mOutputControls.mLED3 ? 0x1 : 0x0) << 6 | 
+						(mOutputControls.mLED4 ? 0x1 : 0x0) << 7; 
+	return mHIDDevice.WriteToDevice(mOutputBuffer,mOutputBufferSize);
+}
+
+bool cWiiMote::HeartBeat(int timeout)
+{
+	bool retval = true;
+	int bytes_read = 0;
+	
+
+	//most of these reports aren't implemented yet. I don't have a sensor bar or a nunchuck :)
+	if (mHIDDevice.ReadFromDevice(mInputBuffer,mInputBufferSize,bytes_read) && (bytes_read > 0,timeout))
+	{
+		const int channel = mInputBuffer[0];
+		switch (channel)
+		{
+			case INPUT_CHANNEL_EXPANSION_PORT:// 	 6 	Expansion Port change
+				{
+					ParseButtonReport(&mInputBuffer[1]);
+					ParseExpansionReport(&mInputBuffer[2]);
+					bool restart = mDataStreamRunning;
+					StopDataStream();
+					InitNunchuck();
+					
+					if (restart)
+					{
+						retval = StartDataStream();
+					}
+				}
+			break;
+
+			case INPUT_CHANNEL_BUTTONS_ONLY:// 	2 	Buttons only
+				ParseButtonReport(&mInputBuffer[1]);
+			break;
+
+			case 0x21:// 	21 	Read data
+				ParseButtonReport(&mInputBuffer[1]);
+				ParseReadData(&mInputBuffer[3]);
+				break;
+
+			case INPUT_CHANNEL_WRITE_CONFIRM:// 	4 	Write data
+			break;
+
+			case 0x31:// 	5 	Buttons | Motion Sensing Report
+				ParseButtonReport(&mInputBuffer[1]);
+				ParseMotionReport(&mInputBuffer[3]);
+			break;
+
+			case 0x32:// 	16 	Buttons | Expansion Port | IR??
+				ParseButtonReport(&mInputBuffer[1]);
+			break;
+
+			case INPUT_CHANNEL_MOTION_IR:
+				ParseButtonReport(&mInputBuffer[1]);
+				ParseMotionReport(&mInputBuffer[3]);
+				ParseIRReport(&mInputBuffer[6]);
+			break;
+
+			case INPUT_CHANNEL_MOTION_CHUCK_IR:
+				ParseButtonReport(&mInputBuffer[1]);
+				ParseMotionReport(&mInputBuffer[3]);
+				ParseIRReport(&mInputBuffer[6]);
+				ParseChuckReport(&mInputBuffer[16]);
+			break;
+
+			case INPUT_CHANNEL_MOTION_CHUCK:
+				ParseButtonReport(&mInputBuffer[1]);
+				ParseMotionReport(&mInputBuffer[3]);
+				ParseChuckReport(&mInputBuffer[6]);
+
+			break;
+
+			case 0x34:// 	21 	Buttons | Expansion Port | IR??
+			case 0x3d:// 	21 	Buttons | Expansion Port | IR??
+				ParseButtonReport(&mInputBuffer[1]);
+			break;
+
+			case 0x3e:// 	21 	Buttons | Motion Sensing Report | IR??
+			case 0x3f:// 	21 	Buttons | Motion Sensing Report | IR??
+				ParseButtonReport(&mInputBuffer[1]);
+			break;
+			default:
+				retval = false;
+				//unknown report
+			break;
+		}		
+	}
+	return retval;
+}
+
+void cWiiMote::ParseExpansionReport(const unsigned char *data)
+{
+	//four bytes long
+	mLastExpansionReport.mAttachmentPluggedIn = (data[0] & 0x02) != 0;
+	mLastExpansionReport.mIREnabled = (data[0] & 0x08) != 0;
+	mLastExpansionReport.mSpeakerEnabled = (data[0] & 0x04) != 0;
+	mLastExpansionReport.mLED1On = (data[0] & 0x10) != 0;
+	mLastExpansionReport.mLED2On = (data[0] & 0x20) != 0;
+	mLastExpansionReport.mLED3On = (data[0] & 0x40) != 0;
+	mLastExpansionReport.mLED4On = (data[0] & 0x80) != 0;
+	
+	//two unknown bytes
+	mLastExpansionReport.mBatteryLevel = data[3];
+}
+
+void cWiiMote::ParseButtonReport(const unsigned char * data)
+{
+	//two bytes long
+	mLastButtonStatus.mA = (data[1] & 0x08) != 0;
+ 	mLastButtonStatus.mB = (data[1] & 0x04) != 0;
+ 	mLastButtonStatus.m1 = (data[1] & 0x02) != 0;
+ 	mLastButtonStatus.m2 = (data[1] & 0x01) != 0;
+ 	mLastButtonStatus.mPlus = (data[0] & 0x10) != 0;
+ 	mLastButtonStatus.mMinus = (data[1] & 0x10) != 0;
+ 	mLastButtonStatus.mHome = (data[1] & 0x80) != 0;
+ 	mLastButtonStatus.mUp = (data[0] & 0x08) != 0;
+ 	mLastButtonStatus.mDown = (data[0] & 0x04) != 0;
+ 	mLastButtonStatus.mLeft = (data[0] & 0x01) != 0;
+ 	mLastButtonStatus.mRight = (data[0] & 0x02) != 0;
+}
+
+void cWiiMote::ParseMotionReport(const unsigned char * data)
+{
+	//three bytes long
+	mLastMotionReport.mX = data[0];
+	mLastMotionReport.mY = data[1];
+	mLastMotionReport.mZ = data[2];
+}
+
+void cWiiMote::PrintStatus() const
+{
+	float wX,wY,wZ;
+	float cX,cY,cZ;
+	float sX,sY;
+	float irX,irY;
+	
+	wX =wY=wZ=cX=cY=cZ=sX=sY=irX=irY=0.f;
+
+	GetCalibratedAcceleration(wX,wY,wZ);
+	printf("W:[%+1.2f %+1.2f %+1.2f] ",wX,wY,wZ);
+
+	if (mNunchuckAttached)
+	{
+		GetCalibratedChuckAcceleration(cX,cY,cZ);
+		printf("N:[%+1.2f %+1.2f %+1.2f] ",cX,cY,cZ);
+
+		GetCalibratedChuckStick(sX,sY);
+		printf("S:[%+1.2f %+1.2f] ",sX,sY);
+	}
+
+	if (mIRRunning)
+	{
+		if (GetIRP1(irX,irY))
+		{
+			printf("P1:[%+1.2f %+1.2f]",irX,irY);
+		}
+		if (GetIRP2(irX,irY))
+		{
+			printf("P2:[%+1.2f %+1.2f]",irX,irY);
+		}
+	}
+
+
+	//print the button status
+	if (mLastButtonStatus.m1)
+		printf("1");
+	if (mLastButtonStatus.m2)
+		printf("2");
+	if (mLastButtonStatus.mA)
+		printf("A");
+	if (mLastButtonStatus.mB)
+		printf("B");
+	if (mLastButtonStatus.mPlus)
+		printf("+");
+	if (mLastButtonStatus.mMinus)
+		printf("-");
+	if (mLastButtonStatus.mUp)
+		printf("U");
+	if (mLastButtonStatus.mDown)
+		printf("D");
+	if (mLastButtonStatus.mLeft)
+		printf("L");
+	if (mLastButtonStatus.mRight)
+		printf("R");
+	if (mLastButtonStatus.mHome)
+		printf("H");
+
+	if (mNunchuckAttached)
+	{
+		if (mLastChuckReport.mButtonZ)
+			printf("Z");
+		if (mLastChuckReport.mButtonC)
+			printf("C");
+	}
+
+	printf("\n");
+
+}
+
+
+bool cWiiMote::SelectInputChannel(bool continuous, unsigned char channel)
+{
+	ClearBuffer();
+	mOutputBuffer[0] = OUTPUT_CHANNEL_REPORT;
+	mOutputBuffer[1] = (continuous ? REQUEST_CONTINUOUS_REPORTS : REQUEST_SINGLE_REPORTS) | (mOutputControls.mVibration ? 0x1 : 0x0);
+	mOutputBuffer[2] = channel;
+	return mHIDDevice.WriteToDevice(mOutputBuffer,mOutputBufferSize);
+}
+
+
+//this may or may not work to read buffers greater than 16 bytes. . . .
+bool cWiiMote::IssueReadRequest(unsigned int address, unsigned short size, unsigned char * buffer)
+{
+	bool retval = false;
+	if (mReadInfo.mReadStatus != tMemReadInfo::READ_PENDING)
+	{
+		ClearBuffer();
+		mOutputBuffer[0] = OUTPUT_READ_MEMORY;
+		mOutputBuffer[1] = (((address & 0xff000000) >> 24) & 0xFE) | (mOutputControls.mVibration ? 0x1 : 0x0);
+		mOutputBuffer[2] = (address & 0x00ff0000) >> 16;
+		mOutputBuffer[3] = (address & 0x0000ff00) >> 8;
+		mOutputBuffer[4] = (address & 0xff);
+		
+		mOutputBuffer[5] = (size & 0xff00) >> 8;
+		mOutputBuffer[6] = (size & 0xff);
+		
+		if (mHIDDevice.WriteToDevice(mOutputBuffer,mOutputBufferSize))
+		{
+			mReadInfo.mReadStatus = tMemReadInfo::READ_PENDING;
+			mReadInfo.mReadBuffer = buffer;
+			mReadInfo.mTotalBytesToRead = size;
+			mReadInfo.mBytesRead =0;
+			mReadInfo.mBaseAddress = (unsigned short)(address & 0xFFFF);
+			retval = true;
+		}
+	}
+
+	return retval;
+}
+
+void cWiiMote::ParseReadData(const unsigned char * data)
+{
+	if(mReadInfo.mReadStatus == tMemReadInfo::READ_PENDING)
+	{
+		const bool error = (data[0] & 0x0F) != 0;
+		if (error)
+		{
+			mReadInfo.mReadStatus = tMemReadInfo::READ_ERROR;
+		}
+		else
+		{
+			unsigned char bytes = (data[0] >> 4)+1;
+			unsigned short offset = ((unsigned short)data[1] << 8) + data[2];
+			unsigned int space_left_in_buffer = mReadInfo.mTotalBytesToRead -  mReadInfo.mBytesRead;
+			if (offset == mReadInfo.mBytesRead + mReadInfo.mBaseAddress &&
+				space_left_in_buffer >= bytes)
+			{
+				memcpy(&mReadInfo.mReadBuffer[mReadInfo.mBytesRead],&data[3],bytes);
+				
+				mReadInfo.mBytesRead+= bytes;
+				if (mReadInfo.mBytesRead >= mReadInfo.mTotalBytesToRead)
+				{
+					mReadInfo.mReadStatus = tMemReadInfo::READ_COMPLETE;
+				}
+			}
+		}
+	}
+
+}
+
+bool cWiiMote::ReadData(unsigned int address, unsigned short size, unsigned char * buffer)
+{
+	if (IssueReadRequest(address, size,buffer))
+	{
+		while (mReadInfo.mReadStatus == tMemReadInfo::READ_PENDING)
+		{
+			if (!HeartBeat(1000))
+			{
+				break;
+			}
+		}
+	}
+	return mReadInfo.mReadStatus == tMemReadInfo::READ_COMPLETE;
+}
+
+bool cWiiMote::ReadCalibrationData()
+{
+	bool retval = false;
+	unsigned char buffer[CALIBRATION_DATA_LENGTH];
+	if (ReadData(CALIBRATION_ADDRESS, CALIBRATION_DATA_LENGTH,buffer))
+	{
+		mAccelCalibrationData.mXZero = buffer[0];
+		mAccelCalibrationData.mYZero = buffer[1];
+		mAccelCalibrationData.mZZero = buffer[2];
+		mAccelCalibrationData.mXG = buffer[4];
+		mAccelCalibrationData.mYG = buffer[5];
+		mAccelCalibrationData.mZG = buffer[6];
+		retval = true;
+	}
+	
+	return retval;
+}
+
+void cWiiMote::GetCalibratedAcceleration(float & x, float & y, float &z) const
+{
+ 	x = (mLastMotionReport.mX - mAccelCalibrationData.mXZero) / (float)(mAccelCalibrationData.mXG- mAccelCalibrationData.mXZero);
+	y = (mLastMotionReport.mY - mAccelCalibrationData.mYZero) / (float)(mAccelCalibrationData.mYG- mAccelCalibrationData.mYZero);
+	z = (mLastMotionReport.mZ - mAccelCalibrationData.mZZero) / (float)(mAccelCalibrationData.mZG- mAccelCalibrationData.mZZero);
+}
+
+void cWiiMote::GetCalibratedChuckAcceleration(float & x, float & y, float &z) const
+{
+	if (!mNunchuckAttached)
+	{
+		x = y = z = 0.f;
+		return;
+	}
+
+	x = (mLastChuckReport.mAccelX - mNunchuckAccelCalibrationData.mXZero) / (float)(mNunchuckAccelCalibrationData.mXG- mNunchuckAccelCalibrationData.mXZero);
+	y = (mLastChuckReport.mAccelY - mNunchuckAccelCalibrationData.mYZero) / (float)(mNunchuckAccelCalibrationData.mYG- mNunchuckAccelCalibrationData.mYZero);
+	z = (mLastChuckReport.mAccelZ - mNunchuckAccelCalibrationData.mZZero) / (float)(mNunchuckAccelCalibrationData.mZG- mNunchuckAccelCalibrationData.mZZero);
+}
+void cWiiMote::GetCalibratedChuckStick(float & x, float & y) const
+{
+	if (!mNunchuckAttached)
+	{
+		x = y = 0.f;
+		return;
+	}
+
+	if (mLastChuckReport.mStickX < mNunchuckStickCalibrationData.mXmid)
+	{
+		x = ((mLastChuckReport.mStickX - mNunchuckStickCalibrationData.mXmin) / (float)(mNunchuckStickCalibrationData.mXmid - mNunchuckStickCalibrationData.mXmin)) -  1.f;
+	}
+	else
+	{
+		x = ((mLastChuckReport.mStickX - mNunchuckStickCalibrationData.mXmid) / (float)(mNunchuckStickCalibrationData.mXmax - mNunchuckStickCalibrationData.mXmid));
+	}
+
+	if (mLastChuckReport.mStickY < mNunchuckStickCalibrationData.mYmid)
+	{
+		y = ((mLastChuckReport.mStickY - mNunchuckStickCalibrationData.mYmin) / (float)(mNunchuckStickCalibrationData.mYmid - mNunchuckStickCalibrationData.mYmin)) -  1.f;
+	}
+	else
+	{
+		y = ((mLastChuckReport.mStickY - mNunchuckStickCalibrationData.mYmid) / (float)(mNunchuckStickCalibrationData.mYmax - mNunchuckStickCalibrationData.mYmid));
+	}
+}
+
+
+bool cWiiMote::WriteMemory(unsigned int address, unsigned char size, const unsigned char * buffer)
+{
+	bool retval = false;
+	if (size <= 16)
+	{
+		ClearBuffer();
+		mOutputBuffer[0] = OUTPUT_WRITE_MEMORY;
+		mOutputBuffer[1] = (address & 0xff000000) >> 24 | (mOutputControls.mVibration ? 0x1 : 0x0);
+		mOutputBuffer[2] = (address & 0x00ff0000) >> 16;
+		mOutputBuffer[3] = (address & 0x0000ff00) >> 8;
+		mOutputBuffer[4] = (address & 0xff);
+		mOutputBuffer[5] = size;
+		memcpy(&mOutputBuffer[6],buffer,size);
+		retval = mHIDDevice.WriteToDevice(mOutputBuffer,mOutputBufferSize);
+	}
+
+	return retval;
+}
+
+bool cWiiMote::InitNunchuck()
+{
+
+	bool retval = false;
+	
+	//first init the nunchuck, if it is present
+	if (WriteMemory(NUNCHUCK_INIT_ADDRESS,1,&NUNCHUCK_INIT_VAL))
+	{
+	
+		unsigned char buffer[16];
+		//now try to read the nunchuck's calibration data
+		if (ReadData(NUNCHUCK_CALIBRATION_ADDRESS,16,buffer))
+		{
+			
+			//note that this hasn't worked properly for me yet (I get all 0xff). 
+			/*mNunchuckAccelCalibrationData.mXZero = NunChuckByte(buffer[0]);
+			mNunchuckAccelCalibrationData.mYZero = NunChuckByte(buffer[1]);
+			mNunchuckAccelCalibrationData.mZZero = NunChuckByte(buffer[2]);
+
+			mNunchuckAccelCalibrationData.mXG = NunChuckByte(buffer[4]);
+			mNunchuckAccelCalibrationData.mYG = NunChuckByte(buffer[5]);
+			mNunchuckAccelCalibrationData.mZG = NunChuckByte(buffer[6]);
+
+			mNunchuckStickCalibrationData.mXmax = NunChuckByte(buffer[8]);
+			mNunchuckStickCalibrationData.mXmin = NunChuckByte(buffer[9]);
+			mNunchuckStickCalibrationData.mXmid = NunChuckByte(buffer[10]);
+			mNunchuckStickCalibrationData.mYmax = NunChuckByte(buffer[11]);
+			mNunchuckStickCalibrationData.mYmin = NunChuckByte(buffer[12]);
+			mNunchuckStickCalibrationData.mYmid = NunChuckByte(buffer[13]);*/
+
+			//these are default values from the wiili wiki
+			mNunchuckAccelCalibrationData.mXZero = 0x7E;
+			mNunchuckAccelCalibrationData.mYZero = 0x7A;
+			mNunchuckAccelCalibrationData.mZZero = 0x7D;
+			mNunchuckAccelCalibrationData.mXG = 0xB0;
+			mNunchuckAccelCalibrationData.mYG = 0xAF;
+			mNunchuckAccelCalibrationData.mZG = 0xB1;
+			mNunchuckStickCalibrationData.mXmax = 0xe5;
+			mNunchuckStickCalibrationData.mXmin = 0x21;
+			mNunchuckStickCalibrationData.mXmid =  0x7c;
+			mNunchuckStickCalibrationData.mYmax = 0xe7;
+			mNunchuckStickCalibrationData.mYmin =  0x23;
+			mNunchuckStickCalibrationData.mYmid = 0x7a;
+			retval = true;
+
+		}
+	}
+	mNunchuckAttached = retval;
+	return retval;
+}
+
+void cWiiMote::ParseChuckReport(const unsigned char * data)
+{
+	mLastChuckReport.mStickX = NunChuckByte(data[0]);
+	mLastChuckReport.mStickY = NunChuckByte(data[1]);
+	mLastChuckReport.mAccelX = NunChuckByte(data[2]);
+	mLastChuckReport.mAccelY = NunChuckByte(data[3]);
+	mLastChuckReport.mAccelZ = NunChuckByte(data[4]);
+	mLastChuckReport.mButtonC = (NunChuckByte(data[5]) & 0x2) == 0;
+	mLastChuckReport.mButtonZ = (NunChuckByte(data[5]) & 0x1) == 0;
+}
+
+bool cWiiMote::EnableIR()
+{
+	bool retval = false;
+	
+	DisableIR();
+
+	if (!mIRRunning)
+	{
+		ClearBuffer();
+		mOutputBuffer[0] = OUTPUT_ENABLE_IR;
+		mOutputBuffer[1] = 0x4 | (mOutputControls.mVibration ? 0x1 : 0x0);
+		retval = mHIDDevice.WriteToDevice(mOutputBuffer,mOutputBufferSize);
+		
+		if (retval)
+		{
+			mOutputBuffer[0] = OUTPUT_ENABLE_IR2;
+			mOutputBuffer[1] = 0x4 | (mOutputControls.mVibration ? 0x1 : 0x0);
+			retval = mHIDDevice.WriteToDevice(mOutputBuffer,mOutputBufferSize);
+		}
+
+		if (retval)
+		{
+			unsigned char val = 0x1;
+			retval = WriteMemory(IR_REG_1,1,&val);
+		}
+		
+		if (retval)
+		{
+			retval = WriteMemory(IR_SENS_ADDR_1,9,IR_SENS_MIDRANGE_PART1);
+		}
+
+		if (retval)
+		{
+			retval = WriteMemory(IR_SENS_ADDR_2,2,IR_SENS_MIDRANGE_PART2);
+		}
+
+
+		if (retval)
+		{
+			retval = WriteMemory(IR_REG_2,1,&IR_MODE_EXP);
+		}
+		
+		if (retval)
+		{
+			unsigned char val = 0x8;
+			retval = WriteMemory(IR_REG_1,1,&val);
+		}
+
+
+		mIRRunning = retval;
+	}
+	return retval;
+
+}
+
+bool cWiiMote::DisableIR()
+{
+	bool retval = false;
+
+	if (mIRRunning)
+	{
+		ClearBuffer();
+		mOutputBuffer[0] = OUTPUT_ENABLE_IR;
+		mOutputBuffer[1] = (mOutputControls.mVibration ? 0x1 : 0x0);
+		retval = mHIDDevice.WriteToDevice(mOutputBuffer,mOutputBufferSize);
+		
+		if (retval)
+		{
+			mOutputBuffer[0] = OUTPUT_ENABLE_IR2;
+			mOutputBuffer[1] = (mOutputControls.mVibration ? 0x1 : 0x0);
+			retval = mHIDDevice.WriteToDevice(mOutputBuffer,mOutputBufferSize);
+		}
+
+		mIRRunning = false;
+	}
+	return retval;
+
+}
+
+void cWiiMote::ParseIRReport(const unsigned char * data)
+{
+	mLastIRReport.mP1X = data[0] << 2 | (data[2] & 0x30) >>4;
+	mLastIRReport.mP1Y = data[1] << 2 | (data[2] & 0xc0) >>6;
+	mLastIRReport.mP1Size = data[2] & 0xf;
+
+	mLastIRReport.mP2X = data[3] << 2 | (data[5] & 0x30) >>4;
+	mLastIRReport.mP2Y = data[4] << 2 | (data[5] & 0xc0) >>6;
+	mLastIRReport.mP2Size = data[5] & 0xf;
+
+	mLastIRReport.mP1Found =  !(data[0] == 0xff && data[1] == 0xff && data[2] == 0xff);
+	mLastIRReport.mP2Found =  !(data[3] == 0xff && data[4] == 0xff && data[5] == 0xff);
+}
+
+bool cWiiMote::GetIRP1(float &x, float &y) const
+{
+	bool retval = false;
+	if (mIRRunning && mLastIRReport.mP1Found)
+	{
+		x = mLastIRReport.mP1X / 1024.f;
+		y = mLastIRReport.mP1Y / 1024.f;
+		retval = true;
+	}
+	return retval;
+}
+
+
+bool cWiiMote::GetIRP2(float &x, float &y) const
+{
+	bool retval = false;
+	if (mIRRunning && mLastIRReport.mP2Found)
+	{
+		x = mLastIRReport.mP2X / 1024.f;
+		y = mLastIRReport.mP2Y / 1024.f;
+		retval = true;
+	}
+	return retval;
+
+}
+
+bool cWiiMote::StartDataStream()
+{
+	bool retval = false;
+	
+	StopDataStream();
+
+	if (mNunchuckAttached)
+	{
+		retval =SetReportMode(REPORT_MODE_MOTION_CHUCK_IR);
+	}
+	else
+	{
+		retval = SetReportMode(REPORT_MODE_MOTION_IR);
+	}
+	EnableIR();
+
+	mDataStreamRunning = retval;
+	return retval;
+}
+
+
+bool cWiiMote::StopDataStream()
+{
+	if (mDataStreamRunning)
+	{
+		mDataStreamRunning = false;
+		DisableIR();
+		SetReportMode(REPORT_MODE_EVENT_BUTTONS);
+	}
+	return true;;
+}
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/wiimote.h b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/wiimote.h
new file mode 100644
index 0000000..c9c796d
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/ois-v1-4svn/src/win32/extras/WiiMote/wiimote.h
@@ -0,0 +1,291 @@
+#include "OISConfig.h"
+#ifdef OIS_WIN32_WIIMOTE_SUPPORT
+//cWiimote 0.2 by Kevin Forbes (http://simulatedcomicproduct.com)
+//This code is public domain, and comes with no warranty. The user takes full responsibility for anything that happens as a result from using this code.
+
+#ifndef WIIMOTE_H
+#define WIIMOTE_H
+
+#include "hiddevice.h"
+
+
+
+class cWiiMote
+{
+public:
+	cWiiMote();
+	~cWiiMote();
+	
+	//connection management
+	bool ConnectToDevice(int index = 0);
+	bool Disconnect();	
+	bool IsConnected() const {return mHIDDevice.IsConnected();}
+	
+	
+	bool StartDataStream();
+	bool StopDataStream();
+
+	bool IsNunChuckAttached() { return mNunchuckAttached; }
+
+
+	//this is the wiimote message pump. It should probably be called in loop from a thread
+	bool HeartBeat(int timeout = 1);
+	bool SetVibration(bool vib_on);
+	bool SetLEDs(bool led1, bool led2, bool led3, bool led4);
+
+
+
+	//Querying functions and structures:
+	void GetCalibratedAcceleration(float & x, float & y, float &z) const;
+	void GetCalibratedChuckAcceleration(float & x, float & y, float &z) const;
+	void GetCalibratedChuckStick(float & x, float & y) const;
+	bool GetIRP1(float &x, float &y) const;
+	bool GetIRP2(float &x, float &y) const;
+
+
+	struct tExpansionReport
+	{
+		bool mAttachmentPluggedIn;
+		bool mIREnabled;
+		bool mSpeakerEnabled;
+		bool mLED1On;
+		bool mLED2On;
+		bool mLED3On;
+		bool mLED4On;
+		unsigned char mBatteryLevel;
+
+		void Init()
+		{
+			mAttachmentPluggedIn = false;
+			mIREnabled = false;
+			mSpeakerEnabled = false;
+			mLED1On = false;
+			mLED2On = false;
+			mLED3On = false;
+			mLED4On = false;
+			mBatteryLevel = 0;
+		}
+	};
+	struct tButtonStatus
+	{
+		bool mA;
+		bool mB;
+		bool m1;
+		bool m2;
+		bool mPlus;
+		bool mMinus;
+		bool mHome;
+		bool mUp;
+		bool mDown;
+		bool mLeft;
+		bool mRight;
+	
+		void Init()
+		{
+			mA = mB = m1 = m2 = mPlus = mMinus = mHome = mUp = mDown = mLeft = mRight = false;
+		}
+	};
+	struct tMotionReport
+	{
+		unsigned char mX;
+		unsigned char mY;
+		unsigned char mZ;
+		
+		void Init()
+		{
+			mX = mY = mZ = 0;
+		}
+	};
+
+	struct tChuckReport
+	{
+		unsigned char mStickX;
+		unsigned char mStickY;
+		unsigned char mAccelX;
+		unsigned char mAccelY;
+		unsigned char mAccelZ;
+		bool	mButtonC;
+		bool	mButtonZ;
+		void Init()
+		{
+			mStickX=mStickY=mAccelX=mAccelY=mAccelZ=0;
+			mButtonC = mButtonZ = false;
+		};
+	};
+
+	struct tIRReport
+	{
+		unsigned short mP1X;
+		unsigned short mP1Y;
+		
+		unsigned short mP2X;
+		unsigned short mP2Y;
+
+		unsigned char mP1Size;
+		unsigned char mP2Size;
+
+		bool mP1Found;
+		bool mP2Found;
+
+		void Init()
+		{
+			mP1X = mP1Y = mP2X = mP2Y = mP1Size = mP2Size = 0;
+			mP1Found = mP2Found = false;
+		}
+
+
+	};
+	const tButtonStatus & GetLastButtonStatus() const {return mLastButtonStatus;}
+	const tChuckReport & GetLastChuckReport() const {return mLastChuckReport;}
+	const tMotionReport & GetLastMotionReport() const { return mLastMotionReport;}
+	const tExpansionReport & GetLastExpansionReport() const { return mLastExpansionReport;}
+	const tIRReport & GetLastIRReport() const { return mLastIRReport;}
+	
+	
+	//debugging functions:
+	void PrintStatus() const;
+
+private:
+	
+	//parsing functions for input reports
+	void ParseExpansionReport(const unsigned char * data);
+	void ParseButtonReport(const unsigned char * data);
+	void ParseMotionReport(const unsigned char * data);
+	void ParseReadData(const unsigned char * data);
+	void ParseChuckReport(const unsigned char * data);
+	void ParseIRReport(const unsigned char * data);
+
+
+	//tell the wiimote how to send data
+	enum eReportMode
+	{
+		REPORT_MODE_EVENT_BUTTONS,
+		REPORT_MODE_MOTION, 
+		REPORT_MODE_MOTION_CHUCK,
+		REPORT_MODE_MOTION_IR,
+		REPORT_MODE_MOTION_CHUCK_IR
+	};
+	bool SetReportMode(eReportMode mode);
+
+
+	//housekeeping functions
+	void Init();
+	void ClearBuffer();
+
+	//low level tasks
+	bool SelectInputChannel(bool continuous, unsigned char channel);
+	bool UpdateOutput();
+	bool ReadMemory(unsigned int address, unsigned short size, unsigned char * buffer) const;	
+	bool WriteMemory(unsigned int address, unsigned char size, const unsigned char * buffer);
+
+	bool ReadData(unsigned int address, unsigned short size, unsigned char * buffer);
+	bool IssueReadRequest(unsigned int address, unsigned short size, unsigned char * buffer);
+	bool ReadCalibrationData();
+	bool SendReportMode();
+
+	bool InitNunchuck();
+	bool EnableIR();
+	bool DisableIR();
+
+	static inline unsigned char NunChuckByte(unsigned char in) {return (in ^ 0x17)+0x17;}
+	//flash reading vars
+	struct tMemReadInfo
+	{
+		enum eReadStatus
+		{
+			READ_PENDING,
+			READ_NONE,
+			READ_COMPLETE,
+			READ_ERROR
+		} mReadStatus;
+
+		unsigned char * mReadBuffer;
+		unsigned short mTotalBytesToRead;
+		unsigned short mBytesRead;
+		unsigned short mBaseAddress;
+		void Init()
+		{
+			mReadStatus = READ_NONE;
+			mReadBuffer = NULL;
+			mTotalBytesToRead = 0;
+			mBytesRead = 0;
+			mBaseAddress = 0;
+		}
+	} mReadInfo;
+
+	//calibration data for the wiimote
+	struct tAccelCalibrationData
+	{
+		unsigned char mXZero;
+		unsigned char mYZero;
+		unsigned char mZZero;
+		unsigned char mXG;
+		unsigned char mYG;
+		unsigned char mZG;
+		void Init()
+		{
+			mXZero = mYZero = mZZero = mXG = mYG = mZG= 0;
+		}
+	} ;
+
+	struct tStickCalibrationData
+	{
+		unsigned char mXmin;
+		unsigned char mXmid;
+		unsigned char mXmax;
+		unsigned char mYmin;
+		unsigned char mYmid;
+		unsigned char mYmax;
+
+		void Init()
+		{
+			mXmax = mYmax = mXmin = mYmin = mXmid = mYmid =0;
+		}
+	};
+	
+	tAccelCalibrationData mAccelCalibrationData;
+	tAccelCalibrationData mNunchuckAccelCalibrationData;
+	tStickCalibrationData mNunchuckStickCalibrationData;
+
+	//output requests
+	struct tOutputControls
+	{
+		bool mVibration;
+		bool mLED1;
+		bool mLED2;
+		bool mLED3;
+		bool mLED4;
+
+		void Init()
+		{
+			mVibration = mLED1 = mLED2= mLED3= mLED4 = false;
+		}
+	};
+	
+	
+	//input states
+	tExpansionReport mLastExpansionReport;
+	tButtonStatus mLastButtonStatus;
+	tMotionReport mLastMotionReport;
+	tChuckReport mLastChuckReport;
+	tIRReport mLastIRReport;
+
+	//output states
+	tOutputControls mOutputControls;
+	eReportMode	mReportMode;
+
+	//our communications device
+	cHIDDevice mHIDDevice;
+	
+	bool mNunchuckAttached;
+	bool mIRRunning;
+	bool mDataStreamRunning;
+
+	//buffers for input/output
+	static const int mOutputBufferSize = 22;
+	unsigned char mOutputBuffer[mOutputBufferSize];
+	static const int mInputBufferSize = 22;
+	unsigned char mInputBuffer[mInputBufferSize];
+};
+#endif
+#endif
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/libs/gdx-controllers-desktop-natives.jar b/extensions/gdx-controllers/gdx-controllers-desktop/libs/gdx-controllers-desktop-natives.jar
new file mode 100755
index 0000000..be5292f
Binary files /dev/null and b/extensions/gdx-controllers/gdx-controllers-desktop/libs/gdx-controllers-desktop-natives.jar differ
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/DesktopControllers.java b/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/DesktopControllers.java
new file mode 100644
index 0000000..5520948
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/DesktopControllers.java
@@ -0,0 +1,38 @@
+
+package com.badlogic.gdx.controllers;
+
+import com.badlogic.gdx.ApplicationAdapter;
+import com.badlogic.gdx.backends.lwjgl.LwjglFrame;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+
+import org.lwjgl.opengl.Display;
+
+public class DesktopControllers {
+	public static void main (String[] args) throws Exception {
+		//DesktopControllersBuild.main(null);
+		new LwjglFrame(new ApplicationAdapter() {
+			public void create () {
+				long hwnd = getWindowHandle();
+				System.out.println("hwnd: " + hwnd);
+				System.out.println("inputManager pointer: " + OisWrapper.initialize(hwnd));
+			}
+
+			long getWindowHandle () {
+				try {
+					Method getImplementation = Display.class.getDeclaredMethod("getImplementation", new Class[0]);
+					getImplementation.setAccessible(true);
+					Object display = getImplementation.invoke(null, (Object[])null);
+					String fieldName = System.getProperty("os.name").toLowerCase().contains("windows") ? "hwnd" : "parent_window";
+					Field field = display.getClass().getDeclaredField(fieldName);
+					field.setAccessible(true);
+					return (Long)field.get(display);
+				} catch (Exception ex) {
+					throw new GdxRuntimeException("Unable to get window handle.", ex);
+				}
+			}
+		}, "meow", 200, 200, true);
+	}
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/DesktopControllersBuild.java b/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/DesktopControllersBuild.java
new file mode 100755
index 0000000..e85e7a5
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/DesktopControllersBuild.java
@@ -0,0 +1,35 @@
+
+package com.badlogic.gdx.controllers;
+
+import com.badlogic.gdx.jnigen.AntScriptGenerator;
+import com.badlogic.gdx.jnigen.BuildConfig;
+import com.badlogic.gdx.jnigen.BuildExecutor;
+import com.badlogic.gdx.jnigen.BuildTarget;
+import com.badlogic.gdx.jnigen.NativeCodeGenerator;
+import com.badlogic.gdx.jnigen.BuildTarget.TargetOs;
+
+public class DesktopControllersBuild {
+	public static void main (String[] args) throws Exception {
+		new NativeCodeGenerator().generate("src/", "bin/", "jni/");
+		BuildConfig buildConfig = new BuildConfig("gdx-controllers-desktop");
+		BuildTarget win32home = BuildTarget.newDefaultTarget(TargetOs.Windows, false);
+		win32home.buildFileName = "build-windows32home.xml";
+		win32home.is64Bit = false;
+		win32home.compilerPrefix = "";
+		win32home.cppIncludes = new String[] {
+			"*.cpp",
+			"ois-v1-4svn/src/*.cpp",
+			"ois-v1-4svn/src/win32/*.cpp"
+		};
+		win32home.headerDirs = new String[] {
+			"ois-v1-4svn/includes",
+			"dinput/"
+		};
+		win32home.cIncludes = new String[0];
+		win32home.libraries = "-ldinput8 -ldxguid";
+
+		new AntScriptGenerator().generate(buildConfig, win32home);
+		BuildExecutor.executeAnt("jni/build-windows32home.xml", "-Dhas-compiler=true clean postcompile -v");
+		BuildExecutor.executeAnt("jni/build.xml", "pack-natives");
+	}
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/OisWrapper.java b/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/OisWrapper.java
new file mode 100755
index 0000000..8bac3a8
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/OisWrapper.java
@@ -0,0 +1,89 @@
+
+package com.badlogic.gdx.controllers;
+
+import com.badlogic.gdx.utils.SharedLibraryLoader;
+
+/** JNI wrapper for the object-oriented input system
+ * @author mzechner
+ * @author Nathan Sweet */
+public class OisWrapper {
+	static {
+		new SharedLibraryLoader().load("gdx-controllers-desktop");
+	}
+
+	// @off
+	/*JNI
+	#include <OISJoyStick.h>
+	#include <OISInputManager.h>
+	#include <sstream>
+
+	class Listener : public OIS::JoyStickListener {
+	private:
+		bool povMoved (const OIS::JoyStickEvent &event, int pov);
+		bool axisMoved (const OIS::JoyStickEvent &event, int axis);
+		bool sliderMoved (const OIS::JoyStickEvent &event, int sliderID);
+		bool buttonPressed (const OIS::JoyStickEvent &event, int button);
+		bool buttonReleased (const OIS::JoyStickEvent &event, int button);
+	};
+
+	bool Listener::buttonPressed (const OIS::JoyStickEvent &event, int buttonId) {
+		printf("buttonPressed: %i\n", buttonId);
+		fflush(stdout);
+		return true;
+	}
+
+	bool Listener::buttonReleased (const OIS::JoyStickEvent &event, int buttonId) {
+		printf("buttonReleased: %i\n", buttonId);
+		fflush(stdout);
+		return true;
+	}
+
+	bool Listener::axisMoved (const OIS::JoyStickEvent &event, int axisId) {
+		printf("axisMoved: %i\n", axisId);
+		fflush(stdout);
+		return true;
+	}
+
+	bool Listener::povMoved (const OIS::JoyStickEvent &event, int povId) {
+		printf("povMoved: %i\n", povId);
+		fflush(stdout);
+		return true;
+	}
+
+	bool Listener::sliderMoved (const OIS::JoyStickEvent &event, int sliderId) {
+		printf("sliderMoved: %i\n", sliderId);
+		fflush(stdout);
+		return true;
+	}
+	*/
+
+	static public native long initialize (long hwnd); /*
+		std::ostringstream hwndStr;
+		hwndStr << hwnd;
+
+		OIS::ParamList params;
+		params.insert(std::make_pair("WINDOW", hwndStr.str()));
+		params.insert(std::make_pair("w32_joystick", "DISCL_BACKGROUND"));
+		params.insert(std::make_pair("w32_joystick", "DISCL_NONEXCLUSIVE"));
+
+		OIS::InputManager *inputManager = OIS::InputManager::createInputSystem(params);
+		printf("OIS version: %i\n", inputManager->getVersionNumber());
+		fflush(stdout);
+
+		//Listener *listener = new Listener();
+		int count = inputManager->getNumberOfDevices(OIS::OISJoyStick);
+		printf("joystick count: %i\n", count);
+		fflush(stdout);
+		for (int i = 0; i < count; i++) {
+			try {
+				inputManager->createInputObject(OIS::OISJoyStick, true);
+			} catch (std::exception &ex) {
+				printf("exception!\n%s\n", ex.what());
+				fflush(stdout);
+			}
+			//OIS::JoyStick* joystick = static_cast<OIS::JoyStick*>(inputManager->createInputObject(OIS::OISJoyStick, true));
+			//joystick->setEventCallback(listener);
+		}
+		return (jlong)inputManager;
+	*/
+}
diff --git a/extensions/gdx-controllers/gdx-controllers/.classpath b/extensions/gdx-controllers/gdx-controllers/.classpath
new file mode 100644
index 0000000..57502b6
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers/.classpath
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
+	<classpathentry excluding="**/.svn/*" kind="src" path="src"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/gdx"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/extensions/gdx-controllers/gdx-controllers/.project b/extensions/gdx-controllers/gdx-controllers/.project
new file mode 100644
index 0000000..3bfc9bc
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>gdx-controllers</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/extensions/gdx-controllers/gdx-controllers/.settings/org.eclipse.cdt.managedbuilder.core.prefs b/extensions/gdx-controllers/gdx-controllers/.settings/org.eclipse.cdt.managedbuilder.core.prefs
new file mode 100644
index 0000000..6988534
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers/.settings/org.eclipse.cdt.managedbuilder.core.prefs
@@ -0,0 +1,14 @@
+#Fri Apr 29 13:59:56 CEST 2011
+eclipse.preferences.version=1
+environment/buildEnvironmentInclude/cdt.managedbuild.config.gnu.mingw.so.debug.1412059085/CPATH/delimiter=;
+environment/buildEnvironmentInclude/cdt.managedbuild.config.gnu.mingw.so.debug.1412059085/CPATH/operation=remove
+environment/buildEnvironmentInclude/cdt.managedbuild.config.gnu.mingw.so.debug.1412059085/CPLUS_INCLUDE_PATH/delimiter=;
+environment/buildEnvironmentInclude/cdt.managedbuild.config.gnu.mingw.so.debug.1412059085/CPLUS_INCLUDE_PATH/operation=remove
+environment/buildEnvironmentInclude/cdt.managedbuild.config.gnu.mingw.so.debug.1412059085/C_INCLUDE_PATH/delimiter=;
+environment/buildEnvironmentInclude/cdt.managedbuild.config.gnu.mingw.so.debug.1412059085/C_INCLUDE_PATH/operation=remove
+environment/buildEnvironmentInclude/cdt.managedbuild.config.gnu.mingw.so.debug.1412059085/append=true
+environment/buildEnvironmentInclude/cdt.managedbuild.config.gnu.mingw.so.debug.1412059085/appendContributed=true
+environment/buildEnvironmentLibrary/cdt.managedbuild.config.gnu.mingw.so.debug.1412059085/LIBRARY_PATH/delimiter=;
+environment/buildEnvironmentLibrary/cdt.managedbuild.config.gnu.mingw.so.debug.1412059085/LIBRARY_PATH/operation=remove
+environment/buildEnvironmentLibrary/cdt.managedbuild.config.gnu.mingw.so.debug.1412059085/append=true
+environment/buildEnvironmentLibrary/cdt.managedbuild.config.gnu.mingw.so.debug.1412059085/appendContributed=true
diff --git a/extensions/gdx-controllers/gdx-controllers/.settings/org.eclipse.jdt.core.prefs b/extensions/gdx-controllers/gdx-controllers/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..cc51644
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,369 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.6
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.doc.comment.support=enabled
+org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.autoboxing=ignore
+org.eclipse.jdt.core.compiler.problem.comparingIdentical=warning
+org.eclipse.jdt.core.compiler.problem.deadCode=ignore
+org.eclipse.jdt.core.compiler.problem.deprecation=ignore
+org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
+org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
+org.eclipse.jdt.core.compiler.problem.discouragedReference=warning
+org.eclipse.jdt.core.compiler.problem.emptyStatement=ignore
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.fallthroughCase=ignore
+org.eclipse.jdt.core.compiler.problem.fatalOptionalError=disabled
+org.eclipse.jdt.core.compiler.problem.fieldHiding=ignore
+org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
+org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=warning
+org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
+org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
+org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=ignore
+org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=ignore
+org.eclipse.jdt.core.compiler.problem.invalidJavadoc=warning
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTags=enabled
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsDeprecatedRef=enabled
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsNotVisibleRef=enabled
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsVisibility=private
+org.eclipse.jdt.core.compiler.problem.localVariableHiding=ignore
+org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
+org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingHashCodeMethod=ignore
+org.eclipse.jdt.core.compiler.problem.missingJavadocComments=ignore
+org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsOverriding=enabled
+org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsVisibility=public
+org.eclipse.jdt.core.compiler.problem.missingJavadocTagDescription=return_tag
+org.eclipse.jdt.core.compiler.problem.missingJavadocTags=ignore
+org.eclipse.jdt.core.compiler.problem.missingJavadocTagsOverriding=enabled
+org.eclipse.jdt.core.compiler.problem.missingJavadocTagsVisibility=private
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotationForInterfaceMethodImplementation=enabled
+org.eclipse.jdt.core.compiler.problem.missingSerialVersion=ignore
+org.eclipse.jdt.core.compiler.problem.missingSynchronizedOnInheritedMethod=ignore
+org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
+org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
+org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=ignore
+org.eclipse.jdt.core.compiler.problem.nullReference=warning
+org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
+org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=warning
+org.eclipse.jdt.core.compiler.problem.potentialNullReference=ignore
+org.eclipse.jdt.core.compiler.problem.rawTypeReference=ignore
+org.eclipse.jdt.core.compiler.problem.redundantNullCheck=ignore
+org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=ignore
+org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
+org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=warning
+org.eclipse.jdt.core.compiler.problem.suppressOptionalErrors=disabled
+org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
+org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=warning
+org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
+org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=ignore
+org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=ignore
+org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.unnecessaryElse=ignore
+org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=ignore
+org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=enabled
+org.eclipse.jdt.core.compiler.problem.unusedImport=ignore
+org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
+org.eclipse.jdt.core.compiler.problem.unusedLocal=ignore
+org.eclipse.jdt.core.compiler.problem.unusedObjectAllocation=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameterIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=enabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=enabled
+org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=ignore
+org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
+org.eclipse.jdt.core.compiler.source=1.6
+org.eclipse.jdt.core.formatter.align_type_members_on_columns=false
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_annotation=0
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_qualified_allocation_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_assignment=0
+org.eclipse.jdt.core.formatter.alignment_for_binary_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_compact_if=16
+org.eclipse.jdt.core.formatter.alignment_for_conditional_expression=80
+org.eclipse.jdt.core.formatter.alignment_for_enum_constants=0
+org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer=16
+org.eclipse.jdt.core.formatter.alignment_for_method_declaration=0
+org.eclipse.jdt.core.formatter.alignment_for_multiple_fields=16
+org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_resources_in_try=80
+org.eclipse.jdt.core.formatter.alignment_for_selector_in_method_invocation=16
+org.eclipse.jdt.core.formatter.alignment_for_superclass_in_type_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_enum_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_type_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_union_type_in_multicatch=16
+org.eclipse.jdt.core.formatter.blank_lines_after_imports=1
+org.eclipse.jdt.core.formatter.blank_lines_after_package=1
+org.eclipse.jdt.core.formatter.blank_lines_before_field=0
+org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration=0
+org.eclipse.jdt.core.formatter.blank_lines_before_imports=1
+org.eclipse.jdt.core.formatter.blank_lines_before_member_type=1
+org.eclipse.jdt.core.formatter.blank_lines_before_method=1
+org.eclipse.jdt.core.formatter.blank_lines_before_new_chunk=1
+org.eclipse.jdt.core.formatter.blank_lines_before_package=1
+org.eclipse.jdt.core.formatter.blank_lines_between_import_groups=1
+org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations=1
+org.eclipse.jdt.core.formatter.brace_position_for_annotation_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_anonymous_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_array_initializer=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_block=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_block_in_case=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_enum_constant=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_method_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_switch=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment=false
+org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment=false
+org.eclipse.jdt.core.formatter.comment.format_block_comments=true
+org.eclipse.jdt.core.formatter.comment.format_header=false
+org.eclipse.jdt.core.formatter.comment.format_html=true
+org.eclipse.jdt.core.formatter.comment.format_javadoc_comments=true
+org.eclipse.jdt.core.formatter.comment.format_line_comments=true
+org.eclipse.jdt.core.formatter.comment.format_source_code=true
+org.eclipse.jdt.core.formatter.comment.indent_parameter_description=true
+org.eclipse.jdt.core.formatter.comment.indent_root_tags=true
+org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags=do not insert
+org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter=do not insert
+org.eclipse.jdt.core.formatter.comment.line_length=130
+org.eclipse.jdt.core.formatter.comment.new_lines_at_block_boundaries=true
+org.eclipse.jdt.core.formatter.comment.new_lines_at_javadoc_boundaries=false
+org.eclipse.jdt.core.formatter.comment.preserve_white_space_between_code_and_line_comments=false
+org.eclipse.jdt.core.formatter.compact_else_if=true
+org.eclipse.jdt.core.formatter.continuation_indentation=1
+org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer=1
+org.eclipse.jdt.core.formatter.disabling_tag=@off
+org.eclipse.jdt.core.formatter.enabling_tag=@on
+org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line=false
+org.eclipse.jdt.core.formatter.format_line_comment_starting_on_first_column=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header=true
+org.eclipse.jdt.core.formatter.indent_breaks_compare_to_cases=true
+org.eclipse.jdt.core.formatter.indent_empty_lines=false
+org.eclipse.jdt.core.formatter.indent_statements_compare_to_block=true
+org.eclipse.jdt.core.formatter.indent_statements_compare_to_body=true
+org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases=true
+org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch=false
+org.eclipse.jdt.core.formatter.indentation.size=4
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_field=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_method=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_package=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_type=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_label=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing=insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_annotation_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_anonymous_type_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_block=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_constant=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_method_body=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_after_and_in_type_parameter=insert
+org.eclipse.jdt.core.formatter.insert_space_after_assignment_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation_type_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_binary_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_assert=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_case=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_labeled_statement=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_constant_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_explicitconstructorcall_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_inits=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_throws=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_field_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_local_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_parameterized_type_reference=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_ellipsis=insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_cast=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_catch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_if=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_switch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_try=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_while=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_prefix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_after_question_in_wildcard=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_try_resources=insert
+org.eclipse.jdt.core.formatter.insert_space_after_unary_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_and_in_type_parameter=insert
+org.eclipse.jdt.core.formatter.insert_space_before_assignment_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_before_at_in_annotation_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_binary_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_cast=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_catch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_if=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_switch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_synchronized=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_try=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_while=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_assert=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_throws=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_constant_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_explicitconstructorcall_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_increments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_inits=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_local_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_ellipsis=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_annotation_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_anonymous_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_constructor_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_constant=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation_type_member_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_constructor_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_try=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while=insert
+org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_return=insert
+org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_throw=insert
+org.eclipse.jdt.core.formatter.insert_space_before_postfix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_prefix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_before_question_in_wildcard=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_semicolon=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_try_resources=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_unary_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_brackets_in_array_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_braces_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_brackets_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.join_lines_in_comments=true
+org.eclipse.jdt.core.formatter.join_wrapped_lines=true
+org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line=false
+org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line=false
+org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line=true
+org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line=false
+org.eclipse.jdt.core.formatter.lineSplit=130
+org.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column=true
+org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column=true
+org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body=0
+org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve=1
+org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line=true
+org.eclipse.jdt.core.formatter.tabulation.char=tab
+org.eclipse.jdt.core.formatter.tabulation.size=3
+org.eclipse.jdt.core.formatter.use_on_off_tags=true
+org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations=false
+org.eclipse.jdt.core.formatter.wrap_before_binary_operator=true
+org.eclipse.jdt.core.formatter.wrap_before_or_operator_multicatch=true
+org.eclipse.jdt.core.formatter.wrap_outer_expressions_when_nested=true
diff --git a/extensions/gdx-controllers/gdx-controllers/.settings/org.eclipse.jdt.ui.prefs b/extensions/gdx-controllers/gdx-controllers/.settings/org.eclipse.jdt.ui.prefs
new file mode 100644
index 0000000..12ca759
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers/.settings/org.eclipse.jdt.ui.prefs
@@ -0,0 +1,3 @@
+eclipse.preferences.version=1
+formatter_profile=_libgdx
+formatter_settings_version=12
diff --git a/extensions/gdx-controllers/gdx-controllers/src/com/badlogic/gdx/controllers/ComponentType.java b/extensions/gdx-controllers/gdx-controllers/src/com/badlogic/gdx/controllers/ComponentType.java
new file mode 100644
index 0000000..49c5db0
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers/src/com/badlogic/gdx/controllers/ComponentType.java
@@ -0,0 +1,6 @@
+
+package com.badlogic.gdx.controllers;
+
+public enum ComponentType {
+	button, axis, slider, pov, accelerometer
+}
diff --git a/extensions/gdx-controllers/gdx-controllers/src/com/badlogic/gdx/controllers/Controller.java b/extensions/gdx-controllers/gdx-controllers/src/com/badlogic/gdx/controllers/Controller.java
new file mode 100644
index 0000000..b2ccbd8
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers/src/com/badlogic/gdx/controllers/Controller.java
@@ -0,0 +1,28 @@
+
+package com.badlogic.gdx.controllers;
+
+import com.badlogic.gdx.math.Vector3;
+
+public interface Controller {
+	public boolean getButton (int buttonIndex);
+
+	public float getAxis (int axisIndex);
+
+	public PovDirection getPov (int povIndex);
+
+	public boolean getSliderX (int sliderIndex);
+
+	public boolean getSliderY (int sliderIndex);
+
+	public Vector3 getAccelerometer (int accelerometerIndex);
+
+	public void setAccelerometerSensitivity (float sensitivity);
+
+	public int getComponentCount (ComponentType type);
+
+	public String getName ();
+
+	public void addListener (ControllerListener listener);
+
+	public void removeListener (ControllerListener listener);
+}
diff --git a/extensions/gdx-controllers/gdx-controllers/src/com/badlogic/gdx/controllers/ControllerListener.java b/extensions/gdx-controllers/gdx-controllers/src/com/badlogic/gdx/controllers/ControllerListener.java
new file mode 100644
index 0000000..c99b74e
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers/src/com/badlogic/gdx/controllers/ControllerListener.java
@@ -0,0 +1,16 @@
+
+package com.badlogic.gdx.controllers;
+
+public interface ControllerListener {
+	public boolean buttonDown (Controller controller, int buttonIndex);
+
+	public boolean buttonUp (Controller controller, int buttonIndex);
+
+	public boolean axisMoved (Controller controller, int axisIndex);
+
+	public boolean povMoved (Controller controller, int povId, PovDirection direction);
+
+	public boolean sliderMoved (Controller controller, int sliderIndex);
+
+	public boolean accelerometerMoved (Controller controller, int accelerometerIndex);
+}
diff --git a/extensions/gdx-controllers/gdx-controllers/src/com/badlogic/gdx/controllers/Controllers.java b/extensions/gdx-controllers/gdx-controllers/src/com/badlogic/gdx/controllers/Controllers.java
new file mode 100644
index 0000000..f79cb8e
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers/src/com/badlogic/gdx/controllers/Controllers.java
@@ -0,0 +1,12 @@
+
+package com.badlogic.gdx.controllers;
+
+import com.badlogic.gdx.utils.Array;
+
+public interface Controllers {
+	public Array<Controller> getControllers ();
+
+	public void addListener (ControllerListener listener);
+
+	public void removeListener (ControllerListener listener);
+}
diff --git a/extensions/gdx-controllers/gdx-controllers/src/com/badlogic/gdx/controllers/PovDirection.java b/extensions/gdx-controllers/gdx-controllers/src/com/badlogic/gdx/controllers/PovDirection.java
new file mode 100644
index 0000000..45e604f
--- /dev/null
+++ b/extensions/gdx-controllers/gdx-controllers/src/com/badlogic/gdx/controllers/PovDirection.java
@@ -0,0 +1,6 @@
+
+package com.badlogic.gdx.controllers;
+
+public enum PovDirection {
+	center, north, south, east, west, northEast, southEast, northWest, southWest
+}
diff --git a/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGenerator.java b/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGenerator.java
index 1172270..d37328a 100644
--- a/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGenerator.java
+++ b/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGenerator.java
@@ -86,6 +86,69 @@ public class FreeTypeFontGenerator implements Disposable {
 	public BitmapFont generateFont (int size) {
 		return generateFont(size, DEFAULT_CHARS, false);
 	}
+	
+	/** Uses ascender and descender of font to calculate real height that makes
+	 *  all glyphs to fit in given pixel size. Source:
+	 *  http://nothings.org/stb/stb_truetype.h / stbtt_ScaleForPixelHeight
+	 */
+	public int scaleForPixelHeight(int size) {
+		if (!FreeType.setPixelSizes(face, 0, size)) throw new GdxRuntimeException("Couldn't set size for font");
+		SizeMetrics fontMetrics = face.getSize().getMetrics();
+		int ascent = FreeType.toInt(fontMetrics.getAscender());
+		int descent = FreeType.toInt(fontMetrics.getDescender());
+		return size * size / (ascent - descent);
+	}
+	
+	public class GlyphAndBitmap {
+		public Glyph glyph;
+		public Bitmap bitmap;
+	}
+	
+	/** Returns null if glyph was not found. If there is nothing to render,
+	 * for example with various space characters, then bitmap is null.
+	 * */
+	public GlyphAndBitmap generateGlyphAndBitmap(int c, int size, boolean flip) {
+		if (!FreeType.setPixelSizes(face, 0, size)) throw new GdxRuntimeException("Couldn't set size for font");
+
+		SizeMetrics fontMetrics = face.getSize().getMetrics();
+		int baseline = FreeType.toInt(fontMetrics.getAscender());
+
+		// Check if character exists in this font
+		if (!FreeType.loadChar(face, c, FreeType.FT_LOAD_DEFAULT)) {
+			return null;
+		}
+
+		GlyphSlot slot = face.getGlyph();
+		
+		// Try to render to bitmap
+		Bitmap bitmap;
+		if (!FreeType.renderGlyph(slot, FreeType.FT_RENDER_MODE_LIGHT)) {
+			bitmap = null;
+		} else {
+			bitmap = slot.getBitmap();
+		}
+
+		GlyphMetrics metrics = slot.getMetrics();
+
+		Glyph glyph = new Glyph();
+		if (bitmap != null) {
+			glyph.width = bitmap.getWidth();
+			glyph.height = bitmap.getRows();
+		} else {
+			glyph.width = 0;
+			glyph.height = 0;
+		}
+		glyph.xoffset = slot.getBitmapLeft();
+		glyph.yoffset = flip ? -slot.getBitmapTop() + baseline : -(glyph.height - slot.getBitmapTop()) - baseline;
+		glyph.xadvance = FreeType.toInt(metrics.getHoriAdvance());
+		glyph.srcX = 0;
+		glyph.srcY = 0;
+
+		GlyphAndBitmap result = new GlyphAndBitmap();
+		result.glyph = glyph;
+		result.bitmap = bitmap;
+		return result;
+	}
 
 	/** Generates a new {@link BitmapFontData} instance, expert usage only. Throws a GdxRuntimeException in case something went
 	 * wrong.
diff --git a/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/AntScriptGenerator.java b/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/AntScriptGenerator.java
index dbb1dd8..37eb790 100644
--- a/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/AntScriptGenerator.java
+++ b/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/AntScriptGenerator.java
@@ -227,6 +227,7 @@ public class AntScriptGenerator {
 		template = template.replace("%cFlags%", target.cFlags);
 		template = template.replace("%cppFlags%", target.cppFlags);
 		template = template.replace("%linkerFlags%", target.linkerFlags);
+		template = template.replace("%libraries%", target.libraries);
 		template = template.replace("%cIncludes%", cIncludes);
 		template = template.replace("%cExcludes%", cExcludes);
 		template = template.replace("%cppIncludes%", cppIncludes);
diff --git a/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/BuildExecutor.java b/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/BuildExecutor.java
index 9fe3289..c0b21f1 100644
--- a/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/BuildExecutor.java
+++ b/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/BuildExecutor.java
@@ -32,7 +32,7 @@ public class BuildExecutor {
 	public static void executeAnt (String buildFile, String params) {
 		FileDescriptor build = new FileDescriptor(buildFile);
 		String ant = System.getProperty("os.name").contains("Windows") ? "ant.bat" : "ant";
-		String command = ant + " -f " + build.name() + " " + params;
+		String command = ant + " -f " + build.file().getAbsolutePath() + " " + params;
 		System.out.println("Executing '" + command + "'");
 		startProcess(command, build.parent().file());
 	}
@@ -47,7 +47,8 @@ public class BuildExecutor {
 
 	private static void startProcess (String command, File directory) {
 		try {
-			final Process process = Runtime.getRuntime().exec(command, null, directory);
+			final Process process = new ProcessBuilder(command.split(" ")).redirectErrorStream(true).start();
+
 			Thread t = new Thread(new Runnable() {
 				@Override
 				public void run () {
@@ -134,7 +135,6 @@ public class BuildExecutor {
 			});
 			t.setDaemon(true);
 			t.start();
-			// FIXME this will hang if Ant detects an error while executing GCC in a process. Why?
 			process.waitFor();
 		} catch (Exception e) {
 			e.printStackTrace();
diff --git a/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/BuildTarget.java b/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/BuildTarget.java
index dc5dbcb..10d9624 100644
--- a/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/BuildTarget.java
+++ b/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/BuildTarget.java
@@ -54,6 +54,8 @@ public class BuildTarget {
 	public String preCompileTask;
 	/** Ant Xml executed in a target after compilation **/
 	public String postCompileTask;
+	/** the libraries to be linked to the output, specify via e.g. -ldinput -ldxguid etc. **/
+	public String libraries;
 
 	/** Creates a new build target. See members of this class for a description of the parameters. */
 	public BuildTarget (BuildTarget.TargetOs targetType, boolean is64Bit, String[] cIncludes, String[] cExcludes,
@@ -81,6 +83,7 @@ public class BuildTarget {
 		this.cFlags = cFlags;
 		this.cppFlags = cppFlags;
 		this.linkerFlags = linkerFlags;
+		this.libraries = "";
 	}
 
 	/** Creates a new default BuildTarget for the given OS, using common default values. */
diff --git a/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/resources/scripts/build-target.xml.template b/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/resources/scripts/build-target.xml.template
index 950228c..ab8a3ba 100644
--- a/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/resources/scripts/build-target.xml.template
+++ b/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/resources/scripts/build-target.xml.template
@@ -33,6 +33,7 @@
 	<!-- define linker and options -->
 	<property name="linker" value="${compilerPrefix}g++"/>
 	<property name="linker-opts" value="%linkerFlags%"/>
+	<property name="libraries" value="%libraries%"/>
 	
 	<!-- cleans the build directory, removes all object files and shared libs -->
 	<target name="clean">
@@ -112,17 +113,20 @@
 
 	<!-- links the shared library based on the previously compiled object files -->	
 	<target name="link" depends="compile" if="has-compiler">
-		<mkdir dir="${libsDir}"/>
-		<apply failonerror="true" executable="${linker}" parallel="true" dir="${buildDir}">
-			<arg line="${linker-opts}"/>
-			<arg value="-o"/>
-			<arg path="${libsDir}/${libName}"/>		
-			<fileset dir="${buildDir}">
-				<patternset>
-					<include name="**/*.o"/>
-				</patternset>
-			</fileset>
-		</apply>
+		<fileset dir="${buildDir}" id="objFileSet">
+			<patternset>
+				<include name="**/*.o" />
+			</patternset>
+		</fileset>
+		<pathconvert pathsep=" " property="objFiles" refid="objFileSet" />
+		<mkdir dir="${libsDir}" />
+		<exec executable="${linker}" failonerror="true" dir="${buildDir}">
+			<arg line="${linker-opts}" />
+			<arg value="-o" />
+			<arg path="${libsDir}/${libName}" />
+			<arg line="${objFiles}"/>
+			<arg line="${libraries}" />
+		</exec>
 	</target>	
 	
 	<target name="postcompile" depends="link">
diff --git a/gdx/src/com/badlogic/gdx/graphics/Mesh.java b/gdx/src/com/badlogic/gdx/graphics/Mesh.java
index c68fdea..c9437a9 100644
--- a/gdx/src/com/badlogic/gdx/graphics/Mesh.java
+++ b/gdx/src/com/badlogic/gdx/graphics/Mesh.java
@@ -787,4 +787,108 @@ public class Mesh implements Disposable {
 			break;
 		}
 	}
+	
+	/** Copies this mesh optionally removing duplicate vertices and/or reducing the amount of attributes.
+	 * @param isStatic whether the new mesh is static or not. Allows for internal optimizations.
+	 * @param removeDuplicates whether to remove duplicate vertices if possible. Only the vertices specified by usage are checked.
+	 * @param usage which attributes (if available) to copy
+	 * @return the copy of this mesh
+	 */
+	public Mesh copy(boolean isStatic, boolean removeDuplicates, final int[] usage) {
+		// TODO move this to a copy constructor?
+		// TODO duplicate the buffers without double copying the data if possible.
+		// TODO perhaps move this code to JNI if it turns out being too slow.
+		final int vertexSize = getVertexSize() / 4;
+		int numVertices = getNumVertices();
+		float[] vertices = new float[numVertices * vertexSize];
+		getVertices(0, vertices.length, vertices);
+		short[] checks = null;
+		VertexAttribute[] attrs = null;
+		int newVertexSize = 0;
+		if (usage != null) {
+			int size = 0;
+			int as = 0;
+			for (int i = 0; i < usage.length; i++)
+				if (getVertexAttribute(usage[i]) != null) {
+					size += getVertexAttribute(usage[i]).numComponents;
+					as++;
+				}
+			if (size > 0) {
+				attrs = new VertexAttribute[as];
+				checks = new short[size];
+				int idx = -1;
+				int ai = -1;
+				for (int i = 0; i < usage.length; i++) {
+					VertexAttribute a = getVertexAttribute(usage[i]);
+					if (a == null)
+						continue;
+					for (int j = 0; j < a.numComponents; j++)
+						checks[++idx] = (short)(a.offset + j);
+					attrs[++ai] = new VertexAttribute(a.usage, a.numComponents, a.alias);
+					newVertexSize += a.numComponents;
+				}
+			}
+		}
+		if (checks == null) {
+			checks = new short[vertexSize];
+			for (short i = 0; i < vertexSize; i++)
+				checks[i] = i;
+			newVertexSize = vertexSize;
+		}
+		
+		int numIndices = getNumIndices();
+		short[] indices = null;	
+		if (numIndices > 0) {
+			indices = new short[numIndices];
+			getIndices(indices);
+			if (removeDuplicates || newVertexSize != vertexSize) {
+				float[] tmp = new float[vertices.length];
+				int size = 0;
+				for (int i = 0; i < numIndices; i++) {
+					final int idx1 = indices[i] * vertexSize;
+					short newIndex = -1;
+					if (removeDuplicates) {
+						for (short j = 0; j < size && newIndex < 0; j++) {
+							final int idx2 = j*newVertexSize;
+							boolean found = true;
+							for (int k = 0; k < checks.length && found; k++) {
+								if (tmp[idx2+k] != vertices[idx1+checks[k]])
+									found = false;
+							}
+							if (found)
+								newIndex = j;
+						}
+					}
+					if (newIndex > 0)
+						indices[i] = newIndex;
+					else {
+						final int idx = size * newVertexSize;
+						for (int j = 0; j < checks.length; j++)
+							tmp[idx+j] = vertices[idx1+checks[j]];
+						indices[i] = (short)size;
+						size++;
+					}
+				}
+				vertices = tmp;
+				numVertices = size;
+			}
+		}
+		
+		Mesh result;
+		if (attrs == null)
+			result = new Mesh(isStatic, numVertices, indices == null ? 0 : indices.length, getVertexAttributes());
+		else
+			result = new Mesh(isStatic, numVertices, indices == null ? 0 : indices.length, attrs);
+		result.setVertices(vertices, 0, numVertices * newVertexSize);
+		result.setIndices(indices);
+		return result;
+	}
+	
+	/** Copies this mesh.
+	 * @param isStatic whether the new mesh is static or not. Allows for internal optimizations.
+	 * @return the copy of this mesh
+	 */
+	public Mesh copy(boolean isStatic) {
+		return copy(isStatic, false, null);
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/VertexAttribute.java b/gdx/src/com/badlogic/gdx/graphics/VertexAttribute.java
index dfb216b..251cc55 100644
--- a/gdx/src/com/badlogic/gdx/graphics/VertexAttribute.java
+++ b/gdx/src/com/badlogic/gdx/graphics/VertexAttribute.java
@@ -66,22 +66,6 @@ public final class VertexAttribute {
 	public static VertexAttribute ColorUnpacked () {
 		return new VertexAttribute(Usage.Color, 4, ShaderProgram.COLOR_ATTRIBUTE);
 	}
-	
-	public static VertexAttribute Tangent() {
-		return new VertexAttribute(Usage.Generic, 3, ShaderProgram.TANGENT_ATTRIBUTE);
-	}
-	
-	public static VertexAttribute Binormal() {
-		return new VertexAttribute(Usage.Generic, 3, ShaderProgram.BINORMAL_ATTRIBUTE);
-	}
-	
-	public static VertexAttribute BoneIds(int numBones) {
-		return new VertexAttribute(Usage.Generic, numBones, "a_boneids");
-	}
-	
-	public static VertexAttribute BoneWeights(int numBones) {
-		return new VertexAttribute(Usage.Generic, numBones, "a_boneWeights");
-	}
 
 	/** Tests to determine if the passed object was created with the same parameters */
 	@Override
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMaterial.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMaterial.java
deleted file mode 100755
index bd6d00d..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMaterial.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.loaders.json;
-
-import com.badlogic.gdx.graphics.Color;
-
-public class JsonMaterial {
-	public String id;
-	public Color ambient;
-	public Color diffuse;
-	public Color specular;
-	public Color emmissive;
-	public float shininess;
-	public String diffuseMap;
-	public String lightMap;
-	public String normalMap;
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMesh.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMesh.java
deleted file mode 100755
index bfd396b..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMesh.java
+++ /dev/null
@@ -1,10 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.loaders.json;
-
-import com.badlogic.gdx.graphics.VertexAttribute;
-
-public class JsonMesh {
-	public String id;
-	public VertexAttribute[] attributes;
-	public float[] vertices;
-	public JsonMeshPart[] parts;
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMeshPart.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMeshPart.java
deleted file mode 100755
index a2fb02a..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMeshPart.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.loaders.json;
-
-public class JsonMeshPart {
-	public String id;
-	public short[] indices;
-	public int primitiveType;
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMeshPartMaterial.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMeshPartMaterial.java
deleted file mode 100755
index 011b2d9..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMeshPartMaterial.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.loaders.json;
-
-public class JsonMeshPartMaterial {
-	public String materialId;
-	public String partId;
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonModel.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonModel.java
deleted file mode 100755
index 58612b6..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonModel.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.loaders.json;
-
-import com.badlogic.gdx.utils.GdxRuntimeException;
-
-public class JsonModel {
-	public String version;
-	public JsonMesh[] meshes;
-	public JsonMaterial[] materials;
-	public JsonNode[] nodes;
-	
-	public void addMesh(JsonMesh mesh) {
-		for(JsonMesh other: meshes) {
-			if(other.id.equals(mesh.id)) {
-				throw new GdxRuntimeException("Mesh with id '" + other.id + "' already in model");
-			}
-		}
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonModelLoader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonModelLoader.java
deleted file mode 100755
index ec24229..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonModelLoader.java
+++ /dev/null
@@ -1,180 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.loaders.json;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.GL10;
-import com.badlogic.gdx.graphics.VertexAttribute;
-import com.badlogic.gdx.graphics.g3d.ModelLoaderHints;
-import com.badlogic.gdx.graphics.g3d.loaders.ModelLoader;
-import com.badlogic.gdx.graphics.g3d.loaders.StillModelLoader;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
-import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-import com.badlogic.gdx.utils.JsonReader;
-import com.badlogic.gdx.utils.OrderedMap;
-
-/**
- * {@link ModelLoader} for the JSON format written by the 
- * <a href="https://github.com/libgdx/fbx-conv">fbx-conv</a> tool.
- * 
- * @author mzechner
- *
- */
-public class JsonModelLoader implements StillModelLoader {
-	public static String VERSION = "1.0";
-	
-	@Override
-	public StillModel load (FileHandle handle, ModelLoaderHints hints) {
-		JsonModel model = parseModel(handle, hints);
-		
-		return null;
-	}
-
-	public JsonModel parseModel (FileHandle handle, ModelLoaderHints hints) {
-		JsonReader reader = new JsonReader();
-		OrderedMap<String, Object> json = (OrderedMap<String, Object>)reader.parse(handle);
-		
-		String version = (String)json.get("version");
-		if(version == null || !version.equals(VERSION)) {
-			throw new GdxRuntimeException("No or wrong JSON format version given, should be " + VERSION + ", is " + version);
-		}
-		
-		JsonModel model = new JsonModel();
-		parseMeshes(model, json, hints);
-		parseMaterials(model, json, hints);
-		parseNodes(model, json, hints);
-		return model;
-	}
-	
-	private JsonMesh[] parseMeshes (JsonModel model, OrderedMap<String, Object> json, ModelLoaderHints hints) {
-		Array<OrderedMap<String, Object>> meshes = (Array<OrderedMap<String, Object>>)json.get("meshes");
-		if(meshes == null) {
-			throw new GdxRuntimeException("No meshes found in file");
-		}
-		
-		model.meshes = new JsonMesh[meshes.size];
-		int i = 0;
-		for(OrderedMap<String, Object> mesh: meshes) {
-			JsonMesh jsonMesh = new JsonMesh();
-			String id = (String)mesh.get("id");
-			if(id == null) {
-				throw new GdxRuntimeException("No id given for mesh");
-			}
-			jsonMesh.id = id;
-			
-			Array<Object> attributes = (Array<Object>)mesh.get("attributes");
-			if(attributes == null) {
-				throw new GdxRuntimeException("No vertex attributes given for mesh '" + id + "'");
-			}
-			jsonMesh.attributes = parseAttributes(attributes);
-			
-			Array<Object> vertices = (Array<Object>)mesh.get("vertices");
-			if(vertices == null) {
-				throw new GdxRuntimeException("No vertices given for mesh '" + id + "'");
-			}
-			float[] verts = new float[vertices.size];
-			int idx = 0;
-			for(Object v: vertices) {
-				verts[idx++] = (Float)v;
-			}
-			jsonMesh.vertices = verts;
-			
-			Array<OrderedMap<String, Object>> meshParts = (Array<OrderedMap<String, Object>>)mesh.get("parts");
-			if(meshParts == null) {
-				throw new GdxRuntimeException("No mesh parts given for mesh '" + id + "'");
-			}
-			Array<JsonMeshPart> parts = new Array<JsonMeshPart>();
-			for(OrderedMap<String, Object> meshPart: meshParts) {
-				JsonMeshPart jsonPart = new JsonMeshPart();
-				String partId = (String)meshPart.get("id");
-				if(id == null) {
-					throw new GdxRuntimeException("Not id given for mesh part");
-				}
-				for(JsonMeshPart other: parts) {
-					if(other.id.equals(partId)) {
-						throw new GdxRuntimeException("Mesh part with id '" + partId + "' already in defined");
-					}
-				}
-				jsonPart.id = partId;
-				
-				String type = (String)meshPart.get("type");
-				if(type == null) {
-					throw new GdxRuntimeException("No primitive type given for mesh part '" + partId + "'");
-				}
-				jsonPart.primitiveType = parseType(type);
-				
-				Array<Object> indices = (Array<Object>)meshPart.get("indices");
-				if(indices == null) {
-					throw new GdxRuntimeException("No indices given for mesh part '" + partId + "'");
-				}
-				short[] partIndices = new short[indices.size];
-				idx = 0;
-				for(Object index: indices) {
-					partIndices[idx++] = (short)(float)(Float)index;
-				}
-				jsonPart.indices = partIndices;
-				parts.add(jsonPart);
-			}
-			jsonMesh.parts = parts.toArray(JsonMeshPart.class);
-			model.meshes[i++] = jsonMesh;
-		}
-		return model.meshes;
-	}
-	
-	private int parseType (String type) {
-		if(type.equals("TRIANGLES")) {
-			return GL10.GL_TRIANGLES;
-		} else if(type.equals("LINES")) {
-			return GL10.GL_LINES;
-		} else if(type.equals("POINTS")) {
-			return GL10.GL_POINTS;
-		} else if(type.equals("TRIANGLE_STRIP")) {
-			return GL10.GL_TRIANGLE_STRIP;
-		} else if(type.equals("LINE_STRIP")) {
-			return GL10.GL_LINE_STRIP;
-		} /* Gameplay encoder doesn't read out line loop
-			else if(type.equals("lineloop")) {
-			return GL10.GL_LINE_LOOP; 
-		} */
-			else { 
-			throw new GdxRuntimeException("Unknown primitive type '" + type + "', should be one of triangle, trianglestrip, line, linestrip, lineloop or point");
-		}
-	}
-
-	private VertexAttribute[] parseAttributes (Array<Object> attributes) {
-		Array<VertexAttribute> vertexAttributes = new Array<VertexAttribute>();
-		int unit = 0;
-		for(Object attribute: attributes) {
-			String attr = (String)attribute;
-			if(attr.equals("POSITION")) {
-				vertexAttributes.add(VertexAttribute.Position());
-			} else if(attr.equals("NORMAL")) {
-				vertexAttributes.add(VertexAttribute.Normal());
-			} else if(attr.startsWith("TEXCOORD")) {
-				vertexAttributes.add(VertexAttribute.TexCoords(unit++));
-			} else if(attr.equals("TANGENT")) {
-				vertexAttributes.add(VertexAttribute.Tangent());
-			} else if(attr.equals("BINORMAL")) {
-				vertexAttributes.add(VertexAttribute.Binormal());
-			} else if(attr.equals("BLENDINDICES")) {
-				vertexAttributes.add(VertexAttribute.BoneIds(4));
-			} else if(attr.equals("BLENDWEIGHTS")) {
-				vertexAttributes.add(VertexAttribute.BoneWeights(4));
-			} else if(attr.equals("COLOR")) {
-				vertexAttributes.add(VertexAttribute.Color());
-			} else {
-				throw new GdxRuntimeException("Unknown vertex attribuet '" + attr + "', should be one of position, normal, uv, tangent or binormal");
-			}
-		}
-		return vertexAttributes.toArray(VertexAttribute.class);
-	}
-
-	private JsonMaterial[] parseMaterials (JsonModel model, OrderedMap<String, Object> json, ModelLoaderHints hints) {
-		
-		return null;
-	}
-
-	private JsonNode[] parseNodes (JsonModel model, OrderedMap<String, Object> json, ModelLoaderHints hints) {
-		return null;
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonNode.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonNode.java
deleted file mode 100755
index 95504cb..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonNode.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.loaders.json;
-
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Vector3;
-
-public class JsonNode {
-	public String id;
-	public int boneId = -1;
-	public Vector3 translation;
-	public Quaternion rotation;
-	public Vector3 scale;
-	public String meshId;
-	public JsonMeshPartMaterial[] meshPartMaterials;
-	public JsonNode[] children;
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/SubMesh.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/SubMesh.java
index 8d67ce1..260f08f 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/SubMesh.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/model/SubMesh.java
@@ -27,10 +27,15 @@ public abstract class SubMesh {
 	public Mesh mesh;
 
 
-	public SubMesh (String name, Mesh mesh, int primitiveType) {
+	public SubMesh (String name, Mesh mesh, int primitiveType, Material material) {
 		this.name = name;
 		this.setMesh(mesh);
 		this.primitiveType = primitiveType;
+		this.material = material;
+	}
+	
+	public SubMesh (String name, Mesh mesh, int primitiveType) {
+		this(name, mesh, primitiveType, null);
 	}
 
 	/** Obtain the {@link BoundingBox} of this {@link SubMesh}.
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/still/StillModel.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/still/StillModel.java
index 2b4ca3b..91c1eb2 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/still/StillModel.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/model/still/StillModel.java
@@ -27,7 +27,7 @@ import com.badlogic.gdx.math.collision.BoundingBox;
 public class StillModel implements Model {
 	final public StillSubMesh[] subMeshes;
 
-	public StillModel (SubMesh[] subMeshes) {
+	public StillModel (SubMesh... subMeshes) {
 		this.subMeshes = new StillSubMesh[subMeshes.length];
 		for (int i = 0; i < subMeshes.length ; ++i) {
 			this.subMeshes[i] = (StillSubMesh)subMeshes[i];
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/still/StillSubMesh.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/still/StillSubMesh.java
index d274cea..3150021 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/still/StillSubMesh.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/model/still/StillSubMesh.java
@@ -17,11 +17,16 @@
 package com.badlogic.gdx.graphics.g3d.model.still;
 
 import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.g3d.materials.Material;
 import com.badlogic.gdx.graphics.g3d.model.SubMesh;
 import com.badlogic.gdx.math.collision.BoundingBox;
 
 public class StillSubMesh extends SubMesh {
 
+	public StillSubMesh (String name, Mesh mesh, int primitiveType, Material material) {
+		super(name, mesh, primitiveType, material);
+	}
+	
 	public StillSubMesh (String name, Mesh mesh, int primitiveType) {
 		super(name, mesh, primitiveType);
 	}
diff --git a/gdx/src/com/badlogic/gdx/utils/GdxNativesLoader.java b/gdx/src/com/badlogic/gdx/utils/GdxNativesLoader.java
index f8ae0d5..a16c379 100644
--- a/gdx/src/com/badlogic/gdx/utils/GdxNativesLoader.java
+++ b/gdx/src/com/badlogic/gdx/utils/GdxNativesLoader.java
@@ -65,33 +65,35 @@ public class GdxNativesLoader {
 	static public String extractLibrary (String native32, String native64) {
 		String nativeFileName = is64Bit ? native64 : native32;
 		File nativeFile = new File(nativesDir, nativeFileName);
-		try {
-			// Extract native from classpath to temp dir.
-			InputStream input = GdxNativesLoader.class.getResourceAsStream("/" + nativeFileName);
-			if (input == null) return null;
-			nativesDir.mkdirs();
-			FileOutputStream output = new FileOutputStream(nativeFile);
-			byte[] buffer = new byte[4096];
-			while (true) {
-				int length = input.read(buffer);
-				if (length == -1) break;
-				output.write(buffer, 0, length);
+		InputStream input = GdxNativesLoader.class.getResourceAsStream("/" + nativeFileName);
+		if (!nativeFile.exists() || nativeFile.length() == 0) {
+			try {
+				// Extract native from classpath to temp dir.
+				if (input == null) return null;
+				nativesDir.mkdirs();
+				FileOutputStream output = new FileOutputStream(nativeFile);
+				byte[] buffer = new byte[4096];
+				while (true) {
+					int length = input.read(buffer);
+					if (length == -1) break;
+					output.write(buffer, 0, length);
+				}
+				input.close();
+				output.close();
+			} catch (IOException ignored) {
 			}
-			input.close();
-			output.close();
-		} catch (IOException ex) {
 		}
 		return nativeFile.exists() ? nativeFile.getAbsolutePath() : null;
 	}
 
 	/** Loads the libgdx native libraries. */
 	static public void load () {
+		if (nativesLoaded) return;
 		if (disableNativesLoading) {
-			System.out
-				.println("So you don't like our native lib loading? Good, you are on your own now. We don't give support from here on out");
+			nativesLoaded = true;
+			System.out.println("Native loading is disabled.");
 			return;
 		}
-		if (nativesLoaded) return;
 
 		String vm = System.getProperty("java.vm.name");
 		if (vm == null || !vm.contains("Dalvik")) {
diff --git a/gdx/src/com/badlogic/gdx/utils/SharedLibraryLoader.java b/gdx/src/com/badlogic/gdx/utils/SharedLibraryLoader.java
index cac8e9a..3fd73d3 100644
--- a/gdx/src/com/badlogic/gdx/utils/SharedLibraryLoader.java
+++ b/gdx/src/com/badlogic/gdx/utils/SharedLibraryLoader.java
@@ -145,7 +145,7 @@ public class SharedLibraryLoader {
 		if (loaded) {
 			loadedLibraries.add(sharedLibName);
 		} else {
-			throw new RuntimeException("Couldn't load shared library: '" + sharedLibName + "' for target "
+			throw new RuntimeException("Couldn't load shared library '" + sharedLibName + "' for target: "
 				+ System.getProperty("os.name") + ", " + (is64Bit ? "64-bit" : "32-bit"));
 		}
 	}
diff --git a/tests/gdx-tests-android/assets/data/g3d/simple.json b/tests/gdx-tests-android/assets/data/g3d/simple.json
deleted file mode 100755
index b2af015..0000000
--- a/tests/gdx-tests-android/assets/data/g3d/simple.json
+++ /dev/null
@@ -1,23 +0,0 @@
-{
-	"version": "1.0",
-	"meshes": [
-		{
-			"id": "triangle",
-			"attributes": ["position", "normal", "uv", "uv"],
-			"vertices": [ -1, -1, 0, 0, 0, -1,   0, 0,   0, 0, 
-						   1, -1, 0, 0, 0, -1,   1, 0,   1, 0,
-						   0,  1, 0, 0, 0, -1, 0.5, 1, 0.5, 1 ],
-			"parts": [
-				{ "id": "tris", "type": "triangle", "indices": [ 0, 1, 2 ] },
-				{ "id": "line", "type": "line", "indices": [ 0, 1 ] },
-				{ "id": "pts", "type": "point", "indices": [0, 1, 2 ] },
-			] 
-		},
-	],
-	
-	"materials": [
-	],
-	
-	"nodes": [
-	]
-}
\ No newline at end of file
diff --git a/tests/gdx-tests-android/assets/data/g3d/test.g3dj b/tests/gdx-tests-android/assets/data/g3d/test.g3dj
deleted file mode 100644
index a793002..0000000
--- a/tests/gdx-tests-android/assets/data/g3d/test.g3dj
+++ /dev/null
@@ -1,30 +0,0 @@
-{
-	"version" : "1.0",
-	"meshes" : [
-		{
-			"id" : "Cube_Mesh",
-			"attributes" : [
-				"POSITION","NORMAL"
-			],
-			"vertices" : [
-				-1.000000,-1.000000,-1.000000,-0.577349,-0.577349,-0.577349,1.000000,1.000000,-1.000000,0.577349,0.577349,-0.577349,1.000000,-1.000000,-1.000000,0.577349,-0.577349,-0.577349,-1.000000,1.000000,-1.000000,-0.577349,0.577349,-0.577349,-1.000000,1.000000,1.000000,-0.577349,0.577349,0.577349,-1.000000,-1.000000,1.000000,-0.577349,-0.577349,0.577349,1.000000,0.999999,1.000000,0.577349,0.577349,0.577349,0.999999,-1.000001,1.000000,0.577349,-0.577349,0.577349
-			],
-			"parts" : [
-				{
-					"id" : "part0",
-					"type" : "TRIANGLES",
-					"indices" : [
-						0,1,2,1,0,3,4,5,6,6,5,7,6,2,1,2,6,7,7,0,2,0,7,5,4,0,5,0,4,3,4,6,3,6,1,3,
-					]
-				}
-			]
-		},
-		
-	],
-	"materials" : [
-		
-	],
-	"nodes" : [
-		
-	]
-}
\ No newline at end of file
diff --git a/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java b/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java
index 882130d..e9e25c0 100644
--- a/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java
+++ b/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java
@@ -18,11 +18,7 @@ package com.badlogic.gdx.tests.lwjgl;
 
 import com.badlogic.gdx.backends.lwjgl.LwjglApplication;
 import com.badlogic.gdx.backends.lwjgl.LwjglApplicationConfiguration;
-import com.badlogic.gdx.tests.BulletTestCollection;
-import com.badlogic.gdx.tests.SoundTest;
-import com.badlogic.gdx.tests.bullet.SoftMeshTest;
-import com.badlogic.gdx.tests.extensions.Mpg123Test;
-import com.badlogic.gdx.tests.g3d.JsonModelLoaderTest;
+import com.badlogic.gdx.tests.YDownTest;
 import com.badlogic.gdx.tests.utils.GdxTest;
 import com.badlogic.gdx.utils.SharedLibraryLoader;
 
@@ -34,7 +30,7 @@ public class LwjglDebugStarter {
 		new SharedLibraryLoader("../../extensions/gdx-freetype/libs/gdx-freetype-natives.jar").load("gdx-freetype");
 		new SharedLibraryLoader("../../gdx/libs/gdx-natives.jar").load("gdx");
 
-		GdxTest test = new JsonModelLoaderTest();
+		GdxTest test = new YDownTest();
 		LwjglApplicationConfiguration config = new LwjglApplicationConfiguration();
 		config.useGL20 = test.needsGL20();
 		new LwjglApplication(test, config);
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/BulletTestCollection.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/BulletTestCollection.java
index 449ffa9..ae256e1 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/BulletTestCollection.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/BulletTestCollection.java
@@ -29,6 +29,7 @@ import com.badlogic.gdx.input.GestureDetector.GestureListener;
 import com.badlogic.gdx.math.Vector2;
 import com.badlogic.gdx.scenes.scene2d.Stage;
 import com.badlogic.gdx.scenes.scene2d.ui.Label;
+import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.tests.box2d.Box2DTest;
 import com.badlogic.gdx.tests.bullet.BulletTest;
 import com.badlogic.gdx.tests.bullet.ConstraintsTest;
@@ -45,9 +46,11 @@ import com.badlogic.gdx.tests.utils.GdxTest;
 
 /** @author xoppa */
 public class BulletTestCollection extends GdxTest implements InputProcessor, GestureListener {
-	private final BulletTest[] tests = {new ShootTest(), new KinematicTest(), new ConstraintsTest(), new MeshShapeTest(), new ConvexHullTest(), new RayCastTest(), new RayPickRagdollTest(), new InternalTickTest(), new SoftBodyTest(), new SoftMeshTest()};
+	protected final BulletTest[] tests = {new ShootTest(), new KinematicTest(), new ConstraintsTest(), 
+		new MeshShapeTest(), new ConvexHullTest(), new RayCastTest(), new RayPickRagdollTest(), new InternalTickTest(), 
+		new SoftBodyTest(), new SoftMeshTest()};
 	
-	private int testIndex = 0;
+	protected int testIndex = 0;
 	
 	private Application app = null;
 	
@@ -55,6 +58,7 @@ public class BulletTestCollection extends GdxTest implements InputProcessor, Ges
 	private Stage hud;
 	private Label fpsLabel;
 	private Label titleLabel;
+	private Label instructLabel;
 	private int loading = 0;
 	
 	@Override
@@ -82,6 +86,10 @@ public class BulletTestCollection extends GdxTest implements InputProcessor, Ges
 		fpsLabel.setPosition(0, 0);
 		hud.addActor(titleLabel = new Label(tests[testIndex].getClass().getSimpleName(), new Label.LabelStyle(font, Color.WHITE)));
 		titleLabel.setY(hud.getHeight()-titleLabel.getHeight());
+		hud.addActor(instructLabel = new Label("A\nB\nC\nD\nE\nF", new Label.LabelStyle(font, Color.WHITE)));
+		instructLabel.setY(titleLabel.getY() - instructLabel.getHeight());
+		instructLabel.setAlignment(Align.top | Align.left);
+		instructLabel.setText(tests[testIndex].instructions);
 	}
 	
 	@Override
@@ -106,6 +114,7 @@ public class BulletTestCollection extends GdxTest implements InputProcessor, Ges
 		app.log("TestCollection", "created test '" + tests[testIndex].getClass().getName() + "'");
 		
 		titleLabel.setText(tests[testIndex].getClass().getSimpleName());
+		instructLabel.setText(tests[testIndex].instructions);
 		loading = 0;
 	}
 	
@@ -171,14 +180,14 @@ public class BulletTestCollection extends GdxTest implements InputProcessor, Ges
 
 	@Override
 	public boolean longPress (float x, float y) {
-		if (tests[testIndex].longPress (x, y) == false)
-			next();
-		return true;
+		return tests[testIndex].longPress (x, y);
 	}
 
 	@Override
 	public boolean fling (float velocityX, float velocityY, int button) {
-		return tests[testIndex].fling (velocityX, velocityY, button);
+		if (tests[testIndex].fling (velocityX, velocityY, button) == false)
+			next();
+		return true;
 	}
 
 	@Override
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/SoundTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/SoundTest.java
index 9abffda..7a85685 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/SoundTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/SoundTest.java
@@ -61,8 +61,10 @@ public class SoundTest extends GdxTest {
 		table.setFillParent(true);
 
 		table.align(Align.center | Align.top);
+		table.columnDefaults(0).expandX().right().uniformX();
+		table.columnDefaults(2).expandX().left().uniformX();
 		table.add(play);
-		table.add(stop);
+		table.add(stop).left();
 		table.row();
 		table.add(new Label("Pitch", skin));
 		table.add(pitch);
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/YDownTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/YDownTest.java
index 03a2e4e..c4675f4 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/YDownTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/YDownTest.java
@@ -17,10 +17,12 @@
 package com.badlogic.gdx.tests;
 
 import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.OrthographicCamera;
 import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.graphics.g2d.BitmapFont;
+import com.badlogic.gdx.graphics.g2d.Sprite;
 import com.badlogic.gdx.graphics.g2d.SpriteBatch;
 import com.badlogic.gdx.graphics.g2d.TextureAtlas;
 import com.badlogic.gdx.graphics.g2d.TextureRegion;
@@ -36,6 +38,7 @@ public class YDownTest extends GdxTest {
 	SpriteBatch batch;
 	BitmapFont font;
 	TextureRegion region;
+	Sprite sprite;
 	TextureAtlas atlas;
 	Stage stage;
 	MyActor image;
@@ -50,9 +53,13 @@ public class YDownTest extends GdxTest {
 		// a texture region, note the flipping on y again
 		region = new TextureRegion(new Texture("data/badlogic.jpg"));
 		region.flip(false, true);
-
+		
 		// a texture atlas, note the boolean
 		atlas = new TextureAtlas(Gdx.files.internal("data/pack"), true);
+		
+		// a sprite, created from a region in the atlas
+		sprite = atlas.createSprite("badlogicsmall");
+		sprite.setPosition(0, 0);
 
 		// a sprite batch with which we want to render
 		batch = new SpriteBatch();
@@ -100,6 +107,9 @@ public class YDownTest extends GdxTest {
 		// drawing regions from an atlas, x and y will be the top left corner.
 		// you shouldn't call findRegion every frame, cache the result.
 		batch.draw(atlas.findRegion("badlogicsmall"), 360, 100);
+		// drawing a sprite created from an atlas, FIXME wut?! AtlasSprite#setPosition seems to be wrong
+		sprite.setColor(Color.RED);
+		sprite.draw(batch);
 		// finally we draw our current touch/mouse coordinates
 		font.draw(batch, Gdx.input.getX() + ", " + Gdx.input.getY(), 0, 0);
 		batch.end();
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseBulletTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseBulletTest.java
index 3590eb6..d800d37 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseBulletTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseBulletTest.java
@@ -24,6 +24,9 @@ import com.badlogic.gdx.graphics.Mesh;
 import com.badlogic.gdx.graphics.PerspectiveCamera;
 import com.badlogic.gdx.graphics.VertexAttribute;
 import com.badlogic.gdx.graphics.VertexAttributes.Usage;
+import com.badlogic.gdx.graphics.g3d.materials.Material;
+import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.model.still.StillSubMesh;
 import com.badlogic.gdx.math.collision.Ray;
 import com.badlogic.gdx.physics.bullet.Bullet;
 import com.badlogic.gdx.physics.bullet.btIDebugDraw;
@@ -63,6 +66,7 @@ public class BaseBulletTest extends BulletTest {
 	public void create () {
 		init();
 		world = createWorld();
+		world.performanceCounter = performanceCounter;
 
 		final float width = Gdx.graphics.getWidth();
 		final float height = Gdx.graphics.getHeight();
@@ -78,6 +82,7 @@ public class BaseBulletTest extends BulletTest {
 		final Mesh groundMesh = new Mesh(true, 4, 6, new VertexAttribute(Usage.Position, 3, "a_position"));
 		groundMesh.setVertices(new float[] {20f, 0f, 20f, 20f, 0f, -20f, -20f, 0f, 20f, -20f, 0f, -20f});
 		groundMesh.setIndices(new short[] {0, 1, 2, 1, 2, 3});
+		final StillModel groundModel = new StillModel(new StillSubMesh("ground", groundMesh, GL10.GL_TRIANGLES, new Material()));
 
 		final Mesh boxMesh = new Mesh(true, 8, 36, new VertexAttribute(Usage.Position, 3, "a_position"));
 		boxMesh.setVertices(new float[] {0.5f, 0.5f, 0.5f, 0.5f, 0.5f, -0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, -0.5f,
@@ -89,11 +94,12 @@ public class BaseBulletTest extends BulletTest {
 			2, 3, 6, 6, 7, 3, // left
 			0, 1, 4, 4, 5, 1 // right
 			});
+		final StillModel boxModel = new StillModel(new StillSubMesh("box", boxMesh, GL10.GL_TRIANGLES, new Material()));
 
 		// Add the constructors
-		world.addConstructor("ground", new BulletConstructor(groundMesh, 0f)); // mass = 0: static body
-		world.addConstructor("box", new BulletConstructor(boxMesh, 1f)); // mass = 1kg: dynamic body
-		world.addConstructor("staticbox", new BulletConstructor(boxMesh, 0f)); // mass = 0: static body
+		world.addConstructor("ground", new BulletConstructor(groundModel, 0f)); // mass = 0: static body
+		world.addConstructor("box", new BulletConstructor(boxModel, 1f)); // mass = 1kg: dynamic body
+		world.addConstructor("staticbox", new BulletConstructor(boxModel, 0f)); // mass = 0: static body
 	}
 	
 	@Override
@@ -106,6 +112,8 @@ public class BaseBulletTest extends BulletTest {
 	
 	@Override
 	public void render () {
+		fpsCounter.put(Gdx.graphics.getFramesPerSecond());
+		
 		GL10 gl = Gdx.gl10;
 		gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
 		gl.glEnable(GL10.GL_DEPTH_TEST);
@@ -122,8 +130,8 @@ public class BaseBulletTest extends BulletTest {
 		world.update();
 		
 		performance.setLength(0);
-		performance.append("FPS: ").append(Gdx.graphics.getFramesPerSecond()).append(", Bullet: ")
-			.append((int)(world.bulletLoad*100f)).append("%");
+		performance.append("FPS: ").append(fpsCounter.value).append(", Bullet: ")
+			.append((int)(performanceCounter.load.value*100f)).append("%");
 	}
 	
 	public void shoot(final float x, final float y) {
@@ -158,7 +166,7 @@ public class BaseBulletTest extends BulletTest {
 	}
 	
 	@Override
-	public boolean fling (float velocityX, float velocityY, int button) {
+	public boolean longPress (float x, float y) {
 		toggleDebugMode();
 		return true;
 	}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseEntity.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseEntity.java
index b9266fc..8954959 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseEntity.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseEntity.java
@@ -17,6 +17,7 @@ package com.badlogic.gdx.tests.bullet;
 
 import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.g3d.model.Model;
 import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.utils.Disposable;
 
@@ -25,6 +26,6 @@ import com.badlogic.gdx.utils.Disposable;
  */
 public abstract class BaseEntity implements Disposable {
 	public Matrix4 transform = new Matrix4();
-	public Mesh mesh;
+	public Model model;
 	public Color color = new Color(1f, 1f, 1f, 1f);
 }
\ No newline at end of file
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseWorld.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseWorld.java
index 4753c0e..e0d39e1 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseWorld.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseWorld.java
@@ -19,6 +19,7 @@ import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.g3d.model.Model;
 import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.Disposable;
@@ -29,19 +30,19 @@ import com.badlogic.gdx.utils.ObjectMap;
  */
 public class BaseWorld<T extends BaseEntity> implements Disposable {
 	public static abstract class Constructor<T extends BaseEntity> implements Disposable {
-		public Mesh mesh = null;
+		public Model model = null;
 		public abstract T construct(final float x, final float y, final float z);
 		public abstract T construct(final Matrix4 transform);
 	}	
 	
 	private final ObjectMap<String, Constructor<T>> constructors = new ObjectMap<String, Constructor<T>>();
 	protected final Array<T> entities = new Array<T>();
-	private final Array<Mesh> meshes = new Array<Mesh>();
+	private final Array<Model> models = new Array<Model>();
 	
 	public void addConstructor(final String name, final Constructor<T> constructor) {
 		constructors.put(name, constructor);
-		if (constructor.mesh != null && !meshes.contains(constructor.mesh, true))
-			meshes.add(constructor.mesh);
+		if (constructor.model != null && !models.contains(constructor.model, true))
+			models.add(constructor.model);
 	}
 	
 	public Constructor<T> getConstructor(final String name) {
@@ -72,7 +73,7 @@ public class BaseWorld<T extends BaseEntity> implements Disposable {
 			gl.glPushMatrix();
 			gl.glMultMatrixf(entity.transform.val, 0);
 			gl.glColor4f(entity.color.r, entity.color.g, entity.color.b, entity.color.a);
-			entity.mesh.render(GL10.GL_TRIANGLES);
+			entity.model.render();
 			gl.glPopMatrix();
 		}
 	}
@@ -87,8 +88,8 @@ public class BaseWorld<T extends BaseEntity> implements Disposable {
 			constructor.dispose();
 		constructors.clear();
 		
-		for (int i = 0; i < meshes.size; i++)
-			meshes.get(i).dispose();
-		meshes.clear();
+		for (int i = 0; i < models.size; i++)
+			models.get(i).dispose();
+		models.clear();
 	}
 }
\ No newline at end of file
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletConstructor.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletConstructor.java
index c9ec769..0d13afe 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletConstructor.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletConstructor.java
@@ -16,6 +16,7 @@
 package com.badlogic.gdx.tests.bullet;
 
 import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.g3d.model.Model;
 import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.math.Vector3;
 import com.badlogic.gdx.math.collision.BoundingBox;
@@ -33,33 +34,34 @@ public class BulletConstructor extends BaseWorld.Constructor<BulletEntity> {
 	/**
 	 * Specify null for the shape to use only the renderable part of this entity and not the physics part. 
 	 */
-	public BulletConstructor (final Mesh mesh, final float mass, final btCollisionShape shape) {
-		create(mesh, mass, shape);
+	public BulletConstructor (final Model model, final float mass, final btCollisionShape shape) {
+		create(model, mass, shape);
 	}
 
 	/**
 	 * Creates a btBoxShape with the specified dimensions.
 	 */
-	public BulletConstructor (final Mesh mesh, final float mass, final float width, final float height, final float depth) {
-		create(mesh, mass, width, height, depth);
+	public BulletConstructor (final Model model, final float mass, final float width, final float height, final float depth) {
+		create(model, mass, width, height, depth);
 	}
 	
 	/**
 	 * Creates a btBoxShape with the same dimensions as the shape.
 	 */
-	public BulletConstructor (final Mesh mesh, final float mass) {
-		final BoundingBox boundingBox = mesh.calculateBoundingBox();
+	public BulletConstructor (final Model model, final float mass) {
+		final BoundingBox boundingBox = new BoundingBox(); 
+		model.getBoundingBox(boundingBox);
 		final Vector3 dimensions = boundingBox.getDimensions();
-		create(mesh, mass, dimensions.x, dimensions.y, dimensions.z);
+		create(model, mass, dimensions.x, dimensions.y, dimensions.z);
 	}
 	
-	private void create (final Mesh mesh, final float mass, final float width, final float height, final float depth) {			
+	private void create (final Model model, final float mass, final float width, final float height, final float depth) {			
 		// Create a simple boxshape
-		create(mesh, mass, new btBoxShape(Vector3.tmp.set(width * 0.5f, height * 0.5f, depth * 0.5f)));
+		create(model, mass, new btBoxShape(Vector3.tmp.set(width * 0.5f, height * 0.5f, depth * 0.5f)));
 	}
 	
-	private void create(final Mesh mesh, final float mass, final btCollisionShape shape) {
-		this.mesh = mesh;
+	private void create(final Model model, final float mass, final btCollisionShape shape) {
+		this.model = model;
 		this.shape = shape;
 		
 		if (shape != null) {
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletEntity.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletEntity.java
index bdd9ff9..fd31f11 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletEntity.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletEntity.java
@@ -16,6 +16,7 @@
 package com.badlogic.gdx.tests.bullet;
 
 import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.g3d.model.Model;
 import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.physics.bullet.btMotionState;
 import com.badlogic.gdx.physics.bullet.btRigidBody;
@@ -30,12 +31,12 @@ public class BulletEntity extends BaseEntity {
 	public BulletEntity.MotionState motionState;
 	public btRigidBody body;
 
-	public BulletEntity (final Mesh mesh, final btRigidBodyConstructionInfo bodyInfo, final float x, final float y, final float z) {
-		this(mesh, bodyInfo, tmpM.setToTranslation(x, y, z));
+	public BulletEntity (final Model model, final btRigidBodyConstructionInfo bodyInfo, final float x, final float y, final float z) {
+		this(model, bodyInfo, tmpM.setToTranslation(x, y, z));
 	}
 	
-	public BulletEntity (final Mesh mesh, final btRigidBodyConstructionInfo bodyInfo, final Matrix4 transform) {
-		this.mesh = mesh;
+	public BulletEntity (final Model model, final btRigidBodyConstructionInfo bodyInfo, final Matrix4 transform) {
+		this.model = model;
 		this.transform.set(transform);
 		
 		if (bodyInfo != null) {
@@ -46,11 +47,11 @@ public class BulletEntity extends BaseEntity {
 	}
 
 	public BulletEntity (final BulletConstructor constructInfo, final float x, final float y, final float z) {
-		this(constructInfo.mesh, constructInfo.bodyInfo, x, y, z);
+		this(constructInfo.model, constructInfo.bodyInfo, x, y, z);
 	}
 	
 	public BulletEntity (final BulletConstructor constructInfo, final Matrix4 transform) {
-		this(constructInfo.mesh, constructInfo.bodyInfo, transform);
+		this(constructInfo.model, constructInfo.bodyInfo, transform);
 	}
 
 	@Override
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletTest.java
index 63a7911..5c1a2e7 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletTest.java
@@ -19,12 +19,17 @@ package com.badlogic.gdx.tests.bullet;
 import com.badlogic.gdx.ApplicationListener;
 import com.badlogic.gdx.InputProcessor;
 import com.badlogic.gdx.input.GestureDetector.GestureListener;
+import com.badlogic.gdx.math.FloatCounter;
 import com.badlogic.gdx.math.Vector2;
+import com.badlogic.gdx.utils.PerformanceCounter;
 import com.badlogic.gdx.utils.SharedLibraryLoader;
 
 /** @author xoppa */
 public class BulletTest implements ApplicationListener, InputProcessor, GestureListener {
 	public StringBuilder performance = new StringBuilder();
+	public String instructions = "Tap to shoot\nLong press to toggle debug mode\nSwipe for next test";
+	public PerformanceCounter performanceCounter = new PerformanceCounter(this.getClass().getSimpleName());
+	public FloatCounter fpsCounter = new FloatCounter(5);
 	
 	@Override
 	public boolean keyDown (int keycode) {
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletWorld.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletWorld.java
index 37b16dd..ed15e69 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletWorld.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletWorld.java
@@ -31,6 +31,7 @@ import com.badlogic.gdx.physics.bullet.btDynamicsWorld;
 import com.badlogic.gdx.physics.bullet.btIDebugDraw.DebugDrawModes;
 import com.badlogic.gdx.physics.bullet.btRigidBody;
 import com.badlogic.gdx.physics.bullet.btSequentialImpulseConstraintSolver;
+import com.badlogic.gdx.utils.PerformanceCounter;
 
 /** @author xoppa
  * Bullet physics world that holds all bullet entities and constructors.  
@@ -45,11 +46,9 @@ public class BulletWorld extends BaseWorld<BulletEntity> {
 	public final btBroadphaseInterface broadphase;
 	public final btConstraintSolver solver;
 	public final btDynamicsWorld dynamicsWorld;
+	public PerformanceCounter performanceCounter;
 	public final Vector3 gravity;	
 	
-	private WindowedMean mean = new WindowedMean(5);
-	public float bulletTime;
-	public float bulletLoad;
 	public int maxSubSteps = 5;
 	
 	public BulletWorld(final btCollisionConfiguration collisionConfiguration, final btCollisionDispatcher dispatcher,
@@ -92,14 +91,13 @@ public class BulletWorld extends BaseWorld<BulletEntity> {
 	
 	@Override
 	public void update () {
-		final float dt = Gdx.graphics.getDeltaTime();
-		bulletTime = mean.getMean();
-		final float load = dt == 0 ? 0 : bulletTime / dt;
-		bulletLoad = (dt > 1f) ? load : dt * load + (1f - dt) * bulletLoad;
-		
-		final long start = System.nanoTime();
-		dynamicsWorld.stepSimulation(dt, maxSubSteps);
-		mean.addValue((System.nanoTime() - start) / 1000000000.0f);
+		if (performanceCounter != null) {
+		performanceCounter.tick();
+		performanceCounter.start();
+		}
+		dynamicsWorld.stepSimulation(Gdx.graphics.getDeltaTime(), maxSubSteps);
+		if (performanceCounter != null)
+			performanceCounter.stop();
 
 		if (debugDrawer != null && debugDrawer.getDebugMode() > 0) {
 			debugDrawer.begin();
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConstraintsTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConstraintsTest.java
index cb3401b..f438002 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConstraintsTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConstraintsTest.java
@@ -17,9 +17,13 @@
 package com.badlogic.gdx.tests.bullet;
 
 import com.badlogic.gdx.graphics.Color;
+import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.Mesh;
 import com.badlogic.gdx.graphics.VertexAttribute;
 import com.badlogic.gdx.graphics.VertexAttributes.Usage;
+import com.badlogic.gdx.graphics.g3d.materials.Material;
+import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.model.still.StillSubMesh;
 import com.badlogic.gdx.math.Vector3;
 import com.badlogic.gdx.physics.bullet.btPoint2PointConstraint;
 import com.badlogic.gdx.physics.bullet.btTypedConstraint;
@@ -44,7 +48,8 @@ public class ConstraintsTest extends BaseBulletTest {
 			2, 3, 6, 6, 7, 3, // left
 			0, 1, 4, 4, 5, 1 // right
 			});
-		world.addConstructor("bar", new BulletConstructor(barMesh, 0f)); // mass = 0: static body
+		final StillModel barModel = new StillModel(new StillSubMesh("bar", barMesh, GL10.GL_TRIANGLES, new Material()));
+		world.addConstructor("bar", new BulletConstructor(barModel, 0f)); // mass = 0: static body
 		
 		// Create the entities
 		world.add("ground", 0f, 0f, 0f)
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConvexHullTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConvexHullTest.java
index df54ea1..dc3ddd5 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConvexHullTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConvexHullTest.java
@@ -17,10 +17,12 @@
 package com.badlogic.gdx.tests.bullet;
 
 import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.Mesh;
 import com.badlogic.gdx.graphics.g3d.loaders.ModelLoaderRegistry;
 import com.badlogic.gdx.graphics.g3d.loaders.wavefront.ObjLoader;
 import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.model.still.StillSubMesh;
 import com.badlogic.gdx.physics.bullet.btConvexHullShape;
 import com.badlogic.gdx.physics.bullet.btShapeHull;
 
@@ -33,7 +35,7 @@ public class ConvexHullTest extends BaseBulletTest {
 
 		final StillModel sceneModel = ModelLoaderRegistry.loadStillModel(Gdx.files.internal("data/car.obj"));
 		final Mesh sceneMesh = sceneModel.subMeshes[0].getMesh();
-		world.addConstructor("car", new BulletConstructor(sceneMesh, 5f, createConvexHullShape(sceneMesh)));
+		world.addConstructor("car", new BulletConstructor(sceneModel, 5f, createConvexHullShape(sceneMesh)));
 
 		// Create the entities
 		world.add("ground", 0f, 0f, 0f)
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/MeshShapeTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/MeshShapeTest.java
index 7846697..92c26d7 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/MeshShapeTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/MeshShapeTest.java
@@ -16,20 +16,38 @@
 
 package com.badlogic.gdx.tests.bullet;
 
+import java.util.Random;
+
 import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.Input.Keys;
+import com.badlogic.gdx.graphics.Camera;
+import com.badlogic.gdx.graphics.Color;
+import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.Mesh;
-import com.badlogic.gdx.graphics.g3d.ModelLoaderHints;
+import com.badlogic.gdx.graphics.PerspectiveCamera;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.VertexAttribute;
+import com.badlogic.gdx.graphics.VertexAttributes;
+import com.badlogic.gdx.graphics.VertexAttributes.Usage;
+import com.badlogic.gdx.graphics.g2d.BitmapFont;
+import com.badlogic.gdx.graphics.g2d.SpriteBatch;
+import com.badlogic.gdx.graphics.g2d.TextureRegion;
 import com.badlogic.gdx.graphics.g3d.loaders.ModelLoaderRegistry;
 import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
+import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.math.collision.BoundingBox;
 import com.badlogic.gdx.physics.bullet.PHY_ScalarType;
 import com.badlogic.gdx.physics.bullet.btBvhTriangleMeshShape;
 import com.badlogic.gdx.physics.bullet.btCollisionShape;
 import com.badlogic.gdx.physics.bullet.btIndexedMesh;
+import com.badlogic.gdx.physics.bullet.btPoint2PointConstraint;
 import com.badlogic.gdx.physics.bullet.btSphereShape;
 import com.badlogic.gdx.physics.bullet.btStridingMeshInterface;
 import com.badlogic.gdx.physics.bullet.btTriangleIndexVertexArray;
+import com.badlogic.gdx.physics.bullet.btTypedConstraint;
 import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.XmlReader.Element;
 
 /** @author xoppa */
 public class MeshShapeTest extends BaseBulletTest {
@@ -38,27 +56,22 @@ public class MeshShapeTest extends BaseBulletTest {
 	public void create () {
 		super.create();
 		
-
-		final StillModel model = ModelLoaderRegistry.loadStillModel(Gdx.files.internal("data/sphere.obj"));
-		
-		final Mesh sphereMesh = model.subMeshes[0].getMesh();
-		sphereMesh.scale(0.25f, 0.25f, 0.25f);
-
-		final StillModel sceneModel = ModelLoaderRegistry.loadStillModel(Gdx.files.internal("data/scene.obj")); // we need indices for this test 
-		final Mesh sceneMesh = sceneModel.subMeshes[0].getMesh();
-		
-		final BulletConstructor sphereConstructor = new BulletConstructor(sphereMesh, 0.25f, new btSphereShape(sphereMesh.calculateBoundingBox().getDimensions().x * 0.5f));
+		final StillModel sphereModel = ModelLoaderRegistry.loadStillModel(Gdx.files.internal("data/sphere.obj"));
+		sphereModel.subMeshes[0].getMesh().scale(0.25f, 0.25f, 0.25f);
+		final BoundingBox sphereBounds = new BoundingBox();
+		sphereModel.getBoundingBox(sphereBounds);
+	
+		final BulletConstructor sphereConstructor = new BulletConstructor(sphereModel, 0.25f, new btSphereShape(sphereBounds.getDimensions().x * 0.5f));
 		sphereConstructor.bodyInfo.setM_restitution(1f);
 		world.addConstructor("sphere", sphereConstructor);
-		final BulletConstructor sceneConstructor = new BulletConstructor(sceneMesh, 0f, createMeshShape(sceneMesh));
+		
+		final StillModel sceneModel = ModelLoaderRegistry.loadStillModel(Gdx.files.internal("data/scene.obj"));
+		final BulletConstructor sceneConstructor = new BulletConstructor(sceneModel, 0f, new btBvhTriangleMeshShape(true, sceneModel));
 		sceneConstructor.bodyInfo.setM_restitution(0.25f);
 		world.addConstructor("scene", sceneConstructor);
 		
-		BulletEntity scene = world.add("scene", 0f, 2f, 0f);
-		scene.color.set(0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 1f);
-		scene.transform.rotate(Vector3.Y, -90);
-		// Since the transform is changed, it's needed to apply it again.
-		scene.body.setWorldTransform(scene.transform);
+		world.add("scene", (new Matrix4()).setToTranslation(0f, 2f, 0f).rotate(Vector3.Y, -90))
+			.color.set(0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 1f);
 
 		world.add("ground", 0f, 0f, 0f)
 			.color.set(0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 1f);
@@ -81,62 +94,4 @@ public class MeshShapeTest extends BaseBulletTest {
 		shoot(x, y);
 		return true;
 	}
-	
-	// Create a TriangleMeshShape based on a Mesh
-	public static btCollisionShape createMeshShape(Mesh mesh) {
-		btIndexedMesh indexedMesh = new btIndexedMesh();
-		indexedMesh.setM_indexType(PHY_ScalarType.PHY_SHORT);
-		indexedMesh.setM_numTriangles(mesh.getNumIndices()/3);
-		indexedMesh.setM_numVertices(mesh.getNumVertices());
-		indexedMesh.setM_triangleIndexStride(6);
-		indexedMesh.setM_vertexStride(mesh.getVertexSize());
-		indexedMesh.setM_vertexType(PHY_ScalarType.PHY_FLOAT);
-		indexedMesh.setTriangleIndexBase(mesh.getIndicesBuffer());
-		indexedMesh.setVertexBase(mesh.getVerticesBuffer());
-		btTriangleIndexVertexArray meshInterface = new TestTriangleIndexVertexArray();
-		meshInterface.addIndexedMesh(indexedMesh, PHY_ScalarType.PHY_SHORT);
-		return new TestBvhTriangleMeshShape(meshInterface,true);
-	}
-	
-	/** 
-	 * Convenience class that keeps a reference of the sub meshes.
-	 * Don't use this method if the btIndexedMesh instances are shared amongst other btTriangleIndexVertexArray instances.
-	 */
-	public static class TestTriangleIndexVertexArray extends btTriangleIndexVertexArray {
-		Array<btIndexedMesh> meshes = new Array<btIndexedMesh>();
-		
-		@Override
-		public void addIndexedMesh(btIndexedMesh mesh, int indexType) {
-			super.addIndexedMesh(mesh, indexType);
-			meshes.add(mesh);
-		}
-		
-		@Override
-		public synchronized void delete() {
-			super.delete();
-			for (int i = 0; i < meshes.size; i++)
-				meshes.get(i).delete();
-			meshes.clear();
-		}
-	}
-	
-	/** 
-	 * Convenience class that keeps a reference of the mesh interface 
-	 * Don't use this method if the btStridingMeshInterface is shared amongst other btBvhTriangleMeshShape instances. 
-	 */
-	public static class TestBvhTriangleMeshShape extends btBvhTriangleMeshShape {
-		btStridingMeshInterface meshInterface;
-		public TestBvhTriangleMeshShape(btStridingMeshInterface meshInterface, boolean useQuantizedAabbCompression) {
-			super(meshInterface, useQuantizedAabbCompression);
-			this.meshInterface = meshInterface;
-		}
-		
-		@Override
-		public synchronized void delete() {
-			super.delete();
-			if (meshInterface != null)
-				meshInterface.delete();
-			meshInterface = null;
-		}
-	}
 }
\ No newline at end of file
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/RayCastTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/RayCastTest.java
index 9bbc5c7..84b66e6 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/RayCastTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/RayCastTest.java
@@ -45,6 +45,7 @@ public class RayCastTest extends BaseBulletTest {
 	@Override
 	public void create () {
 		super.create();
+		instructions = "Tap a box to ray cast\nLong press to toggle debug mode\nSwipe for next test";
 
 		// Create the entities
 		world.add("ground", -7f, 0f, -7f)
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/RayPickRagdollTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/RayPickRagdollTest.java
index eebfb4d..c9f55c9 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/RayPickRagdollTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/RayPickRagdollTest.java
@@ -16,9 +16,14 @@
 package com.badlogic.gdx.tests.bullet;
 
 import com.badlogic.gdx.Input.Buttons;
+import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.Mesh;
 import com.badlogic.gdx.graphics.VertexAttribute;
 import com.badlogic.gdx.graphics.VertexAttributes.Usage;
+import com.badlogic.gdx.graphics.g3d.materials.Material;
+import com.badlogic.gdx.graphics.g3d.model.Model;
+import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.model.still.StillSubMesh;
 import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.math.Vector3;
@@ -46,17 +51,19 @@ public class RayPickRagdollTest extends BaseBulletTest {
 	@Override
 	public void create () {
 		super.create();
+		instructions = "Tap to shoot\nDrag ragdoll to pick\nLong press to toggle debug mode\nSwipe for next test";
+		
 		camera.position.set(4f, 2f, 4f);
 		camera.lookAt(0f, 1f, 0f);
 		camera.update();
 		
-		world.addConstructor("pelvis", new BulletConstructor(createCapsuleMesh(0.15f, 0.2f), 1f, new btCapsuleShape(0.15f, 0.2f)));
-		world.addConstructor("spine", new BulletConstructor(createCapsuleMesh(0.15f, 0.28f), 1f, new btCapsuleShape(0.15f, 0.28f)));
-		world.addConstructor("head", new BulletConstructor(createCapsuleMesh(0.1f, 0.05f), 1f, new btCapsuleShape(0.1f, 0.05f)));
-		world.addConstructor("upperleg", new BulletConstructor(createCapsuleMesh(0.07f, 0.45f), 1f, new btCapsuleShape(0.07f, 0.45f)));
-		world.addConstructor("lowerleg", new BulletConstructor(createCapsuleMesh(0.05f, 0.37f), 1f, new btCapsuleShape(0.05f, 0.37f)));
-		world.addConstructor("upperarm", new BulletConstructor(createCapsuleMesh(0.05f, 0.33f), 1f, new btCapsuleShape(0.05f, 0.33f)));
-		world.addConstructor("lowerarm", new BulletConstructor(createCapsuleMesh(0.04f, 0.25f), 1f, new btCapsuleShape(0.04f, 0.25f)));
+		world.addConstructor("pelvis", new BulletConstructor(createCapsuleModel(0.15f, 0.2f), 1f, new btCapsuleShape(0.15f, 0.2f)));
+		world.addConstructor("spine", new BulletConstructor(createCapsuleModel(0.15f, 0.28f), 1f, new btCapsuleShape(0.15f, 0.28f)));
+		world.addConstructor("head", new BulletConstructor(createCapsuleModel(0.1f, 0.05f), 1f, new btCapsuleShape(0.1f, 0.05f)));
+		world.addConstructor("upperleg", new BulletConstructor(createCapsuleModel(0.07f, 0.45f), 1f, new btCapsuleShape(0.07f, 0.45f)));
+		world.addConstructor("lowerleg", new BulletConstructor(createCapsuleModel(0.05f, 0.37f), 1f, new btCapsuleShape(0.05f, 0.37f)));
+		world.addConstructor("upperarm", new BulletConstructor(createCapsuleModel(0.05f, 0.33f), 1f, new btCapsuleShape(0.05f, 0.33f)));
+		world.addConstructor("lowerarm", new BulletConstructor(createCapsuleModel(0.04f, 0.25f), 1f, new btCapsuleShape(0.04f, 0.25f)));
 		
 		world.add("ground", 0f, 0f, 0f)
 			.color.set(0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 1f);
@@ -241,18 +248,18 @@ public class RayPickRagdollTest extends BaseBulletTest {
 		world.dynamicsWorld.addConstraint(hingeC, true);
 	}
 	
-	protected Mesh createCapsuleMesh(float radius, float height) {
+	protected Model createCapsuleModel(float radius, float height) {
 		final float hh = radius + 0.5f * height;
-		final Mesh result = new Mesh(true, 8, 36, new VertexAttribute(Usage.Position, 3, "a_position"));
-		result.setVertices(new float[] {radius, hh, radius, radius, hh, -radius, -radius, hh, radius, -radius, hh, -radius,
+		final Mesh mesh = new Mesh(true, 8, 36, new VertexAttribute(Usage.Position, 3, "a_position"));
+		mesh.setVertices(new float[] {radius, hh, radius, radius, hh, -radius, -radius, hh, radius, -radius, hh, -radius,
 			radius, -hh, radius, radius, -hh, -radius, -radius, -hh, radius, -radius, -hh, -radius});
-		result.setIndices(new short[] {0, 1, 2, 1, 2, 3, // top
+		mesh.setIndices(new short[] {0, 1, 2, 1, 2, 3, // top
 			4, 5, 6, 5, 6, 7, // bottom
 			0, 2, 4, 4, 6, 2, // front
 			1, 3, 5, 5, 7, 3, // back
 			2, 3, 6, 6, 7, 3, // left
 			0, 1, 4, 4, 5, 1 // right
 			});
-		return result;
+		return new StillModel(new StillSubMesh("capsule", mesh, GL10.GL_TRIANGLES, new Material()));
 	}
 }
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/SoftMeshTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/SoftMeshTest.java
index 375933e..33b8984 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/SoftMeshTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/SoftMeshTest.java
@@ -70,13 +70,12 @@ public class SoftMeshTest extends BaseBulletTest {
 		.color.set(0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 0.25f + 0.5f * (float)Math.random(), 1f);
 		
 		// Note: not every model is suitable for a one on one translation with a soft body, a better model might be added later.
-		
 		final StillModel model = ModelLoaderRegistry.loadStillModel(Gdx.files.internal("data/wheel.obj"));
-		mesh = model.subMeshes[0].getMesh();
+		mesh = model.subMeshes[0].getMesh().copy(false, true, new int[] {Usage.Position});
 		mesh.scale(6f, 6f, 6f);
-		
+
 		softBody = new btSoftBody(worldInfo, mesh.getVerticesBuffer(), mesh.getNumVertices(), mesh.getVertexSize(), mesh.getVertexAttribute(Usage.Position).offset, mesh.getIndicesBuffer(), mesh.getNumIndices()/3);
-		// Set mass of 1 one to zero so its unmovable, comment out this line to make it a full dynamic body.
+		// Set mass of the first vertex to zero so its unmovable, comment out this line to make it a full dynamic body.
 		softBody.setMass(0, 0);
 		Material pm = softBody.appendMaterial();
 		pm.setM_kLST(0.2f);
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/JsonModelLoaderTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/JsonModelLoaderTest.java
deleted file mode 100755
index d98ad1c..0000000
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/JsonModelLoaderTest.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package com.badlogic.gdx.tests.g3d;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.graphics.g3d.loaders.json.JsonModelLoader;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
-import com.badlogic.gdx.tests.utils.GdxTest;
-
-public class JsonModelLoaderTest extends GdxTest {
-
-	@Override
-	public void create () {
-		JsonModelLoader loader = new JsonModelLoader();
-		loader.load(Gdx.files.internal("data/g3d/test.g3dj"), null);
-	}
-
-	@Override
-	public void render () {
-		
-	}
-}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
index 2362e9a..6f7d5e1 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
@@ -36,7 +36,6 @@ import java.util.List;
 import com.badlogic.gdx.tests.*;
 import com.badlogic.gdx.tests.examples.MoveSpriteExample;
 import com.badlogic.gdx.tests.extensions.GLEEDTest;
-import com.badlogic.gdx.tests.g3d.JsonModelLoaderTest;
 import com.badlogic.gdx.tests.gles2.HelloTriangle;
 import com.badlogic.gdx.tests.gles2.SimpleVertexShader;
 
@@ -75,7 +74,7 @@ public class GdxTests {
 		// InternationalFontsTest.class, VorbisTest.class
 		TextButtonTest.class, TextButtonTestGL2.class, TextureBindTest.class, SortedSpriteTest.class,
 		ExternalMusicTest.class, SoftKeyboardTest.class, DirtyRenderingTest.class, YDownTest.class,
-		ScreenCaptureTest.class, BitmapFontTest.class, LabelScaleTest.class, GLEEDTest.class, JsonModelLoaderTest.class));
+		ScreenCaptureTest.class, BitmapFontTest.class, LabelScaleTest.class, GLEEDTest.class));
 	
 	public static List<String> getNames () {
 		List<String> names = new ArrayList<String>(tests.size());
