diff --git a/.gitignore b/.gitignore
index 8f72d31..6302018 100644
--- a/.gitignore
+++ b/.gitignore
@@ -35,6 +35,7 @@ libgdx-*.zip
 
 #core & extension libs/ folders that have no 3rd party dependencies in them
 /gdx/libs
+/backends/gdx-backend-jglfw/libs/
 /extensions/gdx-audio/libs/
 /extensions/gdx-bullet/libs/
 /extensions/gdx-controllers/gdx-controllers-desktop/libs/
diff --git a/CHANGES b/CHANGES
new file mode 100644
index 0000000..12125eb
--- /dev/null
+++ b/CHANGES
@@ -0,0 +1,20 @@
+[0.9.9]
+- TmxMapLoader has a flag in Parameters that lets you specify whether to generate mipmaps
+- Animation#isAnimationFinished was fixed to behave as per javadocs (ignores looping)
+- remove GLU interface and implementations. Use Matrix4 et al instead. see http://www.badlogicgames.com/wordpress/?p=2886
+- new maps API, see http://www.badlogicgames.com/wordpress/?p=2870
+- removed static public tmp Vector2 instances, manage such temporary vars yourself, see http://www.badlogicgames.com/wordpress/?p=2840
+- changed Scene2D Group#clear(), see http://www.badlogicgames.com/wordpress/?p=2837
+- changed the build system, natives are now fetched from the build server, see http://www.badlogicgames.com/wordpress/?p=2821
+- freetype extension supported on iOS, see http://www.badlogicgames.com/wordpress/?p=2819
+- changed ShapeRenderer API, see http://www.badlogicgames.com/wordpress/?p=2809
+- changed Actions.add to addAction, changed parameter order, and added removeAction, addListener, removeListener
+
+[0.9.8]
+- see http://www.badlogicgames.com/wordpress/?p=2664
+
+[0.9.7]
+- see http://www.badlogicgames.com/wordpress/?p=2664
+
+[0.9.6]
+- see http://www.badlogicgames.com/wordpress/?p=2513
diff --git a/README.md b/README.md
index 6936540..9958785 100644
--- a/README.md
+++ b/README.md
@@ -4,6 +4,7 @@ Libgdx is a cross-platform Java game development framework based on
 OpenGL (ES) that works on Windows, Linux, Mac OS X, Android, your
 WebGL enabled browser and iOS.
 
+#### Learn [how to contribute][B]
 #### The [Libgdx Official Site][1] hosts downloads, documentation and contains useful links
 #### The [community-maintained wiki][4] hosted at Google Code will explain much of Libgdx
 #### Use the [Badlogic Forum][5] to ask questions about Libgdx
@@ -50,4 +51,5 @@ Once again, if you get stuck just drop in to the friendly [forums][5].
  [7]: http://code.google.com/p/libgdx/wiki/Prerequisits
  [8]: http://code.google.com/p/libgdx/wiki/SourceRunningDemos
  [9]: http://code.google.com/p/libgdx/wiki/SourceBuilding
- [A]: http://libgdx.badlogicgames.com/download.html
\ No newline at end of file
+ [A]: http://libgdx.badlogicgames.com/download.html
+ [B]: https://code.google.com/p/libgdx/wiki/Contributing?ts=1363359071&updated=Contributing
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidDaydream.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidDaydream.java
index 1a9581b..256bfda 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidDaydream.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidDaydream.java
@@ -51,7 +51,7 @@ import com.badlogic.gdx.utils.Clipboard;
 import com.badlogic.gdx.utils.GdxNativesLoader;
 
 /** An implementation of the {@link Application} interface for Android. Create an {@link Activity} that derives from this class. In
- * the {@link Activity#onCreate(Bundle)} method call the {@link #initialize(ApplicationListener, boolean)} method specifying the
+ * the Activity#onCreate(Bundle) method call the {@link #initialize(ApplicationListener, boolean)} method specifying the
  * configuration for the GLSurfaceView.
  * 
  * @author mzechner */
@@ -74,11 +74,11 @@ public class AndroidDaydream extends DreamService implements Application {
 	protected WakeLock wakeLock = null;
 	protected int logLevel = LOG_INFO;
 
-	/** This method has to be called in the {@link Activity#onCreate(Bundle)} method. It sets up all the things necessary to get
-	 * input, render via OpenGL and so on. If useGL20IfAvailable is set the AndroidApplication will try to create an OpenGL ES 2.0
-	 * context which can then be used via {@link Graphics#getGL20()}. The {@link GL10} and {@link GL11} interfaces should not be
-	 * used when OpenGL ES 2.0 is enabled. To query whether enabling OpenGL ES 2.0 was successful use the
-	 * {@link Graphics#isGL20Available()} method. Uses a default {@link AndroidApplicationConfiguration}.
+	/** This method has to be called in the Activity#onCreate(Bundle) method. It sets up all the things necessary to get input,
+	 * render via OpenGL and so on. If useGL20IfAvailable is set the AndroidApplication will try to create an OpenGL ES 2.0 context
+	 * which can then be used via {@link Graphics#getGL20()}. The {@link GL10} and {@link GL11} interfaces should not be used when
+	 * OpenGL ES 2.0 is enabled. To query whether enabling OpenGL ES 2.0 was successful use the {@link Graphics#isGL20Available()}
+	 * method. Uses a default {@link AndroidApplicationConfiguration}.
 	 * 
 	 * @param listener the {@link ApplicationListener} implementing the program logic
 	 * @param useGL2IfAvailable whether to use OpenGL ES 2.0 if its available. */
@@ -88,12 +88,12 @@ public class AndroidDaydream extends DreamService implements Application {
 		initialize(listener, config);
 	}
 
-	/** This method has to be called in the {@link Activity#onCreate(Bundle)} method. It sets up all the things necessary to get
-	 * input, render via OpenGL and so on. If config.useGL20 is set the AndroidApplication will try to create an OpenGL ES 2.0
-	 * context which can then be used via {@link Graphics#getGL20()}. The {@link GL10} and {@link GL11} interfaces should not be
-	 * used when OpenGL ES 2.0 is enabled. To query whether enabling OpenGL ES 2.0 was successful use the
-	 * {@link Graphics#isGL20Available()} method. You can configure other aspects of the application with the rest of the fields in
-	 * the {@link AndroidApplicationConfiguration} instance.
+	/** This method has to be called in the Activity#onCreate(Bundle) method. It sets up all the things necessary to get input,
+	 * render via OpenGL and so on. If config.useGL20 is set the AndroidApplication will try to create an OpenGL ES 2.0 context
+	 * which can then be used via {@link Graphics#getGL20()}. The {@link GL10} and {@link GL11} interfaces should not be used when
+	 * OpenGL ES 2.0 is enabled. To query whether enabling OpenGL ES 2.0 was successful use the {@link Graphics#isGL20Available()}
+	 * method. You can configure other aspects of the application with the rest of the fields in the
+	 * {@link AndroidApplicationConfiguration} instance.
 	 * 
 	 * @param listener the {@link ApplicationListener} implementing the program logic
 	 * @param config the {@link AndroidApplicationConfiguration}, defining various settings of the application (use accelerometer,
@@ -104,7 +104,7 @@ public class AndroidDaydream extends DreamService implements Application {
 		input = AndroidInputFactory.newAndroidInput(this, this, graphics.view, config);
 		audio = new AndroidAudio(this, config);
 		files = new AndroidFiles(this.getAssets(), this.getFilesDir().getAbsolutePath());
-//		net = new AndroidNet(this);
+		net = new AndroidNet(null);
 		this.listener = listener;
 		this.handler = new Handler();
 
@@ -116,7 +116,7 @@ public class AndroidDaydream extends DreamService implements Application {
 		Gdx.net = this.getNet();
 
 		setFullscreen(true);
-		
+
 		setContentView(graphics.getView(), createLayoutParams());
 		createWakeLock(config);
 		hideStatusBar(config);
@@ -137,8 +137,7 @@ public class AndroidDaydream extends DreamService implements Application {
 	}
 
 	protected void hideStatusBar (AndroidApplicationConfiguration config) {
-		if (!config.hideStatusBar || getVersion() < 11)
-			return;
+		if (!config.hideStatusBar || getVersion() < 11) return;
 
 		View rootView = getWindow().getDecorView();
 
@@ -151,11 +150,11 @@ public class AndroidDaydream extends DreamService implements Application {
 		}
 	}
 
-	/** This method has to be called in the {@link Activity#onCreate(Bundle)} method. It sets up all the things necessary to get
-	 * input, render via OpenGL and so on. If useGL20IfAvailable is set the AndroidApplication will try to create an OpenGL ES 2.0
-	 * context which can then be used via {@link Graphics#getGL20()}. The {@link GL10} and {@link GL11} interfaces should not be
-	 * used when OpenGL ES 2.0 is enabled. To query whether enabling OpenGL ES 2.0 was successful use the
-	 * {@link Graphics#isGL20Available()} method. Uses a default {@link AndroidApplicationConfiguration}.
+	/** This method has to be called in the Activity#onCreate(Bundle) method. It sets up all the things necessary to get input,
+	 * render via OpenGL and so on. If useGL20IfAvailable is set the AndroidApplication will try to create an OpenGL ES 2.0 context
+	 * which can then be used via {@link Graphics#getGL20()}. The {@link GL10} and {@link GL11} interfaces should not be used when
+	 * OpenGL ES 2.0 is enabled. To query whether enabling OpenGL ES 2.0 was successful use the {@link Graphics#isGL20Available()}
+	 * method. Uses a default {@link AndroidApplicationConfiguration}.
 	 * <p/>
 	 * Note: you have to add the returned view to your layout!
 	 * 
@@ -168,12 +167,12 @@ public class AndroidDaydream extends DreamService implements Application {
 		return initializeForView(listener, config);
 	}
 
-	/** This method has to be called in the {@link Activity#onCreate(Bundle)} method. It sets up all the things necessary to get
-	 * input, render via OpenGL and so on. If config.useGL20 is set the AndroidApplication will try to create an OpenGL ES 2.0
-	 * context which can then be used via {@link Graphics#getGL20()}. The {@link GL10} and {@link GL11} interfaces should not be
-	 * used when OpenGL ES 2.0 is enabled. To query whether enabling OpenGL ES 2.0 was successful use the
-	 * {@link Graphics#isGL20Available()} method. You can configure other aspects of the application with the rest of the fields in
-	 * the {@link AndroidApplicationConfiguration} instance.
+	/** This method has to be called in the Activity#onCreate(Bundle) method. It sets up all the things necessary to get input,
+	 * render via OpenGL and so on. If config.useGL20 is set the AndroidApplication will try to create an OpenGL ES 2.0 context
+	 * which can then be used via {@link Graphics#getGL20()}. The {@link GL10} and {@link GL11} interfaces should not be used when
+	 * OpenGL ES 2.0 is enabled. To query whether enabling OpenGL ES 2.0 was successful use the {@link Graphics#isGL20Available()}
+	 * method. You can configure other aspects of the application with the rest of the fields in the
+	 * {@link AndroidApplicationConfiguration} instance.
 	 * <p/>
 	 * Note: you have to add the returned view to your layout!
 	 * 
@@ -187,7 +186,7 @@ public class AndroidDaydream extends DreamService implements Application {
 		input = AndroidInputFactory.newAndroidInput(this, this, graphics.view, config);
 		audio = new AndroidAudio(this, config);
 		files = new AndroidFiles(this.getAssets(), this.getFilesDir().getAbsolutePath());
-//		net = new AndroidNet(this);
+		net = new AndroidNet(null);
 		this.listener = listener;
 		this.handler = new Handler();
 
@@ -253,10 +252,10 @@ public class AndroidDaydream extends DreamService implements Application {
 	}
 
 	@Override
-	public void onDetachedFromWindow() {
+	public void onDetachedFromWindow () {
 		super.onDetachedFromWindow();
 	}
-	
+
 	@Override
 	public ApplicationListener getApplicationListener () {
 		return listener;
@@ -281,7 +280,7 @@ public class AndroidDaydream extends DreamService implements Application {
 	public Input getInput () {
 		return input;
 	}
-	
+
 	@Override
 	public Net getNet () {
 		return net;
@@ -313,15 +312,15 @@ public class AndroidDaydream extends DreamService implements Application {
 	}
 
 	AndroidClipboard clipboard;
-	
+
 	@Override
-	public Clipboard getClipboard() {
+	public Clipboard getClipboard () {
 		if (clipboard == null) {
 			clipboard = new AndroidClipboard(this);
 		}
 		return clipboard;
 	}
-	
+
 	@Override
 	public void postRunnable (Runnable runnable) {
 		synchronized (runnables) {
@@ -386,18 +385,18 @@ public class AndroidDaydream extends DreamService implements Application {
 	public void setLogLevel (int logLevel) {
 		this.logLevel = logLevel;
 	}
-	
+
 	@Override
 	public void addLifecycleListener (LifecycleListener listener) {
-		synchronized(lifecycleListeners) {
+		synchronized (lifecycleListeners) {
 			lifecycleListeners.add(listener);
 		}
 	}
 
 	@Override
 	public void removeLifecycleListener (LifecycleListener listener) {
-		synchronized(lifecycleListeners) {
+		synchronized (lifecycleListeners) {
 			lifecycleListeners.removeValue(listener, true);
-		}		
+		}
 	}
-}
\ No newline at end of file
+}
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGLU.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGLU.java
deleted file mode 100644
index bea7c5f..0000000
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGLU.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.backends.android;
-
-import com.badlogic.gdx.graphics.GL10;
-import com.badlogic.gdx.graphics.GLU;
-
-public class AndroidGLU implements GLU {
-
-	@Override
-	public void gluLookAt (GL10 gl, float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX,
-		float upY, float upZ) {
-		android.opengl.GLU.gluLookAt(((AndroidGL10)gl).gl, eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ);
-	}
-
-	@Override
-	public void gluOrtho2D (GL10 gl, float left, float right, float bottom, float top) {
-		android.opengl.GLU.gluOrtho2D(((AndroidGL10)gl).gl, left, right, bottom, top);
-	}
-
-	@Override
-	public void gluPerspective (GL10 gl, float fovy, float aspect, float zNear, float zFar) {
-		android.opengl.GLU.gluPerspective(((AndroidGL10)gl).gl, fovy, aspect, zNear, zFar);
-	}
-
-	@Override
-	public boolean gluProject (float objX, float objY, float objZ, float[] model, int modelOffset, float[] project,
-		int projectOffset, int[] view, int viewOffset, float[] win, int winOffset) {
-		int result = android.opengl.GLU.gluProject(objX, objY, objZ, model, modelOffset, project, projectOffset, view, viewOffset,
-			win, winOffset);
-		return result == GL10.GL_TRUE;
-	}
-
-	@Override
-	public boolean gluUnProject (float winX, float winY, float winZ, float[] model, int modelOffset, float[] project,
-		int projectOffset, int[] view, int viewOffset, float[] obj, int objOffset) {
-		int result = android.opengl.GLU.gluUnProject(winX, winY, winZ, model, modelOffset, project, projectOffset, view,
-			viewOffset, obj, objOffset);
-		return result == GL10.GL_TRUE;
-	}
-
-}
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphics.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphics.java
index 943a4fa..87be2ac 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphics.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphics.java
@@ -16,19 +16,11 @@
 
 package com.badlogic.gdx.backends.android;
 
-import java.lang.reflect.Method;
-
-import javax.microedition.khronos.egl.EGL10;
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.egl.EGLContext;
-import javax.microedition.khronos.egl.EGLDisplay;
-
 import android.app.Activity;
 import android.opengl.GLSurfaceView;
 import android.opengl.GLSurfaceView.EGLConfigChooser;
 import android.opengl.GLSurfaceView.Renderer;
 import android.os.SystemClock;
-import android.text.InputType;
 import android.util.DisplayMetrics;
 import android.view.Display;
 import android.view.KeyCharacterMap;
@@ -49,7 +41,6 @@ import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.GL11;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.GLCommon;
-import com.badlogic.gdx.graphics.GLU;
 import com.badlogic.gdx.graphics.Mesh;
 import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.graphics.glutils.FrameBuffer;
@@ -57,6 +48,13 @@ import com.badlogic.gdx.graphics.glutils.ShaderProgram;
 import com.badlogic.gdx.math.WindowedMean;
 import com.badlogic.gdx.utils.Array;
 
+import java.lang.reflect.Method;
+
+import javax.microedition.khronos.egl.EGL10;
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.egl.EGLContext;
+import javax.microedition.khronos.egl.EGLDisplay;
+
 /** An implementation of {@link Graphics} for Android.
  * 
  * @author mzechner */
@@ -69,7 +67,6 @@ public final class AndroidGraphics implements Graphics, Renderer {
 	GL10 gl10;
 	GL11 gl11;
 	GL20 gl20;
-	GLU glu;
 	EGLContext eglContext;
 	String extensions;
 
@@ -304,13 +301,10 @@ public final class AndroidGraphics implements Graphics, Renderer {
 			}
 		}
 
-		this.glu = new AndroidGLU();
-
 		Gdx.gl = this.gl;
 		Gdx.gl10 = gl10;
 		Gdx.gl11 = gl11;
 		Gdx.gl20 = gl20;
-		Gdx.glu = glu;
 
 		Gdx.app.log("AndroidGraphics", "OGL renderer: " + gl.glGetString(GL10.GL_RENDERER));
 		Gdx.app.log("AndroidGraphics", "OGL vendor: " + gl.glGetString(GL10.GL_VENDOR));
@@ -597,11 +591,6 @@ public final class AndroidGraphics implements Graphics, Renderer {
 	}
 
 	@Override
-	public GLU getGLU () {
-		return glu;
-	}
-
-	@Override
 	public boolean supportsDisplayModeChange () {
 		return false;
 	}
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphicsDaydream.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphicsDaydream.java
index 3df8bd8..0fb8316 100644
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphicsDaydream.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphicsDaydream.java
@@ -57,7 +57,6 @@ import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.GL11;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.GLCommon;
-import com.badlogic.gdx.graphics.GLU;
 import com.badlogic.gdx.graphics.Mesh;
 import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.graphics.glutils.FrameBuffer;
@@ -77,7 +76,6 @@ public final class AndroidGraphicsDaydream implements Graphics, Renderer {
 	GL10 gl10;
 	GL11 gl11;
 	GL20 gl20;
-	GLU glu;
 	EGLContext eglContext;
 	String extensions;
 
@@ -283,13 +281,10 @@ public final class AndroidGraphicsDaydream implements Graphics, Renderer {
 			}
 		}
 
-		this.glu = new AndroidGLU();
-
 		Gdx.gl = this.gl;
 		Gdx.gl10 = gl10;
 		Gdx.gl11 = gl11;
 		Gdx.gl20 = gl20;
-		Gdx.glu = glu;
 
 		Gdx.app.log("AndroidGraphics", "OGL renderer: " + gl.glGetString(GL10.GL_RENDERER));
 		Gdx.app.log("AndroidGraphics", "OGL vendor: " + gl.glGetString(GL10.GL_VENDOR));
@@ -576,11 +571,6 @@ public final class AndroidGraphicsDaydream implements Graphics, Renderer {
 	}
 
 	@Override
-	public GLU getGLU () {
-		return glu;
-	}
-
-	@Override
 	public boolean supportsDisplayModeChange () {
 		return false;
 	}
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphicsLiveWallpaper.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphicsLiveWallpaper.java
index 923bfe7..134cdd7 100755
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphicsLiveWallpaper.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidGraphicsLiveWallpaper.java
@@ -45,7 +45,6 @@ import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.GL11;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.GLCommon;
-import com.badlogic.gdx.graphics.GLU;
 import com.badlogic.gdx.graphics.Mesh;
 import com.badlogic.gdx.graphics.Pixmap;
 import com.badlogic.gdx.graphics.Texture;
@@ -70,7 +69,6 @@ public final class AndroidGraphicsLiveWallpaper implements Graphics, Renderer {
 	protected GL10 gl10;
 	protected GL11 gl11;
 	protected GL20 gl20;
-	protected GLU glu;
 	protected EGLContext eglContext;
 	protected String extensions;
 
@@ -415,13 +413,10 @@ public final class AndroidGraphicsLiveWallpaper implements Graphics, Renderer {
 			}
 		}
 
-		this.glu = new AndroidGLU();
-
 		Gdx.gl = this.gl;
 		Gdx.gl10 = gl10;
 		Gdx.gl11 = gl11;
 		Gdx.gl20 = gl20;
-		Gdx.glu = glu;
 
 		Gdx.app.log("AndroidGraphics", "OGL renderer: " + gl.glGetString(GL10.GL_RENDERER));
 		Gdx.app.log("AndroidGraphics", "OGL vendor: " + gl.glGetString(GL10.GL_VENDOR));
@@ -600,11 +595,6 @@ public final class AndroidGraphicsLiveWallpaper implements Graphics, Renderer {
 	}
 
 	@Override
-	public GLU getGLU () {
-		return glu;
-	}
-
-	@Override
 	public float getDensity () {
 		return density;
 	}
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidLiveWallpaper.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidLiveWallpaper.java
index 40d0892..3db7ea8 100755
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidLiveWallpaper.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidLiveWallpaper.java
@@ -86,12 +86,14 @@ class AndroidLiveWallpaper implements Application {
 		input = AndroidInputFactory.newAndroidInput(this, this.getService(), null, config);
 		audio = new AndroidAudio(this.getService(), config);
 		files = new AndroidFiles(this.getService().getAssets(), this.getService().getFilesDir().getAbsolutePath());
+		net = new AndroidNet(null);
 		this.listener = listener;
 		
 		Gdx.app = this;
 		Gdx.input = this.getInput();
 		Gdx.audio = this.getAudio();
 		Gdx.files = this.getFiles();
+		Gdx.net = this.getNet();
 		Gdx.graphics = this.getGraphics();
 	}
 
@@ -106,6 +108,7 @@ class AndroidLiveWallpaper implements Application {
 		Gdx.input = this.getInput();
 		Gdx.audio = this.getAudio();
 		Gdx.files = this.getFiles();
+		Gdx.net = this.getNet();
 		Gdx.graphics = this.getGraphics();
 
 		((AndroidInput)getInput()).registerSensorListeners();
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidNet.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidNet.java
index 1c7a261..953e2e3 100755
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidNet.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/AndroidNet.java
@@ -62,7 +62,7 @@ import com.badlogic.gdx.utils.JsonWriter;
  * @author acoppes */
 public class AndroidNet implements Net {
 
-	// IMPORTANT: The Gdx.net classes are a currently duplicated for LWJGL + Android!
+	// IMPORTANT: The Gdx.net classes are a currently duplicated for JGLFW/LWJGL + Android!
 	// If you make changes here, make changes in the other backend as well.
 	final AndroidApplication app;
 	NetJavaImpl netJavaImpl;
@@ -89,6 +89,10 @@ public class AndroidNet implements Net {
 
 	@Override
 	public void openURI (String URI) {
+		if(app == null) {
+			Gdx.app.log("AndroidNet", "Can't open browser activity from livewallpaper");
+			return;
+		}
 		final Uri uri = Uri.parse(URI);
 		app.runOnUiThread(new Runnable() {
 			@Override
diff --git a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/surfaceview/GLBaseSurfaceViewLW.java b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/surfaceview/GLBaseSurfaceViewLW.java
index a64187d..0d8c549 100755
--- a/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/surfaceview/GLBaseSurfaceViewLW.java
+++ b/backends/gdx-backend-android/src/com/badlogic/gdx/backends/android/surfaceview/GLBaseSurfaceViewLW.java
@@ -506,7 +506,7 @@ public class GLBaseSurfaceViewLW
 	 * An interface for customizing the eglCreateContext and eglDestroyContext calls.
 	 * <p>
 	 * This interface must be implemented by clients wishing to call
-	 * {@link GLBaseSurfaceViewLW#setEGLContextFactory(EGLContextFactory)}
+	 * GLBaseSurfaceViewLW#setEGLContextFactory(EGLContextFactory)
 	 */
 	public interface EGLContextFactory {
 		EGLContext createContext (EGL10 egl, EGLDisplay display, EGLConfig eglConfig);
@@ -529,7 +529,7 @@ public class GLBaseSurfaceViewLW
 	 * An interface for customizing the eglCreateWindowSurface and eglDestroySurface calls.
 	 * <p>
 	 * This interface must be implemented by clients wishing to call
-	 * {@link GLBaseSurfaceViewLW#setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory)}
+	 * GLBaseSurfaceViewLW#setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory)
 	 */
 	public interface EGLWindowSurfaceFactory {
 		EGLSurface createWindowSurface (EGL10 egl, EGLDisplay display, EGLConfig config, Object nativeWindow);
diff --git a/backends/gdx-backend-iosmonotouch/libs/objectal/libObjectAL.dll b/backends/gdx-backend-iosmonotouch/libs/objectal/libObjectAL.dll
index 54bf846..6a646bd 100755
Binary files a/backends/gdx-backend-iosmonotouch/libs/objectal/libObjectAL.dll and b/backends/gdx-backend-iosmonotouch/libs/objectal/libObjectAL.dll differ
diff --git a/backends/gdx-backend-iosmonotouch/libs/objectal/libObjectAL.jar b/backends/gdx-backend-iosmonotouch/libs/objectal/libObjectAL.jar
index 17f8b98..d43654c 100644
Binary files a/backends/gdx-backend-iosmonotouch/libs/objectal/libObjectAL.jar and b/backends/gdx-backend-iosmonotouch/libs/objectal/libObjectAL.jar differ
diff --git a/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSGraphics.java b/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSGraphics.java
index 58e3817..e5bb872 100644
--- a/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSGraphics.java
+++ b/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSGraphics.java
@@ -39,7 +39,6 @@ import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.GL11;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.GLCommon;
-import com.badlogic.gdx.graphics.GLU;
 import com.badlogic.gdx.graphics.Pixmap;
 import com.badlogic.gdx.utils.Array;
 
@@ -238,12 +237,6 @@ public class IOSGraphics extends iPhoneOSGameView implements Graphics {
 	}
 
 	@Override
-	public GLU getGLU () {
-		// FIXME implement this
-		return null;
-	}
-
-	@Override
 	public int getWidth () {
 		return width;
 	}
diff --git a/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSInput.java b/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSInput.java
index 28725ef..ee96f4a 100644
--- a/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSInput.java
+++ b/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSInput.java
@@ -417,14 +417,14 @@ public class IOSInput implements Input {
 		}
 	});
 	
-	private int getFreePointer() {
+	int getFreePointer() {
 		for(int i = 0; i < touchDown.length; i++) {
 			if(touchDown[i] == 0) return i;
 		}
 		throw new GdxRuntimeException("Couldn't find free pointer id!");
 	}
 	
-	private int findPointer(UITouch touch) {
+	int findPointer(UITouch touch) {
 		int ptr = touch.get_Handle().ToInt32();
 		for(int i = 0; i < touchDown.length; i++) {
 			if(touchDown[i] == ptr) return i;
diff --git a/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSNet.java b/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSNet.java
index 8098edd..ba2f71e 100755
--- a/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSNet.java
+++ b/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSNet.java
@@ -19,33 +19,24 @@ package com.badlogic.gdx.backends.ios;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.net.URL;
 import java.util.Map;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 
-import sun.awt.SunToolkit.InfiniteLoop;
-
 import cli.MonoTouch.Foundation.NSUrl;
 import cli.MonoTouch.UIKit.UIApplication;
-import cli.System.Uri;
 import cli.System.IO.Stream;
 import cli.System.IO.StreamReader;
-import cli.System.IO.StreamWriter;
 import cli.System.Net.HttpWebRequest;
 import cli.System.Net.HttpWebResponse;
 import cli.System.Net.WebHeaderCollection;
 import cli.System.Net.WebRequest;
-import cli.System.Net.WebResponse;
-import cli.System.Text.Encoding;
-import cli.System.Text.UTF8Encoding;
 
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.Net;
 import com.badlogic.gdx.StreamUtils;
-import com.badlogic.gdx.Net.HttpMethods;
-import com.badlogic.gdx.Net.HttpStatus;
+import com.badlogic.gdx.net.HttpStatus;
 import com.badlogic.gdx.net.ServerSocket;
 import com.badlogic.gdx.net.ServerSocketHints;
 import com.badlogic.gdx.net.Socket;
@@ -160,16 +151,24 @@ public class IOSNet implements Net {
 					httpWebRequest.set_Headers(webHeaderCollection);
 
 					if (method.equalsIgnoreCase(HttpMethods.POST)) {
-						Stream stream = httpWebRequest.GetRequestStream();
-
 						InputStream contentAsStream = httpRequest.getContentStream();
 						String contentAsString = httpRequest.getContent();
 
 						if (contentAsStream != null) {
+							httpWebRequest.set_ContentLength(contentAsStream.available());
+							
+							Stream stream = httpWebRequest.GetRequestStream();
 							StreamUtils.copyStream(contentAsStream, new OutputStreamNetStreamImpl(stream));
+							stream.Close();
 						} else if (contentAsString != null) {
-							new StreamWriter(stream).Write(contentAsString);
+							byte[] data = contentAsString.getBytes();
+							httpWebRequest.set_ContentLength(data.length);
+							
+							Stream stream = httpWebRequest.GetRequestStream();
+							stream.Write(data, 0, data.length);
+							stream.Close();
 						}
+						
 					}
 
 					final HttpWebResponse httpWebResponse = (HttpWebResponse)httpWebRequest.GetResponse();
diff --git a/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSSound.java b/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSSound.java
index 236b5f9..de00d22 100644
--- a/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSSound.java
+++ b/backends/gdx-backend-iosmonotouch/src/com/badlogic/gdx/backends/ios/IOSSound.java
@@ -48,7 +48,7 @@ public class IOSSound implements Sound {
 	private int playerIndex;
 	
 	// one single thread will play sounds outside the rendering low (otherwise our FPS drops!)
-	private static class PlayThread extends Thread {
+	static class PlayThread extends Thread {
 		@Override
 		public void run () {
 			Gdx.app.debug("IOSSound", "Sound player is running.");
@@ -67,7 +67,7 @@ public class IOSSound implements Sound {
 	}
 	private static PlayThread playThread = null;
 	private static int soundCounter = 0;
-	private static final LinkedBlockingQueue<AVAudioPlayer> playQueue = new LinkedBlockingQueue<AVAudioPlayer>();
+	static final LinkedBlockingQueue<AVAudioPlayer> playQueue = new LinkedBlockingQueue<AVAudioPlayer>();
 	
 	/**
 	 * Creates a new sound object. We are creating several AVAudioPlayer objects to
diff --git a/backends/gdx-backend-jglfw/.classpath b/backends/gdx-backend-jglfw/.classpath
new file mode 100644
index 0000000..f09ca1d
--- /dev/null
+++ b/backends/gdx-backend-jglfw/.classpath
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry excluding="**/.svn/*" kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
+	<classpathentry combineaccessrules="false" exported="true" kind="src" path="/gdx"/>
+	<classpathentry exported="true" kind="lib" path="/gdx/libs/gdx-natives.jar"/>
+	<classpathentry exported="true" kind="lib" path="libs/gdx-backend-jglfw-natives.jar"/>
+	<classpathentry exported="true" kind="lib" path="libs/jglfw.jar" sourcepath="/jglfw"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/backends/gdx-backend-jglfw/.project b/backends/gdx-backend-jglfw/.project
new file mode 100644
index 0000000..80c954e
--- /dev/null
+++ b/backends/gdx-backend-jglfw/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>gdx-backend-jglfw</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/backends/gdx-backend-jglfw/.settings/org.eclipse.jdt.core.prefs b/backends/gdx-backend-jglfw/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..cc51644
--- /dev/null
+++ b/backends/gdx-backend-jglfw/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,369 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.6
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.doc.comment.support=enabled
+org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.autoboxing=ignore
+org.eclipse.jdt.core.compiler.problem.comparingIdentical=warning
+org.eclipse.jdt.core.compiler.problem.deadCode=ignore
+org.eclipse.jdt.core.compiler.problem.deprecation=ignore
+org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
+org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
+org.eclipse.jdt.core.compiler.problem.discouragedReference=warning
+org.eclipse.jdt.core.compiler.problem.emptyStatement=ignore
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.fallthroughCase=ignore
+org.eclipse.jdt.core.compiler.problem.fatalOptionalError=disabled
+org.eclipse.jdt.core.compiler.problem.fieldHiding=ignore
+org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
+org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=warning
+org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
+org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
+org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=ignore
+org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=ignore
+org.eclipse.jdt.core.compiler.problem.invalidJavadoc=warning
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTags=enabled
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsDeprecatedRef=enabled
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsNotVisibleRef=enabled
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsVisibility=private
+org.eclipse.jdt.core.compiler.problem.localVariableHiding=ignore
+org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
+org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingHashCodeMethod=ignore
+org.eclipse.jdt.core.compiler.problem.missingJavadocComments=ignore
+org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsOverriding=enabled
+org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsVisibility=public
+org.eclipse.jdt.core.compiler.problem.missingJavadocTagDescription=return_tag
+org.eclipse.jdt.core.compiler.problem.missingJavadocTags=ignore
+org.eclipse.jdt.core.compiler.problem.missingJavadocTagsOverriding=enabled
+org.eclipse.jdt.core.compiler.problem.missingJavadocTagsVisibility=private
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotationForInterfaceMethodImplementation=enabled
+org.eclipse.jdt.core.compiler.problem.missingSerialVersion=ignore
+org.eclipse.jdt.core.compiler.problem.missingSynchronizedOnInheritedMethod=ignore
+org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
+org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
+org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=ignore
+org.eclipse.jdt.core.compiler.problem.nullReference=warning
+org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
+org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=warning
+org.eclipse.jdt.core.compiler.problem.potentialNullReference=ignore
+org.eclipse.jdt.core.compiler.problem.rawTypeReference=ignore
+org.eclipse.jdt.core.compiler.problem.redundantNullCheck=ignore
+org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=ignore
+org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
+org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=warning
+org.eclipse.jdt.core.compiler.problem.suppressOptionalErrors=disabled
+org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
+org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=warning
+org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
+org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=ignore
+org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=ignore
+org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.unnecessaryElse=ignore
+org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=ignore
+org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=enabled
+org.eclipse.jdt.core.compiler.problem.unusedImport=ignore
+org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
+org.eclipse.jdt.core.compiler.problem.unusedLocal=ignore
+org.eclipse.jdt.core.compiler.problem.unusedObjectAllocation=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameterIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=enabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=enabled
+org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=ignore
+org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
+org.eclipse.jdt.core.compiler.source=1.6
+org.eclipse.jdt.core.formatter.align_type_members_on_columns=false
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_annotation=0
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_qualified_allocation_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_assignment=0
+org.eclipse.jdt.core.formatter.alignment_for_binary_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_compact_if=16
+org.eclipse.jdt.core.formatter.alignment_for_conditional_expression=80
+org.eclipse.jdt.core.formatter.alignment_for_enum_constants=0
+org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer=16
+org.eclipse.jdt.core.formatter.alignment_for_method_declaration=0
+org.eclipse.jdt.core.formatter.alignment_for_multiple_fields=16
+org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_resources_in_try=80
+org.eclipse.jdt.core.formatter.alignment_for_selector_in_method_invocation=16
+org.eclipse.jdt.core.formatter.alignment_for_superclass_in_type_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_enum_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_type_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_union_type_in_multicatch=16
+org.eclipse.jdt.core.formatter.blank_lines_after_imports=1
+org.eclipse.jdt.core.formatter.blank_lines_after_package=1
+org.eclipse.jdt.core.formatter.blank_lines_before_field=0
+org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration=0
+org.eclipse.jdt.core.formatter.blank_lines_before_imports=1
+org.eclipse.jdt.core.formatter.blank_lines_before_member_type=1
+org.eclipse.jdt.core.formatter.blank_lines_before_method=1
+org.eclipse.jdt.core.formatter.blank_lines_before_new_chunk=1
+org.eclipse.jdt.core.formatter.blank_lines_before_package=1
+org.eclipse.jdt.core.formatter.blank_lines_between_import_groups=1
+org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations=1
+org.eclipse.jdt.core.formatter.brace_position_for_annotation_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_anonymous_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_array_initializer=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_block=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_block_in_case=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_enum_constant=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_method_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_switch=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment=false
+org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment=false
+org.eclipse.jdt.core.formatter.comment.format_block_comments=true
+org.eclipse.jdt.core.formatter.comment.format_header=false
+org.eclipse.jdt.core.formatter.comment.format_html=true
+org.eclipse.jdt.core.formatter.comment.format_javadoc_comments=true
+org.eclipse.jdt.core.formatter.comment.format_line_comments=true
+org.eclipse.jdt.core.formatter.comment.format_source_code=true
+org.eclipse.jdt.core.formatter.comment.indent_parameter_description=true
+org.eclipse.jdt.core.formatter.comment.indent_root_tags=true
+org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags=do not insert
+org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter=do not insert
+org.eclipse.jdt.core.formatter.comment.line_length=130
+org.eclipse.jdt.core.formatter.comment.new_lines_at_block_boundaries=true
+org.eclipse.jdt.core.formatter.comment.new_lines_at_javadoc_boundaries=false
+org.eclipse.jdt.core.formatter.comment.preserve_white_space_between_code_and_line_comments=false
+org.eclipse.jdt.core.formatter.compact_else_if=true
+org.eclipse.jdt.core.formatter.continuation_indentation=1
+org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer=1
+org.eclipse.jdt.core.formatter.disabling_tag=@off
+org.eclipse.jdt.core.formatter.enabling_tag=@on
+org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line=false
+org.eclipse.jdt.core.formatter.format_line_comment_starting_on_first_column=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header=true
+org.eclipse.jdt.core.formatter.indent_breaks_compare_to_cases=true
+org.eclipse.jdt.core.formatter.indent_empty_lines=false
+org.eclipse.jdt.core.formatter.indent_statements_compare_to_block=true
+org.eclipse.jdt.core.formatter.indent_statements_compare_to_body=true
+org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases=true
+org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch=false
+org.eclipse.jdt.core.formatter.indentation.size=4
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_field=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_method=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_package=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_type=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_label=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing=insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_annotation_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_anonymous_type_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_block=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_constant=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_method_body=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_after_and_in_type_parameter=insert
+org.eclipse.jdt.core.formatter.insert_space_after_assignment_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation_type_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_binary_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_assert=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_case=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_labeled_statement=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_constant_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_explicitconstructorcall_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_inits=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_throws=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_field_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_local_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_parameterized_type_reference=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_ellipsis=insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_cast=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_catch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_if=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_switch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_try=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_while=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_prefix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_after_question_in_wildcard=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_try_resources=insert
+org.eclipse.jdt.core.formatter.insert_space_after_unary_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_and_in_type_parameter=insert
+org.eclipse.jdt.core.formatter.insert_space_before_assignment_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_before_at_in_annotation_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_binary_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_cast=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_catch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_if=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_switch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_synchronized=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_try=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_while=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_assert=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_throws=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_constant_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_explicitconstructorcall_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_increments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_inits=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_local_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_ellipsis=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_annotation_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_anonymous_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_constructor_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_constant=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation_type_member_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_constructor_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_try=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while=insert
+org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_return=insert
+org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_throw=insert
+org.eclipse.jdt.core.formatter.insert_space_before_postfix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_prefix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_before_question_in_wildcard=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_semicolon=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_try_resources=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_unary_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_brackets_in_array_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_braces_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_brackets_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.join_lines_in_comments=true
+org.eclipse.jdt.core.formatter.join_wrapped_lines=true
+org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line=false
+org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line=false
+org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line=true
+org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line=false
+org.eclipse.jdt.core.formatter.lineSplit=130
+org.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column=true
+org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column=true
+org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body=0
+org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve=1
+org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line=true
+org.eclipse.jdt.core.formatter.tabulation.char=tab
+org.eclipse.jdt.core.formatter.tabulation.size=3
+org.eclipse.jdt.core.formatter.use_on_off_tags=true
+org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations=false
+org.eclipse.jdt.core.formatter.wrap_before_binary_operator=true
+org.eclipse.jdt.core.formatter.wrap_before_or_operator_multicatch=true
+org.eclipse.jdt.core.formatter.wrap_outer_expressions_when_nested=true
diff --git a/backends/gdx-backend-jglfw/.settings/org.eclipse.jdt.ui.prefs b/backends/gdx-backend-jglfw/.settings/org.eclipse.jdt.ui.prefs
new file mode 100644
index 0000000..12ca759
--- /dev/null
+++ b/backends/gdx-backend-jglfw/.settings/org.eclipse.jdt.ui.prefs
@@ -0,0 +1,3 @@
+eclipse.preferences.version=1
+formatter_profile=_libgdx
+formatter_settings_version=12
diff --git a/backends/gdx-backend-jglfw/AUTHORS b/backends/gdx-backend-jglfw/AUTHORS
new file mode 100644
index 0000000..e55a032
--- /dev/null
+++ b/backends/gdx-backend-jglfw/AUTHORS
@@ -0,0 +1,10 @@
+# This is the official list of the AUTHORS of libgdx
+# for copyright purposes.
+# This file is distinct from the CONTRIBUTORS files.
+# See the latter for an explanation.
+
+# Names should be added to this file as
+#	Name or Organization <email address>
+# The email address is not required for organizations.
+Mario Zechner <badlogicgames@gmail.com>
+Nathan Sweet <nathan.sweet@gmail.com> 
\ No newline at end of file
diff --git a/backends/gdx-backend-jglfw/CC-LICENSE b/backends/gdx-backend-jglfw/CC-LICENSE
new file mode 100644
index 0000000..7252d9c
--- /dev/null
+++ b/backends/gdx-backend-jglfw/CC-LICENSE
@@ -0,0 +1,63 @@
+License
+
+THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS PUBLIC LICENSE ("CCPL" OR "LICENSE"). THE WORK IS PROTECTED BY COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED.
+
+BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS.
+
+1. Definitions
+
+   1. "Adaptation" means a work based upon the Work, or upon the Work and other pre-existing works, such as a translation, adaptation, derivative work, arrangement of music or other alterations of a literary or artistic work, or phonogram or performance and includes cinematographic adaptations or any other form in which the Work may be recast, transformed, or adapted including in any form recognizably derived from the original, except that a work that constitutes a Collection will not be considered an Adaptation for the purpose of this License. For the avoidance of doubt, where the Work is a musical work, performance or phonogram, the synchronization of the Work in timed-relation with a moving image ("synching") will be considered an Adaptation for the purpose of this License.
+   2. "Collection" means a collection of literary or artistic works, such as encyclopedias and anthologies, or performances, phonograms or broadcasts, or other works or subject matter other than works listed in Section 1(f) below, which, by reason of the selection and arrangement of their contents, constitute intellectual creations, in which the Work is included in its entirety in unmodified form along with one or more other contributions, each constituting separate and independent works in themselves, which together are assembled into a collective whole. A work that constitutes a Collection will not be considered an Adaptation (as defined below) for the purposes of this License.
+   3. "Creative Commons Compatible License" means a license that is listed at http://creativecommons.org/compatiblelicenses that has been approved by Creative Commons as being essentially equivalent to this License, including, at a minimum, because that license: (i) contains terms that have the same purpose, meaning and effect as the License Elements of this License; and, (ii) explicitly permits the relicensing of adaptations of works made available under that license under this License or a Creative Commons jurisdiction license with the same License Elements as this License.
+   4. "Distribute" means to make available to the public the original and copies of the Work or Adaptation, as appropriate, through sale or other transfer of ownership.
+   5. "License Elements" means the following high-level license attributes as selected by Licensor and indicated in the title of this License: Attribution, ShareAlike.
+   6. "Licensor" means the individual, individuals, entity or entities that offer(s) the Work under the terms of this License.
+   7. "Original Author" means, in the case of a literary or artistic work, the individual, individuals, entity or entities who created the Work or if no individual or entity can be identified, the publisher; and in addition (i) in the case of a performance the actors, singers, musicians, dancers, and other persons who act, sing, deliver, declaim, play in, interpret or otherwise perform literary or artistic works or expressions of folklore; (ii) in the case of a phonogram the producer being the person or legal entity who first fixes the sounds of a performance or other sounds; and, (iii) in the case of broadcasts, the organization that transmits the broadcast.
+   8. "Work" means the literary and/or artistic work offered under the terms of this License including without limitation any production in the literary, scientific and artistic domain, whatever may be the mode or form of its expression including digital form, such as a book, pamphlet and other writing; a lecture, address, sermon or other work of the same nature; a dramatic or dramatico-musical work; a choreographic work or entertainment in dumb show; a musical composition with or without words; a cinematographic work to which are assimilated works expressed by a process analogous to cinematography; a work of drawing, painting, architecture, sculpture, engraving or lithography; a photographic work to which are assimilated works expressed by a process analogous to photography; a work of applied art; an illustration, map, plan, sketch or three-dimensional work relative to geography, topography, architecture or science; a performance; a broadcast; a phonogram; a compilation of data to the extent it is protected as a copyrightable work; or a work performed by a variety or circus performer to the extent it is not otherwise considered a literary or artistic work.
+   9. "You" means an individual or entity exercising rights under this License who has not previously violated the terms of this License with respect to the Work, or who has received express permission from the Licensor to exercise rights under this License despite a previous violation.
+  10. "Publicly Perform" means to perform public recitations of the Work and to communicate to the public those public recitations, by any means or process, including by wire or wireless means or public digital performances; to make available to the public Works in such a way that members of the public may access these Works from a place and at a place individually chosen by them; to perform the Work to the public by any means or process and the communication to the public of the performances of the Work, including by public digital performance; to broadcast and rebroadcast the Work by any means including signs, sounds or images.
+  11. "Reproduce" means to make copies of the Work by any means including without limitation by sound or visual recordings and the right of fixation and reproducing fixations of the Work, including storage of a protected performance or phonogram in digital form or other electronic medium.
+
+2. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or restrict any uses free from copyright or rights arising from limitations or exceptions that are provided for in connection with the copyright protection under copyright law or other applicable laws.
+
+3. License Grant. Subject to the terms and conditions of this License, Licensor hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for the duration of the applicable copyright) license to exercise the rights in the Work as stated below:
+
+   1. to Reproduce the Work, to incorporate the Work into one or more Collections, and to Reproduce the Work as incorporated in the Collections;
+   2. to create and Reproduce Adaptations provided that any such Adaptation, including any translation in any medium, takes reasonable steps to clearly label, demarcate or otherwise identify that changes were made to the original Work. For example, a translation could be marked "The original work was translated from English to Spanish," or a modification could indicate "The original work has been modified.";
+   3. to Distribute and Publicly Perform the Work including as incorporated in Collections; and,
+   4. to Distribute and Publicly Perform Adaptations.
+   5.
+
+      For the avoidance of doubt:
+         1. Non-waivable Compulsory License Schemes. In those jurisdictions in which the right to collect royalties through any statutory or compulsory licensing scheme cannot be waived, the Licensor reserves the exclusive right to collect such royalties for any exercise by You of the rights granted under this License;
+         2. Waivable Compulsory License Schemes. In those jurisdictions in which the right to collect royalties through any statutory or compulsory licensing scheme can be waived, the Licensor waives the exclusive right to collect such royalties for any exercise by You of the rights granted under this License; and,
+         3. Voluntary License Schemes. The Licensor waives the right to collect royalties, whether individually or, in the event that the Licensor is a member of a collecting society that administers voluntary licensing schemes, via that society, from any exercise by You of the rights granted under this License.
+
+The above rights may be exercised in all media and formats whether now known or hereafter devised. The above rights include the right to make such modifications as are technically necessary to exercise the rights in other media and formats. Subject to Section 8(f), all rights not expressly granted by Licensor are hereby reserved.
+
+4. Restrictions. The license granted in Section 3 above is expressly made subject to and limited by the following restrictions:
+
+   1. You may Distribute or Publicly Perform the Work only under the terms of this License. You must include a copy of, or the Uniform Resource Identifier (URI) for, this License with every copy of the Work You Distribute or Publicly Perform. You may not offer or impose any terms on the Work that restrict the terms of this License or the ability of the recipient of the Work to exercise the rights granted to that recipient under the terms of the License. You may not sublicense the Work. You must keep intact all notices that refer to this License and to the disclaimer of warranties with every copy of the Work You Distribute or Publicly Perform. When You Distribute or Publicly Perform the Work, You may not impose any effective technological measures on the Work that restrict the ability of a recipient of the Work from You to exercise the rights granted to that recipient under the terms of the License. This Section 4(a) applies to the Work as incorporated in a Collection, but this does not require the Collection apart from the Work itself to be made subject to the terms of this License. If You create a Collection, upon notice from any Licensor You must, to the extent practicable, remove from the Collection any credit as required by Section 4(c), as requested. If You create an Adaptation, upon notice from any Licensor You must, to the extent practicable, remove from the Adaptation any credit as required by Section 4(c), as requested.
+   2. You may Distribute or Publicly Perform an Adaptation only under the terms of: (i) this License; (ii) a later version of this License with the same License Elements as this License; (iii) a Creative Commons jurisdiction license (either this or a later license version) that contains the same License Elements as this License (e.g., Attribution-ShareAlike 3.0 US)); (iv) a Creative Commons Compatible License. If you license the Adaptation under one of the licenses mentioned in (iv), you must comply with the terms of that license. If you license the Adaptation under the terms of any of the licenses mentioned in (i), (ii) or (iii) (the "Applicable License"), you must comply with the terms of the Applicable License generally and the following provisions: (I) You must include a copy of, or the URI for, the Applicable License with every copy of each Adaptation You Distribute or Publicly Perform; (II) You may not offer or impose any terms on the Adaptation that restrict the terms of the Applicable License or the ability of the recipient of the Adaptation to exercise the rights granted to that recipient under the terms of the Applicable License; (III) You must keep intact all notices that refer to the Applicable License and to the disclaimer of warranties with every copy of the Work as included in the Adaptation You Distribute or Publicly Perform; (IV) when You Distribute or Publicly Perform the Adaptation, You may not impose any effective technological measures on the Adaptation that restrict the ability of a recipient of the Adaptation from You to exercise the rights granted to that recipient under the terms of the Applicable License. This Section 4(b) applies to the Adaptation as incorporated in a Collection, but this does not require the Collection apart from the Adaptation itself to be made subject to the terms of the Applicable License.
+   3. If You Distribute, or Publicly Perform the Work or any Adaptations or Collections, You must, unless a request has been made pursuant to Section 4(a), keep intact all copyright notices for the Work and provide, reasonable to the medium or means You are utilizing: (i) the name of the Original Author (or pseudonym, if applicable) if supplied, and/or if the Original Author and/or Licensor designate another party or parties (e.g., a sponsor institute, publishing entity, journal) for attribution ("Attribution Parties") in Licensor's copyright notice, terms of service or by other reasonable means, the name of such party or parties; (ii) the title of the Work if supplied; (iii) to the extent reasonably practicable, the URI, if any, that Licensor specifies to be associated with the Work, unless such URI does not refer to the copyright notice or licensing information for the Work; and (iv) , consistent with Ssection 3(b), in the case of an Adaptation, a credit identifying the use of the Work in the Adaptation (e.g., "French translation of the Work by Original Author," or "Screenplay based on original Work by Original Author"). The credit required by this Section 4(c) may be implemented in any reasonable manner; provided, however, that in the case of a Adaptation or Collection, at a minimum such credit will appear, if a credit for all contributing authors of the Adaptation or Collection appears, then as part of these credits and in a manner at least as prominent as the credits for the other contributing authors. For the avoidance of doubt, You may only use the credit required by this Section for the purpose of attribution in the manner set out above and, by exercising Your rights under this License, You may not implicitly or explicitly assert or imply any connection with, sponsorship or endorsement by the Original Author, Licensor and/or Attribution Parties, as appropriate, of You or Your use of the Work, without the separate, express prior written permission of the Original Author, Licensor and/or Attribution Parties.
+   4. Except as otherwise agreed in writing by the Licensor or as may be otherwise permitted by applicable law, if You Reproduce, Distribute or Publicly Perform the Work either by itself or as part of any Adaptations or Collections, You must not distort, mutilate, modify or take other derogatory action in relation to the Work which would be prejudicial to the Original Author's honor or reputation. Licensor agrees that in those jurisdictions (e.g. Japan), in which any exercise of the right granted in Section 3(b) of this License (the right to make Adaptations) would be deemed to be a distortion, mutilation, modification or other derogatory action prejudicial to the Original Author's honor and reputation, the Licensor will waive or not assert, as appropriate, this Section, to the fullest extent permitted by the applicable national law, to enable You to reasonably exercise Your right under Section 3(b) of this License (right to make Adaptations) but not otherwise.
+
+5. Representations, Warranties and Disclaimer
+
+UNLESS OTHERWISE MUTUALLY AGREED TO BY THE PARTIES IN WRITING, LICENSOR OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND CONCERNING THE WORK, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, INCLUDING, WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTIBILITY, FITNESS FOR A PARTICULAR PURPOSE, NONINFRINGEMENT, OR THE ABSENCE OF LATENT OR OTHER DEFECTS, ACCURACY, OR THE PRESENCE OF ABSENCE OF ERRORS, WHETHER OR NOT DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU.
+
+6. Limitation on Liability. EXCEPT TO THE EXTENT REQUIRED BY APPLICABLE LAW, IN NO EVENT WILL LICENSOR BE LIABLE TO YOU ON ANY LEGAL THEORY FOR ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES ARISING OUT OF THIS LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+
+7. Termination
+
+   1. This License and the rights granted hereunder will terminate automatically upon any breach by You of the terms of this License. Individuals or entities who have received Adaptations or Collections from You under this License, however, will not have their licenses terminated provided such individuals or entities remain in full compliance with those licenses. Sections 1, 2, 5, 6, 7, and 8 will survive any termination of this License.
+   2. Subject to the above terms and conditions, the license granted here is perpetual (for the duration of the applicable copyright in the Work). Notwithstanding the above, Licensor reserves the right to release the Work under different license terms or to stop distributing the Work at any time; provided, however that any such election will not serve to withdraw this License (or any other license that has been, or is required to be, granted under the terms of this License), and this License will continue in full force and effect unless terminated as stated above.
+
+8. Miscellaneous
+
+   1. Each time You Distribute or Publicly Perform the Work or a Collection, the Licensor offers to the recipient a license to the Work on the same terms and conditions as the license granted to You under this License.
+   2. Each time You Distribute or Publicly Perform an Adaptation, Licensor offers to the recipient a license to the original Work on the same terms and conditions as the license granted to You under this License.
+   3. If any provision of this License is invalid or unenforceable under applicable law, it shall not affect the validity or enforceability of the remainder of the terms of this License, and without further action by the parties to this agreement, such provision shall be reformed to the minimum extent necessary to make such provision valid and enforceable.
+   4. No term or provision of this License shall be deemed waived and no breach consented to unless such waiver or consent shall be in writing and signed by the party to be charged with such waiver or consent.
+   5. This License constitutes the entire agreement between the parties with respect to the Work licensed here. There are no understandings, agreements or representations with respect to the Work not specified here. Licensor shall not be bound by any additional provisions that may appear in any communication from You. This License may not be modified without the mutual written agreement of the Licensor and You.
+   6. The rights granted under, and the subject matter referenced, in this License were drafted utilizing the terminology of the Berne Convention for the Protection of Literary and Artistic Works (as amended on September 28, 1979), the Rome Convention of 1961, the WIPO Copyright Treaty of 1996, the WIPO Performances and Phonograms Treaty of 1996 and the Universal Copyright Convention (as revised on July 24, 1971). These rights and subject matter take effect in the relevant jurisdiction in which the License terms are sought to be enforced according to the corresponding provisions of the implementation of those treaty provisions in the applicable national law. If the standard suite of rights granted under applicable copyright law includes additional rights not granted under this License, such additional rights are deemed to be included in the License; this License is not intended to restrict the license of any rights under applicable law.
diff --git a/backends/gdx-backend-jglfw/CONTRIBUTORS b/backends/gdx-backend-jglfw/CONTRIBUTORS
new file mode 100644
index 0000000..31f9947
--- /dev/null
+++ b/backends/gdx-backend-jglfw/CONTRIBUTORS
@@ -0,0 +1,13 @@
+# This is the official list of people who can contribute
+# (and who have contributed) code to the libgdx project
+# repository.
+# The AUTHORS file lists the copyright holders; this file
+# lists people. Contributors must sign the CLA to grant
+# the AUTHORS copyright within the terms of the Apache 2 license.
+#
+Tony Wang manifaust@gmail.com, 
+Christoph Widulle christoph.widulle@googlemail.com, 
+Dave Clayton davedx@gmail.com, 
+David Fraska dfraska@gmail.com, 
+Moritz Post moritzpost@gmail.com, 
+Eric Spitz eric.spitz2000@gmail.com
\ No newline at end of file
diff --git a/backends/gdx-backend-jglfw/LICENSE b/backends/gdx-backend-jglfw/LICENSE
new file mode 100644
index 0000000..4947287
--- /dev/null
+++ b/backends/gdx-backend-jglfw/LICENSE
@@ -0,0 +1,177 @@
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
\ No newline at end of file
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwApplication.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwApplication.java
new file mode 100644
index 0000000..cd7cdb4
--- /dev/null
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwApplication.java
@@ -0,0 +1,385 @@
+
+package com.badlogic.gdx.backends.jglfw;
+
+import static com.badlogic.gdx.utils.SharedLibraryLoader.*;
+import static com.badlogic.jglfw.Glfw.*;
+
+import com.badlogic.gdx.Application;
+import com.badlogic.gdx.ApplicationListener;
+import com.badlogic.gdx.Audio;
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.LifecycleListener;
+import com.badlogic.gdx.Preferences;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.Clipboard;
+import com.badlogic.gdx.utils.GdxNativesLoader;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+import com.badlogic.jglfw.GlfwCallbackAdapter;
+import com.badlogic.jglfw.GlfwCallbacks;
+
+import java.awt.EventQueue;
+import java.util.HashMap;
+import java.util.Map;
+
+/** An OpenGL surface fullscreen or in a lightweight window using GLFW.
+ * @author mzechner
+ * @author Nathan Sweet */
+public class JglfwApplication implements Application {
+	JglfwGraphics graphics;
+	JglfwFiles files;
+	JglfwInput input;
+	JglfwNet net;
+	final ApplicationListener listener;
+	private final Array<Runnable> runnables = new Array();
+	private final Array<Runnable> executedRunnables = new Array();
+	private final Array<LifecycleListener> lifecycleListeners = new Array();
+	private final Map<String, Preferences> preferences = new HashMap();
+	private final JglfwClipboard clipboard = new JglfwClipboard();
+	private final GlfwCallbacks callbacks = new GlfwCallbacks();
+	private int logLevel = LOG_INFO;
+	volatile boolean running = true;
+	boolean isPaused;
+
+	private boolean forceExit, runOnEDT;
+	private int foregroundFPS, backgroundFPS, hiddenFPS;
+
+	public JglfwApplication (ApplicationListener listener) {
+		this(listener, listener.getClass().getSimpleName(), 640, 480, false);
+	}
+
+	public JglfwApplication (ApplicationListener listener, String title, int width, int height, boolean useGL2) {
+		this(listener, createConfig(title, width, height, useGL2));
+	}
+
+	static private JglfwApplicationConfiguration createConfig (String title, int width, int height, boolean useGL2) {
+		JglfwApplicationConfiguration config = new JglfwApplicationConfiguration();
+		config.title = title;
+		config.width = width;
+		config.height = height;
+		config.useGL20 = useGL2;
+		return config;
+	}
+
+	public JglfwApplication (final ApplicationListener listener, final JglfwApplicationConfiguration config) {
+		if (listener == null) throw new IllegalArgumentException("listener cannot be null.");
+		if (config == null) throw new IllegalArgumentException("config cannot be null.");
+
+		this.listener = listener;
+
+		Runnable runnable = new Runnable() {
+			public void run () {
+				try {
+					initialize(config);
+				} catch (Throwable ex) {
+					exception(ex);
+				}
+			}
+		};
+		if (config.runOnEDT)
+			EventQueue.invokeLater(runnable);
+		else
+			new Thread(runnable, "MainLoop").start();
+	}
+
+	/** Called when an uncaught exception happens in the game loop. Default implementation prints the exception and calls
+	 * System.exit(0). */
+	protected void exception (Throwable ex) {
+		ex.printStackTrace();
+		System.exit(0);
+	}
+
+	void initialize (JglfwApplicationConfiguration config) {
+		forceExit = config.forceExit;
+		runOnEDT = config.runOnEDT;
+		foregroundFPS = config.foregroundFPS;
+		backgroundFPS = config.backgroundFPS;
+		hiddenFPS = config.hiddenFPS;
+
+		final Thread glThread = Thread.currentThread();
+
+		GdxNativesLoader.load();
+
+		boolean inputCallbacksOnAppKitThread = isMac;
+		if (inputCallbacksOnAppKitThread) java.awt.Toolkit.getDefaultToolkit(); // Ensure AWT is initialized before GLFW.
+
+		if (!glfwInit()) throw new GdxRuntimeException("Unable to initialize GLFW.");
+
+		Gdx.app = this;
+		Gdx.graphics = graphics = new JglfwGraphics(config);
+		Gdx.files = files = new JglfwFiles();
+		Gdx.input = input = new JglfwInput(this, inputCallbacksOnAppKitThread);
+		Gdx.net = net = new JglfwNet();
+
+		callbacks.add(new GlfwCallbackAdapter() {
+			public void windowSize (long window, final int width, final int height) {
+				Runnable runnable = new Runnable() {
+					public void run () {
+						graphics.sizeChanged(width, height);
+					}
+				};
+				if (Thread.currentThread() != glThread)
+					postRunnable(runnable);
+				else
+					runnable.run();
+			}
+
+			public void windowPos (long window, final int x, final int y) {
+				Runnable runnable = new Runnable() {
+					public void run () {
+						graphics.positionChanged(x, y);
+					}
+				};
+				if (Thread.currentThread() != glThread)
+					postRunnable(runnable);
+				else
+					runnable.run();
+			}
+
+			public void windowRefresh (long window) {
+				if (Thread.currentThread() == glThread) render(System.nanoTime());
+			}
+
+			public void windowFocus (long window, boolean focused) {
+				graphics.foreground = focused;
+			}
+
+			public void windowIconify (long window, boolean iconified) {
+				graphics.minimized = iconified;
+			}
+
+			public void error (int error, String description) {
+				throw new GdxRuntimeException("GLFW error " + error + ": " + description);
+			}
+		});
+		glfwSetCallback(callbacks);
+
+		start();
+	}
+
+	/** Starts the game loop after the application internals have been initialized. */
+	protected void start () {
+		listener.create();
+		listener.resize(graphics.getWidth(), graphics.getHeight());
+
+		if (runOnEDT) {
+			new Runnable() {
+				public void run () {
+					frame();
+					if (running)
+						EventQueue.invokeLater(this);
+					else
+						end();
+				}
+			}.run();
+		} else {
+			while (running)
+				frame();
+			end();
+		}
+	}
+
+	/** Handles posted runnables, input, and rendering for each frame. */
+	protected void frame () {
+		if (glfwWindowShouldClose(graphics.window)) {
+			exit();
+			return;
+		}
+
+		synchronized (runnables) {
+			executedRunnables.clear();
+			executedRunnables.addAll(runnables);
+			runnables.clear();
+		}
+		if (executedRunnables.size > 0) {
+			for (int i = 0; i < executedRunnables.size; i++)
+				executedRunnables.get(i).run();
+			if (!running) return;
+			graphics.requestRendering();
+		}
+
+		input.update();
+
+		long frameStartTime = System.nanoTime();
+		int targetFPS = (graphics.isHidden() || graphics.isMinimized()) ? hiddenFPS : //
+			(graphics.isForeground() ? foregroundFPS : backgroundFPS);
+
+		if (targetFPS == -1) { // Rendering is paused.
+			if (!isPaused) listener.pause();
+			isPaused = true;
+		} else {
+			if (isPaused) listener.resume();
+			isPaused = false;
+			if (graphics.shouldRender()) render(frameStartTime);
+		}
+
+		if (targetFPS != 0)
+			sleep(targetFPS == -1 ? 100 : (int)(1000f / targetFPS - (System.nanoTime() - frameStartTime) / 1000000f));
+	}
+
+	void sleep (int millis) {
+		try {
+			if (millis > 0) Thread.sleep(millis);
+		} catch (InterruptedException ignored) {
+		}
+	}
+
+	void render (long time) {
+		graphics.frameStart(time);
+		listener.render();
+		glfwSwapBuffers(graphics.window);
+	}
+
+	/** Called when the game loop has exited. */
+	protected void end () {
+		synchronized (lifecycleListeners) {
+			for (LifecycleListener listener : lifecycleListeners) {
+				listener.pause();
+				listener.dispose();
+			}
+		}
+		listener.pause();
+		listener.dispose();
+		glfwTerminate();
+		if (forceExit) System.exit(-1);
+	}
+
+	public ApplicationListener getApplicationListener () {
+		return listener;
+	}
+
+	public JglfwGraphics getGraphics () {
+		return graphics;
+	}
+
+	public Audio getAudio () {
+		return null;
+	}
+
+	public JglfwInput getInput () {
+		return input;
+	}
+
+	public JglfwFiles getFiles () {
+		return files;
+	}
+
+	public JglfwNet getNet () {
+		return net;
+	}
+
+	public ApplicationType getType () {
+		return ApplicationType.Desktop;
+	}
+
+	public int getVersion () {
+		return 0;
+	}
+
+	public long getJavaHeap () {
+		return Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
+	}
+
+	public long getNativeHeap () {
+		return getJavaHeap();
+	}
+
+	public Preferences getPreferences (String name) {
+		if (preferences.containsKey(name))
+			return preferences.get(name);
+		else {
+			Preferences prefs = new JglfwPreferences(name);
+			preferences.put(name, prefs);
+			return prefs;
+		}
+	}
+
+	public Clipboard getClipboard () {
+		return clipboard;
+	}
+
+	public void postRunnable (Runnable runnable) {
+		synchronized (runnables) {
+			runnables.add(runnable);
+			graphics.requestRendering();
+		}
+	}
+
+	public boolean isPaused () {
+		return isPaused;
+	}
+
+	public void setForegroundFPS (int foregroundFPS) {
+		this.foregroundFPS = foregroundFPS;
+	}
+
+	public void setBackgroundFPS (int backgroundFPS) {
+		this.backgroundFPS = backgroundFPS;
+	}
+
+	public void setHiddenFPS (int hiddenFPS) {
+		this.hiddenFPS = hiddenFPS;
+	}
+
+	public void exit () {
+		running = false;
+	}
+
+	public void setLogLevel (int logLevel) {
+		this.logLevel = logLevel;
+	}
+
+	public void debug (String tag, String message) {
+		if (logLevel >= LOG_DEBUG) {
+			System.out.println(tag + ": " + message);
+		}
+	}
+
+	public void debug (String tag, String message, Throwable exception) {
+		if (logLevel >= LOG_DEBUG) {
+			System.out.println(tag + ": " + message);
+			exception.printStackTrace(System.out);
+		}
+	}
+
+	public void log (String tag, String message) {
+		if (logLevel >= LOG_INFO) {
+			System.out.println(tag + ": " + message);
+		}
+	}
+
+	public void log (String tag, String message, Exception exception) {
+		if (logLevel >= LOG_INFO) {
+			System.out.println(tag + ": " + message);
+			exception.printStackTrace(System.out);
+		}
+	}
+
+	public void error (String tag, String message) {
+		if (logLevel >= LOG_ERROR) {
+			System.err.println(tag + ": " + message);
+		}
+	}
+
+	public void error (String tag, String message, Throwable exception) {
+		if (logLevel >= LOG_ERROR) {
+			System.err.println(tag + ": " + message);
+			exception.printStackTrace(System.err);
+		}
+	}
+
+	public void addLifecycleListener (LifecycleListener listener) {
+		synchronized (lifecycleListeners) {
+			lifecycleListeners.add(listener);
+		}
+	}
+
+	public void removeLifecycleListener (LifecycleListener listener) {
+		synchronized (lifecycleListeners) {
+			lifecycleListeners.removeValue(listener, true);
+		}
+	}
+
+	public GlfwCallbacks getCallbacks () {
+		return callbacks;
+	}
+}
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwApplicationConfiguration.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwApplicationConfiguration.java
new file mode 100644
index 0000000..9e6c665
--- /dev/null
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwApplicationConfiguration.java
@@ -0,0 +1,80 @@
+
+package com.badlogic.gdx.backends.jglfw;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.Graphics.DisplayMode;
+import com.badlogic.gdx.backends.jglfw.JglfwGraphics.JglfwDisplayMode;
+import com.badlogic.gdx.graphics.Color;
+import com.badlogic.gdx.utils.Array;
+
+import java.awt.GraphicsDevice;
+import java.awt.GraphicsEnvironment;
+
+/** @author Nathan Sweet */
+public class JglfwApplicationConfiguration {
+	/** Title of application window. **/
+	public String title = "";
+	/** Initial width of the application window. **/
+	public int width = 640;
+	/** Initial height of the application window. **/
+	public int height = 480;
+	/** Intial x coordinate of the application window, -1 for center. **/
+	public int x = -1;
+	/** Intial x coordinate of the application window, -1 for center. **/
+	public int y = -1;
+	/** True to start in fullscreen. **/
+	public boolean fullscreen;
+	/** Monitor index to use for fullscreen. **/
+	public int fullscreenMonitorIndex = -1;
+	/** Number of bits per color channel. **/
+	public int r = 8, g = 8, b = 8, a = 8;
+	/** Number of bits for the depth buffer. **/
+	public int depth = 16;
+	/** Number of bits for the stencil buffer. **/
+	public int stencil = 0;
+	/** Number of samples for MSAA **/
+	public int samples = 0;
+	/** True to enable vsync. **/
+	public boolean vSync = true;
+	/** True if the window is resizable. **/
+	public boolean resizable = true;
+	/** True to attempt to use OpenGL ES 2.0. Note {@link Gdx#gl20} may be null even when this is true. **/
+	public boolean useGL20;
+	/** True to call System.exit() when the main loop is complete. **/
+	public boolean forceExit = true;
+	/** True to have a title and border around the window. **/
+	public boolean undecorated;
+	/** Causes the main loop to run on the EDT instead of a new thread, for easier interoperability with AWT/Swing. Broken on Linux. **/
+	public boolean runOnEDT;
+	/** The color to clear the window immediately after creation. **/
+	public Color initialBackgroundColor = Color.BLACK;
+	/** True to hide the window when it is created. The window must be shown with {@link JglfwGraphics#show()}. **/
+	public boolean hidden;
+	/** Target framerate when the window is in the foreground. The CPU sleeps as needed. Use 0 to never sleep. **/
+	public int foregroundFPS;
+	/** Target framerate when the window is in the background. The CPU sleeps as needed. Use 0 to never sleep, -1 to not render. **/
+	public int backgroundFPS;
+	/** Target framerate when the window is hidden or minimized. The CPU sleeps as needed. Use 0 to never sleep, -1 to not render. **/
+	public int hiddenFPS = -1;
+
+	static public DisplayMode[] getDisplayModes () {
+		GraphicsDevice device = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice();
+		java.awt.DisplayMode desktopMode = device.getDisplayMode();
+		java.awt.DisplayMode[] displayModes = device.getDisplayModes();
+		Array<DisplayMode> modes = new Array();
+		outer:
+		for (java.awt.DisplayMode mode : displayModes) {
+			for (DisplayMode other : modes)
+				if (other.width == mode.getWidth() && other.height == mode.getHeight() && other.bitsPerPixel == mode.getBitDepth())
+					continue outer; // Duplicate.
+			if (mode.getBitDepth() != desktopMode.getBitDepth()) continue;
+			modes.add(new JglfwDisplayMode(mode.getWidth(), mode.getHeight(), mode.getRefreshRate(), mode.getBitDepth()));
+		}
+		return modes.toArray(DisplayMode.class);
+	}
+
+	static public DisplayMode getDesktopDisplayMode () {
+		java.awt.DisplayMode mode = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().getDisplayMode();
+		return new JglfwDisplayMode(mode.getWidth(), mode.getHeight(), mode.getRefreshRate(), mode.getBitDepth());
+	}
+}
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwClipboard.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwClipboard.java
new file mode 100644
index 0000000..21370be
--- /dev/null
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwClipboard.java
@@ -0,0 +1,49 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.backends.jglfw;
+
+import com.badlogic.gdx.utils.Clipboard;
+
+import java.awt.Toolkit;
+import java.awt.datatransfer.ClipboardOwner;
+import java.awt.datatransfer.DataFlavor;
+import java.awt.datatransfer.StringSelection;
+import java.awt.datatransfer.Transferable;
+
+/** Clipboard implementation for desktop that uses the system clipboard via the default AWT {@link Toolkit}.
+ * @author mzechner */
+public class JglfwClipboard implements Clipboard, ClipboardOwner {
+	public String getContents () {
+		java.awt.datatransfer.Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
+		Transferable contents = clipboard.getContents(null);
+		if (contents != null && contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {
+			try {
+				return (String)contents.getTransferData(DataFlavor.stringFlavor);
+			} catch (Exception ignored) {
+			}
+		}
+		return "";
+	}
+
+	public void setContents (String content) {
+		java.awt.datatransfer.Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
+		clipboard.setContents(new StringSelection(content), this);
+	}
+
+	public void lostOwnership (java.awt.datatransfer.Clipboard clipboard, Transferable transferable) {
+	}
+}
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwFileHandle.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwFileHandle.java
new file mode 100644
index 0000000..0ae4c53
--- /dev/null
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwFileHandle.java
@@ -0,0 +1,61 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.backends.jglfw;
+
+import java.io.File;
+
+import com.badlogic.gdx.Files.FileType;
+import com.badlogic.gdx.files.FileHandle;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+/** @author mzechner
+ * @author Nathan Sweet */
+public final class JglfwFileHandle extends FileHandle {
+	public JglfwFileHandle (String fileName, FileType type) {
+		super(fileName, type);
+	}
+
+	public JglfwFileHandle (File file, FileType type) {
+		super(file, type);
+	}
+
+	public FileHandle child (String name) {
+		if (file.getPath().length() == 0) return new JglfwFileHandle(new File(name), type);
+		return new JglfwFileHandle(new File(file, name), type);
+	}
+
+	public FileHandle sibling (String name) {
+		if (file.getPath().length() == 0) throw new GdxRuntimeException("Cannot get the sibling of the root.");
+		return new JglfwFileHandle(new File(file.getParent(), name), type);
+	}
+
+	public FileHandle parent () {
+		File parent = file.getParentFile();
+		if (parent == null) {
+			if (type == FileType.Absolute)
+				parent = new File("/");
+			else
+				parent = new File("");
+		}
+		return new JglfwFileHandle(parent, type);
+	}
+
+	public File file () {
+		if (type == FileType.External) return new File(JglfwFiles.externalPath, file.getPath());
+		return file;
+	}
+}
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwFiles.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwFiles.java
new file mode 100644
index 0000000..4fd59cc
--- /dev/null
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwFiles.java
@@ -0,0 +1,66 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.backends.jglfw;
+
+import com.badlogic.gdx.Files;
+import com.badlogic.gdx.files.FileHandle;
+
+/** @author mzechner
+ * @author Nathan Sweet */
+public final class JglfwFiles implements Files {
+	static public final String externalPath = System.getProperty("user.home") + "/";
+
+	public FileHandle getFileHandle (String fileName, FileType type) {
+		return new JglfwFileHandle(fileName, type);
+	}
+
+	public FileHandle classpath (String path) {
+		return new JglfwFileHandle(path, FileType.Classpath);
+	}
+
+	public FileHandle internal (String path) {
+		return new JglfwFileHandle(path, FileType.Internal);
+	}
+
+	public FileHandle external (String path) {
+		return new JglfwFileHandle(path, FileType.External);
+	}
+
+	public FileHandle absolute (String path) {
+		return new JglfwFileHandle(path, FileType.Absolute);
+	}
+
+	public FileHandle local (String path) {
+		return new JglfwFileHandle(path, FileType.Local);
+	}
+
+	public String getExternalStoragePath () {
+		return externalPath;
+	}
+
+	public boolean isExternalStorageAvailable () {
+		return true;
+	}
+
+	public String getLocalStoragePath () {
+		return "";
+	}
+
+	public boolean isLocalStorageAvailable () {
+		return true;
+	}
+}
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwGL10.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwGL10.java
new file mode 100644
index 0000000..02bc1c7
--- /dev/null
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwGL10.java
@@ -0,0 +1,374 @@
+
+package com.badlogic.gdx.backends.jglfw;
+
+import static com.badlogic.gdx.backends.jglfw.JglfwUtil.*;
+import static com.badlogic.jglfw.utils.Memory.*;
+
+import com.badlogic.gdx.graphics.GL10;
+import com.badlogic.jglfw.gl.GL;
+
+import java.nio.Buffer;
+import java.nio.FloatBuffer;
+import java.nio.IntBuffer;
+
+public class JglfwGL10 implements GL10 {
+	public void glActiveTexture (int texture) {
+		GL.glActiveTexture(texture);
+	}
+
+	public void glBindTexture (int target, int texture) {
+		GL.glBindTexture(target, texture);
+	}
+
+	public void glBlendFunc (int sfactor, int dfactor) {
+		GL.glBlendFunc(sfactor, dfactor);
+	}
+
+	public void glClear (int mask) {
+		GL.glClear(mask);
+	}
+
+	public void glClearColor (float red, float green, float blue, float alpha) {
+		GL.glClearColor(red, green, blue, alpha);
+	}
+
+	public void glClearDepthf (float depth) {
+		GL.glClearDepthf(depth);
+	}
+
+	public void glClearStencil (int s) {
+		GL.glClearStencil(s);
+	}
+
+	public void glColorMask (boolean red, boolean green, boolean blue, boolean alpha) {
+		GL.glColorMask(red, green, blue, alpha);
+	}
+
+	public void glCompressedTexImage2D (int target, int level, int internalformat, int width, int height, int border,
+		int imageSize, Buffer data) {
+		GL.glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data, getPosition(data));
+	}
+
+	public void glCompressedTexSubImage2D (int target, int level, int xoffset, int yoffset, int width, int height, int format,
+		int imageSize, Buffer data) {
+		GL.glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data, getPosition(data));
+	}
+
+	public void glCopyTexImage2D (int target, int level, int internalformat, int x, int y, int width, int height, int border) {
+		GL.glCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
+	}
+
+	public void glCopyTexSubImage2D (int target, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
+		GL.glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
+	}
+
+	public void glCullFace (int mode) {
+		GL.glCullFace(mode);
+	}
+
+	public void glDeleteTextures (int n, IntBuffer textures) {
+		GL.glDeleteTextures(n, textures, getPosition(textures));
+	}
+
+	public void glDepthFunc (int func) {
+		GL.glDepthFunc(func);
+	}
+
+	public void glDepthMask (boolean flag) {
+		GL.glDepthMask(flag);
+	}
+
+	public void glDepthRangef (float zNear, float zFar) {
+		GL.glDepthRangef(zNear, zFar);
+	}
+
+	public void glDisable (int cap) {
+		GL.glDisable(cap);
+	}
+
+	public void glDrawArrays (int mode, int first, int count) {
+		GL.glDrawArrays(mode, first, count);
+	}
+
+	public void glDrawElements (int mode, int count, int type, Buffer indices) {
+		GL.glDrawElements(mode, count, type, indices, getPosition(indices));
+	}
+
+	public void glEnable (int cap) {
+		GL.glEnable(cap);
+	}
+
+	public void glFinish () {
+		GL.glFinish();
+	}
+
+	public void glFlush () {
+		GL.glFlush();
+	}
+
+	public void glFrontFace (int mode) {
+		GL.glFrontFace(mode);
+	}
+
+	public void glGenTextures (int n, IntBuffer textures) {
+		GL.glGenTextures(n, textures, getPosition(textures));
+	}
+
+	public int glGetError () {
+		return GL.glGetError();
+	}
+
+	public void glGetIntegerv (int pname, IntBuffer params) {
+		GL.glGetIntegerv(pname, params, getPosition(params));
+	}
+
+	public String glGetString (int name) {
+		return GL.glGetString(name);
+	}
+
+	public void glHint (int target, int mode) {
+		GL.glHint(target, mode);
+	}
+
+	public void glLineWidth (float width) {
+		GL.glLineWidth(width);
+	}
+
+	public void glPixelStorei (int pname, int param) {
+		GL.glPixelStorei(pname, param);
+	}
+
+	public void glPolygonOffset (float factor, float units) {
+		GL.glPolygonOffset(factor, units);
+	}
+
+	public void glReadPixels (int x, int y, int width, int height, int format, int type, Buffer pixels) {
+		GL.glReadPixels(x, y, width, height, format, type, pixels, getPosition(pixels));
+	}
+
+	public void glScissor (int x, int y, int width, int height) {
+		GL.glScissor(x, y, width, height);
+	}
+
+	public void glStencilFunc (int func, int ref, int mask) {
+		GL.glStencilFunc(func, ref, mask);
+	}
+
+	public void glStencilMask (int mask) {
+		GL.glStencilMask(mask);
+	}
+
+	public void glStencilOp (int fail, int zfail, int zpass) {
+		GL.glStencilOp(fail, zfail, zpass);
+	}
+
+	public void glTexImage2D (int target, int level, int internalFormat, int width, int height, int border, int format, int type,
+		Buffer pixels) {
+		GL.glTexImage2D(target, level, internalFormat, width, height, border, format, type, pixels, getPosition(pixels));
+	}
+
+	public void glTexParameterf (int target, int pname, float param) {
+		GL.glTexParameterf(target, pname, param);
+	}
+
+	public void glTexSubImage2D (int target, int level, int xoffset, int yoffset, int width, int height, int format, int type,
+		Buffer pixels) {
+		GL.glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels, getPosition(pixels));
+	}
+
+	public void glViewport (int x, int y, int width, int height) {
+		GL.glViewport(x, y, width, height);
+	}
+
+	public void glAlphaFunc (int func, float ref) {
+		GL.glAlphaFunc(func, ref);
+	}
+
+	public void glClientActiveTexture (int texture) {
+		GL.glClientActiveTexture(texture);
+	}
+
+	public void glColor4f (float red, float green, float blue, float alpha) {
+		GL.glColor4f(red, green, blue, alpha);
+	}
+
+	public void glColorPointer (int size, int type, int stride, Buffer pointer) {
+		GL.glColorPointer(size, type, stride, pointer, getPosition(pointer));
+	}
+
+	public void glDeleteTextures (int n, int[] textures, int offset) {
+		GL.glDeleteTextures(n, toBuffer(textures, offset), 0);
+	}
+
+	public void glDisableClientState (int array) {
+		GL.glDisableClientState(array);
+	}
+
+	public void glEnableClientState (int array) {
+		GL.glEnableClientState(array);
+	}
+
+	public void glFogf (int pname, float param) {
+		GL.glFogf(pname, param);
+	}
+
+	public void glFogfv (int pname, float[] params, int offset) {
+		GL.glFogfv(pname, toBuffer(params, offset), 0);
+	}
+
+	public void glFogfv (int pname, FloatBuffer params) {
+		GL.glFogfv(pname, params, getPosition(params));
+	}
+
+	public void glFrustumf (float left, float right, float bottom, float top, float zNear, float zFar) {
+		GL.glFrustum(left, right, bottom, top, zNear, zFar);
+	}
+
+	public void glGenTextures (int n, int[] textures, int offset) {
+		IntBuffer buffer = toBuffer(textures, offset);
+		GL.glGenTextures(n, buffer, 0);
+		toArray(buffer, textures, offset);
+	}
+
+	public void glGetIntegerv (int pname, int[] params, int offset) {
+		IntBuffer buffer = toBuffer(params, offset);
+		GL.glGetIntegerv(pname, buffer, 0);
+		toArray(buffer, params, offset);
+	}
+
+	public void glLightModelf (int pname, float param) {
+		GL.glLightModelf(pname, param);
+	}
+
+	public void glLightModelfv (int pname, float[] params, int offset) {
+		GL.glLightModelfv(pname, toBuffer(params, offset), 0);
+	}
+
+	public void glLightModelfv (int pname, FloatBuffer params) {
+		GL.glLightModelfv(pname, params, getPosition(params));
+	}
+
+	public void glLightf (int light, int pname, float param) {
+		GL.glLightf(light, pname, param);
+	}
+
+	public void glLightfv (int light, int pname, float[] params, int offset) {
+		GL.glLightfv(light, pname, toBuffer(params, offset), 0);
+	}
+
+	public void glLightfv (int light, int pname, FloatBuffer params) {
+		GL.glLightfv(light, pname, params, getPosition(params));
+	}
+
+	public void glLoadIdentity () {
+		GL.glLoadIdentity();
+	}
+
+	public void glLoadMatrixf (float[] m, int offset) {
+		GL.glLoadMatrixf(toBuffer(m, offset), 0);
+	}
+
+	public void glLoadMatrixf (FloatBuffer m) {
+		GL.glLoadMatrixf(m, getPosition(m));
+	}
+
+	public void glLogicOp (int opcode) {
+		GL.glLogicOp(opcode);
+	}
+
+	public void glMaterialf (int face, int pname, float param) {
+		GL.glMaterialf(face, pname, param);
+	}
+
+	public void glMaterialfv (int face, int pname, float[] params, int offset) {
+		GL.glMaterialfv(face, pname, toBuffer(params, offset), 0);
+	}
+
+	public void glMaterialfv (int face, int pname, FloatBuffer params) {
+		GL.glMaterialfv(face, pname, params, getPosition(params));
+	}
+
+	public void glMatrixMode (int mode) {
+		GL.glMatrixMode(mode);
+	}
+
+	public void glMultMatrixf (float[] m, int offset) {
+		GL.glMultMatrixf(toBuffer(m, offset), 0);
+	}
+
+	public void glMultMatrixf (FloatBuffer m) {
+		GL.glMultMatrixf(m, getPosition(m));
+	}
+
+	public void glMultiTexCoord4f (int target, float s, float t, float r, float q) {
+		GL.glMultiTexCoord4f(target, s, t, r, q);
+	}
+
+	public void glNormal3f (float nx, float ny, float nz) {
+		GL.glNormal3f(nx, ny, nz);
+	}
+
+	public void glNormalPointer (int type, int stride, Buffer pointer) {
+		GL.glNormalPointer(type, stride, pointer, getPosition(pointer));
+	}
+
+	public void glOrthof (float left, float right, float bottom, float top, float zNear, float zFar) {
+		GL.glOrtho(left, right, bottom, top, zNear, zFar);
+	}
+
+	public void glPointSize (float size) {
+		GL.glPointSize(size);
+	}
+
+	public void glPopMatrix () {
+		GL.glPopMatrix();
+	}
+
+	public void glPushMatrix () {
+		GL.glPushMatrix();
+	}
+
+	public void glRotatef (float angle, float x, float y, float z) {
+		GL.glRotatef(angle, x, y, z);
+	}
+
+	public void glSampleCoverage (float value, boolean invert) {
+		GL.glSampleCoverage(value, invert);
+	}
+
+	public void glScalef (float x, float y, float z) {
+		GL.glScalef(x, y, z);
+	}
+
+	public void glShadeModel (int mode) {
+		GL.glShadeModel(mode);
+	}
+
+	public void glTexCoordPointer (int size, int type, int stride, Buffer pointer) {
+		GL.glTexCoordPointer(size, type, stride, pointer, getPosition(pointer));
+	}
+
+	public void glTexEnvf (int target, int pname, float param) {
+		GL.glTexEnvf(target, pname, param);
+	}
+
+	public void glTexEnvfv (int target, int pname, float[] params, int offset) {
+		GL.glTexEnvfv(target, pname, toBuffer(params, offset), 0);
+	}
+
+	public void glTexEnvfv (int target, int pname, FloatBuffer params) {
+		GL.glTexEnvfv(target, pname, params, getPosition(params));
+	}
+
+	public void glTranslatef (float x, float y, float z) {
+		GL.glTranslatef(x, y, z);
+	}
+
+	public void glVertexPointer (int size, int type, int stride, Buffer buffer) {
+		GL.glVertexPointer(size, type, stride, buffer, getPosition(buffer));
+	}
+
+	public void glPolygonMode (int face, int mode) {
+		GL.glPolygonMode(face, mode);
+	}
+}
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwGL11.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwGL11.java
new file mode 100644
index 0000000..19a09c1
--- /dev/null
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwGL11.java
@@ -0,0 +1,235 @@
+
+package com.badlogic.gdx.backends.jglfw;
+
+import static com.badlogic.gdx.backends.jglfw.JglfwUtil.*;
+import static com.badlogic.jglfw.utils.Memory.*;
+
+import com.badlogic.gdx.graphics.GL11;
+import com.badlogic.jglfw.gl.GL;
+
+import java.nio.Buffer;
+import java.nio.ByteBuffer;
+import java.nio.FloatBuffer;
+import java.nio.IntBuffer;
+
+public class JglfwGL11 extends JglfwGL10 implements GL11 {
+	public void glClipPlanef (int plane, float[] equation, int offset) {
+		GL.glClipPlane(plane, toBuffer(equation, offset), 0);
+	}
+
+	public void glClipPlanef (int plane, FloatBuffer equation) {
+		GL.glClipPlane(plane, equation, getPosition(equation));
+	}
+
+	public void glGetClipPlanef (int pname, float[] eqn, int offset) {
+		FloatBuffer buffer = toBuffer(eqn, offset);
+		GL.glGetClipPlane(pname, buffer, 0);
+		toArray(buffer, eqn, offset);
+	}
+
+	public void glGetClipPlanef (int pname, FloatBuffer eqn) {
+		GL.glGetClipPlane(pname, eqn, getPosition(eqn));
+	}
+
+	public void glGetFloatv (int pname, float[] params, int offset) {
+		FloatBuffer buffer = toBuffer(params, offset);
+		GL.glGetFloatv(pname, buffer, 0);
+		toArray(buffer, params, offset);
+	}
+
+	public void glGetFloatv (int pname, FloatBuffer params) {
+		GL.glGetFloatv(pname, params, getPosition(params));
+	}
+
+	public void glGetLightfv (int light, int pname, float[] params, int offset) {
+		FloatBuffer buffer = toBuffer(params, offset);
+		GL.glGetLightfv(light, pname, buffer, 0);
+		toArray(buffer, params, offset);
+	}
+
+	public void glGetLightfv (int light, int pname, FloatBuffer params) {
+		GL.glGetLightfv(light, pname, params, getPosition(params));
+	}
+
+	public void glGetMaterialfv (int face, int pname, float[] params, int offset) {
+		FloatBuffer buffer = toBuffer(params, offset);
+		GL.glGetMaterialfv(face, pname, buffer, 0);
+		toArray(buffer, params, offset);
+	}
+
+	public void glGetMaterialfv (int face, int pname, FloatBuffer params) {
+		GL.glGetMaterialfv(face, pname, params, getPosition(params));
+	}
+
+	public void glGetTexParameterfv (int target, int pname, float[] params, int offset) {
+		FloatBuffer buffer = toBuffer(params, offset);
+		GL.glGetTexParameterfv(target, pname, buffer, 0);
+		toArray(buffer, params, offset);
+	}
+
+	public void glGetTexParameterfv (int target, int pname, FloatBuffer params) {
+		GL.glGetTexParameterfv(target, pname, params, getPosition(params));
+	}
+
+	public void glPointParameterf (int pname, float param) {
+		GL.glPointParameterf(pname, param);
+	}
+
+	public void glPointParameterfv (int pname, float[] params, int offset) {
+		GL.glPointParameterfv(pname, toBuffer(params, offset), 0);
+	}
+
+	public void glPointParameterfv (int pname, FloatBuffer params) {
+		GL.glPointParameterfv(pname, params, getPosition(params));
+	}
+
+	public void glTexParameterfv (int target, int pname, float[] params, int offset) {
+		GL.glTexParameterfv(target, pname, toBuffer(params, offset), 0);
+	}
+
+	public void glTexParameterfv (int target, int pname, FloatBuffer params) {
+		GL.glTexParameterfv(target, pname, params, getPosition(params));
+	}
+
+	public void glBindBuffer (int target, int buffer) {
+		GL.glBindBuffer(target, buffer);
+	}
+
+	public void glBufferData (int target, int size, Buffer data, int usage) {
+		GL.glBufferData(target, size, data, getPosition(data), usage);
+	}
+
+	public void glBufferSubData (int target, int offset, int size, Buffer data) {
+		GL.glBufferSubData(target, offset, size, data, getPosition(data));
+	}
+
+	public void glColor4ub (byte red, byte green, byte blue, byte alpha) {
+		GL.glColor4ub(red, green, blue, alpha);
+	}
+
+	public void glDeleteBuffers (int n, int[] buffers, int offset) {
+		GL.glDeleteBuffers(n, toBuffer(buffers, offset), 0);
+	}
+
+	public void glDeleteBuffers (int n, IntBuffer buffers) {
+		GL.glDeleteBuffers(n, buffers, getPosition(buffers));
+	}
+
+	public void glGetBooleanv (int pname, boolean[] params, int offset) {
+		ByteBuffer buffer = toBuffer(params, offset);
+		GL.glGetBooleanv(pname, buffer, 0);
+		toArray(buffer, params, offset);
+	}
+
+	public void glGetBooleanv (int pname, IntBuffer params) {
+		GL.glGetBooleanv(pname, params, getPosition(params));
+	}
+
+	public void glGetBufferParameteriv (int target, int pname, int[] params, int offset) {
+		IntBuffer buffer = toBuffer(params, offset);
+		GL.glGetBufferParameteriv(target, pname, buffer, 0);
+		toArray(buffer, params, offset);
+	}
+
+	public void glGetBufferParameteriv (int target, int pname, IntBuffer params) {
+		GL.glGetBufferParameteriv(target, pname, params, getPosition(params));
+	}
+
+	public void glGenBuffers (int n, int[] buffers, int offset) {
+		IntBuffer buffer = toBuffer(buffers, offset);
+		GL.glGenBuffers(n, buffer, 0);
+		toArray(buffer, buffers, offset);
+	}
+
+	public void glGenBuffers (int n, IntBuffer buffers) {
+		GL.glGenBuffers(n, buffers, getPosition(buffers));
+	}
+
+	public void glGetPointerv (int pname, Buffer[] params) {
+		// FIXME
+		throw new UnsupportedOperationException();
+	}
+
+	public void glGetTexEnviv (int env, int pname, int[] params, int offset) {
+		IntBuffer buffer = toBuffer(params, offset);
+		GL.glGetTexEnviv(env, pname, buffer, 0);
+		toArray(buffer, params, offset);
+	}
+
+	public void glGetTexEnviv (int env, int pname, IntBuffer params) {
+		GL.glGetTexEnviv(env, pname, params, getPosition(params));
+	}
+
+	public void glGetTexParameteriv (int target, int pname, int[] params, int offset) {
+		IntBuffer buffer = toBuffer(params, offset);
+		GL.glGetTexParameteriv(target, pname, buffer, 0);
+		toArray(buffer, params, offset);
+	}
+
+	public void glGetTexParameteriv (int target, int pname, IntBuffer params) {
+		GL.glGetTexParameteriv(target, pname, params, getPosition(params));
+	}
+
+	public boolean glIsBuffer (int buffer) {
+		return GL.glIsBuffer(buffer);
+	}
+
+	public boolean glIsEnabled (int cap) {
+		return GL.glIsEnabled(cap);
+	}
+
+	public boolean glIsTexture (int texture) {
+		return GL.glIsTexture(texture);
+	}
+
+	public void glTexEnvi (int target, int pname, int param) {
+		GL.glTexEnvi(target, pname, param);
+	}
+
+	public void glTexEnviv (int target, int pname, int[] params, int offset) {
+		IntBuffer buffer = toBuffer(params, offset);
+		GL.glTexEnviv(target, pname, buffer, 0);
+		toArray(buffer, params, offset);
+	}
+
+	public void glTexEnviv (int target, int pname, IntBuffer params) {
+		GL.glTexEnviv(target, pname, params, getPosition(params));
+	}
+
+	public void glTexParameteri (int target, int pname, int param) {
+		GL.glTexParameteri(target, pname, param);
+	}
+
+	public void glTexParameteriv (int target, int pname, int[] params, int offset) {
+		GL.glTexParameteriv(target, pname, toBuffer(params, offset), 0);
+	}
+
+	public void glTexParameteriv (int target, int pname, IntBuffer params) {
+		GL.glTexParameteriv(target, pname, params, getPosition(params));
+	}
+
+	public void glPointSizePointerOES (int type, int stride, Buffer pointer) {
+		// FIXME
+		throw new UnsupportedOperationException();
+	}
+
+	public void glVertexPointer (int size, int type, int stride, int pointer) {
+		GL.glVertexPointer(size, type, stride, pointer);
+	}
+
+	public void glColorPointer (int size, int type, int stride, int pointer) {
+		GL.glColorPointer(size, type, stride, pointer);
+	}
+
+	public void glNormalPointer (int type, int stride, int pointer) {
+		GL.glNormalPointer(type, stride, pointer);
+	}
+
+	public void glTexCoordPointer (int size, int type, int stride, int pointer) {
+		GL.glTexCoordPointer(size, type, stride, pointer);
+	}
+
+	public void glDrawElements (int mode, int count, int type, int indices) {
+		GL.glDrawElements(mode, count, type, indices);
+	}
+}
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwGL20.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwGL20.java
new file mode 100644
index 0000000..1283a71
--- /dev/null
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwGL20.java
@@ -0,0 +1,593 @@
+
+package com.badlogic.gdx.backends.jglfw;
+
+import static com.badlogic.jglfw.utils.Memory.*;
+
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.jglfw.gl.GL;
+
+import java.nio.Buffer;
+import java.nio.FloatBuffer;
+import java.nio.IntBuffer;
+
+public class JglfwGL20 implements GL20 {
+	public void glActiveTexture (int texture) {
+		GL.glActiveTexture(texture);
+	}
+
+	public void glBindTexture (int target, int texture) {
+		GL.glBindTexture(target, texture);
+	}
+
+	public void glBlendFunc (int sfactor, int dfactor) {
+		GL.glBlendFunc(sfactor, dfactor);
+	}
+
+	public void glClear (int mask) {
+		GL.glClear(mask);
+	}
+
+	public void glClearColor (float red, float green, float blue, float alpha) {
+		GL.glClearColor(red, green, blue, alpha);
+	}
+
+	public void glClearDepthf (float depth) {
+		GL.glClearDepthf(depth);
+	}
+
+	public void glClearStencil (int s) {
+		GL.glClearStencil(s);
+	}
+
+	public void glColorMask (boolean red, boolean green, boolean blue, boolean alpha) {
+		GL.glColorMask(red, green, blue, alpha);
+	}
+
+	public void glCompressedTexImage2D (int target, int level, int internalformat, int width, int height, int border,
+		int imageSize, Buffer data) {
+		GL.glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data, getPosition(data));
+	}
+
+	public void glCompressedTexSubImage2D (int target, int level, int xoffset, int yoffset, int width, int height, int format,
+		int imageSize, Buffer data) {
+		GL.glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data, getPosition(data));
+	}
+
+	public void glCopyTexImage2D (int target, int level, int internalformat, int x, int y, int width, int height, int border) {
+		GL.glCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
+	}
+
+	public void glCopyTexSubImage2D (int target, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
+		GL.glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
+	}
+
+	public void glCullFace (int mode) {
+		GL.glCullFace(mode);
+	}
+
+	public void glDeleteTextures (int n, IntBuffer textures) {
+		GL.glDeleteTextures(n, textures, getPosition(textures));
+	}
+
+	public void glDepthFunc (int func) {
+		GL.glDepthFunc(func);
+	}
+
+	public void glDepthMask (boolean flag) {
+		GL.glDepthMask(flag);
+	}
+
+	public void glDepthRangef (float zNear, float zFar) {
+		GL.glDepthRangef(zNear, zFar);
+	}
+
+	public void glDisable (int cap) {
+		GL.glDisable(cap);
+	}
+
+	public void glDrawArrays (int mode, int first, int count) {
+		GL.glDrawArrays(mode, first, count);
+	}
+
+	public void glDrawElements (int mode, int count, int type, Buffer indices) {
+		GL.glDrawElements(mode, count, type, indices, getPosition(indices));
+	}
+
+	public void glEnable (int cap) {
+		GL.glEnable(cap);
+	}
+
+	public void glFinish () {
+		GL.glFinish();
+	}
+
+	public void glFlush () {
+		GL.glFlush();
+	}
+
+	public void glFrontFace (int mode) {
+		GL.glFrontFace(mode);
+	}
+
+	public void glGenTextures (int n, IntBuffer textures) {
+		GL.glGenTextures(n, textures, getPosition(textures));
+	}
+
+	public int glGetError () {
+		return GL.glGetError();
+	}
+
+	public void glGetIntegerv (int pname, IntBuffer params) {
+		GL.glGetIntegerv(pname, params, getPosition(params));
+	}
+
+	public String glGetString (int name) {
+		return GL.glGetString(name);
+	}
+
+	public void glHint (int target, int mode) {
+		GL.glHint(target, mode);
+	}
+
+	public void glLineWidth (float width) {
+		GL.glLineWidth(width);
+	}
+
+	public void glPixelStorei (int pname, int param) {
+		GL.glPixelStorei(pname, param);
+	}
+
+	public void glPolygonOffset (float factor, float units) {
+		GL.glPolygonOffset(factor, units);
+	}
+
+	public void glReadPixels (int x, int y, int width, int height, int format, int type, Buffer pixels) {
+		GL.glReadPixels(x, y, width, height, format, type, pixels, getPosition(pixels));
+	}
+
+	public void glScissor (int x, int y, int width, int height) {
+		GL.glScissor(x, y, width, height);
+	}
+
+	public void glStencilFunc (int func, int ref, int mask) {
+		GL.glStencilFunc(func, ref, mask);
+	}
+
+	public void glStencilMask (int mask) {
+		GL.glStencilMask(mask);
+	}
+
+	public void glStencilOp (int fail, int zfail, int zpass) {
+		GL.glStencilOp(fail, zfail, zpass);
+	}
+
+	public void glTexImage2D (int target, int level, int internalFormat, int width, int height, int border, int format, int type,
+		Buffer pixels) {
+		GL.glTexImage2D(target, level, internalFormat, width, height, border, format, type, pixels, getPosition(pixels));
+	}
+
+	public void glTexParameterf (int target, int pname, float param) {
+		GL.glTexParameterf(target, pname, param);
+	}
+
+	public void glTexSubImage2D (int target, int level, int xoffset, int yoffset, int width, int height, int format, int type,
+		Buffer pixels) {
+		GL.glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels, getPosition(pixels));
+	}
+
+	public void glViewport (int x, int y, int width, int height) {
+		GL.glViewport(x, y, width, height);
+	}
+
+	public void glGetFloatv (int pname, FloatBuffer params) {
+		GL.glGetFloatv(pname, params, getPosition(params));
+	}
+
+	public void glGetTexParameterfv (int target, int pname, FloatBuffer params) {
+		GL.glGetTexParameterfv(target, pname, params, getPosition(params));
+	}
+
+	public void glTexParameterfv (int target, int pname, FloatBuffer params) {
+		GL.glTexParameterfv(target, pname, params, getPosition(params));
+	}
+
+	public void glBindBuffer (int target, int buffer) {
+		GL.glBindBuffer(target, buffer);
+	}
+
+	public void glBufferData (int target, int size, Buffer data, int usage) {
+		GL.glBufferData(target, size, data, getPosition(data), usage);
+	}
+
+	public void glBufferSubData (int target, int offset, int size, Buffer data) {
+		GL.glBufferSubData(target, offset, size, data, getPosition(data));
+	}
+
+	public void glDeleteBuffers (int n, IntBuffer buffers) {
+		GL.glDeleteBuffers(n, buffers, getPosition(buffers));
+	}
+
+	public void glGetBufferParameteriv (int target, int pname, IntBuffer params) {
+		GL.glGetBufferParameteriv(target, pname, params, getPosition(params));
+	}
+
+	public void glGenBuffers (int n, IntBuffer buffers) {
+		GL.glGenBuffers(n, buffers, getPosition(buffers));
+	}
+
+	public void glGetTexParameteriv (int target, int pname, IntBuffer params) {
+		GL.glGetTexParameteriv(target, pname, params, getPosition(params));
+	}
+
+	public boolean glIsBuffer (int buffer) {
+		return GL.glIsBuffer(buffer);
+	}
+
+	public boolean glIsEnabled (int cap) {
+		return GL.glIsEnabled(cap);
+	}
+
+	public boolean glIsTexture (int texture) {
+		return GL.glIsTexture(texture);
+	}
+
+	public void glTexParameteri (int target, int pname, int param) {
+		GL.glTexParameteri(target, pname, param);
+	}
+
+	public void glTexParameteriv (int target, int pname, IntBuffer params) {
+		GL.glTexParameteriv(target, pname, params, getPosition(params));
+	}
+
+	public void glDrawElements (int mode, int count, int type, int indices) {
+		GL.glDrawElements(mode, count, type, indices);
+	}
+
+	public void glAttachShader (int program, int shader) {
+		GL.glAttachShader(program, shader);
+	}
+
+	public void glBindAttribLocation (int program, int index, String name) {
+		GL.glBindAttribLocation(program, index, name);
+	}
+
+	public void glBindFramebuffer (int target, int framebuffer) {
+		GL.glBindFramebufferEXT(target, framebuffer);
+	}
+
+	public void glBindRenderbuffer (int target, int renderbuffer) {
+		GL.glBindRenderbufferEXT(target, renderbuffer);
+	}
+
+	public void glBlendColor (float red, float green, float blue, float alpha) {
+		GL.glBlendColor(red, green, blue, alpha);
+	}
+
+	public void glBlendEquation (int mode) {
+		GL.glBlendEquation(mode);
+	}
+
+	public void glBlendEquationSeparate (int modeRGB, int modeAlpha) {
+		GL.glBlendEquationSeparate(modeRGB, modeAlpha);
+	}
+
+	public void glBlendFuncSeparate (int srcRGB, int dstRGB, int srcAlpha, int dstAlpha) {
+		GL.glBlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
+	}
+
+	public int glCheckFramebufferStatus (int target) {
+		return GL.glCheckFramebufferStatusEXT(target);
+	}
+
+	public void glCompileShader (int shader) {
+		GL.glCompileShader(shader);
+	}
+
+	public int glCreateProgram () {
+		return GL.glCreateProgram();
+	}
+
+	public int glCreateShader (int type) {
+		return GL.glCreateShader(type);
+	}
+
+	public void glDeleteFramebuffers (int n, IntBuffer framebuffers) {
+		GL.glDeleteFramebuffersEXT(n, framebuffers, getPosition(framebuffers));
+	}
+
+	public void glDeleteProgram (int program) {
+		GL.glDeleteProgram(program);
+	}
+
+	public void glDeleteRenderbuffers (int n, IntBuffer renderbuffers) {
+		GL.glDeleteRenderbuffersEXT(n, renderbuffers, getPosition(renderbuffers));
+	}
+
+	public void glDeleteShader (int shader) {
+		GL.glDeleteShader(shader);
+	}
+
+	public void glDetachShader (int program, int shader) {
+		GL.glDetachShader(program, shader);
+	}
+
+	public void glDisableVertexAttribArray (int index) {
+		GL.glDisableVertexAttribArray(index);
+	}
+
+	public void glEnableVertexAttribArray (int index) {
+		GL.glEnableVertexAttribArray(index);
+	}
+
+	public void glFramebufferRenderbuffer (int target, int attachment, int renderbuffertarget, int renderbuffer) {
+		GL.glFramebufferRenderbufferEXT(target, attachment, renderbuffertarget, renderbuffer);
+	}
+
+	public void glFramebufferTexture2D (int target, int attachment, int textarget, int texture, int level) {
+		GL.glFramebufferTexture2DEXT(target, attachment, textarget, texture, level);
+	}
+
+	public void glGenerateMipmap (int target) {
+		GL.glGenerateMipmapEXT(target);
+	}
+
+	public void glGenFramebuffers (int n, IntBuffer framebuffers) {
+		GL.glGenFramebuffersEXT(n, framebuffers, getPosition(framebuffers));
+	}
+
+	public void glGenRenderbuffers (int n, IntBuffer renderbuffers) {
+		GL.glGenRenderbuffersEXT(n, renderbuffers, getPosition(renderbuffers));
+	}
+
+	public String glGetActiveAttrib (int program, int index, IntBuffer size, Buffer type) {
+		return GL.glGetActiveAttrib(program, index, size, getPosition(size), type, getPosition(type));
+	}
+
+	public String glGetActiveUniform (int program, int index, IntBuffer size, Buffer type) {
+		return GL.glGetActiveUniform(program, index, size, getPosition(size), type, getPosition(type));
+	}
+
+	public void glGetAttachedShaders (int program, int maxcount, Buffer count, IntBuffer shaders) {
+		GL.glGetAttachedShaders(program, maxcount, count, getPosition(count), shaders, getPosition(shaders));
+	}
+
+	public int glGetAttribLocation (int program, String name) {
+		return GL.glGetAttribLocation(program, name);
+	}
+
+	public void glGetBooleanv (int pname, Buffer params) {
+		GL.glGetBooleanv(pname, params, getPosition(params));
+	}
+
+	public void glGetFramebufferAttachmentParameteriv (int target, int attachment, int pname, IntBuffer params) {
+		GL.glGetFramebufferAttachmentParameterivEXT(target, attachment, pname, params, getPosition(params));
+	}
+
+	public void glGetProgramiv (int program, int pname, IntBuffer params) {
+		GL.glGetProgramiv(program, pname, params, getPosition(params));
+	}
+
+	public String glGetProgramInfoLog (int program) {
+		return GL.glGetProgramInfoLog(program);
+	}
+
+	public void glGetRenderbufferParameteriv (int target, int pname, IntBuffer params) {
+		GL.glGetRenderbufferParameterivEXT(target, pname, params, getPosition(params));
+	}
+
+	public void glGetShaderiv (int shader, int pname, IntBuffer params) {
+		GL.glGetShaderiv(shader, pname, params, getPosition(params));
+	}
+
+	public String glGetShaderInfoLog (int shader) {
+		return GL.glGetShaderInfoLog(shader);
+	}
+
+	public void glGetShaderPrecisionFormat (int shadertype, int precisiontype, IntBuffer range, IntBuffer precision) {
+		GL.glGetShaderPrecisionFormat(shadertype, precisiontype, range, getPosition(range), precision, getPosition(precision));
+	}
+
+	public void glGetShaderSource (int shader, int bufsize, Buffer length, String source) {
+		throw new UnsupportedOperationException("Not implemented");
+	}
+
+	public void glGetUniformfv (int program, int location, FloatBuffer params) {
+		GL.glGetUniformfv(program, location, params, getPosition(params));
+	}
+
+	public void glGetUniformiv (int program, int location, IntBuffer params) {
+		GL.glGetUniformiv(program, location, params, getPosition(params));
+	}
+
+	public int glGetUniformLocation (int program, String name) {
+		return GL.glGetUniformLocation(program, name);
+	}
+
+	public void glGetVertexAttribfv (int index, int pname, FloatBuffer params) {
+		GL.glGetVertexAttribfv(index, pname, params, getPosition(params));
+	}
+
+	public void glGetVertexAttribiv (int index, int pname, IntBuffer params) {
+		GL.glGetVertexAttribiv(index, pname, params, getPosition(params));
+	}
+
+	public void glGetVertexAttribPointerv (int index, int pname, Buffer pointer) {
+		GL.glGetVertexAttribPointerv(index, pname, pointer, getPosition(pointer));
+	}
+
+	public boolean glIsFramebuffer (int framebuffer) {
+		return GL.glIsFramebufferEXT(framebuffer);
+	}
+
+	public boolean glIsProgram (int program) {
+		return GL.glIsProgram(program);
+	}
+
+	public boolean glIsRenderbuffer (int renderbuffer) {
+		return GL.glIsRenderbufferEXT(renderbuffer);
+	}
+
+	public boolean glIsShader (int shader) {
+		return GL.glIsShader(shader);
+	}
+
+	public void glLinkProgram (int program) {
+		GL.glLinkProgram(program);
+	}
+
+	public void glReleaseShaderCompiler () {
+		GL.glReleaseShaderCompiler();
+	}
+
+	public void glRenderbufferStorage (int target, int internalformat, int width, int height) {
+		GL.glRenderbufferStorageEXT(target, internalformat, width, height);
+	}
+
+	public void glSampleCoverage (float value, boolean invert) {
+		GL.glSampleCoverage(value, invert);
+	}
+
+	public void glShaderBinary (int n, IntBuffer shaders, int binaryformat, Buffer binary, int length) {
+		GL.glShaderBinary(n, shaders, getPosition(shaders), binaryformat, binary, getPosition(binary), length);
+	}
+
+	public void glShaderSource (int shader, String string) {
+		GL.glShaderSource(shader, string);
+	}
+
+	public void glStencilFuncSeparate (int face, int func, int ref, int mask) {
+		GL.glStencilFuncSeparate(face, func, ref, mask);
+	}
+
+	public void glStencilMaskSeparate (int face, int mask) {
+		GL.glStencilMaskSeparate(face, mask);
+	}
+
+	public void glStencilOpSeparate (int face, int fail, int zfail, int zpass) {
+		GL.glStencilOpSeparate(face, fail, zfail, zpass);
+	}
+
+	public void glUniform1f (int location, float x) {
+		GL.glUniform1f(location, x);
+	}
+
+	public void glUniform1fv (int location, int count, FloatBuffer v) {
+		GL.glUniform1fv(location, count, v, getPosition(v));
+	}
+
+	public void glUniform1i (int location, int x) {
+		GL.glUniform1i(location, x);
+	}
+
+	public void glUniform1iv (int location, int count, IntBuffer v) {
+		GL.glUniform1iv(location, count, v, getPosition(v));
+	}
+
+	public void glUniform2f (int location, float x, float y) {
+		GL.glUniform2f(location, x, y);
+	}
+
+	public void glUniform2fv (int location, int count, FloatBuffer v) {
+		GL.glUniform2fv(location, count, v, getPosition(v));
+	}
+
+	public void glUniform2i (int location, int x, int y) {
+		GL.glUniform2i(location, x, y);
+	}
+
+	public void glUniform2iv (int location, int count, IntBuffer v) {
+		GL.glUniform2iv(location, count, v, getPosition(v));
+	}
+
+	public void glUniform3f (int location, float x, float y, float z) {
+		GL.glUniform3f(location, x, y, z);
+	}
+
+	public void glUniform3fv (int location, int count, FloatBuffer v) {
+		GL.glUniform3fv(location, count, v, getPosition(v));
+	}
+
+	public void glUniform3i (int location, int x, int y, int z) {
+		GL.glUniform3i(location, x, y, z);
+	}
+
+	public void glUniform3iv (int location, int count, IntBuffer v) {
+		GL.glUniform3iv(location, count, v, getPosition(v));
+	}
+
+	public void glUniform4f (int location, float x, float y, float z, float w) {
+		GL.glUniform4f(location, x, y, z, w);
+	}
+
+	public void glUniform4fv (int location, int count, FloatBuffer v) {
+		GL.glUniform4fv(location, count, v, getPosition(v));
+	}
+
+	public void glUniform4i (int location, int x, int y, int z, int w) {
+		GL.glUniform4i(location, x, y, z, w);
+	}
+
+	public void glUniform4iv (int location, int count, IntBuffer v) {
+		GL.glUniform4iv(location, count, v, getPosition(v));
+	}
+
+	public void glUniformMatrix2fv (int location, int count, boolean transpose, FloatBuffer value) {
+		GL.glUniformMatrix2fv(location, count, transpose, value, getPosition(value));
+	}
+
+	public void glUniformMatrix3fv (int location, int count, boolean transpose, FloatBuffer value) {
+		GL.glUniformMatrix3fv(location, count, transpose, value, getPosition(value));
+	}
+
+	public void glUniformMatrix4fv (int location, int count, boolean transpose, FloatBuffer value) {
+		GL.glUniformMatrix4fv(location, count, transpose, value, getPosition(value));
+	}
+
+	public void glUseProgram (int program) {
+		GL.glUseProgram(program);
+	}
+
+	public void glValidateProgram (int program) {
+		GL.glValidateProgram(program);
+	}
+
+	public void glVertexAttrib1f (int indx, float x) {
+		GL.glVertexAttrib1f(indx, x);
+	}
+
+	public void glVertexAttrib1fv (int indx, FloatBuffer values) {
+		GL.glVertexAttrib1fv(indx, values, getPosition(values));
+	}
+
+	public void glVertexAttrib2f (int indx, float x, float y) {
+		GL.glVertexAttrib2f(indx, x, y);
+	}
+
+	public void glVertexAttrib2fv (int indx, FloatBuffer values) {
+		GL.glVertexAttrib2fv(indx, values, getPosition(values));
+	}
+
+	public void glVertexAttrib3f (int indx, float x, float y, float z) {
+		GL.glVertexAttrib3f(indx, x, y, z);
+	}
+
+	public void glVertexAttrib3fv (int indx, FloatBuffer values) {
+		GL.glVertexAttrib3fv(indx, values, getPosition(values));
+	}
+
+	public void glVertexAttrib4f (int indx, float x, float y, float z, float w) {
+		GL.glVertexAttrib4f(indx, x, y, z, w);
+	}
+
+	public void glVertexAttrib4fv (int indx, FloatBuffer values) {
+		GL.glVertexAttrib4fv(indx, values, getPosition(values));
+	}
+
+	public void glVertexAttribPointer (int indx, int size, int type, boolean normalized, int stride, Buffer ptr) {
+		GL.glVertexAttribPointer(indx, size, type, normalized, stride, ptr, getPosition(ptr));
+	}
+
+	public void glVertexAttribPointer (int indx, int size, int type, boolean normalized, int stride, int ptr) {
+		GL.glVertexAttribPointer(indx, size, type, normalized, stride, ptr);
+	}
+}
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwGraphics.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwGraphics.java
new file mode 100644
index 0000000..232d1b7
--- /dev/null
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwGraphics.java
@@ -0,0 +1,393 @@
+
+package com.badlogic.gdx.backends.jglfw;
+
+import static com.badlogic.jglfw.Glfw.*;
+
+import com.badlogic.gdx.ApplicationListener;
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.Graphics;
+import com.badlogic.gdx.graphics.Color;
+import com.badlogic.gdx.graphics.GL10;
+import com.badlogic.gdx.graphics.GL11;
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.gdx.graphics.GLCommon;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+import com.badlogic.jglfw.GlfwVideoMode;
+import com.badlogic.jglfw.gl.GL;
+
+import java.awt.Toolkit;
+
+/** An implementation of the {@link Graphics} interface based on GLFW.
+ * @author Nathan Sweet */
+public class JglfwGraphics implements Graphics {
+	static int glMajorVersion, glMinorVersion;
+
+	long window;
+	private boolean fullscreen;
+	private long fullscreenMonitor;
+	private String title;
+	private boolean resizable, undecorated;
+	private BufferFormat bufferFormat;
+	private boolean vSync;
+	private int x, y, width, height;
+	private boolean visible;
+	private Color initialBackgroundColor;
+	private volatile boolean isContinuous = true, renderRequested;
+	volatile boolean foreground, minimized;
+
+	private float deltaTime;
+	private long frameStart, lastTime = -1;
+	private int frames, fps;
+
+	private GLCommon gl;
+	private JglfwGL10 gl10;
+	private JglfwGL11 gl11;
+	private JglfwGL20 gl20;
+
+	public JglfwGraphics (JglfwApplicationConfiguration config) {
+		// Store values from config.
+		bufferFormat = new BufferFormat(config.r, config.g, config.b, config.a, config.depth, config.stencil, config.samples, false);
+		title = config.title;
+		resizable = config.resizable;
+		undecorated = config.undecorated;
+		x = config.x;
+		y = config.y;
+		vSync = config.vSync;
+		initialBackgroundColor = config.initialBackgroundColor;
+		if (config.fullscreenMonitorIndex != -1) { // Use monitor specified in config if it is valid.
+			long[] monitors = glfwGetMonitors();
+			if (config.fullscreenMonitorIndex < monitors.length) fullscreenMonitor = monitors[config.fullscreenMonitorIndex];
+		}
+
+		// Create window.
+		if (!createWindow(config.width, config.height, config.fullscreen)) {
+			throw new GdxRuntimeException("Unable to create window: " + config.width + "x" + config.height + ", fullscreen: "
+				+ config.fullscreen);
+		}
+
+		// Create GL.
+		String version = GL.glGetString(GL11.GL_VERSION);
+		glMajorVersion = Integer.parseInt("" + version.charAt(0));
+		glMinorVersion = Integer.parseInt("" + version.charAt(2));
+		if (config.useGL20 && (glMajorVersion >= 2 || version.contains("2.1"))) { // special case for MESA, wtf...
+			gl20 = new JglfwGL20();
+			gl = gl20;
+		} else {
+			gl20 = null;
+			if (glMajorVersion == 1 && glMinorVersion < 5)
+				gl10 = new JglfwGL10();
+			else {
+				gl11 = new JglfwGL11();
+				gl10 = gl11;
+			}
+			gl = gl10;
+		}
+		Gdx.gl = gl;
+		Gdx.gl10 = gl10;
+		Gdx.gl11 = gl11;
+		Gdx.gl20 = gl20;
+
+		if (!config.hidden) show();
+	}
+
+	private boolean createWindow (int width, int height, boolean fullscreen) {
+		if (fullscreen && fullscreenMonitor == 0) fullscreenMonitor = getWindowMonitor();
+
+		glfwWindowHint(GLFW_VISIBLE, 0);
+		glfwWindowHint(GLFW_RESIZABLE, resizable ? 1 : 0);
+		glfwWindowHint(GLFW_UNDECORATED, undecorated ? 1 : 0);
+		glfwWindowHint(GLFW_RED_BITS, bufferFormat.r);
+		glfwWindowHint(GLFW_GREEN_BITS, bufferFormat.g);
+		glfwWindowHint(GLFW_BLUE_BITS, bufferFormat.b);
+		glfwWindowHint(GLFW_ALPHA_BITS, bufferFormat.a);
+		glfwWindowHint(GLFW_DEPTH_BITS, bufferFormat.depth);
+		glfwWindowHint(GLFW_STENCIL_BITS, bufferFormat.stencil);
+		glfwWindowHint(GLFW_SAMPLES, bufferFormat.samples);
+
+		boolean mouseCaptured = window != 0 && glfwGetInputMode(window, GLFW_CURSOR_MODE) == GLFW_CURSOR_CAPTURED;
+
+		long oldWindow = window;
+		long newWindow = glfwCreateWindow(width, height, title, fullscreen ? fullscreenMonitor : 0, oldWindow);
+		if (newWindow == 0) return false;
+		if (oldWindow != 0) glfwDestroyWindow(oldWindow);
+		window = newWindow;
+		this.width = Math.max(1, width);
+		this.height = Math.max(1, height);
+
+		this.fullscreen = fullscreen;
+		if (!fullscreen) {
+			if (x == -1 || y == -1) {
+				DisplayMode mode = getDesktopDisplayMode();
+				x = (mode.width - width) / 2;
+				y = (mode.height - height) / 2;
+			}
+			glfwSetWindowPos(window, x, y);
+		}
+
+		if (!mouseCaptured) glfwSetInputMode(window, GLFW_CURSOR_MODE, GLFW_CURSOR_NORMAL); // Prevent fullscreen from taking mouse.
+
+		glfwMakeContextCurrent(newWindow);
+		setVSync(vSync);
+		if (visible) glfwShowWindow(window);
+
+		return true;
+	}
+
+	void frameStart (long time) {
+		if (lastTime == -1) lastTime = time;
+		deltaTime = (time - lastTime) / 1000000000.0f;
+		lastTime = time;
+
+		if (time - frameStart >= 1000000000) {
+			fps = frames;
+			frames = 0;
+			frameStart = time;
+		}
+		frames++;
+	}
+
+	void sizeChanged (int width, int height) {
+		width = Math.max(1, width);
+		height = Math.max(1, height);
+		this.width = width;
+		this.height = height;
+		Gdx.gl.glViewport(0, 0, width, height);
+		ApplicationListener listener = Gdx.app.getApplicationListener();
+		if (listener != null) listener.resize(width, height);
+		requestRendering();
+	}
+
+	void positionChanged (int x, int y) {
+		this.x = x;
+		this.y = y;
+	}
+
+	public boolean isGL11Available () {
+		return gl11 != null;
+	}
+
+	public boolean isGL20Available () {
+		return gl20 != null;
+	}
+
+	public GLCommon getGLCommon () {
+		return gl;
+	}
+
+	public GL10 getGL10 () {
+		return gl10;
+	}
+
+	public GL11 getGL11 () {
+		return gl11;
+	}
+
+	public GL20 getGL20 () {
+		return gl20;
+	}
+
+	public int getWidth () {
+		return width;
+	}
+
+	public int getHeight () {
+		return height;
+	}
+
+	public float getDeltaTime () {
+		return deltaTime;
+	}
+
+	public float getRawDeltaTime () {
+		return deltaTime;
+	}
+
+	public int getFramesPerSecond () {
+		return fps;
+	}
+
+	public GraphicsType getType () {
+		return GraphicsType.JGLFW;
+	}
+
+	public float getPpiX () {
+		// return getWidth() / (glfwGetMonitorPhysicalWidth(getWindowMonitor()) * 0.03937f); // mm to inches
+		return Toolkit.getDefaultToolkit().getScreenResolution();
+	}
+
+	public float getPpiY () {
+		// return getHeight() / (glfwGetMonitorPhysicalHeight(getWindowMonitor()) * 0.03937f); // mm to inches
+		return Toolkit.getDefaultToolkit().getScreenResolution();
+	}
+
+	public float getPpcX () {
+		// return getWidth() / (glfwGetMonitorPhysicalWidth(getWindowMonitor()) / 10); // mm to cm
+		return Toolkit.getDefaultToolkit().getScreenResolution() / 2.54f;
+	}
+
+	public float getPpcY () {
+		// return getHeight() / (glfwGetMonitorPhysicalHeight(getWindowMonitor()) / 10); // mm to cm
+		return Toolkit.getDefaultToolkit().getScreenResolution() / 2.54f;
+	}
+
+	public float getDensity () {
+		// long monitor = getWindowMonitor();
+		// float mmWidth = glfwGetMonitorPhysicalWidth(monitor);
+		// float mmHeight = glfwGetMonitorPhysicalHeight(monitor);
+		// float inches = (float)Math.sqrt(mmWidth * mmWidth + mmHeight * mmHeight) * 0.03937f; // mm to inches
+		// float pixelWidth = getWidth();
+		// float pixelHeight = getHeight();
+		// float pixels = (float)Math.sqrt(pixelWidth * pixelWidth + pixelHeight * pixelHeight);
+		// float diagonalPpi = pixels / inches;
+		// return diagonalPpi / 160f;
+		return Toolkit.getDefaultToolkit().getScreenResolution() / 160f;
+	}
+
+	public boolean supportsDisplayModeChange () {
+		return true;
+	}
+
+	private long getWindowMonitor () {
+		if (window != 0) {
+			long monitor = glfwGetWindowMonitor(window);
+			if (monitor != 0) return monitor;
+		}
+		return glfwGetPrimaryMonitor();
+	}
+
+	public DisplayMode[] getDisplayModes () {
+		Array<DisplayMode> modes = new Array();
+		for (GlfwVideoMode mode : glfwGetVideoModes(getWindowMonitor()))
+			modes.add(new JglfwDisplayMode(mode.width, mode.height, 0, mode.redBits + mode.greenBits + mode.blueBits));
+		return modes.toArray(DisplayMode.class);
+	}
+
+	public DisplayMode getDesktopDisplayMode () {
+		GlfwVideoMode mode = glfwGetVideoMode(getWindowMonitor());
+		return new JglfwDisplayMode(mode.width, mode.height, 0, mode.redBits + mode.greenBits + mode.blueBits);
+	}
+
+	public boolean setDisplayMode (DisplayMode displayMode) {
+		bufferFormat = new BufferFormat( //
+			displayMode.bitsPerPixel == 16 ? 5 : 8, //
+			displayMode.bitsPerPixel == 16 ? 6 : 8, //
+			displayMode.bitsPerPixel == 16 ? 6 : 8, //
+			bufferFormat.a, bufferFormat.depth, bufferFormat.stencil, bufferFormat.samples, false);
+		boolean success = createWindow(displayMode.width, displayMode.height, fullscreen);
+		if (success && fullscreen) sizeChanged(displayMode.width, displayMode.height);
+		return success;
+	}
+
+	public boolean setDisplayMode (int width, int height, boolean fullscreen) {
+		if (fullscreen || this.fullscreen) {
+			boolean success = createWindow(width, height, fullscreen);
+			if (success && fullscreen) sizeChanged(width, height);
+			return success;
+		}
+
+		glfwSetWindowSize(window, width, height);
+		return true;
+	}
+
+	public void setTitle (String title) {
+		if (title == null) title = "";
+		glfwSetWindowTitle(window, title);
+		this.title = title;
+	}
+
+	public void setVSync (boolean vsync) {
+		this.vSync = vsync;
+		glfwSwapInterval(vsync ? 1 : 0);
+	}
+
+	public BufferFormat getBufferFormat () {
+		return bufferFormat;
+	}
+
+	public boolean supportsExtension (String extension) {
+		return glfwExtensionSupported(extension);
+	}
+
+	public void setContinuousRendering (boolean isContinuous) {
+		this.isContinuous = isContinuous;
+	}
+
+	public boolean isContinuousRendering () {
+		return isContinuous;
+	}
+
+	public void requestRendering () {
+		renderRequested = true;
+	}
+
+	public boolean isFullscreen () {
+		return fullscreen;
+	}
+
+	/** Returns the JGLFW window handle. Note this should not be stored externally as it may change if the window is recreated to
+	 * enter/exit fullscreen. */
+	public long getWindow () {
+		return window;
+	}
+
+	public int getX () {
+		return x;
+	}
+
+	public int getY () {
+		return y;
+	}
+
+	public void setPosition (int x, int y) {
+		glfwSetWindowPos(window, x, y);
+	}
+
+	public void hide () {
+		visible = false;
+		glfwHideWindow(window);
+	}
+
+	public void show () {
+		visible = true;
+		glfwShowWindow(window);
+
+		Gdx.gl.glClearColor(initialBackgroundColor.r, initialBackgroundColor.g, initialBackgroundColor.b, initialBackgroundColor.a);
+		Gdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
+		glfwSwapBuffers(window);
+	}
+
+	public boolean isHidden () {
+		return !visible;
+	}
+
+	public boolean isMinimized () {
+		return minimized;
+	}
+
+	public boolean isForeground () {
+		return foreground;
+	}
+
+	public void minimize () {
+		glfwIconifyWindow(window);
+	}
+
+	public void restore () {
+		glfwRestoreWindow(window);
+	}
+
+	boolean shouldRender () {
+		try {
+			return renderRequested || isContinuous;
+		} finally {
+			renderRequested = false;
+		}
+	}
+
+	static class JglfwDisplayMode extends DisplayMode {
+		protected JglfwDisplayMode (int width, int height, int refreshRate, int bitsPerPixel) {
+			super(width, height, refreshRate, bitsPerPixel);
+		}
+	}
+}
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwInput.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwInput.java
new file mode 100644
index 0000000..71f2a1b
--- /dev/null
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwInput.java
@@ -0,0 +1,781 @@
+
+package com.badlogic.gdx.backends.jglfw;
+
+import static com.badlogic.jglfw.Glfw.*;
+
+import com.badlogic.gdx.Input;
+import com.badlogic.gdx.InputProcessor;
+import com.badlogic.gdx.InputProcessorQueue;
+import com.badlogic.jglfw.GlfwCallbackAdapter;
+
+import java.awt.Color;
+import java.awt.FlowLayout;
+import java.awt.event.WindowEvent;
+import java.awt.event.WindowFocusListener;
+
+import javax.swing.JDialog;
+import javax.swing.JLabel;
+import javax.swing.JOptionPane;
+import javax.swing.JPanel;
+import javax.swing.JTextField;
+import javax.swing.OverlayLayout;
+import javax.swing.SwingUtilities;
+import javax.swing.border.EmptyBorder;
+import javax.swing.event.DocumentEvent;
+import javax.swing.event.DocumentListener;
+
+/** An implementation of the {@link Input} interface hooking GLFW panel for input.
+ * @author mzechner
+ * @author Nathan Sweet */
+public class JglfwInput implements Input {
+	final JglfwApplication app;
+	final InputProcessorQueue processorQueue;
+	InputProcessor processor;
+	int pressedKeys = 0;
+	boolean justTouched;
+	int deltaX, deltaY;
+	long currentEventTime;
+
+	public JglfwInput (final JglfwApplication app, boolean queueEvents) {
+		this.app = app;
+
+		InputProcessor inputProcessor = new InputProcessor() {
+			private int mouseX, mouseY;
+
+			public boolean keyDown (int keycode) {
+				pressedKeys++;
+				app.graphics.requestRendering();
+				return processor != null ? processor.keyDown(keycode) : false;
+			}
+
+			public boolean keyUp (int keycode) {
+				pressedKeys--;
+				app.graphics.requestRendering();
+				return processor != null ? processor.keyUp(keycode) : false;
+			}
+
+			public boolean keyTyped (char character) {
+				app.graphics.requestRendering();
+				return processor != null ? processor.keyTyped(character) : false;
+			}
+
+			public boolean touchDown (int screenX, int screenY, int pointer, int button) {
+				justTouched = true;
+				app.graphics.requestRendering();
+				return processor != null ? processor.touchDown(screenX, screenY, pointer, button) : false;
+			}
+
+			public boolean touchUp (int screenX, int screenY, int pointer, int button) {
+				app.graphics.requestRendering();
+				return processor != null ? processor.touchUp(screenX, screenY, pointer, button) : false;
+			}
+
+			public boolean touchDragged (int screenX, int screenY, int pointer) {
+				deltaX = screenX - mouseX;
+				deltaY = screenY - mouseY;
+				mouseX = screenX;
+				mouseY = screenY;
+				app.graphics.requestRendering();
+				return processor != null ? processor.touchDragged(mouseX, mouseY, 0) : false;
+			}
+
+			public boolean mouseMoved (int screenX, int screenY) {
+				deltaX = screenX - mouseX;
+				deltaY = screenY - mouseX;
+				mouseX = screenX;
+				mouseY = screenY;
+				app.graphics.requestRendering();
+				return processor != null ? processor.mouseMoved(mouseX, mouseY) : false;
+			}
+
+			public boolean scrolled (int amount) {
+				app.graphics.requestRendering();
+				return processor != null ? processor.scrolled(amount) : false;
+			}
+		};
+
+		if (queueEvents)
+			inputProcessor = processorQueue = new InputProcessorQueue(inputProcessor);
+		else
+			processorQueue = null;
+
+		app.getCallbacks().add(new GlfwInputProcessor(inputProcessor));
+	}
+
+	public void update () {
+		justTouched = false;
+		if (processorQueue != null)
+			processorQueue.drain(); // Main loop is handled elsewhere and events are queued.
+		else {
+			currentEventTime = System.nanoTime();
+			glfwPollEvents(); // Use GLFW main loop to process events.
+		}
+	}
+
+	public float getAccelerometerX () {
+		return 0;
+	}
+
+	public float getAccelerometerY () {
+		return 0;
+	}
+
+	public float getAccelerometerZ () {
+		return 0;
+	}
+
+	public int getX () {
+		return glfwGetCursorPosX(app.graphics.window);
+	}
+
+	public int getX (int pointer) {
+		return pointer > 0 ? 0 : getX();
+	}
+
+	public int getY () {
+		return glfwGetCursorPosY(app.graphics.window);
+	}
+
+	public int getY (int pointer) {
+		return pointer > 0 ? 0 : getY();
+	}
+
+	public int getDeltaX () {
+		return deltaX;
+	}
+
+	public int getDeltaX (int pointer) {
+		return pointer > 0 ? 0 : deltaX;
+	}
+
+	public int getDeltaY () {
+		return deltaY;
+	}
+
+	public int getDeltaY (int pointer) {
+		return pointer > 0 ? 0 : deltaY;
+	}
+
+	public boolean isTouched () {
+		return glfwGetMouseButton(app.graphics.window, 0) || glfwGetMouseButton(app.graphics.window, 1)
+			|| glfwGetMouseButton(app.graphics.window, 2);
+	}
+
+	public boolean isTouched (int pointer) {
+		return pointer > 0 ? false : isTouched();
+	}
+
+	public boolean justTouched () {
+		return justTouched;
+	}
+
+	public boolean isButtonPressed (int button) {
+		return glfwGetMouseButton(app.graphics.window, button);
+	}
+
+	public boolean isKeyPressed (int key) {
+		if (key == Input.Keys.ANY_KEY) return pressedKeys > 0;
+		return glfwGetKey(app.graphics.window, getJglfwKeyCode(key));
+	}
+
+	public void setOnscreenKeyboardVisible (boolean visible) {
+	}
+
+	public void vibrate (int milliseconds) {
+	}
+
+	public void vibrate (long[] pattern, int repeat) {
+	}
+
+	public void cancelVibrate () {
+	}
+
+	public float getAzimuth () {
+		return 0;
+	}
+
+	public float getPitch () {
+		return 0;
+	}
+
+	public float getRoll () {
+		return 0;
+	}
+
+	public void getRotationMatrix (float[] matrix) {
+	}
+
+	public long getCurrentEventTime () {
+		return processorQueue != null ? processorQueue.getCurrentEventTime() : currentEventTime;
+	}
+
+	public void setCatchBackKey (boolean catchBack) {
+	}
+
+	public void setCatchMenuKey (boolean catchMenu) {
+	}
+
+	public void setInputProcessor (InputProcessor processor) {
+		this.processor = processor;
+	}
+
+	public InputProcessor getInputProcessor () {
+		return processor;
+	}
+
+	public boolean isPeripheralAvailable (Peripheral peripheral) {
+		return peripheral == Peripheral.HardwareKeyboard;
+	}
+
+	public int getRotation () {
+		return 0;
+	}
+
+	public Orientation getNativeOrientation () {
+		return Orientation.Landscape;
+	}
+
+	public void setCursorCatched (boolean captured) {
+		glfwSetInputMode(app.graphics.window, GLFW_CURSOR_MODE, captured ? GLFW_CURSOR_CAPTURED : GLFW_CURSOR_NORMAL);
+	}
+
+	public boolean isCursorCatched () {
+		return glfwGetInputMode(app.graphics.window, GLFW_CURSOR_MODE) == GLFW_CURSOR_CAPTURED;
+	}
+
+	public void setCursorPosition (int x, int y) {
+		glfwSetCursorPos(app.graphics.window, x, y);
+	}
+
+	public void getTextInput (final TextInputListener listener, final String title, final String text) {
+		SwingUtilities.invokeLater(new Runnable() {
+			public void run () {
+				final String output = JOptionPane.showInputDialog(null, title, text);
+				app.postRunnable(new Runnable() {
+					public void run () {
+						if (output != null)
+							listener.input(output);
+						else
+							listener.canceled();
+					}
+				});
+			}
+		});
+	}
+
+	public void getPlaceholderTextInput (final TextInputListener listener, final String title, final String placeholder) {
+		SwingUtilities.invokeLater(new Runnable() {
+			public void run () {
+				JPanel panel = new JPanel(new FlowLayout());
+
+				JPanel textPanel = new JPanel() {
+					public boolean isOptimizedDrawingEnabled () {
+						return false;
+					};
+				};
+				textPanel.setLayout(new OverlayLayout(textPanel));
+				panel.add(textPanel);
+
+				final JTextField textField = new JTextField(20);
+				textField.setAlignmentX(0.0f);
+				textPanel.add(textField);
+
+				final JLabel placeholderLabel = new JLabel(placeholder);
+				placeholderLabel.setForeground(Color.GRAY);
+				placeholderLabel.setAlignmentX(0.0f);
+				textPanel.add(placeholderLabel, 0);
+
+				textField.getDocument().addDocumentListener(new DocumentListener() {
+					public void removeUpdate (DocumentEvent event) {
+						this.updated();
+					}
+
+					public void insertUpdate (DocumentEvent event) {
+						this.updated();
+					}
+
+					public void changedUpdate (DocumentEvent event) {
+						this.updated();
+					}
+
+					private void updated () {
+						placeholderLabel.setVisible(textField.getText().length() == 0);
+					}
+				});
+
+				JOptionPane pane = new JOptionPane(panel, JOptionPane.QUESTION_MESSAGE, JOptionPane.OK_CANCEL_OPTION, null, null,
+					null);
+				pane.setComponentOrientation(JOptionPane.getRootFrame().getComponentOrientation());
+				pane.selectInitialValue();
+
+				placeholderLabel.setBorder(new EmptyBorder(textField.getBorder().getBorderInsets(textField)));
+
+				JDialog dialog = pane.createDialog(null, title);
+				dialog.addWindowFocusListener(new WindowFocusListener() {
+					public void windowLostFocus (WindowEvent arg0) {
+					}
+
+					public void windowGainedFocus (WindowEvent arg0) {
+						textField.requestFocusInWindow();
+					}
+				});
+				dialog.setVisible(true);
+				dialog.dispose();
+
+				Object selectedValue = pane.getValue();
+				if (selectedValue != null && (selectedValue instanceof Integer) && (Integer)selectedValue == JOptionPane.OK_OPTION)
+					listener.input(textField.getText());
+				else
+					listener.canceled();
+			}
+		});
+	}
+
+	static char characterForKeyCode (int key) {
+		// Map certain key codes to character codes.
+		switch (key) {
+		case Keys.BACKSPACE:
+			return 8;
+		case Keys.TAB:
+			return '\t';
+		case Keys.FORWARD_DEL:
+			return 127;
+		}
+		return 0;
+	}
+
+	static public int getGdxKeyCode (int lwjglKeyCode) {
+		switch (lwjglKeyCode) {
+		case GLFW_KEY_LEFT_BRACKET:
+			return Input.Keys.LEFT_BRACKET;
+		case GLFW_KEY_RIGHT_BRACKET:
+			return Input.Keys.RIGHT_BRACKET;
+		case GLFW_KEY_GRAVE_ACCENT:
+			return Input.Keys.GRAVE;
+		case GLFW_KEY_KP_MULTIPLY:
+			return Input.Keys.STAR;
+		case GLFW_KEY_NUM_LOCK:
+			return Input.Keys.NUM;
+		case GLFW_KEY_KP_DECIMAL:
+			return Input.Keys.PERIOD;
+		case GLFW_KEY_KP_DIVIDE:
+			return Input.Keys.SLASH;
+		case GLFW_KEY_MENU:
+			return Input.Keys.MENU;
+		case GLFW_KEY_RIGHT_SUPER:
+			return Input.Keys.SYM;
+		case GLFW_KEY_LEFT_SUPER:
+			return Input.Keys.SYM;
+		case GLFW_KEY_KP_EQUAL:
+			return Input.Keys.EQUALS;
+		case GLFW_KEY_EQUAL:
+			return Input.Keys.EQUALS;
+		case GLFW_KEY_KP_ENTER:
+			return Input.Keys.ENTER;
+		case GLFW_KEY_0:
+			return Input.Keys.NUM_0;
+		case GLFW_KEY_1:
+			return Input.Keys.NUM_1;
+		case GLFW_KEY_2:
+			return Input.Keys.NUM_2;
+		case GLFW_KEY_3:
+			return Input.Keys.NUM_3;
+		case GLFW_KEY_4:
+			return Input.Keys.NUM_4;
+		case GLFW_KEY_5:
+			return Input.Keys.NUM_5;
+		case GLFW_KEY_6:
+			return Input.Keys.NUM_6;
+		case GLFW_KEY_7:
+			return Input.Keys.NUM_7;
+		case GLFW_KEY_8:
+			return Input.Keys.NUM_8;
+		case GLFW_KEY_9:
+			return Input.Keys.NUM_9;
+		case GLFW_KEY_A:
+			return Input.Keys.A;
+		case GLFW_KEY_B:
+			return Input.Keys.B;
+		case GLFW_KEY_C:
+			return Input.Keys.C;
+		case GLFW_KEY_D:
+			return Input.Keys.D;
+		case GLFW_KEY_E:
+			return Input.Keys.E;
+		case GLFW_KEY_F:
+			return Input.Keys.F;
+		case GLFW_KEY_G:
+			return Input.Keys.G;
+		case GLFW_KEY_H:
+			return Input.Keys.H;
+		case GLFW_KEY_I:
+			return Input.Keys.I;
+		case GLFW_KEY_J:
+			return Input.Keys.J;
+		case GLFW_KEY_K:
+			return Input.Keys.K;
+		case GLFW_KEY_L:
+			return Input.Keys.L;
+		case GLFW_KEY_M:
+			return Input.Keys.M;
+		case GLFW_KEY_N:
+			return Input.Keys.N;
+		case GLFW_KEY_O:
+			return Input.Keys.O;
+		case GLFW_KEY_P:
+			return Input.Keys.P;
+		case GLFW_KEY_Q:
+			return Input.Keys.Q;
+		case GLFW_KEY_R:
+			return Input.Keys.R;
+		case GLFW_KEY_S:
+			return Input.Keys.S;
+		case GLFW_KEY_T:
+			return Input.Keys.T;
+		case GLFW_KEY_U:
+			return Input.Keys.U;
+		case GLFW_KEY_V:
+			return Input.Keys.V;
+		case GLFW_KEY_W:
+			return Input.Keys.W;
+		case GLFW_KEY_X:
+			return Input.Keys.X;
+		case GLFW_KEY_Y:
+			return Input.Keys.Y;
+		case GLFW_KEY_Z:
+			return Input.Keys.Z;
+		case GLFW_KEY_LALT:
+			return Input.Keys.ALT_LEFT;
+		case GLFW_KEY_RALT:
+			return Input.Keys.ALT_RIGHT;
+		case GLFW_KEY_BACKSLASH:
+			return Input.Keys.BACKSLASH;
+		case GLFW_KEY_COMMA:
+			return Input.Keys.COMMA;
+		case GLFW_KEY_DELETE:
+			return Input.Keys.FORWARD_DEL;
+		case GLFW_KEY_LEFT:
+			return Input.Keys.DPAD_LEFT;
+		case GLFW_KEY_RIGHT:
+			return Input.Keys.DPAD_RIGHT;
+		case GLFW_KEY_UP:
+			return Input.Keys.DPAD_UP;
+		case GLFW_KEY_DOWN:
+			return Input.Keys.DPAD_DOWN;
+		case GLFW_KEY_ENTER:
+			return Input.Keys.ENTER;
+		case GLFW_KEY_HOME:
+			return Input.Keys.HOME;
+		case GLFW_KEY_MINUS:
+			return Input.Keys.MINUS;
+		case GLFW_KEY_PERIOD:
+			return Input.Keys.PERIOD;
+		case GLFW_KEY_KP_ADD:
+			return Input.Keys.PLUS;
+		case GLFW_KEY_SEMICOLON:
+			return Input.Keys.SEMICOLON;
+		case GLFW_KEY_LSHIFT:
+			return Input.Keys.SHIFT_LEFT;
+		case GLFW_KEY_RSHIFT:
+			return Input.Keys.SHIFT_RIGHT;
+		case GLFW_KEY_SLASH:
+			return Input.Keys.SLASH;
+		case GLFW_KEY_SPACE:
+			return Input.Keys.SPACE;
+		case GLFW_KEY_TAB:
+			return Input.Keys.TAB;
+		case GLFW_KEY_LEFT_CONTROL:
+			return Input.Keys.CONTROL_LEFT;
+		case GLFW_KEY_RIGHT_CONTROL:
+			return Input.Keys.CONTROL_RIGHT;
+		case GLFW_KEY_ESCAPE:
+			return Input.Keys.ESCAPE;
+		case GLFW_KEY_END:
+			return Input.Keys.END;
+		case GLFW_KEY_INSERT:
+			return Input.Keys.INSERT;
+		case GLFW_KEY_BACKSPACE:
+			return Input.Keys.DEL;
+		case GLFW_KEY_KP_SUBTRACT:
+			return Input.Keys.MINUS;
+		case GLFW_KEY_APOSTROPHE:
+			return Input.Keys.APOSTROPHE;
+		case GLFW_KEY_F1:
+			return Input.Keys.F1;
+		case GLFW_KEY_F2:
+			return Input.Keys.F2;
+		case GLFW_KEY_F3:
+			return Input.Keys.F3;
+		case GLFW_KEY_F4:
+			return Input.Keys.F4;
+		case GLFW_KEY_F5:
+			return Input.Keys.F5;
+		case GLFW_KEY_F6:
+			return Input.Keys.F6;
+		case GLFW_KEY_F7:
+			return Input.Keys.F7;
+		case GLFW_KEY_F8:
+			return Input.Keys.F8;
+		case GLFW_KEY_F9:
+			return Input.Keys.F9;
+		case GLFW_KEY_F10:
+			return Input.Keys.F10;
+		case GLFW_KEY_F11:
+			return Input.Keys.F11;
+		case GLFW_KEY_F12:
+			return Input.Keys.F12;
+		case GLFW_KEY_KP_0:
+			return Input.Keys.NUM_0;
+		case GLFW_KEY_KP_1:
+			return Input.Keys.NUM_1;
+		case GLFW_KEY_KP_2:
+			return Input.Keys.NUM_2;
+		case GLFW_KEY_KP_3:
+			return Input.Keys.NUM_3;
+		case GLFW_KEY_KP_4:
+			return Input.Keys.NUM_4;
+		case GLFW_KEY_KP_5:
+			return Input.Keys.NUM_5;
+		case GLFW_KEY_KP_6:
+			return Input.Keys.NUM_6;
+		case GLFW_KEY_KP_7:
+			return Input.Keys.NUM_7;
+		case GLFW_KEY_KP_8:
+			return Input.Keys.NUM_8;
+		case GLFW_KEY_KP_9:
+			return Input.Keys.NUM_9;
+		default:
+			return Input.Keys.UNKNOWN;
+		}
+	}
+
+	static public int getJglfwKeyCode (int gdxKeyCode) {
+		switch (gdxKeyCode) {
+		case Input.Keys.LEFT_BRACKET:
+			return GLFW_KEY_LEFT_BRACKET;
+		case Input.Keys.RIGHT_BRACKET:
+			return GLFW_KEY_RIGHT_BRACKET;
+		case Input.Keys.GRAVE:
+			return GLFW_KEY_GRAVE_ACCENT;
+		case Input.Keys.STAR:
+			return GLFW_KEY_KP_MULTIPLY;
+		case Input.Keys.NUM:
+			return GLFW_KEY_NUM_LOCK;
+		case Input.Keys.EQUALS:
+			return GLFW_KEY_MENU;
+		case Input.Keys.MENU:
+			return GLFW_KEY_MENU;
+		case Input.Keys.SYM:
+			return GLFW_KEY_LEFT_SUPER;
+		case Input.Keys.NUM_0:
+			return GLFW_KEY_0;
+		case Input.Keys.NUM_1:
+			return GLFW_KEY_1;
+		case Input.Keys.NUM_2:
+			return GLFW_KEY_2;
+		case Input.Keys.NUM_3:
+			return GLFW_KEY_3;
+		case Input.Keys.NUM_4:
+			return GLFW_KEY_4;
+		case Input.Keys.NUM_5:
+			return GLFW_KEY_5;
+		case Input.Keys.NUM_6:
+			return GLFW_KEY_6;
+		case Input.Keys.NUM_7:
+			return GLFW_KEY_7;
+		case Input.Keys.NUM_8:
+			return GLFW_KEY_8;
+		case Input.Keys.NUM_9:
+			return GLFW_KEY_9;
+		case Input.Keys.A:
+			return GLFW_KEY_A;
+		case Input.Keys.B:
+			return GLFW_KEY_B;
+		case Input.Keys.C:
+			return GLFW_KEY_C;
+		case Input.Keys.D:
+			return GLFW_KEY_D;
+		case Input.Keys.E:
+			return GLFW_KEY_E;
+		case Input.Keys.F:
+			return GLFW_KEY_F;
+		case Input.Keys.G:
+			return GLFW_KEY_G;
+		case Input.Keys.H:
+			return GLFW_KEY_H;
+		case Input.Keys.I:
+			return GLFW_KEY_I;
+		case Input.Keys.J:
+			return GLFW_KEY_J;
+		case Input.Keys.K:
+			return GLFW_KEY_K;
+		case Input.Keys.L:
+			return GLFW_KEY_L;
+		case Input.Keys.M:
+			return GLFW_KEY_M;
+		case Input.Keys.N:
+			return GLFW_KEY_N;
+		case Input.Keys.O:
+			return GLFW_KEY_O;
+		case Input.Keys.P:
+			return GLFW_KEY_P;
+		case Input.Keys.Q:
+			return GLFW_KEY_Q;
+		case Input.Keys.R:
+			return GLFW_KEY_R;
+		case Input.Keys.S:
+			return GLFW_KEY_S;
+		case Input.Keys.T:
+			return GLFW_KEY_T;
+		case Input.Keys.U:
+			return GLFW_KEY_U;
+		case Input.Keys.V:
+			return GLFW_KEY_V;
+		case Input.Keys.W:
+			return GLFW_KEY_W;
+		case Input.Keys.X:
+			return GLFW_KEY_X;
+		case Input.Keys.Y:
+			return GLFW_KEY_Y;
+		case Input.Keys.Z:
+			return GLFW_KEY_Z;
+		case Input.Keys.ALT_LEFT:
+			return GLFW_KEY_LALT;
+		case Input.Keys.ALT_RIGHT:
+			return GLFW_KEY_RALT;
+		case Input.Keys.BACKSLASH:
+			return GLFW_KEY_BACKSLASH;
+		case Input.Keys.COMMA:
+			return GLFW_KEY_COMMA;
+		case Input.Keys.FORWARD_DEL:
+			return GLFW_KEY_DELETE;
+		case Input.Keys.DPAD_LEFT:
+			return GLFW_KEY_LEFT;
+		case Input.Keys.DPAD_RIGHT:
+			return GLFW_KEY_RIGHT;
+		case Input.Keys.DPAD_UP:
+			return GLFW_KEY_UP;
+		case Input.Keys.DPAD_DOWN:
+			return GLFW_KEY_DOWN;
+		case Input.Keys.ENTER:
+			return GLFW_KEY_ENTER;
+		case Input.Keys.HOME:
+			return GLFW_KEY_HOME;
+		case Input.Keys.MINUS:
+			return GLFW_KEY_MINUS;
+		case Input.Keys.PERIOD:
+			return GLFW_KEY_PERIOD;
+		case Input.Keys.PLUS:
+			return GLFW_KEY_KP_ADD;
+		case Input.Keys.SEMICOLON:
+			return GLFW_KEY_SEMICOLON;
+		case Input.Keys.SHIFT_LEFT:
+			return GLFW_KEY_LSHIFT;
+		case Input.Keys.SHIFT_RIGHT:
+			return GLFW_KEY_RSHIFT;
+		case Input.Keys.SLASH:
+			return GLFW_KEY_SLASH;
+		case Input.Keys.SPACE:
+			return GLFW_KEY_SPACE;
+		case Input.Keys.TAB:
+			return GLFW_KEY_TAB;
+		case Input.Keys.DEL:
+			return GLFW_KEY_BACKSPACE;
+		case Input.Keys.CONTROL_LEFT:
+			return GLFW_KEY_LEFT_CONTROL;
+		case Input.Keys.CONTROL_RIGHT:
+			return GLFW_KEY_RIGHT_CONTROL;
+		case Input.Keys.ESCAPE:
+			return GLFW_KEY_ESCAPE;
+		case Input.Keys.F1:
+			return GLFW_KEY_F1;
+		case Input.Keys.F2:
+			return GLFW_KEY_F2;
+		case Input.Keys.F3:
+			return GLFW_KEY_F3;
+		case Input.Keys.F4:
+			return GLFW_KEY_F4;
+		case Input.Keys.F5:
+			return GLFW_KEY_F5;
+		case Input.Keys.F6:
+			return GLFW_KEY_F6;
+		case Input.Keys.F7:
+			return GLFW_KEY_F7;
+		case Input.Keys.F8:
+			return GLFW_KEY_F8;
+		case Input.Keys.F9:
+			return GLFW_KEY_F9;
+		case Input.Keys.F10:
+			return GLFW_KEY_F10;
+		case Input.Keys.F11:
+			return GLFW_KEY_F11;
+		case Input.Keys.F12:
+			return GLFW_KEY_F12;
+		default:
+			return 0;
+		}
+	}
+
+	/** Receives GLFW input and calls InputProcessor methods.
+	 * @author Nathan Sweet */
+	static class GlfwInputProcessor extends GlfwCallbackAdapter {
+		private int mouseX, mouseY, mousePressed;
+		private char lastCharacter;
+		private InputProcessor processor;
+
+		public GlfwInputProcessor (InputProcessor processor) {
+			if (processor == null) throw new IllegalArgumentException("processor cannot be null.");
+			this.processor = processor;
+		}
+
+		public void key (long window, int key, int action) {
+			switch (action) {
+			case GLFW_PRESS:
+
+				key = getGdxKeyCode(key);
+				processor.keyDown(key);
+
+				lastCharacter = 0;
+				char character = characterForKeyCode(key);
+				if (character != 0) character(window, character);
+				break;
+
+			case GLFW_RELEASE:
+				processor.keyUp(getGdxKeyCode(key));
+				break;
+
+			case GLFW_REPEAT:
+				if (lastCharacter != 0) processor.keyTyped(lastCharacter);
+				break;
+			}
+		}
+
+		public void character (long window, char character) {
+			lastCharacter = character;
+			processor.keyTyped(character);
+		}
+
+		public void scroll (long window, double scrollX, double scrollY) {
+			processor.scrolled((int)-Math.signum(scrollY));
+		}
+
+		public void mouseButton (long window, int button, boolean pressed) {
+			if (pressed) {
+				mousePressed++;
+				processor.touchDown(mouseX, mouseY, 0, button);
+			} else {
+				mousePressed = Math.max(0, mousePressed - 1);
+				processor.touchUp(mouseX, mouseY, 0, button);
+			}
+		}
+
+		public void cursorPos (long window, int x, int y) {
+			mouseX = x;
+			mouseY = y;
+			if (mousePressed > 0)
+				processor.touchDragged(x, y, 0);
+			else
+				processor.mouseMoved(x, y);
+		}
+	}
+}
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwNet.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwNet.java
new file mode 100644
index 0000000..1e6a01b
--- /dev/null
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwNet.java
@@ -0,0 +1,59 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *	 http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.backends.jglfw;
+
+import com.badlogic.gdx.Net;
+import com.badlogic.gdx.net.NetJavaImpl;
+import com.badlogic.gdx.net.ServerSocket;
+import com.badlogic.gdx.net.ServerSocketHints;
+import com.badlogic.gdx.net.Socket;
+import com.badlogic.gdx.net.SocketHints;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+import java.awt.Desktop;
+import java.net.URI;
+
+/** Desktop implementation of the {@link Net} API.
+ * @author acoppes */
+public class JglfwNet implements Net {
+	NetJavaImpl netJavaImpl = new NetJavaImpl();
+
+	public void sendHttpRequest (HttpRequest httpRequest, HttpResponseListener httpResponseListener) {
+		netJavaImpl.sendHttpRequest(httpRequest, httpResponseListener);
+	}
+
+	public ServerSocket newServerSocket (Protocol protocol, int port, ServerSocketHints hints) {
+		return new JglfwServerSocket(protocol, port, hints);
+	}
+
+	public Socket newClientSocket (Protocol protocol, String host, int port, SocketHints hints) {
+		return new JglfwSocket(protocol, host, port, hints);
+	}
+
+	public void openURI (String uri) {
+		if (!Desktop.isDesktopSupported()) return;
+
+		Desktop desktop = Desktop.getDesktop();
+		if (!desktop.isSupported(Desktop.Action.BROWSE)) return;
+
+		try {
+			desktop.browse(new URI(uri));
+		} catch (Exception ex) {
+			throw new GdxRuntimeException(ex);
+		}
+	}
+}
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwPreferences.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwPreferences.java
new file mode 100644
index 0000000..1f9918e
--- /dev/null
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwPreferences.java
@@ -0,0 +1,175 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.backends.jglfw;
+
+import com.badlogic.gdx.Files.FileType;
+import com.badlogic.gdx.Preferences;
+import com.badlogic.gdx.files.FileHandle;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Properties;
+
+public class JglfwPreferences implements Preferences {
+	private final String name;
+	private final Properties properties = new Properties();
+	private final FileHandle file;
+
+	public JglfwPreferences (String name) {
+		this(new JglfwFileHandle(new File(".prefs/" + name), FileType.External));
+	}
+
+	public JglfwPreferences (FileHandle file) {
+		this.name = file.name();
+		this.file = file;
+		if (!file.exists()) return;
+		InputStream in = null;
+		try {
+			in = new BufferedInputStream(file.read());
+			properties.load(in);
+		} catch (Throwable ex) {
+			ex.printStackTrace();
+		} finally {
+			if (in != null) {
+				try {
+					in.close();
+				} catch (Exception ignored) {
+				}
+			}
+		}
+	}
+
+	public void putBoolean (String key, boolean val) {
+		properties.put(key, Boolean.toString(val));
+	}
+
+	public void putInteger (String key, int val) {
+		properties.put(key, Integer.toString(val));
+	}
+
+	public void putLong (String key, long val) {
+		properties.put(key, Long.toString(val));
+	}
+
+	public void putFloat (String key, float val) {
+		properties.put(key, Float.toString(val));
+	}
+
+	public void putString (String key, String val) {
+		properties.put(key, val);
+	}
+
+	public void put (Map<String, ?> vals) {
+		for (Entry<String, ?> val : vals.entrySet()) {
+			if (val.getValue() instanceof Boolean) putBoolean(val.getKey(), (Boolean)val.getValue());
+			if (val.getValue() instanceof Integer) putInteger(val.getKey(), (Integer)val.getValue());
+			if (val.getValue() instanceof Long) putLong(val.getKey(), (Long)val.getValue());
+			if (val.getValue() instanceof String) putString(val.getKey(), (String)val.getValue());
+			if (val.getValue() instanceof Float) putFloat(val.getKey(), (Float)val.getValue());
+		}
+	}
+
+	public boolean getBoolean (String key) {
+		return getBoolean(key, false);
+	}
+
+	public int getInteger (String key) {
+		return getInteger(key, 0);
+	}
+
+	public long getLong (String key) {
+		return getLong(key, 0);
+	}
+
+	public float getFloat (String key) {
+		return getFloat(key, 0);
+	}
+
+	public String getString (String key) {
+		return getString(key, "");
+	}
+
+	public boolean getBoolean (String key, boolean defValue) {
+		return Boolean.parseBoolean(properties.getProperty(key, Boolean.toString(defValue)));
+	}
+
+	public int getInteger (String key, int defValue) {
+		return Integer.parseInt(properties.getProperty(key, Integer.toString(defValue)));
+	}
+
+	public long getLong (String key, long defValue) {
+		return Long.parseLong(properties.getProperty(key, Long.toString(defValue)));
+	}
+
+	public float getFloat (String key, float defValue) {
+		return Float.parseFloat(properties.getProperty(key, Float.toString(defValue)));
+	}
+
+	public String getString (String key, String defValue) {
+		return properties.getProperty(key, defValue);
+	}
+
+	public Map<String, ?> get () {
+		Map<String, Object> map = new HashMap<String, Object>();
+		for (Entry<Object, Object> val : properties.entrySet()) {
+			if (val.getValue() instanceof Boolean)
+				map.put((String)val.getKey(), (Boolean)Boolean.parseBoolean((String)val.getValue()));
+			if (val.getValue() instanceof Integer) map.put((String)val.getKey(), (Integer)Integer.parseInt((String)val.getValue()));
+			if (val.getValue() instanceof Long) map.put((String)val.getKey(), (Long)Long.parseLong((String)val.getValue()));
+			if (val.getValue() instanceof String) map.put((String)val.getKey(), (String)val.getValue());
+			if (val.getValue() instanceof Float) map.put((String)val.getKey(), (Float)Float.parseFloat((String)val.getValue()));
+		}
+
+		return map;
+	}
+
+	public boolean contains (String key) {
+		return properties.containsKey(key);
+	}
+
+	public void clear () {
+		properties.clear();
+	}
+
+	public void flush () {
+		OutputStream out = null;
+		try {
+			out = new BufferedOutputStream(file.write(false));
+			properties.store(out, null);
+		} catch (Exception ex) {
+			throw new GdxRuntimeException("Error writing preferences: " + file, ex);
+		} finally {
+			if (out != null) {
+				try {
+					out.close();
+				} catch (Exception ignored) {
+				}
+			}
+		}
+	}
+
+	public void remove (String key) {
+		properties.remove(key);
+	}
+}
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwServerSocket.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwServerSocket.java
new file mode 100644
index 0000000..a13cfa0
--- /dev/null
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwServerSocket.java
@@ -0,0 +1,85 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.backends.jglfw;
+
+import com.badlogic.gdx.Net.Protocol;
+import com.badlogic.gdx.net.ServerSocket;
+import com.badlogic.gdx.net.ServerSocketHints;
+import com.badlogic.gdx.net.Socket;
+import com.badlogic.gdx.net.SocketHints;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+import java.net.InetSocketAddress;
+
+/** Server socket implementation using java.net.ServerSocket.
+ * @author noblemaster */
+public class JglfwServerSocket implements ServerSocket {
+	private Protocol protocol;
+
+	/** Our server or null for disposed, aka closed. */
+	private java.net.ServerSocket server;
+
+	public JglfwServerSocket (Protocol protocol, int port, ServerSocketHints hints) {
+		this.protocol = protocol;
+
+		// create the server socket
+		try {
+			// initialize
+			server = new java.net.ServerSocket();
+			if (hints != null) {
+				server.setPerformancePreferences(hints.performancePrefConnectionTime, hints.performancePrefLatency,
+					hints.performancePrefBandwidth);
+				server.setReuseAddress(hints.reuseAddress);
+				server.setSoTimeout(hints.acceptTimeout);
+				server.setReceiveBufferSize(hints.receiveBufferSize);
+			}
+
+			// and bind the server...
+			InetSocketAddress address = new InetSocketAddress(port);
+			if (hints != null) {
+				server.bind(address, hints.backlog);
+			} else {
+				server.bind(address);
+			}
+		} catch (Exception e) {
+			throw new GdxRuntimeException("Cannot create a server socket at port " + port + ".", e);
+		}
+	}
+
+	public Protocol getProtocol () {
+		return protocol;
+	}
+
+	public Socket accept (SocketHints hints) {
+		try {
+			return new JglfwSocket(server.accept(), hints);
+		} catch (Exception e) {
+			throw new GdxRuntimeException("Error accepting socket.", e);
+		}
+	}
+
+	public void dispose () {
+		if (server != null) {
+			try {
+				server.close();
+				server = null;
+			} catch (Exception e) {
+				throw new GdxRuntimeException("Error closing server.", e);
+			}
+		}
+	}
+}
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwSocket.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwSocket.java
new file mode 100644
index 0000000..4bd4dd2
--- /dev/null
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwSocket.java
@@ -0,0 +1,109 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.backends.jglfw;
+
+import com.badlogic.gdx.Net.Protocol;
+import com.badlogic.gdx.net.Socket;
+import com.badlogic.gdx.net.SocketHints;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.InetSocketAddress;
+
+/** Socket implementation using java.net.Socket.
+ * @author noblemaster */
+public class JglfwSocket implements Socket {
+
+	/** Our socket or null for disposed, aka closed. */
+	private java.net.Socket socket;
+
+	public JglfwSocket (Protocol protocol, String host, int port, SocketHints hints) {
+		try {
+			// create the socket
+			socket = new java.net.Socket();
+			applyHints(hints); // better to call BEFORE socket is connected!
+
+			// and connect...
+			InetSocketAddress address = new InetSocketAddress(host, port);
+			if (hints != null) {
+				socket.connect(address, hints.connectTimeout);
+			} else {
+				socket.connect(address);
+			}
+		} catch (Exception e) {
+			throw new GdxRuntimeException("Error making a socket connection to " + host + ":" + port, e);
+		}
+	}
+
+	public JglfwSocket (java.net.Socket socket, SocketHints hints) {
+		this.socket = socket;
+		applyHints(hints);
+	}
+
+	private void applyHints (SocketHints hints) {
+		if (hints != null) {
+			try {
+				socket.setPerformancePreferences(hints.performancePrefConnectionTime, hints.performancePrefLatency,
+					hints.performancePrefBandwidth);
+				socket.setTrafficClass(hints.trafficClass);
+				socket.setTcpNoDelay(hints.tcpNoDelay);
+				socket.setKeepAlive(hints.keepAlive);
+				socket.setSendBufferSize(hints.sendBufferSize);
+				socket.setReceiveBufferSize(hints.receiveBufferSize);
+				socket.setSoLinger(hints.linger, hints.lingerDuration);
+			} catch (Exception e) {
+				throw new GdxRuntimeException("Error setting socket hints.", e);
+			}
+		}
+	}
+
+	public boolean isConnected () {
+		if (socket != null) {
+			return socket.isConnected();
+		} else {
+			return false;
+		}
+	}
+
+	public InputStream getInputStream () {
+		try {
+			return socket.getInputStream();
+		} catch (Exception e) {
+			throw new GdxRuntimeException("Error getting input stream from socket.", e);
+		}
+	}
+
+	public OutputStream getOutputStream () {
+		try {
+			return socket.getOutputStream();
+		} catch (Exception e) {
+			throw new GdxRuntimeException("Error getting output stream from socket.", e);
+		}
+	}
+
+	public void dispose () {
+		if (socket != null) {
+			try {
+				socket.close();
+				socket = null;
+			} catch (Exception e) {
+				throw new GdxRuntimeException("Error closing socket.", e);
+			}
+		}
+	}
+}
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwUtil.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwUtil.java
new file mode 100644
index 0000000..b1c4eaa
--- /dev/null
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwUtil.java
@@ -0,0 +1,62 @@
+
+package com.badlogic.gdx.backends.jglfw;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.FloatBuffer;
+import java.nio.IntBuffer;
+
+class JglfwUtil {
+	static private ByteBuffer buffer = ByteBuffer.allocateDirect(8 * 4).order(ByteOrder.nativeOrder());
+	static private IntBuffer bufferInt = buffer.asIntBuffer();
+	static private FloatBuffer bufferFloat = buffer.asFloatBuffer();
+
+	static private void ensureSize (int n) {
+		if (buffer.capacity() < n) {
+			buffer = ByteBuffer.allocateDirect(n).order(ByteOrder.nativeOrder());
+			bufferInt = buffer.asIntBuffer();
+			bufferFloat = buffer.asFloatBuffer();
+		}
+	}
+
+	static ByteBuffer toBuffer (boolean[] src, int offset) {
+		int n = src.length - offset;
+		ensureSize(n);
+		buffer.position(0);
+		for (boolean value : src)
+			buffer.put(value ? (byte)1 : 0);
+		return buffer;
+	}
+
+	static IntBuffer toBuffer (int[] src, int offset) {
+		int n = src.length - offset;
+		ensureSize(n * 4);
+		bufferInt.position(0);
+		bufferInt.put(src, offset, n);
+		return bufferInt;
+	}
+
+	static FloatBuffer toBuffer (float[] src, int offset) {
+		int n = src.length - offset;
+		ensureSize(n * 4);
+		bufferFloat.position(0);
+		bufferFloat.put(src, offset, n);
+		return bufferFloat;
+	}
+
+	static void toArray (ByteBuffer src, boolean[] dst, int offset) {
+		for (int i = 0; i < dst.length - offset; i++) {
+			dst[i + offset] = src.get(i) != 0;
+		}
+	}
+
+	static void toArray (IntBuffer src, int[] dst, int offset) {
+		src.position(0);
+		src.get(dst, offset, dst.length - offset);
+	}
+
+	static void toArray (FloatBuffer src, float[] dst, int offset) {
+		src.position(0);
+		src.get(dst, offset, dst.length - offset);
+	}
+}
diff --git a/backends/gdx-backend-lwjgl/.classpath b/backends/gdx-backend-lwjgl/.classpath
index aec345e..d0e9f88 100644
--- a/backends/gdx-backend-lwjgl/.classpath
+++ b/backends/gdx-backend-lwjgl/.classpath
@@ -5,6 +5,5 @@
 	<classpathentry exported="true" kind="lib" path="/gdx/libs/gdx-natives.jar"/>
 	<classpathentry exported="true" kind="lib" path="libs/gdx-backend-lwjgl-natives.jar"/>
 	<classpathentry combineaccessrules="false" exported="true" kind="src" path="/gdx-openal"/>
-	<classpathentry exported="true" kind="lib" path="libs/lwjgl_util.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/backends/gdx-backend-lwjgl/libs/lwjgl_util.jar b/backends/gdx-backend-lwjgl/libs/lwjgl_util.jar
deleted file mode 100644
index b4fd4a6..0000000
Binary files a/backends/gdx-backend-lwjgl/libs/lwjgl_util.jar and /dev/null differ
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplication.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplication.java
index 9589d1e..3cafb5b 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplication.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplication.java
@@ -57,7 +57,7 @@ public class LwjglApplication implements Application {
 	}
 
 	public LwjglApplication (ApplicationListener listener) {
-		this(listener, new LwjglApplicationConfiguration());
+		this(listener, listener.getClass().getSimpleName(), 640, 480, false);
 	}
 
 	public LwjglApplication (ApplicationListener listener, LwjglApplicationConfiguration config) {
@@ -217,7 +217,7 @@ public class LwjglApplication implements Application {
 	public ApplicationListener getApplicationListener () {
 		return listener;
 	}
-	
+
 	@Override
 	public Audio getAudio () {
 		return audio;
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplicationConfiguration.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplicationConfiguration.java
index 72d2cea..13e8658 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplicationConfiguration.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplicationConfiguration.java
@@ -41,13 +41,13 @@ public class LwjglApplicationConfiguration {
 	/** number of samples for MSAA **/
 	public int samples = 0;
 	/** width & height of application window **/
-	public int width = 480, height = 320;
+	public int width = 640, height = 480;
 	/** x & y of application window, -1 for center **/
 	public int x = -1, y = -1;
 	/** fullscreen **/
 	public boolean fullscreen = false;
 	/** whether to use CPU synching. If this is false display vsynching is used, which might not work in windowed mode **/
-	public boolean useCPUSynch = true;
+	public boolean useCPUSynch = false;
 	/** whether to enable vsync, can be changed at runtime via {@link Graphics#setVSync(boolean)} **/
 	public boolean vSyncEnabled = true;
 	/** title of application **/
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglCanvas.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglCanvas.java
index 85ee047..d50b239 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglCanvas.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglCanvas.java
@@ -64,7 +64,7 @@ public class LwjglCanvas implements Application {
 
 	public LwjglCanvas (ApplicationListener listener, boolean useGL2) {
 		LwjglApplicationConfiguration config = new LwjglApplicationConfiguration();
-		config.useGL20 = true;
+		config.useGL20 = useGL2;
 		initialize(listener, config);
 	}
 
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGLU.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGLU.java
deleted file mode 100644
index 4ba33c8..0000000
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGLU.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.backends.lwjgl;
-
-import java.nio.FloatBuffer;
-import java.nio.IntBuffer;
-
-import org.lwjgl.BufferUtils;
-
-import com.badlogic.gdx.graphics.GL10;
-import com.badlogic.gdx.graphics.GLU;
-
-public class LwjglGLU implements GLU {
-
-	FloatBuffer modelb;
-	FloatBuffer projectb;
-	IntBuffer viewb;
-	FloatBuffer winb;
-
-	public LwjglGLU () {
-		modelb = BufferUtils.createFloatBuffer(16);
-		projectb = BufferUtils.createFloatBuffer(16);
-		viewb = BufferUtils.createIntBuffer(4);
-		winb = BufferUtils.createFloatBuffer(3);
-	}
-
-	@Override
-	public void gluLookAt (GL10 gl, float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX,
-		float upY, float upZ) {
-		org.lwjgl.util.glu.GLU.gluLookAt(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ);
-	}
-
-	@Override
-	public void gluOrtho2D (GL10 gl, float left, float right, float bottom, float top) {
-		org.lwjgl.util.glu.GLU.gluOrtho2D(left, right, bottom, top);
-	}
-
-	@Override
-	public void gluPerspective (GL10 gl, float fovy, float aspect, float zNear, float zFar) {
-		org.lwjgl.util.glu.GLU.gluPerspective(fovy, aspect, zNear, zFar);
-	}
-
-	@Override
-	public boolean gluProject (float objX, float objY, float objZ, float[] model, int modelOffset, float[] project,
-		int projectOffset, int[] view, int viewOffset, float[] win, int winOffset) {
-		modelb.clear();
-		modelb.put(model, modelOffset, 16);
-		modelb.rewind();
-		projectb.clear();
-		projectb.put(project, projectOffset, 16);
-		projectb.rewind();
-		viewb.clear();
-		viewb.put(view, viewOffset, 4);
-		viewb.rewind();
-		winb.clear();
-
-		boolean result = org.lwjgl.util.glu.GLU.gluProject(objX, objY, objZ, modelb, projectb, viewb, winb);
-		win[winOffset] = winb.get(0);
-		win[winOffset + 1] = winb.get(1);
-		win[winOffset + 2] = winb.get(2);
-		return result;
-	}
-
-	@Override
-	public boolean gluUnProject (float winX, float winY, float winZ, float[] model, int modelOffset, float[] project,
-		int projectOffset, int[] view, int viewOffset, float[] obj, int objOffset) {
-		modelb.clear();
-		modelb.put(model, modelOffset, 16);
-		modelb.rewind();
-		projectb.clear();
-		projectb.put(project, projectOffset, 16);
-		projectb.rewind();
-		viewb.clear();
-		viewb.put(view, viewOffset, 4);
-		viewb.rewind();
-		winb.clear();
-
-		boolean result = org.lwjgl.util.glu.GLU.gluUnProject(winX, winY, winZ, modelb, projectb, viewb, winb);
-		obj[objOffset] = winb.get(0);
-		obj[objOffset + 1] = winb.get(1);
-		obj[objOffset + 2] = winb.get(2);
-		return result;
-	}
-}
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGraphics.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGraphics.java
index 7f67363..e0f9423 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGraphics.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGraphics.java
@@ -22,7 +22,6 @@ import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.GL11;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.GLCommon;
-import com.badlogic.gdx.graphics.GLU;
 import com.badlogic.gdx.graphics.Pixmap;
 import com.badlogic.gdx.graphics.Pixmap.Format;
 import com.badlogic.gdx.utils.GdxRuntimeException;
@@ -44,7 +43,6 @@ public class LwjglGraphics implements Graphics {
 	GL10 gl10;
 	GL11 gl11;
 	GL20 gl20;
-	GLU glu;
 	float deltaTime = 0;
 	long frameStart = 0;
 	int frames = 0;
@@ -88,10 +86,6 @@ public class LwjglGraphics implements Graphics {
 		return gl20;
 	}
 
-	public GLU getGLU () {
-		return glu;
-	}
-
 	public int getHeight () {
 		if (canvas != null)
 			return Math.max(1, canvas.getHeight());
@@ -252,9 +246,6 @@ public class LwjglGraphics implements Graphics {
 			gl = gl10;
 		}
 
-		glu = new LwjglGLU();
-
-		Gdx.glu = glu;
 		Gdx.gl = gl;
 		Gdx.gl10 = gl10;
 		Gdx.gl11 = gl11;
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglNativesLoader.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglNativesLoader.java
index 74336fb..55ba4f5 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglNativesLoader.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglNativesLoader.java
@@ -52,13 +52,15 @@ public final class LwjglNativesLoader {
 		try {
 			if (isWindows) {
 				nativesDir = loader.extractFile(is64Bit ? "lwjgl64.dll" : "lwjgl.dll", null).getParentFile();
-				loader.extractFile(is64Bit ? "OpenAL64.dll" : "OpenAL32.dll", nativesDir.getName());
+				if (!LwjglApplicationConfiguration.disableAudio)
+					loader.extractFile(is64Bit ? "OpenAL64.dll" : "OpenAL32.dll", nativesDir.getName());
 			} else if (isMac) {
 				nativesDir = loader.extractFile("liblwjgl.jnilib", null).getParentFile();
-				loader.extractFile("openal.dylib", nativesDir.getName());
+				if (!LwjglApplicationConfiguration.disableAudio) loader.extractFile("openal.dylib", nativesDir.getName());
 			} else if (isLinux) {
 				nativesDir = loader.extractFile(is64Bit ? "liblwjgl64.so" : "liblwjgl.so", null).getParentFile();
-				loader.extractFile(is64Bit ? "libopenal64.so" : "libopenal.so", nativesDir.getName());
+				if (!LwjglApplicationConfiguration.disableAudio)
+					loader.extractFile(is64Bit ? "libopenal64.so" : "libopenal.so", nativesDir.getName());
 			}
 		} catch (Throwable ex) {
 			throw new GdxRuntimeException("Unable to extract LWJGL natives.", ex);
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGraphics.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGraphics.java
index 2973295..5d2b848 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGraphics.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtGraphics.java
@@ -25,7 +25,6 @@ import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.GL11;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.GLCommon;
-import com.badlogic.gdx.graphics.GLU;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 import com.google.gwt.canvas.client.Canvas;
 import com.google.gwt.dom.client.CanvasElement;
@@ -101,11 +100,6 @@ public class GwtGraphics implements Graphics {
 	}
 
 	@Override
-	public GLU getGLU () {
-		return null;
-	}
-
-	@Override
 	public int getWidth () {
 		return canvas.getWidth();
 	}
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtNet.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtNet.java
index 5cb47c1..02fb524 100755
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtNet.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtNet.java
@@ -24,12 +24,12 @@ import java.util.concurrent.Executors;
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.Net;
 import com.badlogic.gdx.Net.HttpRequest;
+import com.badlogic.gdx.net.HttpStatus;
 import com.badlogic.gdx.net.ServerSocket;
 import com.badlogic.gdx.net.ServerSocketHints;
 import com.badlogic.gdx.net.Socket;
 import com.badlogic.gdx.net.SocketHints;
 import com.badlogic.gdx.utils.GdxRuntimeException;
-
 import com.google.gwt.core.client.EntryPoint;
 import com.google.gwt.http.client.Request;
 import com.google.gwt.http.client.RequestBuilder;
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtPreferences.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtPreferences.java
index 3f1a8b8..4345b21 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtPreferences.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtPreferences.java
@@ -139,7 +139,8 @@ public class GwtPreferences implements Preferences {
 
 	@Override
 	public String getString (String key) {
-		return (String)values.get(key);
+		String v = (String)values.get(key);
+		return v == null ? "" : v;
 	}
 
 	@Override
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/assets/AssetManager.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/assets/AssetManager.java
index aa5b54d..727be833 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/assets/AssetManager.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/assets/AssetManager.java
@@ -47,7 +47,7 @@ public class AssetManager implements Disposable {
 	final ObjectMap<String, Class> assetTypes = new ObjectMap<String, Class>();
 	final ObjectMap<String, Array<String>> assetDependencies = new ObjectMap<String, Array<String>>();
 
-	final ObjectMap<Class, AssetLoader> loaders = new ObjectMap<Class, AssetLoader>();
+	final ObjectMap<Class, ObjectMap<String, AssetLoader>> loaders = new ObjectMap<Class, ObjectMap<String, AssetLoader>>();
 	final ArrayList<AssetDescriptor> loadQueue = new ArrayList<AssetDescriptor>();
 
 	Stack<AssetLoadingTask> tasks = new Stack<AssetLoadingTask>();
@@ -201,19 +201,48 @@ public class AssetManager implements Disposable {
 		return assetContainer.getObject(type) != null;
 	}
 
+	/** Returns the default loader for the given type
+	 * @param type The type of the loader to get
+	 * @return The loader capable of loading the type, or null if none exists
+	 */
+	public <T> AssetLoader getLoader(final Class<T> type) {
+		return getLoader(type, null);
+	}
+
+	/** Returns the loader for the given type and the specified filename. If no loader exists for the specific
+	 * filename, the default loader for that type is returned.
+	 * @param type The type of the loader to get
+	 * @param fileName The filename of the asset to get a loader for, or null to get the default loader
+	 * @return The loader capable of loading the type and filename, or null if none exists
+	 */
+	public <T> AssetLoader getLoader(final Class<T> type, final String fileName) {
+		final ObjectMap<String, AssetLoader> loaders = this.loaders.get(type);
+		if (loaders == null || loaders.size < 1) return null;
+		if (fileName == null) return loaders.get("");
+		AssetLoader result = null;
+		int l = -1;
+		for (ObjectMap.Entry<String, AssetLoader> entry : loaders.entries()) {
+			if (entry.key.length() > l && fileName.endsWith(entry.key)) {
+				result = entry.value;
+				l = entry.key.length();
+			}
+		}
+		return result;
+	}
+
 	/** Adds the given asset to the loading queue of the AssetManager.
 	 * @param fileName the file name (interpretation depends on {@link AssetLoader})
 	 * @param type the type of the asset. */
 	public synchronized <T> void load (String fileName, Class<T> type) {
 		load(fileName, type, null);
 	}
-
+	
 	/** Adds the given asset to the loading queue of the AssetManager.
 	 * @param fileName the file name (interpretation depends on {@link AssetLoader})
 	 * @param type the type of the asset.
 	 * @param parameter parameters for the AssetLoader. */
 	public synchronized <T> void load (String fileName, Class<T> type, AssetLoaderParameters<T> parameter) {
-		AssetLoader loader = loaders.get(type);
+		AssetLoader loader = getLoader(type, fileName);
 		if (loader == null) throw new GdxRuntimeException("No loader for type: " + type.getName());
 
 		if (loadQueue.size() == 0) {
@@ -347,7 +376,7 @@ public class AssetManager implements Disposable {
 	/** Adds a {@link AssetLoadingTask} to the task stack for the given asset.
 	 * @param assetDesc */
 	private void addTask (AssetDescriptor assetDesc) {
-		AssetLoader loader = loaders.get(assetDesc.type);
+		AssetLoader loader = getLoader(assetDesc.type, assetDesc.fileName);
 		if (loader == null) throw new GdxRuntimeException("No loader for type: " + assetDesc.type.getName());
 		tasks.push(new AssetLoadingTask(this, assetDesc, loader));
 	}
@@ -442,10 +471,21 @@ public class AssetManager implements Disposable {
 	 * @param type the type of the asset
 	 * @param loader the loader */
 	public synchronized <T, P extends AssetLoaderParameters<T>> void setLoader (Class<T> type, AssetLoader<T, P> loader) {
+		setLoader(type, null, loader);
+	}
+	
+	/** Sets a new {@link AssetLoader} for the given type.
+	 * @param type the type of the asset
+	 * @param suffix the suffix the filename must have for this loader to be used or null to specify the default loader. 
+	 * @param loader the loader */
+	public synchronized <T, P extends AssetLoaderParameters<T>> void setLoader (Class<T> type, String suffix, AssetLoader<T, P> loader) {
 		if (type == null) throw new IllegalArgumentException("type cannot be null.");
 		if (loader == null) throw new IllegalArgumentException("loader cannot be null.");
 // log.debug("Loader set: " + type.getName() + " -> " + loader.getClass().getName());
-		loaders.put(type, loader);
+		ObjectMap<String, AssetLoader> loaders = this.loaders.get(type);
+		if (loaders == null)
+			this.loaders.put(type, loaders = new ObjectMap<String, AssetLoader>());
+		loaders.put(suffix == null ? "" : suffix, loader);
 	}
 
 	/** @return the number of loaded assets */
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/maps/MapLayers.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/maps/MapLayers.java
index ea047b1..cb516c7 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/maps/MapLayers.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/maps/MapLayers.java
@@ -5,32 +5,24 @@ import java.util.Iterator;
 import com.badlogic.gdx.utils.Array;
 
 /**
- * @brief set of MapLayer instances
+ * Ordered list of {@link MapLayer} instances owned by a {@link Map}
  */
 public class MapLayers implements Iterable<MapLayer> {
-	
 	private Array<MapLayer> layers = new Array<MapLayer>();
 
 	/**
-	 * Creates empty set of layers
-	 */
-	public MapLayers() {
-	
-	}
-	
-	/**
 	 * @param index
 	 * @return layer at index
 	 */
-	public MapLayer getLayer(int index) {
+	public MapLayer get(int index) {
 		return layers.get(index);
 	}
 	
 	/**
 	 * @param name
-	 * @return matching layer if exists, otherwise, null
+	 * @return first layer matching the name, null otherwise
 	 */
-	public MapLayer getLayer(String name) {
+	public MapLayer get(String name) {
 		for (MapLayer layer : layers) {
 			if (name.equals(layer.getName())) {
 				return layer;
@@ -39,24 +31,29 @@ public class MapLayers implements Iterable<MapLayer> {
 		return null;
 	}
 	
+	/** @return number of layers in the collection */
+	public int getCount() {
+		return layers.size;
+	}
+
 	/**
 	 * @param layer layer to be added to the set
 	 */
-	public void addLayer(MapLayer layer) {
+	public void add(MapLayer layer) {
 		this.layers.add(layer);
 	}
 	
 	/**
 	 * @param index removes layer at index
 	 */
-	public void removeLayer(int index) {
+	public void remove(int index) {
 		layers.removeIndex(index);
 	}
 	
 	/**
 	 * @param layer layer to be removed
 	 */
-	public void removeLayer(MapLayer layer) {
+	public void remove(MapLayer layer) {
 		layers.removeValue(layer, true);
 	}
 
@@ -64,8 +61,8 @@ public class MapLayers implements Iterable<MapLayer> {
 	 * @param type
 	 * @return array with all the layers matching type
 	 */
-	public <T extends MapLayer> Array<T> getLayersByType(Class<T> type) {
-		return getLayersByType(type, new Array<T>());	
+	public <T extends MapLayer> Array<T> getByType(Class<T> type) {
+		return getByType(type, new Array<T>());
 	}
 	
 	/**
@@ -74,7 +71,7 @@ public class MapLayers implements Iterable<MapLayer> {
 	 * @param fill array to be filled with the matching layers
 	 * @return array with all the layers matching type
 	 */
-	public <T extends MapLayer> Array<T> getLayersByType(Class<T> type, Array<T> fill) {
+	public <T extends MapLayer> Array<T> getByType(Class<T> type, Array<T> fill) {
 		fill.clear();
 		for (MapLayer layer : layers) {
 			if (type.equals(layer.getClass())) {
@@ -92,4 +89,4 @@ public class MapLayers implements Iterable<MapLayer> {
 		return layers.iterator();
 	}
 	
-}
+}
\ No newline at end of file
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/maps/MapObjects.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/maps/MapObjects.java
index 46ef3f1..cbfa686 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/maps/MapObjects.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/maps/MapObjects.java
@@ -15,14 +15,14 @@ public class MapObjects implements Iterable<MapObject> {
 	 * Creates and empty set of MapObject instances
 	 */
 	public MapObjects() {
-		objects = new Array<MapObject>();		
+		objects = new Array<MapObject>();
 	}
 	
 	/**
 	 * @param index
 	 * @return MapObject at index
 	 */
-	public MapObject getObject(int index) {
+	public MapObject get(int index) {
 		return objects.get(index);
 	}
 	
@@ -30,7 +30,7 @@ public class MapObjects implements Iterable<MapObject> {
 	 * @param name
 	 * @return name matching object, null if it´s not in the set
 	 */
-	public MapObject getObject(String name) {
+	public MapObject get(String name) {
 		for (MapObject object : objects) {
 			if (name.equals(object.getName())) {
 				return object;
@@ -42,28 +42,28 @@ public class MapObjects implements Iterable<MapObject> {
 	/**
 	 * @param object instance to be added to the collection
 	 */
-	public void addObject(MapObject object) {
+	public void add(MapObject object) {
 		this.objects.add(object);
 	}
 	
 	/**
 	 * @param index removes MapObject instance at index
 	 */
-	public void removeObject(int index) {
+	public void remove(int index) {
 		objects.removeIndex(index);
 	}
 	
 	/**
 	 * @param object instance to be removed
 	 */
-	public void removeObject(MapObject object) {
+	public void remove(MapObject object) {
 		objects.removeValue(object, true);
 	}
 	
 	/**
 	 * @return number of objects in the collection
 	 */
-	public int getNumObjects() {
+	public int getCount() {
 		return objects.size;
 	}
 
@@ -71,8 +71,8 @@ public class MapObjects implements Iterable<MapObject> {
 	 * @param type class of the objects we want to retrieve
 	 * @return array filled with all the objects in the collection matching type
 	 */
-	public <T extends MapObject> Array<T> getObjectsByType(Class<T> type) {
-		return getObjectsByType(type, new Array<T>());	
+	public <T extends MapObject> Array<T> getByType(Class<T> type) {
+		return getByType(type, new Array<T>());
 	}
 	
 	/**
@@ -80,7 +80,7 @@ public class MapObjects implements Iterable<MapObject> {
 	 * @param fill collection to put the returned objects in
 	 * @return array filled with all the objects in the collection matching type
 	 */
-	public <T extends MapObject> Array<T> getObjectsByType(Class<T> type, Array<T> fill) {
+	public <T extends MapObject> Array<T> getByType(Class<T> type, Array<T> fill) {
 		fill.clear();
 		for (MapObject object : objects) {
 			if (type.equals(object.getClass())) {
@@ -98,4 +98,4 @@ public class MapObjects implements Iterable<MapObject> {
 		return objects.iterator();
 	}
 	
-}
+}
\ No newline at end of file
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/maps/tiled/TmxMapLoader.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/maps/tiled/TmxMapLoader.java
index c1125a3..bbfba6e 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/maps/tiled/TmxMapLoader.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/maps/tiled/TmxMapLoader.java
@@ -17,16 +17,19 @@ import com.badlogic.gdx.files.FileHandle;
 import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.graphics.g2d.TextureRegion;
 import com.badlogic.gdx.maps.ImageResolver;
+import com.badlogic.gdx.maps.ImageResolver.AssetManagerImageResolver;
+import com.badlogic.gdx.maps.ImageResolver.DirectImageResolver;
 import com.badlogic.gdx.maps.MapLayer;
 import com.badlogic.gdx.maps.MapObject;
 import com.badlogic.gdx.maps.MapProperties;
-import com.badlogic.gdx.maps.ImageResolver.AssetManagerImageResolver;
-import com.badlogic.gdx.maps.ImageResolver.DirectImageResolver;
+import com.badlogic.gdx.maps.objects.EllipseMapObject;
 import com.badlogic.gdx.maps.objects.PolygonMapObject;
 import com.badlogic.gdx.maps.objects.PolylineMapObject;
 import com.badlogic.gdx.maps.objects.RectangleMapObject;
 import com.badlogic.gdx.maps.tiled.TiledMapTileLayer.Cell;
 import com.badlogic.gdx.maps.tiled.tiles.StaticTiledMapTile;
+import com.badlogic.gdx.math.Polygon;
+import com.badlogic.gdx.math.Polyline;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.Base64Coder;
 import com.badlogic.gdx.utils.GdxRuntimeException;
@@ -40,16 +43,21 @@ import com.badlogic.gdx.utils.XmlReader.Element;
 public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.Parameters> {
 
 	public static class Parameters extends AssetLoaderParameters<TiledMap> {
-		
+		/** Whether to load the map for a y-up coordinate system */
+		boolean yUp = true;
 	}
 	
-	private static final int FLAG_FLIP_HORIZONTALLY = 0x80000000;
-	private static final int FLAG_FLIP_VERTICALLY = 0x40000000;
-	private static final int FLAG_FLIP_DIAGONALLY = 0x20000000;		
-	private static final int MASK_CLEAR  = 0xE0000000;
+	protected static final int FLAG_FLIP_HORIZONTALLY = 0x80000000;
+	protected static final int FLAG_FLIP_VERTICALLY = 0x40000000;
+	protected static final int FLAG_FLIP_DIAGONALLY = 0x20000000;
+	protected static final int MASK_CLEAR  = 0xE0000000;
 	
-	private XmlReader xml = new XmlReader();
-	private Element root;
+	protected XmlReader xml = new XmlReader();
+	protected Element root;
+	protected boolean yUp;
+
+	protected int mapWidthInPixels;
+	protected int mapHeightInPixels;
 	
 	public TmxMapLoader() {
 		super(new InternalFileHandleResolver());
@@ -67,12 +75,26 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 	/**
 	 * Loads the {@link TiledMap} from the given file. The file is
 	 * resolved via the {@link FileHandleResolver} set in the constructor
-	 * of this class. By default it will resolve to an internal file.
+	 * of this class. By default it will resolve to an internal file. The
+	 * map will be loaded for a y-up coordinate system.
 	 * @param fileName the filename
 	 * @return the TiledMap
 	 */
 	public TiledMap load(String fileName) {
+		return load(fileName, true);
+	}
+
+	/**
+	 * Loads the {@link TiledMap} from the given file. The file is
+	 * resolved via the {@link FileHandleResolver} set in the constructor
+	 * of this class. By default it will resolve to an internal file.
+	 * @param fileName the filename
+	 * @param yUp whether to load the map for a y-up coordinate system
+	 * @return the TiledMap
+	 */
+	public TiledMap load(String fileName, boolean yUp) {
 		try {
+			this.yUp = yUp;
 			FileHandle tmxFile = resolve(fileName);
 			root = xml.parse(tmxFile);
 			ObjectMap<String, Texture> textures = new ObjectMap<String, Texture>();
@@ -91,6 +113,11 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 	@Override
 	public TiledMap load(AssetManager assetManager, String fileName, Parameters parameter) {
 		FileHandle tmxFile = resolve(fileName);
+		if (parameter != null) {
+			yUp = parameter.yUp;
+		} else {
+			yUp = true;
+		}
 		try {
 			return loadTilemap(root, tmxFile, new AssetManagerImageResolver(assetManager));
 		} catch (Exception e) {
@@ -128,8 +155,30 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 	 * @param imageResolver the {@link ImageResolver}
 	 * @return the {@link TiledMap}
 	 */
-	private TiledMap loadTilemap(Element root, FileHandle tmxFile, ImageResolver imageResolver) {
+	protected TiledMap loadTilemap(Element root, FileHandle tmxFile, ImageResolver imageResolver) {
 		TiledMap map = new TiledMap();
+		
+		String mapOrientation = root.getAttribute("orientation", null);
+		int mapWidth = root.getIntAttribute("width", 0);
+		int mapHeight = root.getIntAttribute("height", 0);
+		int tileWidth = root.getIntAttribute("tilewidth", 0);
+		int tileHeight = root.getIntAttribute("tileheight", 0);
+		String mapBackgroundColor = root.getAttribute("backgroundcolor", null);
+		
+		MapProperties mapProperties = map.getProperties();
+		if (mapOrientation != null) {
+			mapProperties.put("orientation", mapBackgroundColor);
+		}
+		mapProperties.put("width", mapWidth);
+		mapProperties.put("height", mapHeight);
+		mapProperties.put("tilewidth", tileWidth);
+		mapProperties.put("tileheight", tileHeight);
+		if (mapBackgroundColor != null) {
+			mapProperties.put("backgroundcolor", mapBackgroundColor);
+		}
+		mapWidthInPixels = mapWidth * tileWidth;
+		mapHeightInPixels = mapHeight * tileHeight;
+		
 		Element properties = root.getChildByName("properties");
 		if (properties != null) {
 			loadProperties(map.getProperties(), properties);
@@ -157,7 +206,7 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 	 * @return a list of filenames for images containing tiles
 	 * @throws IOException 
 	 */
-	private Array<FileHandle> loadTilesets(Element root, FileHandle tmxFile) throws IOException {
+	protected Array<FileHandle> loadTilesets(Element root, FileHandle tmxFile) throws IOException {
 		Array<FileHandle> images = new Array<FileHandle>();
 		for (Element tileset : root.getChildrenByName("tileset")) {
 			String source = tileset.getAttribute("source", null);
@@ -176,7 +225,7 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 		return images;
 	}
 
-	private void loadTileSet(TiledMap map, Element element, FileHandle tmxFile, ImageResolver imageResolver) {
+	protected void loadTileSet(TiledMap map, Element element, FileHandle tmxFile, ImageResolver imageResolver) {
 		if (element.getName().equals("tileset")) {
 			String name = element.get("name", null);
 			int firstgid = element.getIntAttribute("firstgid", 1);
@@ -217,7 +266,12 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 			
 			for (int y = margin; y <= stopHeight; y += tileheight + spacing) {
 				for (int x = margin; x <= stopWidth; x += tilewidth + spacing) {
-					TiledMapTile tile = new StaticTiledMapTile(new TextureRegion(texture, x, y, tilewidth, tileheight));
+					TextureRegion tileRegion = new TextureRegion(texture, x, y, tilewidth, tileheight);
+					if (!yUp) {
+						tileRegion.flip(false, true);
+					}
+					TiledMapTile tile = new StaticTiledMapTile(tileRegion);
+					tile.setId(id);
 					tileset.putTile(id++, tile);
 				}
 			}
@@ -228,7 +282,7 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 				int localtid = tileElement.getIntAttribute("id", 0);
 				TiledMapTile tile = tileset.getTile(firstgid + localtid);
 				if (tile!= null) {
-					Element properties = element.getChildByName("properties");
+					Element properties = tileElement.getChildByName("properties");
 					if (properties != null) {
 						loadProperties(tile.getProperties(), properties);
 					}
@@ -243,14 +297,18 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 		}		
 	}
 	
-	private void loadTileLayer(TiledMap map, Element element) {
+	protected void loadTileLayer(TiledMap map, Element element) {
 		if (element.getName().equals("layer")) {
 			String name = element.getAttribute("name", null);
 			int width = element.getIntAttribute("width", 0);
 			int height = element.getIntAttribute("height", 0);
 			int tileWidth = element.getParent().getIntAttribute("tilewidth", 0);
 			int tileHeight = element.getParent().getIntAttribute("tileheight", 0);
+			boolean visible = element.getIntAttribute("visible", 1) == 1;
+			float opacity = element.getFloatAttribute("opacity", 1.0f);
 			TiledMapTileLayer layer = new TiledMapTileLayer(width, height, tileWidth, tileHeight);
+			layer.setVisible(visible);
+			layer.setOpacity(opacity);
 			layer.setName(name);
 			
 			TiledMapTileSets tilesets = map.getTileSets();
@@ -277,21 +335,21 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 							if (flipDiagonally) {
 								if (flipHorizontally && flipVertically) {
 									cell.setFlipHorizontally(true);
-									cell.setRotation(Cell.ROTATE_90);
+									cell.setRotation(Cell.ROTATE_270);
 								} else if (flipHorizontally) {
-									cell.setRotation(Cell.ROTATE_90);
-								} else if (flipVertically) {
 									cell.setRotation(Cell.ROTATE_270);
+								} else if (flipVertically) {
+									cell.setRotation(Cell.ROTATE_90);
 								} else {
 									cell.setFlipVertically(true);
-									cell.setRotation(Cell.ROTATE_90);
+									cell.setRotation(Cell.ROTATE_270);
 								}
 							} else {
 								cell.setFlipHorizontally(flipHorizontally);
 								cell.setFlipVertically(flipVertically);
 							}
 							cell.setTile(tile);
-							layer.setCell(x, height - 1 - y, cell);
+							layer.setCell(x, yUp ? height - 1 - y : y, cell);
 						}
 					}
 				}
@@ -322,28 +380,28 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 									if (flipDiagonally) {
 										if (flipHorizontally && flipVertically) {
 											cell.setFlipHorizontally(true);
-											cell.setRotation(Cell.ROTATE_90);
+											cell.setRotation(Cell.ROTATE_270);
 										} else if (flipHorizontally) {
-											cell.setRotation(Cell.ROTATE_90);
-										} else if (flipVertically) {
 											cell.setRotation(Cell.ROTATE_270);
+										} else if (flipVertically) {
+											cell.setRotation(Cell.ROTATE_90);
 										} else {
 											cell.setFlipVertically(true);
-											cell.setRotation(Cell.ROTATE_90);
+											cell.setRotation(Cell.ROTATE_270);
 										}
 									} else {
 										cell.setFlipHorizontally(flipHorizontally);
 										cell.setFlipVertically(flipVertically);
 									}
 									cell.setTile(tile);
-									layer.setCell(x, height - 1 - y, cell);
+									layer.setCell(x, yUp ? height - 1 - y : y, cell);
 								}
 							}
 						}
 					} else if (compression.equals("gzip")) {
-						throw new GdxRuntimeException("Not supported in GWT backend");
+						throw new GdxRuntimeException("GZIP compression not supported in GWT backend");
 					} else if (compression.equals("zlib")) {
-						throw new GdxRuntimeException("Not supported in GWT backend");
+						throw new GdxRuntimeException("ZLIB compression not supported in GWT backend");
 					}
 				}
 			}
@@ -351,11 +409,11 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 			if (properties != null) {
 				loadProperties(layer.getProperties(), properties);
 			}
-			map.getLayers().addLayer(layer);
+			map.getLayers().add(layer);
 		}		
 	}
 	
-	public void loadObjectGroup(TiledMap map, Element element) {
+	protected void loadObjectGroup(TiledMap map, Element element) {
 		if (element.getName().equals("objectgroup")) {
 			String name = element.getAttribute("name", null);
 			MapLayer layer = new MapLayer();
@@ -369,66 +427,76 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 				loadObject(layer, objectElement);
 			}
 
-			map.getLayers().addLayer(layer);
+			map.getLayers().add(layer);
 		}
 	}
 	
-	private void loadObject(MapLayer layer, Element element) {
+	protected void loadObject(MapLayer layer, Element element) {
 		if (element.getName().equals("object")) {
 			MapObject object = null;
 			
 			int x = element.getIntAttribute("x", 0);
-			int y = element.getIntAttribute("y", 0);
-			
+			int y = (yUp ? mapHeightInPixels - element.getIntAttribute("y", 0) : element.getIntAttribute("y", 0));
+
 			int width = element.getIntAttribute("width", 0);
 			int height = element.getIntAttribute("height", 0);
 			
 			if (element.getChildCount() > 0) {
-				Element child = element.getChildByName("polygon");
-				if (child != null) {
+				Element child = null;
+				if ((child = element.getChildByName("polygon")) != null) {
 					String[] points = child.getAttribute("points").split(" ");
 					float[] vertices = new float[points.length * 2];
 					for (int i = 0; i < points.length; i++) {
 						String[] point = points[i].split(",");
-						vertices[i * 2] = x + Integer.parseInt(point[0]);
-						vertices[i * 2 + 1] = y + Integer.parseInt(point[1]);
+						vertices[i * 2] = Integer.parseInt(point[0]);
+						vertices[i * 2 + 1] = Integer.parseInt(point[1]);
+						if (yUp) {
+							vertices[i * 2 + 1] *= -1;
+						}
 					}
-					object = new PolygonMapObject(vertices);
-				} else {
-					child = element.getChildByName("polyline");
-					if (child != null) {
-						String[] points = child.getAttribute("points").split(" ");
-						float[] vertices = new float[points.length * 2];
-						for (int i = 0; i < points.length; i++) {
-							String[] point = points[i].split(",");
-							vertices[i * 2] = x + Integer.parseInt(point[0]);
-							vertices[i * 2 + 1] = y + Integer.parseInt(point[1]);
+					Polygon polygon = new Polygon(vertices);
+					polygon.setPosition(x, y);
+					object = new PolygonMapObject(polygon);
+				} else if ((child = element.getChildByName("polyline")) != null) {
+					String[] points = child.getAttribute("points").split(" ");
+					float[] vertices = new float[points.length * 2];
+					for (int i = 0; i < points.length; i++) {
+						String[] point = points[i].split(",");
+						vertices[i * 2] = Integer.parseInt(point[0]);
+						vertices[i * 2 + 1] = Integer.parseInt(point[1]);
+						if (yUp) {
+							vertices[i * 2 + 1] *= -1;
 						}
-						object = new PolylineMapObject(vertices);
 					}
+					Polyline polyline = new Polyline(vertices);
+					polyline.setPosition(x, y);
+					object = new PolylineMapObject(polyline);
+				} else if ((child = element.getChildByName("ellipse")) != null) {
+					object = new EllipseMapObject(x, yUp ? y - height : y, width, height);
 				}
 			}
 			if (object == null) {
-				object = new RectangleMapObject(x, y, width, height);
+				object = new RectangleMapObject(x, yUp ? y - height : y, width, height);
 			}
 			object.setName(element.getAttribute("name", null));
 			String type = element.getAttribute("type", null);
 			if (type != null) {
 				object.getProperties().put("type", type);
 			}
+			object.setVisible(element.getIntAttribute("visible", 1) == 1);
 			Element properties = element.getChildByName("properties");
 			if (properties != null) {
 				loadProperties(object.getProperties(), properties);
 			}
-			layer.getObjects().addObject(object);
+			layer.getObjects().add(object);
 		}
 	}
 	
-	private void loadProperties(MapProperties properties, Element element) {
+	protected void loadProperties(MapProperties properties, Element element) {
 		if (element.getName().equals("properties")) {
 			for (Element property : element.getChildrenByName("property")) {
 				String name = property.getAttribute("name", null);
-				String value = property.getAttribute(name, null);
+				String value = property.getAttribute("value", null);
 				if (value == null) {
 					value = property.getText();
 				}
@@ -437,7 +505,7 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 		}
 	}
 	
-	private static FileHandle getRelativeFileHandle(FileHandle file, String path) {
+	protected static FileHandle getRelativeFileHandle(FileHandle file, String path) {
 		StringTokenizer tokenizer = new StringTokenizer(path, "\\/");
 		FileHandle result = file.parent();
 		while (tokenizer.hasMoreElements()) {
@@ -451,7 +519,7 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 		return result;		
 	}
 	
-	private static int unsignedByteToInt (byte b) {
+	protected static int unsignedByteToInt (byte b) {
 		return (int) b & 0xFF;
 	}
 
diff --git a/build.xml b/build.xml
index ed23270..5320e29 100644
--- a/build.xml
+++ b/build.xml
@@ -61,7 +61,7 @@
 			<reference refid="classpath"/>
 		</ant>
 	</target>
-	
+
 	<!-- gdx lwjgl backend -->
 	<target name="gdx-backend-lwjgl" depends="gdx-core,gdx-openal">
 		<path id="classpath">
@@ -75,7 +75,21 @@
 			<reference refid="jarfiles"/>
 		</ant>
 	</target>
-	
+
+	<!-- gdx jglfw backend -->
+	<target name="gdx-backend-jglfw" depends="gdx-core">
+		<mkdir dir="backends/gdx-backend-jglfw/libs"/>
+		<get src="http://libgdx.badlogicgames.com/jglfw/nightlies/dist/jglfw.jar" dest="backends/gdx-backend-jglfw/libs/jglfw.jar"/>
+		<get src="http://libgdx.badlogicgames.com/jglfw/nightlies/dist/jglfw-natives.jar" dest="backends/gdx-backend-jglfw/libs/gdx-backend-jglfw-natives.jar"/>
+		<path id="classpath">
+			<pathelement location="${distDir}/gdx.jar"/>
+		</path>
+		<ant antfile="../../build-template.xml" dir="backends/gdx-backend-jglfw">
+			<property name="jar" value="gdx-backend-jglfw"/>
+			<reference refid="classpath"/>
+		</ant>
+	</target>
+
 	<!-- gdx android backend -->
 	<target name="gdx-backend-android" depends="gdx-core">
 		<path id="classpath">
@@ -142,10 +156,9 @@
 		</ant>
 	</target>
 	
-	<target name="gdx-controllers-desktop" depends="gdx-core,gdx-backend-lwjgl,gdx-jnigen,gdx-controllers">
+	<target name="gdx-controllers-desktop" depends="gdx-core,gdx-jnigen,gdx-controllers">
 		<path id="classpath">
 			<pathelement location="${distDir}/gdx.jar"/>
-			<pathelement location="${distDir}/gdx-backend-lwjgl.jar"/>
 			<pathelement location="${distDir}/extensions/gdx-jnigen/gdx-jnigen.jar"/>
 			<pathelement location="${distDir}/extensions/gdx-controllers/gdx-controllers.jar"/>
 		</path>
@@ -272,6 +285,7 @@
 				<exclude name="com/badlogic/gdx/utils/XmlReader.rl" />
 				<exclude name="com/badlogic/gdx/utils/JsonReader.rl" />
 			</fileset>			
+			<fileset dir="backends" includes="gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwApplication.java"/>
 			<fileset dir="backends" includes="gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplication.java"/>
 			<fileset dir="backends" includes="gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglCanvas.java"/>
 			<fileset dir="backends" includes="gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplet.java"/>
@@ -330,7 +344,7 @@
 	</target>
 
 	<target name="jars" 
-depends="clean,gdx-setup-ui,gdx-core,gdx-openal,gdx-backend-lwjgl,gdx-backend-android,gdx-backend-gwt,gdx-backend-iosmonotouch,gdx-tools,gdx-controllers,gdx-controllers-desktop,gdx-controllers-android,gdx-controllers-gwt,gdx-image,gdx-audio,gdx-freetype,gdx-bullet"/>
+depends="clean,gdx-setup-ui,gdx-core,gdx-openal,gdx-backend-lwjgl,gdx-backend-jglfw,gdx-backend-android,gdx-backend-gwt,gdx-backend-iosmonotouch,gdx-tools,gdx-controllers,gdx-controllers-desktop,gdx-controllers-android,gdx-controllers-gwt,gdx-image,gdx-audio,gdx-freetype,gdx-bullet"/>
 
 	<target name="all" depends="jars,docs,copy-iosfiles">
 		<!-- copy distribution files (licences etc.) -->
diff --git a/demos/cuboc/cuboc-android/project.properties b/demos/cuboc/cuboc-android/project.properties
index 2cc58fa..c4f09d2 100644
--- a/demos/cuboc/cuboc-android/project.properties
+++ b/demos/cuboc/cuboc-android/project.properties
@@ -8,4 +8,4 @@
 # project structure.
 
 # Project target.
-target=android-12
+target=android-17
diff --git a/demos/invaders/gdx-invaders-android/project.properties b/demos/invaders/gdx-invaders-android/project.properties
index c1fd41a..fd44ee5 100644
--- a/demos/invaders/gdx-invaders-android/project.properties
+++ b/demos/invaders/gdx-invaders-android/project.properties
@@ -10,4 +10,4 @@
 # Indicates whether an apk should be generated for each density.
 split.density=false
 # Project target.
-target=android-8
+target=android-17
diff --git a/demos/metagun/metagun-android/project.properties b/demos/metagun/metagun-android/project.properties
index f049142..c4f09d2 100644
--- a/demos/metagun/metagun-android/project.properties
+++ b/demos/metagun/metagun-android/project.properties
@@ -8,4 +8,4 @@
 # project structure.
 
 # Project target.
-target=android-10
+target=android-17
diff --git a/demos/pax-britannica/pax-britannica-android/project.properties b/demos/pax-britannica/pax-britannica-android/project.properties
index 9b84a6b..a3ee5ab 100755
--- a/demos/pax-britannica/pax-britannica-android/project.properties
+++ b/demos/pax-britannica/pax-britannica-android/project.properties
@@ -11,4 +11,4 @@
 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
 
 # Project target.
-target=android-16
+target=android-17
diff --git a/demos/superjumper/superjumper-android/project.properties b/demos/superjumper/superjumper-android/project.properties
index f049142..c4f09d2 100644
--- a/demos/superjumper/superjumper-android/project.properties
+++ b/demos/superjumper/superjumper-android/project.properties
@@ -8,4 +8,4 @@
 # project structure.
 
 # Project target.
-target=android-10
+target=android-17
diff --git a/demos/superjumper/superjumper-ios/superjumper-ios.userprefs b/demos/superjumper/superjumper-ios/superjumper-ios.userprefs
index a96e05d..702e9e4 100644
--- a/demos/superjumper/superjumper-ios/superjumper-ios.userprefs
+++ b/demos/superjumper/superjumper-ios/superjumper-ios.userprefs
@@ -1,14 +1,16 @@
 ﻿<Properties>
-  <MonoDevelop.Ide.Workspace ActiveConfiguration="Release|iPhoneSimulator" PreferredExecutionTarget="MonoDevelop.IPhone.IPhoneSimulatorTarget.IPhone.6.0" />
+  <MonoDevelop.Ide.Workspace ActiveConfiguration="Debug|iPhoneSimulator" PreferredExecutionTarget="MonoDevelop.IPhone.IPhoneSimulatorTarget.IPhone.6.1" />
   <MonoDevelop.Ide.Workbench ActiveDocument="superjumper-ios/Main.cs">
     <Files>
-      <File FileName="superjumper-ios/Main.cs" Line="10" Column="25" />
+      <File FileName="superjumper-ios/Main.cs" Line="8" Column="11" />
       <File FileName="superjumper-ios/Info.plist" />
     </Files>
     <Pads>
       <Pad Id="ProjectPad">
         <State expanded="True">
-          <Node name="superjumper-ios" expanded="True" selected="True" />
+          <Node name="superjumper-ios" expanded="True">
+            <Node name="Main.cs" selected="True" />
+          </Node>
         </State>
       </Pad>
     </Pads>
diff --git a/demos/vector-pinball/gdx-vectorpinball-android/project.properties b/demos/vector-pinball/gdx-vectorpinball-android/project.properties
index ea89160..c4f09d2 100644
--- a/demos/vector-pinball/gdx-vectorpinball-android/project.properties
+++ b/demos/vector-pinball/gdx-vectorpinball-android/project.properties
@@ -8,4 +8,4 @@
 # project structure.
 
 # Project target.
-target=android-8
+target=android-17
diff --git a/demos/very-angry-robots/very-angry-robots-android/project.properties b/demos/very-angry-robots/very-angry-robots-android/project.properties
index ea89160..c4f09d2 100644
--- a/demos/very-angry-robots/very-angry-robots-android/project.properties
+++ b/demos/very-angry-robots/very-angry-robots-android/project.properties
@@ -8,4 +8,4 @@
 # project structure.
 
 # Project target.
-target=android-8
+target=android-17
diff --git a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/SWIGTYPE_p_btAlignedObjectArrayT_btBroadphasePair_t.java b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/SWIGTYPE_p_btAlignedObjectArrayT_btBroadphasePair_t.java
deleted file mode 100755
index 9b7ae20..0000000
--- a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/SWIGTYPE_p_btAlignedObjectArrayT_btBroadphasePair_t.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 2.0.9
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet;
-
-public class SWIGTYPE_p_btAlignedObjectArrayT_btBroadphasePair_t {
-  private long swigCPtr;
-
-  protected SWIGTYPE_p_btAlignedObjectArrayT_btBroadphasePair_t(long cPtr, boolean futureUse) {
-    swigCPtr = cPtr;
-  }
-
-  protected SWIGTYPE_p_btAlignedObjectArrayT_btBroadphasePair_t() {
-    swigCPtr = 0;
-  }
-
-  public static long getCPtr(SWIGTYPE_p_btAlignedObjectArrayT_btBroadphasePair_t obj) {
-    return (obj == null) ? 0 : obj.swigCPtr;
-  }
-}
-
diff --git a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/SWIGTYPE_p_btAlignedObjectArrayT_btPersistentManifold_p_t.java b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/SWIGTYPE_p_btAlignedObjectArrayT_btPersistentManifold_p_t.java
deleted file mode 100755
index 58be5a9..0000000
--- a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/SWIGTYPE_p_btAlignedObjectArrayT_btPersistentManifold_p_t.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (http://www.swig.org).
- * Version 2.0.9
- *
- * Do not make changes to this file unless you know what you are doing--modify
- * the SWIG interface file instead.
- * ----------------------------------------------------------------------------- */
-
-package com.badlogic.gdx.physics.bullet;
-
-public class SWIGTYPE_p_btAlignedObjectArrayT_btPersistentManifold_p_t {
-  private long swigCPtr;
-
-  protected SWIGTYPE_p_btAlignedObjectArrayT_btPersistentManifold_p_t(long cPtr, boolean futureUse) {
-    swigCPtr = cPtr;
-  }
-
-  protected SWIGTYPE_p_btAlignedObjectArrayT_btPersistentManifold_p_t() {
-    swigCPtr = 0;
-  }
-
-  public static long getCPtr(SWIGTYPE_p_btAlignedObjectArrayT_btPersistentManifold_p_t obj) {
-    return (obj == null) ? 0 : obj.swigCPtr;
-  }
-}
-
diff --git a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btBroadphasePairArray.java b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btBroadphasePairArray.java
new file mode 100644
index 0000000..006f790
--- /dev/null
+++ b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btBroadphasePairArray.java
@@ -0,0 +1,84 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.9
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package com.badlogic.gdx.physics.bullet;
+
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.math.Quaternion;
+import com.badlogic.gdx.math.Matrix3;
+import com.badlogic.gdx.math.Matrix4;
+
+public class btBroadphasePairArray {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected btBroadphasePairArray(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  public static long getCPtr(btBroadphasePairArray obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        gdxBulletJNI.delete_btBroadphasePairArray(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+	/**
+	 * @param out The array to fill with collision objects
+	 * @param other The collision object the pair must contain (which itself is excluded from the result)
+	 * @param tempArray A temporary array used by the method, not more object than the length of this array are added 
+	 * @return The array specified by out */
+	public com.badlogic.gdx.utils.Array<btCollisionObject> getCollisionObjects(final com.badlogic.gdx.utils.Array<btCollisionObject> out, final btCollisionObject other, final int[] tempArray) {
+		final int c = getCollisionObjects(tempArray, tempArray.length, (int)btCollisionObject.getCPtr(other));
+		for (int i = 0; i < c; i++)
+			out.add(btCollisionObject.getInstance(tempArray[i], false));
+		return out;
+	}
+	
+	/** Fills the given array with user value set using {@link btCollisionObject#setUserValue(int)} of the collision objects
+	 * within this pair array colliding with the given collision object.
+	 * @param out The array to fill with the user values
+	 * @param other The collision object the pair must contain (which itself is excluded from the result)
+	 * @return The amount of user values set in the out array. */
+	public int getCollisionObjectsValue(final int[] out, final btCollisionObject other) {
+		return getCollisionObjectsValue(out, out.length, (int)btCollisionObject.getCPtr(other));
+	}
+
+  public int size() {
+    return gdxBulletJNI.btBroadphasePairArray_size(swigCPtr, this);
+  }
+
+  public btBroadphasePair at(int n) {
+    return new btBroadphasePair(gdxBulletJNI.btBroadphasePairArray_at(swigCPtr, this, n), false);
+  }
+
+  public int getCollisionObjects(int[] result, int max, int other) {
+    return gdxBulletJNI.btBroadphasePairArray_getCollisionObjects(swigCPtr, this, result, max, other);
+  }
+
+  public int getCollisionObjectsValue(int[] result, int max, int other) {
+    return gdxBulletJNI.btBroadphasePairArray_getCollisionObjectsValue(swigCPtr, this, result, max, other);
+  }
+
+  public btBroadphasePairArray() {
+    this(gdxBulletJNI.new_btBroadphasePairArray(), true);
+  }
+
+}
diff --git a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btCollisionAlgorithm.java b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btCollisionAlgorithm.java
index 2a1b032..f6c8ac7 100755
--- a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btCollisionAlgorithm.java
+++ b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btCollisionAlgorithm.java
@@ -48,8 +48,8 @@ public class btCollisionAlgorithm {
     return gdxBulletJNI.btCollisionAlgorithm_calculateTimeOfImpact(swigCPtr, this, btCollisionObject.getCPtr(body0), body0, btCollisionObject.getCPtr(body1), body1, btDispatcherInfo.getCPtr(dispatchInfo), dispatchInfo, btManifoldResult.getCPtr(resultOut), resultOut);
   }
 
-  public void getAllContactManifolds(SWIGTYPE_p_btAlignedObjectArrayT_btPersistentManifold_p_t manifoldArray) {
-    gdxBulletJNI.btCollisionAlgorithm_getAllContactManifolds(swigCPtr, this, SWIGTYPE_p_btAlignedObjectArrayT_btPersistentManifold_p_t.getCPtr(manifoldArray));
+  public void getAllContactManifolds(btManifoldArray manifoldArray) {
+    gdxBulletJNI.btCollisionAlgorithm_getAllContactManifolds(swigCPtr, this, btManifoldArray.getCPtr(manifoldArray), manifoldArray);
   }
 
 }
diff --git a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btCollisionObject.java b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btCollisionObject.java
index 06ccfe4..50fabc7 100755
--- a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btCollisionObject.java
+++ b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btCollisionObject.java
@@ -320,6 +320,14 @@ public class btCollisionObject implements
     gdxBulletJNI.btCollisionObject_getInterpolationAngularVelocity__SWIG_1(swigCPtr, this, out);
   }
 
+  public int getUserValue() {
+    return gdxBulletJNI.btCollisionObject_getUserValue(swigCPtr, this);
+  }
+
+  public void setUserValue(int value) {
+    gdxBulletJNI.btCollisionObject_setUserValue(swigCPtr, this, value);
+  }
+
   public final static class CollisionFlags {
     public final static int CF_STATIC_OBJECT = 1;
     public final static int CF_KINEMATIC_OBJECT = 2;
diff --git a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btHashedOverlappingPairCache.java b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btHashedOverlappingPairCache.java
index 4b0c991..20f60b6 100755
--- a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btHashedOverlappingPairCache.java
+++ b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btHashedOverlappingPairCache.java
@@ -53,8 +53,8 @@ public class btHashedOverlappingPairCache extends btOverlappingPairCache {
     return (cPtr == 0) ? null : new btBroadphasePair(cPtr, false);
   }
 
-  public SWIGTYPE_p_btAlignedObjectArrayT_btBroadphasePair_t getOverlappingPairArray() {
-    return new SWIGTYPE_p_btAlignedObjectArrayT_btBroadphasePair_t(gdxBulletJNI.btHashedOverlappingPairCache_getOverlappingPairArray__SWIG_0(swigCPtr, this), false);
+  public btBroadphasePairArray getOverlappingPairArray() {
+    return new btBroadphasePairArray(gdxBulletJNI.btHashedOverlappingPairCache_getOverlappingPairArray__SWIG_0(swigCPtr, this), false);
   }
 
   public int GetCount() {
diff --git a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btManifoldArray.java b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btManifoldArray.java
new file mode 100644
index 0000000..e215661
--- /dev/null
+++ b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btManifoldArray.java
@@ -0,0 +1,128 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 2.0.9
+ *
+ * Do not make changes to this file unless you know what you are doing--modify
+ * the SWIG interface file instead.
+ * ----------------------------------------------------------------------------- */
+
+package com.badlogic.gdx.physics.bullet;
+
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.math.Quaternion;
+import com.badlogic.gdx.math.Matrix3;
+import com.badlogic.gdx.math.Matrix4;
+
+public class btManifoldArray {
+  private long swigCPtr;
+  protected boolean swigCMemOwn;
+
+  protected btManifoldArray(long cPtr, boolean cMemoryOwn) {
+    swigCMemOwn = cMemoryOwn;
+    swigCPtr = cPtr;
+  }
+
+  public static long getCPtr(btManifoldArray obj) {
+    return (obj == null) ? 0 : obj.swigCPtr;
+  }
+
+  protected void finalize() {
+    delete();
+  }
+
+  public synchronized void delete() {
+    if (swigCPtr != 0) {
+      if (swigCMemOwn) {
+        swigCMemOwn = false;
+        gdxBulletJNI.delete_btManifoldArray(swigCPtr);
+      }
+      swigCPtr = 0;
+    }
+  }
+
+  public btManifoldArray() {
+    this(gdxBulletJNI.new_btManifoldArray__SWIG_0(), true);
+  }
+
+  public btManifoldArray(btManifoldArray otherArray) {
+    this(gdxBulletJNI.new_btManifoldArray__SWIG_1(btManifoldArray.getCPtr(otherArray), otherArray), true);
+  }
+
+  public int size() {
+    return gdxBulletJNI.btManifoldArray_size(swigCPtr, this);
+  }
+
+  public btPersistentManifold at(int n) {
+    long cPtr = gdxBulletJNI.btManifoldArray_at__SWIG_0(swigCPtr, this, n);
+    return (cPtr == 0) ? null : new btPersistentManifold(cPtr, false);
+  }
+
+  public void clear() {
+    gdxBulletJNI.btManifoldArray_clear(swigCPtr, this);
+  }
+
+  public void pop_back() {
+    gdxBulletJNI.btManifoldArray_pop_back(swigCPtr, this);
+  }
+
+  public void resizeNoInitialize(int newsize) {
+    gdxBulletJNI.btManifoldArray_resizeNoInitialize(swigCPtr, this, newsize);
+  }
+
+  public void resize(int newsize, btPersistentManifold fillData) {
+    gdxBulletJNI.btManifoldArray_resize__SWIG_0(swigCPtr, this, newsize, btPersistentManifold.getCPtr(fillData), fillData);
+  }
+
+  public void resize(int newsize) {
+    gdxBulletJNI.btManifoldArray_resize__SWIG_1(swigCPtr, this, newsize);
+  }
+
+  public SWIGTYPE_p_p_btPersistentManifold expandNonInitializing() {
+    return new SWIGTYPE_p_p_btPersistentManifold(gdxBulletJNI.btManifoldArray_expandNonInitializing(swigCPtr, this), false);
+  }
+
+  public SWIGTYPE_p_p_btPersistentManifold expand(btPersistentManifold fillValue) {
+    return new SWIGTYPE_p_p_btPersistentManifold(gdxBulletJNI.btManifoldArray_expand__SWIG_0(swigCPtr, this, btPersistentManifold.getCPtr(fillValue), fillValue), false);
+  }
+
+  public SWIGTYPE_p_p_btPersistentManifold expand() {
+    return new SWIGTYPE_p_p_btPersistentManifold(gdxBulletJNI.btManifoldArray_expand__SWIG_1(swigCPtr, this), false);
+  }
+
+  public void push_back(btPersistentManifold _Val) {
+    gdxBulletJNI.btManifoldArray_push_back(swigCPtr, this, btPersistentManifold.getCPtr(_Val), _Val);
+  }
+
+  public int capacity() {
+    return gdxBulletJNI.btManifoldArray_capacity(swigCPtr, this);
+  }
+
+  public void reserve(int _Count) {
+    gdxBulletJNI.btManifoldArray_reserve(swigCPtr, this, _Count);
+  }
+
+  public void swap(int index0, int index1) {
+    gdxBulletJNI.btManifoldArray_swap(swigCPtr, this, index0, index1);
+  }
+
+  public int findBinarySearch(btPersistentManifold key) {
+    return gdxBulletJNI.btManifoldArray_findBinarySearch(swigCPtr, this, btPersistentManifold.getCPtr(key), key);
+  }
+
+  public int findLinearSearch(btPersistentManifold key) {
+    return gdxBulletJNI.btManifoldArray_findLinearSearch(swigCPtr, this, btPersistentManifold.getCPtr(key), key);
+  }
+
+  public void remove(btPersistentManifold key) {
+    gdxBulletJNI.btManifoldArray_remove(swigCPtr, this, btPersistentManifold.getCPtr(key), key);
+  }
+
+  public void initializeFromBuffer(SWIGTYPE_p_void buffer, int size, int capacity) {
+    gdxBulletJNI.btManifoldArray_initializeFromBuffer(swigCPtr, this, SWIGTYPE_p_void.getCPtr(buffer), size, capacity);
+  }
+
+  public void copyFromArray(btManifoldArray otherArray) {
+    gdxBulletJNI.btManifoldArray_copyFromArray(swigCPtr, this, btManifoldArray.getCPtr(otherArray), otherArray);
+  }
+
+}
diff --git a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btMultiSapBroadphase.java b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btMultiSapBroadphase.java
index 73ff718..29bb6a2 100755
--- a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btMultiSapBroadphase.java
+++ b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btMultiSapBroadphase.java
@@ -73,8 +73,8 @@ public class btMultiSapBroadphase extends btBroadphaseInterface {
     gdxBulletJNI.btMultiSapBroadphase_buildTree(swigCPtr, this, bvhAabbMin, bvhAabbMax);
   }
 
-  public void quicksort(SWIGTYPE_p_btAlignedObjectArrayT_btBroadphasePair_t a, int lo, int hi) {
-    gdxBulletJNI.btMultiSapBroadphase_quicksort(swigCPtr, this, SWIGTYPE_p_btAlignedObjectArrayT_btBroadphasePair_t.getCPtr(a), lo, hi);
+  public void quicksort(btBroadphasePairArray a, int lo, int hi) {
+    gdxBulletJNI.btMultiSapBroadphase_quicksort(swigCPtr, this, btBroadphasePairArray.getCPtr(a), a, lo, hi);
   }
 
 }
diff --git a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btOverlappingPairCache.java b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btOverlappingPairCache.java
index 0035b25..3b10703 100755
--- a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btOverlappingPairCache.java
+++ b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btOverlappingPairCache.java
@@ -45,8 +45,8 @@ public class btOverlappingPairCache extends btOverlappingPairCallback {
     return (cPtr == 0) ? null : new btBroadphasePair(cPtr, false);
   }
 
-  public SWIGTYPE_p_btAlignedObjectArrayT_btBroadphasePair_t getOverlappingPairArray() {
-    return new SWIGTYPE_p_btAlignedObjectArrayT_btBroadphasePair_t(gdxBulletJNI.btOverlappingPairCache_getOverlappingPairArray(swigCPtr, this), false);
+  public btBroadphasePairArray getOverlappingPairArray() {
+    return new btBroadphasePairArray(gdxBulletJNI.btOverlappingPairCache_getOverlappingPairArray(swigCPtr, this), false);
   }
 
   public void cleanOverlappingPair(btBroadphasePair pair, btDispatcher dispatcher) {
diff --git a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btSortedOverlappingPairCache.java b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btSortedOverlappingPairCache.java
index 80baaa8..7c1309c 100755
--- a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btSortedOverlappingPairCache.java
+++ b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/btSortedOverlappingPairCache.java
@@ -48,8 +48,8 @@ public class btSortedOverlappingPairCache extends btOverlappingPairCache {
     return gdxBulletJNI.btSortedOverlappingPairCache_needsBroadphaseCollision(swigCPtr, this, btBroadphaseProxy.getCPtr(proxy0), proxy0, btBroadphaseProxy.getCPtr(proxy1), proxy1);
   }
 
-  public SWIGTYPE_p_btAlignedObjectArrayT_btBroadphasePair_t getOverlappingPairArray() {
-    return new SWIGTYPE_p_btAlignedObjectArrayT_btBroadphasePair_t(gdxBulletJNI.btSortedOverlappingPairCache_getOverlappingPairArray__SWIG_0(swigCPtr, this), false);
+  public btBroadphasePairArray getOverlappingPairArray() {
+    return new btBroadphasePairArray(gdxBulletJNI.btSortedOverlappingPairCache_getOverlappingPairArray__SWIG_0(swigCPtr, this), false);
   }
 
   public btBroadphasePair getOverlappingPairArrayPtr() {
diff --git a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/gdxBulletJNI.java b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/gdxBulletJNI.java
index 420e78f..9a7fa59 100755
--- a/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/gdxBulletJNI.java
+++ b/extensions/gdx-bullet/jni/swig-src/com/badlogic/gdx/physics/bullet/gdxBulletJNI.java
@@ -907,7 +907,7 @@ public class gdxBulletJNI {
   public final static native boolean btMultiSapBroadphase_testAabbOverlap(long jarg1, btMultiSapBroadphase jarg1_, long jarg2, btBroadphaseProxy jarg2_, long jarg3, btBroadphaseProxy jarg3_);
   public final static native long btMultiSapBroadphase_getOverlappingPairCache__SWIG_0(long jarg1, btMultiSapBroadphase jarg1_);
   public final static native void btMultiSapBroadphase_buildTree(long jarg1, btMultiSapBroadphase jarg1_, Vector3 jarg2, Vector3 jarg3);
-  public final static native void btMultiSapBroadphase_quicksort(long jarg1, btMultiSapBroadphase jarg1_, long jarg2, int jarg3, int jarg4);
+  public final static native void btMultiSapBroadphase_quicksort(long jarg1, btMultiSapBroadphase jarg1_, long jarg2, btBroadphasePairArray jarg2_, int jarg3, int jarg4);
   public final static native long new_btCollisionAlgorithmConstructionInfo__SWIG_0();
   public final static native long new_btCollisionAlgorithmConstructionInfo__SWIG_1(long jarg1, btDispatcher jarg1_, int jarg2);
   public final static native void btCollisionAlgorithmConstructionInfo_m_dispatcher1_set(long jarg1, btCollisionAlgorithmConstructionInfo jarg1_, long jarg2, btDispatcher jarg2_);
@@ -918,7 +918,7 @@ public class gdxBulletJNI {
   public final static native void delete_btCollisionAlgorithm(long jarg1);
   public final static native void btCollisionAlgorithm_processCollision(long jarg1, btCollisionAlgorithm jarg1_, long jarg2, btCollisionObjectWrapper jarg2_, long jarg3, btCollisionObjectWrapper jarg3_, long jarg4, btDispatcherInfo jarg4_, long jarg5, btManifoldResult jarg5_);
   public final static native float btCollisionAlgorithm_calculateTimeOfImpact(long jarg1, btCollisionAlgorithm jarg1_, long jarg2, btCollisionObject jarg2_, long jarg3, btCollisionObject jarg3_, long jarg4, btDispatcherInfo jarg4_, long jarg5, btManifoldResult jarg5_);
-  public final static native void btCollisionAlgorithm_getAllContactManifolds(long jarg1, btCollisionAlgorithm jarg1_, long jarg2);
+  public final static native void btCollisionAlgorithm_getAllContactManifolds(long jarg1, btCollisionAlgorithm jarg1_, long jarg2, btManifoldArray jarg2_);
   public final static native void delete_btOverlappingPairCallback(long jarg1);
   public final static native long btOverlappingPairCallback_addOverlappingPair(long jarg1, btOverlappingPairCallback jarg1_, long jarg2, btBroadphaseProxy jarg2_, long jarg3, btBroadphaseProxy jarg3_);
   public final static native long btOverlappingPairCallback_removeOverlappingPair(long jarg1, btOverlappingPairCallback jarg1_, long jarg2, btBroadphaseProxy jarg2_, long jarg3, btBroadphaseProxy jarg3_, long jarg4, btDispatcher jarg4_);
@@ -1743,6 +1743,8 @@ public class gdxBulletJNI {
   public final static native void btCollisionObject_getInterpolationWorldTransform__SWIG_2(long jarg1, btCollisionObject jarg1_, Matrix4 jarg2);
   public final static native void btCollisionObject_getInterpolationLinearVelocity__SWIG_1(long jarg1, btCollisionObject jarg1_, Vector3 jarg2);
   public final static native void btCollisionObject_getInterpolationAngularVelocity__SWIG_1(long jarg1, btCollisionObject jarg1_, Vector3 jarg2);
+  public final static native int btCollisionObject_getUserValue(long jarg1, btCollisionObject jarg1_);
+  public final static native void btCollisionObject_setUserValue(long jarg1, btCollisionObject jarg1_, int jarg2);
   public final static native void btCollisionObjectDoubleData_m_broadphaseHandle_set(long jarg1, btCollisionObjectDoubleData jarg1_, long jarg2);
   public final static native long btCollisionObjectDoubleData_m_broadphaseHandle_get(long jarg1, btCollisionObjectDoubleData jarg1_);
   public final static native void btCollisionObjectDoubleData_m_collisionShape_set(long jarg1, btCollisionObjectDoubleData jarg1_, long jarg2);
@@ -4487,6 +4489,34 @@ public class gdxBulletJNI {
   public final static native void btCollisionObjectArray_remove(long jarg1, btCollisionObjectArray jarg1_, long jarg2, btCollisionObject jarg2_);
   public final static native void btCollisionObjectArray_initializeFromBuffer(long jarg1, btCollisionObjectArray jarg1_, long jarg2, int jarg3, int jarg4);
   public final static native void btCollisionObjectArray_copyFromArray(long jarg1, btCollisionObjectArray jarg1_, long jarg2, btCollisionObjectArray jarg2_);
+  public final static native int btBroadphasePairArray_size(long jarg1, btBroadphasePairArray jarg1_);
+  public final static native long btBroadphasePairArray_at(long jarg1, btBroadphasePairArray jarg1_, int jarg2);
+  public final static native int btBroadphasePairArray_getCollisionObjects(long jarg1, btBroadphasePairArray jarg1_, int[] jarg2, int jarg3, int jarg4);
+  public final static native int btBroadphasePairArray_getCollisionObjectsValue(long jarg1, btBroadphasePairArray jarg1_, int[] jarg2, int jarg3, int jarg4);
+  public final static native long new_btBroadphasePairArray();
+  public final static native void delete_btBroadphasePairArray(long jarg1);
+  public final static native long new_btManifoldArray__SWIG_0();
+  public final static native void delete_btManifoldArray(long jarg1);
+  public final static native long new_btManifoldArray__SWIG_1(long jarg1, btManifoldArray jarg1_);
+  public final static native int btManifoldArray_size(long jarg1, btManifoldArray jarg1_);
+  public final static native long btManifoldArray_at__SWIG_0(long jarg1, btManifoldArray jarg1_, int jarg2);
+  public final static native void btManifoldArray_clear(long jarg1, btManifoldArray jarg1_);
+  public final static native void btManifoldArray_pop_back(long jarg1, btManifoldArray jarg1_);
+  public final static native void btManifoldArray_resizeNoInitialize(long jarg1, btManifoldArray jarg1_, int jarg2);
+  public final static native void btManifoldArray_resize__SWIG_0(long jarg1, btManifoldArray jarg1_, int jarg2, long jarg3, btPersistentManifold jarg3_);
+  public final static native void btManifoldArray_resize__SWIG_1(long jarg1, btManifoldArray jarg1_, int jarg2);
+  public final static native long btManifoldArray_expandNonInitializing(long jarg1, btManifoldArray jarg1_);
+  public final static native long btManifoldArray_expand__SWIG_0(long jarg1, btManifoldArray jarg1_, long jarg2, btPersistentManifold jarg2_);
+  public final static native long btManifoldArray_expand__SWIG_1(long jarg1, btManifoldArray jarg1_);
+  public final static native void btManifoldArray_push_back(long jarg1, btManifoldArray jarg1_, long jarg2, btPersistentManifold jarg2_);
+  public final static native int btManifoldArray_capacity(long jarg1, btManifoldArray jarg1_);
+  public final static native void btManifoldArray_reserve(long jarg1, btManifoldArray jarg1_, int jarg2);
+  public final static native void btManifoldArray_swap(long jarg1, btManifoldArray jarg1_, int jarg2, int jarg3);
+  public final static native int btManifoldArray_findBinarySearch(long jarg1, btManifoldArray jarg1_, long jarg2, btPersistentManifold jarg2_);
+  public final static native int btManifoldArray_findLinearSearch(long jarg1, btManifoldArray jarg1_, long jarg2, btPersistentManifold jarg2_);
+  public final static native void btManifoldArray_remove(long jarg1, btManifoldArray jarg1_, long jarg2, btPersistentManifold jarg2_);
+  public final static native void btManifoldArray_initializeFromBuffer(long jarg1, btManifoldArray jarg1_, long jarg2, int jarg3, int jarg4);
+  public final static native void btManifoldArray_copyFromArray(long jarg1, btManifoldArray jarg1_, long jarg2, btManifoldArray jarg2_);
   public final static native long btVector4_SWIGUpcast(long jarg1);
   public final static native long btDefaultMotionState_SWIGUpcast(long jarg1);
   public final static native long GrahamVector2_SWIGUpcast(long jarg1);
diff --git a/extensions/gdx-bullet/jni/swig-src/gdxBullet_wrap.cpp b/extensions/gdx-bullet/jni/swig-src/gdxBullet_wrap.cpp
index 56c0947..cc8b616 100755
--- a/extensions/gdx-bullet/jni/swig-src/gdxBullet_wrap.cpp
+++ b/extensions/gdx-bullet/jni/swig-src/gdxBullet_wrap.cpp
@@ -564,6 +564,9 @@ SWIGINTERN inline void btTransform_to_Matrix4(JNIEnv * jenv, jobject target, con
 }
 
 
+#include <stdint.h>
+
+
 #if defined(SWIG_NOINCLUDE) || defined(SWIG_NOARRAYS)
 
 
@@ -1806,6 +1809,14 @@ SWIGINTERN void btCollisionObject_getInterpolationLinearVelocity__SWIG_1(btColli
 SWIGINTERN void btCollisionObject_getInterpolationAngularVelocity__SWIG_1(btCollisionObject *self,btVector3 &out){
 		out = self->getInterpolationAngularVelocity();
 	}
+SWIGINTERN int btCollisionObject_getUserValue(btCollisionObject *self){
+		int result;
+		*(const void **)&result = self->getUserPointer();
+		return result;
+	}
+SWIGINTERN void btCollisionObject_setUserValue(btCollisionObject *self,int value){
+		self->setUserPointer((void*)value);
+	}
 
 #include <BulletDynamics/Dynamics/btRigidBody.h>
 
@@ -2078,7 +2089,6 @@ typedef btTypedConstraint::btConstraintInfo2 btConstraintInfo2;
 
 
 #include <BulletSoftBody/btSoftBody.h>
-#include <stdint.h>
 
 SWIGINTERN btSoftBody *new_btSoftBody__SWIG_2(btSoftBodyWorldInfo *worldInfo,float *vertices,int vertexCount,int vertexSize,int posOffset,short *indices,int triangleCount){
 		int offset = posOffset / sizeof(btScalar);
@@ -2230,6 +2240,76 @@ SWIGINTERN void btSoftBody_setConfig_collisions(btSoftBody *self,int v){ self->m
 
 typedef btRaycastVehicle::btVehicleTuning btVehicleTuning;
 
+ /*SWIG_JavaArrayArgout##Bool(jenv, jarr$argnum, (bool *)$1, $input);*/ 
+ /*SWIG_JavaArrayArgout##Schar(jenv, jarr$argnum, (signed char *)$1, $input);*/ 
+ /*SWIG_JavaArrayArgout##Uchar(jenv, jarr$argnum, (unsigned char *)$1, $input);*/ 
+ /*SWIG_JavaArrayArgout##Short(jenv, jarr$argnum, (short *)$1, $input);*/ 
+ /*SWIG_JavaArrayArgout##Ushort(jenv, jarr$argnum, (unsigned short *)$1, $input);*/ 
+ /*SWIG_JavaArrayArgout##Int(jenv, jarr$argnum, (int *)$1, $input);*/ 
+ /*SWIG_JavaArrayArgout##Uint(jenv, jarr$argnum, (unsigned int *)$1, $input);*/ 
+ /*SWIG_JavaArrayArgout##Long(jenv, jarr$argnum, (long *)$1, $input);*/ 
+ /*SWIG_JavaArrayArgout##Ulong(jenv, jarr$argnum, (unsigned long *)$1, $input);*/ 
+ /*SWIG_JavaArrayArgout##Longlong(jenv, jarr$argnum, (long long *)$1, $input);*/ 
+ /*SWIG_JavaArrayArgout##Float(jenv, jarr$argnum, (float *)$1, $input);*/ 
+ /*SWIG_JavaArrayArgout##Double(jenv, jarr$argnum, (double *)$1, $input);*/ 
+SWIGINTERN int btAlignedObjectArray_Sl_btBroadphasePair_Sg__getCollisionObjects(btAlignedObjectArray< btBroadphasePair > *self,int result[],int max,int other){
+		static btManifoldArray marr;
+		const int n = self->size();
+		int count = 0;
+		int obj0, obj1;
+		for (int i = 0; i < n; i++) {
+			const btBroadphasePair& collisionPair = (*self)[i];
+			if (collisionPair.m_algorithm) {
+				marr.resize(0);
+				collisionPair.m_algorithm->getAllContactManifolds(marr);
+				const int s = marr.size();
+				for (int j = 0; j < s; j++) {
+					btPersistentManifold *manifold = marr[j];
+					if (manifold->getNumContacts() > 0) {
+						*(const btCollisionObject **)&obj0 = manifold->getBody0();
+						*(const btCollisionObject **)&obj1 = manifold->getBody1();
+						if (obj0 == other)
+							result[count++] = obj1;
+						else if (obj1 == other)
+							result[count++] = obj0;
+						else continue;
+						if (count >= max)
+							return count;
+					}
+				}
+			}
+		}
+		return count;
+	}
+SWIGINTERN int btAlignedObjectArray_Sl_btBroadphasePair_Sg__getCollisionObjectsValue(btAlignedObjectArray< btBroadphasePair > *self,int result[],int max,int other){
+		static btManifoldArray marr;
+		const int n = self->size();
+		int count = 0;
+		int obj0, obj1;
+		for (int i = 0; i < n; i++) {
+			const btBroadphasePair& collisionPair = (*self)[i];
+			if (collisionPair.m_algorithm) {
+				marr.resize(0);
+				collisionPair.m_algorithm->getAllContactManifolds(marr);
+				const int s = marr.size();
+				for (int j = 0; j < s; j++) {
+					btPersistentManifold *manifold = marr[j];
+					if (manifold->getNumContacts() > 0) {
+						*(const btCollisionObject **)&obj0 = manifold->getBody0();
+						*(const btCollisionObject **)&obj1 = manifold->getBody1();
+						if (obj0 == other)
+							*(const void **)&(result[count++]) = manifold->getBody1()->getUserPointer();
+						else if (obj1 == other)
+							*(const void **)&(result[count++]) = manifold->getBody0()->getUserPointer();
+						else continue;
+						if (count >= max)
+							return count;
+					}
+				}
+			}
+		}
+		return count;
+	}
 
 
 // Begin dummy implementations for missing Bullet methods
@@ -18555,7 +18635,7 @@ SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btMult
 }
 
 
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btMultiSapBroadphase_1quicksort(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jint jarg3, jint jarg4) {
+SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btMultiSapBroadphase_1quicksort(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_, jint jarg3, jint jarg4) {
   btMultiSapBroadphase *arg1 = (btMultiSapBroadphase *) 0 ;
   btBroadphasePairArray *arg2 = 0 ;
   int arg3 ;
@@ -18564,6 +18644,7 @@ SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btMult
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
+  (void)jarg2_;
   arg1 = *(btMultiSapBroadphase **)&jarg1; 
   arg2 = *(btBroadphasePairArray **)&jarg2;
   if (!arg2) {
@@ -18741,13 +18822,14 @@ SWIGEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btCo
 }
 
 
-SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btCollisionAlgorithm_1getAllContactManifolds(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
+SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btCollisionAlgorithm_1getAllContactManifolds(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
   btCollisionAlgorithm *arg1 = (btCollisionAlgorithm *) 0 ;
   btManifoldArray *arg2 = 0 ;
   
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
+  (void)jarg2_;
   arg1 = *(btCollisionAlgorithm **)&jarg1; 
   arg2 = *(btManifoldArray **)&jarg2;
   if (!arg2) {
@@ -32218,6 +32300,34 @@ SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btColl
 }
 
 
+SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btCollisionObject_1getUserValue(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
+  jint jresult = 0 ;
+  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
+  int result;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  arg1 = *(btCollisionObject **)&jarg1; 
+  result = (int)btCollisionObject_getUserValue(arg1);
+  jresult = (jint)result; 
+  return jresult;
+}
+
+
+SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btCollisionObject_1setUserValue(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
+  btCollisionObject *arg1 = (btCollisionObject *) 0 ;
+  int arg2 ;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  arg1 = *(btCollisionObject **)&jarg1; 
+  arg2 = (int)jarg2; 
+  btCollisionObject_setUserValue(arg1,arg2);
+}
+
+
 SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btCollisionObjectDoubleData_1m_1broadphaseHandle_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
   btCollisionObjectDoubleData *arg1 = (btCollisionObjectDoubleData *) 0 ;
   void *arg2 = (void *) 0 ;
@@ -75311,6 +75421,443 @@ SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btColl
 }
 
 
+SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btBroadphasePairArray_1size(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
+  jint jresult = 0 ;
+  btAlignedObjectArray< btBroadphasePair > *arg1 = (btAlignedObjectArray< btBroadphasePair > *) 0 ;
+  int result;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  arg1 = *(btAlignedObjectArray< btBroadphasePair > **)&jarg1; 
+  result = (int)((btAlignedObjectArray< btBroadphasePair > const *)arg1)->size();
+  jresult = (jint)result; 
+  return jresult;
+}
+
+
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btBroadphasePairArray_1at(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
+  jlong jresult = 0 ;
+  btAlignedObjectArray< btBroadphasePair > *arg1 = (btAlignedObjectArray< btBroadphasePair > *) 0 ;
+  int arg2 ;
+  btBroadphasePair *result = 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  arg1 = *(btAlignedObjectArray< btBroadphasePair > **)&jarg1; 
+  arg2 = (int)jarg2; 
+  result = (btBroadphasePair *) &((btAlignedObjectArray< btBroadphasePair > const *)arg1)->at(arg2);
+  *(btBroadphasePair **)&jresult = result; 
+  return jresult;
+}
+
+
+SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btBroadphasePairArray_1getCollisionObjects(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jintArray jarg2, jint jarg3, jint jarg4) {
+  jint jresult = 0 ;
+  btAlignedObjectArray< btBroadphasePair > *arg1 = (btAlignedObjectArray< btBroadphasePair > *) 0 ;
+  int *arg2 ;
+  int arg3 ;
+  int arg4 ;
+  int result;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  arg1 = *(btAlignedObjectArray< btBroadphasePair > **)&jarg1; 
+  arg2 = (int *)jenv->GetPrimitiveArrayCritical(jarg2, 0); 
+  arg3 = (int)jarg3; 
+  arg4 = (int)jarg4; 
+  result = (int)btAlignedObjectArray_Sl_btBroadphasePair_Sg__getCollisionObjects(arg1,arg2,arg3,arg4);
+  jresult = (jint)result; 
+  jenv->ReleasePrimitiveArrayCritical(jarg2, (int *)arg2, 0); 
+  return jresult;
+}
+
+
+SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btBroadphasePairArray_1getCollisionObjectsValue(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jintArray jarg2, jint jarg3, jint jarg4) {
+  jint jresult = 0 ;
+  btAlignedObjectArray< btBroadphasePair > *arg1 = (btAlignedObjectArray< btBroadphasePair > *) 0 ;
+  int *arg2 ;
+  int arg3 ;
+  int arg4 ;
+  int result;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  arg1 = *(btAlignedObjectArray< btBroadphasePair > **)&jarg1; 
+  arg2 = (int *)jenv->GetPrimitiveArrayCritical(jarg2, 0); 
+  arg3 = (int)jarg3; 
+  arg4 = (int)jarg4; 
+  result = (int)btAlignedObjectArray_Sl_btBroadphasePair_Sg__getCollisionObjectsValue(arg1,arg2,arg3,arg4);
+  jresult = (jint)result; 
+  jenv->ReleasePrimitiveArrayCritical(jarg2, (int *)arg2, 0); 
+  return jresult;
+}
+
+
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_new_1btBroadphasePairArray(JNIEnv *jenv, jclass jcls) {
+  jlong jresult = 0 ;
+  btAlignedObjectArray< btBroadphasePair > *result = 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  result = (btAlignedObjectArray< btBroadphasePair > *)new btAlignedObjectArray< btBroadphasePair >();
+  *(btAlignedObjectArray< btBroadphasePair > **)&jresult = result; 
+  return jresult;
+}
+
+
+SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_delete_1btBroadphasePairArray(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+  btAlignedObjectArray< btBroadphasePair > *arg1 = (btAlignedObjectArray< btBroadphasePair > *) 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  arg1 = *(btAlignedObjectArray< btBroadphasePair > **)&jarg1; 
+  delete arg1;
+}
+
+
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_new_1btManifoldArray_1_1SWIG_10(JNIEnv *jenv, jclass jcls) {
+  jlong jresult = 0 ;
+  btAlignedObjectArray< btPersistentManifold * > *result = 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  result = (btAlignedObjectArray< btPersistentManifold * > *)new btAlignedObjectArray< btPersistentManifold * >();
+  *(btAlignedObjectArray< btPersistentManifold * > **)&jresult = result; 
+  return jresult;
+}
+
+
+SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_delete_1btManifoldArray(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+  btAlignedObjectArray< btPersistentManifold * > *arg1 = (btAlignedObjectArray< btPersistentManifold * > *) 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  arg1 = *(btAlignedObjectArray< btPersistentManifold * > **)&jarg1; 
+  delete arg1;
+}
+
+
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_new_1btManifoldArray_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
+  jlong jresult = 0 ;
+  btAlignedObjectArray< btPersistentManifold * > *arg1 = 0 ;
+  btAlignedObjectArray< btPersistentManifold * > *result = 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  arg1 = *(btAlignedObjectArray< btPersistentManifold * > **)&jarg1;
+  if (!arg1) {
+    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAlignedObjectArray< btPersistentManifold * > const & reference is null");
+    return 0;
+  } 
+  result = (btAlignedObjectArray< btPersistentManifold * > *)new btAlignedObjectArray< btPersistentManifold * >((btAlignedObjectArray< btPersistentManifold * > const &)*arg1);
+  *(btAlignedObjectArray< btPersistentManifold * > **)&jresult = result; 
+  return jresult;
+}
+
+
+SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btManifoldArray_1size(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
+  jint jresult = 0 ;
+  btAlignedObjectArray< btPersistentManifold * > *arg1 = (btAlignedObjectArray< btPersistentManifold * > *) 0 ;
+  int result;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  arg1 = *(btAlignedObjectArray< btPersistentManifold * > **)&jarg1; 
+  result = (int)((btAlignedObjectArray< btPersistentManifold * > const *)arg1)->size();
+  jresult = (jint)result; 
+  return jresult;
+}
+
+
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btManifoldArray_1at_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
+  jlong jresult = 0 ;
+  btAlignedObjectArray< btPersistentManifold * > *arg1 = (btAlignedObjectArray< btPersistentManifold * > *) 0 ;
+  int arg2 ;
+  btPersistentManifold **result = 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  arg1 = *(btAlignedObjectArray< btPersistentManifold * > **)&jarg1; 
+  arg2 = (int)jarg2; 
+  result = (btPersistentManifold **) &((btAlignedObjectArray< btPersistentManifold * > const *)arg1)->at(arg2);
+  *(btPersistentManifold **)&jresult = *result; 
+  return jresult;
+}
+
+
+SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btManifoldArray_1clear(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
+  btAlignedObjectArray< btPersistentManifold * > *arg1 = (btAlignedObjectArray< btPersistentManifold * > *) 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  arg1 = *(btAlignedObjectArray< btPersistentManifold * > **)&jarg1; 
+  (arg1)->clear();
+}
+
+
+SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btManifoldArray_1pop_1back(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
+  btAlignedObjectArray< btPersistentManifold * > *arg1 = (btAlignedObjectArray< btPersistentManifold * > *) 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  arg1 = *(btAlignedObjectArray< btPersistentManifold * > **)&jarg1; 
+  (arg1)->pop_back();
+}
+
+
+SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btManifoldArray_1resizeNoInitialize(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
+  btAlignedObjectArray< btPersistentManifold * > *arg1 = (btAlignedObjectArray< btPersistentManifold * > *) 0 ;
+  int arg2 ;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  arg1 = *(btAlignedObjectArray< btPersistentManifold * > **)&jarg1; 
+  arg2 = (int)jarg2; 
+  (arg1)->resizeNoInitialize(arg2);
+}
+
+
+SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btManifoldArray_1resize_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3, jobject jarg3_) {
+  btAlignedObjectArray< btPersistentManifold * > *arg1 = (btAlignedObjectArray< btPersistentManifold * > *) 0 ;
+  int arg2 ;
+  btPersistentManifold **arg3 = 0 ;
+  btPersistentManifold *temp3 = 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  (void)jarg3_;
+  arg1 = *(btAlignedObjectArray< btPersistentManifold * > **)&jarg1; 
+  arg2 = (int)jarg2; 
+  temp3 = *(btPersistentManifold **)&jarg3;
+  arg3 = (btPersistentManifold **)&temp3; 
+  (arg1)->resize(arg2,(btPersistentManifold *const &)*arg3);
+}
+
+
+SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btManifoldArray_1resize_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
+  btAlignedObjectArray< btPersistentManifold * > *arg1 = (btAlignedObjectArray< btPersistentManifold * > *) 0 ;
+  int arg2 ;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  arg1 = *(btAlignedObjectArray< btPersistentManifold * > **)&jarg1; 
+  arg2 = (int)jarg2; 
+  (arg1)->resize(arg2);
+}
+
+
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btManifoldArray_1expandNonInitializing(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
+  jlong jresult = 0 ;
+  btAlignedObjectArray< btPersistentManifold * > *arg1 = (btAlignedObjectArray< btPersistentManifold * > *) 0 ;
+  btPersistentManifold **result = 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  arg1 = *(btAlignedObjectArray< btPersistentManifold * > **)&jarg1; 
+  result = (btPersistentManifold **) &(arg1)->expandNonInitializing();
+  *(btPersistentManifold ***)&jresult = result; 
+  return jresult;
+}
+
+
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btManifoldArray_1expand_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
+  jlong jresult = 0 ;
+  btAlignedObjectArray< btPersistentManifold * > *arg1 = (btAlignedObjectArray< btPersistentManifold * > *) 0 ;
+  btPersistentManifold **arg2 = 0 ;
+  btPersistentManifold *temp2 = 0 ;
+  btPersistentManifold **result = 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  (void)jarg2_;
+  arg1 = *(btAlignedObjectArray< btPersistentManifold * > **)&jarg1; 
+  temp2 = *(btPersistentManifold **)&jarg2;
+  arg2 = (btPersistentManifold **)&temp2; 
+  result = (btPersistentManifold **) &(arg1)->expand((btPersistentManifold *const &)*arg2);
+  *(btPersistentManifold ***)&jresult = result; 
+  return jresult;
+}
+
+
+SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btManifoldArray_1expand_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
+  jlong jresult = 0 ;
+  btAlignedObjectArray< btPersistentManifold * > *arg1 = (btAlignedObjectArray< btPersistentManifold * > *) 0 ;
+  btPersistentManifold **result = 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  arg1 = *(btAlignedObjectArray< btPersistentManifold * > **)&jarg1; 
+  result = (btPersistentManifold **) &(arg1)->expand();
+  *(btPersistentManifold ***)&jresult = result; 
+  return jresult;
+}
+
+
+SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btManifoldArray_1push_1back(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
+  btAlignedObjectArray< btPersistentManifold * > *arg1 = (btAlignedObjectArray< btPersistentManifold * > *) 0 ;
+  btPersistentManifold **arg2 = 0 ;
+  btPersistentManifold *temp2 = 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  (void)jarg2_;
+  arg1 = *(btAlignedObjectArray< btPersistentManifold * > **)&jarg1; 
+  temp2 = *(btPersistentManifold **)&jarg2;
+  arg2 = (btPersistentManifold **)&temp2; 
+  (arg1)->push_back((btPersistentManifold *const &)*arg2);
+}
+
+
+SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btManifoldArray_1capacity(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
+  jint jresult = 0 ;
+  btAlignedObjectArray< btPersistentManifold * > *arg1 = (btAlignedObjectArray< btPersistentManifold * > *) 0 ;
+  int result;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  arg1 = *(btAlignedObjectArray< btPersistentManifold * > **)&jarg1; 
+  result = (int)((btAlignedObjectArray< btPersistentManifold * > const *)arg1)->capacity();
+  jresult = (jint)result; 
+  return jresult;
+}
+
+
+SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btManifoldArray_1reserve(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
+  btAlignedObjectArray< btPersistentManifold * > *arg1 = (btAlignedObjectArray< btPersistentManifold * > *) 0 ;
+  int arg2 ;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  arg1 = *(btAlignedObjectArray< btPersistentManifold * > **)&jarg1; 
+  arg2 = (int)jarg2; 
+  (arg1)->reserve(arg2);
+}
+
+
+SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btManifoldArray_1swap(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3) {
+  btAlignedObjectArray< btPersistentManifold * > *arg1 = (btAlignedObjectArray< btPersistentManifold * > *) 0 ;
+  int arg2 ;
+  int arg3 ;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  arg1 = *(btAlignedObjectArray< btPersistentManifold * > **)&jarg1; 
+  arg2 = (int)jarg2; 
+  arg3 = (int)jarg3; 
+  (arg1)->swap(arg2,arg3);
+}
+
+
+SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btManifoldArray_1findBinarySearch(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
+  jint jresult = 0 ;
+  btAlignedObjectArray< btPersistentManifold * > *arg1 = (btAlignedObjectArray< btPersistentManifold * > *) 0 ;
+  btPersistentManifold **arg2 = 0 ;
+  btPersistentManifold *temp2 = 0 ;
+  int result;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  (void)jarg2_;
+  arg1 = *(btAlignedObjectArray< btPersistentManifold * > **)&jarg1; 
+  temp2 = *(btPersistentManifold **)&jarg2;
+  arg2 = (btPersistentManifold **)&temp2; 
+  result = (int)((btAlignedObjectArray< btPersistentManifold * > const *)arg1)->findBinarySearch((btPersistentManifold *const &)*arg2);
+  jresult = (jint)result; 
+  return jresult;
+}
+
+
+SWIGEXPORT jint JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btManifoldArray_1findLinearSearch(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
+  jint jresult = 0 ;
+  btAlignedObjectArray< btPersistentManifold * > *arg1 = (btAlignedObjectArray< btPersistentManifold * > *) 0 ;
+  btPersistentManifold **arg2 = 0 ;
+  btPersistentManifold *temp2 = 0 ;
+  int result;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  (void)jarg2_;
+  arg1 = *(btAlignedObjectArray< btPersistentManifold * > **)&jarg1; 
+  temp2 = *(btPersistentManifold **)&jarg2;
+  arg2 = (btPersistentManifold **)&temp2; 
+  result = (int)((btAlignedObjectArray< btPersistentManifold * > const *)arg1)->findLinearSearch((btPersistentManifold *const &)*arg2);
+  jresult = (jint)result; 
+  return jresult;
+}
+
+
+SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btManifoldArray_1remove(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
+  btAlignedObjectArray< btPersistentManifold * > *arg1 = (btAlignedObjectArray< btPersistentManifold * > *) 0 ;
+  btPersistentManifold **arg2 = 0 ;
+  btPersistentManifold *temp2 = 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  (void)jarg2_;
+  arg1 = *(btAlignedObjectArray< btPersistentManifold * > **)&jarg1; 
+  temp2 = *(btPersistentManifold **)&jarg2;
+  arg2 = (btPersistentManifold **)&temp2; 
+  (arg1)->remove((btPersistentManifold *const &)*arg2);
+}
+
+
+SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btManifoldArray_1initializeFromBuffer(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jint jarg3, jint jarg4) {
+  btAlignedObjectArray< btPersistentManifold * > *arg1 = (btAlignedObjectArray< btPersistentManifold * > *) 0 ;
+  void *arg2 = (void *) 0 ;
+  int arg3 ;
+  int arg4 ;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  arg1 = *(btAlignedObjectArray< btPersistentManifold * > **)&jarg1; 
+  arg2 = *(void **)&jarg2; 
+  arg3 = (int)jarg3; 
+  arg4 = (int)jarg4; 
+  (arg1)->initializeFromBuffer(arg2,arg3,arg4);
+}
+
+
+SWIGEXPORT void JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btManifoldArray_1copyFromArray(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
+  btAlignedObjectArray< btPersistentManifold * > *arg1 = (btAlignedObjectArray< btPersistentManifold * > *) 0 ;
+  btAlignedObjectArray< btPersistentManifold * > *arg2 = 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  (void)jarg1_;
+  (void)jarg2_;
+  arg1 = *(btAlignedObjectArray< btPersistentManifold * > **)&jarg1; 
+  arg2 = *(btAlignedObjectArray< btPersistentManifold * > **)&jarg2;
+  if (!arg2) {
+    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "btAlignedObjectArray< btPersistentManifold * > const & reference is null");
+    return ;
+  } 
+  (arg1)->copyFromArray((btAlignedObjectArray< btPersistentManifold * > const &)*arg2);
+}
+
+
 SWIGEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_bullet_gdxBulletJNI_btVector4_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
     jlong baseptr = 0;
     (void)jenv;
diff --git a/extensions/gdx-bullet/jni/swig/custom/btBroadphasePairArray.i b/extensions/gdx-bullet/jni/swig/custom/btBroadphasePairArray.i
new file mode 100644
index 0000000..6bd45b8
--- /dev/null
+++ b/extensions/gdx-bullet/jni/swig/custom/btBroadphasePairArray.i
@@ -0,0 +1,98 @@
+%module btBroadphasePairArray
+
+%include "gdxDisableBuffers.i"
+%include "gdxEnableCriticalArrays.i"
+
+%typemap(javacode) btAlignedObjectArray<btBroadphasePair> %{
+	/**
+	 * @param out The array to fill with collision objects
+	 * @param other The collision object the pair must contain (which itself is excluded from the result)
+	 * @param tempArray A temporary array used by the method, not more object than the length of this array are added 
+	 * @return The array specified by out */
+	public com.badlogic.gdx.utils.Array<btCollisionObject> getCollisionObjects(final com.badlogic.gdx.utils.Array<btCollisionObject> out, final btCollisionObject other, final int[] tempArray) {
+		final int c = getCollisionObjects(tempArray, tempArray.length, (int)btCollisionObject.getCPtr(other));
+		for (int i = 0; i < c; i++)
+			out.add(btCollisionObject.getInstance(tempArray[i], false));
+		return out;
+	}
+	
+	/** Fills the given array with user value set using {@link btCollisionObject#setUserValue(int)} of the collision objects
+	 * within this pair array colliding with the given collision object.
+	 * @param out The array to fill with the user values
+	 * @param other The collision object the pair must contain (which itself is excluded from the result)
+	 * @return The amount of user values set in the out array. */
+	public int getCollisionObjectsValue(final int[] out, final btCollisionObject other) {
+		return getCollisionObjectsValue(out, out.length, (int)btCollisionObject.getCPtr(other));
+	}
+%}
+
+%rename(btBroadphasePairArray) btAlignedObjectArray<btBroadphasePair>;
+class btAlignedObjectArray<btBroadphasePair> {
+public:
+	SIMD_FORCE_INLINE	int size() const;
+	SIMD_FORCE_INLINE const btBroadphasePair& at(int n) const;
+};
+
+%extend btAlignedObjectArray<btBroadphasePair> {
+	int getCollisionObjects(int result[], int max, int other) {
+		static btManifoldArray marr;
+		const int n = $self->size();
+		int count = 0;
+		int obj0, obj1;
+		for (int i = 0; i < n; i++) {
+			const btBroadphasePair& collisionPair = (*$self)[i];
+			if (collisionPair.m_algorithm) {
+				marr.resize(0);
+				collisionPair.m_algorithm->getAllContactManifolds(marr);
+				const int s = marr.size();
+				for (int j = 0; j < s; j++) {
+					btPersistentManifold *manifold = marr[j];
+					if (manifold->getNumContacts() > 0) {
+						*(const btCollisionObject **)&obj0 = manifold->getBody0();
+						*(const btCollisionObject **)&obj1 = manifold->getBody1();
+						if (obj0 == other)
+							result[count++] = obj1;
+						else if (obj1 == other)
+							result[count++] = obj0;
+						else continue;
+						if (count >= max)
+							return count;
+					}
+				}
+			}
+		}
+		return count;
+	}
+	
+	int getCollisionObjectsValue(int result[], int max, int other) {
+		static btManifoldArray marr;
+		const int n = $self->size();
+		int count = 0;
+		int obj0, obj1;
+		for (int i = 0; i < n; i++) {
+			const btBroadphasePair& collisionPair = (*$self)[i];
+			if (collisionPair.m_algorithm) {
+				marr.resize(0);
+				collisionPair.m_algorithm->getAllContactManifolds(marr);
+				const int s = marr.size();
+				for (int j = 0; j < s; j++) {
+					btPersistentManifold *manifold = marr[j];
+					if (manifold->getNumContacts() > 0) {
+						*(const btCollisionObject **)&obj0 = manifold->getBody0();
+						*(const btCollisionObject **)&obj1 = manifold->getBody1();
+						if (obj0 == other)
+							*(const void **)&(result[count++]) = manifold->getBody1()->getUserPointer();
+						else if (obj1 == other)
+							*(const void **)&(result[count++]) = manifold->getBody0()->getUserPointer();
+						else continue;
+						if (count >= max)
+							return count;
+					}
+				}
+			}
+		}
+		return count;
+	}
+};
+
+%include "gdxEnableBuffers.i"
diff --git a/extensions/gdx-bullet/jni/swig/custom/btCollisionObject.i b/extensions/gdx-bullet/jni/swig/custom/btCollisionObject.i
index 954fd00..dbee306 100644
--- a/extensions/gdx-bullet/jni/swig/custom/btCollisionObject.i
+++ b/extensions/gdx-bullet/jni/swig/custom/btCollisionObject.i
@@ -79,4 +79,14 @@
 	void getInterpolationAngularVelocity(btVector3 & out) {
 		out = $self->getInterpolationAngularVelocity();
 	}
+	
+	int getUserValue() {
+		int result;
+		*(const void **)&result = $self->getUserPointer();
+		return result;
+	}
+	
+	void setUserValue(int value) {
+		$self->setUserPointer((void*)value);
+	}
 };
\ No newline at end of file
diff --git a/extensions/gdx-bullet/jni/swig/custom/btSoftBody.i b/extensions/gdx-bullet/jni/swig/custom/btSoftBody.i
index b4ae8fd..b6c94ff 100644
--- a/extensions/gdx-bullet/jni/swig/custom/btSoftBody.i
+++ b/extensions/gdx-bullet/jni/swig/custom/btSoftBody.i
@@ -125,7 +125,6 @@ struct	Config
 
 %{
 #include <BulletSoftBody/btSoftBody.h>
-#include <stdint.h>
 %}
 %include "BulletSoftBody/btSoftBody.h"
 
diff --git a/extensions/gdx-bullet/jni/swig/gdxBullet.i b/extensions/gdx-bullet/jni/swig/gdxBullet.i
index 4d7863a..13d8663 100644
--- a/extensions/gdx-bullet/jni/swig/gdxBullet.i
+++ b/extensions/gdx-bullet/jni/swig/gdxBullet.i
@@ -25,6 +25,8 @@ SWIG_JAVABODY_TYPEWRAPPER(protected, protected, public, SWIGTYPE)
 %include "gdxBuffers.i"
 %include "gdxEnableBuffers.i"
 
+%include "gdxCriticalArrays.i"
+
 %include "gdxPool.i"
 %include "gdxPooledTypemap.i"
 
@@ -41,6 +43,11 @@ SWIG_JAVABODY_TYPEWRAPPER(protected, protected, public, SWIGTYPE)
 /* Include Java imports for all the types we'll need in all extensions/custom types. */
 %include "gdxJavaImports.i"
 
+
+%{
+#include <stdint.h>
+%}
+
 /*
  * btScalar.h defines macros the other types need, so process it first.  
  * It also defines some static functions that end up in gdxBulletJNI.java.
@@ -885,6 +892,8 @@ ENABLE_POOLED_TYPEMAP(btTransform, Matrix4, "Lcom/badlogic/gdx/math/Matrix4;");
  */
  
 %template(btCollisionObjectArray) btAlignedObjectArray<btCollisionObject *>;
+%include "custom/btBroadphasePairArray.i"
+%template(btManifoldArray) btAlignedObjectArray<btPersistentManifold*>;
 
 /*
  * Include dummy methods for ones Bullet declares but doesn't
diff --git a/extensions/gdx-bullet/jni/swig/gdxCriticalArrays.i b/extensions/gdx-bullet/jni/swig/gdxCriticalArrays.i
new file mode 100644
index 0000000..5c9098d
--- /dev/null
+++ b/extensions/gdx-bullet/jni/swig/gdxCriticalArrays.i
@@ -0,0 +1,31 @@
+%define JAVA_CRITICAL_ARRAYS_TYPEMAPS(CTYPE, JTYPE, JNITYPE, JFUNCNAME, JNIDESC)
+
+%typemap(jni) CTYPE[ANY], CTYPE[]               %{JNITYPE##Array%}
+%typemap(jtype) CTYPE[ANY], CTYPE[]             %{JTYPE[]%}
+%typemap(jstype) CTYPE[ANY], CTYPE[]            %{JTYPE[]%}
+
+%typemap(in) CTYPE[]
+%{ $1 = (CTYPE *)jenv->GetPrimitiveArrayCritical($input, 0); %}
+%typemap(in) CTYPE[ANY]
+%{  if ($input && JCALL1(GetArrayLength, jenv, $input) != $1_size) {
+    SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "incorrect array size");
+    return $null;
+  }
+  $1 = (CTYPE *)jenv->GetPrimitiveArrayCritical($input, 0); %}
+%typemap(argout) CTYPE[ANY], CTYPE[]; 
+%{ /*SWIG_JavaArrayArgout##JFUNCNAME(jenv, jarr$argnum, (CTYPE *)$1, $input);*/ %}
+%typemap(out) CTYPE[ANY]
+%{ /*$result = SWIG_JavaArrayOut##JFUNCNAME(jenv, (CTYPE *)$1, $1_dim0);*/ %}
+%typemap(out) CTYPE[] 
+%{ /*$result = SWIG_JavaArrayOut##JFUNCNAME(jenv, (CTYPE *)$1, FillMeInAsSizeCannotBeDeterminedAutomatically);*/ %}
+%typemap(freearg) CTYPE[ANY], CTYPE[]
+%{ jenv->ReleasePrimitiveArrayCritical($input, (CTYPE *)$1, 0); %}
+
+%typemap(javain) CTYPE[ANY], CTYPE[] "$javainput"
+%typemap(javaout) CTYPE[ANY], CTYPE[] {
+    return $jnicall;
+}
+
+%typemap(memberin) CTYPE[ANY], CTYPE[];
+%typemap(globalin) CTYPE[ANY], CTYPE[];
+%enddef
\ No newline at end of file
diff --git a/extensions/gdx-bullet/jni/swig/gdxEnableCriticalArrays.i b/extensions/gdx-bullet/jni/swig/gdxEnableCriticalArrays.i
new file mode 100644
index 0000000..d7ea7f7
--- /dev/null
+++ b/extensions/gdx-bullet/jni/swig/gdxEnableCriticalArrays.i
@@ -0,0 +1,13 @@
+
+JAVA_CRITICAL_ARRAYS_TYPEMAPS(bool, boolean, jboolean, Bool, "[Z")       /* bool[ANY] */
+JAVA_CRITICAL_ARRAYS_TYPEMAPS(signed char, byte, jbyte, Schar, "[B")     /* signed char[ANY] */
+JAVA_CRITICAL_ARRAYS_TYPEMAPS(unsigned char, short, jshort, Uchar, "[S") /* unsigned char[ANY] */
+JAVA_CRITICAL_ARRAYS_TYPEMAPS(short, short, jshort, Short, "[S")         /* short[ANY] */
+JAVA_CRITICAL_ARRAYS_TYPEMAPS(unsigned short, int, jint, Ushort, "[I")   /* unsigned short[ANY] */
+JAVA_CRITICAL_ARRAYS_TYPEMAPS(int, int, jint, Int, "[I")                 /* int[ANY] */
+JAVA_CRITICAL_ARRAYS_TYPEMAPS(unsigned int, long, jlong, Uint, "[J")     /* unsigned int[ANY] */
+JAVA_CRITICAL_ARRAYS_TYPEMAPS(long, int, jint, Long, "[I")               /* long[ANY] */
+JAVA_CRITICAL_ARRAYS_TYPEMAPS(unsigned long, long, jlong, Ulong, "[J")   /* unsigned long[ANY] */
+JAVA_CRITICAL_ARRAYS_TYPEMAPS(long long, long, jlong, Longlong, "[J")    /* long long[ANY] */
+JAVA_CRITICAL_ARRAYS_TYPEMAPS(float, float, jfloat, Float, "[F")         /* float[ANY] */
+JAVA_CRITICAL_ARRAYS_TYPEMAPS(double, double, jdouble, Double, "[D")     /* double[ANY] */
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/.classpath b/extensions/gdx-controllers/gdx-controllers-desktop/.classpath
index f4c9643..84bf81c 100644
--- a/extensions/gdx-controllers/gdx-controllers-desktop/.classpath
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/.classpath
@@ -3,7 +3,6 @@
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
 	<classpathentry excluding="**/.svn/*" kind="src" path="src"/>
 	<classpathentry combineaccessrules="false" exported="true" kind="src" path="/gdx"/>
-	<classpathentry combineaccessrules="false" exported="true" kind="src" path="/gdx-backend-lwjgl"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/gdx-jnigen"/>
 	<classpathentry exported="true" kind="lib" path="libs/gdx-controllers-desktop-natives.jar"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/gdx-controllers"/>
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/desktop/DesktopControllersTest.java b/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/desktop/DesktopControllersTest.java
deleted file mode 100644
index b6fd6bb..0000000
--- a/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/desktop/DesktopControllersTest.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-package com.badlogic.gdx.controllers.desktop;
-
-import com.badlogic.gdx.ApplicationAdapter;
-import com.badlogic.gdx.backends.lwjgl.LwjglFrame;
-import com.badlogic.gdx.controllers.Controller;
-import com.badlogic.gdx.controllers.ControllerListener;
-import com.badlogic.gdx.controllers.Controllers;
-import com.badlogic.gdx.controllers.PovDirection;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.utils.SharedLibraryLoader;
-
-import javax.swing.JFrame;
-import javax.swing.SwingUtilities;
-
-public class DesktopControllersTest {
-	public static void main (String[] args) throws Exception {
-		DesktopControllersBuild.main(null);
-		new SharedLibraryLoader("libs/gdx-controllers-desktop-natives.jar").load("gdx-controllers-desktop");
-
-		ApplicationAdapter app = new ApplicationAdapter() {
-			public void create () {
-				Controllers.addListener(new ControllerListener() {
-					public boolean ySliderMoved (Controller controller, int sliderIndex, boolean value) {
-						System.out.println("ySliderMoved: " + sliderIndex + ", " + value);
-						return true;
-					}
-
-					public boolean xSliderMoved (Controller controller, int sliderIndex, boolean value) {
-						System.out.println("xSliderMoved: " + sliderIndex + ", " + value);
-						return true;
-					}
-
-					public boolean povMoved (Controller controller, int povIndex, PovDirection value) {
-						System.out.println("povMoved: " + povIndex + ", " + value);
-						return true;
-					}
-
-					public boolean buttonUp (Controller controller, int buttonIndex) {
-						System.out.println("buttonUp: " + buttonIndex);
-						return true;
-					}
-
-					public boolean buttonDown (Controller controller, int buttonIndex) {
-						System.out.println("buttonDown: " + buttonIndex);
-						return true;
-					}
-
-					public boolean axisMoved (Controller controller, int axisIndex, float value) {
-						System.out.println("axisMoved: " + axisIndex + ", " + value);
-						return true;
-					}
-
-					public boolean accelerometerMoved (Controller controller, int accelerometerIndex, Vector3 value) {
-						System.out.println("accelerometerMoved: " + accelerometerIndex + ", " + value);
-						return true;
-					}
-
-					@Override
-					public void connected (Controller controller) {
-					}
-
-					@Override
-					public void disconnected (Controller controller) {
-					}
-				});
-			}
-
-			public void render () {
-				for (Controller controller : Controllers.getControllers())
-					if (controller.getButton(0)) System.out.println("button 0 pressed");
-			}
-		};
-
-		// new LwjglApplication(app);
-		new LwjglFrame(app, "Controllers", 200, 200, false);
-	}
-}
\ No newline at end of file
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/desktop/OisControllers.java b/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/desktop/OisControllers.java
index 3427614..566609c 100644
--- a/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/desktop/OisControllers.java
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/desktop/OisControllers.java
@@ -13,10 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  ******************************************************************************/
+
 package com.badlogic.gdx.controllers.desktop;
 
 import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.backends.lwjgl.LwjglCanvas;
+import com.badlogic.gdx.Graphics.GraphicsType;
 import com.badlogic.gdx.controllers.ControlType;
 import com.badlogic.gdx.controllers.Controller;
 import com.badlogic.gdx.controllers.ControllerListener;
@@ -29,20 +30,17 @@ import com.badlogic.gdx.math.Vector3;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 
-import java.awt.Container;
-import java.awt.Frame;
+import java.awt.Component;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 
 import javax.swing.SwingUtilities;
 
-import org.lwjgl.opengl.Display;
-
 /** @author Nathan Sweet */
 public class OisControllers {
 	final DesktopControllerManager manager;
-	final Ois ois = new Ois(getLwjglWindowHandle());
+	final Ois ois = new Ois(getWindowHandle());
 	final OisController[] controllers;
 
 	public OisControllers (DesktopControllerManager manager) {
@@ -202,28 +200,37 @@ public class OisControllers {
 	}
 
 	/** Returns the window handle from LWJGL needed by OIS. */
-	static public long getLwjglWindowHandle () {
+	static public long getWindowHandle () {
 		// don't need a window handle for Mac OS X
-		if(System.getProperty("os.name").toLowerCase().contains("mac")) {
+		if (System.getProperty("os.name").toLowerCase().contains("mac")) {
 			return 0;
 		}
-		
+
 		try {
-			if (Gdx.app instanceof LwjglCanvas) {
-				return (Long)invokeMethod(
-					invokeMethod(SwingUtilities.windowForComponent(((LwjglCanvas)Gdx.app).getCanvas()), "getPeer"), "getHWnd");
-			}
+			if (Gdx.graphics.getType() == GraphicsType.JGLFW)
+				return (Long)Gdx.graphics.getClass().getDeclaredMethod("getWindow").invoke(null);
+
+			if (Gdx.graphics.getType() == GraphicsType.LWJGL) {
+				if (Gdx.app.getClass().getName().equals("com.badlogic.gdx.backends.lwjgl.LwjglCanvas")) {
+					Class canvasClass = Class.forName("com.badlogic.gdx.backends.lwjgl.LwjglCanvas");
+					Object canvas = canvasClass.getDeclaredMethod("getCanvas").invoke(Gdx.app);
+					return (Long)invokeMethod(invokeMethod(SwingUtilities.windowForComponent((Component)canvas), "getPeer"), "getHWnd");
+				}
 
-			Method getImplementation = Display.class.getDeclaredMethod("getImplementation", new Class[0]);
-			getImplementation.setAccessible(true);
-			Object display = getImplementation.invoke(null, (Object[])null);
-			String fieldName = System.getProperty("os.name").toLowerCase().contains("windows") ? "hwnd" : "parent_window";
-			Field field = display.getClass().getDeclaredField(fieldName);
-			field.setAccessible(true);
-			return (Long)field.get(display);
+				Class displayClass = Class.forName("org.lwjgl.opengl.Display");
+				Method getImplementation = displayClass.getDeclaredMethod("getImplementation", new Class[0]);
+				getImplementation.setAccessible(true);
+				Object display = getImplementation.invoke(null, (Object[])null);
+				String fieldName = System.getProperty("os.name").toLowerCase().contains("windows") ? "hwnd" : "parent_window";
+				Field field = display.getClass().getDeclaredField(fieldName);
+				field.setAccessible(true);
+				return (Long)field.get(display);
+			}
 		} catch (Exception ex) {
 			throw new RuntimeException("Unable to get window handle.", ex);
 		}
+
+		return 0;
 	}
 
 	static private Object invokeMethod (Object object, String methodName) throws Exception {
@@ -232,4 +239,4 @@ public class OisControllers {
 		throw new RuntimeException("Could not find method '" + methodName + "' on class: " + object.getClass());
 	}
 
-}
\ No newline at end of file
+}
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/desktop/ois/Ois.java b/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/desktop/ois/Ois.java
index 1b6c433..a33fd35 100755
--- a/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/desktop/ois/Ois.java
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/desktop/ois/Ois.java
@@ -15,12 +15,8 @@
  ******************************************************************************/
 package com.badlogic.gdx.controllers.desktop.ois;
 
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
 import java.util.ArrayList;
 
-import org.lwjgl.opengl.Display;
-
 /** JNI wrapper for OIS (Object-oriented Input System).
  * @author mzechner
  * @author Nathan Sweet */
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/desktop/ois/OisTest.java b/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/desktop/ois/OisTest.java
index cd2f4cd..6716312 100755
--- a/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/desktop/ois/OisTest.java
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/src/com/badlogic/gdx/controllers/desktop/ois/OisTest.java
@@ -16,7 +16,6 @@
 package com.badlogic.gdx.controllers.desktop.ois;
 
 import com.badlogic.gdx.ApplicationAdapter;
-import com.badlogic.gdx.backends.lwjgl.LwjglApplication;
 import com.badlogic.gdx.controllers.desktop.DesktopControllersBuild;
 import com.badlogic.gdx.controllers.desktop.OisControllers;
 import com.badlogic.gdx.controllers.desktop.ois.OisJoystick.OisPov;
@@ -31,7 +30,7 @@ public class OisTest {
 			Ois ois;
 
 			public void create () {
-				ois = new Ois(OisControllers.getLwjglWindowHandle());
+				ois = new Ois(OisControllers.getWindowHandle());
 				if (ois.getJoysticks().size() > 0) {
 					ois.getJoysticks().get(0).setListener(new OisListener() {
 						@Override
@@ -73,7 +72,7 @@ public class OisTest {
 			}
 		};
 
-		new LwjglApplication(app);
+		//new LwjglApplication(app);
 //		 new LwjglFrame(app, "Controllers", 200, 200, false);
 	}
 }
\ No newline at end of file
diff --git a/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGenerator.java b/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGenerator.java
index d37328a..c68df47 100644
--- a/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGenerator.java
+++ b/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGenerator.java
@@ -113,11 +113,17 @@ public class FreeTypeFontGenerator implements Disposable {
 		SizeMetrics fontMetrics = face.getSize().getMetrics();
 		int baseline = FreeType.toInt(fontMetrics.getAscender());
 
-		// Check if character exists in this font
-		if (!FreeType.loadChar(face, c, FreeType.FT_LOAD_DEFAULT)) {
+		// Check if character exists in this font.
+		// 0 means 'undefined character code'
+		if (FreeType.getCharIndex(face, c) == 0) {
 			return null;
 		}
 
+		// Try to load character
+		if (!FreeType.loadChar(face, c, FreeType.FT_LOAD_DEFAULT)) {
+			throw new GdxRuntimeException("Unable to load character!");
+		}
+
 		GlyphSlot slot = face.getGlyph();
 		
 		// Try to render to bitmap
diff --git a/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/JniGenSharedLibraryLoader.java b/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/JniGenSharedLibraryLoader.java
index 7e2d1bd..5549c5a 100644
--- a/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/JniGenSharedLibraryLoader.java
+++ b/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/JniGenSharedLibraryLoader.java
@@ -1,22 +1,8 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
 package com.badlogic.gdx.jnigen;
 
 import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -26,8 +12,6 @@ import java.util.zip.CRC32;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 
-import com.badlogic.gdx.jnigen.test.MyJniClass;
-
 /** Loads shared libraries from a natives jar file (desktop) or arm folders (Android). For desktop projects, have the natives jar
  * in the classpath, for Android projects put the shared libraries in the libs/armeabi and libs/armeabi-v7a folders.
  * 
@@ -41,14 +25,14 @@ public class JniGenSharedLibraryLoader {
 	public JniGenSharedLibraryLoader () {
 	}
 
-	/** Fetches the natives from the given natives jar file. Used for testing a shared lib on the fly, see {@link MyJniClass}.
+	/** Fetches the natives from the given natives jar file. Used for testing a shared lib on the fly, see MyJniClass.
 	 * @param nativesJar */
 	public JniGenSharedLibraryLoader (String nativesJar) {
 		this.nativesJar = nativesJar;
 	}
 
-	private String crc (String nativeFile) {
-		InputStream input = JniGenSharedLibraryLoader.class.getResourceAsStream("/" + nativeFile);
+	/** Returns a CRC of the remaining bytes in the stream. */
+	public String crc (InputStream input) {
 		if (input == null) return "" + System.nanoTime(); // fallback
 		CRC32 crc = new CRC32();
 		byte[] buffer = new byte[4096];
@@ -74,29 +58,41 @@ public class JniGenSharedLibraryLoader {
 	}
 
 	private String extractLibrary (String sharedLibName) {
-		File nativesDir = new File(System.getProperty("java.io.tmpdir") + "/jnigen/" + crc(sharedLibName));
+		String srcCrc = crc(JniGenSharedLibraryLoader.class.getResourceAsStream("/" + sharedLibName));
+		File nativesDir = new File(System.getProperty("java.io.tmpdir") + "/jnigen/" + srcCrc);
 		File nativeFile = new File(nativesDir, sharedLibName);
-		try {
-			// Extract native from classpath to temp dir.
-			InputStream input = null;
-			if (nativesJar == null)
-				input = JniGenSharedLibraryLoader.class.getResourceAsStream("/" + sharedLibName);
-			else
-				input = getFromJar(nativesJar, sharedLibName);
-			if (input == null) return null;
-			nativesDir.mkdirs();
-			FileOutputStream output = new FileOutputStream(nativeFile);
-			byte[] buffer = new byte[4096];
-			while (true) {
-				int length = input.read(buffer);
-				if (length == -1) break;
-				output.write(buffer, 0, length);
+		
+		String extractedCrc = null;
+		if (nativeFile.exists()) {
+			try {
+				extractedCrc = crc(new FileInputStream(nativeFile));
+			} catch (FileNotFoundException ignored) {
+			}
+		}
+		
+		if(extractedCrc == null || !extractedCrc.equals(srcCrc)) {
+			try {
+				// Extract native from classpath to temp dir.
+				InputStream input = null;
+				if (nativesJar == null)
+					input = JniGenSharedLibraryLoader.class.getResourceAsStream("/" + sharedLibName);
+				else
+					input = getFromJar(nativesJar, sharedLibName);
+				if (input == null) return null;
+				nativesDir.mkdirs();
+				FileOutputStream output = new FileOutputStream(nativeFile);
+				byte[] buffer = new byte[4096];
+				while (true) {
+					int length = input.read(buffer);
+					if (length == -1) break;
+					output.write(buffer, 0, length);
+				}
+				input.close();
+				output.close();
+			} catch (IOException ex) {
+				ex.printStackTrace();
+				throw new RuntimeException(ex);
 			}
-			input.close();
-			output.close();
-		} catch (IOException ex) {
-			ex.printStackTrace();
-			throw new RuntimeException(ex);
 		}
 		return nativeFile.exists() ? nativeFile.getAbsolutePath() : null;
 	}
diff --git a/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/NativeCodeGenerator.java b/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/NativeCodeGenerator.java
index 46cefa8..a4865cd 100644
--- a/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/NativeCodeGenerator.java
+++ b/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/NativeCodeGenerator.java
@@ -322,7 +322,8 @@ public class NativeCodeGenerator {
 
 	private CMethod findCMethod (JavaMethod javaMethod, ArrayList<CMethod> cMethods) {
 		for (CMethod cMethod : cMethods) {
-			if (cMethod.getHead().contains(javaMethod.getClassName() + "_" + javaMethod.getName())) {
+			if (cMethod.getHead().endsWith(javaMethod.getClassName() + "_" + javaMethod.getName()) ||
+				 cMethod.getHead().contains(javaMethod.getClassName() + "_" + javaMethod.getName() + "__")) {
 				// FIXME poor man's overloaded method check...
 				// FIXME float test[] won't work, needs to be float[] test.
 				if (cMethod.getArgumentTypes().length - 2 == javaMethod.getArguments().size()) {
@@ -513,8 +514,8 @@ public class NativeCodeGenerator {
 		for (Argument arg : javaMethod.getArguments()) {
 			if (arg.getType().isBuffer()) {
 				String type = arg.getType().getBufferCType();
-				buffer.append("\t" + type + " " + arg.getName() + " = (" + type + ")env->GetDirectBufferAddress(" + JNI_ARG_PREFIX
-					+ arg.getName() + ");\n");
+				buffer.append("\t" + type + " " + arg.getName() + " = (" + type + ")(" + JNI_ARG_PREFIX
+					+ arg.getName() + "?env->GetDirectBufferAddress(" + JNI_ARG_PREFIX	+ arg.getName() + "):0);\n");
 				additionalArgs.append(", ");
 				additionalArgs.append(type);
 				additionalArgs.append(" ");
diff --git a/extensions/gdx-remote/project.properties b/extensions/gdx-remote/project.properties
index f049142..c4f09d2 100644
--- a/extensions/gdx-remote/project.properties
+++ b/extensions/gdx-remote/project.properties
@@ -8,4 +8,4 @@
 # project structure.
 
 # Project target.
-target=android-10
+target=android-17
diff --git a/extensions/model-loaders/model-loaders-android/project.properties b/extensions/model-loaders/model-loaders-android/project.properties
index 2cc58fa..c4f09d2 100644
--- a/extensions/model-loaders/model-loaders-android/project.properties
+++ b/extensions/model-loaders/model-loaders-android/project.properties
@@ -8,4 +8,4 @@
 # project structure.
 
 # Project target.
-target=android-12
+target=android-17
diff --git a/fetch.xml b/fetch.xml
index f0fb91e..dfa1bdb 100755
--- a/fetch.xml
+++ b/fetch.xml
@@ -57,6 +57,11 @@
 		<get src="${domain}/extensions/gdx-image/gdx-image-natives.jar" dest="extensions/gdx-image/libs"/>
 		<get src="${domain}/extensions/gdx-image/armeabi/libgdx-image.so" dest="tmp/armeabi"/>
 		<get src="${domain}/extensions/gdx-image/armeabi-v7a/libgdx-image.so" dest="tmp/armeabi-v7a"/>	
+
+		<!-- jglfw -->
+		<mkdir dir="backends/gdx-backend-jglfw/libs"/>
+		<get src="http://libgdx.badlogicgames.com/jglfw/nightlies/dist/jglfw-natives.jar" dest="backends/gdx-backend-jglfw/libs/gdx-backend-jglfw-natives.jar"/>
+		<get src="http://libgdx.badlogicgames.com/jglfw/nightlies/dist/jglfw.jar" dest="backends/gdx-backend-jglfw/libs/"/>
 	</target>
 	
 	<target name="copy">
diff --git a/gdx/jni/gdx2d/gdx2d.c b/gdx/jni/gdx2d/gdx2d.c
index 03d6888..f46eff2 100644
--- a/gdx/jni/gdx2d/gdx2d.c
+++ b/gdx/jni/gdx2d/gdx2d.c
@@ -229,6 +229,7 @@ gdx2d_pixmap* gdx2d_load(const unsigned char *buffer, uint32_t len, uint32_t req
 		return NULL;
 
 	gdx2d_pixmap* pixmap = (gdx2d_pixmap*)malloc(sizeof(gdx2d_pixmap));
+	if (!pixmap) return 0;
 	pixmap->width = (uint32_t)width;
 	pixmap->height = (uint32_t)height;
 	pixmap->format = (uint32_t)format;
@@ -255,10 +256,15 @@ uint32_t gdx2d_bytes_per_pixel(uint32_t format) {
 
 gdx2d_pixmap* gdx2d_new(uint32_t width, uint32_t height, uint32_t format) {
 	gdx2d_pixmap* pixmap = (gdx2d_pixmap*)malloc(sizeof(gdx2d_pixmap));
+	if (!pixmap) return 0;
 	pixmap->width = width;
 	pixmap->height = height;
 	pixmap->format = format;
 	pixmap->pixels = (unsigned char*)malloc(width * height * gdx2d_bytes_per_pixel(format));
+	if (!pixmap->pixels) {
+		free((void*)pixmap);
+		return 0;
+	}
 	return pixmap;
 }
 void gdx2d_free(const gdx2d_pixmap* pixmap) {
diff --git a/gdx/src/com/badlogic/gdx.gwt.xml b/gdx/src/com/badlogic/gdx.gwt.xml
index f14c434..a7131c0 100644
--- a/gdx/src/com/badlogic/gdx.gwt.xml
+++ b/gdx/src/com/badlogic/gdx.gwt.xml
@@ -242,6 +242,7 @@
 		<include name="scenes/scene2d/utils/DragListener.java"/>
 		
 		<include name="Net.java"/>
+		<include name="net/HttpStatus.java"/>
 		<include name="net/ServerSocket.java"/>
 		<include name="net/ServerSocketHints.java"/>
 		<include name="net/Socket.java"/>
@@ -253,5 +254,7 @@
 		<include name="math/Path.java"/>
 		<include name="math/Bezier.java"/>
 		<include name="math/BSpline.java"/>
+		<include name="math/Ellipse.java"/>
+		<include name="math/Polyline.java"/>
 	</source>
 </module>
diff --git a/gdx/src/com/badlogic/gdx/Application.java b/gdx/src/com/badlogic/gdx/Application.java
index 39388bb..768083f 100644
--- a/gdx/src/com/badlogic/gdx/Application.java
+++ b/gdx/src/com/badlogic/gdx/Application.java
@@ -27,7 +27,7 @@ import com.badlogic.gdx.utils.Clipboard;
  * <p>
  * An application can be an instance of any of the following:
  * <ul>
- * <li>a desktop application (see <code>LwjglApplication</code> found in gdx-backends-lwjgl.jar)</li>
+ * <li>a desktop application (see <code>JglfwApplication</code> found in gdx-backends-jglfw.jar)</li>
  * <li>an Android application (see <code>AndroidApplication</code> found in gdx-backends-android.jar)</li>
  * <li>a HTML5 application (see <code>GwtApplication</code> found in gdx-backends-gwt.jar)</li>
  * <li>an iOS application (see <code>IOSApplication</code> found in gdx-backends-iosmonotouch.jar)</li>
diff --git a/gdx/src/com/badlogic/gdx/Gdx.java b/gdx/src/com/badlogic/gdx/Gdx.java
index 01474c6..f274afe 100644
--- a/gdx/src/com/badlogic/gdx/Gdx.java
+++ b/gdx/src/com/badlogic/gdx/Gdx.java
@@ -20,15 +20,14 @@ import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.GL11;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.GLCommon;
-import com.badlogic.gdx.graphics.GLU;
 
 /** Environment class holding references to the {@link Application}, {@link Graphics}, {@link Audio}, {@link Files} and
  * {@link Input} instances. The references are held in public static fields. Do not mess with this! This essentially allows you
  * static access to all sub systems. It is your responsiblity to keep things thread safe. Don't use Graphics in a thread that is
  * not the rendering thread or things will go crazy. Really.
  * <p>
- * There's also references to {@link GLCommon}, {@link GL10}, {@link GL11}, {@link GL20} and {@link GLU}. The same rules as above
- * apply. Don't mess with this or things will break!
+ * There's also references to {@link GLCommon}, {@link GL10}, {@link GL11}, and {@link GL20}. The same rules as above apply. Don't
+ * mess with this or things will break!
  * <p>
  * This is kind of messy but better than throwing around Graphics and similar instances. I'm aware of the design faux pas.
  * @author mzechner */
@@ -44,5 +43,4 @@ public class Gdx {
 	public static GL10 gl10;
 	public static GL11 gl11;
 	public static GL20 gl20;
-	public static GLU glu;
 }
diff --git a/gdx/src/com/badlogic/gdx/Graphics.java b/gdx/src/com/badlogic/gdx/Graphics.java
index 61424b8..37a7723 100644
--- a/gdx/src/com/badlogic/gdx/Graphics.java
+++ b/gdx/src/com/badlogic/gdx/Graphics.java
@@ -20,7 +20,6 @@ import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.GL11;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.GLCommon;
-import com.badlogic.gdx.graphics.GLU;
 import com.badlogic.gdx.graphics.Mesh;
 import com.badlogic.gdx.graphics.Pixmap;
 import com.badlogic.gdx.graphics.Texture;
@@ -60,7 +59,7 @@ public interface Graphics {
 	 * 
 	 * @author mzechner */
 	public enum GraphicsType {
-		AndroidGL, LWJGL, Angle, WebGL, iOSGL
+		AndroidGL, LWJGL, Angle, WebGL, iOSGL, JGLFW
 	}
 
 	/** Describe a fullscreen display mode
@@ -137,9 +136,6 @@ public interface Graphics {
 	/** @return the {@link GL20} instance or null if not supported */
 	public GL20 getGL20 ();
 
-	/** @return the {@link GLU} instance */
-	public GLU getGLU ();
-
 	/** @return the width in pixels of the display surface */
 	public int getWidth ();
 
diff --git a/gdx/src/com/badlogic/gdx/InputProcessorQueue.java b/gdx/src/com/badlogic/gdx/InputProcessorQueue.java
new file mode 100644
index 0000000..6fda916
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/InputProcessorQueue.java
@@ -0,0 +1,154 @@
+
+package com.badlogic.gdx;
+
+import com.badlogic.gdx.utils.IntArray;
+
+/** Queues events that are later passed to the wrapped {@link InputProcessor}.
+ * @author Nathan Sweet */
+public class InputProcessorQueue implements InputProcessor {
+	static private final int KEY_DOWN = 0;
+	static private final int KEY_UP = 1;
+	static private final int KEY_TYPED = 2;
+	static private final int TOUCH_DOWN = 3;
+	static private final int TOUCH_UP = 4;
+	static private final int TOUCH_DRAGGED = 5;
+	static private final int MOUSE_MOVED = 6;
+	static private final int SCROLLED = 7;
+
+	private InputProcessor processor;
+	private final IntArray queue = new IntArray();
+	private final IntArray processingQueue = new IntArray();
+	private long currentEventTime;
+
+	public InputProcessorQueue () {
+	}
+
+	public InputProcessorQueue (InputProcessor processor) {
+		this.processor = processor;
+	}
+
+	public void setProcessor (InputProcessor processor) {
+		this.processor = processor;
+	}
+
+	public InputProcessor getProcessor () {
+		return processor;
+	}
+
+	public void drain () {
+		IntArray q = processingQueue;
+		synchronized (this) {
+			if (processor == null) {
+				queue.clear();
+				return;
+			}
+			q.addAll(queue);
+			queue.clear();
+		}
+		for (int i = 0, n = q.size; i < n;) {
+			currentEventTime = (long)q.get(i++) << 32 | q.get(i++) & 0xFFFFFFFFL;
+			switch (q.get(i++)) {
+			case KEY_DOWN:
+				processor.keyDown(q.get(i++));
+				break;
+			case KEY_UP:
+				processor.keyUp(q.get(i++));
+				break;
+			case KEY_TYPED:
+				processor.keyTyped((char)q.get(i++));
+				break;
+			case TOUCH_DOWN:
+				processor.touchDown(q.get(i++), q.get(i++), q.get(i++), q.get(i++));
+				break;
+			case TOUCH_UP:
+				processor.touchUp(q.get(i++), q.get(i++), q.get(i++), q.get(i++));
+				break;
+			case TOUCH_DRAGGED:
+				processor.touchDragged(q.get(i++), q.get(i++), q.get(i++));
+				break;
+			case MOUSE_MOVED:
+				processor.mouseMoved(q.get(i++), q.get(i++));
+				break;
+			case SCROLLED:
+				processor.scrolled(q.get(i++));
+				break;
+			}
+		}
+		q.clear();
+	}
+
+	private void queueTime () {
+		long time = System.nanoTime();
+		queue.add((int)(time >> 32));
+		queue.add((int)time);
+	}
+
+	public synchronized boolean keyDown (int keycode) {
+		queueTime();
+		queue.add(KEY_DOWN);
+		queue.add(keycode);
+		return false;
+	}
+
+	public synchronized boolean keyUp (int keycode) {
+		queueTime();
+		queue.add(KEY_UP);
+		queue.add(keycode);
+		return false;
+	}
+
+	public synchronized boolean keyTyped (char character) {
+		queueTime();
+		queue.add(KEY_TYPED);
+		queue.add(character);
+		return false;
+	}
+
+	public synchronized boolean touchDown (int screenX, int screenY, int pointer, int button) {
+		queueTime();
+		queue.add(TOUCH_DOWN);
+		queue.add(screenX);
+		queue.add(screenY);
+		queue.add(pointer);
+		queue.add(button);
+		return false;
+	}
+
+	public synchronized boolean touchUp (int screenX, int screenY, int pointer, int button) {
+		queueTime();
+		queue.add(TOUCH_UP);
+		queue.add(screenX);
+		queue.add(screenY);
+		queue.add(pointer);
+		queue.add(button);
+		return false;
+	}
+
+	public synchronized boolean touchDragged (int screenX, int screenY, int pointer) {
+		queueTime();
+		queue.add(TOUCH_DRAGGED);
+		queue.add(screenX);
+		queue.add(screenY);
+		queue.add(pointer);
+		return false;
+	}
+
+	public synchronized boolean mouseMoved (int screenX, int screenY) {
+		queueTime();
+		queue.add(MOUSE_MOVED);
+		queue.add(screenX);
+		queue.add(screenY);
+		return false;
+	}
+
+	public synchronized boolean scrolled (int amount) {
+		queueTime();
+		queue.add(SCROLLED);
+		queue.add(amount);
+		return false;
+	}
+
+	public long getCurrentEventTime () {
+		return currentEventTime;
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/Net.java b/gdx/src/com/badlogic/gdx/Net.java
old mode 100755
new mode 100644
index 6b9430e..ebf4627
--- a/gdx/src/com/badlogic/gdx/Net.java
+++ b/gdx/src/com/badlogic/gdx/Net.java
@@ -26,6 +26,7 @@ import java.util.concurrent.Future;
 
 import com.badlogic.gdx.Net.HttpRequest;
 import com.badlogic.gdx.Net.HttpResponseListener;
+import com.badlogic.gdx.net.HttpStatus;
 import com.badlogic.gdx.net.ServerSocketHints;
 import com.badlogic.gdx.net.Socket;
 import com.badlogic.gdx.net.ServerSocket;
@@ -39,7 +40,7 @@ import com.badlogic.gdx.utils.JsonWriter;
  * To perform an HTTP request create a {@link HttpRequest} with the HTTP method (see {@link HttpMethods} for common methods) and
  * invoke {@link #sendHttpRequest(HttpRequest, HttpResponseListener)} with it and a {@link HttpResponseListener}. After the HTTP
  * request was processed, the {@link HttpResponseListener} is called with a {@link HttpResponse} with the HTTP response values and
- * an status code to determine if the request was successful or not.
+ * an status code to determine if the request was successful or not.</p>
  * 
  * To create a TCP client socket to communicate with a remote TCP server, invoke the
  * {@link #newClientSocket(Protocol, String, int, SocketHints)} method. The returned {@link Socket} offers an {@link InputStream}
@@ -54,24 +55,6 @@ import com.badlogic.gdx.utils.JsonWriter;
  * @author arielsan */
 public interface Net {
 
-	/** Contains information about the HTTP status line returned with the {@link HttpResponse} after a {@link HttpRequest} was
-	 * performed. */
-	public static class HttpStatus {
-
-		int statusCode;
-
-		/** Returns the status code of the HTTP response, normally 2xx status codes indicate success while 4xx and 5xx indicate
-		 * client and server errors, respectively (see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">HTTP/1.1:
-		 * Status Code Definitions</a> for more information about HTTP status codes). */
-		public int getStatusCode () {
-			return statusCode;
-		}
-
-		public HttpStatus (int statusCode) {
-			this.statusCode = statusCode;
-		}
-
-	}
 
 	/** HTTP response interface with methods to get the response data as a byte[], a {@link String} or an {@link InputStream}. */
 	public static interface HttpResponse {
@@ -298,4 +281,4 @@ public interface Net {
 	 * 
 	 * @param URI the URI to be opened. */
 	public void openURI (String URI);
-}
+}
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/assets/AssetManager.java b/gdx/src/com/badlogic/gdx/assets/AssetManager.java
index fd3e326..70a0b9d 100644
--- a/gdx/src/com/badlogic/gdx/assets/AssetManager.java
+++ b/gdx/src/com/badlogic/gdx/assets/AssetManager.java
@@ -55,7 +55,7 @@ public class AssetManager implements Disposable {
 	final ObjectMap<String, Class> assetTypes = new ObjectMap<String, Class>();
 	final ObjectMap<String, Array<String>> assetDependencies = new ObjectMap<String, Array<String>>();
 
-	final ObjectMap<Class, AssetLoader> loaders = new ObjectMap<Class, AssetLoader>();
+	final ObjectMap<Class, ObjectMap<String, AssetLoader>> loaders = new ObjectMap<Class, ObjectMap<String, AssetLoader>>();
 	final Array<AssetDescriptor> loadQueue = new Array<AssetDescriptor>();
 	final ExecutorService threadPool;
 
@@ -220,6 +220,33 @@ public class AssetManager implements Disposable {
 		return assetContainer.getObject(type) != null;
 	}
 
+	/** Returns the default loader for the given type
+	 * @param type The type of the loader to get
+	 * @return The loader capable of loading the type, or null if none exists */
+	public <T> AssetLoader getLoader (final Class<T> type) {
+		return getLoader(type, null);
+	}
+
+	/** Returns the loader for the given type and the specified filename. If no loader exists for the specific filename, the default
+	 * loader for that type is returned.
+	 * @param type The type of the loader to get
+	 * @param fileName The filename of the asset to get a loader for, or null to get the default loader
+	 * @return The loader capable of loading the type and filename, or null if none exists */
+	public <T> AssetLoader getLoader (final Class<T> type, final String fileName) {
+		final ObjectMap<String, AssetLoader> loaders = this.loaders.get(type);
+		if (loaders == null || loaders.size < 1) return null;
+		if (fileName == null) return loaders.get("");
+		AssetLoader result = null;
+		int l = -1;
+		for (ObjectMap.Entry<String, AssetLoader> entry : loaders.entries()) {
+			if (entry.key.length() > l && fileName.endsWith(entry.key)) {
+				result = entry.value;
+				l = entry.key.length();
+			}
+		}
+		return result;
+	}
+
 	/** Adds the given asset to the loading queue of the AssetManager.
 	 * @param fileName the file name (interpretation depends on {@link AssetLoader})
 	 * @param type the type of the asset. */
@@ -232,7 +259,7 @@ public class AssetManager implements Disposable {
 	 * @param type the type of the asset.
 	 * @param parameter parameters for the AssetLoader. */
 	public synchronized <T> void load (String fileName, Class<T> type, AssetLoaderParameters<T> parameter) {
-		AssetLoader loader = loaders.get(type);
+		AssetLoader loader = getLoader(type, fileName);
 		if (loader == null) throw new GdxRuntimeException("No loader for type: " + type.getSimpleName());
 
 		if (loadQueue.size == 0) {
@@ -317,7 +344,7 @@ public class AssetManager implements Disposable {
 	 * of a single task that happens in the GL thread takes a long time.
 	 * @return true if all loading is finished. */
 	public synchronized boolean update (int millis) {
-		long endTime = System.nanoTime() + millis * 1000;
+		long endTime = System.currentTimeMillis() + millis;
 		while (true) {
 			boolean done = update();
 			if (done || System.currentTimeMillis() > endTime) return done;
@@ -380,13 +407,13 @@ public class AssetManager implements Disposable {
 	/** Adds a {@link AssetLoadingTask} to the task stack for the given asset.
 	 * @param assetDesc */
 	private void addTask (AssetDescriptor assetDesc) {
-		AssetLoader loader = loaders.get(assetDesc.type);
+		AssetLoader loader = getLoader(assetDesc.type, assetDesc.fileName);
 		if (loader == null) throw new GdxRuntimeException("No loader for type: " + assetDesc.type.getSimpleName());
 		tasks.push(new AssetLoadingTask(this, assetDesc, loader, threadPool));
 	}
-	
+
 	/** Adds an asset to this AssetManager */
-	protected <T> void addAsset(final String fileName, Class<T> type, T asset) {
+	protected <T> void addAsset (final String fileName, Class<T> type, T asset) {
 		// add the asset to the filename lookup
 		assetTypes.put(fileName, type);
 
@@ -396,7 +423,7 @@ public class AssetManager implements Disposable {
 			typeToAssets = new ObjectMap<String, RefCountedContainer>();
 			assets.put(type, typeToAssets);
 		}
-		typeToAssets.put(fileName, new RefCountedContainer(asset));	
+		typeToAssets.put(fileName, new RefCountedContainer(asset));
 	}
 
 	/** Updates the current task on the top of the task stack.
@@ -475,10 +502,21 @@ public class AssetManager implements Disposable {
 	 * @param type the type of the asset
 	 * @param loader the loader */
 	public synchronized <T, P extends AssetLoaderParameters<T>> void setLoader (Class<T> type, AssetLoader<T, P> loader) {
+		setLoader(type, null, loader);
+	}
+
+	/** Sets a new {@link AssetLoader} for the given type.
+	 * @param type the type of the asset
+	 * @param suffix the suffix the filename must have for this loader to be used or null to specify the default loader.
+	 * @param loader the loader */
+	public synchronized <T, P extends AssetLoaderParameters<T>> void setLoader (Class<T> type, String suffix,
+		AssetLoader<T, P> loader) {
 		if (type == null) throw new IllegalArgumentException("type cannot be null.");
 		if (loader == null) throw new IllegalArgumentException("loader cannot be null.");
 		log.debug("Loader set: " + type.getSimpleName() + " -> " + loader.getClass().getSimpleName());
-		loaders.put(type, loader);
+		ObjectMap<String, AssetLoader> loaders = this.loaders.get(type);
+		if (loaders == null) this.loaders.put(type, loaders = new ObjectMap<String, AssetLoader>());
+		loaders.put(suffix == null ? "" : suffix, loader);
 	}
 
 	/** @return the number of loaded assets */
diff --git a/gdx/src/com/badlogic/gdx/graphics/Camera.java b/gdx/src/com/badlogic/gdx/graphics/Camera.java
index 2ae1ef5..cdf9838 100644
--- a/gdx/src/com/badlogic/gdx/graphics/Camera.java
+++ b/gdx/src/com/badlogic/gdx/graphics/Camera.java
@@ -22,6 +22,7 @@ import com.badlogic.gdx.Input;
 import com.badlogic.gdx.graphics.g2d.SpriteBatch;
 import com.badlogic.gdx.math.Frustum;
 import com.badlogic.gdx.math.Matrix4;
+import com.badlogic.gdx.math.Quaternion;
 import com.badlogic.gdx.math.Vector3;
 import com.badlogic.gdx.math.collision.Ray;
 
@@ -57,7 +58,6 @@ public abstract class Camera {
 	/** the frustum **/
 	public final Frustum frustum = new Frustum();
 
-	private final Matrix4 tmpMat = new Matrix4();
 	private final Vector3 tmpVec = new Vector3();
 
 	/** Recalculates the projection and view matrix of this camera and the {@link Frustum} planes. Use this after you've manipulated
@@ -87,6 +87,12 @@ public abstract class Camera {
 	public void lookAt (float x, float y, float z) {
 		direction.set(x, y, z).sub(position).nor();
 	}
+	
+	/** Recalculates the direction of the camera to look at the point (x, y, z).
+	 * @param target the point to look at */
+	public void lookAt (Vector3 target) {
+		direction.set(target).sub(position).nor();
+	}
 
 	/** Normalizes the up vector by first calculating the right vector via a cross product between direction and up, and then
 	 * recalculating the up vector via a cross product between right and direction. */
@@ -105,7 +111,8 @@ public abstract class Camera {
 	 * @param axisY the y-component of the axis
 	 * @param axisZ the z-component of the axis */
 	public void rotate (float angle, float axisX, float axisY, float axisZ) {
-		rotate(tmpVec.set(axisX, axisY, axisZ), angle);
+		direction.rotate(axisX, axisY, axisZ, angle);
+		up.rotate(axisX, axisY, axisZ, angle);
 	}
 
 	/** Rotates the direction and up vector of this camera by the given angle around the given axis. The direction and up vector
@@ -114,13 +121,30 @@ public abstract class Camera {
 	 * @param axis
 	 * @param angle the angle */
 	public void rotate (Vector3 axis, float angle) {
-		tmpMat.setToRotation(axis, angle);
-		direction.mul(tmpMat).nor();
-		up.mul(tmpMat).nor();
+		direction.rotate(axis, angle);
+		up.rotate(axis, angle);
+	}
+
+	/** Rotates the direction and up vector of this camera by the given rotation matrix. The direction and up vector
+	 * will not be orthogonalized.
+	 * 
+	 * @param transform The rotation matrix */
+	public void rotate(final Matrix4 transform) {
+		direction.rot(transform);
+		up.rot(transform);
 	}
 	
-	/** Rotates the direction and up vector of this camera by the given angle around the given axis, with the axis attached to given point. 
-	 * The direction and up vector will not be orthogonalized.
+	/** Rotates the direction and up vector of this camera by the given {@link Quaternion}. The direction and up vector
+	 * will not be orthogonalized.
+	 * 
+	 * @param quat The quaternion */
+	public void rotate(final Quaternion quat) {
+		quat.transform(direction);
+		quat.transform(up);
+	}
+
+	/** Rotates the direction and up vector of this camera by the given angle around the given axis, with the axis attached to given
+	 * point. The direction and up vector will not be orthogonalized.
 	 * 
 	 * @param point
 	 * @param axis
@@ -133,6 +157,14 @@ public abstract class Camera {
 		tmpVec.rotate(axis, angle);
 		translate(-tmpVec.x, -tmpVec.y, -tmpVec.z);
 	}
+	
+	/** Transform the position, direction and up vector by the given matrix
+	 * 
+	 * @param transform The transform matrix */
+	public void transform(final Matrix4 transform) {
+		position.mul(transform);
+		rotate(transform);
+	}
 
 	/** Moves the camera by the given amount on each axis.
 	 * @param x the displacement on the x-axis
@@ -148,13 +180,12 @@ public abstract class Camera {
 		position.add(vec);
 	}
 
-	/** Function to translate a point given in window (or window) coordinates to world space. It's the same as
-	 * {@link GLU#gluUnProject(float, float, float, float[], int, float[], int, int[], int, float[], int)} but does not rely on
-	 * OpenGL. The x- and y-coordinate of vec are assumed to be in window coordinates (origin is the top left corner, y pointing
-	 * down, x pointing to the right) as reported by the touch methods in {@link Input}. A z-coordinate of 0 will return a point on
-	 * the near plane, a z-coordinate of 1 will return a point on the far plane. This method allows you to specify the viewport
-	 * position and dimensions in the coordinate system expected by {@link GLCommon#glViewport(int, int, int, int)}, with the
-	 * origin in the bottom left corner of the screen.
+	/** Function to translate a point given in window (or window) coordinates to world space. It's the same as GLU gluUnProject, but
+	 * does not rely on OpenGL. The x- and y-coordinate of vec are assumed to be in window coordinates (origin is the top left
+	 * corner, y pointing down, x pointing to the right) as reported by the touch methods in {@link Input}. A z-coordinate of 0
+	 * will return a point on the near plane, a z-coordinate of 1 will return a point on the far plane. This method allows you to
+	 * specify the viewport position and dimensions in the coordinate system expected by
+	 * {@link GLCommon#glViewport(int, int, int, int)}, with the origin in the bottom left corner of the screen.
 	 * 
 	 * @param vec the point in window coordinates (origin top left)
 	 * @param viewportX the coordinate of the top left corner of the viewport in glViewport coordinates (origin bottom left)
@@ -172,35 +203,32 @@ public abstract class Camera {
 		vec.prj(invProjectionView);
 	}
 
-	/** Function to translate a point given in window (or window) coordinates to world space. It's the same as
-	 * {@link GLU#gluUnProject(float, float, float, float[], int, float[], int, int[], int, float[], int)} but does not rely on
-	 * OpenGL. The viewport is assumed to span the whole screen and is fetched from {@link Graphics#getWidth()} and
-	 * {@link Graphics#getHeight()}. The x- and y-coordinate of vec are assumed to be in window coordinates (origin is the top left
-	 * corner, y pointing down, x pointing to the right) as reported by the touch methods in {@link Input}. A z-coordinate of 0
-	 * will return a point on the near plane, a z-coordinate of 1 will return a point on the far plane.
+	/** Function to translate a point given in window (or window) coordinates to world space. It's the same as GLU gluUnProject but
+	 * does not rely on OpenGL. The viewport is assumed to span the whole screen and is fetched from {@link Graphics#getWidth()}
+	 * and {@link Graphics#getHeight()}. The x- and y-coordinate of vec are assumed to be in window coordinates (origin is the top
+	 * left corner, y pointing down, x pointing to the right) as reported by the touch methods in {@link Input}. A z-coordinate of
+	 * 0 will return a point on the near plane, a z-coordinate of 1 will return a point on the far plane.
 	 * 
 	 * @param vec the point in window coordinates */
 	public void unproject (Vector3 vec) {
 		unproject(vec, 0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
 	}
 
-	/** Projects the {@link Vector3} given in object/world space to window coordinates. It's the same as
-	 * {@link GLU#gluProject(float, float, float, float[], int, float[], int, int[], int, float[], int)} with one small deviation:
-	 * The viewport is assumed to span the whole screen. The window coordinate system has its origin in the <b>bottom</b> left,
-	 * with the y-axis pointing <b>upwards</b> and the x-axis pointing to the right. This makes it easily useable in conjunction
-	 * with {@link SpriteBatch} and similar classes.
+	/** Projects the {@link Vector3} given in object/world space to window coordinates. It's the same as GLU gluProject with one
+	 * small deviation: The viewport is assumed to span the whole screen. The window coordinate system has its origin in the
+	 * <b>bottom</b> left, with the y-axis pointing <b>upwards</b> and the x-axis pointing to the right. This makes it easily
+	 * useable in conjunction with {@link SpriteBatch} and similar classes.
 	 * @param vec the position in object/world space. */
 	public void project (Vector3 vec) {
 		project(vec, 0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
 	}
 
-	/** Projects the {@link Vector3} given in object/world space to window coordinates. It's the same as
-	 * {@link GLU#gluProject(float, float, float, float[], int, float[], int, int[], int, float[], int)} with one small deviation:
-	 * The viewport is assumed to span the whole screen. The window coordinate system has its origin in the <b>bottom</b> left,
-	 * with the y-axis pointing <b>upwards</b> and the x-axis pointing to the right. This makes it easily useable in conjunction
-	 * with {@link SpriteBatch} and similar classes. This method allows you to specify the viewport position and dimensions in the
-	 * coordinate system expected by {@link GLCommon#glViewport(int, int, int, int)}, with the origin in the bottom left corner of
-	 * the screen.
+	/** Projects the {@link Vector3} given in object/world space to window coordinates. It's the same as GLU gluProject with one
+	 * small deviation: The viewport is assumed to span the whole screen. The window coordinate system has its origin in the
+	 * <b>bottom</b> left, with the y-axis pointing <b>upwards</b> and the x-axis pointing to the right. This makes it easily
+	 * useable in conjunction with {@link SpriteBatch} and similar classes. This method allows you to specify the viewport position
+	 * and dimensions in the coordinate system expected by {@link GLCommon#glViewport(int, int, int, int)}, with the origin in the
+	 * bottom left corner of the screen.
 	 * 
 	 * @param vec the point in object/world space
 	 * @param viewportX the coordinate of the top left corner of the viewport in glViewport coordinates (origin bottom left)
diff --git a/gdx/src/com/badlogic/gdx/graphics/GLU.java b/gdx/src/com/badlogic/gdx/graphics/GLU.java
deleted file mode 100644
index e46dd02..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/GLU.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics;
-
-/** OpenGL utility class.
- * @author mzechner */
-public interface GLU {
-	public void gluLookAt (GL10 gl, float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX,
-		float upY, float upZ);
-
-	public void gluOrtho2D (GL10 gl, float left, float right, float bottom, float top);
-
-	public void gluPerspective (GL10 gl, float fovy, float aspect, float zNear, float zFar);
-
-	public boolean gluProject (float objX, float objY, float objZ, float[] model, int modelOffset, float[] project,
-		int projectOffset, int[] view, int viewOffset, float[] win, int winOffset);
-
-	public boolean gluUnProject (float winX, float winY, float winZ, float[] model, int modelOffset, float[] project,
-		int projectOffset, int[] view, int viewOffset, float[] obj, int objOffset);
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/TextureDict.java b/gdx/src/com/badlogic/gdx/graphics/TextureDict.java
deleted file mode 100644
index bedea20..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/TextureDict.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics;
-
-import com.badlogic.gdx.Files.FileType;
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.Texture.TextureFilter;
-import com.badlogic.gdx.graphics.Texture.TextureWrap;
-import com.badlogic.gdx.utils.ObjectMap;
-
-/** <p>
- * A texture dictionary is used to track the usage of your textures and supply a single point of access for texture resources. It
- * stores {@link TextureRef}s by their path. If you need to load the same texture in different parts of your application it will
- * only be loaded into memory once by the dictionary.
- * </p>
- * @deprecated
- * @author Dave Clayton <contact@redskyforge.com> */
-public class TextureDict {
-
-	private static ObjectMap<String, TextureRef> sDictionary = new ObjectMap<String, TextureRef>();
-
-	/** Loads a new texture into the dictionary as a reference counted {@link TextureRef}.
-	 * @param path the path to the texture image.
-	 * @return the {@TextureRef} representing the texture. */
-	public static TextureRef loadTexture (String path) {
-		return loadTexture(path, TextureFilter.MipMap, TextureFilter.Linear, TextureWrap.ClampToEdge, TextureWrap.ClampToEdge);
-	}
-
-	/** Loads a new texture into the dictionary as a reference counted {@link TextureRef}.
-	 * @param path the path to the texture image.
-	 * @param minFilter minFilter {@link TextureFilter}.
-	 * @param magFilter magFilter {@link TextureFilter}.
-	 * @param uwrap u-wrapping.
-	 * @param vwrap v-wrapping.
-	 * @return the {@TextureRef} representing the texture. */
-	public static TextureRef loadTexture (String path, TextureFilter minFilter, TextureFilter magFilter, TextureWrap uwrap,
-		TextureWrap vwrap) {
-		if (sDictionary.containsKey(path)) {
-			TextureRef ref = sDictionary.get(path);
-			ref.addRef();
-			return ref;
-		}
-		// load new texture
-		FileHandle texFile = Gdx.app.getFiles().getFileHandle(path, FileType.Internal);
-		Texture newTex = new Texture(texFile, minFilter.isMipMap() || magFilter.isMipMap() ? true : false);
-		newTex.setFilter(minFilter, magFilter);
-		newTex.setWrap(uwrap, vwrap);
-		TextureRef ref = new TextureRef(path, newTex);
-		sDictionary.put(path, ref);
-		return ref;
-	}
-
-	/** Removes a texture from the dictionary. In general you should probably not use this - use {@link TextureRef#unload()}
-	 * instead.
-	 * @param path to the texture. */
-	public static void removeTexture (String path) {
-		sDictionary.remove(path);
-	}
-
-	/** Unloads all of the currently managed textures. */
-	public static void unloadAll () {
-		for (TextureRef tex : sDictionary.values()) {
-			tex.dispose();
-		}
-		sDictionary.clear();
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/TextureRef.java b/gdx/src/com/badlogic/gdx/graphics/TextureRef.java
deleted file mode 100644
index 7bbbe75..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/TextureRef.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics;
-
-/** <p>
- * A reference counted wrapper for a {@link Texture}. TextureRefs are managed by the {@link TextureDict}.
- * </p>
- * @deprecated
- * @author Dave Clayton <contact@redskyforge.com> */
-public class TextureRef {
-	public String Name;
-	private int mRefCount;
-	private Texture mTexture;
-
-	/** Create a new TextureRef with the given name and texture.
-	 * @param name The texture's name, typically its filesystem path.
-	 * @param texture The texture it reference counts. */
-	public TextureRef (String name, Texture texture) {
-		Name = name;
-		mTexture = texture;
-		mRefCount = 1;
-	}
-
-	/** Adds a reference to the texture. */
-	public void addRef () {
-		mRefCount++;
-	}
-
-	/** Removes a reference to the texture. If the internal reference count reaches 0, the texture is disposed.
-	 * @return the new reference count. */
-	public int unload () {
-		if (--mRefCount == 0) {
-			mTexture.dispose();
-			mTexture = null;
-			// Note: This doesn't seem the best way to do this, but it works. Re-factoring welcome :)
-			TextureDict.removeTexture(Name);
-		}
-		return mRefCount;
-	}
-
-	public void dispose () {
-		mTexture.dispose();
-	}
-
-	/** Binds the texture in OpenGL. */
-	public void bind () {
-		mTexture.bind();
-	}
-
-	/** Gets the wrapped texture.
-	 * @return the texture. */
-	public Texture get () {
-		return mTexture;
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/Animation.java b/gdx/src/com/badlogic/gdx/graphics/g2d/Animation.java
index b679557..2a29c32 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/Animation.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/Animation.java
@@ -171,7 +171,6 @@ public class Animation {
 	 * @param stateTime
 	 * @return whether the animation is finished. */
 	public boolean isAnimationFinished (float stateTime) {
-		if(playMode != NORMAL && playMode != REVERSED) return false;
 		int frameNumber = (int)(stateTime / frameDuration);
 		return keyFrames.length - 1 < frameNumber;
 	}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/Gdx2DPixmap.java b/gdx/src/com/badlogic/gdx/graphics/g2d/Gdx2DPixmap.java
index cacebfc..3efad63 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/Gdx2DPixmap.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/Gdx2DPixmap.java
@@ -81,9 +81,10 @@ public class Gdx2DPixmap implements Disposable {
 		format = (int)nativeData[3];
 	}
 
-	public Gdx2DPixmap (int width, int height, int format) throws IllegalArgumentException {
+	/** @throws GdxRuntimeException if allocation failed. */
+	public Gdx2DPixmap (int width, int height, int format) throws GdxRuntimeException {
 		pixelPtr = newPixmap(nativeData, width, height, format);
-		if (pixelPtr == null) throw new IllegalArgumentException("couldn't load pixmap");
+		if (pixelPtr == null) throw new GdxRuntimeException("couldn't load pixmap");
 
 		this.basePtr = nativeData[0];
 		this.width = (int)nativeData[1];
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/NinePatch.java b/gdx/src/com/badlogic/gdx/graphics/g2d/NinePatch.java
index dd0b69a..7c6e76b 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/NinePatch.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/NinePatch.java
@@ -21,7 +21,16 @@ import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 
 /** A 3x3 grid of texture regions. Any of the regions may be omitted. Padding may be set as a hint on how to inset content on top
- * of the ninepatch. */
+ * of the ninepatch (by default the eight "edge" textures of the nine-patch define the padding).  When drawn the eight "edge" patches
+ * will not be scaled, only the interior patch will be scaled.
+ * 
+ * <p><b>NOTE</b>: This class expects a "post-processed" nine-patch, and not a raw ".9.png" texture. That is, the textures given to
+ * this class should <em>not</em> include the meta-data pixels from a ".9.png" that describe the layout of the ninepatch over the
+ * interior of the graphic. That information should be passed into the constructor either implicitly as the size of the individual
+ * patch textures, or via the <code>left, right, top, bottom</code> parameters to {@link #NinePatch(Texture, int, int, int, int)}
+ * or {@link #NinePatch(TextureRegion, int, int, int, int)}.
+ * 
+ * <p>A correctly created {@link TextureAtlas} is one way to generate a post-processed nine-patch from a ".9.png" file. */
 public class NinePatch {
 	public static final int TOP_LEFT = 0;
 	public static final int TOP_CENTER = 1;
@@ -30,10 +39,11 @@ public class NinePatch {
 	public static final int MIDDLE_CENTER = 4;
 	public static final int MIDDLE_RIGHT = 5;
 	public static final int BOTTOM_LEFT = 6;
+	/** Indices for {@link #NinePatch(TextureRegion...)} constructor */  // alphabetically first in javadoc
 	public static final int BOTTOM_CENTER = 7;
 	public static final int BOTTOM_RIGHT = 8;
 
-	static private final Color tempColor = new Color();
+	static private final Color tmpDrawColor = new Color();
 
 	private Texture texture;
 	private int bottomLeft = -1, bottomCenter = -1, bottomRight = -1;
@@ -45,7 +55,10 @@ public class NinePatch {
 	private final Color color = new Color(Color.WHITE);
 	private int padLeft = -1, padRight = -1, padTop = -1, padBottom = -1;
 
-	/** @param left Pixels from left edge.
+	/** Create a ninepatch by cutting up the given texture into nine patches. The subsequent parameters define the 4 lines that will
+	 * cut the texture region into 9 pieces.
+	 * 
+	 * @param left Pixels from left edge.
 	 * @param right Pixels from right edge.
 	 * @param top Pixels from top edge.
 	 * @param bottom Pixels from bottom edge. */
@@ -53,30 +66,33 @@ public class NinePatch {
 		this(new TextureRegion(texture), left, right, top, bottom);
 	}
 
-	/** @param left Pixels from left edge.
+	/** Create a ninepatch by cutting up the given texture region into nine patches. The subsequent parameters define the 4 lines
+	 * that will cut the texture region into 9 pieces.
+	 * 
+	 * @param left Pixels from left edge.
 	 * @param right Pixels from right edge.
 	 * @param top Pixels from top edge.
 	 * @param bottom Pixels from bottom edge. */
 	public NinePatch (TextureRegion region, int left, int right, int top, int bottom) {
 		if (region == null) throw new IllegalArgumentException("region cannot be null.");
-		int middleWidth = region.getRegionWidth() - left - right;
-		int middleHeight = region.getRegionHeight() - top - bottom;
+		final int middleWidth = region.getRegionWidth() - left - right;
+		final int middleHeight = region.getRegionHeight() - top - bottom;
 
 		TextureRegion[] patches = new TextureRegion[9];
 		if (top > 0) {
-			if (left > 0) patches[0] = new TextureRegion(region, 0, 0, left, top);
-			if (middleWidth > 0) patches[1] = new TextureRegion(region, left, 0, middleWidth, top);
-			if (right > 0) patches[2] = new TextureRegion(region, left + middleWidth, 0, right, top);
+			if (left > 0) patches[TOP_LEFT] = new TextureRegion(region, 0, 0, left, top);
+			if (middleWidth > 0) patches[TOP_CENTER] = new TextureRegion(region, left, 0, middleWidth, top);
+			if (right > 0) patches[TOP_RIGHT] = new TextureRegion(region, left + middleWidth, 0, right, top);
 		}
 		if (middleHeight > 0) {
-			if (left > 0) patches[3] = new TextureRegion(region, 0, top, left, middleHeight);
-			if (middleWidth > 0) patches[4] = new TextureRegion(region, left, top, middleWidth, middleHeight);
-			if (right > 0) patches[5] = new TextureRegion(region, left + middleWidth, top, right, middleHeight);
+			if (left > 0) patches[MIDDLE_LEFT] = new TextureRegion(region, 0, top, left, middleHeight);
+			if (middleWidth > 0) patches[MIDDLE_CENTER] = new TextureRegion(region, left, top, middleWidth, middleHeight);
+			if (right > 0) patches[MIDDLE_RIGHT] = new TextureRegion(region, left + middleWidth, top, right, middleHeight);
 		}
 		if (bottom > 0) {
-			if (left > 0) patches[6] = new TextureRegion(region, 0, top + middleHeight, left, bottom);
-			if (middleWidth > 0) patches[7] = new TextureRegion(region, left, top + middleHeight, middleWidth, bottom);
-			if (right > 0) patches[8] = new TextureRegion(region, left + middleWidth, top + middleHeight, right, bottom);
+			if (left > 0) patches[BOTTOM_LEFT] = new TextureRegion(region, 0, top + middleHeight, left, bottom);
+			if (middleWidth > 0) patches[BOTTOM_CENTER] = new TextureRegion(region, left, top + middleHeight, middleWidth, bottom);
+			if (right > 0) patches[BOTTOM_RIGHT] = new TextureRegion(region, left + middleWidth, top + middleHeight, right, bottom);
 		}
 
 		// If split only vertical, move splits from right to center.
@@ -101,20 +117,24 @@ public class NinePatch {
 		load(patches);
 	}
 
+	/** Construct a degenerate "nine" patch with only a center component. */
 	public NinePatch (Texture texture, Color color) {
 		this(texture);
 		setColor(color);
 	}
 
+	/** Construct a degenerate "nine" patch with only a center component. */
 	public NinePatch (Texture texture) {
 		this(new TextureRegion(texture));
 	}
 
+	/** Construct a degenerate "nine" patch with only a center component. */
 	public NinePatch (TextureRegion region, Color color) {
 		this(region);
 		setColor(color);
 	}
 
+	/** Construct a degenerate "nine" patch with only a center component. */
 	public NinePatch (TextureRegion region) {
 		load(new TextureRegion[] {
 			//
@@ -124,6 +144,9 @@ public class NinePatch {
 		});
 	}
 
+	/** Construct a nine patch from the given nine texture regions. The provided patches must be consistently sized (e.g., any left
+	 * edge textures must have the same width, etc). Patches may be <code>null</code>. Patch indices are specified via the public
+	 * members {@link #TOP_LEFT}, {@link #TOP_CENTER}, etc. */ 
 	public NinePatch (TextureRegion... patches) {
 		if (patches == null || patches.length != 9) throw new IllegalArgumentException("NinePatch needs nine TextureRegions");
 
@@ -159,7 +182,7 @@ public class NinePatch {
 	}
 
 	public NinePatch (NinePatch ninePatch) {
-		this(ninePatch, new Color(ninePatch.color));
+		this(ninePatch, ninePatch.color);
 	}
 
 	public NinePatch (NinePatch ninePatch, Color color) {
@@ -189,7 +212,7 @@ public class NinePatch {
 	}
 
 	private void load (TextureRegion[] patches) {
-		float color = Color.WHITE.toFloatBits();
+		final float color = Color.WHITE.toFloatBits(); // placeholder color, overwritten at draw time
 
 		if (patches[BOTTOM_LEFT] != null) {
 			bottomLeft = add(patches[BOTTOM_LEFT], color);
@@ -275,6 +298,7 @@ public class NinePatch {
 		return idx - 4 * 5;
 	}
 
+	/** Set the coordinates and color of a ninth of the patch. */
 	private void set (int idx, float x, float y, float width, float height, float color) {
 		final float fx2 = x + width;
 		final float fy2 = y + height;
@@ -297,11 +321,11 @@ public class NinePatch {
 	}
 
 	public void draw (SpriteBatch batch, float x, float y, float width, float height) {
-		float centerColumnX = x + leftWidth;
-		float rightColumnX = x + width - rightWidth;
-		float middleRowY = y + bottomHeight;
-		float topRowY = y + height - topHeight;
-		float c = tempColor.set(color).mul(batch.getColor()).toFloatBits();
+		final float centerColumnX = x + leftWidth;
+		final float rightColumnX = x + width - rightWidth;
+		final float middleRowY = y + bottomHeight;
+		final float topRowY = y + height - topHeight;
+		final float c = tmpDrawColor.set(color).mul(batch.getColor()).toFloatBits();
 
 		if (bottomLeft != -1) set(bottomLeft, x, y, centerColumnX - x, middleRowY - y, c);
 		if (bottomCenter != -1) set(bottomCenter, centerColumnX, y, rightColumnX - centerColumnX, middleRowY - y, c);
@@ -317,6 +341,8 @@ public class NinePatch {
 		batch.draw(texture, vertices, 0, idx);
 	}
 
+	/** Copy given color. The color will be blended with the batch color, then combined with the texture colors at
+	 * {@link NinePatch#draw(SpriteBatch, float, float, float, float) draw} time. Default is {@link Color#WHITE}. */
 	public void setColor (Color color) {
 		this.color.set(color);
 	}
@@ -329,6 +355,7 @@ public class NinePatch {
 		return leftWidth;
 	}
 
+	/** Set the draw-time width of the three left edge patches */ 
 	public void setLeftWidth (float leftWidth) {
 		this.leftWidth = leftWidth;
 	}
@@ -337,6 +364,7 @@ public class NinePatch {
 		return rightWidth;
 	}
 
+	/** Set the draw-time width of the three right edge patches */ 
 	public void setRightWidth (float rightWidth) {
 		this.rightWidth = rightWidth;
 	}
@@ -345,6 +373,7 @@ public class NinePatch {
 		return topHeight;
 	}
 
+	/** Set the draw-time height of the three top edge patches */ 
 	public void setTopHeight (float topHeight) {
 		this.topHeight = topHeight;
 	}
@@ -353,6 +382,7 @@ public class NinePatch {
 		return bottomHeight;
 	}
 
+	/** Set the draw-time height of the three bottom edge patches */ 
 	public void setBottomHeight (float bottomHeight) {
 		this.bottomHeight = bottomHeight;
 	}
@@ -361,6 +391,9 @@ public class NinePatch {
 		return middleWidth;
 	}
 
+	/** Set the width of the middle column of the patch. At render time, this is implicitly the requested render-width of the entire
+	 * nine patch, minus the left and right width. This value is only used for computing the {@link #getTotalWidth() default total
+	 * width}. */
 	public void setMiddleWidth (float middleWidth) {
 		this.middleWidth = middleWidth;
 	}
@@ -369,6 +402,9 @@ public class NinePatch {
 		return middleHeight;
 	}
 
+	/** Set the height of the middle row of the patch. At render time, this is implicitly the requested render-height of the entire
+	 * nine patch, minus the top and bottom height. This value is only used for computing the {@link #getTotalHeight() default total
+	 * height}. */
 	public void setMiddleHeight (float middleHeight) {
 		this.middleHeight = middleHeight;
 	}
@@ -381,6 +417,8 @@ public class NinePatch {
 		return topHeight + middleHeight + bottomHeight;
 	}
 
+	/** Set the padding for content inside this ninepatch. By default the padding is set to match the exterior of the ninepatch, so
+	 * the content should fit exactly within the middle patch. */
 	public void setPadding (int left, int right, int top, int bottom) {
 		this.padLeft = left;
 		this.padRight = right;
@@ -394,6 +432,7 @@ public class NinePatch {
 		return padLeft;
 	}
 
+	/** See {@link #setPadding(int, int, int, int)} */
 	public void setPadLeft (int left) {
 		this.padLeft = left;
 	}
@@ -404,6 +443,7 @@ public class NinePatch {
 		return padRight;
 	}
 
+	/** See {@link #setPadding(int, int, int, int)} */
 	public void setPadRight (int right) {
 		this.padRight = right;
 	}
@@ -413,7 +453,8 @@ public class NinePatch {
 		if (padTop == -1) return getTopHeight();
 		return padTop;
 	}
-
+	
+	/** See {@link #setPadding(int, int, int, int)} */
 	public void setPadTop (int top) {
 		this.padTop = top;
 	}
@@ -424,6 +465,7 @@ public class NinePatch {
 		return padBottom;
 	}
 
+	/** See {@link #setPadding(int, int, int, int)} */
 	public void setPadBottom (int bottom) {
 		this.padBottom = bottom;
 	}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteCache.java b/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteCache.java
index 4814de9..6ba3dcc 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteCache.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteCache.java
@@ -859,13 +859,14 @@ public class SpriteCache implements Disposable {
 				customShader.setUniformMatrix("u_trans", transformMatrix);
 				customShader.setUniformMatrix("u_projTrans", combinedMatrix);
 				customShader.setUniformi("u_texture", 0);
+				mesh.bind(customShader);
 			} else {
 				shader.begin();
 				shader.setUniformMatrix("u_projectionViewMatrix", combinedMatrix);
 				shader.setUniformi("u_texture", 0);
+				mesh.bind(shader);
 			}
 
-			mesh.bind(shader);
 		}
 		drawing = true;
 	}
@@ -884,7 +885,8 @@ public class SpriteCache implements Disposable {
 			shader.end();
 			GL20 gl = Gdx.gl20;
 			gl.glDepthMask(true);
-			mesh.unbind(shader);
+			if(customShader != null) mesh.unbind(customShader);
+			else mesh.unbind(shader);
 		}
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/TextureRegion.java b/gdx/src/com/badlogic/gdx/graphics/g2d/TextureRegion.java
index 9ce40b8..532a372 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/TextureRegion.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/TextureRegion.java
@@ -225,7 +225,8 @@ public class TextureRegion {
 
 	/** Helper function to create tiles out of this TextureRegion starting from the top left corner going to the left and ending at
 	 * the bottom right corner. Only complete tiles will be returned so if the region's width or height are not a multiple of the
-	 * tile width and height not all of the region will be used.
+	 * tile width and height not all of the region will be used. This will not work on texture regions returned form a TextureAtlas
+	 * that either have whitespace removed or where flipped before the region is split.
 	 * 
 	 * @param tileWidth a tile's width in pixels
 	 * @param tileHeight a tile's height in pixels
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/AnimatedModelInstance.java b/gdx/src/com/badlogic/gdx/graphics/g3d/AnimatedModelInstance.java
deleted file mode 100644
index ea207db..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/AnimatedModelInstance.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d;
-
-public interface AnimatedModelInstance extends StillModelInstance {
-	public String getAnimation ();
-
-	public float getAnimationTime ();
-
-	public boolean isLooping ();
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/AnimatedModelNode.java b/gdx/src/com/badlogic/gdx/graphics/g3d/AnimatedModelNode.java
deleted file mode 100644
index 63950aa..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/AnimatedModelNode.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d;
-
-import com.badlogic.gdx.graphics.g3d.materials.Material;
-
-public class AnimatedModelNode extends StillModelNode implements AnimatedModelInstance {
-	public String animation;
-	public float time;
-	public boolean looping;
-	
-	public AnimatedModelNode() {
-		super();
-	}
-	
-	public AnimatedModelNode(Material[] materials) {
-		super(materials);
-	}
-
-	@Override
-	public String getAnimation () {
-		return animation;
-	}
-
-	@Override
-	public float getAnimationTime () {
-		return time;
-	}
-
-	@Override
-	public boolean isLooping () {
-		return looping;
-	}
-
-	public AnimatedModelNode copy () {
-		final AnimatedModelNode copy = new AnimatedModelNode();
-		if (materials != null) {
-			final int len = materials.length;
-			Material[] mats = new Material[len];
-			for (int i = 0; i < len; i++) {
-				mats[i] = materials[i].copy();
-			}
-			copy.materials = mats;
-		}
-		copy.matrix.set(matrix.val);
-		copy.origin.set(origin);
-		copy.radius = radius;
-		copy.transformedPosition.set(transformedPosition);
-		copy.animation = animation;
-		copy.time = time;
-		copy.looping = looping;
-		return copy;
-	}
-
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/DefaultShader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/DefaultShader.java
new file mode 100644
index 0000000..4647fc1
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/DefaultShader.java
@@ -0,0 +1,24 @@
+package com.badlogic.gdx.graphics.g3d;
+
+import com.badlogic.gdx.graphics.g3d.test.TestShader;
+import com.badlogic.gdx.graphics.g3d.utils.ExclusiveTextures;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+
+public class DefaultShader extends TestShader {
+// TODO implement a default shader, for now it's just a stub to TestShader
+	public DefaultShader (long mask) {
+		super(mask);
+		// TODO Auto-generated constructor stub
+	}
+
+	/* public DefaultShader (ShaderProgram program) {
+		super(program);
+		// TODO Auto-generated constructor stub
+	}
+
+	public DefaultShader (String vertexShader, String fragmentShader) {
+		super(vertexShader, fragmentShader);
+		// TODO Auto-generated constructor stub
+	}*/
+
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/ModelLoaderHints.java b/gdx/src/com/badlogic/gdx/graphics/g3d/ModelLoaderHints.java
deleted file mode 100644
index 580be89..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/ModelLoaderHints.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d;
-
-import com.badlogic.gdx.graphics.g3d.loaders.ModelLoaderRegistry;
-
-/** Hints passed to a loader which might ignore them. See {@link ModelLoaderRegistry}.
- * @author mzechner */
-public class ModelLoaderHints {
-	/** whether to flip the v texture coordinate **/
-	public final boolean flipV;
-
-	public ModelLoaderHints (boolean flipV) {
-		this.flipV = flipV;
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/ModelRenderer.java b/gdx/src/com/badlogic/gdx/graphics/g3d/ModelRenderer.java
deleted file mode 100644
index 362b286..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/ModelRenderer.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d;
-
-import com.badlogic.gdx.graphics.g3d.model.AnimatedModel;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
-
-public interface ModelRenderer {
-	public void begin ();
-
-	public void draw (StillModel model, StillModelInstance instance);
-
-	public void draw (AnimatedModel model, AnimatedModelInstance instance);
-
-	public void end ();
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/RenderBatch.java b/gdx/src/com/badlogic/gdx/graphics/g3d/RenderBatch.java
new file mode 100644
index 0000000..2a1cf94
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/RenderBatch.java
@@ -0,0 +1,143 @@
+package com.badlogic.gdx.graphics.g3d;
+
+import com.badlogic.gdx.graphics.Camera;
+import com.badlogic.gdx.graphics.g3d.old.model.Model;
+import com.badlogic.gdx.graphics.g3d.old.model.SubMesh;
+import com.badlogic.gdx.graphics.g3d.test.InterimModel;
+import com.badlogic.gdx.graphics.g3d.test.Light;
+import com.badlogic.gdx.graphics.g3d.test.NewModel;
+import com.badlogic.gdx.graphics.g3d.utils.ExclusiveTextures;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.badlogic.gdx.math.Matrix4;
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.Pool;
+
+public class RenderBatch {
+	protected RenderContext context;
+	protected RenderBatchListener listener;
+	protected Camera camera;
+	// TODO: perhaps its better to use a sorted list?
+	protected final Array<RenderInstance> instances = new Array<RenderInstance>();
+	/* protected final Pool<RenderInstance> instancePool = new Pool<RenderInstance>() {
+		@Override
+		protected RenderInstance newObject () {
+			return new RenderInstance();
+		}
+	}; */
+	
+	/** Construct a BaseRenderBatch with the specified listener */
+	public RenderBatch(RenderBatchListener listener, ExclusiveTextures textures) {
+		this.listener = listener;
+		this.context = new RenderContext(textures);
+	}
+	
+	/** Construct a BaseRenderBatch with the default implementation and the specified texture range */
+	public RenderBatch(ExclusiveTextures textures) {
+		this(new RenderBatchAdapter(), textures);
+	}
+	
+	/** Construct a BaseRenderBatch with the default implementation */
+	public RenderBatch() {
+		this((ExclusiveTextures)null);
+	}
+
+	public void begin (Camera cam) {
+		this.camera = cam;
+	}
+
+	public void end () {
+		instances.sort(listener);
+		context.begin();
+		Shader currentShader = null;
+		for (int i = 0; i < instances.size; i++) {
+			final RenderInstance instance = instances.get(i);
+			if (currentShader != instance.shader) {
+				if (currentShader != null)
+					currentShader.end();
+				currentShader = instance.shader;
+				currentShader.begin(camera, context);
+			}
+			currentShader.render(instance);
+		}
+		if (currentShader != null)
+			currentShader.end();
+		context.end();
+		RenderInstance.pool.freeAll(instances);
+		instances.clear();
+		camera = null;
+	}
+
+	/** Add an instance to render, the shader property of the instance will be overwritten by this method */
+	protected void addInstance(final RenderInstance instance, final Shader shader) {
+		instance.shader = listener.getShader(instance, shader);
+		instance.renderable.mesh.setAutoBind(false);
+		instances.add(instance);
+	}
+	
+	public void addModelPart(final Renderable renderable, final Matrix4 transform, final float distance, final Light[] lights, final Shader shader) {
+		addInstance(RenderInstance.pool.obtain(renderable, transform, distance, lights, null), shader);
+	}
+	
+	public void addModel(final NewModel model, final Matrix4 transform) {
+		addModel(model, transform, null, null);
+	}
+	
+	public void addModel(final NewModel model, final Matrix4 transform, final Light[] lights) {
+		addModel(model, transform, lights, null);
+	}
+	
+	public void addModel(final NewModel model, final Matrix4 transform, final Light[] lights, final Shader shader) {
+		transform.getTranslation(Vector3.tmp);
+		float dist = Vector3.tmp2.set(Vector3.tmp.x - camera.position.x, Vector3.tmp.y - camera.position.y , Vector3.tmp.z - camera.position.z).len();
+		if (Vector3.tmp2.div(dist).dot(camera.direction) < 0)
+			dist = -dist;
+		Iterable<Renderable> parts = model.getParts(dist);
+		if (instances != null)
+			for (Renderable part : parts)
+				addModelPart(part, transform, dist, lights, null);
+	}
+	
+	
+	// Old methods:
+	
+	/*public void addMesh (final SubMesh mesh, final Matrix4 transform) {
+		addInstance(subMesh2Instance(instancePool.obtain(), mesh, transform, camera));
+	}
+	
+	public void addMesh (final SubMesh mesh, final Matrix4 transform, float distance) {
+		addInstance(subMesh2Instance(instancePool.obtain(), mesh, transform, distance));
+	}*/
+
+	/*public void addModel(final Model model, final Matrix4 transform) {
+		SubMesh[] meshes = model.getSubMeshes();
+		for (int i = 0; i < meshes.length; i++)
+			addMesh(meshes[i], transform);
+	}
+	
+	public void addModel(final Model model, final Matrix4 transform, float distance) {
+		SubMesh[] meshes = model.getSubMeshes();
+		for (int i = 0; i < meshes.length; i++)
+			addMesh(meshes[i], transform, distance);		
+	}*/
+	
+	/*public static RenderInstance subMesh2Instance(final RenderInstance instance, final SubMesh mesh, final Matrix4 transform, final Camera camera) {
+		transform.getTranslation(Vector3.tmp);
+		float dist = Vector3.tmp2.set(Vector3.tmp.x - camera.position.x, Vector3.tmp.y - camera.position.y , Vector3.tmp.z - camera.position.z).len();
+		if (Vector3.tmp2.div(dist).dot(camera.direction) < 0)
+			dist = -dist;
+		return subMesh2Instance(instance, mesh, transform, dist);
+	}
+	
+	public static RenderInstance subMesh2Instance(final RenderInstance instance, final SubMesh mesh, final Matrix4 transform, final float distance) {
+		instance.distance = distance;
+		instance.material = InterimModel.convertMaterial(mesh.material);
+		instance.mesh = mesh.mesh;
+		instance.meshPartOffset = 0;
+		instance.meshPartSize = mesh.mesh.getMaxIndices() > 0 ? mesh.mesh.getNumIndices() : mesh.mesh.getNumVertices();
+		instance.primitiveType = mesh.primitiveType;
+		instance.transform = transform;
+		instance.shader = null;
+		return instance;
+	}*/
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/RenderBatchAdapter.java b/gdx/src/com/badlogic/gdx/graphics/g3d/RenderBatchAdapter.java
new file mode 100644
index 0000000..250c554
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/RenderBatchAdapter.java
@@ -0,0 +1,42 @@
+package com.badlogic.gdx.graphics.g3d;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.g3d.materials.BlendingAttribute;
+import com.badlogic.gdx.graphics.g3d.materials.NewMaterial;
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+import com.badlogic.gdx.graphics.g3d.test.TestShader;
+import com.badlogic.gdx.graphics.g3d.utils.ExclusiveTextures;
+import com.badlogic.gdx.utils.Array;
+
+public class RenderBatchAdapter implements RenderBatchListener {
+	protected Array<Shader> shaders = new Array<Shader>();
+		
+	@Override
+	public int compare (final RenderInstance o1, final RenderInstance o2) {
+		final boolean b1 = o1.renderable.material.has(BlendingAttribute.Type);
+		final boolean b2 = o2.renderable.material.has(BlendingAttribute.Type);
+		if (b1 != b2) 
+			return b1 ? 1 : -1;
+		final int result = (o1.shader == o2.shader) ? 0 : o1.shader.compareTo(o2.shader);
+		return result != 0 ? result : o1.shader.compare(o1, o2);
+	}
+
+	@Override
+	public Shader getShader (final RenderInstance instance, final Shader suggestedShader) {
+		if (suggestedShader != null && suggestedShader.canRender(instance))
+			return suggestedShader;
+		for (int i = 0; i < shaders.size; i++) {
+			final Shader shader = shaders.get(i);
+			if (shader.canRender(instance))
+				return shader;
+		}
+		final Shader result = createShader(instance.renderable.material);
+		shaders.add(result);
+		return result;
+	}
+	
+	protected Shader createShader(final NewMaterial material) {
+		Gdx.app.log("test", "Creating new shader");
+		return new TestShader(material);
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/RenderBatchListener.java b/gdx/src/com/badlogic/gdx/graphics/g3d/RenderBatchListener.java
new file mode 100644
index 0000000..6e4986b
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/RenderBatchListener.java
@@ -0,0 +1,9 @@
+package com.badlogic.gdx.graphics.g3d;
+
+import java.util.Comparator;
+
+public interface RenderBatchListener extends Comparator<RenderInstance> {
+	/** Returns the shader to be used for this instance. If the suggestedShader isn't null the preferred action is to return
+	 * that shader, but the implementation can choose to return another shader. */
+	Shader getShader(RenderInstance instance, Shader suggestedShader);
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/RenderContext.java b/gdx/src/com/badlogic/gdx/graphics/g3d/RenderContext.java
new file mode 100644
index 0000000..bd50a14
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/RenderContext.java
@@ -0,0 +1,60 @@
+package com.badlogic.gdx.graphics.g3d;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.GL10;
+import com.badlogic.gdx.graphics.g3d.utils.ExclusiveTextures;
+
+public class RenderContext {
+	public final ExclusiveTextures textures;
+	
+	private boolean blending;
+	private int blendSFactor;
+	private int blendDFactor;
+	private boolean depthTest;
+	private int depthFunc;
+	
+	public RenderContext(ExclusiveTextures textures) {
+		this.textures = textures;
+	}
+	
+	public final void begin() {
+		Gdx.gl.glDisable(GL10.GL_DEPTH_TEST);
+		depthTest = false;
+		Gdx.gl.glDisable(GL10.GL_BLEND);
+		blending = false;
+		blendSFactor = blendDFactor = depthFunc = 0;
+	}
+	
+	public final void end() {
+		
+	}
+	
+	public final void setDepthTest(final boolean enabled, final int depthFunction) {
+		if (enabled != depthTest) {
+			depthTest = enabled;
+			if (enabled)
+				Gdx.gl.glEnable(GL10.GL_DEPTH_TEST);
+			else
+				Gdx.gl.glDisable(GL10.GL_DEPTH_TEST);
+		}
+		if (enabled && depthFunc != depthFunction) {
+			Gdx.gl.glDepthFunc(depthFunction);
+			depthFunc = depthFunction;
+		}
+	}
+	
+	public final void setBlending(final boolean enabled, final int sFactor, final int dFactor) {
+		if (enabled != blending) {
+			blending = enabled;
+			if (enabled)
+				Gdx.gl.glEnable(GL10.GL_BLEND);
+			else
+				Gdx.gl.glDisable(GL10.GL_BLEND);
+		}
+		if (enabled && (blendSFactor != sFactor || blendDFactor != dFactor)) {
+			Gdx.gl.glBlendFunc(sFactor, dFactor);
+			blendSFactor = sFactor;
+			blendDFactor = dFactor;
+		}
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/RenderInstance.java b/gdx/src/com/badlogic/gdx/graphics/g3d/RenderInstance.java
new file mode 100644
index 0000000..857a09e
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/RenderInstance.java
@@ -0,0 +1,36 @@
+package com.badlogic.gdx.graphics.g3d;
+
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.g3d.materials.NewMaterial;
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+import com.badlogic.gdx.graphics.g3d.test.Light;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.badlogic.gdx.math.Matrix4;
+import com.badlogic.gdx.utils.Pool;
+
+public class RenderInstance {
+	public Renderable renderable;
+	public Matrix4 transform;
+	public float distance;
+	public Shader shader;
+	public Light[] lights;
+	
+	public final static class RenderInstancePool extends Pool<RenderInstance> {
+		@Override
+		protected final RenderInstance newObject () {
+			return new RenderInstance();
+		}
+		
+		public final RenderInstance obtain(final Renderable renderable, final Matrix4 transform, final float distance, final Light[] lights, final Shader shader) {
+			final RenderInstance result = obtain();
+			result.renderable = renderable;
+			result.transform = transform;
+			result.distance = distance;
+			result.lights = lights;
+			result.shader = shader;
+			return result;
+		}
+	};
+	
+	public final static RenderInstancePool pool = new RenderInstancePool(); 
+}
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/Renderable.java b/gdx/src/com/badlogic/gdx/graphics/g3d/Renderable.java
new file mode 100644
index 0000000..7620b98
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/Renderable.java
@@ -0,0 +1,12 @@
+package com.badlogic.gdx.graphics.g3d;
+
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.g3d.materials.NewMaterial;
+
+public class Renderable {
+	public Mesh mesh;
+	public int meshPartOffset;
+	public int meshPartSize;
+	public int primitiveType;
+	public NewMaterial material;
+}
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/Shader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/Shader.java
new file mode 100644
index 0000000..19398da
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/Shader.java
@@ -0,0 +1,19 @@
+package com.badlogic.gdx.graphics.g3d;
+
+import java.util.Comparator;
+
+import com.badlogic.gdx.graphics.Camera;
+import com.badlogic.gdx.graphics.g3d.materials.NewMaterial;
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+import com.badlogic.gdx.graphics.g3d.test.Light;
+import com.badlogic.gdx.graphics.g3d.test.NewModel;
+import com.badlogic.gdx.math.Matrix4;
+
+public interface Shader extends Comparator<RenderInstance> {
+	int compareTo(Shader other); // TODO: probably better to add some weight value to sort on
+	boolean canRender(RenderInstance instance);
+	void begin(Camera camera, RenderContext context);
+	void render(final RenderInstance instance);
+	void render(final NewModel model, final Matrix4 transform, final Light[] lights);
+	void end();
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/StillModelInstance.java b/gdx/src/com/badlogic/gdx/graphics/g3d/StillModelInstance.java
deleted file mode 100644
index 8901436..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/StillModelInstance.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d;
-
-import com.badlogic.gdx.graphics.g3d.materials.Material;
-import com.badlogic.gdx.math.Matrix4;
-import com.badlogic.gdx.math.Vector3;
-
-public interface StillModelInstance {
-	public Matrix4 getTransform ();
-
-	public Vector3 getSortCenter ();
-
-	public float getBoundingSphereRadius ();
-
-	public Material[] getMaterials ();
-
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/StillModelNode.java b/gdx/src/com/badlogic/gdx/graphics/g3d/StillModelNode.java
deleted file mode 100644
index 3ec9ac7..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/StillModelNode.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d;
-
-import com.badlogic.gdx.graphics.g3d.materials.Material;
-import com.badlogic.gdx.math.Matrix4;
-import com.badlogic.gdx.math.Vector3;
-
-public class StillModelNode implements StillModelInstance {
-	static final private float[] vec3 = {0, 0, 0};
-
-	final public Vector3 origin = new Vector3();
-	final public Vector3 transformedPosition = new Vector3();
-
-	final public Matrix4 matrix = new Matrix4();
-	public Material[] materials;
-	public float radius;
-
-	public StillModelNode () {
-		this(null);
-	}
-
-	public StillModelNode (Material[] materials) {
-		this.materials = materials;
-	}
-
-	@Override
-	public Matrix4 getTransform () {
-		return matrix;
-	}
-
-	@Override
-	public Vector3 getSortCenter () {
-		vec3[0] = origin.x;
-		vec3[1] = origin.y;
-		vec3[2] = origin.z;
-		Matrix4.mulVec(matrix.val, vec3);
-		transformedPosition.x = vec3[0];
-		transformedPosition.y = vec3[1];
-		transformedPosition.z = vec3[2];
-		return transformedPosition;
-	}
-
-	@Override
-	public Material[] getMaterials () {
-		return materials;
-	}
-
-	@Override
-	public float getBoundingSphereRadius () {
-		return radius;
-	}
-
-	public StillModelNode copy () {
-		final StillModelNode copy = new StillModelNode();
-		if (materials != null) {
-			final int len = materials.length;
-			Material[] mats = new Material[len];
-			for (int i = 0; i < len; i++) {
-				mats[i] = materials[i].copy();
-			}
-			copy.materials = mats;
-		}
-		copy.matrix.set(matrix.val);
-		copy.origin.set(origin);
-		copy.radius = radius;
-		copy.transformedPosition.set(transformedPosition);
-		return copy;
-
-	}
-
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loader/JsonModelLoader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loader/JsonModelLoader.java
new file mode 100644
index 0000000..ffd74df
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/loader/JsonModelLoader.java
@@ -0,0 +1,415 @@
+package com.badlogic.gdx.graphics.g3d.loader;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.files.FileHandle;
+import com.badlogic.gdx.graphics.Color;
+import com.badlogic.gdx.graphics.GL10;
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.Texture.TextureFilter;
+import com.badlogic.gdx.graphics.VertexAttribute;
+import com.badlogic.gdx.graphics.g3d.model.ModelMaterial;
+import com.badlogic.gdx.graphics.g3d.model.ModelMesh;
+import com.badlogic.gdx.graphics.g3d.model.ModelMeshPart;
+import com.badlogic.gdx.graphics.g3d.model.ModelMeshPartMaterial;
+import com.badlogic.gdx.graphics.g3d.model.JsonModel;
+import com.badlogic.gdx.graphics.g3d.model.ModelNode;
+import com.badlogic.gdx.graphics.g3d.model.ModelTexture;
+import com.badlogic.gdx.graphics.g3d.model.ModelMaterial.MaterialType;
+import com.badlogic.gdx.graphics.g3d.old.ModelLoaderHints;
+import com.badlogic.gdx.graphics.g3d.old.loaders.ModelLoader;
+import com.badlogic.gdx.graphics.g3d.old.materials.ColorAttribute;
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+import com.badlogic.gdx.graphics.g3d.old.materials.TextureAttribute;
+import com.badlogic.gdx.graphics.g3d.old.model.Model;
+import com.badlogic.gdx.graphics.g3d.old.model.SubMesh;
+import com.badlogic.gdx.graphics.g3d.old.model.skeleton.SkeletonModel;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillSubMesh;
+import com.badlogic.gdx.math.Vector2;
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+import com.badlogic.gdx.utils.JsonReader;
+import com.badlogic.gdx.utils.ObjectMap;
+import com.badlogic.gdx.utils.OrderedMap;
+
+/**
+ * {@link ModelLoader} for the JSON format written by the 
+ * <a href="https://github.com/libgdx/fbx-conv">fbx-conv</a> tool.
+ * 
+ * @author mzechner
+ *
+ */
+public class JsonModelLoader implements ModelLoader {
+	public static String VERSION = "1.0";
+	
+	@Override
+	public Model load (FileHandle handle, ModelLoaderHints hints) {
+		JsonModel jsonModel = parseModel(handle, hints);
+		Model model = null;
+		
+		if(jsonModel.animations == null)
+			model = createStillModel(jsonModel);
+		else // add hints for sampling to keyframed model
+			model = createSkeletonModel(jsonModel);
+		
+		return model;
+	}
+
+	private SkeletonModel createSkeletonModel (JsonModel jsonModel) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	private StillModel createStillModel (JsonModel model) {
+		StillModel stillModel = new StillModel(new SubMesh[model.meshes.length]);
+		
+		// We create the materials first
+		ObjectMap<String, Material> materials = new ObjectMap<String, Material>();
+		for(int i=0; i<model.materials.length; i++){
+			ModelMaterial jsonMaterial = model.materials[i];
+			Material material = new Material(jsonMaterial.id);
+			
+			// simple loader for now. Just diffuse & textures
+			material.addAttribute(new ColorAttribute(jsonMaterial.diffuse, "diffuse"));
+
+			if(jsonMaterial.diffuseTextures != null){
+				ModelTexture jsonTexture = jsonMaterial.diffuseTextures.get(0);
+				
+				// one texture unit for now
+				Texture texture = new Texture(Gdx.files.internal(jsonTexture.fileName));
+				texture.setFilter(TextureFilter.Linear, TextureFilter.Linear);
+				material.addAttribute(new TextureAttribute(texture, 0, "diffuseTexture"));
+			}
+			
+			materials.put(jsonMaterial.id, material);
+		}
+		
+		// Create the meshes and assign materials to them. This is a super hack until we have hierarchy
+		for(int i=0; i<model.meshes.length; i++){
+			ModelMesh jsonMesh = model.meshes[i];
+			// if we have more than one submesh we're screwed for now.
+			ModelMeshPart jsonMeshPart = model.meshes[i].parts[0];
+			
+			Mesh mesh = new Mesh(false, jsonMesh.vertices.length, jsonMeshPart.indices.length, jsonMesh.attributes);
+			mesh.setIndices(jsonMeshPart.indices);
+			mesh.setVertices(jsonMesh.vertices);
+			
+			StillSubMesh subMesh = new StillSubMesh(jsonMesh.id, mesh, jsonMeshPart.primitiveType);
+			// Just assumes i material. We need the node tree to work this properly
+			subMesh.material = materials.get(model.materials[i].id);
+			stillModel.subMeshes[i] = subMesh;
+		}
+		
+		return stillModel;
+	}
+
+	public JsonModel parseModel (FileHandle handle, ModelLoaderHints hints) {
+		JsonReader reader = new JsonReader();
+		OrderedMap<String, Object> json = (OrderedMap<String, Object>)reader.parse(handle);
+		
+		String version = (String)json.get("version");
+		if(version == null || !version.equals(VERSION)) {
+			throw new GdxRuntimeException("No or wrong JSON format version given, should be " + VERSION + ", is " + version);
+		}
+		
+		JsonModel model = new JsonModel();
+		parseMeshes(model, json, hints);
+		parseMaterials(model, json, hints, handle.parent().path());
+		parseNodes(model, json, hints);
+		return model;
+	}
+	
+	private void parseMeshes (JsonModel model, OrderedMap<String, Object> json, ModelLoaderHints hints) {
+		Array<OrderedMap<String, Object>> meshes = (Array<OrderedMap<String, Object>>)json.get("meshes");
+		if(meshes == null) {
+			throw new GdxRuntimeException("No meshes found in file");
+		}
+		
+		model.meshes = new ModelMesh[meshes.size];
+		int i = 0;
+		for(OrderedMap<String, Object> mesh: meshes) {
+			ModelMesh jsonMesh = new ModelMesh();
+			String id = (String)mesh.get("id");
+			if(id == null) {
+				throw new GdxRuntimeException("No id given for mesh");
+			}
+			jsonMesh.id = id;
+			
+			Array<Object> attributes = (Array<Object>)mesh.get("attributes");
+			if(attributes == null) {
+				throw new GdxRuntimeException("No vertex attributes given for mesh '" + id + "'");
+			}
+			jsonMesh.attributes = parseAttributes(attributes);
+			
+			Array<Object> vertices = (Array<Object>)mesh.get("vertices");
+			if(vertices == null) {
+				throw new GdxRuntimeException("No vertices given for mesh '" + id + "'");
+			}
+			float[] verts = new float[vertices.size];
+			int idx = 0;
+			for(Object v: vertices) {
+				verts[idx++] = (Float)v;
+			}
+			jsonMesh.vertices = verts;
+			
+			Array<OrderedMap<String, Object>> meshParts = (Array<OrderedMap<String, Object>>)mesh.get("parts");
+			if(meshParts == null) {
+				throw new GdxRuntimeException("No mesh parts given for mesh '" + id + "'");
+			}
+			Array<ModelMeshPart> parts = new Array<ModelMeshPart>();
+			for(OrderedMap<String, Object> meshPart: meshParts) {
+				ModelMeshPart jsonPart = new ModelMeshPart();
+				String partId = (String)meshPart.get("id");
+				if(id == null) {
+					throw new GdxRuntimeException("Not id given for mesh part");
+				}
+				for(ModelMeshPart other: parts) {
+					if(other.id.equals(partId)) {
+						throw new GdxRuntimeException("Mesh part with id '" + partId + "' already in defined");
+					}
+				}
+				jsonPart.id = partId;
+				
+				String type = (String)meshPart.get("type");
+				if(type == null) {
+					throw new GdxRuntimeException("No primitive type given for mesh part '" + partId + "'");
+				}
+				jsonPart.primitiveType = parseType(type);
+				
+				Array<Object> indices = (Array<Object>)meshPart.get("indices");
+				if(indices == null) {
+					throw new GdxRuntimeException("No indices given for mesh part '" + partId + "'");
+				}
+				short[] partIndices = new short[indices.size];
+				idx = 0;
+				for(Object index: indices) {
+					partIndices[idx++] = (short)(float)(Float)index;
+				}
+				jsonPart.indices = partIndices;
+				parts.add(jsonPart);
+			}
+			jsonMesh.parts = parts.toArray(ModelMeshPart.class);
+			model.meshes[i++] = jsonMesh;
+		}
+	}
+	
+	private int parseType (String type) {
+		if(type.equals("TRIANGLES")) {
+			return GL10.GL_TRIANGLES;
+		} else if(type.equals("LINES")) {
+			return GL10.GL_LINES;
+		} else if(type.equals("POINTS")) {
+			return GL10.GL_POINTS;
+		} else if(type.equals("TRIANGLE_STRIP")) {
+			return GL10.GL_TRIANGLE_STRIP;
+		} else if(type.equals("LINE_STRIP")) {
+			return GL10.GL_LINE_STRIP;
+		} /* Gameplay encoder doesn't read out line loop
+			else if(type.equals("lineloop")) {
+			return GL10.GL_LINE_LOOP; 
+		} */
+			else { 
+			throw new GdxRuntimeException("Unknown primitive type '" + type + "', should be one of triangle, trianglestrip, line, linestrip, lineloop or point");
+		}
+	}
+
+	private VertexAttribute[] parseAttributes (Array<Object> attributes) {
+		Array<VertexAttribute> vertexAttributes = new Array<VertexAttribute>();
+		int unit = 0;
+		for(Object attribute: attributes) {
+			String attr = (String)attribute;
+			if(attr.equals("POSITION")) {
+				vertexAttributes.add(VertexAttribute.Position());
+			} else if(attr.equals("NORMAL")) {
+				vertexAttributes.add(VertexAttribute.Normal());
+			} else if(attr.startsWith("TEXCOORD")) {
+				vertexAttributes.add(VertexAttribute.TexCoords(unit++));
+			} else if(attr.equals("TANGENT")) {
+				vertexAttributes.add(VertexAttribute.Tangent());
+			} else if(attr.equals("BINORMAL")) {
+				vertexAttributes.add(VertexAttribute.Binormal());
+			} else if(attr.equals("BLENDINDICES")) {
+				vertexAttributes.add(VertexAttribute.BoneIds(4));
+			} else if(attr.equals("BLENDWEIGHTS")) {
+				vertexAttributes.add(VertexAttribute.BoneWeights(4));
+			} else if(attr.equals("COLOR")) {
+				vertexAttributes.add(VertexAttribute.Color());
+			} else {
+				throw new GdxRuntimeException("Unknown vertex attribuet '" + attr + "', should be one of position, normal, uv, tangent or binormal");
+			}
+		}
+		return vertexAttributes.toArray(VertexAttribute.class);
+	}
+
+	private void parseMaterials (JsonModel model, OrderedMap<String, Object> json, ModelLoaderHints hints, String materialDir) {
+		Array<OrderedMap<String, Object>> materials = (Array<OrderedMap<String, Object>>)json.get("materials");
+		if(materials == null) {
+			// we should probably create some default material in this case
+		}
+		else {
+			model.materials = new ModelMaterial[materials.size];
+			
+			int i = 0;
+			for(OrderedMap<String, Object> material: materials) {
+				ModelMaterial jsonMaterial = new ModelMaterial();
+				
+				String id = (String)material.get("id");
+				if(id == null)
+					throw new GdxRuntimeException("Material needs an id.");
+				
+				jsonMaterial.id = id;
+				
+				// Read type
+				String type = (String)material.get("type");
+				if(type == null)
+					throw new GdxRuntimeException("Material needs a type. Lambert|Phong");
+				
+				jsonMaterial.type = type.equals("PHONG") ? MaterialType.Phong : MaterialType.Lambert;
+				
+				// Read material colors
+				jsonMaterial.diffuse = parseColor((Array<Object>)material.get("diffuse"), Color.WHITE);
+				jsonMaterial.ambient = parseColor((Array<Object>)material.get("ambient"), Color.BLACK);
+				jsonMaterial.emissive = parseColor((Array<Object>)material.get("emissive"), Color.WHITE);
+				
+				if(jsonMaterial.type == MaterialType.Phong){
+				   // Read specular
+					jsonMaterial.specular = parseColor((Array<Object>)material.get("specular"), Color.WHITE);
+					
+					// Read shininess
+					float shininess = (Float)material.get("shininess", 1.0f);
+				}
+				
+				// Read textures
+				Array<OrderedMap<String, Object>> textures = (Array<OrderedMap<String, Object>>)material.get("textures");
+				if(textures != null){
+					for(OrderedMap<String, Object> texture : textures) {
+						ModelTexture jsonTexture = new ModelTexture();
+						
+						String textureId = (String)texture.get("id");
+						if(textureId == null)
+							throw new GdxRuntimeException("Texture has no id.");
+						jsonTexture.id = textureId;
+						
+						String fileName = (String)texture.get("filename");
+						if(fileName == null)
+							throw new GdxRuntimeException("Texture needs filename.");
+						jsonTexture.fileName = materialDir + "/" + fileName;
+						
+						jsonTexture.uvTranslation = readVector2((Array<Object>)texture.get("uvTranslation"), 0f, 0f);
+						jsonTexture.uvScaling = readVector2((Array<Object>)texture.get("uvScaling"), 1f, 1f);
+						
+						String textureType = (String)texture.get("type");
+						if(type == null)
+							throw new GdxRuntimeException("Texture needs type.");
+						
+						/* Only diffuse textures for now. Most programs don't export texture usage properly ..
+						 	So we probably need to find a workaround. */
+						if(textureType.equals("STANDARD")){
+							if(jsonMaterial.diffuseTextures == null)
+								jsonMaterial.diffuseTextures = new Array<ModelTexture>();
+							jsonMaterial.diffuseTextures.add(jsonTexture);
+						}
+					}
+				}
+
+				model.materials[i++] = jsonMaterial;
+			}
+		}
+	}
+
+	private Color parseColor (Array<Object> colorArray, Color defaultColor) {
+		if(colorArray == null) {
+			return defaultColor;
+		}
+		else if(colorArray.size == 3)
+			return new Color((Float)colorArray.get(0), (Float)colorArray.get(1), (Float)colorArray.get(2), 1.0f);
+		else
+			throw new GdxRuntimeException("Expected Color values <> than three.");
+	}
+
+	private Vector2 readVector2 (Array<Object> vectorArray, float x, float y) {
+		if(vectorArray == null)
+			return new Vector2(x, y);
+		else if(vectorArray.size == 2)
+			return new Vector2((Float)vectorArray.get(0), (Float)vectorArray.get(1));
+		else
+			throw new GdxRuntimeException("Expected Vector2 values <> than two.");
+	}
+
+	private ModelNode[] parseNodes (JsonModel model, OrderedMap<String, Object> json, ModelLoaderHints hints) {
+		Array<OrderedMap<String, Object>> nodes = (Array<OrderedMap<String, Object>>)json.get("nodes");
+		if(nodes == null) {
+			throw new GdxRuntimeException("At least one node is required.");
+		}
+		
+		model.nodes = new ModelNode[nodes.size];
+		
+		int i = 0;
+		for(OrderedMap<String, Object> node : nodes) {
+			model.nodes[i++] = parseNodesRecursively(node, hints);
+		}
+		return model.nodes;
+	}
+	
+	private ModelNode parseNodesRecursively(OrderedMap<String, Object> json, ModelLoaderHints hints){
+		ModelNode jsonNode = new ModelNode();
+		
+		String id = (String)json.get("id");
+		if(id == null)
+			throw new GdxRuntimeException("Node id missing.");
+		jsonNode.id = id;
+		
+		Array<Object> translation = (Array<Object>)json.get("translation");
+		if(translation == null || translation.size != 3)
+			throw new GdxRuntimeException("Node translation missing or incomplete");
+		jsonNode.translation = new Vector3((Float)translation.get(0), (Float)translation.get(1), (Float)translation.get(2));
+		
+		Array<Object> rotation = (Array<Object>)json.get("rotation");
+		if(rotation == null || rotation.size != 3)
+			throw new GdxRuntimeException("Node rotation missing or incomplete");
+		jsonNode.rotation = new Vector3((Float)rotation.get(0), (Float)rotation.get(1), (Float)rotation.get(2));
+		
+		Array<Object> scale = (Array<Object>)json.get("scale");
+		if(scale == null || scale.size != 3)
+			throw new GdxRuntimeException("Node scale missing or incomplete");
+		jsonNode.scale = new Vector3((Float)scale.get(0), (Float)scale.get(1), (Float)scale.get(2));
+		
+		String meshId = (String)json.get("mesh");
+		if(meshId != null)
+			jsonNode.meshId = meshId;
+		
+		Array<OrderedMap<String, Object>> materials = (Array<OrderedMap<String, Object>>)json.get("materials");
+		if(materials != null){
+			jsonNode.meshPartMaterials = new ModelMeshPartMaterial[materials.size];
+			
+			int i = 0;
+			for(OrderedMap<String, Object> material : materials) {
+				ModelMeshPartMaterial meshPartMaterial = new ModelMeshPartMaterial();
+				
+				String meshPartId = (String)material.get("meshpartid");
+				String materialId = (String)material.get("materialid");
+				if(meshPartId == null || materialId == null){
+					throw new GdxRuntimeException("Node material is missing meshPartId or materialId");
+				}
+				meshPartMaterial.materialId = materialId;
+				meshPartMaterial.meshPartId = meshPartId;
+				
+				jsonNode.meshPartMaterials[i++] = meshPartMaterial;
+			}
+		}
+		
+		Array<OrderedMap<String, Object>> children = (Array<OrderedMap<String, Object>>)json.get("children");
+		if(children != null){
+			jsonNode.children = new ModelNode[children.size];
+			
+			int i = 0;
+			for(OrderedMap<String, Object> child : children) {
+				jsonNode.children[i++] = parseNodesRecursively(child, hints);
+			}
+		}
+		
+		return jsonNode;
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/KeyframedModelLoader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/KeyframedModelLoader.java
deleted file mode 100644
index 7694d35..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/KeyframedModelLoader.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.loaders;
-
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.g3d.ModelLoaderHints;
-import com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedModel;
-
-/** Interface for classes loading {@link KeyframedModel} instances.
- * @author mzechner */
-public interface KeyframedModelLoader extends ModelLoader {
-	public KeyframedModel load (FileHandle handle, ModelLoaderHints hints);
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/ModelLoader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/ModelLoader.java
deleted file mode 100644
index cd9bdd0..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/ModelLoader.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.loaders;
-
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.g3d.ModelLoaderHints;
-import com.badlogic.gdx.graphics.g3d.model.Model;
-
-/** Interface for all loaders. Loaders that need more files need to derrive the other file names by the given file. A bit of a
- * hack, but most formats are self contained.
- * 
- * @author mzechner */
-public interface ModelLoader {
-	public Model load (FileHandle file, ModelLoaderHints hints);
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/ModelLoaderRegistry.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/ModelLoaderRegistry.java
deleted file mode 100644
index 594742d..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/ModelLoaderRegistry.java
+++ /dev/null
@@ -1,390 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.loaders;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.g3d.ModelLoaderHints;
-import com.badlogic.gdx.graphics.g3d.loaders.g3d.G3dLoader.G3dKeyframedModelLoader;
-import com.badlogic.gdx.graphics.g3d.loaders.g3d.G3dLoader.G3dStillModelLoader;
-import com.badlogic.gdx.graphics.g3d.loaders.g3d.G3dLoader.G3dSkeletonModelLoader;
-import com.badlogic.gdx.graphics.g3d.loaders.g3d.G3dtLoader.G3dtKeyframedModelLoader;
-import com.badlogic.gdx.graphics.g3d.loaders.g3d.G3dtLoader.G3dtStillModelLoader;
-import com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Loader;
-import com.badlogic.gdx.graphics.g3d.loaders.md2.MD2Loader.MD2LoaderHints;
-import com.badlogic.gdx.graphics.g3d.loaders.wavefront.ObjLoader;
-import com.badlogic.gdx.graphics.g3d.model.Model;
-import com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedModel;
-import com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonModel;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
-import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-
-/** Simple "pluggable" class for loading models. Keeps a list of {@link ModelLoader} instances on a per file suffix basis. Use one
- * of the static methods to load a {@link Model}. The registry will then try out all the registered loaders for that extension and
- * eventually return a Model or throw a {@link GdxRuntimeException}.
- * 
- * @author mzechner */
-public class ModelLoaderRegistry {
-	private static Map<String, Array<ModelLoader>> loaders = new HashMap<String, Array<ModelLoader>>();
-	private static Map<String, Array<ModelLoaderHints>> defaultHints = new HashMap<String, Array<ModelLoaderHints>>();
-
-	// registering the default loaders here
-	static {
-		/* TODO: Move/Drop support
-		registerLoader("dae", new ColladaLoader(), new ModelLoaderHints(false));
-		registerLoader("dae", new ColladaLoaderSkeleton(), new ModelLoaderHints(false));
-		*/
-		registerLoader("obj", new ObjLoader(), new ModelLoaderHints(false));
-		registerLoader("md2", new MD2Loader(), new MD2LoaderHints(0.2f));
-		registerLoader("g3dt", new G3dtStillModelLoader(), new ModelLoaderHints(true));
-		registerLoader("g3dt", new G3dtKeyframedModelLoader(), new ModelLoaderHints(true));
-		registerLoader("g3d", new G3dStillModelLoader(), new ModelLoaderHints(false));
-		registerLoader("g3d", new G3dKeyframedModelLoader(), new ModelLoaderHints(false));
-		registerLoader("g3d", new G3dSkeletonModelLoader(), new ModelLoaderHints(false));
-		/*
-		registerLoader("ctm", new CtmModelLoader(), new ModelLoaderHints(false));
-		*/
-	}
-
-	/** Registers a new loader with the registry. The extension will be used to match the loader against a file to be loaded. The
-	 * extension will be compared case insensitive. If multiple loaders are registered per extension they will be tried on a file
-	 * in the sequence they have been registered until one succeeds or none succeed.
-	 * 
-	 * @param extension the extension string, e.g. "dae" or "obj"
-	 * @param loader the {@link ModelLoader}
-	 * @param defaultHints the default {@link ModelLoaderHints} to be used with this loader. */
-	public static void registerLoader (String extension, ModelLoader loader, ModelLoaderHints defaultHints) {
-		Array<ModelLoader> loaders = ModelLoaderRegistry.loaders.get(extension);
-		if (loaders == null) {
-			loaders = new Array<ModelLoader>();
-			ModelLoaderRegistry.loaders.put(extension.toLowerCase(), loaders);
-		}
-		loaders.add(loader);
-
-		Array<ModelLoaderHints> hints = ModelLoaderRegistry.defaultHints.get(extension);
-		if (hints == null) {
-			hints = new Array<ModelLoaderHints>();
-			ModelLoaderRegistry.defaultHints.put(extension.toLowerCase(), hints);
-		}
-		hints.add(defaultHints);
-	}
-
-	/** Loads the specified file with one of the loaders registered with this ModelLoaderRegistry. Uses the extension to determine
-	 * which loader to use. The comparison of extensions is done case insensitive.
-	 * @param file the file to be loaded
-	 * @return the {@link Model}
-	 * @throws GdxRuntimeException in case the model could not be loaded. */
-	public static Model load (FileHandle file) {
-		String name = file.name();
-		int dotIndex = name.lastIndexOf('.');
-		if (dotIndex == -1)
-			throw new GdxRuntimeException("file '" + file.name()
-				+ "' does not have an extension that can be matched to a ModelLoader");
-		String extension = name.substring(dotIndex + 1).toLowerCase();
-
-		Array<ModelLoader> loaders = ModelLoaderRegistry.loaders.get(extension);
-		Array<ModelLoaderHints> hints = ModelLoaderRegistry.defaultHints.get(extension);
-		if (loaders == null) throw new GdxRuntimeException("no loaders for extension '" + extension + "'");
-		if (hints == null) throw new GdxRuntimeException("no default hints for extension '" + extension + "'");
-
-		Model model = null;
-		StringBuilder errors = new StringBuilder();
-		for (int i = 0; i < loaders.size; i++) {
-			ModelLoader loader = loaders.get(i);
-			ModelLoaderHints hint = hints.get(i);
-			try {
-				model = loader.load(file, hint);
-			} catch (GdxRuntimeException e) {
-				errors.append("Couldn't load '" + file.name() + "' with loader of type " + loader.getClass().getName() + ": "
-					+ e.getMessage() + "\n");
-			}
-		}
-
-		if (model == null)
-			throw new GdxRuntimeException(errors.toString());
-		else
-			return model;
-	}
-
-	/** Loads the specified file with one of the loaders registered with this ModelLoaderRegistry. Uses the extension to determine
-	 * which loader to use. The comparison of extensions is done case insensitive.
-	 * @param file the file to be loaded
-	 * @param hints the {@link ModelLoaderHints} to use
-	 * @return the {@link Model}
-	 * @throws GdxRuntimeException in case the model could not be loaded. */
-	public static Model load (FileHandle file, ModelLoaderHints hints) {
-		String name = file.name();
-		int dotIndex = name.lastIndexOf('.');
-		if (dotIndex == -1)
-			throw new GdxRuntimeException("file '" + file.name()
-				+ "' does not have an extension that can be matched to a ModelLoader");
-		String extension = name.substring(dotIndex + 1).toLowerCase();
-
-		Array<ModelLoader> loaders = ModelLoaderRegistry.loaders.get(extension);
-		if (loaders == null) throw new GdxRuntimeException("no loaders for extension '" + extension + "'");
-
-		Model model = null;
-		StringBuilder errors = new StringBuilder();
-		for (int i = 0; i < loaders.size; i++) {
-			ModelLoader loader = loaders.get(i);
-			try {
-				model = loader.load(file, hints);
-			} catch (GdxRuntimeException e) {
-				errors.append("Couldn't load '" + file.name() + "' with loader of type " + loader.getClass().getName() + ": "
-					+ e.getMessage() + "\n");
-			}
-		}
-
-		if (model == null)
-			throw new GdxRuntimeException(errors.toString());
-		else
-			return model;
-	}
-
-	/** Loads the specified file with one of the loaders registered with this ModelLoaderRegistry. Uses the extension to determine
-	 * which loader to use. The comparison of extensions is done case insensitive. Uses only {@link StillModelLoader} instances.
-	 * @param file the file to be loaded
-	 * @return the {@link Model}
-	 * @throws GdxRuntimeException in case the model could not be loaded. */
-	public static StillModel loadStillModel (FileHandle file) {
-		String name = file.name();
-		int dotIndex = name.lastIndexOf('.');
-		if (dotIndex == -1)
-			throw new GdxRuntimeException("file '" + file.name()
-				+ "' does not have an extension that can be matched to a ModelLoader");
-		String extension = name.substring(dotIndex + 1).toLowerCase();
-
-		Array<ModelLoader> loaders = ModelLoaderRegistry.loaders.get(extension);
-		Array<ModelLoaderHints> hints = ModelLoaderRegistry.defaultHints.get(extension);
-		if (loaders == null) throw new GdxRuntimeException("no loaders for extension '" + extension + "'");
-		if (hints == null) throw new GdxRuntimeException("no default hints for extension '" + extension + "'");
-
-		StillModel model = null;
-		StringBuilder errors = new StringBuilder();
-		for (int i = 0; i < loaders.size; i++) {
-			ModelLoader loader = loaders.get(i);
-			ModelLoaderHints hint = hints.get(i);
-			try {
-				if (loader instanceof StillModelLoader) {
-					model = ((StillModelLoader)loader).load(file, hint);
-				}
-			} catch (GdxRuntimeException e) {
-				errors.append("Couldn't load '" + file.name() + "' with loader of type " + loader.getClass().getName() + ": "
-					+ e.getMessage() + "\n");
-			}
-		}
-
-		if (model == null)
-			throw new GdxRuntimeException("Couldn't load model '" + file.name() + "', " + errors.toString());
-		else
-			return model;
-	}
-
-	/** Loads the specified file with one of the loaders registered with this ModelLoaderRegistry. Uses the extension to determine
-	 * which loader to use. The comparison of extensions is done case insensitive. Uses only {@link StillModelLoader} instances.
-	 * @param file the file to be loaded
-	 * @param hints the ModelLoaderHints to be used.
-	 * @return the {@link Model}
-	 * @throws GdxRuntimeException in case the model could not be loaded. */
-	public static StillModel loadStillModel (FileHandle file, ModelLoaderHints hints) {
-		String name = file.name();
-		int dotIndex = name.lastIndexOf('.');
-		if (dotIndex == -1)
-			throw new GdxRuntimeException("file '" + file.name()
-				+ "' does not have an extension that can be matched to a ModelLoader");
-		String extension = name.substring(dotIndex + 1).toLowerCase();
-
-		Array<ModelLoader> loaders = ModelLoaderRegistry.loaders.get(extension);
-		if (loaders == null) throw new GdxRuntimeException("no loaders for extension '" + extension + "'");
-
-		StillModel model = null;
-		StringBuilder errors = new StringBuilder();
-		for (int i = 0; i < loaders.size; i++) {
-			ModelLoader loader = loaders.get(i);
-			try {
-				if (loader instanceof StillModelLoader) {
-					model = ((StillModelLoader)loader).load(file, hints);
-				}
-			} catch (GdxRuntimeException e) {
-				errors.append("Couldn't load '" + file.name() + "' with loader of type " + loader.getClass().getName() + ": "
-					+ e.getMessage() + "\n");
-			}
-		}
-
-		if (model == null)
-			throw new GdxRuntimeException("Couldn't load model '" + file.name() + "', " + errors.toString());
-		else
-			return model;
-	}
-
-	/** Loads the specified file with one of the loaders registered with this ModelLoaderRegistry. Uses the extension to determine
-	 * which loader to use. The comparison of extensions is done case insensitive. Uses only {@link KeyframedModelLoader}
-	 * instances.
-	 * @param file the file to be loaded
-	 * @return the {@link Model}
-	 * @throws GdxRuntimeException in case the model could not be loaded. */
-	public static KeyframedModel loadKeyframedModel (FileHandle file) {
-		String name = file.name();
-		int dotIndex = name.lastIndexOf('.');
-		if (dotIndex == -1)
-			throw new GdxRuntimeException("file '" + file.name()
-				+ "' does not have an extension that can be matched to a ModelLoader");
-		String extension = name.substring(dotIndex + 1).toLowerCase();
-
-		Array<ModelLoader> loaders = ModelLoaderRegistry.loaders.get(extension);
-		Array<ModelLoaderHints> hints = ModelLoaderRegistry.defaultHints.get(extension);
-		if (loaders == null) throw new GdxRuntimeException("no loaders for extension '" + extension + "'");
-		if (hints == null) throw new GdxRuntimeException("no default hints for extension '" + extension + "'");
-
-		KeyframedModel model = null;
-		StringBuilder errors = new StringBuilder();
-		for (int i = 0; i < loaders.size; i++) {
-			ModelLoader loader = loaders.get(i);
-			ModelLoaderHints hint = hints.get(i);
-			try {
-				if (loader instanceof KeyframedModelLoader) {
-					model = ((KeyframedModelLoader)loader).load(file, hint);
-				}
-			} catch (GdxRuntimeException e) {
-				errors.append("Couldn't load '" + file.name() + "' with loader of type " + loader.getClass().getName() + ": "
-					+ e.getMessage() + "\n");
-			}
-		}
-
-		if (model == null)
-			throw new GdxRuntimeException(errors.toString());
-		else
-			return model;
-	}
-
-	/** Loads the specified file with one of the loaders registered with this ModelLoaderRegistry. Uses the extension to determine
-	 * which loader to use. The comparison of extensions is done case insensitive. Uses only {@link KeyframedModelLoader}
-	 * instances.
-	 * @param file the file to be loaded
-	 * @param hints the Model
-	 * @return the {@link Model}
-	 * @throws GdxRuntimeException in case the model could not be loaded. */
-	public static KeyframedModel loadKeyframedModel (FileHandle file, ModelLoaderHints hints) {
-		String name = file.name();
-		int dotIndex = name.lastIndexOf('.');
-		if (dotIndex == -1)
-			throw new GdxRuntimeException("file '" + file.name()
-				+ "' does not have an extension that can be matched to a ModelLoader");
-		String extension = name.substring(dotIndex + 1).toLowerCase();
-
-		Array<ModelLoader> loaders = ModelLoaderRegistry.loaders.get(extension);
-		if (loaders == null) throw new GdxRuntimeException("no loaders for extension '" + extension + "'");
-
-		KeyframedModel model = null;
-		StringBuilder errors = new StringBuilder();
-		for (int i = 0; i < loaders.size; i++) {
-			ModelLoader loader = loaders.get(i);
-			try {
-				if (loader instanceof KeyframedModelLoader) {
-					model = ((KeyframedModelLoader)loader).load(file, hints);
-				}
-			} catch (GdxRuntimeException e) {
-				errors.append("Couldn't load '" + file.name() + "' with loader of type " + loader.getClass().getName() + ": "
-					+ e.getMessage() + "\n");
-			}
-		}
-
-		if (model == null)
-			throw new GdxRuntimeException(errors.toString());
-		else
-			return model;
-	}
-
-	/** Loads the specified file with one of the loaders registered with this ModelLoaderRegistry. Uses the extension to determine
-	 * which loader to use. The comparison of extensions is done case insensitive. Uses only {@link SkeletonModelLoader} instances.
-	 * @param file the file to be loaded
-	 * @return the {@link Model}
-	 * @throws GdxRuntimeException in case the model could not be loaded. */
-	public static SkeletonModel loadSkeletonModel (FileHandle file) {
-		String name = file.name();
-		int dotIndex = name.lastIndexOf('.');
-		if (dotIndex == -1)
-			throw new GdxRuntimeException("file '" + file.name()
-				+ "' does not have an extension that can be matched to a ModelLoader");
-		String extension = name.substring(dotIndex + 1).toLowerCase();
-
-		Array<ModelLoader> loaders = ModelLoaderRegistry.loaders.get(extension);
-		Array<ModelLoaderHints> hints = ModelLoaderRegistry.defaultHints.get(extension);
-		if (loaders == null) throw new GdxRuntimeException("no loaders for extension '" + extension + "'");
-		if (hints == null) throw new GdxRuntimeException("no default hints for extension '" + extension + "'");
-
-		SkeletonModel model = null;
-		StringBuilder errors = new StringBuilder();
-		for (int i = 0; i < loaders.size; i++) {
-			ModelLoader loader = loaders.get(i);
-			ModelLoaderHints hint = hints.get(i);
-			try {
-				if (loader instanceof SkeletonModelLoader) {
-					model = ((SkeletonModelLoader)loader).load(file, hint);
-				}
-			} catch (GdxRuntimeException e) {
-				errors.append("Couldn't load '" + file.name() + "' with loader of type " + loader.getClass().getName() + ": "
-					+ e.getMessage());
-			}
-		}
-
-		if (model == null)
-			throw new GdxRuntimeException(errors.toString());
-		else
-			return model;
-	}
-
-	/** Loads the specified file with one of the loaders registered with this ModelLoaderRegistry. Uses the extension to determine
-	 * which loader to use. The comparison of extensions is done case insensitive. Uses only {@link SkeletonModelLoader} instances.
-	 * @param file the file to be loaded
-	 * @param hints the ModelLoaderHints to use
-	 * @return the {@link Model}
-	 * @throws GdxRuntimeException in case the model could not be loaded. */
-	public static SkeletonModel loadSkeletonModel (FileHandle file, ModelLoaderHints hints) {
-		String name = file.name();
-		int dotIndex = name.lastIndexOf('.');
-		if (dotIndex == -1)
-			throw new GdxRuntimeException("file '" + file.name()
-				+ "' does not have an extension that can be matched to a ModelLoader");
-		String extension = name.substring(dotIndex + 1).toLowerCase();
-
-		Array<ModelLoader> loaders = ModelLoaderRegistry.loaders.get(extension);
-		if (loaders == null) throw new GdxRuntimeException("no loaders for extension '" + extension + "'");
-
-		SkeletonModel model = null;
-		StringBuilder errors = new StringBuilder();
-		for (int i = 0; i < loaders.size; i++) {
-			ModelLoader loader = loaders.get(i);
-			try {
-				if (loader instanceof SkeletonModelLoader) {
-					model = ((SkeletonModelLoader)loader).load(file, hints);
-				}
-			} catch (GdxRuntimeException e) {
-				errors.append("Couldn't load '" + file.name() + "' with loader of type " + loader.getClass().getName() + ": "
-					+ e.getMessage());
-			}
-		}
-
-		if (model == null)
-			throw new GdxRuntimeException(errors.toString());
-		else
-			return model;
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/SkeletonModelLoader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/SkeletonModelLoader.java
deleted file mode 100644
index 802df58..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/SkeletonModelLoader.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.loaders;
-
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.g3d.ModelLoaderHints;
-import com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonModel;
-
-/** Interface for classes loading {@link SkeletonModel} instances.
- * @author mzechner */
-public interface SkeletonModelLoader extends ModelLoader {
-	public SkeletonModel load (FileHandle file, ModelLoaderHints hints);
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/StillModelLoader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/StillModelLoader.java
deleted file mode 100644
index 68452a0..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/StillModelLoader.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.loaders;
-
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.g3d.ModelLoaderHints;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
-
-/** Interface for loaders loading {@link StillModel} instances.
- * @author mzechner */
-public interface StillModelLoader extends ModelLoader {
-	public StillModel load (FileHandle handle, ModelLoaderHints hints);
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/g3d/G3dConstants.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/g3d/G3dConstants.java
deleted file mode 100644
index 11c5f87..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/g3d/G3dConstants.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.loaders.g3d;
-
-public class G3dConstants {
-	// Version info for file format
-	public static final byte MAJOR_VERSION = 0;
-	public static final byte MINOR_VERSION = 1;
-
-	// Unique IDs for chunk declarations
-	public static final int G3D_ROOT = 0x4733441A;
-	public static final int VERSION_INFO = 0x0001;
-
-	// still model specific constants
-	public static final int STILL_MODEL = 0x1000;
-	public static final int STILL_SUBMESH = 0x1100;
-
-	// keyframed model specific constants
-	public static final int KEYFRAMED_MODEL = 0x2000;
-	public static final int KEYFRAMED_SUBMESH = 0x2200;
-	public static final int KEYFRAMED_ANIMATION = 0x2300;
-	public static final int KEYFRAMED_FRAME = 0x2400;
-	
-	// skeleton model specific constants
-	public static final int SKELETON_MODEL = 0x4000;
-	public static final int SKELETON_SUBMESH = 0x4200;
-	public static final int SKELETON_ANIMATIONS = 0x4300;
-	public static final int SKELETON_ANIMATION = 0x4400;
-	public static final int SKELETON = 0x4500;
-	public static final int SKELETON_HIERARCHY = 0x4600;
-	public static final int SKELETON_JOINT = 0x4700;
-	public static final int SKELETON_KEYFRAME = 0x4800;
-
-	// constants used for all types of models, mostly to describe a mesh
-	public static final int VERTEX_LIST = 0x1110;
-	public static final int INDEX_LIST = 0x1111;
-	public static final int VERTEX_ATTRIBUTES = 0x1120;
-	public static final int VERTEX_ATTRIBUTE = 0x1121;
-	public static final int BONE_WEIGHTS = 0x1130;
-	public static final int BONE_WEIGHT = 0x1131;
-	public static final int BONE_ASSIGNMENTS = 0x1140;
-	public static final int BONE_ASSIGNMENT = 0x1141;
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/g3d/G3dLoader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/g3d/G3dLoader.java
deleted file mode 100644
index 7c66f14..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/g3d/G3dLoader.java
+++ /dev/null
@@ -1,448 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.loaders.g3d;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.Mesh;
-import com.badlogic.gdx.graphics.Mesh.VertexDataType;
-import com.badlogic.gdx.graphics.VertexAttribute;
-import com.badlogic.gdx.graphics.g3d.ModelLoaderHints;
-import com.badlogic.gdx.graphics.g3d.loaders.KeyframedModelLoader;
-import com.badlogic.gdx.graphics.g3d.loaders.SkeletonModelLoader;
-import com.badlogic.gdx.graphics.g3d.loaders.StillModelLoader;
-import com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.ChunkReader;
-import com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks.ChunkReader.Chunk;
-import com.badlogic.gdx.graphics.g3d.materials.Material;
-import com.badlogic.gdx.graphics.g3d.model.keyframe.Keyframe;
-import com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedAnimation;
-import com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedModel;
-import com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedSubMesh;
-import com.badlogic.gdx.graphics.g3d.model.skeleton.Skeleton;
-import com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonAnimation;
-import com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonJoint;
-import com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonKeyframe;
-import com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonModel;
-import com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonSubMesh;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
-import com.badlogic.gdx.graphics.g3d.model.still.StillSubMesh;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-import com.badlogic.gdx.utils.ObjectMap;
-
-public class G3dLoader {
-	public static StillModel loadStillModel (FileHandle handle) {
-		Chunk root = null;
-		InputStream in = null;
-		try {
-			in = handle.read();
-			root = ChunkReader.readChunks(in);
-
-			// check root tag
-			if (root.getId() != G3dConstants.G3D_ROOT) throw new GdxRuntimeException("Invalid root tag id: " + root.getId());
-
-			// check version
-			Chunk version = root.getChild(G3dConstants.VERSION_INFO);
-			if (version == null) throw new GdxRuntimeException("No version chunk found");
-			int major = version.readByte();
-			int minor = version.readByte();
-			if (major != 0 || minor != 1)
-				throw new GdxRuntimeException("Invalid version, required 0.1, got " + major + "." + minor);
-
-			// read stillmodel
-			Chunk stillModel = root.getChild(G3dConstants.STILL_MODEL);
-			if (stillModel == null) throw new GdxRuntimeException("No stillmodel chunk found");
-			int numSubMeshes = stillModel.readInt();
-
-			// read submeshes
-			StillSubMesh[] meshes = new StillSubMesh[numSubMeshes];
-			Chunk[] meshChunks = stillModel.getChildren(G3dConstants.STILL_SUBMESH);
-			if (meshChunks.length != numSubMeshes)
-				throw new GdxRuntimeException("Number of submeshes not equal to number specified in still model chunk, expected "
-					+ numSubMeshes + ", got " + meshChunks.length);
-			for (int i = 0; i < numSubMeshes; i++) {
-				// read submesh name and primitive type
-				Chunk subMesh = meshChunks[i];
-				String name = subMesh.readString();
-				int primitiveType = subMesh.readInt();
-
-				// read attributes
-				Chunk attributes = subMesh.getChild(G3dConstants.VERTEX_ATTRIBUTES);
-				if (attributes == null) throw new GdxRuntimeException("No vertex attribute chunk given");
-				int numAttributes = attributes.readInt();
-				Chunk[] attributeChunks = attributes.getChildren(G3dConstants.VERTEX_ATTRIBUTE);
-				if (attributeChunks.length != numAttributes)
-					new GdxRuntimeException("Number of attributes not equal to number specified in attributes chunk, expected "
-						+ numAttributes + ", got " + attributeChunks.length);
-				VertexAttribute[] vertAttribs = new VertexAttribute[numAttributes];
-				for (int j = 0; j < numAttributes; j++) {
-					vertAttribs[j] = new VertexAttribute(attributeChunks[j].readInt(), attributeChunks[j].readInt(),
-						attributeChunks[j].readString());
-				}
-
-				// read vertices
-				Chunk vertices = subMesh.getChild(G3dConstants.VERTEX_LIST);
-				int numVertices = vertices.readInt();
-				float[] vertexData = vertices.readFloats();
-
-				// read indices
-				Chunk indices = subMesh.getChild(G3dConstants.INDEX_LIST);
-				int numIndices = indices.readInt();
-				short[] indexData = indices.readShorts();
-
-				StillSubMesh mesh = new StillSubMesh(name, new Mesh(true, numVertices, numIndices, vertAttribs), primitiveType);
-				mesh.mesh.setVertices(vertexData);
-				mesh.mesh.setIndices(indexData);
-				mesh.material = new Material("default");
-				meshes[i] = mesh;
-			}
-
-			StillModel model = new StillModel(meshes);
-			model.setMaterial(new Material("default"));
-			return model;
-		} catch (IOException e) {
-			throw new GdxRuntimeException("Couldn't load still model from '" + handle.name() + "', " + e.getMessage(), e);
-		} finally {
-			if (in != null) try {
-				in.close();
-			} catch (IOException e) {
-			}
-		}
-	}
-
-	public static KeyframedModel loadKeyframedModel (FileHandle handle) {
-		Chunk root = null;
-		InputStream in = null;
-		try {
-			in = handle.read();
-			root = ChunkReader.readChunks(in);
-
-			// check root tag
-			if (root.getId() != G3dConstants.G3D_ROOT) throw new GdxRuntimeException("Invalid root tag id: " + root.getId());
-
-			// check version
-			Chunk version = root.getChild(G3dConstants.VERSION_INFO);
-			if (version == null) throw new GdxRuntimeException("No version chunk found");
-			int major = version.readByte();
-			int minor = version.readByte();
-			if (major != 0 || minor != 1)
-				throw new GdxRuntimeException("Invalid version, required 0.1, got " + major + "." + minor);
-
-			// read keyframed model
-			Chunk stillModel = root.getChild(G3dConstants.KEYFRAMED_MODEL);
-			if (stillModel == null) throw new GdxRuntimeException("No stillmodel chunk found");
-			int numSubMeshes = stillModel.readInt();
-
-			// read submeshes
-			KeyframedSubMesh[] meshes = new KeyframedSubMesh[numSubMeshes];
-			Chunk[] meshChunks = stillModel.getChildren(G3dConstants.KEYFRAMED_SUBMESH);
-			if (meshChunks.length != numSubMeshes)
-				throw new GdxRuntimeException("Number of submeshes not equal to number specified in still model chunk, expected "
-					+ numSubMeshes + ", got " + meshChunks.length);
-			for (int i = 0; i < numSubMeshes; i++) {
-				// read submesh name and primitive type
-				Chunk subMesh = meshChunks[i];
-				String meshName = subMesh.readString();
-				int primitiveType = subMesh.readInt();
-				int animatedComponents = subMesh.readInt();
-				int numAnimations = subMesh.readInt();
-
-				// read attributes
-				Chunk attributes = subMesh.getChild(G3dConstants.VERTEX_ATTRIBUTES);
-				if (attributes == null) throw new GdxRuntimeException("No vertex attribute chunk given");
-				int numAttributes = attributes.readInt();
-				Chunk[] attributeChunks = attributes.getChildren(G3dConstants.VERTEX_ATTRIBUTE);
-				if (attributeChunks.length != numAttributes)
-					new GdxRuntimeException("Number of attributes not equal to number specified in attributes chunk, expected "
-						+ numAttributes + ", got " + attributeChunks.length);
-				VertexAttribute[] vertAttribs = new VertexAttribute[numAttributes];
-				for (int j = 0; j < numAttributes; j++) {
-					vertAttribs[j] = new VertexAttribute(attributeChunks[j].readInt(), attributeChunks[j].readInt(),
-						attributeChunks[j].readString());
-				}
-
-				// read static components, sort of like a bind pose mesh
-				Chunk vertices = subMesh.getChild(G3dConstants.VERTEX_LIST);
-				int numVertices = vertices.readInt();
-				float[] vertexData = vertices.readFloats();
-
-				// read indices
-				Chunk indices = subMesh.getChild(G3dConstants.INDEX_LIST);
-				int numIndices = indices.readInt();
-				short[] indexData = indices.readShorts();
-
-				// read animations
-				ObjectMap<String, KeyframedAnimation> animations = new ObjectMap<String, KeyframedAnimation>();
-				Chunk[] animationChunks = subMesh.getChildren(G3dConstants.KEYFRAMED_ANIMATION);
-				if (numAnimations != animationChunks.length)
-					throw new GdxRuntimeException(
-						"number of keyframed animations not equal to number specified in keyframed submesh chunk, was "
-							+ animationChunks.length + ", expected " + numAnimations);
-				for (int j = 0; j < numAnimations; j++) {
-					Chunk animationChunk = animationChunks[j];
-					String animationName = animationChunk.readString();
-					float frameDuration = animationChunk.readFloat();
-
-					// read keyframes
-					int numKeyframes = animationChunk.readInt();
-					Keyframe[] keyframes = new Keyframe[numKeyframes];
-					Chunk[] keyframeChunks = animationChunk.getChildren(G3dConstants.KEYFRAMED_FRAME);
-					if (numKeyframes != keyframeChunks.length)
-						throw new GdxRuntimeException("number of keyframes not equal to number specified in keyframed animation, was "
-							+ keyframeChunks.length + ", expected " + numKeyframes);
-					for (int k = 0; k < numKeyframes; k++) {
-						Chunk keyframeChunk = keyframeChunks[k];
-						float timeStamp = keyframeChunk.readFloat();
-						float[] keyframeVertices = keyframeChunk.readFloats();
-
-						keyframes[k] = new Keyframe(timeStamp, keyframeVertices);
-					}
-
-					animations.put(animationName, new KeyframedAnimation(animationName, frameDuration, keyframes));
-				}
-
-				Mesh mesh = new Mesh(VertexDataType.VertexArray, false, numVertices, numIndices, vertAttribs);
-				meshes[i] = new KeyframedSubMesh(meshName, mesh, vertexData, animations, animatedComponents, primitiveType);
-				mesh.setVertices(vertexData);
-				mesh.setIndices(indexData);
-			}
-
-			KeyframedModel model = new KeyframedModel(meshes);
-			model.setMaterial(new Material("default"));
-			return model;
-		} catch (IOException e) {
-			throw new GdxRuntimeException("Couldn't load still model from '" + handle.name() + "', " + e.getMessage(), e);
-		} finally {
-			if (in != null) try {
-				in.close();
-			} catch (IOException e) {
-			}
-		}
-	}
-	
-	public static SkeletonModel loadSkeletonModel (FileHandle handle) {
-		Chunk root = null;
-		InputStream in = null;
-		try {
-			in = handle.read();
-			root = ChunkReader.readChunks(in);
-
-			// check root tag
-			if (root.getId() != G3dConstants.G3D_ROOT) throw new GdxRuntimeException("Invalid root tag id: " + root.getId());
-
-			// check version
-			Chunk version = root.getChild(G3dConstants.VERSION_INFO);
-			if (version == null) throw new GdxRuntimeException("No version chunk found");
-			int major = version.readByte();
-			int minor = version.readByte();
-			if (major != 0 || minor != 1)
-				throw new GdxRuntimeException("Invalid version, required 0.1, got " + major + "." + minor);
-
-			// read skeleton model
-			Chunk skeletonModel = root.getChild(G3dConstants.SKELETON_MODEL);
-			if (skeletonModel == null) throw new GdxRuntimeException("No skeletonModel chunk found");
-			int numSubMeshes = skeletonModel.readInt();
-
-			// read submeshes
-			SkeletonSubMesh[] meshes = new SkeletonSubMesh[numSubMeshes];
-			Chunk[] meshChunks = skeletonModel.getChildren(G3dConstants.SKELETON_SUBMESH);
-			if (meshChunks.length != numSubMeshes)
-				throw new GdxRuntimeException("Number of submeshes not equal to number specified in still model chunk, expected "
-					+ numSubMeshes + ", got " + meshChunks.length);
-			for (int i = 0; i < numSubMeshes; i++) {
-				Chunk subMeshChunk = meshChunks[i];
-				
-				// read attributes
-				Chunk attributes = subMeshChunk.getChild(G3dConstants.VERTEX_ATTRIBUTES);
-				if (attributes == null) throw new GdxRuntimeException("No vertex attribute chunk given");
-				int numAttributes = attributes.readInt();
-				Chunk[] attributeChunks = attributes.getChildren(G3dConstants.VERTEX_ATTRIBUTE);
-				if (attributeChunks.length != numAttributes)
-					new GdxRuntimeException("Number of attributes not equal to number specified in attributes chunk, expected "
-						+ numAttributes + ", got " + attributeChunks.length);
-				VertexAttribute[] vertAttribs = new VertexAttribute[numAttributes];
-				for (int j = 0; j < numAttributes; j++) {
-					vertAttribs[j] = new VertexAttribute(attributeChunks[j].readInt(), attributeChunks[j].readInt(),
-						attributeChunks[j].readString());
-				}
-
-				// read static components, sort of like a bind pose mesh
-				Chunk vertices = subMeshChunk.getChild(G3dConstants.VERTEX_LIST);
-				int numVertices = vertices.readInt();
-				float[] meshVertices = vertices.readFloats();
-
-				// read indices
-				Chunk indices = subMeshChunk.getChild(G3dConstants.INDEX_LIST);
-				int numIndices = indices.readInt();
-				short[] meshIndices = indices.readShorts();
-				
-				//read bone weight
-				Chunk boneWeights = subMeshChunk.getChild(G3dConstants.BONE_WEIGHTS);
-				int numBonesWeights = boneWeights.readInt();
-				Chunk[] boneWeightChunks = boneWeights.getChildren(G3dConstants.BONE_WEIGHT);
-				if (attributeChunks.length != numAttributes)
-					new GdxRuntimeException("Number of bone weights not equal to number specified in bone weights chunk, expected "
-						+ numBonesWeights + ", got " + boneWeightChunks.length);
-				float[][] meshBoneWeights = new float[numBonesWeights][];
-				for(int j=0;j<numBonesWeights;j++) {
-					int count = boneWeightChunks[j].readInt();
-					meshBoneWeights[j] = boneWeightChunks[j].readFloats();
-				}
-
-				//read bone assignment
-				Chunk boneAssignments = subMeshChunk.getChild(G3dConstants.BONE_ASSIGNMENTS);
-				int numBoneAssignments = boneAssignments.readInt();
-				Chunk[] boneAssignmentChunks = boneAssignments.getChildren(G3dConstants.BONE_ASSIGNMENT);
-				if (boneAssignmentChunks.length != numBoneAssignments)
-					new GdxRuntimeException("Number of bone assignment not equal to number specified in bone assignment chunk, expected "
-						+ numBoneAssignments + ", got " + boneAssignmentChunks.length);
-				int[][] meshBoneAssignments = new int[numBoneAssignments][];
-				for(int j=0;j<numBoneAssignments;j++) {
-					int count = boneAssignmentChunks[j].readInt();
-					meshBoneAssignments[j] = boneAssignmentChunks[j].readInts();
-				}
-				
-				SkeletonSubMesh subMesh = new SkeletonSubMesh(subMeshChunk.readString(), new Mesh(false, numVertices, numIndices, vertAttribs),
-					subMeshChunk.readInt());
-				
-				subMesh.indices = meshIndices;
-				subMesh.boneAssignments = meshBoneAssignments;
-				subMesh.boneWeights = meshBoneWeights;
-				subMesh.vertices = meshVertices;
-				
-				subMesh.mesh.setVertices(subMesh.vertices);
-				subMesh.mesh.setIndices(subMesh.indices);
-				subMesh.skinnedVertices = new float[subMesh.vertices.length];
-				System.arraycopy(subMesh.vertices, 0, subMesh.skinnedVertices, 0, subMesh.vertices.length);
-				meshes[i] = subMesh;
-			}
-			
-			//read Skeleton hierarchy
-			Skeleton skeleton = new Skeleton();
-			Chunk skeletonChunk = skeletonModel.getChild(G3dConstants.SKELETON);
-			{
-				// read Skeleton hierarchy
-				Chunk hierarchy = skeletonChunk.getChild(G3dConstants.SKELETON_HIERARCHY);
-				int numHierarchyJoints = hierarchy.readInt();
-				for(int i=0;i<numHierarchyJoints;i++) {
-					skeleton.hierarchy.add(readSkeletonJoint(hierarchy));
-				}
-				
-				
-				// read Skeleton animations
-				Chunk animations = skeletonChunk.getChild(G3dConstants.SKELETON_ANIMATIONS);
-				int numAnimations = animations.readInt();
-				Chunk[] animationChunks = animations.getChildren(G3dConstants.SKELETON_ANIMATION);
-				if (animationChunks.length != numAnimations)
-					new GdxRuntimeException("Number of animations not equal to number specified in animations chunk, expected "
-						+ numAnimations + ", got " + animationChunks.length);
-				for(int i=0;i<numAnimations; i++) {
-					Chunk animation = animationChunks[i];
-
-					String name = animation.readString();
-					float totalDuration = animation.readFloat();
-					
-					int numJoints = animation.readInt();
-					SkeletonKeyframe perJointKeyFrames[][] = new SkeletonKeyframe[numJoints][];
-					for(int j=0;j<numJoints;j++){
-						int numFrames = animation.readInt();
-						perJointKeyFrames[j] = new SkeletonKeyframe[numFrames];
-						
-						for(int k=0;k<numFrames;k++){
-							SkeletonKeyframe frame = new SkeletonKeyframe();
-
-							frame.timeStamp = animation.readFloat();
-							frame.parentIndex = animation.readInt();
-							frame.position.x = animation.readFloat();
-							frame.position.y = animation.readFloat();
-							frame.position.z = animation.readFloat();
-							frame.rotation.w = animation.readFloat();
-							frame.rotation.x = animation.readFloat();
-							frame.rotation.y = animation.readFloat();
-							frame.rotation.z = animation.readFloat();
-							frame.scale.x = animation.readFloat();
-							frame.scale.y = animation.readFloat();
-							frame.scale.z = animation.readFloat();
-							perJointKeyFrames[j][k] = frame;
-						}
-					}
-					
-					skeleton.animations.put(name, new SkeletonAnimation(name, totalDuration, perJointKeyFrames));
-				}
-			}
-			skeleton.buildFromHierarchy();
-
-			SkeletonModel model = new SkeletonModel(skeleton, meshes);
-			model.setMaterial(new Material("default"));
-			return model;
-		} catch (IOException e) {
-			throw new GdxRuntimeException("Couldn't load skeleton model from '" + handle.name() + "', " + e.getMessage(), e);
-		} finally {
-			if (in != null) try {
-				in.close();
-			} catch (IOException e) {
-			}
-		}
-	}
-	
-	private static SkeletonJoint readSkeletonJoint(Chunk jointChunk) {
-		SkeletonJoint joint = new SkeletonJoint();
-		
-		joint.name = jointChunk.readString();
-		joint.position.x = jointChunk.readFloat();
-		joint.position.y = jointChunk.readFloat();
-		joint.position.z = jointChunk.readFloat();
-		joint.rotation.w = jointChunk.readFloat();
-		joint.rotation.x = jointChunk.readFloat();
-		joint.rotation.y = jointChunk.readFloat();
-		joint.rotation.z = jointChunk.readFloat();
-		joint.scale.x = jointChunk.readFloat();
-		joint.scale.y = jointChunk.readFloat();
-		joint.scale.z = jointChunk.readFloat();
-		
-		int count = jointChunk.readInt();
-		for(int i=0;i<count;i++) {
-			SkeletonJoint child = readSkeletonJoint(jointChunk);
-			child.parent = joint;
-			joint.children.add(child);
-		}
-		
-		return joint;
-	}
-
-	public static class G3dStillModelLoader implements StillModelLoader {
-		@Override
-		public StillModel load (FileHandle handle, ModelLoaderHints hints) {
-			return G3dLoader.loadStillModel(handle);
-		}
-	}
-
-	public static class G3dKeyframedModelLoader implements KeyframedModelLoader {
-		@Override
-		public KeyframedModel load (FileHandle handle, ModelLoaderHints hints) {
-			return G3dLoader.loadKeyframedModel(handle);
-		}
-	}
-	
-	public static class G3dSkeletonModelLoader implements SkeletonModelLoader {
-		@Override
-		public SkeletonModel load (FileHandle handle, ModelLoaderHints hints) {
-			return G3dLoader.loadSkeletonModel(handle);
-		}
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/g3d/G3dtLoader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/g3d/G3dtLoader.java
deleted file mode 100644
index 13be14d..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/g3d/G3dtLoader.java
+++ /dev/null
@@ -1,345 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.loaders.g3d;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.GL10;
-import com.badlogic.gdx.graphics.Mesh;
-import com.badlogic.gdx.graphics.Mesh.VertexDataType;
-import com.badlogic.gdx.graphics.VertexAttribute;
-import com.badlogic.gdx.graphics.VertexAttributes;
-import com.badlogic.gdx.graphics.VertexAttributes.Usage;
-import com.badlogic.gdx.graphics.g3d.ModelLoaderHints;
-import com.badlogic.gdx.graphics.g3d.loaders.KeyframedModelLoader;
-import com.badlogic.gdx.graphics.g3d.loaders.StillModelLoader;
-import com.badlogic.gdx.graphics.g3d.model.keyframe.Keyframe;
-import com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedAnimation;
-import com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedModel;
-import com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedSubMesh;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
-import com.badlogic.gdx.graphics.g3d.model.still.StillSubMesh;
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.FloatArray;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-import com.badlogic.gdx.utils.IntArray;
-import com.badlogic.gdx.utils.ObjectMap;
-
-/** Class to import the G3D text format.
- * @author mzechner */
-public class G3dtLoader {
-	public static KeyframedModel loadKeyframedModel (FileHandle handle, boolean flipV) {
-		return loadKeyframedModel(handle.read(), flipV);
-	}
-
-	public static StillModel loadStillModel (FileHandle handle, boolean flipV) {
-		return loadStillModel(handle.read(), flipV);
-	}
-
-	static int lineNum = 0;
-	static String line = null;
-
-	public static StillModel loadStillModel (InputStream stream, boolean flipV) {
-		BufferedReader in = new BufferedReader(new InputStreamReader(stream));
-
-		lineNum = 1;
-		try {
-			String version = readString(in);
-			if (!version.equals("g3dt-still-1.0")) throw new GdxRuntimeException("incorrect version");
-			int numMeshes = readInt(in);
-			StillSubMesh[] subMeshes = new StillSubMesh[numMeshes];
-			for (int i = 0; i < numMeshes; i++) {
-				subMeshes[i] = readStillSubMesh(in, flipV);
-			}
-			StillModel model = new StillModel(subMeshes);
-			return model;
-		} catch (Throwable e) {
-			throw new GdxRuntimeException("Couldn't read keyframed model, error in line " + lineNum + ", '" + line + "' : "
-				+ e.getMessage(), e);
-		}
-	}
-
-	private static StillSubMesh readStillSubMesh (BufferedReader in, boolean flipV) throws IOException {
-		String name = readString(in);
-		IntArray indices = readFaces(in);
-		int numVertices = readInt(in);
-		int numAttributes = readInt(in);
-
-		if (!readString(in).equals("position")) throw new GdxRuntimeException("first attribute must be position.");
-		int numUvs = 0;
-		boolean hasNormals = false;
-		for (int i = 1; i < numAttributes; i++) {
-			String attributeType = readString(in);
-
-			if (!attributeType.equals("normal") && !attributeType.equals("uv"))
-				throw new GdxRuntimeException("attribute name must be normal or uv");
-
-			if (attributeType.equals("normal")) {
-				if (i != 1) throw new GdxRuntimeException("attribute normal must be second attribute");
-				hasNormals = true;
-			}
-			if (attributeType.equals("uv")) {
-				numUvs++;
-			}
-		}
-		VertexAttribute[] vertexAttributes = createVertexAttributes(hasNormals, numUvs);
-		int vertexSize = new VertexAttributes(vertexAttributes).vertexSize / 4;
-		float[] vertices = new float[numVertices * vertexSize];
-		int idx = 0;
-		int uvOffset = hasNormals ? 6 : 3;
-		for (int i = 0; i < numVertices; i++) {
-			readFloatArray(in, vertices, idx);
-			if (flipV) {
-				for (int j = idx + uvOffset + 1; j < idx + uvOffset + numUvs * 2; j += 2) {
-					vertices[j] = 1 - vertices[j];
-				}
-			}
-			idx += vertexSize;
-		}
-
-		Mesh mesh = new Mesh(true, numVertices, indices.size, vertexAttributes);
-		mesh.setVertices(vertices);
-		mesh.setIndices(convertToShortArray(indices));
-		return new StillSubMesh(name, mesh, GL10.GL_TRIANGLES);
-	}
-
-	public static KeyframedModel loadKeyframedModel (InputStream stream, boolean flipV) {
-		BufferedReader in = new BufferedReader(new InputStreamReader(stream));
-
-		lineNum = 1;
-		try {
-			String version = readString(in);
-			if (!version.equals("g3dt-keyframed-1.0")) throw new GdxRuntimeException("incorrect version");
-			int numMeshes = readInt(in);
-			KeyframedSubMesh[] subMeshes = new KeyframedSubMesh[numMeshes];
-			for (int i = 0; i < numMeshes; i++) {
-				subMeshes[i] = readMesh(in, flipV);
-			}
-			KeyframedModel model = new KeyframedModel(subMeshes);
-			model.setAnimation(model.getAnimations()[0].name, 0, false);
-			return model;
-		} catch (Throwable e) {
-			throw new GdxRuntimeException("Couldn't read keyframed model, error in line " + lineNum + ", '" + line + "' : "
-				+ e.getMessage(), e);
-		}
-	}
-
-	private static KeyframedSubMesh readMesh (BufferedReader in, boolean flipV) throws IOException {
-		String name = readString(in);
-		IntArray indices = readFaces(in);
-		int numVertices = readInt(in);
-		int numAttributes = readInt(in);
-
-		if (!readString(in).equals("position")) throw new GdxRuntimeException("first attribute must be position.");
-		Array<FloatArray> uvSets = new Array<FloatArray>();
-		boolean hasNormals = false;
-		for (int i = 1; i < numAttributes; i++) {
-			String attributeType = readString(in);
-
-			if (!attributeType.equals("normal") && !attributeType.equals("uv"))
-				throw new GdxRuntimeException("attribute name must be normal or uv");
-
-			if (attributeType.equals("normal")) {
-				if (i != 1) throw new GdxRuntimeException("attribute normal must be second attribute");
-				hasNormals = true;
-			}
-			if (attributeType.equals("uv")) {
-				uvSets.add(readUVSet(in, numVertices, flipV));
-			}
-		}
-		int animatedComponents = hasNormals ? 6 : 3;
-
-		VertexAttribute[] vertexAttributes = createVertexAttributes(hasNormals, uvSets.size);
-
-		int numAnimations = readInt(in);
-		ObjectMap<String, KeyframedAnimation> animations = new ObjectMap<String, KeyframedAnimation>(numAnimations);
-		for (int i = 0; i < numAnimations; i++) {
-			String animationName = readString(in);
-			int numKeyframes = readInt(in);
-			float frameDuration = readFloat(in); // in seconds
-
-			Keyframe[] keyframes = new Keyframe[numKeyframes];
-			float time = 0;
-			FloatArray vertex = new FloatArray(animatedComponents);
-			for (int frame = 0; frame < numKeyframes; frame++) {
-				float[] vertices = new float[numVertices * (animatedComponents)];
-				int idx = 0;
-				for (int j = 0; j < numVertices; j++) {
-					idx = readFloatArray(in, vertices, idx);
-				}
-				Keyframe keyframe = new Keyframe(time, vertices);
-				keyframes[frame] = keyframe;
-				time += frameDuration;
-			}
-
-			KeyframedAnimation animation = new KeyframedAnimation(animationName, frameDuration, keyframes);
-			animations.put(animationName, animation);
-		}
-
-		KeyframedSubMesh mesh = new KeyframedSubMesh(name, new Mesh(VertexDataType.VertexArray, false, numVertices, indices.size,
-			createVertexAttributes(hasNormals, uvSets.size)), buildVertices(numVertices, hasNormals, uvSets), animations,
-			animatedComponents, GL10.GL_TRIANGLES);
-		mesh.mesh.setIndices(convertToShortArray(indices));
-		mesh.mesh.setVertices(mesh.blendedVertices);
-		return mesh;
-	}
-
-	private static float[] buildVertices (int numVertices, boolean hasNormals, Array<FloatArray> uvSets) {
-		float[] vertices = new float[numVertices * (3 + (hasNormals ? 3 : 0) + uvSets.size * 2)];
-
-		int idx = 0;
-		int idxUv = 0;
-		for (int i = 0; i < numVertices; i++) {
-			vertices[idx++] = 0;
-			vertices[idx++] = 0;
-			vertices[idx++] = 0;
-			if (hasNormals) {
-				vertices[idx++] = 0;
-				vertices[idx++] = 0;
-				vertices[idx++] = 0;
-			}
-			for (int j = 0; j < uvSets.size; j++) {
-				vertices[idx++] = uvSets.get(j).get(idxUv);
-				vertices[idx++] = uvSets.get(j).get(idxUv + 1);
-			}
-			idxUv += 2;
-		}
-		return vertices;
-	}
-
-	private static VertexAttribute[] createVertexAttributes (boolean hasNormals, int uvs) {
-		VertexAttribute[] attributes = new VertexAttribute[1 + (hasNormals ? 1 : 0) + uvs];
-		int idx = 0;
-		attributes[idx++] = new VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE);
-		if (hasNormals) attributes[idx++] = new VertexAttribute(Usage.Normal, 3, ShaderProgram.NORMAL_ATTRIBUTE);
-		for (int i = 0; i < uvs; i++) {
-			attributes[idx++] = new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + i);
-		}
-		return attributes;
-	}
-
-	private static FloatArray readUVSet (BufferedReader in, int numVertices, boolean flipV) throws IOException {
-		FloatArray uvSet = new FloatArray(numVertices * 2);
-		FloatArray uv = new FloatArray(2);
-		for (int i = 0; i < numVertices; i++) {
-			readFloatArray(in, uv);
-			uvSet.add(uv.items[0]);
-			uvSet.add(flipV ? 1 - uv.items[1] : uv.items[1]);
-		}
-		return uvSet;
-	}
-
-	private static IntArray readFaces (BufferedReader in) throws NumberFormatException, IOException {
-		int numFaces = readInt(in);
-		IntArray faceIndices = new IntArray();
-		IntArray triangles = new IntArray();
-		IntArray indices = new IntArray();
-
-		for (int face = 0; face < numFaces; face++) {
-			readIntArray(in, faceIndices);
-			int numIndices = faceIndices.get(0);
-			triangles.clear();
-			int baseIndex = faceIndices.get(1);
-			for (int i = 2; i < numIndices; i++) {
-				triangles.add(baseIndex);
-				triangles.add(faceIndices.items[i]);
-				triangles.add(faceIndices.items[i + 1]);
-			}
-			indices.addAll(triangles);
-		}
-
-		indices.shrink();
-		return indices;
-	}
-
-	private static short[] convertToShortArray (IntArray array) {
-		short[] shortArray = new short[array.size];
-		for (int i = 0; i < array.size; i++) {
-			shortArray[i] = (short)array.items[i];
-		}
-		return shortArray;
-	}
-
-	private static float readFloat (BufferedReader in) throws NumberFormatException, IOException {
-		lineNum++;
-		return Float.parseFloat(read(in).trim());
-	}
-
-	private static int readInt (BufferedReader in) throws NumberFormatException, IOException {
-		lineNum++;
-		return (int)(Math.floor(Float.parseFloat(read(in).trim())));
-	}
-
-	private static String readString (BufferedReader in) throws IOException {
-		lineNum++;
-		return read(in);
-	}
-
-	private static void readFloatArray (BufferedReader in, FloatArray array) throws IOException {
-		lineNum++;
-		String[] tokens = read(in).split(",");
-		int len = tokens.length;
-		array.clear();
-		for (int i = 0; i < len; i++) {
-			array.add(Float.parseFloat(tokens[i].trim()));
-		}
-	}
-
-	private static int readFloatArray (BufferedReader in, float[] array, int idx) throws IOException {
-		lineNum++;
-		String[] tokens = read(in).split(",");
-		int len = tokens.length;
-		for (int i = 0; i < len; i++) {
-			array[idx++] = Float.parseFloat(tokens[i].trim());
-		}
-		return idx;
-	}
-
-	private static void readIntArray (BufferedReader in, IntArray array) throws IOException {
-		String[] tokens = read(in).split(",");
-		int len = tokens.length;
-		array.clear();
-		for (int i = 0; i < len; i++) {
-			array.add(Integer.parseInt(tokens[i].trim()));
-		}
-	}
-
-	private static String read (BufferedReader in) throws IOException {
-		line = in.readLine();
-		return line;
-	}
-
-	public static class G3dtStillModelLoader implements StillModelLoader {
-
-		@Override
-		public StillModel load (FileHandle handle, ModelLoaderHints hints) {
-			return G3dtLoader.loadStillModel(handle, hints.flipV);
-		}
-	}
-
-	public static class G3dtKeyframedModelLoader implements KeyframedModelLoader {
-		@Override
-		public KeyframedModel load (FileHandle handle, ModelLoaderHints hints) {
-			return G3dtLoader.loadKeyframedModel(handle, hints.flipV);
-		}
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/g3d/chunks/ChunkReader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/g3d/chunks/ChunkReader.java
deleted file mode 100644
index 1dc8f35..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/g3d/chunks/ChunkReader.java
+++ /dev/null
@@ -1,332 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.Arrays;
-
-import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-
-import static com.badlogic.gdx.graphics.g3d.loaders.g3d.G3dConstants.*;
-
-public class ChunkReader {
-	public static class Chunk {
-		int id;
-		Chunk parent;
-		Array<Chunk> children = new Array<Chunk>();
-		ByteArrayInputStream payload;
-		byte[] payloadBytes;
-		int offset = 0;
-		CountingDataInputStream in;
-
-		protected Chunk (int id, Chunk parent, byte[] bytes, int offset, int size) throws IOException {
-			this.id = id;
-			this.parent = parent;
-			this.payload = new ByteArrayInputStream(bytes, offset, size);
-			this.payloadBytes = bytes;
-			this.offset = offset;
-			this.in = new CountingDataInputStream(payload);
-		}
-
-		public int getId () {
-			return id;
-		}
-
-		public Chunk getParent () {
-			return parent;
-		}
-
-		public Array<Chunk> getChildren () {
-			return children;
-		}
-
-		public int readByte () {
-			try {
-				return in.readByte();
-			} catch (IOException e) {
-				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
-			}
-		}
-
-		public short readShort () {
-			try {
-				return in.readShort();
-			} catch (IOException e) {
-				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
-			}
-		}
-
-		public int readInt () {
-			try {
-				return in.readInt();
-			} catch (IOException e) {
-				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
-			}
-		}
-
-		public long readLong () {
-			try {
-				return in.readLong();
-			} catch (IOException e) {
-				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
-			}
-		}
-
-		public float readFloat () {
-			try {
-				return in.readFloat();
-			} catch (IOException e) {
-				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
-			}
-		}
-
-		public double readDouble () {
-			try {
-				return in.readDouble();
-			} catch (IOException e) {
-				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
-			}
-		}
-
-		public byte[] readBytes () {
-			try {
-				int len = in.readInt();
-				byte[] v = new byte[len];
-				for (int i = 0; i < len; i++) {
-					v[i] = in.readByte();
-				}
-				return v;
-			} catch (IOException e) {
-				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
-			}
-		}
-
-		public short[] readShorts () {
-			try {
-				int len = in.readInt();
-				short[] v = new short[len];
-				for (int i = 0; i < len; i++) {
-					v[i] = in.readShort();
-				}
-				return v;
-			} catch (IOException e) {
-				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
-			}
-		}
-
-		public int[] readInts () {
-			try {
-				int len = in.readInt();
-				int[] v = new int[len];
-				for (int i = 0; i < len; i++) {
-					v[i] = in.readInt();
-				}
-				return v;
-			} catch (IOException e) {
-				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
-			}
-		}
-
-		public long[] readLongs () {
-			try {
-				int len = in.readInt();
-				long[] v = new long[len];
-				for (int i = 0; i < len; i++) {
-					v[i] = in.readLong();
-				}
-				return v;
-			} catch (IOException e) {
-				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
-			}
-		}
-
-		public float[] readFloats () {
-			try {
-				int len = in.readInt();
-				float[] v = new float[len];
-				for (int i = 0; i < len; i++) {
-					v[i] = in.readFloat();
-				}
-				return v;
-			} catch (IOException e) {
-				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
-			}
-		}
-
-		public double[] readDoubles () {
-			try {
-				int len = in.readInt();
-				double[] v = new double[len];
-				for (int i = 0; i < len; i++) {
-					v[i] = in.readDouble();
-				}
-				return v;
-			} catch (IOException e) {
-				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
-			}
-		}
-
-		public String readString () {
-			try {
-				int len = in.readInt();
-				byte[] bytes = new byte[len];
-				in.readFully(bytes);
-				return new String(bytes, "UTF-8");
-			} catch (IOException e) {
-				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
-			}
-		}
-
-		public Chunk getChild (int id) {
-			for (int i = 0; i < children.size; i++) {
-				Chunk child = children.get(i);
-				if (child.getId() == id) return child;
-			}
-			return null;
-		}
-
-		public Chunk[] getChildren (int id) {
-			Array<Chunk> meshes = new Array<Chunk>(true, 16, Chunk.class);
-			for (int i = 0; i < children.size; i++) {
-				Chunk child = children.get(i);
-				if (child.getId() == id) meshes.add(child);
-			}
-			meshes.shrink();
-			return meshes.items;
-		}
-	}
-
-	public static Chunk readChunks (InputStream in) throws IOException {
-		return loadChunks(in, 0);
-	}
-
-	private static Chunk loadChunks (InputStream in, int fileSize) throws IOException {
-		byte[] bytes = readStream(in, fileSize);
-		CountingDataInputStream din = new CountingDataInputStream(new ByteArrayInputStream(bytes));
-		return loadChunk(din, bytes);
-	}
-
-	private static Chunk loadChunk (CountingDataInputStream din, byte[] bytes) throws IOException {
-		int id = din.readInt();
-		int payloadSize = din.readInt();
-		int numChildren = din.readInt();
-		int offset = din.getReadBytes();
-		din.skipBytes(payloadSize);
-		Chunk chunk = new Chunk(id, null, bytes, offset, payloadSize);
-		for (int i = 0; i < numChildren; i++) {
-			Chunk child = loadChunk(din, bytes);
-			child.parent = chunk;
-			chunk.children.add(child);
-		}
-		return chunk;
-	}
-
-	private static byte[] readStream (InputStream in, int size) throws IOException {
-		if (size == 0) {
-			ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-			byte[] buffer = new byte[10 * 1024];
-			int readBytes = 0;
-			while ((readBytes = in.read(buffer)) != -1) {
-				bytes.write(buffer, 0, readBytes);
-			}
-			return bytes.toByteArray();
-		} else {
-			byte[] bytes = new byte[size];
-			DataInputStream din = new DataInputStream(in);
-			din.readFully(bytes);
-			return bytes;
-		}
-	}
-
-	/** Prints a textual representation of the given Chunk hierarchy
-	 * @param chunk the hierarchy root {@link Chunk} */
-	public static void printChunks (Chunk chunk) {
-		printChunks(chunk, 0);
-	}
-
-	private static void printChunks (Chunk chunk, int level) {
-		String id = null;
-		String payload = null;
-		switch (chunk.getId()) {
-		case G3D_ROOT:
-			id = "G3D_ROOT";
-			break;
-		case VERSION_INFO:
-			id = "VERSION_INFO";
-			int major = chunk.readByte();
-			int minor = chunk.readByte();
-			payload = rep("   ", level + 1) + "major: " + major + ", minor: " + minor;
-			break;
-		case STILL_MODEL:
-			id = "STILL_MODEL";
-			int subMeshes = chunk.readInt();
-			payload = rep("   ", level + 1) + "#submeshes: " + subMeshes;
-			break;
-		case STILL_SUBMESH:
-			id = "STILL_SUBMESH";
-			payload = rep("   ", level + 1) + "name: " + chunk.readString() + ", primitive type: " + chunk.readInt();
-			break;
-		case VERTEX_ATTRIBUTE:
-			id = "VERTEX_ATTRIBUTE";
-			int usage = chunk.readInt();
-			int components = chunk.readInt();
-			String name = chunk.readString();
-			payload = rep("   ", level + 1) + "usage: " + usage + ", components: " + components + ", name: " + name;
-			break;
-		case VERTEX_ATTRIBUTES:
-			id = "VERTEX_ATTRIBUTES";
-			int numAttributes = chunk.readInt();
-			payload = rep("   ", level + 1) + "#attributes: " + numAttributes;
-			break;
-		case VERTEX_LIST:
-			id = "VERTEX_LIST";
-			int numVertices = chunk.readInt();
-			float[] vertices = chunk.readFloats();
-			payload = rep("   ", level + 1) + "#vertices: " + numVertices + ": " + Arrays.toString(vertices).substring(0, 400);
-			break;
-		case INDEX_LIST:
-			id = "INDEX_LIST";
-			int numIndices = chunk.readInt();
-			short[] indices = chunk.readShorts();
-			payload = rep("   ", level + 1) + "#indices: " + numIndices + ": " + Arrays.toString(indices).substring(0, 400);
-			break;
-		default:
-			id = "unknown [" + id + "]";
-			payload = rep("   ", level + 1) + "unknown";
-			break;
-		}
-
-		System.out.println(rep("   ", level) + id + " {");
-		if (payload != null) System.out.println(payload);
-		for (Chunk child : chunk.getChildren()) {
-			printChunks(child, level + 1);
-		}
-		System.out.println(rep("   ", level) + "}");
-	}
-
-	private static String rep (String c, int n) {
-		StringBuffer buf = new StringBuffer();
-		for (int i = 0; i < n; i++)
-			buf.append(c);
-		return buf.toString();
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/g3d/chunks/ChunkWriter.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/g3d/chunks/ChunkWriter.java
deleted file mode 100644
index 4cd1c9d..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/g3d/chunks/ChunkWriter.java
+++ /dev/null
@@ -1,202 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks;
-
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-
-import com.badlogic.gdx.utils.Array;
-
-import static com.badlogic.gdx.graphics.g3d.loaders.g3d.G3dConstants.*;
-
-public class ChunkWriter {
-
-	class Chunk {
-		final int id;
-		final Chunk parent;
-		final Array<Chunk> children = new Array<Chunk>();
-		final ByteArrayOutputStream payload = new ByteArrayOutputStream();
-		final DataOutputStream out = new DataOutputStream(payload);
-
-		public Chunk (int id) {
-			this.id = id;
-			this.parent = null;
-		}
-
-		public Chunk (int id, Chunk parent) {
-			this.id = id;
-			this.parent = parent;
-		}
-	}
-
-	final Chunk root;
-	Chunk currChunk;
-
-	public ChunkWriter () {
-		root = new Chunk(G3D_ROOT);
-		currChunk = root;
-	}
-
-	public void newChunk (int id) {
-		Chunk chunk = new Chunk(id, currChunk);
-		currChunk.children.add(chunk);
-		currChunk = chunk;
-	}
-
-	public void endChunk () {
-		currChunk = currChunk.parent;
-	}
-
-	public void writeByte (int v) {
-		try {
-			currChunk.out.writeByte(v);
-		} catch (IOException e) {
-		}
-		;
-	}
-
-	public void writeShort (short v) {
-		try {
-			currChunk.out.writeShort(v);
-		} catch (IOException e) {
-		}
-		;
-	}
-
-	public void writeInt (int v) {
-		try {
-			currChunk.out.writeInt(v);
-		} catch (IOException e) {
-		}
-		;
-	}
-
-	public void writeLong (long v) {
-		try {
-			currChunk.out.writeLong(v);
-		} catch (IOException e) {
-		}
-		;
-	}
-
-	public void writeFloat (float v) {
-		try {
-			currChunk.out.writeFloat(v);
-		} catch (IOException e) {
-		}
-		;
-	}
-
-	public void writeDouble (double v) {
-		try {
-			currChunk.out.writeDouble(v);
-		} catch (IOException e) {
-		}
-		;
-	}
-
-	public void writeString (String v) {
-		try {
-			byte[] bytes = v.getBytes("UTF-8");
-			currChunk.out.writeInt(bytes.length);
-			currChunk.out.write(bytes);
-		} catch (IOException e) {
-		}
-	}
-
-	public void writeToStream (OutputStream out) throws IOException {
-		writeToStream(root, new DataOutputStream(out));
-	}
-
-	private void writeToStream (Chunk chunk, DataOutputStream out) throws IOException {
-		// write id, payload size in bytes and number of children
-		out.writeInt(chunk.id);
-		out.writeInt(chunk.payload.size());
-		out.writeInt(chunk.children.size);
-
-		// write payload
-		out.write(chunk.payload.toByteArray());
-
-		// recursively write children
-		for (int i = 0; i < chunk.children.size; i++) {
-			Chunk child = chunk.children.get(i);
-			writeToStream(child, out);
-		}
-	}
-
-	public void writeBytes (byte[] v) {
-		try {
-			currChunk.out.writeInt(v.length);
-			for (int i = 0; i < v.length; i++) {
-				currChunk.out.writeByte(v[i]);
-			}
-		} catch (IOException e) {
-		}
-	}
-
-	public void writeShorts (short[] v) {
-		try {
-			currChunk.out.writeInt(v.length);
-			for (int i = 0; i < v.length; i++) {
-				currChunk.out.writeShort(v[i]);
-			}
-		} catch (IOException e) {
-		}
-	}
-
-	public void writeInts (int[] v) {
-		try {
-			currChunk.out.writeInt(v.length);
-			for (int i = 0; i < v.length; i++) {
-				currChunk.out.writeInt(v[i]);
-			}
-		} catch (IOException e) {
-		}
-	}
-
-	public void writeLongs (long[] v) {
-		try {
-			currChunk.out.writeInt(v.length);
-			for (int i = 0; i < v.length; i++) {
-				currChunk.out.writeLong(v[i]);
-			}
-		} catch (IOException e) {
-		}
-	}
-
-	public void writeFloats (float[] v) {
-		try {
-			currChunk.out.writeInt(v.length);
-			for (int i = 0; i < v.length; i++) {
-				currChunk.out.writeFloat(v[i]);
-			}
-		} catch (IOException e) {
-		}
-	}
-
-	public void writeDoubles (double[] v) {
-		try {
-			currChunk.out.writeInt(v.length);
-			for (int i = 0; i < v.length; i++) {
-				currChunk.out.writeDouble(v[i]);
-			}
-		} catch (IOException e) {
-		}
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/g3d/chunks/CountingDataInputStream.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/g3d/chunks/CountingDataInputStream.java
deleted file mode 100644
index eed79e3..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/g3d/chunks/CountingDataInputStream.java
+++ /dev/null
@@ -1,124 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks;
-
-import java.io.DataInput;
-import java.io.DataInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-
-public class CountingDataInputStream implements DataInput {
-	int readBytes = 0;
-	DataInputStream in;
-
-	public CountingDataInputStream (InputStream in) {
-		this.in = new DataInputStream(in);
-	}
-
-	public int getReadBytes () {
-		return readBytes;
-	}
-
-	@Override
-	public void readFully (byte[] b) throws IOException {
-		readBytes += b.length;
-		in.readFully(b);
-	}
-
-	@Override
-	public void readFully (byte[] b, int off, int len) throws IOException {
-		readBytes += len;
-		in.readFully(b, off, len);
-	}
-
-	@Override
-	public int skipBytes (int n) throws IOException {
-		int skipped = in.skipBytes(n);
-		readBytes += skipped;
-		return skipped;
-	}
-
-	@Override
-	public boolean readBoolean () throws IOException {
-		readBytes += 1;
-		return in.readBoolean();
-	}
-
-	@Override
-	public byte readByte () throws IOException {
-		readBytes += 1;
-		return in.readByte();
-	}
-
-	@Override
-	public int readUnsignedByte () throws IOException {
-		readBytes += 1;
-		return in.readUnsignedByte();
-	}
-
-	@Override
-	public short readShort () throws IOException {
-		readBytes += 2;
-		return in.readShort();
-	}
-
-	@Override
-	public int readUnsignedShort () throws IOException {
-		readBytes += 2;
-		return in.readUnsignedShort();
-	}
-
-	@Override
-	public char readChar () throws IOException {
-		readBytes += 2;
-		return in.readChar();
-	}
-
-	@Override
-	public int readInt () throws IOException {
-		readBytes += 4;
-		return in.readInt();
-	}
-
-	@Override
-	public long readLong () throws IOException {
-		readBytes += 8;
-		return in.readLong();
-	}
-
-	@Override
-	public float readFloat () throws IOException {
-		readBytes += 4;
-		return in.readFloat();
-	}
-
-	@Override
-	public double readDouble () throws IOException {
-		readBytes += 8;
-		return in.readDouble();
-	}
-
-	@Override
-	public String readLine () throws IOException {
-		throw new UnsupportedOperationException("Not implemented");
-	}
-
-	@Override
-	public String readUTF () throws IOException {
-		throw new UnsupportedOperationException("Not implemented");
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/g3d/chunks/G3dExporter.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/g3d/chunks/G3dExporter.java
deleted file mode 100644
index 6a626b8..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/g3d/chunks/G3dExporter.java
+++ /dev/null
@@ -1,365 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.loaders.g3d.chunks;
-
-import java.io.IOException;
-import java.io.OutputStream;
-
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.VertexAttribute;
-import com.badlogic.gdx.graphics.g3d.loaders.g3d.G3dConstants;
-import com.badlogic.gdx.graphics.g3d.model.keyframe.Keyframe;
-import com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedAnimation;
-import com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedModel;
-import com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedSubMesh;
-import com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonAnimation;
-import com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonJoint;
-import com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonKeyframe;
-import com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonModel;
-import com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonSubMesh;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
-import com.badlogic.gdx.graphics.g3d.model.still.StillSubMesh;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-
-public class G3dExporter {
-	public static void export (StillModel model, FileHandle file) {
-		ChunkWriter writer = new ChunkWriter();
-
-		// write version info
-		writer.newChunk(G3dConstants.VERSION_INFO);
-		writer.writeByte(G3dConstants.MAJOR_VERSION);
-		writer.writeByte(G3dConstants.MINOR_VERSION);
-		writer.endChunk();
-
-		// write still model
-		writer.newChunk(G3dConstants.STILL_MODEL);
-		writer.writeInt(model.subMeshes.length);
-
-		// write sub mesh
-		for (StillSubMesh mesh : model.subMeshes) {
-			// start sub mesh
-			writer.newChunk(G3dConstants.STILL_SUBMESH);
-			writer.writeString(mesh.name == null ? "" : mesh.name);
-			writer.writeInt(mesh.primitiveType);
-
-			// write vertex attributes
-			writer.newChunk(G3dConstants.VERTEX_ATTRIBUTES);
-			writer.writeInt(mesh.mesh.getVertexAttributes().size());
-			for (int i = 0; i < mesh.mesh.getVertexAttributes().size(); i++) {
-				VertexAttribute attribute = mesh.mesh.getVertexAttributes().get(i);
-				writer.newChunk(G3dConstants.VERTEX_ATTRIBUTE);
-				writer.writeInt(attribute.usage);
-				writer.writeInt(attribute.numComponents);
-				writer.writeString(attribute.alias);
-				writer.endChunk();
-			}
-			writer.endChunk();
-
-			// write vertices
-			writer.newChunk(G3dConstants.VERTEX_LIST);
-			int numFloats = mesh.mesh.getNumVertices() * mesh.mesh.getVertexSize() / 4;
-			float[] vertices = new float[numFloats];
-			mesh.mesh.getVertices(vertices);
-			writer.writeInt(mesh.mesh.getNumVertices());
-			writer.writeFloats(vertices);
-			writer.endChunk();
-
-			// write indices
-			writer.newChunk(G3dConstants.INDEX_LIST);
-			int numShorts = mesh.mesh.getNumIndices();
-			short[] indices = new short[numShorts];
-			mesh.mesh.getIndices(indices);
-			writer.writeInt(numShorts);
-			writer.writeShorts(indices);
-			writer.endChunk();
-
-			// end sub mesh
-			writer.endChunk();
-		}
-
-		// end still model
-		writer.endChunk();
-
-		// write to file
-		OutputStream out = null;
-		try {
-			out = file.write(false);
-			writer.writeToStream(out);
-		} catch (IOException e) {
-			throw new GdxRuntimeException("An error occured while exporting the still model, " + e.getMessage(), e);
-		} finally {
-			if (out != null) try {
-				out.close();
-			} catch (IOException e) {
-			}
-		}
-	}
-
-	public static void export (KeyframedModel model, FileHandle file) {
-		ChunkWriter writer = new ChunkWriter();
-
-		// write version info
-		writer.newChunk(G3dConstants.VERSION_INFO);
-		writer.writeByte(G3dConstants.MAJOR_VERSION);
-		writer.writeByte(G3dConstants.MINOR_VERSION);
-		writer.endChunk();
-
-		// write keyframed model
-		writer.newChunk(G3dConstants.KEYFRAMED_MODEL);
-		writer.writeInt(model.subMeshes.length);
-
-		for (KeyframedSubMesh mesh : model.subMeshes) {
-			// writes keyframed submesh
-			writer.newChunk(G3dConstants.KEYFRAMED_SUBMESH);
-			writer.writeString(mesh.name == null ? "" : mesh.name);
-			writer.writeInt(mesh.primitiveType);
-			writer.writeInt(mesh.animatedComponents);
-			writer.writeInt(mesh.animations.size);
-
-			// write vertex attributes
-			writer.newChunk(G3dConstants.VERTEX_ATTRIBUTES);
-			writer.writeInt(mesh.mesh.getVertexAttributes().size());
-			for (int i = 0; i < mesh.mesh.getVertexAttributes().size(); i++) {
-				VertexAttribute attribute = mesh.mesh.getVertexAttributes().get(i);
-				writer.newChunk(G3dConstants.VERTEX_ATTRIBUTE);
-				writer.writeInt(attribute.usage);
-				writer.writeInt(attribute.numComponents);
-				writer.writeString(attribute.alias);
-				writer.endChunk();
-			}
-			writer.endChunk();
-
-			// write static components, sort of like a bind pose mesh
-			writer.newChunk(G3dConstants.VERTEX_LIST);
-			int numFloats = mesh.mesh.getNumVertices() * mesh.mesh.getVertexSize() / 4;
-			float[] vertices = new float[numFloats];
-			mesh.mesh.getVertices(vertices);
-			writer.writeInt(mesh.mesh.getNumVertices());
-			writer.writeFloats(vertices);
-			writer.endChunk();
-
-			// write indices
-			writer.newChunk(G3dConstants.INDEX_LIST);
-			int numShorts = mesh.mesh.getNumIndices();
-			short[] indices = new short[numShorts];
-			mesh.mesh.getIndices(indices);
-			writer.writeInt(mesh.mesh.getNumIndices());
-			writer.writeShorts(indices);
-			writer.endChunk();
-
-			// write animations
-			for (String animationName : mesh.animations.keys()) {
-				KeyframedAnimation animation = mesh.animations.get(animationName);
-
-				// write keyframed animation
-				writer.newChunk(G3dConstants.KEYFRAMED_ANIMATION);
-				writer.writeString(animation.name);
-				writer.writeFloat(animation.frameDuration);
-
-				// write key frames
-				writer.writeInt(animation.keyframes.length);
-				for (Keyframe keyframe : animation.keyframes) {
-					// write keyframed
-					writer.newChunk(G3dConstants.KEYFRAMED_FRAME);
-					writer.writeFloat(keyframe.timeStamp);
-					writer.writeFloats(keyframe.vertices);
-					writer.endChunk();
-				}
-				// end keyframed animation
-				writer.endChunk();
-			}
-
-			// end keyframed submesh
-			writer.endChunk();
-		}
-
-		// end keyframed model
-		writer.endChunk();
-
-		// write to file
-		OutputStream out = null;
-		try {
-			out = file.write(false);
-			writer.writeToStream(out);
-		} catch (IOException e) {
-			throw new GdxRuntimeException("An error occured while exporting the still model, " + e.getMessage(), e);
-		} finally {
-			if (out != null) try {
-				out.close();
-			} catch (IOException e) {
-			}
-		}
-	}
-	
-	public static void export (SkeletonModel model, FileHandle file) {
-		ChunkWriter writer = new ChunkWriter();
-
-		// write version info
-		writer.newChunk(G3dConstants.VERSION_INFO);
-		writer.writeByte(G3dConstants.MAJOR_VERSION);
-		writer.writeByte(G3dConstants.MINOR_VERSION);
-		writer.endChunk();
-
-		// write skeleton model
-		writer.newChunk(G3dConstants.SKELETON_MODEL);
-		writer.writeInt(model.subMeshes.length);
-
-		for (SkeletonSubMesh mesh : model.subMeshes) {
-			// writes skeleton submesh
-			writer.newChunk(G3dConstants.SKELETON_SUBMESH);
-			writer.writeString(mesh.name == null ? "" : mesh.name);
-			writer.writeInt(mesh.primitiveType);
-
-			// write vertex attributes
-			writer.newChunk(G3dConstants.VERTEX_ATTRIBUTES);
-			writer.writeInt(mesh.mesh.getVertexAttributes().size());
-			for (int i = 0; i < mesh.mesh.getVertexAttributes().size(); i++) {
-				VertexAttribute attribute = mesh.mesh.getVertexAttributes().get(i);
-				writer.newChunk(G3dConstants.VERTEX_ATTRIBUTE);
-				writer.writeInt(attribute.usage);
-				writer.writeInt(attribute.numComponents);
-				writer.writeString(attribute.alias);
-				writer.endChunk();
-			}
-			writer.endChunk();
-
-			// write static components, sort of like a bind pose mesh
-			writer.newChunk(G3dConstants.VERTEX_LIST);
-			int numFloats = mesh.mesh.getNumVertices() * mesh.mesh.getVertexSize() / 4;
-			writer.writeInt(mesh.mesh.getNumVertices());
-			writer.writeFloats(mesh.vertices);
-			writer.endChunk();
-
-			// write indices
-			writer.newChunk(G3dConstants.INDEX_LIST);
-			int numShorts = mesh.mesh.getNumIndices();
-			writer.writeInt(numShorts);
-			writer.writeShorts(mesh.indices);
-			writer.endChunk();
-			
-			// write bone weight
-			writer.newChunk(G3dConstants.BONE_WEIGHTS);
-			writer.writeInt(mesh.boneWeights.length);
-			for(float array[] : mesh.boneWeights) {
-				writer.newChunk(G3dConstants.BONE_WEIGHT);
-				writer.writeInt(array.length);
-				writer.writeFloats(array);
-				writer.endChunk();
-			}
-			writer.endChunk();
-			
-			// write bone assignment
-			writer.newChunk(G3dConstants.BONE_ASSIGNMENTS);
-			writer.writeInt(mesh.boneAssignments.length);
-			for(int array[] : mesh.boneAssignments) {
-				writer.newChunk(G3dConstants.BONE_ASSIGNMENT);
-				writer.writeInt(array.length);
-				writer.writeInts(array);
-				writer.endChunk();
-			}
-			writer.endChunk();
-
-			// end skeleton submesh
-			writer.endChunk();
-		}
-		
-		//Write Skeleton
-		writer.newChunk(G3dConstants.SKELETON);
-		
-		//Write Skeleton hierarchy
-		writer.newChunk(G3dConstants.SKELETON_HIERARCHY);
-		writer.writeInt(model.skeleton.hierarchy.size);
-		for(SkeletonJoint joint : model.skeleton.hierarchy) {
-			writeSkeletonJoint(writer,joint);
-		}
-		
-		// end Skeleton hierarchy
-		writer.endChunk();
-		
-		//Write Skeleton animations
-		writer.newChunk(G3dConstants.SKELETON_ANIMATIONS);
-		
-		writer.writeInt(model.skeleton.animations.size);
-		for(String animationName : model.skeleton.animations.keys()){
-			writer.newChunk(G3dConstants.SKELETON_ANIMATION);
-			writer.writeString(animationName);
-			SkeletonAnimation animation = model.skeleton.animations.get(animationName);
-			writer.writeFloat(animation.totalDuration);
-			writer.writeInt(animation.perJointkeyFrames.length);
-			for(SkeletonKeyframe array[] : animation.perJointkeyFrames){
-				writer.writeInt(array.length);
-				for(SkeletonKeyframe frame : array) {
-					writer.writeFloat(frame.timeStamp);
-					writer.writeInt(frame.parentIndex);
-					writer.writeFloat(frame.position.x);
-					writer.writeFloat(frame.position.y);
-					writer.writeFloat(frame.position.z);
-					writer.writeFloat(frame.rotation.w);
-					writer.writeFloat(frame.rotation.x);
-					writer.writeFloat(frame.rotation.y);
-					writer.writeFloat(frame.rotation.z);
-					writer.writeFloat(frame.scale.x);
-					writer.writeFloat(frame.scale.y);
-					writer.writeFloat(frame.scale.z);
-				}
-			}
-			writer.endChunk();
-		}
-		
-		// end Skeleton animations
-		writer.endChunk();
-		
-		// end Skeleton
-		writer.endChunk();
-
-		// end skeleton model
-		writer.endChunk();
-
-		// write to file
-		OutputStream out = null;
-		try {
-			out = file.write(false);
-			writer.writeToStream(out);
-		} catch (IOException e) {
-			throw new GdxRuntimeException("An error occured while exporting the still model, " + e.getMessage(), e);
-		} finally {
-			if (out != null) try {
-				out.close();
-			} catch (IOException e) {
-			}
-		}
-	}
-	
-	private static void writeSkeletonJoint(ChunkWriter writer, SkeletonJoint joint) {
-		writer.writeString(joint.name);
-		writer.writeFloat(joint.position.x);
-		writer.writeFloat(joint.position.y);
-		writer.writeFloat(joint.position.z);
-		writer.writeFloat(joint.rotation.w);
-		writer.writeFloat(joint.rotation.x);
-		writer.writeFloat(joint.rotation.y);
-		writer.writeFloat(joint.rotation.z);
-		writer.writeFloat(joint.scale.x);
-		writer.writeFloat(joint.scale.y);
-		writer.writeFloat(joint.scale.z);
-		
-		writer.writeInt(joint.children.size);
-		for(SkeletonJoint child : joint.children) {
-			writeSkeletonJoint(writer,child);
-		}
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonAnimation.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonAnimation.java
deleted file mode 100644
index 141d984..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonAnimation.java
+++ /dev/null
@@ -1,5 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.loaders.json;
-
-public class JsonAnimation {
-
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMaterial.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMaterial.java
deleted file mode 100755
index 7c6e92b..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMaterial.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.loaders.json;
-
-import com.badlogic.gdx.graphics.Color;
-import com.badlogic.gdx.utils.Array;
-
-public class JsonMaterial {
-	public enum MaterialType {
-		Lambert,
-		Phong
-	}
-	
-	public String id;
-	
-	public MaterialType type;
-	
-	public Color ambient;
-	public Color diffuse;
-	public Color specular;
-	public Color emissive;
-	
-	public float shininess;
-	
-	public Array<JsonTexture> diffuseTextures;
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMesh.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMesh.java
deleted file mode 100755
index bfd396b..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMesh.java
+++ /dev/null
@@ -1,10 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.loaders.json;
-
-import com.badlogic.gdx.graphics.VertexAttribute;
-
-public class JsonMesh {
-	public String id;
-	public VertexAttribute[] attributes;
-	public float[] vertices;
-	public JsonMeshPart[] parts;
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMeshPart.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMeshPart.java
deleted file mode 100755
index a2fb02a..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMeshPart.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.loaders.json;
-
-public class JsonMeshPart {
-	public String id;
-	public short[] indices;
-	public int primitiveType;
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMeshPartMaterial.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMeshPartMaterial.java
deleted file mode 100755
index 0082255..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonMeshPartMaterial.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.loaders.json;
-
-public class JsonMeshPartMaterial {
-	public String materialId;
-	public String meshPartId;
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonModel.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonModel.java
deleted file mode 100755
index 4e282e3..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonModel.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.loaders.json;
-
-import com.badlogic.gdx.utils.GdxRuntimeException;
-
-public class JsonModel {
-	public String version;
-	public JsonMesh[] meshes;
-	public JsonMaterial[] materials;
-	public JsonNode[] nodes;
-	public JsonAnimation[] animations;
-	
-	public void addMesh(JsonMesh mesh) {
-		for(JsonMesh other: meshes) {
-			if(other.id.equals(mesh.id)) {
-				throw new GdxRuntimeException("Mesh with id '" + other.id + "' already in model");
-			}
-		}
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonModelLoader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonModelLoader.java
deleted file mode 100755
index 344461d..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonModelLoader.java
+++ /dev/null
@@ -1,408 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.loaders.json;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.Color;
-import com.badlogic.gdx.graphics.GL10;
-import com.badlogic.gdx.graphics.Mesh;
-import com.badlogic.gdx.graphics.Texture;
-import com.badlogic.gdx.graphics.Texture.TextureFilter;
-import com.badlogic.gdx.graphics.VertexAttribute;
-import com.badlogic.gdx.graphics.g3d.ModelLoaderHints;
-import com.badlogic.gdx.graphics.g3d.loaders.ModelLoader;
-import com.badlogic.gdx.graphics.g3d.loaders.json.JsonMaterial.MaterialType;
-import com.badlogic.gdx.graphics.g3d.materials.ColorAttribute;
-import com.badlogic.gdx.graphics.g3d.materials.Material;
-import com.badlogic.gdx.graphics.g3d.materials.TextureAttribute;
-import com.badlogic.gdx.graphics.g3d.model.Model;
-import com.badlogic.gdx.graphics.g3d.model.SubMesh;
-import com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonModel;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
-import com.badlogic.gdx.graphics.g3d.model.still.StillSubMesh;
-import com.badlogic.gdx.math.Vector2;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-import com.badlogic.gdx.utils.JsonReader;
-import com.badlogic.gdx.utils.ObjectMap;
-import com.badlogic.gdx.utils.OrderedMap;
-
-/**
- * {@link ModelLoader} for the JSON format written by the 
- * <a href="https://github.com/libgdx/fbx-conv">fbx-conv</a> tool.
- * 
- * @author mzechner
- *
- */
-public class JsonModelLoader implements ModelLoader {
-	public static String VERSION = "1.0";
-	
-	@Override
-	public Model load (FileHandle handle, ModelLoaderHints hints) {
-		JsonModel jsonModel = parseModel(handle, hints);
-		Model model = null;
-		
-		if(jsonModel.animations == null)
-			model = createStillModel(jsonModel);
-		else // add hints for sampling to keyframed model
-			model = createSkeletonModel(jsonModel);
-		
-		return model;
-	}
-
-	private SkeletonModel createSkeletonModel (JsonModel jsonModel) {
-		// TODO Auto-generated method stub
-		return null;
-	}
-
-	private StillModel createStillModel (JsonModel model) {
-		StillModel stillModel = new StillModel(new SubMesh[model.meshes.length]);
-		
-		// We create the materials first
-		ObjectMap<String, Material> materials = new ObjectMap<String, Material>();
-		for(int i=0; i<model.materials.length; i++){
-			JsonMaterial jsonMaterial = model.materials[i];
-			Material material = new Material(jsonMaterial.id);
-			
-			// simple loader for now. Just diffuse & textures
-			material.addAttribute(new ColorAttribute(jsonMaterial.diffuse, "diffuse"));
-
-			if(jsonMaterial.diffuseTextures != null){
-				JsonTexture jsonTexture = jsonMaterial.diffuseTextures.get(0);
-				
-				// one texture unit for now
-				Texture texture = new Texture(Gdx.files.internal(jsonTexture.fileName));
-				texture.setFilter(TextureFilter.Linear, TextureFilter.Linear);
-				material.addAttribute(new TextureAttribute(texture, 0, "diffuseTexture"));
-			}
-			
-			materials.put(jsonMaterial.id, material);
-		}
-		
-		// Create the meshes and assign materials to them. This is a super hack until we have hierarchy
-		for(int i=0; i<model.meshes.length; i++){
-			JsonMesh jsonMesh = model.meshes[i];
-			// if we have more than one submesh we're screwed for now.
-			JsonMeshPart jsonMeshPart = model.meshes[i].parts[0];
-			
-			Mesh mesh = new Mesh(false, jsonMesh.vertices.length, jsonMeshPart.indices.length, jsonMesh.attributes);
-			mesh.setIndices(jsonMeshPart.indices);
-			mesh.setVertices(jsonMesh.vertices);
-			
-			StillSubMesh subMesh = new StillSubMesh(jsonMesh.id, mesh, jsonMeshPart.primitiveType);
-			// Just assumes i material. We need the node tree to work this properly
-			subMesh.material = materials.get(model.materials[i].id);
-			stillModel.subMeshes[i] = subMesh;
-		}
-		
-		return stillModel;
-	}
-
-	public JsonModel parseModel (FileHandle handle, ModelLoaderHints hints) {
-		JsonReader reader = new JsonReader();
-		OrderedMap<String, Object> json = (OrderedMap<String, Object>)reader.parse(handle);
-		
-		String version = (String)json.get("version");
-		if(version == null || !version.equals(VERSION)) {
-			throw new GdxRuntimeException("No or wrong JSON format version given, should be " + VERSION + ", is " + version);
-		}
-		
-		JsonModel model = new JsonModel();
-		parseMeshes(model, json, hints);
-		parseMaterials(model, json, hints, handle.parent().path());
-		parseNodes(model, json, hints);
-		return model;
-	}
-	
-	private void parseMeshes (JsonModel model, OrderedMap<String, Object> json, ModelLoaderHints hints) {
-		Array<OrderedMap<String, Object>> meshes = (Array<OrderedMap<String, Object>>)json.get("meshes");
-		if(meshes == null) {
-			throw new GdxRuntimeException("No meshes found in file");
-		}
-		
-		model.meshes = new JsonMesh[meshes.size];
-		int i = 0;
-		for(OrderedMap<String, Object> mesh: meshes) {
-			JsonMesh jsonMesh = new JsonMesh();
-			String id = (String)mesh.get("id");
-			if(id == null) {
-				throw new GdxRuntimeException("No id given for mesh");
-			}
-			jsonMesh.id = id;
-			
-			Array<Object> attributes = (Array<Object>)mesh.get("attributes");
-			if(attributes == null) {
-				throw new GdxRuntimeException("No vertex attributes given for mesh '" + id + "'");
-			}
-			jsonMesh.attributes = parseAttributes(attributes);
-			
-			Array<Object> vertices = (Array<Object>)mesh.get("vertices");
-			if(vertices == null) {
-				throw new GdxRuntimeException("No vertices given for mesh '" + id + "'");
-			}
-			float[] verts = new float[vertices.size];
-			int idx = 0;
-			for(Object v: vertices) {
-				verts[idx++] = (Float)v;
-			}
-			jsonMesh.vertices = verts;
-			
-			Array<OrderedMap<String, Object>> meshParts = (Array<OrderedMap<String, Object>>)mesh.get("parts");
-			if(meshParts == null) {
-				throw new GdxRuntimeException("No mesh parts given for mesh '" + id + "'");
-			}
-			Array<JsonMeshPart> parts = new Array<JsonMeshPart>();
-			for(OrderedMap<String, Object> meshPart: meshParts) {
-				JsonMeshPart jsonPart = new JsonMeshPart();
-				String partId = (String)meshPart.get("id");
-				if(id == null) {
-					throw new GdxRuntimeException("Not id given for mesh part");
-				}
-				for(JsonMeshPart other: parts) {
-					if(other.id.equals(partId)) {
-						throw new GdxRuntimeException("Mesh part with id '" + partId + "' already in defined");
-					}
-				}
-				jsonPart.id = partId;
-				
-				String type = (String)meshPart.get("type");
-				if(type == null) {
-					throw new GdxRuntimeException("No primitive type given for mesh part '" + partId + "'");
-				}
-				jsonPart.primitiveType = parseType(type);
-				
-				Array<Object> indices = (Array<Object>)meshPart.get("indices");
-				if(indices == null) {
-					throw new GdxRuntimeException("No indices given for mesh part '" + partId + "'");
-				}
-				short[] partIndices = new short[indices.size];
-				idx = 0;
-				for(Object index: indices) {
-					partIndices[idx++] = (short)(float)(Float)index;
-				}
-				jsonPart.indices = partIndices;
-				parts.add(jsonPart);
-			}
-			jsonMesh.parts = parts.toArray(JsonMeshPart.class);
-			model.meshes[i++] = jsonMesh;
-		}
-	}
-	
-	private int parseType (String type) {
-		if(type.equals("TRIANGLES")) {
-			return GL10.GL_TRIANGLES;
-		} else if(type.equals("LINES")) {
-			return GL10.GL_LINES;
-		} else if(type.equals("POINTS")) {
-			return GL10.GL_POINTS;
-		} else if(type.equals("TRIANGLE_STRIP")) {
-			return GL10.GL_TRIANGLE_STRIP;
-		} else if(type.equals("LINE_STRIP")) {
-			return GL10.GL_LINE_STRIP;
-		} /* Gameplay encoder doesn't read out line loop
-			else if(type.equals("lineloop")) {
-			return GL10.GL_LINE_LOOP; 
-		} */
-			else { 
-			throw new GdxRuntimeException("Unknown primitive type '" + type + "', should be one of triangle, trianglestrip, line, linestrip, lineloop or point");
-		}
-	}
-
-	private VertexAttribute[] parseAttributes (Array<Object> attributes) {
-		Array<VertexAttribute> vertexAttributes = new Array<VertexAttribute>();
-		int unit = 0;
-		for(Object attribute: attributes) {
-			String attr = (String)attribute;
-			if(attr.equals("POSITION")) {
-				vertexAttributes.add(VertexAttribute.Position());
-			} else if(attr.equals("NORMAL")) {
-				vertexAttributes.add(VertexAttribute.Normal());
-			} else if(attr.startsWith("TEXCOORD")) {
-				vertexAttributes.add(VertexAttribute.TexCoords(unit++));
-			} else if(attr.equals("TANGENT")) {
-				vertexAttributes.add(VertexAttribute.Tangent());
-			} else if(attr.equals("BINORMAL")) {
-				vertexAttributes.add(VertexAttribute.Binormal());
-			} else if(attr.equals("BLENDINDICES")) {
-				vertexAttributes.add(VertexAttribute.BoneIds(4));
-			} else if(attr.equals("BLENDWEIGHTS")) {
-				vertexAttributes.add(VertexAttribute.BoneWeights(4));
-			} else if(attr.equals("COLOR")) {
-				vertexAttributes.add(VertexAttribute.Color());
-			} else {
-				throw new GdxRuntimeException("Unknown vertex attribuet '" + attr + "', should be one of position, normal, uv, tangent or binormal");
-			}
-		}
-		return vertexAttributes.toArray(VertexAttribute.class);
-	}
-
-	private void parseMaterials (JsonModel model, OrderedMap<String, Object> json, ModelLoaderHints hints, String materialDir) {
-		Array<OrderedMap<String, Object>> materials = (Array<OrderedMap<String, Object>>)json.get("materials");
-		if(materials == null) {
-			// we should probably create some default material in this case
-		}
-		else {
-			model.materials = new JsonMaterial[materials.size];
-			
-			int i = 0;
-			for(OrderedMap<String, Object> material: materials) {
-				JsonMaterial jsonMaterial = new JsonMaterial();
-				
-				String id = (String)material.get("id");
-				if(id == null)
-					throw new GdxRuntimeException("Material needs an id.");
-				
-				jsonMaterial.id = id;
-				
-				// Read type
-				String type = (String)material.get("type");
-				if(type == null)
-					throw new GdxRuntimeException("Material needs a type. Lambert|Phong");
-				
-				jsonMaterial.type = type.equals("PHONG") ? MaterialType.Phong : MaterialType.Lambert;
-				
-				// Read material colors
-				jsonMaterial.diffuse = parseColor((Array<Object>)material.get("diffuse"), Color.WHITE);
-				jsonMaterial.ambient = parseColor((Array<Object>)material.get("ambient"), Color.BLACK);
-				jsonMaterial.emissive = parseColor((Array<Object>)material.get("emissive"), Color.WHITE);
-				
-				if(jsonMaterial.type == MaterialType.Phong){
-				   // Read specular
-					jsonMaterial.specular = parseColor((Array<Object>)material.get("specular"), Color.WHITE);
-					
-					// Read shininess
-					float shininess = (Float)material.get("shininess", 1.0f);
-				}
-				
-				// Read textures
-				Array<OrderedMap<String, Object>> textures = (Array<OrderedMap<String, Object>>)material.get("textures");
-				if(textures != null){
-					for(OrderedMap<String, Object> texture : textures) {
-						JsonTexture jsonTexture = new JsonTexture();
-						
-						String textureId = (String)texture.get("id");
-						if(textureId == null)
-							throw new GdxRuntimeException("Texture has no id.");
-						jsonTexture.id = textureId;
-						
-						String fileName = (String)texture.get("filename");
-						if(fileName == null)
-							throw new GdxRuntimeException("Texture needs filename.");
-						jsonTexture.fileName = materialDir + "/" + fileName;
-						
-						jsonTexture.uvTranslation = readVector2((Array<Object>)texture.get("uvTranslation"), 0f, 0f);
-						jsonTexture.uvScaling = readVector2((Array<Object>)texture.get("uvScaling"), 1f, 1f);
-						
-						String textureType = (String)texture.get("type");
-						if(type == null)
-							throw new GdxRuntimeException("Texture needs type.");
-						
-						/* Only diffuse textures for now. Most programs don't export texture usage properly ..
-						 	So we probably need to find a workaround. */
-						if(textureType.equals("STANDARD")){
-							if(jsonMaterial.diffuseTextures == null)
-								jsonMaterial.diffuseTextures = new Array<JsonTexture>();
-							jsonMaterial.diffuseTextures.add(jsonTexture);
-						}
-					}
-				}
-
-				model.materials[i++] = jsonMaterial;
-			}
-		}
-	}
-
-	private Color parseColor (Array<Object> colorArray, Color defaultColor) {
-		if(colorArray == null) {
-			return defaultColor;
-		}
-		else if(colorArray.size == 3)
-			return new Color((Float)colorArray.get(0), (Float)colorArray.get(1), (Float)colorArray.get(2), 1.0f);
-		else
-			throw new GdxRuntimeException("Expected Color values <> than three.");
-	}
-
-	private Vector2 readVector2 (Array<Object> vectorArray, float x, float y) {
-		if(vectorArray == null)
-			return new Vector2(x, y);
-		else if(vectorArray.size == 2)
-			return new Vector2((Float)vectorArray.get(0), (Float)vectorArray.get(1));
-		else
-			throw new GdxRuntimeException("Expected Vector2 values <> than two.");
-	}
-
-	private JsonNode[] parseNodes (JsonModel model, OrderedMap<String, Object> json, ModelLoaderHints hints) {
-		Array<OrderedMap<String, Object>> nodes = (Array<OrderedMap<String, Object>>)json.get("nodes");
-		if(nodes == null) {
-			throw new GdxRuntimeException("At least one node is required.");
-		}
-		
-		model.nodes = new JsonNode[nodes.size];
-		
-		int i = 0;
-		for(OrderedMap<String, Object> node : nodes) {
-			model.nodes[i++] = parseNodesRecursively(node, hints);
-		}
-		return model.nodes;
-	}
-	
-	private JsonNode parseNodesRecursively(OrderedMap<String, Object> json, ModelLoaderHints hints){
-		JsonNode jsonNode = new JsonNode();
-		
-		String id = (String)json.get("id");
-		if(id == null)
-			throw new GdxRuntimeException("Node id missing.");
-		jsonNode.id = id;
-		
-		Array<Object> translation = (Array<Object>)json.get("translation");
-		if(translation == null || translation.size != 3)
-			throw new GdxRuntimeException("Node translation missing or incomplete");
-		jsonNode.translation = new Vector3((Float)translation.get(0), (Float)translation.get(1), (Float)translation.get(2));
-		
-		Array<Object> rotation = (Array<Object>)json.get("rotation");
-		if(rotation == null || rotation.size != 3)
-			throw new GdxRuntimeException("Node rotation missing or incomplete");
-		jsonNode.rotation = new Vector3((Float)rotation.get(0), (Float)rotation.get(1), (Float)rotation.get(2));
-		
-		Array<Object> scale = (Array<Object>)json.get("scale");
-		if(scale == null || scale.size != 3)
-			throw new GdxRuntimeException("Node scale missing or incomplete");
-		jsonNode.scale = new Vector3((Float)scale.get(0), (Float)scale.get(1), (Float)scale.get(2));
-		
-		String meshId = (String)json.get("mesh");
-		if(meshId != null)
-			jsonNode.meshId = meshId;
-		
-		Array<OrderedMap<String, Object>> materials = (Array<OrderedMap<String, Object>>)json.get("materials");
-		if(materials != null){
-			jsonNode.meshPartMaterials = new JsonMeshPartMaterial[materials.size];
-			
-			int i = 0;
-			for(OrderedMap<String, Object> material : materials) {
-				JsonMeshPartMaterial meshPartMaterial = new JsonMeshPartMaterial();
-				
-				String meshPartId = (String)material.get("meshpartid");
-				String materialId = (String)material.get("materialid");
-				if(meshPartId == null || materialId == null){
-					throw new GdxRuntimeException("Node material is missing meshPartId or materialId");
-				}
-				meshPartMaterial.materialId = materialId;
-				meshPartMaterial.meshPartId = meshPartId;
-				
-				jsonNode.meshPartMaterials[i++] = meshPartMaterial;
-			}
-		}
-		
-		Array<OrderedMap<String, Object>> children = (Array<OrderedMap<String, Object>>)json.get("children");
-		if(children != null){
-			jsonNode.children = new JsonNode[children.size];
-			
-			int i = 0;
-			for(OrderedMap<String, Object> child : children) {
-				jsonNode.children[i++] = parseNodesRecursively(child, hints);
-			}
-		}
-		
-		return jsonNode;
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonNode.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonNode.java
deleted file mode 100755
index 4983cce..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonNode.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.loaders.json;
-
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Vector3;
-
-public class JsonNode {
-	public String id;
-	public int boneId = -1;
-	public Vector3 translation;
-	public Vector3 rotation;
-	public Vector3 scale;
-	public String meshId;
-	public JsonMeshPartMaterial[] meshPartMaterials;
-	public JsonNode[] children;
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonTexture.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonTexture.java
deleted file mode 100644
index 566146a..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/json/JsonTexture.java
+++ /dev/null
@@ -1,10 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.loaders.json;
-
-import com.badlogic.gdx.math.Vector2;
-
-public class JsonTexture {
-	public String id;
-	public String fileName;
-	public Vector2 uvTranslation;
-	public Vector2 uvScaling;	
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/md2/MD2Frame.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/md2/MD2Frame.java
deleted file mode 100644
index 962beb3..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/md2/MD2Frame.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.loaders.md2;
-
-public class MD2Frame {
-	public float[] vertices;
-	public int[] normalIndices;
-	public String name;
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/md2/MD2Header.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/md2/MD2Header.java
deleted file mode 100644
index 19a2b84..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/md2/MD2Header.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.loaders.md2;
-
-public class MD2Header {
-	public int ident;
-	public int version;
-	public int skinWidth;
-	public int skinHeight;
-	public int frameSize;
-	public int numSkins;
-	public int numVertices;
-	public int numTexCoords;
-	public int numTriangles;
-	public int numGLCommands;
-	public int numFrames;
-	public int offsetSkin;
-	public int offsetTexCoords;
-	public int offsetTriangles;
-	public int offsetFrames;
-	public int offsetGLCommands;
-	public int offsetEnd;
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/md2/MD2Loader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/md2/MD2Loader.java
deleted file mode 100644
index e91ccb5..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/md2/MD2Loader.java
+++ /dev/null
@@ -1,421 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.loaders.md2;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.ArrayList;
-
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.GL10;
-import com.badlogic.gdx.graphics.Mesh;
-import com.badlogic.gdx.graphics.Mesh.VertexDataType;
-import com.badlogic.gdx.graphics.VertexAttribute;
-import com.badlogic.gdx.graphics.VertexAttributes.Usage;
-import com.badlogic.gdx.graphics.g3d.ModelLoaderHints;
-import com.badlogic.gdx.graphics.g3d.loaders.KeyframedModelLoader;
-import com.badlogic.gdx.graphics.g3d.model.keyframe.Keyframe;
-import com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedAnimation;
-import com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedModel;
-import com.badlogic.gdx.graphics.g3d.model.keyframe.KeyframedSubMesh;
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-import com.badlogic.gdx.utils.LittleEndianInputStream;
-import com.badlogic.gdx.utils.ObjectMap;
-
-public class MD2Loader implements KeyframedModelLoader {
-	public KeyframedModel load (FileHandle file, ModelLoaderHints hints) {
-		float frameDuration = 0.2f;
-		if (hints instanceof MD2LoaderHints) {
-			frameDuration = ((MD2LoaderHints)hints).frameDuration;
-		}
-		return load(file, frameDuration);
-	}
-
-	public KeyframedModel load (FileHandle fileHandle, float frameDuration) {
-		InputStream in = fileHandle.read();
-		try {
-			return load(in, frameDuration);
-		} finally {
-			if (in != null) try {
-				in.close();
-			} catch (IOException e) {
-			}
-			;
-		}
-	}
-
-	public KeyframedModel load (InputStream in, float frameDuration) {
-		try {
-			byte[] bytes = loadBytes(in);
-
-			MD2Header header = loadHeader(bytes);
-			float[] texCoords = loadTexCoords(header, bytes);
-			MD2Triangle[] triangles = loadTriangles(header, bytes);
-			MD2Frame[] frames = loadFrames(header, bytes);
-
-			return buildModel(header, triangles, texCoords, frames, frameDuration);
-		} catch (Exception ex) {
-			ex.printStackTrace();
-			return null;
-		}
-	}
-
-	private KeyframedModel buildModel (MD2Header header, MD2Triangle[] triangles, float[] texCoords, MD2Frame[] frames,
-		float frameDuration) {
-		ArrayList<VertexIndices> vertCombos = new ArrayList<VertexIndices>();
-		short[] indices = new short[triangles.length * 3];
-		int idx = 0;
-		short vertIdx = 0;
-		for (int i = 0; i < triangles.length; i++) {
-			MD2Triangle triangle = triangles[i];
-			for (int j = 0; j < 3; j++) {
-				VertexIndices vert = null;
-				boolean contains = false;
-				for (int k = 0; k < vertCombos.size(); k++) {
-					VertexIndices vIdx = vertCombos.get(k);
-					if (vIdx.vIdx == triangle.vertices[j] && vIdx.tIdx == triangle.texCoords[j]) {
-						vert = vIdx;
-						contains = true;
-						break;
-					}
-				}
-				if (!contains) {
-					vert = new VertexIndices(triangle.vertices[j], triangle.texCoords[j], vertIdx);
-					vertCombos.add(vert);
-					vertIdx++;
-				}
-
-				indices[idx++] = vert.nIdx;
-			}
-		}
-
-		idx = 0;
-		float[] uvs = new float[vertCombos.size() * 2];
-		for (int i = 0; i < vertCombos.size(); i++) {
-			VertexIndices vtI = vertCombos.get(i);
-			uvs[idx++] = texCoords[vtI.tIdx * 2];
-			uvs[idx++] = texCoords[vtI.tIdx * 2 + 1];
-		}
-
-		for (int i = 0; i < frames.length; i++) {
-			MD2Frame frame = frames[i];
-			idx = 0;
-			float[] newVerts = new float[vertCombos.size() * 6];
-
-			for (int j = 0; j < vertCombos.size(); j++) {
-				VertexIndices vIdx = vertCombos.get(j);
-				newVerts[idx++] = frame.vertices[vIdx.vIdx * 3];
-				newVerts[idx++] = frame.vertices[vIdx.vIdx * 3 + 1];
-				newVerts[idx++] = frame.vertices[vIdx.vIdx * 3 + 2];
-				newVerts[idx++] = MD2Normals.normals[frame.normalIndices[vIdx.vIdx]][1];
-				newVerts[idx++] = MD2Normals.normals[frame.normalIndices[vIdx.vIdx]][2];
-				newVerts[idx++] = MD2Normals.normals[frame.normalIndices[vIdx.vIdx]][0];
-			}
-			frame.vertices = newVerts;
-		}
-
-		header.numVertices = vertCombos.size();
-
-		float[] blendedVertices = new float[header.numVertices * 8];
-		MD2Frame frame = frames[0];
-
-		idx = 0;
-		int idxV = 0;
-		int idxT = 0;
-		for (int i = 0; i < header.numVertices; i++) {
-			VertexIndices vIdx = vertCombos.get(i);
-
-			blendedVertices[idx++] = frame.vertices[idxV++];
-			blendedVertices[idx++] = frame.vertices[idxV++];
-			blendedVertices[idx++] = frame.vertices[idxV++];
-			blendedVertices[idx++] = frame.vertices[idxV++];
-			blendedVertices[idx++] = frame.vertices[idxV++];
-			blendedVertices[idx++] = frame.vertices[idxV++];
-			blendedVertices[idx++] = uvs[idxT++];
-			blendedVertices[idx++] = uvs[idxT++];
-		}
-
-		ObjectMap<String, KeyframedAnimation> animations = new ObjectMap<String, KeyframedAnimation>();
-
-		String lastName = frames[0].name;
-		int beginFrame = 0;
-
-		for (int frameNum = 1; frameNum < frames.length; frameNum++) {
-			if (!frames[frameNum].name.equals(lastName) || frameNum == frames.length - 1) {
-				int subAnimLen = frameNum - beginFrame;
-				KeyframedAnimation subAnim = new KeyframedAnimation(lastName, frameDuration, new Keyframe[subAnimLen]);
-
-				for (int subFrame = beginFrame; subFrame < frameNum; subFrame++) {
-					int absFrameNum = subFrame - beginFrame;
-
-					frame = frames[subFrame];
-					float[] vertices = new float[header.numVertices * 6];
-					idx = 0;
-					idxV = 0;
-					for (int i = 0; i < header.numVertices; i++) {
-						vertices[idx++] = frame.vertices[idxV++];
-						vertices[idx++] = frame.vertices[idxV++];
-						vertices[idx++] = frame.vertices[idxV++];
-						vertices[idx++] = frame.vertices[idxV++];
-						vertices[idx++] = frame.vertices[idxV++];
-						vertices[idx++] = frame.vertices[idxV++];
-					}
-
-					Keyframe keyFrame = new Keyframe(absFrameNum * frameDuration, vertices);
-					subAnim.keyframes[absFrameNum] = keyFrame;
-					animations.put(subAnim.name, subAnim);
-				}
-
-				lastName = frames[frameNum].name;
-				beginFrame = frameNum;
-			}
-		}
-
-		KeyframedAnimation animation = new KeyframedAnimation("all", frameDuration, new Keyframe[frames.length]);
-		float timeStamp = 0;
-		for (int frameNum = 0; frameNum < frames.length; frameNum++) {
-			frame = frames[frameNum];
-			float[] vertices = new float[header.numVertices * 6];
-			idx = 0;
-			idxV = 0;
-			for (int i = 0; i < header.numVertices; i++) {
-				vertices[idx++] = frame.vertices[idxV++];
-				vertices[idx++] = frame.vertices[idxV++];
-				vertices[idx++] = frame.vertices[idxV++];
-				vertices[idx++] = frame.vertices[idxV++];
-				vertices[idx++] = frame.vertices[idxV++];
-				vertices[idx++] = frame.vertices[idxV++];
-			}
-
-			Keyframe keyFrame = new Keyframe(frameNum * frameDuration, vertices);
-			animation.keyframes[frameNum] = keyFrame;
-		}
-
-		Mesh mesh = new Mesh(VertexDataType.VertexArray, false, header.numVertices, indices.length, new VertexAttribute(
-			Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE), new VertexAttribute(Usage.Normal, 3,
-			ShaderProgram.NORMAL_ATTRIBUTE),
-			new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + "0"));
-		mesh.setIndices(indices);
-		animations.put("all", animation);
-
-		KeyframedSubMesh subMesh = new KeyframedSubMesh("md2-mesh", mesh, blendedVertices, animations, 6, GL10.GL_TRIANGLES);
-		KeyframedModel model = new KeyframedModel(new KeyframedSubMesh[] {subMesh});
-		model.setAnimation("all", 0, false);
-		return model;
-	}
-
-	private float[] buildTexCoords (MD2Header header, MD2Triangle[] triangles, float[] texCoords) {
-		float[] uvs = new float[header.numVertices * 2];
-
-		for (int i = 0; i < triangles.length; i++) {
-			MD2Triangle triangle = triangles[i];
-			for (int j = 0; j < 3; j++) {
-				int vertIdx = triangle.vertices[j];
-				int uvIdx = vertIdx * 2;
-				uvs[uvIdx] = texCoords[triangle.texCoords[j] * 2];
-				uvs[uvIdx + 1] = texCoords[triangle.texCoords[j] * 2 + 1];
-			}
-		}
-
-		return uvs;
-	}
-
-	private short[] buildIndices (MD2Triangle[] triangles) {
-		short[] indices = new short[triangles.length * 3];
-
-		int idx = 0;
-		for (int i = 0; i < triangles.length; i++) {
-			MD2Triangle triangle = triangles[i];
-			indices[idx++] = triangle.vertices[0];
-			indices[idx++] = triangle.vertices[1];
-			indices[idx++] = triangle.vertices[2];
-		}
-		return indices;
-	}
-
-	private MD2Frame[] loadFrames (MD2Header header, byte[] bytes) throws IOException {
-		LittleEndianInputStream in = new LittleEndianInputStream(new ByteArrayInputStream(bytes));
-		in.skip(header.offsetFrames);
-
-		MD2Frame[] frames = new MD2Frame[header.numFrames];
-		for (int i = 0; i < header.numFrames; i++) {
-			frames[i] = loadFrame(header, in);
-		}
-
-		in.close();
-
-		return frames;
-	}
-
-	private final byte[] charBuffer = new byte[16];
-
-	private MD2Frame loadFrame (MD2Header header, LittleEndianInputStream in) throws IOException {
-		MD2Frame frame = new MD2Frame();
-		frame.vertices = new float[header.numVertices * 3];
-		frame.normalIndices = new int[header.numVertices];
-
-		float scaleX = in.readFloat(), scaleY = in.readFloat(), scaleZ = in.readFloat();
-		float transX = in.readFloat(), transY = in.readFloat(), transZ = in.readFloat();
-		in.read(charBuffer);
-
-		int len = 0;
-		for (int i = 0; i < charBuffer.length; i++)
-			if (charBuffer[i] == 0) {
-				len = i;
-				break;
-			}
-
-		frame.name = new String(charBuffer, 0, len);
-
-		int vertIdx = 0;
-
-		for (int i = 0; i < header.numVertices; i++) {
-			float x = in.read() * scaleX + transX;
-			float y = in.read() * scaleY + transY;
-			float z = in.read() * scaleZ + transZ;
-
-			frame.vertices[vertIdx++] = y;
-			frame.vertices[vertIdx++] = z;
-			frame.vertices[vertIdx++] = x;
-
-			frame.normalIndices[i] = in.read(); // normal index
-		}
-
-		return frame;
-	}
-
-	private MD2Triangle[] loadTriangles (MD2Header header, byte[] bytes) throws IOException {
-		LittleEndianInputStream in = new LittleEndianInputStream(new ByteArrayInputStream(bytes));
-		in.skip(header.offsetTriangles);
-		MD2Triangle[] triangles = new MD2Triangle[header.numTriangles];
-
-		for (int i = 0; i < header.numTriangles; i++) {
-			MD2Triangle triangle = new MD2Triangle();
-			triangle.vertices[0] = in.readShort();
-			triangle.vertices[1] = in.readShort();
-			triangle.vertices[2] = in.readShort();
-			triangle.texCoords[0] = in.readShort();
-			triangle.texCoords[1] = in.readShort();
-			triangle.texCoords[2] = in.readShort();
-			triangles[i] = triangle;
-		}
-
-		in.close();
-
-		return triangles;
-	}
-
-	private float[] loadTexCoords (MD2Header header, byte[] bytes) throws IOException {
-		LittleEndianInputStream in = new LittleEndianInputStream(new ByteArrayInputStream(bytes));
-		in.skip(header.offsetTexCoords);
-		float[] texCoords = new float[header.numTexCoords * 2];
-		float width = header.skinWidth;
-		float height = header.skinHeight;
-
-		for (int i = 0; i < header.numTexCoords * 2; i += 2) {
-			short u = in.readShort();
-			short v = in.readShort();
-			texCoords[i] = u / width;
-			texCoords[i + 1] = v / height;
-		}
-		in.close();
-		return texCoords;
-	}
-
-	private MD2Header loadHeader (byte[] bytes) throws IOException {
-		LittleEndianInputStream in = new LittleEndianInputStream(new ByteArrayInputStream(bytes));
-		MD2Header header = new MD2Header();
-
-		header.ident = in.readInt();
-		header.version = in.readInt();
-		header.skinWidth = in.readInt();
-		header.skinHeight = in.readInt();
-		header.frameSize = in.readInt();
-		header.numSkins = in.readInt();
-		header.numVertices = in.readInt();
-		header.numTexCoords = in.readInt();
-		header.numTriangles = in.readInt();
-		header.numGLCommands = in.readInt();
-		header.numFrames = in.readInt();
-		header.offsetSkin = in.readInt();
-		header.offsetTexCoords = in.readInt();
-		header.offsetTriangles = in.readInt();
-		header.offsetFrames = in.readInt();
-		header.offsetGLCommands = in.readInt();
-		header.offsetEnd = in.readInt();
-
-		in.close();
-
-		return header;
-	}
-
-	private byte[] loadBytes (InputStream in) throws IOException {
-		ByteArrayOutputStream out = new ByteArrayOutputStream();
-		byte[] buffer = new byte[1024];
-
-		int readBytes = 0;
-		while ((readBytes = in.read(buffer)) > 0) {
-			out.write(buffer, 0, readBytes);
-		}
-
-		out.close();
-		return out.toByteArray();
-	}
-
-	public class VertexIndices {
-		public VertexIndices (short vIdx, short tIdx, short nIdx) {
-			this.vIdx = vIdx;
-			this.tIdx = tIdx;
-			this.nIdx = nIdx;
-		}
-
-		@Override
-		public int hashCode () {
-			final int prime = 31;
-			int result = 1;
-			result = prime * result + tIdx;
-			result = prime * result + vIdx;
-			return result;
-		}
-
-		@Override
-		public boolean equals (Object obj) {
-			if (this == obj) return true;
-			if (obj == null) return false;
-			if (getClass() != obj.getClass()) return false;
-			VertexIndices other = (VertexIndices)obj;
-			if (tIdx != other.tIdx) return false;
-			if (vIdx != other.vIdx) return false;
-			return true;
-		}
-
-		public short vIdx;
-		public short tIdx;
-		public short nIdx;
-	}
-
-	public static class MD2LoaderHints extends ModelLoaderHints {
-		public final float frameDuration;
-
-		public MD2LoaderHints (float frameDuration) {
-			super(false);
-			this.frameDuration = frameDuration;
-		}
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/md2/MD2Normals.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/md2/MD2Normals.java
deleted file mode 100644
index efc5d81..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/md2/MD2Normals.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.loaders.md2;
-
-public class MD2Normals {
-	public static float[][] normals = { {-0.525731f, 0.000000f, 0.850651f}, {-0.442863f, 0.238856f, 0.864188f},
-		{-0.295242f, 0.000000f, 0.955423f}, {-0.309017f, 0.500000f, 0.809017f}, {-0.162460f, 0.262866f, 0.951056f},
-		{0.000000f, 0.000000f, 1.000000f}, {0.000000f, 0.850651f, 0.525731f}, {-0.147621f, 0.716567f, 0.681718f},
-		{0.147621f, 0.716567f, 0.681718f}, {0.000000f, 0.525731f, 0.850651f}, {0.309017f, 0.500000f, 0.809017f},
-		{0.525731f, 0.000000f, 0.850651f}, {0.295242f, 0.000000f, 0.955423f}, {0.442863f, 0.238856f, 0.864188f},
-		{0.162460f, 0.262866f, 0.951056f}, {-0.681718f, 0.147621f, 0.716567f}, {-0.809017f, 0.309017f, 0.500000f},
-		{-0.587785f, 0.425325f, 0.688191f}, {-0.850651f, 0.525731f, 0.000000f}, {-0.864188f, 0.442863f, 0.238856f},
-		{-0.716567f, 0.681718f, 0.147621f}, {-0.688191f, 0.587785f, 0.425325f}, {-0.500000f, 0.809017f, 0.309017f},
-		{-0.238856f, 0.864188f, 0.442863f}, {-0.425325f, 0.688191f, 0.587785f}, {-0.716567f, 0.681718f, -0.147621f},
-		{-0.500000f, 0.809017f, -0.309017f}, {-0.525731f, 0.850651f, 0.000000f}, {0.000000f, 0.850651f, -0.525731f},
-		{-0.238856f, 0.864188f, -0.442863f}, {0.000000f, 0.955423f, -0.295242f}, {-0.262866f, 0.951056f, -0.162460f},
-		{0.000000f, 1.000000f, 0.000000f}, {0.000000f, 0.955423f, 0.295242f}, {-0.262866f, 0.951056f, 0.162460f},
-		{0.238856f, 0.864188f, 0.442863f}, {0.262866f, 0.951056f, 0.162460f}, {0.500000f, 0.809017f, 0.309017f},
-		{0.238856f, 0.864188f, -0.442863f}, {0.262866f, 0.951056f, -0.162460f}, {0.500000f, 0.809017f, -0.309017f},
-		{0.850651f, 0.525731f, 0.000000f}, {0.716567f, 0.681718f, 0.147621f}, {0.716567f, 0.681718f, -0.147621f},
-		{0.525731f, 0.850651f, 0.000000f}, {0.425325f, 0.688191f, 0.587785f}, {0.864188f, 0.442863f, 0.238856f},
-		{0.688191f, 0.587785f, 0.425325f}, {0.809017f, 0.309017f, 0.500000f}, {0.681718f, 0.147621f, 0.716567f},
-		{0.587785f, 0.425325f, 0.688191f}, {0.955423f, 0.295242f, 0.000000f}, {1.000000f, 0.000000f, 0.000000f},
-		{0.951056f, 0.162460f, 0.262866f}, {0.850651f, -0.525731f, 0.000000f}, {0.955423f, -0.295242f, 0.000000f},
-		{0.864188f, -0.442863f, 0.238856f}, {0.951056f, -0.162460f, 0.262866f}, {0.809017f, -0.309017f, 0.500000f},
-		{0.681718f, -0.147621f, 0.716567f}, {0.850651f, 0.000000f, 0.525731f}, {0.864188f, 0.442863f, -0.238856f},
-		{0.809017f, 0.309017f, -0.500000f}, {0.951056f, 0.162460f, -0.262866f}, {0.525731f, 0.000000f, -0.850651f},
-		{0.681718f, 0.147621f, -0.716567f}, {0.681718f, -0.147621f, -0.716567f}, {0.850651f, 0.000000f, -0.525731f},
-		{0.809017f, -0.309017f, -0.500000f}, {0.864188f, -0.442863f, -0.238856f}, {0.951056f, -0.162460f, -0.262866f},
-		{0.147621f, 0.716567f, -0.681718f}, {0.309017f, 0.500000f, -0.809017f}, {0.425325f, 0.688191f, -0.587785f},
-		{0.442863f, 0.238856f, -0.864188f}, {0.587785f, 0.425325f, -0.688191f}, {0.688191f, 0.587785f, -0.425325f},
-		{-0.147621f, 0.716567f, -0.681718f}, {-0.309017f, 0.500000f, -0.809017f}, {0.000000f, 0.525731f, -0.850651f},
-		{-0.525731f, 0.000000f, -0.850651f}, {-0.442863f, 0.238856f, -0.864188f}, {-0.295242f, 0.000000f, -0.955423f},
-		{-0.162460f, 0.262866f, -0.951056f}, {0.000000f, 0.000000f, -1.000000f}, {0.295242f, 0.000000f, -0.955423f},
-		{0.162460f, 0.262866f, -0.951056f}, {-0.442863f, -0.238856f, -0.864188f}, {-0.309017f, -0.500000f, -0.809017f},
-		{-0.162460f, -0.262866f, -0.951056f}, {0.000000f, -0.850651f, -0.525731f}, {-0.147621f, -0.716567f, -0.681718f},
-		{0.147621f, -0.716567f, -0.681718f}, {0.000000f, -0.525731f, -0.850651f}, {0.309017f, -0.500000f, -0.809017f},
-		{0.442863f, -0.238856f, -0.864188f}, {0.162460f, -0.262866f, -0.951056f}, {0.238856f, -0.864188f, -0.442863f},
-		{0.500000f, -0.809017f, -0.309017f}, {0.425325f, -0.688191f, -0.587785f}, {0.716567f, -0.681718f, -0.147621f},
-		{0.688191f, -0.587785f, -0.425325f}, {0.587785f, -0.425325f, -0.688191f}, {0.000000f, -0.955423f, -0.295242f},
-		{0.000000f, -1.000000f, 0.000000f}, {0.262866f, -0.951056f, -0.162460f}, {0.000000f, -0.850651f, 0.525731f},
-		{0.000000f, -0.955423f, 0.295242f}, {0.238856f, -0.864188f, 0.442863f}, {0.262866f, -0.951056f, 0.162460f},
-		{0.500000f, -0.809017f, 0.309017f}, {0.716567f, -0.681718f, 0.147621f}, {0.525731f, -0.850651f, 0.000000f},
-		{-0.238856f, -0.864188f, -0.442863f}, {-0.500000f, -0.809017f, -0.309017f}, {-0.262866f, -0.951056f, -0.162460f},
-		{-0.850651f, -0.525731f, 0.000000f}, {-0.716567f, -0.681718f, -0.147621f}, {-0.716567f, -0.681718f, 0.147621f},
-		{-0.525731f, -0.850651f, 0.000000f}, {-0.500000f, -0.809017f, 0.309017f}, {-0.238856f, -0.864188f, 0.442863f},
-		{-0.262866f, -0.951056f, 0.162460f}, {-0.864188f, -0.442863f, 0.238856f}, {-0.809017f, -0.309017f, 0.500000f},
-		{-0.688191f, -0.587785f, 0.425325f}, {-0.681718f, -0.147621f, 0.716567f}, {-0.442863f, -0.238856f, 0.864188f},
-		{-0.587785f, -0.425325f, 0.688191f}, {-0.309017f, -0.500000f, 0.809017f}, {-0.147621f, -0.716567f, 0.681718f},
-		{-0.425325f, -0.688191f, 0.587785f}, {-0.162460f, -0.262866f, 0.951056f}, {0.442863f, -0.238856f, 0.864188f},
-		{0.162460f, -0.262866f, 0.951056f}, {0.309017f, -0.500000f, 0.809017f}, {0.147621f, -0.716567f, 0.681718f},
-		{0.000000f, -0.525731f, 0.850651f}, {0.425325f, -0.688191f, 0.587785f}, {0.587785f, -0.425325f, 0.688191f},
-		{0.688191f, -0.587785f, 0.425325f}, {-0.955423f, 0.295242f, 0.000000f}, {-0.951056f, 0.162460f, 0.262866f},
-		{-1.000000f, 0.000000f, 0.000000f}, {-0.850651f, 0.000000f, 0.525731f}, {-0.955423f, -0.295242f, 0.000000f},
-		{-0.951056f, -0.162460f, 0.262866f}, {-0.864188f, 0.442863f, -0.238856f}, {-0.951056f, 0.162460f, -0.262866f},
-		{-0.809017f, 0.309017f, -0.500000f}, {-0.864188f, -0.442863f, -0.238856f}, {-0.951056f, -0.162460f, -0.262866f},
-		{-0.809017f, -0.309017f, -0.500000f}, {-0.681718f, 0.147621f, -0.716567f}, {-0.681718f, -0.147621f, -0.716567f},
-		{-0.850651f, 0.000000f, -0.525731f}, {-0.688191f, 0.587785f, -0.425325f}, {-0.587785f, 0.425325f, -0.688191f},
-		{-0.425325f, 0.688191f, -0.587785f}, {-0.425325f, -0.688191f, -0.587785f}, {-0.587785f, -0.425325f, -0.688191f},
-		{-0.688191f, -0.587785f, -0.425325f}};
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/md2/MD2Triangle.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/md2/MD2Triangle.java
deleted file mode 100644
index 5cd6052..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/md2/MD2Triangle.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.loaders.md2;
-
-public class MD2Triangle {
-	public short[] vertices = new short[3];
-	public short[] texCoords = new short[3];
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/wavefront/ObjLoader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/wavefront/ObjLoader.java
deleted file mode 100644
index 1255c75..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loaders/wavefront/ObjLoader.java
+++ /dev/null
@@ -1,394 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.loaders.wavefront;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.ArrayList;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.assets.AssetManager;
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.Color;
-import com.badlogic.gdx.graphics.GL10;
-import com.badlogic.gdx.graphics.Mesh;
-import com.badlogic.gdx.graphics.Pixmap;
-import com.badlogic.gdx.graphics.Pixmap.Format;
-import com.badlogic.gdx.graphics.Texture;
-import com.badlogic.gdx.graphics.Texture.TextureFilter;
-import com.badlogic.gdx.graphics.VertexAttribute;
-import com.badlogic.gdx.graphics.VertexAttributes.Usage;
-import com.badlogic.gdx.graphics.g3d.ModelLoaderHints;
-import com.badlogic.gdx.graphics.g3d.loaders.StillModelLoader;
-import com.badlogic.gdx.graphics.g3d.materials.ColorAttribute;
-import com.badlogic.gdx.graphics.g3d.materials.Material;
-import com.badlogic.gdx.graphics.g3d.materials.TextureAttribute;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
-import com.badlogic.gdx.graphics.g3d.model.still.StillSubMesh;
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-import com.badlogic.gdx.utils.FloatArray;
-
-/** Loads Wavefront OBJ files.
- * 
- * @author mzechner, espitz */
-public class ObjLoader implements StillModelLoader {
-	final FloatArray verts;
-	final FloatArray norms;
-	final FloatArray uvs;
-	final ArrayList<Group> groups;
-
-	public ObjLoader () {
-		verts = new FloatArray(300);
-		norms = new FloatArray(300);
-		uvs = new FloatArray(200);
-		groups = new ArrayList<Group>(10);
-	}
-
-	/** Loads a Wavefront OBJ file from a given file handle.
-	 * 
-	 * @param file the FileHandle */
-	public StillModel loadObj (FileHandle file) {
-		return loadObj(file, false);
-	}
-
-	/** Loads a Wavefront OBJ file from a given file handle.
-	 * 
-	 * @param file the FileHandle
-	 * @param flipV whether to flip the v texture coordinate (Blender, Wings3D, et al) */
-	public StillModel loadObj (FileHandle file, boolean flipV) {
-		return loadObj(file, file.parent(), flipV);
-	}
-
-	/** Loads a Wavefront OBJ file from a given file handle.
-	 * 
-	 * @param file the FileHandle
-	 * @param textureDir
-	 * @param flipV whether to flip the v texture coordinate (Blender, Wings3D, et al) */
-	public StillModel loadObj (FileHandle file, FileHandle textureDir, boolean flipV) {
-		String line;
-		String[] tokens;
-		char firstChar;
-		MtlLoader mtl = new MtlLoader();
-
-		// Create a "default" Group and set it as the active group, in case
-		// there are no groups or objects defined in the OBJ file.
-		Group activeGroup = new Group("default");
-		groups.add(activeGroup);
-
-		BufferedReader reader = new BufferedReader(new InputStreamReader(file.read()), 4096);
-		try {
-			while ((line = reader.readLine()) != null) {
-
-				tokens = line.split("\\s+");
-
-				if (tokens[0].length() == 0) {
-					continue;
-				} else if ((firstChar = tokens[0].toLowerCase().charAt(0)) == '#') {
-					continue;
-				} else if (firstChar == 'v') {
-					if (tokens[0].length() == 1) {
-						verts.add(Float.parseFloat(tokens[1]));
-						verts.add(Float.parseFloat(tokens[2]));
-						verts.add(Float.parseFloat(tokens[3]));
-					} else if (tokens[0].charAt(1) == 'n') {
-						norms.add(Float.parseFloat(tokens[1]));
-						norms.add(Float.parseFloat(tokens[2]));
-						norms.add(Float.parseFloat(tokens[3]));
-					} else if (tokens[0].charAt(1) == 't') {
-						uvs.add(Float.parseFloat(tokens[1]));
-						uvs.add((flipV ? 1 - Float.parseFloat(tokens[2]) : Float.parseFloat(tokens[2])));
-					}
-				} else if (firstChar == 'f') {
-					String[] parts;
-					ArrayList<Integer> faces = activeGroup.faces;
-					for (int i = 1; i < tokens.length - 2; i--) {
-						parts = tokens[1].split("/");
-						faces.add(getIndex(parts[0], verts.size));
-						if (parts.length > 2) {
-							if (i == 1) activeGroup.hasNorms = true;
-							faces.add(getIndex(parts[2], norms.size));
-						}
-						if (parts.length > 1 && parts[1].length() > 0) {
-							if (i == 1) activeGroup.hasUVs = true;
-							faces.add(getIndex(parts[1], uvs.size));
-						}
-						parts = tokens[++i].split("/");
-						faces.add(getIndex(parts[0], verts.size));
-						if (parts.length > 2) faces.add(getIndex(parts[2], norms.size));
-						if (parts.length > 1 && parts[1].length() > 0) faces.add(getIndex(parts[1], uvs.size));
-						parts = tokens[++i].split("/");
-						faces.add(getIndex(parts[0], verts.size));
-						if (parts.length > 2) faces.add(getIndex(parts[2], norms.size));
-						if (parts.length > 1 && parts[1].length() > 0) faces.add(getIndex(parts[1], uvs.size));
-						activeGroup.numFaces++;
-					}
-				} else if (firstChar == 'o' || firstChar == 'g') {
-					// This implementation only supports single object or group
-					// definitions. i.e. "o group_a group_b" will set group_a
-					// as the active group, while group_b will simply be
-					// ignored.
-					if (tokens.length > 1)
-						activeGroup = setActiveGroup(tokens[1]);
-					else
-						activeGroup = setActiveGroup("default");
-				} else if (tokens[0].equals("mtllib")) {
-					String path = "";
-					if (file.path().contains("/")) {
-						path = file.path().substring(0, file.path().lastIndexOf('/') + 1);
-					}
-					mtl.load(path + tokens[1], textureDir);
-				} else if (tokens[0].equals("usemtl")) {
-					if (tokens.length == 1)
-						activeGroup.materialName = "default";
-					else
-						activeGroup.materialName = tokens[1];
-				}
-			}
-			reader.close();
-		} catch (IOException e) {
-			return null;
-		}
-
-		// If the "default" group or any others were not used, get rid of them
-		for (int i = 0; i < groups.size(); i++) {
-			if (groups.get(i).numFaces < 1) {
-				groups.remove(i);
-				i--;
-			}
-		}
-
-		// If there are no groups left, there is no valid Model to return
-		if (groups.size() < 1) return null;
-
-		// Get number of objects/groups remaining after removing empty ones
-		final int numGroups = groups.size();
-
-		final StillModel model = new StillModel(new StillSubMesh[numGroups]);
-
-		for (int g = 0; g < numGroups; g++) {
-			Group group = groups.get(g);
-			ArrayList<Integer> faces = group.faces;
-			final int numElements = faces.size();
-			final int numFaces = group.numFaces;
-			final boolean hasNorms = group.hasNorms;
-			final boolean hasUVs = group.hasUVs;
-
-			final float[] finalVerts = new float[(numFaces * 3) * (3 + (hasNorms ? 3 : 0) + (hasUVs ? 2 : 0))];
-
-			for (int i = 0, vi = 0; i < numElements;) {
-				int vertIndex = faces.get(i++) * 3;
-				finalVerts[vi++] = verts.get(vertIndex++);
-				finalVerts[vi++] = verts.get(vertIndex++);
-				finalVerts[vi++] = verts.get(vertIndex);
-				if (hasNorms) {
-					int normIndex = faces.get(i++) * 3;
-					finalVerts[vi++] = norms.get(normIndex++);
-					finalVerts[vi++] = norms.get(normIndex++);
-					finalVerts[vi++] = norms.get(normIndex);
-				}
-				if (hasUVs) {
-					int uvIndex = faces.get(i++) * 2;
-					finalVerts[vi++] = uvs.get(uvIndex++);
-					finalVerts[vi++] = uvs.get(uvIndex);
-				}
-			}
-
-			final int numIndices = numFaces * 3 >= Short.MAX_VALUE ? 0 : numFaces * 3;
-			final short[] finalIndices = new short[numIndices];
-			// if there are too many vertices in a mesh, we can't use indices
-			if (numIndices > 0) {
-				for (int i = 0; i < numIndices; i++) {
-					finalIndices[i] = (short)i;
-				}
-			}
-			final Mesh mesh;
-
-			ArrayList<VertexAttribute> attributes = new ArrayList<VertexAttribute>();
-			attributes.add(new VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE));
-			if (hasNorms) attributes.add(new VertexAttribute(Usage.Normal, 3, ShaderProgram.NORMAL_ATTRIBUTE));
-			if (hasUVs) attributes.add(new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + "0"));
-
-			mesh = new Mesh(true, numFaces * 3, numIndices, attributes.toArray(new VertexAttribute[attributes.size()]));
-			mesh.setVertices(finalVerts);
-			if (numIndices > 0) mesh.setIndices(finalIndices);
-
-			StillSubMesh subMesh = new StillSubMesh(group.name, mesh, GL10.GL_TRIANGLES);
-			subMesh.material = mtl.getMaterial(group.materialName);
-			model.subMeshes[g] = subMesh;
-
-		}
-
-		// An instance of ObjLoader can be used to load more than one OBJ.
-		// Clearing the ArrayList cache instead of instantiating new
-		// ArrayLists should result in slightly faster load times for
-		// subsequent calls to loadObj
-		if (verts.size > 0) verts.clear();
-		if (norms.size > 0) norms.clear();
-		if (uvs.size > 0) uvs.clear();
-		if (groups.size() > 0) groups.clear();
-
-		return model;
-	}
-
-	private Group setActiveGroup (String name) {
-		// TODO: Check if a HashMap.get calls are faster than iterating
-		// through an ArrayList
-		for (Group group : groups) {
-			if (group.name.equals(name)) return group;
-		}
-		Group group = new Group(name);
-		groups.add(group);
-		return group;
-	}
-
-	private int getIndex (String index, int size) {
-		if (index == null || index.length() == 0) return 0;
-		final int idx = Integer.parseInt(index);
-		if (idx < 0)
-			return size + idx;
-		else
-			return idx - 1;
-	}
-
-	private class Group {
-		final String name;
-		String materialName;
-		ArrayList<Integer> faces;
-		int numFaces;
-		boolean hasNorms;
-		boolean hasUVs;
-		Material mat;
-
-		Group (String name) {
-			this.name = name;
-			this.faces = new ArrayList<Integer>(200);
-			this.numFaces = 0;
-			this.mat = new Material("");
-			this.materialName = "default";
-		}
-	}
-
-	@Override
-	public StillModel load (FileHandle handle, ModelLoaderHints hints) {
-		return loadObj(handle, hints.flipV);
-	}
-}
-
-class MtlLoader {
-	private ArrayList<Material> materials = new ArrayList<Material>();
-	private static AssetManager assetManager;
-	private static Texture emptyTexture = null;
-
-	public MtlLoader () {
-		if (emptyTexture == null) {
-			assetManager = new AssetManager();
-			Pixmap pm = new Pixmap(1, 1, Format.RGB888);
-			pm.setColor(0.5f, 0.5f, 0.5f, 1);
-			pm.fill();
-			emptyTexture = new Texture(pm, false);
-		}
-	}
-
-	/** loads .mtl file
-	 * @param name */
-	public void load (String name, FileHandle textureDir) {
-		String line;
-		String[] tokens;
-		String curMatName = "default";
-		Color difcolor = Color.WHITE;
-		Color speccolor = Color.WHITE;
-		Texture texture = emptyTexture;
-
-		FileHandle file = Gdx.files.internal(name);
-		if (file == null || file.exists() == false) return;
-
-		BufferedReader reader = new BufferedReader(new InputStreamReader(file.read()), 4096);
-		try {
-			while ((line = reader.readLine()) != null) {
-
-				if (line.length() > 0 && line.charAt(0) == '\t') line = line.substring(1).trim();
-
-				tokens = line.split("\\s+");
-
-				if (tokens[0].length() == 0) {
-					continue;
-				} else if (tokens[0].charAt(0) == '#')
-					continue;
-				else if (tokens[0].toLowerCase().equals("newmtl")) {
-					Material mat = new Material(curMatName, new TextureAttribute(texture, 0, TextureAttribute.diffuseTexture),
-						new ColorAttribute(difcolor, ColorAttribute.diffuse), new ColorAttribute(speccolor, ColorAttribute.specular));
-					materials.add(mat);
-
-					if (tokens.length > 1) {
-						curMatName = tokens[1];
-						curMatName = curMatName.replace('.', '_');
-					} else
-						curMatName = "default";
-
-					difcolor = Color.WHITE;
-					speccolor = Color.WHITE;
-				} else if (tokens[0].toLowerCase().equals("kd") || tokens[0].toLowerCase().equals("ks")) // diffuse or specular
-				{
-					float r = Float.parseFloat(tokens[1]);
-					float g = Float.parseFloat(tokens[2]);
-					float b = Float.parseFloat(tokens[3]);
-					float a = 1;
-					if (tokens.length > 4) a = Float.parseFloat(tokens[4]);
-
-					if (tokens[0].toLowerCase().equals("kd")) {
-						difcolor = new Color();
-						difcolor.set(r, g, b, a);
-					} else {
-						speccolor = new Color();
-						speccolor.set(r, g, b, a);
-					}
-				} else if (tokens[0].toLowerCase().equals("map_kd")) {
-					String textureName = tokens[1];
-					if (textureName.length() > 0) {
-						String texname = textureDir.child(textureName).toString();
-						assetManager.load(texname, Texture.class);
-						assetManager.finishLoading();
-						texture = assetManager.get(texname, Texture.class);
-						texture.setFilter(TextureFilter.Linear, TextureFilter.Linear);
-					} else
-						texture = emptyTexture;
-
-				}
-
-			}
-			reader.close();
-		} catch (IOException e) {
-			return;
-		}
-
-		// last material
-		Material mat = new Material(curMatName, new TextureAttribute(texture, 0, TextureAttribute.diffuseTexture),
-			new ColorAttribute(difcolor, ColorAttribute.diffuse), new ColorAttribute(speccolor, ColorAttribute.specular));
-		materials.add(mat);
-
-		return;
-	}
-
-	public Material getMaterial (String name) {
-		name = name.replace('.', '_');
-		for (Material mat : materials) {
-			if (mat.getName().equals(name)) return mat;
-		}
-		return new Material("default");
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/materials/BlendingAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/materials/BlendingAttribute.java
index 67fe84c..96b5374 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/materials/BlendingAttribute.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/materials/BlendingAttribute.java
@@ -1,88 +1,40 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
 package com.badlogic.gdx.graphics.g3d.materials;
 
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.graphics.GL10;
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-import com.badlogic.gdx.utils.Pool;
-
-public class BlendingAttribute extends MaterialAttribute {
-
-	/** if BlendingAttribute name is translucent then default tranparency mechanism is used in shader */
-	public static final String translucent = "translucent";
+import com.badlogic.gdx.graphics.g3d.materials.NewMaterial.Attribute;
 
-	public int blendSrcFunc;
-	public int blendDstFunc;
-
-	protected BlendingAttribute () {
+public class BlendingAttribute extends NewMaterial.Attribute {
+	public final static String Alias = "blended";
+	public final static long Type = register(Alias);
+	
+	public final static boolean is(final long mask) {
+		return (mask & Type) == mask;
 	}
+ 
+	public int sourceFunction;
+	public int destFunction;
 
-	/** Utility constuctor for basic transparency blendSrcFunc = GL10.GL_SRC_ALPHA blendDstFunc = GL10.GL_ONE_MINUS_SRC_ALPHA
-	 * @param name */
-	public BlendingAttribute (String name) {
-		this(name, GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
+	public BlendingAttribute() { 
+		super(Type); 
 	}
-
-	public BlendingAttribute (String name, int srcFunc, int dstFunc) {
-		super(name);
-		blendSrcFunc = srcFunc;
-		blendDstFunc = dstFunc;
+	
+	public BlendingAttribute(final int sourceFunc, final int destFunc) {
+		this();
+		sourceFunction = sourceFunc;
+		destFunction = destFunc;
 	}
-
-	@Override
-	public void bind () {
-		Gdx.gl.glBlendFunc(blendSrcFunc, blendDstFunc);
+	
+	public BlendingAttribute(final BlendingAttribute copyFrom) {
+		this(copyFrom == null ? 0 : copyFrom.sourceFunction, copyFrom == null ? 0 : copyFrom.destFunction);
 	}
-
+	
 	@Override
-	public void bind (ShaderProgram program) {
-		Gdx.gl.glBlendFunc(blendSrcFunc, blendDstFunc);
+	public BlendingAttribute copy () {
+		return new BlendingAttribute(this);
 	}
-
-	@Override
-	public MaterialAttribute copy () {
-		return new BlendingAttribute(this.name, this.blendSrcFunc, this.blendDstFunc);
-	}
-
-	@Override
-	public void set (MaterialAttribute attr) {
-		BlendingAttribute blendAttr = (BlendingAttribute)attr;
-		name = blendAttr.name;
-		blendDstFunc = blendAttr.blendDstFunc;
-		blendSrcFunc = blendAttr.blendSrcFunc;
-	}
-
-	private final static Pool<BlendingAttribute> pool = new Pool<BlendingAttribute>() {
-		@Override
-		protected BlendingAttribute newObject () {
-			return new BlendingAttribute();
-		}
-	};
-
-	@Override
-	public MaterialAttribute pooledCopy () {
-		BlendingAttribute attr = pool.obtain();
-		attr.set(this);
-		return attr;
-	}
-
+	
 	@Override
-	public void free () {
-		if (isPooled) pool.free(this);
+	protected boolean equals (final Attribute other) {
+		return ((BlendingAttribute)other).sourceFunction == sourceFunction && 
+			((BlendingAttribute)other).destFunction == destFunction; 
 	}
-}
+}
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/materials/ColorAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/materials/ColorAttribute.java
index 10153f8..e0cc828 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/materials/ColorAttribute.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/materials/ColorAttribute.java
@@ -1,96 +1,55 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
 package com.badlogic.gdx.graphics.g3d.materials;
 
-import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.Color;
-import com.badlogic.gdx.graphics.GL10;
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-import com.badlogic.gdx.utils.Pool;
-
-public class ColorAttribute extends MaterialAttribute {
-
-	static final public String diffuse = "diffuseColor";
-	static final public String specular = "specularColor";
-	static final public String emissive = "emissiveColor";
-	static final public String rim = "rimColor";
-	static final public String fog = "fogColor";
-
+import com.badlogic.gdx.graphics.g3d.materials.NewMaterial.Attribute;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+public class ColorAttribute extends NewMaterial.Attribute {
+	public final static String DiffuseAlias = "diffuseColor";
+	public final static long Diffuse = register(DiffuseAlias);
+	public final static String SpecularAlias = "specularColor";
+	public final static long Specular = register(SpecularAlias);
+	
+	// Might be useful:...
+	protected static long Mask = Diffuse | Specular;
+	
+	public final static boolean is(final long mask) {
+		return (mask & Mask) != 0;
+	}
+	
+	public final static ColorAttribute createDiffuse(final Color color) {
+		return new ColorAttribute(Diffuse, color);
+	}
+	
+	public final static ColorAttribute createSpecular(final Color color) {
+		return new ColorAttribute(Specular, color);
+	}
+	
 	public final Color color = new Color();
-
-	protected ColorAttribute () {
+	
+	public ColorAttribute(final long type) {
+		this(type, null);
 	}
-
-	/** Creates a {@link MaterialAttribute} that is a pure {@link Color}.
-	 * 
-	 * @param color The {@link Color} that you wish the attribute to represent.
-	 * @param name The name of the uniform in the {@link ShaderProgram} that will have its value set to this color. (A 'name' does
-	 *           not matter for a game that uses {@link GL10}). */
-	public ColorAttribute (Color color, String name) {
-		super(name);
-		this.color.set(color);
+	
+	public ColorAttribute(final long type, final Color color) {
+		super(type);
+		if (!is(type))
+			throw new GdxRuntimeException("Invalid type specified");
+		if (color != null)
+			this.color.set(color);
 	}
-
-	@Override
-	public void bind () {
-		if (Gdx.gl10 == null) throw new RuntimeException("Can't call ColorAttribute.bind() in a GL20 context");
-
-		// todo how about emissive or specular?
-		// TODO replace string equals with something more performant
-		if (diffuse.equals(diffuse)) Gdx.gl10.glColor4f(color.r, color.g, color.b, color.a);
+	
+	public ColorAttribute(final ColorAttribute copyFrom) {
+		this(copyFrom.type, copyFrom.color);
 	}
 
 	@Override
-	public void bind (ShaderProgram program) {
-		program.setUniformf(name, color.r, color.g, color.b, color.a);
-	}
-
-	@Override
-	public MaterialAttribute copy () {
-		return new ColorAttribute(color, name);
-	}
-
-	@Override
-	public void set (MaterialAttribute attr) {
-		ColorAttribute colAttr = (ColorAttribute)attr;
-		name = colAttr.name;
-		final Color c = colAttr.color;
-		color.r = c.r;
-		color.g = c.g;
-		color.b = c.b;
-		color.a = c.a;
-	}
-
-	private final static Pool<ColorAttribute> pool = new Pool<ColorAttribute>() {
-		@Override
-		protected ColorAttribute newObject () {
-			return new ColorAttribute();
-		}
-	};
-
-	@Override
-	public MaterialAttribute pooledCopy () {
-		ColorAttribute attr = pool.obtain();
-		attr.set(this);
-		return attr;
+	public Attribute copy () {
+		return new ColorAttribute(this);
 	}
 
 	@Override
-	public void free () {
-		if (isPooled) pool.free(this);
+	protected boolean equals (Attribute other) {
+		return ((ColorAttribute)other).color.equals(color);
 	}
-}
+}
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/materials/Material.java b/gdx/src/com/badlogic/gdx/graphics/g3d/materials/Material.java
deleted file mode 100644
index 1936b24..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/materials/Material.java
+++ /dev/null
@@ -1,226 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.materials;
-
-import java.util.Iterator;
-
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-import com.badlogic.gdx.utils.Array;
-
-public class Material implements Iterable<MaterialAttribute> {
-	protected String name;
-	private Array<MaterialAttribute> attributes;
-
-	/** This flag is true if material contain blendingAttribute */
-	protected boolean needBlending;
-	/** This flag is true if material contain TextureAttribute */
-	protected boolean hasTexture;
-
-	protected ShaderProgram shader;
-
-	public Material () {
-		attributes = new Array<MaterialAttribute>(2);
-	}
-
-	public Material (String name, Array<MaterialAttribute> attributes) {
-		this.name = name;
-		this.attributes = attributes;
-
-		checkAttributes();
-	}
-
-	public Material (String name, MaterialAttribute... attributes) {
-		this(name, new Array<MaterialAttribute>(attributes));
-	}
-	
-	protected void checkAttributes() {
-		// this way we foresee if blending is needed with this material and rendering can deferred more easily
-		this.needBlending = false;
-		this.hasTexture = false;
-		for (int i = 0; i < this.attributes.size; i++) {
-			if (!needBlending && this.attributes.get(i) instanceof BlendingAttribute)
-				this.needBlending = true;
-			else if (!hasTexture && this.attributes.get(i) instanceof TextureAttribute)
-				this.hasTexture = true;
-		}		
-	}
-
-	public void bind () {
-		for (int i = 0; i < attributes.size; i++) {
-			attributes.get(i).bind();
-		}
-	}
-
-	public void bind (ShaderProgram program) {
-		for (int i = 0; i < attributes.size; i++) {
-			attributes.get(i).bind(program);
-		}
-	}
-
-	public String getName () {
-		return name;
-	}
-	
-	public void addAttribute(MaterialAttribute... attributes){
-		for (int i = 0; i < attributes.length; i++) {
-			if(attributes[i] instanceof BlendingAttribute)
-				needBlending = true;
-			else if (attributes[i] instanceof TextureAttribute)
-				hasTexture = true;
-			this.attributes.add(attributes[i]);
-		}
-	}
-	
-	public void removeAttribute(MaterialAttribute... attributes){
-		for (int i = 0; i < attributes.length; i++)
-			this.attributes.removeValue(attributes[i], true);
-		checkAttributes();
-	}
-	
-	public void clearAttributes(){
-		attributes.clear();
-		needBlending = false;
-	}
-	
-	public MaterialAttribute getAttribute(int index){
-		if(index >= 0 && index < attributes.size)
-			return attributes.get(index);
-		return null;
-	}
-	
-	public int getNumberOfAttributes(){
-		return attributes.size;
-	}
-	
-//	/** @return True if this material contains attribute of the specified type, false otherwise */
-//	public <T extends MaterialAttribute> boolean hasAttribute(Class<T> type) {
-//		return indexOfAttribute(type) >= 0;
-//	}
-//	
-//	/** @return The index of the first attribute of the specified type or -1 if not available */
-//	public <T extends MaterialAttribute> int indexOfAttribute(Class<T> type) {
-//		for (int i = 0; i < attributes.size; i++)
-//			if (type.isInstance(attributes.get(i)))
-//				return i;
-//		return -1;
-//	}
-//	
-//	/** @return The first attribute of the specified type, or null if not available */
-//	public <T extends MaterialAttribute> T getAttribute(Class<T> type) {
-//		return (T)getAttribute(indexOfAttribute(type));
-//	}
-
-	public Material copy () {
-		Array<MaterialAttribute> attributes = new Array<MaterialAttribute>(this.attributes.size);
-		for (int i = 0; i < attributes.size; i++) {
-			attributes.add(this.attributes.get(i).copy());
-		}
-		final Material copy = new Material(name, attributes);
-		copy.shader = this.shader;
-		return copy;
-	}
-
-	@Override
-	public int hashCode () {
-		final int prime = 31;
-		int result = 1;
-		result = prime * result + attributes.hashCode();
-		result = prime * result + ((name == null) ? 0 : name.hashCode());
-		return result;
-	}
-
-	@Override
-	public boolean equals (Object obj) {
-		if (this == obj) return true;
-		if (obj == null) return false;
-		if (getClass() != obj.getClass()) return false;
-		Material other = (Material)obj;
-		if (other.attributes.size != attributes.size) return false;
-		for (int i = 0; i < attributes.size; i++) {
-			if (!attributes.get(i).equals(other.attributes.get(i))) return false;
-		}
-		if (name == null) {
-			if (other.name != null) return false;
-		} else if (!name.equals(other.name)) return false;
-		return true;
-	}
-
-	public boolean shaderEquals (Material other) {
-		if (this == other) return true;
-
-		int len = this.attributes.size;
-		if (len != other.attributes.size) return false;
-
-		for (int i = 0; i < len; i++) {
-			final String str = this.attributes.get(i).name;
-			if (str == null) return false;
-
-			boolean matchFound = false;
-			for (int j = 0; j < len; j++) {
-				if (str.equals(other.attributes.get(j).name)) {
-					matchFound = true;
-					break;
-				}
-			}
-			if (!matchFound) return false;
-		}
-
-		return true;
-	}
-
-	public void setPooled (Material material) {
-		name = material.name;
-		shader = material.shader;
-		needBlending = material.needBlending;
-		hasTexture = material.hasTexture;
-		attributes.clear();
-		for (int i = 0, len = material.attributes.size; i < len; i++) {
-			attributes.add(material.attributes.get(i).pooledCopy());
-		}
-	}
-
-	public boolean isNeedBlending () {
-		return needBlending;
-	}
-	
-	public boolean hasTexture() {
-		return hasTexture;
-	}
-
-	public ShaderProgram getShader () {
-		return shader;
-	}
-	
-	public void setShader(final ShaderProgram shader) {
-		this.shader = shader;
-	}
-	
-	public void resetShader () {
-		shader = null;
-	}
-
-	@Override
-	public Iterator<MaterialAttribute> iterator () {
-		return attributes.iterator();
-	}
-
-	/* TODO: Sits in Experimental only used for ProtoRenderer
-	public void generateShader (MaterialShaderHandler materialShaderHandler) {
-		shader = materialShaderHandler.getShader(this);
-	}
-	*/
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/materials/MaterialAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/materials/MaterialAttribute.java
deleted file mode 100644
index e91e4ec..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/materials/MaterialAttribute.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.materials;
-
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-
-public abstract class MaterialAttribute {
-	private static final String FLAG = "Flag";
-	public String name;
-	protected final boolean isPooled;
-
-	protected MaterialAttribute () {
-		isPooled = true;
-	}
-
-	public MaterialAttribute (String name) {
-		this.name = name;
-		isPooled = false;
-	}
-
-	public abstract void bind ();
-
-	public abstract void bind (ShaderProgram program);
-
-	public abstract MaterialAttribute copy ();
-
-	public abstract MaterialAttribute pooledCopy ();
-
-	public abstract void free ();
-
-	public abstract void set (MaterialAttribute attr);
-
-	public String getShaderFlag () {
-		return name + FLAG;
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/materials/NewMaterial.java b/gdx/src/com/badlogic/gdx/graphics/g3d/materials/NewMaterial.java
new file mode 100644
index 0000000..ded76e8
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/materials/NewMaterial.java
@@ -0,0 +1,230 @@
+package com.badlogic.gdx.graphics.g3d.materials;
+
+import java.util.Comparator;
+import java.util.Iterator;
+
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.utils.Array;
+
+public class NewMaterial implements Iterable<NewMaterial.Attribute>, Comparator<NewMaterial.Attribute> {
+	/** Extend this class to implement a material attribute.
+	 *  Register the attribute type by statically calling the {@link #register(String)} method, 
+	 *  whose return value should be used to instantiate the attribute. 
+	 *  A class can implement multiple types*/
+	public static abstract class Attribute {
+		protected static long register(final String type) {
+			return NewMaterial.register(type);
+		}
+		/** The type of this attribute */
+		protected long type;
+		protected Attribute(final long type) {
+			this.type = type;
+		}
+		/** @return The type of material */
+		public final long getType() {
+			return type;
+		}
+		/** @return An exact copy of this attribute */
+		public abstract Attribute copy(); 
+		protected abstract boolean equals(Attribute other);
+		@Override
+		public boolean equals (Object obj) {
+			if (obj == null) return false;
+			if (obj == this) return true;
+			if (!(obj instanceof Attribute)) return false;
+			final Attribute other = (Attribute)obj;
+			if (other.type != other.type) return false; 
+			return equals(other);
+		}
+	}
+	
+	/** The registered type aliases */
+	private final static Array<String> types = new Array<String>();
+	
+	/** @return The ID of the specified attribute type, or zero if not available */
+	protected final static long getAttributeType(final String alias) {
+		for (int i = 0; i < types.size; i++)
+			if (types.get(i).compareTo(alias)==0)
+				return 1L << i;
+		return 0;
+	}
+	
+	/** Use {@link Attribute#register(String)} instead */ 
+	protected final static long register(final String alias) {
+		long result = getAttributeType(alias);
+		if (result > 0)
+			return result;
+		types.add(alias);
+		return 1L << (types.size - 1);
+	}
+	
+	protected long mask;
+	protected Array<Attribute> attributes = new Array<Attribute>();
+	protected boolean sorted = true;
+	
+	/** Create an empty material */
+	public NewMaterial() {	}
+	/** Create a material with the specified attributes */
+	public NewMaterial(final Attribute... attributes) {
+		add(attributes);
+	}
+	/** Create a material with the specified attributes */
+	public NewMaterial(final Array<Attribute> attributes) {
+		add(attributes);
+	}
+	/** Create a material which is an exact copy of the specified material */
+	public NewMaterial(final NewMaterial copyFrom) {
+		for (Attribute attr : copyFrom)
+			add(attr.copy());
+	}
+	
+	private final void enable(final long mask) {
+		this.mask |= mask; 
+	}
+	private final void disable(final long mask) {
+		this.mask &= -1L ^ mask;
+	}
+	
+	/** @return Bitwise mask of the ID's of all the containing attributes */  
+	public final long getMask() {
+		return mask;
+	}
+	
+	/** @return True if this material has the specified attribute, i.e. material.has(BlendingAttribute.ID); */
+	public final boolean has(final long type) {
+		return type > 0 && (this.mask & type) == type;
+	}
+	
+	/** @deprecated Use {@link #has(long)} instead
+	 * @return True if this material has the specified attribute, i.e. material.has(BlendingAttribute.class); */
+	public final boolean has(final String type) {
+		return has(getAttributeType(type));
+	}
+	
+	/** Add one or more attributes to this material */
+	public final void add(final Attribute... attributes) {
+		for (int i = 0; i < attributes.length; i++) {
+			final Attribute attr = attributes[i];
+			if (!has(attr.type)) {
+				enable(attr.type);
+				this.attributes.add(attr);
+				sorted = false;
+			}
+		}
+	}
+
+	/** Add an array of attributes to this material */
+	public final void add(final Array<Attribute> attributes) {
+		for (int i = 0; i < attributes.size; i++) {
+			final Attribute attr = attributes.get(i);
+			if (!has(attr.type)) {
+				enable(attr.type);
+				this.attributes.add(attr);
+				sorted = false;
+			}
+		}
+	}
+	
+	/** Removes the attribute from the material, i.e.: material.remove(BlendingAttribute.ID);
+	 * Can also be used to remove multiple attributes also, i.e. remove(AttributeA.ID | AttributeB.ID); */
+	public final void remove(final long mask) {
+		for (int i = 0; i < attributes.size; i++) {
+			final long type = attributes.get(i).type;
+			if ((mask & type) == type) {
+				attributes.removeIndex(i);
+				disable(type);
+				sorted = false;
+			}
+		}
+	}
+	
+	/** @deprecated Use {@link #remove(long)} instead
+	 * Removes the attribute from the material, i.e.: material.remove(BlendingAttribute.class); */
+	public final void remove(final String alias) {
+		final long type = getAttributeType(alias);
+		if (has(type)) {
+			for (int i = 0; i < attributes.size; i++)
+				if (attributes.get(i).type == type) {
+					attributes.removeIndex(i);
+					break;
+				}
+			sorted = false;
+			disable(type);
+		}
+	}
+	
+	/** Example usage: ((BlendingAttribute)material.get(BlendingAttribute.ID)).sourceFunction;
+	 * @return The attribute (which can safely be cast) if any, otherwise null */
+	public final Attribute get(final long type) {
+		if (has(type))
+			for (int i = 0; i < attributes.size; i++)
+				if (attributes.get(i).type == type)
+					return attributes.get(i);
+		return null;
+	}
+	
+	/** Get multiple attributes at once.
+	 * Example: material.get(out, AttributeA.ID | AttributeB.ID | AttributeC.ID); */
+	public final Array<Attribute> get(final Array<Attribute> out, final long type) {
+		for (int i = 0; i < attributes.size; i++)
+			if ((attributes.get(i).type & type) != 0)
+				out.add(attributes.get(i));
+		return out;
+	}
+	
+	/** Removes all attributes */
+	public final void clear() {
+		mask = 0;
+		attributes.clear();
+	}
+	
+	/** Create a copy of this material */
+	public final NewMaterial copy() {
+		return new NewMaterial(this); 
+	}
+
+	/** Used for sorting attributes */
+	@Override
+	public final int compare (final Attribute arg0, final Attribute arg1) {
+		return (int)(arg0.type - arg1.type);
+	}
+	
+	/** Sort the attributes by their ID */
+	public final void sort() {
+		if (!sorted) {
+			attributes.sort(this);
+			sorted = true;
+		}
+	}
+	
+	/** @return True if this material contains the same attributes as the other, 
+	 * use {@link #equals(NewMaterial)} to see if the values are also the same */
+	public final boolean same(final NewMaterial other) {
+		return mask == other.mask;
+	}
+	
+	/** @return True if this material equals the other material in every aspect */
+	public final boolean equals (final NewMaterial other) {
+		if (other == null) return false;
+		if (other == this) return true;
+		if (!same(other)) return false;
+		sort();
+		other.sort();
+		for (int i = 0; i < attributes.size; i++)
+			if (!attributes.get(i).equals(other.attributes.get(i)))
+				return false;
+		return true;
+	}
+	
+	/** @return True if this material equals the other material in every aspect */
+	@Override
+	public final boolean equals (final Object obj) {
+		return obj instanceof NewMaterial ? equals((NewMaterial)obj) : false;
+	}
+	
+	/** Used for iterating through the attributes */
+	@Override
+	public final Iterator<Attribute> iterator () {
+		return attributes.iterator();
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/materials/TextureAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/materials/TextureAttribute.java
index 056a6e7..724bbe3 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/materials/TextureAttribute.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/materials/TextureAttribute.java
@@ -1,128 +1,47 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
 package com.badlogic.gdx.graphics.g3d.materials;
 
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.Texture;
-import com.badlogic.gdx.graphics.Texture.TextureFilter;
-import com.badlogic.gdx.graphics.Texture.TextureWrap;
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-import com.badlogic.gdx.utils.Pool;
-
-public class TextureAttribute extends MaterialAttribute {
-
-	public final static int MAX_TEXTURE_UNITS = 16;
-	static final public String diffuseTexture = "diffuseTexture";
-	static final public String lightmapTexture = "lightmapTexture";
-	static final public String specularTexture = "specularTexture";
-
-	public Texture texture;
-	public int unit;
-	public int minFilter;
-	public int magFilter;
-	public int uWrap;
-	public int vWrap;
-
-	protected TextureAttribute () {
-	}
-
-	public TextureAttribute (Texture texture, int unit, String name, TextureFilter minFilter, TextureFilter magFilter,
-		TextureWrap uWrap, TextureWrap vWrap) {
-		this(texture, unit, name, minFilter.getGLEnum(), magFilter.getGLEnum(), uWrap.getGLEnum(), vWrap.getGLEnum());
-	}
-
-	public TextureAttribute (Texture texture, int unit, String name, int minFilter, int magFilter, int uWrap, int vWrap) {
-		super(name);
-		this.texture = texture;
-		if (unit > MAX_TEXTURE_UNITS) throw new RuntimeException(MAX_TEXTURE_UNITS + " is max texture units supported");
-		this.unit = unit;
-		this.uWrap = uWrap;
-		this.vWrap = vWrap;
-		this.minFilter = minFilter;
-		this.magFilter = magFilter;
-	}
-
-	public TextureAttribute (Texture texture, int unit, String name) {
-		this(texture, unit, name, texture.getMinFilter(), texture.getMagFilter(), texture.getUWrap(), texture.getVWrap());
-	}
-
-	@Override
-	public void bind () {
-		texture.bind(unit);
-		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER, minFilter);
-		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER, magFilter);
-		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_S, uWrap);
-		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_T, vWrap);
-	}
-
-	@Override
-	public void bind (ShaderProgram program) {
-		texture.bind(unit);
-		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER, minFilter);
-		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER, magFilter);
-		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_S, uWrap);
-		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_T, vWrap);
-		program.setUniformi(name, unit);
-	}
-
-	@Override
-	public MaterialAttribute copy () {
-		return new TextureAttribute(texture, unit, name, minFilter, magFilter, uWrap, vWrap);
-	}
-
-	@Override
-	public void set (MaterialAttribute attr) {
-		TextureAttribute texAttr = (TextureAttribute)attr;
-		name = texAttr.name;
-		texture = texAttr.texture;
-		unit = texAttr.unit;
-		magFilter = texAttr.magFilter;
-		minFilter = texAttr.minFilter;
-		uWrap = texAttr.uWrap;
-		vWrap = texAttr.vWrap;
-	}
-
-	/** this method check if the texture portion of texture attribute is equal, name isn't used */
-	public boolean texturePortionEquals (TextureAttribute other) {
-		if (other == null) return false;
-		if (this == other) return true;
-
-		return (texture == other.texture) && (unit == other.unit) && (minFilter == other.minFilter)
-			&& (magFilter == other.magFilter) && (uWrap == other.uWrap) && (vWrap == other.vWrap);
-
-	}
-
-	private final static Pool<TextureAttribute> pool = new Pool<TextureAttribute>() {
-		@Override
-		protected TextureAttribute newObject () {
-			return new TextureAttribute();
-		}
-	};
-
+import com.badlogic.gdx.graphics.g3d.materials.NewMaterial.Attribute;
+import com.badlogic.gdx.graphics.g3d.utils.TextureDescription;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+public class TextureAttribute extends NewMaterial.Attribute {
+	public final static String DiffuseAlias = "diffuseTexture";
+	public final static long Diffuse = register(DiffuseAlias);
+	public final static String SpecularAlias = "specularTexture";
+	public final static long Specular = register(SpecularAlias);
+	
+	// Might be useful:...
+	protected static long Mask = Diffuse | Specular;
+	
+	public final static boolean is(final long mask) {
+		return (mask & Mask) != 0;
+	}
+	
+	public final TextureDescription textureDescription;
+	
+	public TextureAttribute(final long type, final TextureDescription textureDescription) {
+		super(type);
+		if (!is(type))
+			throw new GdxRuntimeException("Invalid type specified");
+		this.textureDescription = textureDescription;
+	}
+	
+	public TextureAttribute(final long type) {
+		this(type, null);
+	}
+	
+	public TextureAttribute(final TextureAttribute copyFrom) {
+		this(copyFrom.getType(), copyFrom.textureDescription);
+	}
+	
 	@Override
-	public MaterialAttribute pooledCopy () {
-		TextureAttribute attr = pool.obtain();
-		attr.set(this);
-		return attr;
+	public Attribute copy () {
+		return new TextureAttribute(this);
 	}
 
 	@Override
-	public void free () {
-		if (isPooled) pool.free(this);
+	protected boolean equals (Attribute other) {
+		return ((TextureAttribute)other).textureDescription.equals(textureDescription);
 	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/AnimatedModel.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/AnimatedModel.java
deleted file mode 100644
index 31609d6..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/AnimatedModel.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.model;
-
-public interface AnimatedModel extends Model {
-	/** Start playing the given animation at the given time in the animation and specify wether or not the animation will loop.
-	 * @param animation The name of the animation in this {@link Model} that you should play.
-	 * @param time The time, in seconds, of the section to start the animation.
-	 * @param loop Whether or not the animation will loop if the time is after the end of the animation. (TODO what happens when
-	 *           you reach the end of the animation and this is not set?) */
-	public void setAnimation (String animation, float time, boolean loop);
-
-	/** Get a specific named animation out of the model.
-	 * @param name The name of the animation that you wish to get.
-	 * @return The Animation that you requested; or, if the animation does not exist, null is returned. */
-	public Animation getAnimation (String name);
-
-	/** Get an array containing all of the animations in this model.
-	 * @return An array containing a list of all of the animations in this model. */
-	public Animation[] getAnimations ();
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/Animation.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/Animation.java
deleted file mode 100644
index d8709b6..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/Animation.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.model;
-
-public class Animation {
-	public final String name;
-	public final float totalDuration;
-
-	public Animation (String name, float totalDuration) {
-		this.name = name;
-		this.totalDuration = totalDuration;
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/JsonModel.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/JsonModel.java
new file mode 100644
index 0000000..964aa26
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/model/JsonModel.java
@@ -0,0 +1,19 @@
+package com.badlogic.gdx.graphics.g3d.model;
+
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+public class JsonModel {
+	public String version;
+	public ModelMesh[] meshes;
+	public ModelMaterial[] materials;
+	public ModelNode[] nodes;
+	public ModelAnimation[] animations;
+	
+	public void addMesh(ModelMesh mesh) {
+		for(ModelMesh other: meshes) {
+			if(other.id.equals(mesh.id)) {
+				throw new GdxRuntimeException("Mesh with id '" + other.id + "' already in model");
+			}
+		}
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/Model.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/Model.java
deleted file mode 100644
index cd48f8f..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/Model.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.model;
-
-import com.badlogic.gdx.graphics.GL10;
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.g3d.materials.Material;
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-import com.badlogic.gdx.math.collision.BoundingBox;
-
-public interface Model {
-	/** Renders the model using the {@link GL10} pipeline.<br />
-	 * <br />
-	 * <strong>Important:</strong> This model must have materials set before you can use this render function. Do that by using
-	 * {@link Model#setMaterials(Material...)}. */
-	public void render ();
-
-	/** Renders this model using the {@link GL20} shader pipeline.<br />
-	 * <br />
-	 * <strong>IMPORTANT:</strong> This model must have materials set before you can use this render function. Do that by using
-	 * {@link Model#setMaterials(Material...)}.
-	 * @param program The shader program that you will use to draw this object to the screen. It must be non-null. */
-	public void render (ShaderProgram program);
-
-	/** Returns a {@link Model} that is made up of the sub-meshes with the provided names.
-	 * @param subMeshNames A list of names of each {@link SubMesh} that is to be extracted from this model.
-	 * @return A new {@link Model} that is only made up of the parts you requested. */
-	public Model getSubModel (String... subMeshNames);
-
-	/** @param name The name of the {@link SubMesh} to be acquired.
-	 * @return The {@link SubMesh} that matches that name; or null, if one does not exist. */
-	public SubMesh getSubMesh (String name);
-
-	/** @return An array of every {@link SubMesh} that makes up this model. */
-	public SubMesh[] getSubMeshes ();
-
-	/** Generates the bounding box for the Model.<br />
-	 * <br />
-	 * For every finite 3D object there exists a box that can enclose the object. This function sets the give {@link BoundingBox}
-	 * to be one such enclosing box.<br />
-	 * Bounding boxes are useful for very basic collision detection amongst other tasks.
-	 * @param bbox The provided {@link BoundingBox} will have its internal values correctly set. (To allow Java Object reuse) */
-	public void getBoundingBox (BoundingBox bbox);
-
-	/** Sets every {@link Material} of every {@link SubMesh} in this {@link Model} to be the materials provided.
-	 * @param materials A list of the materials to set the submeshes to for this model. (The length of the list of materials must
-	 *           be the same as the number of SubMeshes in this Model. Failure to do so will result in an
-	 *           {@link UnsupportedOperationException}) */
-	public void setMaterials (Material... materials);
-
-	/** Sets the {@link Material} of every {@link SubMesh} in this Model to be the material provided.
-	 * @param material The Material that you wish the whole object to be rendered with. */
-	public void setMaterial (Material material);
-
-	/** This function releases memory once you are done with the Model. Once you are finished with the Model you MUST call this
-	 * function or else you will suffer memory leaks. */
-	public void dispose ();
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/ModelAnimation.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/ModelAnimation.java
new file mode 100644
index 0000000..fb51f5f
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/model/ModelAnimation.java
@@ -0,0 +1,5 @@
+package com.badlogic.gdx.graphics.g3d.model;
+
+public class ModelAnimation {
+
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/ModelMaterial.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/ModelMaterial.java
new file mode 100644
index 0000000..5b3ec99
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/model/ModelMaterial.java
@@ -0,0 +1,24 @@
+package com.badlogic.gdx.graphics.g3d.model;
+
+import com.badlogic.gdx.graphics.Color;
+import com.badlogic.gdx.utils.Array;
+
+public class ModelMaterial {
+	public enum MaterialType {
+		Lambert,
+		Phong
+	}
+	
+	public String id;
+	
+	public MaterialType type;
+	
+	public Color ambient;
+	public Color diffuse;
+	public Color specular;
+	public Color emissive;
+	
+	public float shininess;
+	
+	public Array<ModelTexture> diffuseTextures;
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/ModelMesh.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/ModelMesh.java
new file mode 100644
index 0000000..fd392de
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/model/ModelMesh.java
@@ -0,0 +1,10 @@
+package com.badlogic.gdx.graphics.g3d.model;
+
+import com.badlogic.gdx.graphics.VertexAttribute;
+
+public class ModelMesh {
+	public String id;
+	public VertexAttribute[] attributes;
+	public float[] vertices;
+	public ModelMeshPart[] parts;
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/ModelMeshPart.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/ModelMeshPart.java
new file mode 100644
index 0000000..a2fa862
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/model/ModelMeshPart.java
@@ -0,0 +1,7 @@
+package com.badlogic.gdx.graphics.g3d.model;
+
+public class ModelMeshPart {
+	public String id;
+	public short[] indices;
+	public int primitiveType;
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/ModelMeshPartMaterial.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/ModelMeshPartMaterial.java
new file mode 100644
index 0000000..1e205c5
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/model/ModelMeshPartMaterial.java
@@ -0,0 +1,6 @@
+package com.badlogic.gdx.graphics.g3d.model;
+
+public class ModelMeshPartMaterial {
+	public String materialId;
+	public String meshPartId;
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/ModelNode.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/ModelNode.java
new file mode 100644
index 0000000..0eb0b22
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/model/ModelNode.java
@@ -0,0 +1,15 @@
+package com.badlogic.gdx.graphics.g3d.model;
+
+import com.badlogic.gdx.math.Quaternion;
+import com.badlogic.gdx.math.Vector3;
+
+public class ModelNode {
+	public String id;
+	public int boneId = -1;
+	public Vector3 translation;
+	public Vector3 rotation;
+	public Vector3 scale;
+	public String meshId;
+	public ModelMeshPartMaterial[] meshPartMaterials;
+	public ModelNode[] children;
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/ModelTexture.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/ModelTexture.java
new file mode 100644
index 0000000..7be8473
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/model/ModelTexture.java
@@ -0,0 +1,10 @@
+package com.badlogic.gdx.graphics.g3d.model;
+
+import com.badlogic.gdx.math.Vector2;
+
+public class ModelTexture {
+	public String id;
+	public String fileName;
+	public Vector2 uvTranslation;
+	public Vector2 uvScaling;	
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/SubMesh.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/SubMesh.java
deleted file mode 100644
index 260f08f..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/SubMesh.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.model;
-
-import com.badlogic.gdx.graphics.Mesh;
-import com.badlogic.gdx.graphics.g3d.materials.Material;
-import com.badlogic.gdx.math.collision.BoundingBox;
-
-public abstract class SubMesh {
-	public String name;
-	public Material material;
-	public int primitiveType;
-	public Mesh mesh;
-
-
-	public SubMesh (String name, Mesh mesh, int primitiveType, Material material) {
-		this.name = name;
-		this.setMesh(mesh);
-		this.primitiveType = primitiveType;
-		this.material = material;
-	}
-	
-	public SubMesh (String name, Mesh mesh, int primitiveType) {
-		this(name, mesh, primitiveType, null);
-	}
-
-	/** Obtain the {@link BoundingBox} of this {@link SubMesh}.
-	 * 
-	 * @param bbox This {@link BoundingBox} will be modified so that its contain values that are the bounding box for this SubMesh. */
-	public abstract void getBoundingBox (BoundingBox bbox);
-
-	public Mesh getMesh() {
-		return mesh;
-	}
-
-	public void setMesh(Mesh mesh) {
-		this.mesh = mesh;
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/keyframe/Keyframe.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/keyframe/Keyframe.java
deleted file mode 100644
index a6d3165..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/keyframe/Keyframe.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.model.keyframe;
-
-public class Keyframe {
-	public final float timeStamp;
-	public final float[] vertices;
-
-	public Keyframe (float timeStamp, float[] vertices) {
-		this.timeStamp = timeStamp;
-		this.vertices = vertices;
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/keyframe/KeyframedAnimation.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/keyframe/KeyframedAnimation.java
deleted file mode 100644
index 4301bcc..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/keyframe/KeyframedAnimation.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.model.keyframe;
-
-import com.badlogic.gdx.graphics.g3d.model.Animation;
-
-public class KeyframedAnimation extends Animation {
-	public final float frameDuration;
-	public final Keyframe[] keyframes;
-
-	public KeyframedAnimation (String name, float frameDuration, Keyframe[] keyframes) {
-		super(name, frameDuration * keyframes.length);
-		this.frameDuration = frameDuration;
-		this.keyframes = keyframes;
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/keyframe/KeyframedModel.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/keyframe/KeyframedModel.java
deleted file mode 100644
index d32e777..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/keyframe/KeyframedModel.java
+++ /dev/null
@@ -1,200 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.model.keyframe;
-
-import com.badlogic.gdx.graphics.g3d.materials.Material;
-import com.badlogic.gdx.graphics.g3d.model.AnimatedModel;
-import com.badlogic.gdx.graphics.g3d.model.Model;
-import com.badlogic.gdx.graphics.g3d.model.SubMesh;
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-import com.badlogic.gdx.math.collision.BoundingBox;
-import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.Disposable;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-
-public class KeyframedModel implements AnimatedModel, Disposable {
-	public final KeyframedSubMesh[] subMeshes;
-	protected final KeyframedAnimation[] animations;
-
-	public KeyframedModel (KeyframedSubMesh[] subMeshes) {
-		this.subMeshes = subMeshes;
-
-		Array<KeyframedAnimation> meshAnims = subMeshes[0].animations.values().toArray();
-		animations = new KeyframedAnimation[meshAnims.size];
-		for (int i = 0; i < animations.length; i++) {
-			animations[i] = meshAnims.get(i);
-		}
-
-		checkValidity();
-	}
-
-	private void checkValidity () {
-		for (int i = 0; i < subMeshes.length; i++) {
-			if (subMeshes[i].animations.size != animations.length)
-				throw new GdxRuntimeException("number of animations in subMesh[0] is not the same in subMesh[" + i
-					+ "]. All sub-meshes must have the same animations and number of frames");
-		}
-
-		for (int i = 0; i < animations.length; i++) {
-			KeyframedAnimation anim = animations[i];
-			for (int j = 0; j < subMeshes.length; j++) {
-				KeyframedAnimation otherAnim = subMeshes[j].animations.get(anim.name);
-				if (otherAnim == null) throw new GdxRuntimeException("animation '" + anim.name + "' missing in subMesh[" + j + "]");
-				if (otherAnim.frameDuration != anim.frameDuration)
-					throw new GdxRuntimeException("animation '" + anim.name + "' in subMesh[" + j
-						+ "] has different frame duration than the same animation in subMesh[0]");
-				if (otherAnim.keyframes.length != anim.keyframes.length)
-					throw new GdxRuntimeException("animation '" + anim.name + "' in subMesh[" + j
-						+ "] has different number of keyframes than the same animation in subMesh[0]");
-			}
-		}
-	}
-
-	@Override
-	public void render () {
-		int len = subMeshes.length;
-		for (int i = 0; i < len; i++) {
-			KeyframedSubMesh subMesh = subMeshes[i];
-			if (i == 0 || !subMeshes[i - 1].material.equals(subMesh.material)) {
-				subMesh.material.bind();
-			}
-			subMesh.mesh.render(subMesh.primitiveType);
-		}
-	}
-
-	@Override
-	public void render (ShaderProgram program) {
-		int len = subMeshes.length;
-		for (int i = 0; i < len; i++) {
-			KeyframedSubMesh subMesh = subMeshes[i];
-			if (i == 0 || !subMeshes[i - 1].material.equals(subMesh.material)) {
-				subMesh.material.bind(program);
-			}
-			subMesh.mesh.render(program, subMesh.primitiveType);
-		}
-	}
-
-	@Override
-	public void setMaterials (Material... materials) {
-		if (materials.length != subMeshes.length)
-			throw new UnsupportedOperationException("number of materials must equal number of sub-meshes");
-		int len = materials.length;
-		for (int i = 0; i < len; i++) {
-			subMeshes[i].material = materials[i];
-		}
-	}
-
-	@Override
-	public void setMaterial (Material material) {
-		int len = subMeshes.length;
-		for (int i = 0; i < len; i++) {
-			subMeshes[i].material = material;
-		}
-	}
-
-	@Override
-	public KeyframedSubMesh getSubMesh (String name) {
-		int len = subMeshes.length;
-		for (int i = 0; i < len; i++) {
-			if (subMeshes[i].name.equals(name)) return subMeshes[i];
-		}
-		return null;
-	}
-
-	@Override
-	public SubMesh[] getSubMeshes () {
-		return subMeshes;
-	}
-
-	@Override
-	public void setAnimation (String animation, float time, boolean loop) {
-		int len = subMeshes.length;
-		for (int i = 0; i < len; i++) {
-			final KeyframedSubMesh subMesh = subMeshes[i];
-			final KeyframedAnimation anim = subMesh.animations.get(animation);
-			if (anim == null) throw new IllegalArgumentException("No animation with name '" + animation + "' in submesh #" + i);
-			if (time < 0 || time > anim.totalDuration)
-				throw new IllegalArgumentException("time must be 0 <= time <= animation duration");
-
-			final int startIndex = (int)Math.floor((time / anim.frameDuration));
-			final Keyframe startFrame = anim.keyframes[startIndex];
-			final Keyframe endFrame = anim.keyframes[anim.keyframes.length - 1 == startIndex ? loop ? 0 : startIndex
-				: startIndex + 1];
-
-			final int numComponents = subMesh.animatedComponents;
-			final float[] src = startFrame.vertices;
-			final int srcLen = numComponents * subMesh.mesh.getNumVertices();
-
-			final float[] dst = subMesh.blendedVertices;
-			final int dstInc = subMesh.mesh.getVertexSize() / 4 - numComponents;
-
-			if (startFrame == endFrame) {
-				for (int srcIdx = 0, dstIdx = 0; srcIdx < srcLen; dstIdx += dstInc) {
-					for (int j = 0; j < numComponents; j++) {
-						dst[dstIdx++] = src[srcIdx++];
-					}
-				}
-			} else {
-				float[] src2 = endFrame.vertices;
-				float alpha = (time - (startIndex * anim.frameDuration)) / anim.frameDuration;
-				for (int srcIdx = 0, dstIdx = 0; srcIdx < srcLen; dstIdx += dstInc) {
-					for (int j = 0; j < numComponents; j++) {
-						final float valSrc = src[srcIdx];
-						final float valSrc2 = src2[srcIdx++];
-						dst[dstIdx++] = valSrc + (valSrc2 - valSrc) * alpha;
-					}
-				}
-			}
-
-			subMesh.mesh.setVertices(dst);
-		}
-	}
-
-	@Override
-	public KeyframedAnimation getAnimation (String name) {
-		return subMeshes[0].animations.get(name);
-	}
-
-	@Override
-	public KeyframedAnimation[] getAnimations () {
-		return animations;
-	}
-
-	@Override
-	public Model getSubModel (String... subMeshNames) {
-		// FIXME
-		return null;
-	}
-
-	private final static BoundingBox tmpBox = new BoundingBox();
-
-	@Override
-	public void getBoundingBox (BoundingBox bbox) {
-		bbox.inf();
-		for (int i = 0; i < subMeshes.length; i++) {
-			subMeshes[i].mesh.calculateBoundingBox(tmpBox);
-			bbox.ext(tmpBox);
-		}
-	}
-
-	@Override
-	public void dispose () {
-		for (int i = 0; i < subMeshes.length; i++) {
-			subMeshes[i].mesh.dispose();
-		}
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/keyframe/KeyframedSubMesh.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/keyframe/KeyframedSubMesh.java
deleted file mode 100644
index 2748a7f..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/keyframe/KeyframedSubMesh.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.model.keyframe;
-
-import com.badlogic.gdx.graphics.Mesh;
-import com.badlogic.gdx.graphics.g3d.model.SubMesh;
-import com.badlogic.gdx.math.collision.BoundingBox;
-import com.badlogic.gdx.utils.ObjectMap;
-
-public class KeyframedSubMesh extends SubMesh {
-	public final float[] blendedVertices;
-	public final int animatedComponents;
-	public final ObjectMap<String, KeyframedAnimation> animations;
-
-	public KeyframedSubMesh (String name, Mesh mesh, float[] blendedVertices, ObjectMap<String, KeyframedAnimation> animations,
-		int animatedComponents, int primitiveType) {
-		
-		super(name, mesh, primitiveType);
-		
-		this.blendedVertices = blendedVertices;
-		this.animations = animations;
-		this.animatedComponents = animatedComponents;
-	}
-
-	@Override
-	public void getBoundingBox (BoundingBox bbox) {
-		mesh.calculateBoundingBox(bbox);
-	}
-
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/skeleton/Skeleton.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/skeleton/Skeleton.java
deleted file mode 100644
index d4251e9..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/skeleton/Skeleton.java
+++ /dev/null
@@ -1,156 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.model.skeleton;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import com.badlogic.gdx.math.Matrix4;
-import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.ObjectMap;
-
-public class Skeleton {
-	/** each joint is a root joint in the hierachy **/
-	public final Array<SkeletonJoint> hierarchy = new Array<SkeletonJoint>();
-	/** the names of each joint in breadth first order **/
-	public final Array<String> jointNames = new Array<String>();
-	/** names to indices **/
-	public final Map<String, Integer> namesToIndices = new HashMap<String, Integer>();
-	/** the bind pose joints in breadth first order **/
-	public final Array<SkeletonKeyframe> bindPoseJoints = new Array<SkeletonKeyframe>();
-	/** the joints in breadth first order for the last calculates animation pose **/
-	public final Array<SkeletonKeyframe> animPoseJoints = new Array<SkeletonKeyframe>();
-	/** the offset matrices for each joint in the same order as the bindPoseJoints **/
-	public final Array<Matrix4> offsetMatrices = new Array<Matrix4>();
-	/** the scene matrices for each joint in the same order as bindPoseJoints **/
-	public final Array<Matrix4> sceneMatrices = new Array<Matrix4>();
-	/** combined scene and offset matrices **/
-	public final Array<Matrix4> combinedMatrices = new Array<Matrix4>();
-	/** map of animations, indexed by name **/
-	public final ObjectMap<String, SkeletonAnimation> animations = new ObjectMap<String, SkeletonAnimation>();
-
-	private static final Matrix4 IDENTITY = new Matrix4();
-	private final Matrix4 rotMatrix = new Matrix4();
-
-	/** Fills the baseJoints, offsetMatrices and sceneMatrices Array instances with joints and Matrix4 instances in an breadth first
-	 * order. This allows one to iterate over the joint arrays instead of recursing over the hierarchy when calculating the scene
-	 * matrices. */
-	public void buildFromHierarchy () {
-		jointNames.clear();
-		namesToIndices.clear();
-		bindPoseJoints.clear();
-		animPoseJoints.clear();
-		offsetMatrices.clear();
-		sceneMatrices.clear();
-
-		for (int i = 0; i < hierarchy.size; i++) {
-			recursiveFill(hierarchy.get(i));
-		}
-
-		calculateMatrices(bindPoseJoints);
-		calculateOffsetMatrices();
-	}
-
-	private void recursiveFill (SkeletonJoint joint) {
-		joint.index = bindPoseJoints.size;
-		joint.parentIndex = joint.parent != null ? joint.parent.index : -1;
-
-		SkeletonKeyframe keyFrame = new SkeletonKeyframe();
-		keyFrame.position.set(joint.position);
-		keyFrame.scale.set(joint.scale);
-		keyFrame.rotation.set(joint.rotation);
-		keyFrame.parentIndex = joint.parentIndex;
-
-		jointNames.add(joint.name);
-		namesToIndices.put(joint.name, joint.index);
-		bindPoseJoints.add(keyFrame);
-		SkeletonKeyframe animKeyframe = new SkeletonKeyframe();
-		animKeyframe.parentIndex = joint.parentIndex;
-		animPoseJoints.add(animKeyframe);
-		offsetMatrices.add(new Matrix4());
-		sceneMatrices.add(new Matrix4());
-		combinedMatrices.add(new Matrix4());
-
-		int len = joint.children.size;
-		for (int i = 0; i < len; i++) {
-			recursiveFill(joint.children.get(i));
-		}
-	}
-
-	protected void calculateOffsetMatrices () {
-		for (int i = 0; i < offsetMatrices.size; i++) {
-			offsetMatrices.get(i).set(sceneMatrices.get(i)).inv();
-		}
-	}
-
-	protected void calculateMatrices (Array<SkeletonKeyframe> joints) {
-		for (int i = 0; i < joints.size; i++) {
-			SkeletonKeyframe joint = joints.get(i);
-			Matrix4 sceneMatrix = sceneMatrices.get(i);
-			Matrix4 parentMatrix = joint.parentIndex != -1 ? sceneMatrices.get(joint.parentIndex) : IDENTITY;
-			Matrix4 combinedMatrix = combinedMatrices.get(i);
-
-			joint.rotation.toMatrix(rotMatrix.val);
-			rotMatrix.trn(joint.position);
-			rotMatrix.scl(joint.scale);
-			sceneMatrix.set(parentMatrix);
-			sceneMatrix.mul(rotMatrix);
-
-			combinedMatrix.set(sceneMatrix);
-			combinedMatrix.mul(offsetMatrices.get(i));
-		}
-	}
-
-	public void setAnimation (String name, float time) {
-		SkeletonAnimation anim = animations.get(name);
-		if (anim == null) throw new IllegalArgumentException("Animation with name '" + name + "' does not exist");
-		if (time < 0 || time > anim.totalDuration)
-			throw new IllegalArgumentException("time must be 0 <= time <= animation duration");
-
-		int len = anim.perJointkeyFrames.length;
-		for (int i = 0; i < len; i++) {
-			SkeletonKeyframe[] jointTrack = anim.perJointkeyFrames[i];
-			int idx = 0;
-			int len2 = jointTrack.length;
-			for (int j = 0; j < len2; j++) {
-				SkeletonKeyframe jointFrame = jointTrack[j];
-				if (jointFrame.timeStamp >= time) {
-					idx = Math.max(0, j - 1);
-					break;
-				}
-			}
-
-			SkeletonKeyframe startFrame = jointTrack[idx];
-			SkeletonKeyframe endFrame = idx + 1 == len2 ? startFrame : jointTrack[idx + 1];
-			float alpha = 0;
-
-			if (startFrame != endFrame) {
-				alpha = Math.min(1, (time - startFrame.timeStamp) / (endFrame.timeStamp - startFrame.timeStamp));
-			}
-			SkeletonKeyframe animFrame = animPoseJoints.get(i);
-			animFrame.position.set(startFrame.position).lerp(endFrame.position, alpha);
-			animFrame.scale.set(startFrame.scale).lerp(endFrame.scale, alpha);
-			animFrame.rotation.set(startFrame.rotation).slerp(endFrame.rotation, alpha);
-		}
-
-		calculateMatrices(animPoseJoints);
-	}
-
-	public void setBindPose () {
-		calculateMatrices(bindPoseJoints);
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/skeleton/SkeletonAnimation.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/skeleton/SkeletonAnimation.java
deleted file mode 100644
index 9d264fe..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/skeleton/SkeletonAnimation.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.model.skeleton;
-
-import com.badlogic.gdx.graphics.g3d.model.Animation;
-
-public class SkeletonAnimation extends Animation {
-	public final SkeletonKeyframe[][] perJointkeyFrames;
-
-	public SkeletonAnimation (String name, float totalDuration, SkeletonKeyframe[][] perJointKeyFrames) {
-		super(name, totalDuration);
-		this.perJointkeyFrames = perJointKeyFrames;
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/skeleton/SkeletonJoint.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/skeleton/SkeletonJoint.java
deleted file mode 100644
index f8b0ac1..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/skeleton/SkeletonJoint.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.model.skeleton;
-
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.utils.Array;
-
-public class SkeletonJoint {
-	public String name;
-
-	public int index;
-	public int parentIndex;
-	public SkeletonJoint parent;
-	public final Array<SkeletonJoint> children = new Array<SkeletonJoint>(1);
-
-	public final Vector3 position = new Vector3();
-	public final Quaternion rotation = new Quaternion(new Vector3(0, 1, 0), 0);
-	public final Vector3 scale = new Vector3(1, 1, 1);
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/skeleton/SkeletonKeyframe.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/skeleton/SkeletonKeyframe.java
deleted file mode 100644
index 5bc16fb..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/skeleton/SkeletonKeyframe.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.model.skeleton;
-
-import com.badlogic.gdx.math.Quaternion;
-import com.badlogic.gdx.math.Vector3;
-
-public class SkeletonKeyframe {
-	public float timeStamp = 0;
-	public int parentIndex = -1;
-	public final Vector3 position = new Vector3();
-	public final Vector3 scale = new Vector3(1, 1, 1);
-	public final Quaternion rotation = new Quaternion(0, 0, 0, 1);
-
-	public String toString () {
-		return "time: " + timeStamp + ", " + "parent: " + parentIndex + ", " + "position: " + position + ", " + "scale: " + scale
-			+ ", " + "rotation: " + rotation;
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/skeleton/SkeletonModel.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/skeleton/SkeletonModel.java
deleted file mode 100644
index 934e218..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/skeleton/SkeletonModel.java
+++ /dev/null
@@ -1,222 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.model.skeleton;
-
-import com.badlogic.gdx.graphics.VertexAttributes.Usage;
-import com.badlogic.gdx.graphics.g3d.materials.Material;
-import com.badlogic.gdx.graphics.g3d.model.AnimatedModel;
-import com.badlogic.gdx.graphics.g3d.model.Model;
-import com.badlogic.gdx.graphics.g3d.model.SubMesh;
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-import com.badlogic.gdx.math.Matrix4;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.math.collision.BoundingBox;
-import com.badlogic.gdx.utils.Array;
-
-public class SkeletonModel implements AnimatedModel {
-	public final Skeleton skeleton;
-	public final SkeletonSubMesh[] subMeshes;
-
-	public SkeletonModel (Skeleton skeleton, SubMesh[] subMeshes) {
-		this.skeleton = skeleton;
-		this.subMeshes = new SkeletonSubMesh[subMeshes.length];
-		
-		for (int i=0; i < subMeshes.length; ++i) {
-			this.subMeshes[i] = (SkeletonSubMesh)subMeshes[i];
-		}
-		setMaterial(new Material("default"));
-	}
-
-	public void setBindPose () {
-		skeleton.setBindPose();
-		for (int i = 0; i < subMeshes.length; i++) {
-			skin(subMeshes[i], skeleton.combinedMatrices);
-		}
-	}
-
-	@Override
-	public void setAnimation (String animation, float time, boolean loop) {
-		skeleton.setAnimation(animation, time);
-		for (int i = 0; i < subMeshes.length; i++) {
-			skin(subMeshes[i], skeleton.combinedMatrices);
-		}
-	}
-
-	final Vector3 v = new Vector3();
-
-	public void skin (SkeletonSubMesh subMesh, Array<Matrix4> boneMatrices) {
-		final int stride = subMesh.mesh.getVertexSize() / 4;
-		final int numVertices = subMesh.mesh.getNumVertices();
-		int idx = 0;
-		int nidx = subMesh.mesh.getVertexAttribute(Usage.Normal) == null ? -1
-			: subMesh.mesh.getVertexAttribute(Usage.Normal).offset / 4;
-		final float[] vertices = subMesh.vertices;
-		final float[] skinnedVertices = subMesh.skinnedVertices;
-
-		System.arraycopy(subMesh.vertices, 0, skinnedVertices, 0, subMesh.vertices.length);
-
-		for (int i = 0; i < numVertices; i++, idx += stride, nidx += stride) {
-			final int[] boneIndices = subMesh.boneAssignments[i];
-			final float[] boneWeights = subMesh.boneWeights[i];
-
-			final float ox = vertices[idx], oy = vertices[idx + 1], oz = vertices[idx + 2];
-			float x = 0, y = 0, z = 0;
-			float onx = 0, ony = 0, onz = 0;
-			float nx = 0, ny = 0, nz = 0;
-
-			if (nidx != -1) {
-				onx = vertices[nidx];
-				ony = vertices[nidx + 1];
-				onz = vertices[nidx + 2];
-			}
-
-			for (int j = 0; j < boneIndices.length; j++) {
-				int boneIndex = boneIndices[j];
-				float weight = boneWeights[j];
-				v.set(ox, oy, oz);
-				v.mul(boneMatrices.get(boneIndex));
-				x += v.x * weight;
-				y += v.y * weight;
-				z += v.z * weight;
-
-				if (nidx != -1) {
-					v.set(onx, ony, onz);
-					v.rot(boneMatrices.get(boneIndex));
-					nx += v.x * weight;
-					ny += v.y * weight;
-					nz += v.z * weight;
-				}
-			}
-
-			skinnedVertices[idx] = x;
-			skinnedVertices[idx + 1] = y;
-			skinnedVertices[idx + 2] = z;
-
-			if (nidx != -1) {
-				skinnedVertices[nidx] = nx;
-				skinnedVertices[nidx + 1] = ny;
-				skinnedVertices[nidx + 2] = nz;
-			}
-		}
-
-		subMesh.mesh.setVertices(skinnedVertices);
-	}
-
-	@Override
-	public void render () {
-		int len = subMeshes.length;
-		for (int i = 0; i < len; i++) {
-			SkeletonSubMesh subMesh = subMeshes[i];
-			if (i == 0) {
-				subMesh.material.bind();
-			} else if (!subMeshes[i - 1].material.equals(subMesh.material)) {
-				subMesh.material.bind();
-			}
-			subMesh.mesh.render(subMesh.primitiveType);
-		}
-	}
-
-	@Override
-	public void render (ShaderProgram program) {
-		int len = subMeshes.length;
-		for (int i = 0; i < len; i++) {
-			SkeletonSubMesh subMesh = subMeshes[i];
-			if (i == 0) {
-				subMesh.material.bind(program);
-			} else if (!subMeshes[i - 1].material.equals(subMesh.material)) {
-				subMesh.material.bind(program);
-			}
-			subMesh.mesh.render(program, subMesh.primitiveType);
-		}
-	}
-
-	@Override
-	public void setMaterials (Material... materials) {
-		if (materials.length != subMeshes.length)
-			throw new UnsupportedOperationException("number of materials must equal number of sub-meshes");
-		int len = materials.length;
-		for (int i = 0; i < len; i++) {
-			subMeshes[i].material = materials[i];
-		}
-	}
-
-	@Override
-	public void setMaterial (Material material) {
-		int len = subMeshes.length;
-		for (int i = 0; i < len; i++) {
-			subMeshes[i].material = material;
-		}
-	}
-
-	@Override
-	public SubMesh getSubMesh (String name) {
-		int len = subMeshes.length;
-		for (int i = 0; i < len; i++) {
-			if (subMeshes[i].name.equals(name)) return subMeshes[i];
-		}
-		return null;
-	}
-
-	@Override
-	public SubMesh[] getSubMeshes () {
-		return subMeshes;
-	}
-
-	@Override
-	public SkeletonAnimation getAnimation (String name) {
-		return skeleton.animations.get(name);
-	}
-
-	// FIXME, ugh...
-	protected SkeletonAnimation[] animations;
-
-	@Override
-	public SkeletonAnimation[] getAnimations () {
-		if (animations == null || animations.length != skeleton.animations.size) {
-			animations = new SkeletonAnimation[skeleton.animations.size];
-			int i = 0;
-			for (SkeletonAnimation anim : skeleton.animations.values()) {
-				animations[i++] = anim;
-			}
-		}
-		return animations;
-	}
-
-	@Override
-	public Model getSubModel (String... subMeshNames) {
-		// FIXME
-		return null;
-	}
-
-	private final static BoundingBox tmpBox = new BoundingBox();
-
-	@Override
-	public void getBoundingBox (BoundingBox bbox) {
-		bbox.inf();
-		for (int i = 0; i < subMeshes.length; i++) {
-			subMeshes[i].mesh.calculateBoundingBox(tmpBox);
-			bbox.ext(tmpBox);
-		}
-	}
-
-	@Override
-	public void dispose () {
-		for (int i = 0; i < subMeshes.length; i++) {
-			subMeshes[i].mesh.dispose();
-		}
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/skeleton/SkeletonModelGpuSkinned.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/skeleton/SkeletonModelGpuSkinned.java
deleted file mode 100644
index 4f55268..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/skeleton/SkeletonModelGpuSkinned.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-package com.badlogic.gdx.graphics.g3d.model.skeleton;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.graphics.Mesh;
-import com.badlogic.gdx.graphics.VertexAttribute;
-import com.badlogic.gdx.graphics.VertexAttributes;
-import com.badlogic.gdx.graphics.VertexAttributes.Usage;
-import com.badlogic.gdx.graphics.g3d.model.skeleton.Skeleton;
-import com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonModel;
-import com.badlogic.gdx.graphics.g3d.model.skeleton.SkeletonSubMesh;
-
-public class SkeletonModelGpuSkinned extends SkeletonModel {
-	public final static String BoneIndexAttribue = "a_boneIndex";
-	public final static String BoneWeightAttribue = "a_boneWeight";
-
-	public SkeletonModelGpuSkinned(Skeleton skeleton, SkeletonSubMesh[] subMeshes) {
-		super(skeleton,subMeshes);
-	}
-	
-	// Factory Method to create a SkeletonModelGpuSkinned from a SkeletonModel
-	// This will destroy the skeletonModel passed in.
-	public static SkeletonModel CreateFromSkeletonModel(SkeletonModel skeletonModel){
-		if (Gdx.gl20 == null){
-			return skeletonModel;
-		}
-		SkeletonModelGpuSkinned model = new SkeletonModelGpuSkinned(skeletonModel.skeleton, skeletonModel.subMeshes);
-		model.setupGpuSkin();
-		return model;
-	}
-	
-	public void setupGpuSkin(){
-		for (int i = 0; i < subMeshes.length; i++) {
-			setupGpuSkin(subMeshes[i]);
-		}
-	}
-	
-	private void setupGpuSkin(SkeletonSubMesh subMesh){
-		VertexAttributes oldAttributes =  subMesh.mesh.getVertexAttributes();
-		final int oldAttributeCount = oldAttributes.size();
-		VertexAttribute[] attributeArray = new VertexAttribute[oldAttributeCount+2];
-		for(int i=0;i<oldAttributeCount;i++){
-			attributeArray[i] = oldAttributes.get(i);
-		}
-		final int boneIndex = oldAttributeCount;
-		final int weightIndex = oldAttributeCount+1;
-		attributeArray[boneIndex] = new VertexAttribute(Usage.Generic, 4, BoneIndexAttribue);
-		attributeArray[weightIndex] = new VertexAttribute(Usage.Generic, 4, BoneWeightAttribue);
-		VertexAttributes newAttributes = new VertexAttributes(attributeArray);
-		
-		//TODO: not sure if I want to generate a new mesh. But VertexAttributes was final inside mesh
-		Mesh newMesh = new Mesh(true, subMesh.mesh.getMaxVertices(), subMesh.mesh.getMaxIndices(), newAttributes);
-		
-		final int stride = subMesh.mesh.getVertexSize() / 4;
-		final int newStride = newMesh.getVertexSize() / 4;
-		final int numVertices = subMesh.mesh.getNumVertices();
-		int idx = 0;
-		int newIdx = 0;
-		int bidx = -1;
-		int widx = -1;
-		for(int i=0;i<newAttributes.size();i++)
-		{
-			VertexAttribute a = newAttributes.get(i);
-			if(a.alias.equals(BoneIndexAttribue)){
-				bidx = a.offset/4;
-			} else if(a.alias.equals(BoneWeightAttribue)){
-				widx = a.offset/4;
-			}
-		}
-		
-		if(bidx <0 || widx < 0){
-			throw new IllegalArgumentException("Need Shader with bone index and bone wieght vectors to use GPU skinning");
-		}
-		
-		final float[] vertices = subMesh.vertices;
-		final float[] skinnedVertices = new float[newStride * numVertices];
-
-		for (int i = 0; i < numVertices; i++, idx += stride, newIdx += newStride, bidx += newStride, widx += newStride) {
-			final int[] boneIndices = subMesh.boneAssignments[i];
-			final float[] boneWeights = subMesh.boneWeights[i];
-			
-			System.arraycopy(vertices, idx, skinnedVertices, newIdx, stride);
-			
-			skinnedVertices[bidx] = boneIndices.length>0?boneIndices[0]:0;
-			skinnedVertices[bidx + 1] = boneIndices.length>1?boneIndices[1]:0;
-			skinnedVertices[bidx + 2] = boneIndices.length>2?boneIndices[2]:0;
-			skinnedVertices[bidx + 3] = boneIndices.length>3?boneIndices[3]:0;
-			
-			skinnedVertices[widx] = boneWeights.length>0?boneWeights[0]:0;
-			skinnedVertices[widx + 1] = boneWeights.length>1?boneWeights[1]:0;
-			skinnedVertices[widx + 2] = boneWeights.length>2?boneWeights[2]:0;
-			skinnedVertices[widx + 3] = boneWeights.length>3?boneWeights[3]:0;
-		}
-
-		newMesh.setVertices(skinnedVertices);
-		newMesh.setIndices(subMesh.indices);
-		subMesh.mesh.dispose();
-		subMesh.mesh = newMesh;
-		subMesh.skinnedVertices = null;
-		subMesh.vertices = skinnedVertices;
-	}
-	
-	@Override
-	public void setAnimation(String animation, float time, boolean loop) {
-		skeleton.setAnimation(animation, time);
-	}
-}
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/skeleton/SkeletonSubMesh.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/skeleton/SkeletonSubMesh.java
deleted file mode 100644
index 3752794..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/skeleton/SkeletonSubMesh.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.model.skeleton;
-
-import com.badlogic.gdx.graphics.Mesh;
-import com.badlogic.gdx.graphics.g3d.model.SubMesh;
-import com.badlogic.gdx.math.collision.BoundingBox;
-
-public class SkeletonSubMesh extends SubMesh {
-
-	public SkeletonSubMesh (String name, Mesh mesh, int primitiveType) {
-		super(name, mesh, primitiveType);
-	}
-
-	public short[] indices;
-	public float[] vertices;
-	public float[] skinnedVertices;
-
-	public int[][] boneAssignments;
-	public float[][] boneWeights;
-
-	@Override
-	public void getBoundingBox (BoundingBox bbox) {
-		mesh.calculateBoundingBox(bbox);
-	}
-
-	public void setVertices (float[] vertices) {
-		this.vertices = vertices;
-	}
-
-	public void setIndices (short[] indices) {
-		this.indices = indices;
-	}
-
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/still/StillModel.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/still/StillModel.java
deleted file mode 100644
index 91c1eb2..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/still/StillModel.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.model.still;
-
-import java.util.ArrayList;
-
-import com.badlogic.gdx.graphics.g3d.materials.Material;
-import com.badlogic.gdx.graphics.g3d.model.Model;
-import com.badlogic.gdx.graphics.g3d.model.SubMesh;
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-import com.badlogic.gdx.math.collision.BoundingBox;
-
-public class StillModel implements Model {
-	final public StillSubMesh[] subMeshes;
-
-	public StillModel (SubMesh... subMeshes) {
-		this.subMeshes = new StillSubMesh[subMeshes.length];
-		for (int i = 0; i < subMeshes.length ; ++i) {
-			this.subMeshes[i] = (StillSubMesh)subMeshes[i];
-		}	
-	}
-
-	@Override
-	public void render () {
-		int len = subMeshes.length;
-		for (int i = 0; i < len; i++) {
-			StillSubMesh subMesh = subMeshes[i];
-			if (i == 0) {
-				subMesh.material.bind();
-			} else if (!subMeshes[i - 1].material.equals(subMesh.material)) {
-				subMesh.material.bind();
-			}
-			subMesh.mesh.render(subMesh.primitiveType);
-		}
-	}
-
-	@Override
-	public void render (ShaderProgram program) {
-		int len = subMeshes.length;
-		for (int i = 0; i < len; i++) {
-			StillSubMesh subMesh = subMeshes[i];
-			if (i == 0) {
-				subMesh.material.bind(program);
-			} else if (!subMeshes[i - 1].material.equals(subMesh.material)) {
-				subMesh.material.bind(program);
-			}
-			subMesh.mesh.render(program, subMesh.primitiveType);
-		}
-	}
-
-	@Override
-	public Model getSubModel (String... subMeshNames) {
-		ArrayList<SubMesh> subMeshes = new ArrayList<SubMesh>();
-		for (String name : subMeshNames)
-			for (StillSubMesh subMesh : this.subMeshes)
-				if (name.equals(subMesh.name)) subMeshes.add(subMesh);
-		if (subMeshes.size() > 0) return new StillModel(subMeshes.toArray(new StillSubMesh[subMeshes.size()]));
-		return null;
-	}
-
-	@Override
-	public StillSubMesh getSubMesh (String name) {
-		for (StillSubMesh subMesh : subMeshes) {
-			if (subMesh.name.equals(name)) return subMesh;
-		}
-		return null;
-	}
-
-	@Override
-	public SubMesh[] getSubMeshes () {
-		return subMeshes;
-	}
-
-	@Override
-	public void setMaterials (Material... materials) {
-		if (materials.length != subMeshes.length)
-			throw new UnsupportedOperationException("number of materials must equal number of sub-meshes");
-		int len = materials.length;
-		for (int i = 0; i < len; i++) {
-			subMeshes[i].material = materials[i];
-		}
-	}
-
-	@Override
-	public void setMaterial (Material material) {
-		int len = subMeshes.length;
-		for (int i = 0; i < len; i++) {
-			subMeshes[i].material = material;
-		}
-	}
-
-	private final static BoundingBox tmpBox = new BoundingBox();
-
-	@Override
-	public void getBoundingBox (BoundingBox bbox) {
-		bbox.inf();
-		for (int i = 0; i < subMeshes.length; i++) {
-			subMeshes[i].mesh.calculateBoundingBox(tmpBox);
-			bbox.ext(tmpBox);
-		}
-	}
-
-	@Override
-	public void dispose () {
-		for (int i = 0; i < subMeshes.length; i++) {
-			subMeshes[i].mesh.dispose();
-		}
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/still/StillSubMesh.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/still/StillSubMesh.java
deleted file mode 100644
index 3150021..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/still/StillSubMesh.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.model.still;
-
-import com.badlogic.gdx.graphics.Mesh;
-import com.badlogic.gdx.graphics.g3d.materials.Material;
-import com.badlogic.gdx.graphics.g3d.model.SubMesh;
-import com.badlogic.gdx.math.collision.BoundingBox;
-
-public class StillSubMesh extends SubMesh {
-
-	public StillSubMesh (String name, Mesh mesh, int primitiveType, Material material) {
-		super(name, mesh, primitiveType, material);
-	}
-	
-	public StillSubMesh (String name, Mesh mesh, int primitiveType) {
-		super(name, mesh, primitiveType);
-	}
-
-	@Override
-	public void getBoundingBox (BoundingBox bbox) {
-		mesh.calculateBoundingBox(bbox);
-	}
-
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/AnimatedModelInstance.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/AnimatedModelInstance.java
new file mode 100644
index 0000000..c99b546
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/AnimatedModelInstance.java
@@ -0,0 +1,25 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old;
+
+public interface AnimatedModelInstance extends StillModelInstance {
+	public String getAnimation ();
+
+	public float getAnimationTime ();
+
+	public boolean isLooping ();
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/AnimatedModelNode.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/AnimatedModelNode.java
new file mode 100644
index 0000000..0b6f3f3
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/AnimatedModelNode.java
@@ -0,0 +1,69 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old;
+
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+
+public class AnimatedModelNode extends StillModelNode implements AnimatedModelInstance {
+	public String animation;
+	public float time;
+	public boolean looping;
+	
+	public AnimatedModelNode() {
+		super();
+	}
+	
+	public AnimatedModelNode(Material[] materials) {
+		super(materials);
+	}
+
+	@Override
+	public String getAnimation () {
+		return animation;
+	}
+
+	@Override
+	public float getAnimationTime () {
+		return time;
+	}
+
+	@Override
+	public boolean isLooping () {
+		return looping;
+	}
+
+	public AnimatedModelNode copy () {
+		final AnimatedModelNode copy = new AnimatedModelNode();
+		if (materials != null) {
+			final int len = materials.length;
+			Material[] mats = new Material[len];
+			for (int i = 0; i < len; i++) {
+				mats[i] = materials[i].copy();
+			}
+			copy.materials = mats;
+		}
+		copy.matrix.set(matrix.val);
+		copy.origin.set(origin);
+		copy.radius = radius;
+		copy.transformedPosition.set(transformedPosition);
+		copy.animation = animation;
+		copy.time = time;
+		copy.looping = looping;
+		return copy;
+	}
+
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/ModelLoaderHints.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/ModelLoaderHints.java
new file mode 100644
index 0000000..7d18043
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/ModelLoaderHints.java
@@ -0,0 +1,30 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old;
+
+import com.badlogic.gdx.graphics.g3d.old.loaders.ModelLoaderRegistry;
+
+/** Hints passed to a loader which might ignore them. See {@link ModelLoaderRegistry}.
+ * @author mzechner */
+public class ModelLoaderHints {
+	/** whether to flip the v texture coordinate **/
+	public final boolean flipV;
+
+	public ModelLoaderHints (boolean flipV) {
+		this.flipV = flipV;
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/ModelRenderer.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/ModelRenderer.java
new file mode 100644
index 0000000..4c1fe22
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/ModelRenderer.java
@@ -0,0 +1,30 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old;
+
+import com.badlogic.gdx.graphics.g3d.old.model.AnimatedModel;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
+
+public interface ModelRenderer {
+	public void begin ();
+
+	public void draw (StillModel model, StillModelInstance instance);
+
+	public void draw (AnimatedModel model, AnimatedModelInstance instance);
+
+	public void end ();
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/StillModelInstance.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/StillModelInstance.java
new file mode 100644
index 0000000..a821055
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/StillModelInstance.java
@@ -0,0 +1,32 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old;
+
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+import com.badlogic.gdx.math.Matrix4;
+import com.badlogic.gdx.math.Vector3;
+
+public interface StillModelInstance {
+	public Matrix4 getTransform ();
+
+	public Vector3 getSortCenter ();
+
+	public float getBoundingSphereRadius ();
+
+	public Material[] getMaterials ();
+
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/StillModelNode.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/StillModelNode.java
new file mode 100644
index 0000000..9b0f16e
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/StillModelNode.java
@@ -0,0 +1,86 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old;
+
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+import com.badlogic.gdx.math.Matrix4;
+import com.badlogic.gdx.math.Vector3;
+
+public class StillModelNode implements StillModelInstance {
+	static final private float[] vec3 = {0, 0, 0};
+
+	final public Vector3 origin = new Vector3();
+	final public Vector3 transformedPosition = new Vector3();
+
+	final public Matrix4 matrix = new Matrix4();
+	public Material[] materials;
+	public float radius;
+
+	public StillModelNode () {
+		this(null);
+	}
+
+	public StillModelNode (Material[] materials) {
+		this.materials = materials;
+	}
+
+	@Override
+	public Matrix4 getTransform () {
+		return matrix;
+	}
+
+	@Override
+	public Vector3 getSortCenter () {
+		vec3[0] = origin.x;
+		vec3[1] = origin.y;
+		vec3[2] = origin.z;
+		Matrix4.mulVec(matrix.val, vec3);
+		transformedPosition.x = vec3[0];
+		transformedPosition.y = vec3[1];
+		transformedPosition.z = vec3[2];
+		return transformedPosition;
+	}
+
+	@Override
+	public Material[] getMaterials () {
+		return materials;
+	}
+
+	@Override
+	public float getBoundingSphereRadius () {
+		return radius;
+	}
+
+	public StillModelNode copy () {
+		final StillModelNode copy = new StillModelNode();
+		if (materials != null) {
+			final int len = materials.length;
+			Material[] mats = new Material[len];
+			for (int i = 0; i < len; i++) {
+				mats[i] = materials[i].copy();
+			}
+			copy.materials = mats;
+		}
+		copy.matrix.set(matrix.val);
+		copy.origin.set(origin);
+		copy.radius = radius;
+		copy.transformedPosition.set(transformedPosition);
+		return copy;
+
+	}
+
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/KeyframedModelLoader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/KeyframedModelLoader.java
new file mode 100644
index 0000000..918c98e
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/KeyframedModelLoader.java
@@ -0,0 +1,27 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.loaders;
+
+import com.badlogic.gdx.files.FileHandle;
+import com.badlogic.gdx.graphics.g3d.old.ModelLoaderHints;
+import com.badlogic.gdx.graphics.g3d.old.model.keyframe.KeyframedModel;
+
+/** Interface for classes loading {@link KeyframedModel} instances.
+ * @author mzechner */
+public interface KeyframedModelLoader extends ModelLoader {
+	public KeyframedModel load (FileHandle handle, ModelLoaderHints hints);
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/ModelLoader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/ModelLoader.java
new file mode 100644
index 0000000..2838191
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/ModelLoader.java
@@ -0,0 +1,29 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.loaders;
+
+import com.badlogic.gdx.files.FileHandle;
+import com.badlogic.gdx.graphics.g3d.old.ModelLoaderHints;
+import com.badlogic.gdx.graphics.g3d.old.model.Model;
+
+/** Interface for all loaders. Loaders that need more files need to derrive the other file names by the given file. A bit of a
+ * hack, but most formats are self contained.
+ * 
+ * @author mzechner */
+public interface ModelLoader {
+	public Model load (FileHandle file, ModelLoaderHints hints);
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/ModelLoaderRegistry.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/ModelLoaderRegistry.java
new file mode 100644
index 0000000..78c780c
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/ModelLoaderRegistry.java
@@ -0,0 +1,390 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.loaders;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import com.badlogic.gdx.files.FileHandle;
+import com.badlogic.gdx.graphics.g3d.old.ModelLoaderHints;
+import com.badlogic.gdx.graphics.g3d.old.loaders.g3d.G3dLoader.G3dKeyframedModelLoader;
+import com.badlogic.gdx.graphics.g3d.old.loaders.g3d.G3dLoader.G3dSkeletonModelLoader;
+import com.badlogic.gdx.graphics.g3d.old.loaders.g3d.G3dLoader.G3dStillModelLoader;
+import com.badlogic.gdx.graphics.g3d.old.loaders.g3d.G3dtLoader.G3dtKeyframedModelLoader;
+import com.badlogic.gdx.graphics.g3d.old.loaders.g3d.G3dtLoader.G3dtStillModelLoader;
+import com.badlogic.gdx.graphics.g3d.old.loaders.md2.MD2Loader;
+import com.badlogic.gdx.graphics.g3d.old.loaders.md2.MD2Loader.MD2LoaderHints;
+import com.badlogic.gdx.graphics.g3d.old.loaders.wavefront.ObjLoader;
+import com.badlogic.gdx.graphics.g3d.old.model.Model;
+import com.badlogic.gdx.graphics.g3d.old.model.keyframe.KeyframedModel;
+import com.badlogic.gdx.graphics.g3d.old.model.skeleton.SkeletonModel;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+/** Simple "pluggable" class for loading models. Keeps a list of {@link ModelLoader} instances on a per file suffix basis. Use one
+ * of the static methods to load a {@link Model}. The registry will then try out all the registered loaders for that extension and
+ * eventually return a Model or throw a {@link GdxRuntimeException}.
+ * 
+ * @author mzechner */
+public class ModelLoaderRegistry {
+	private static Map<String, Array<ModelLoader>> loaders = new HashMap<String, Array<ModelLoader>>();
+	private static Map<String, Array<ModelLoaderHints>> defaultHints = new HashMap<String, Array<ModelLoaderHints>>();
+
+	// registering the default loaders here
+	static {
+		/* TODO: Move/Drop support
+		registerLoader("dae", new ColladaLoader(), new ModelLoaderHints(false));
+		registerLoader("dae", new ColladaLoaderSkeleton(), new ModelLoaderHints(false));
+		*/
+		registerLoader("obj", new ObjLoader(), new ModelLoaderHints(false));
+		registerLoader("md2", new MD2Loader(), new MD2LoaderHints(0.2f));
+		registerLoader("g3dt", new G3dtStillModelLoader(), new ModelLoaderHints(true));
+		registerLoader("g3dt", new G3dtKeyframedModelLoader(), new ModelLoaderHints(true));
+		registerLoader("g3d", new G3dStillModelLoader(), new ModelLoaderHints(false));
+		registerLoader("g3d", new G3dKeyframedModelLoader(), new ModelLoaderHints(false));
+		registerLoader("g3d", new G3dSkeletonModelLoader(), new ModelLoaderHints(false));
+		/*
+		registerLoader("ctm", new CtmModelLoader(), new ModelLoaderHints(false));
+		*/
+	}
+
+	/** Registers a new loader with the registry. The extension will be used to match the loader against a file to be loaded. The
+	 * extension will be compared case insensitive. If multiple loaders are registered per extension they will be tried on a file
+	 * in the sequence they have been registered until one succeeds or none succeed.
+	 * 
+	 * @param extension the extension string, e.g. "dae" or "obj"
+	 * @param loader the {@link ModelLoader}
+	 * @param defaultHints the default {@link ModelLoaderHints} to be used with this loader. */
+	public static void registerLoader (String extension, ModelLoader loader, ModelLoaderHints defaultHints) {
+		Array<ModelLoader> loaders = ModelLoaderRegistry.loaders.get(extension);
+		if (loaders == null) {
+			loaders = new Array<ModelLoader>();
+			ModelLoaderRegistry.loaders.put(extension.toLowerCase(), loaders);
+		}
+		loaders.add(loader);
+
+		Array<ModelLoaderHints> hints = ModelLoaderRegistry.defaultHints.get(extension);
+		if (hints == null) {
+			hints = new Array<ModelLoaderHints>();
+			ModelLoaderRegistry.defaultHints.put(extension.toLowerCase(), hints);
+		}
+		hints.add(defaultHints);
+	}
+
+	/** Loads the specified file with one of the loaders registered with this ModelLoaderRegistry. Uses the extension to determine
+	 * which loader to use. The comparison of extensions is done case insensitive.
+	 * @param file the file to be loaded
+	 * @return the {@link Model}
+	 * @throws GdxRuntimeException in case the model could not be loaded. */
+	public static Model load (FileHandle file) {
+		String name = file.name();
+		int dotIndex = name.lastIndexOf('.');
+		if (dotIndex == -1)
+			throw new GdxRuntimeException("file '" + file.name()
+				+ "' does not have an extension that can be matched to a ModelLoader");
+		String extension = name.substring(dotIndex + 1).toLowerCase();
+
+		Array<ModelLoader> loaders = ModelLoaderRegistry.loaders.get(extension);
+		Array<ModelLoaderHints> hints = ModelLoaderRegistry.defaultHints.get(extension);
+		if (loaders == null) throw new GdxRuntimeException("no loaders for extension '" + extension + "'");
+		if (hints == null) throw new GdxRuntimeException("no default hints for extension '" + extension + "'");
+
+		Model model = null;
+		StringBuilder errors = new StringBuilder();
+		for (int i = 0; i < loaders.size; i++) {
+			ModelLoader loader = loaders.get(i);
+			ModelLoaderHints hint = hints.get(i);
+			try {
+				model = loader.load(file, hint);
+			} catch (GdxRuntimeException e) {
+				errors.append("Couldn't load '" + file.name() + "' with loader of type " + loader.getClass().getName() + ": "
+					+ e.getMessage() + "\n");
+			}
+		}
+
+		if (model == null)
+			throw new GdxRuntimeException(errors.toString());
+		else
+			return model;
+	}
+
+	/** Loads the specified file with one of the loaders registered with this ModelLoaderRegistry. Uses the extension to determine
+	 * which loader to use. The comparison of extensions is done case insensitive.
+	 * @param file the file to be loaded
+	 * @param hints the {@link ModelLoaderHints} to use
+	 * @return the {@link Model}
+	 * @throws GdxRuntimeException in case the model could not be loaded. */
+	public static Model load (FileHandle file, ModelLoaderHints hints) {
+		String name = file.name();
+		int dotIndex = name.lastIndexOf('.');
+		if (dotIndex == -1)
+			throw new GdxRuntimeException("file '" + file.name()
+				+ "' does not have an extension that can be matched to a ModelLoader");
+		String extension = name.substring(dotIndex + 1).toLowerCase();
+
+		Array<ModelLoader> loaders = ModelLoaderRegistry.loaders.get(extension);
+		if (loaders == null) throw new GdxRuntimeException("no loaders for extension '" + extension + "'");
+
+		Model model = null;
+		StringBuilder errors = new StringBuilder();
+		for (int i = 0; i < loaders.size; i++) {
+			ModelLoader loader = loaders.get(i);
+			try {
+				model = loader.load(file, hints);
+			} catch (GdxRuntimeException e) {
+				errors.append("Couldn't load '" + file.name() + "' with loader of type " + loader.getClass().getName() + ": "
+					+ e.getMessage() + "\n");
+			}
+		}
+
+		if (model == null)
+			throw new GdxRuntimeException(errors.toString());
+		else
+			return model;
+	}
+
+	/** Loads the specified file with one of the loaders registered with this ModelLoaderRegistry. Uses the extension to determine
+	 * which loader to use. The comparison of extensions is done case insensitive. Uses only {@link StillModelLoader} instances.
+	 * @param file the file to be loaded
+	 * @return the {@link Model}
+	 * @throws GdxRuntimeException in case the model could not be loaded. */
+	public static StillModel loadStillModel (FileHandle file) {
+		String name = file.name();
+		int dotIndex = name.lastIndexOf('.');
+		if (dotIndex == -1)
+			throw new GdxRuntimeException("file '" + file.name()
+				+ "' does not have an extension that can be matched to a ModelLoader");
+		String extension = name.substring(dotIndex + 1).toLowerCase();
+
+		Array<ModelLoader> loaders = ModelLoaderRegistry.loaders.get(extension);
+		Array<ModelLoaderHints> hints = ModelLoaderRegistry.defaultHints.get(extension);
+		if (loaders == null) throw new GdxRuntimeException("no loaders for extension '" + extension + "'");
+		if (hints == null) throw new GdxRuntimeException("no default hints for extension '" + extension + "'");
+
+		StillModel model = null;
+		StringBuilder errors = new StringBuilder();
+		for (int i = 0; i < loaders.size; i++) {
+			ModelLoader loader = loaders.get(i);
+			ModelLoaderHints hint = hints.get(i);
+			try {
+				if (loader instanceof StillModelLoader) {
+					model = ((StillModelLoader)loader).load(file, hint);
+				}
+			} catch (GdxRuntimeException e) {
+				errors.append("Couldn't load '" + file.name() + "' with loader of type " + loader.getClass().getName() + ": "
+					+ e.getMessage() + "\n");
+			}
+		}
+
+		if (model == null)
+			throw new GdxRuntimeException("Couldn't load model '" + file.name() + "', " + errors.toString());
+		else
+			return model;
+	}
+
+	/** Loads the specified file with one of the loaders registered with this ModelLoaderRegistry. Uses the extension to determine
+	 * which loader to use. The comparison of extensions is done case insensitive. Uses only {@link StillModelLoader} instances.
+	 * @param file the file to be loaded
+	 * @param hints the ModelLoaderHints to be used.
+	 * @return the {@link Model}
+	 * @throws GdxRuntimeException in case the model could not be loaded. */
+	public static StillModel loadStillModel (FileHandle file, ModelLoaderHints hints) {
+		String name = file.name();
+		int dotIndex = name.lastIndexOf('.');
+		if (dotIndex == -1)
+			throw new GdxRuntimeException("file '" + file.name()
+				+ "' does not have an extension that can be matched to a ModelLoader");
+		String extension = name.substring(dotIndex + 1).toLowerCase();
+
+		Array<ModelLoader> loaders = ModelLoaderRegistry.loaders.get(extension);
+		if (loaders == null) throw new GdxRuntimeException("no loaders for extension '" + extension + "'");
+
+		StillModel model = null;
+		StringBuilder errors = new StringBuilder();
+		for (int i = 0; i < loaders.size; i++) {
+			ModelLoader loader = loaders.get(i);
+			try {
+				if (loader instanceof StillModelLoader) {
+					model = ((StillModelLoader)loader).load(file, hints);
+				}
+			} catch (GdxRuntimeException e) {
+				errors.append("Couldn't load '" + file.name() + "' with loader of type " + loader.getClass().getName() + ": "
+					+ e.getMessage() + "\n");
+			}
+		}
+
+		if (model == null)
+			throw new GdxRuntimeException("Couldn't load model '" + file.name() + "', " + errors.toString());
+		else
+			return model;
+	}
+
+	/** Loads the specified file with one of the loaders registered with this ModelLoaderRegistry. Uses the extension to determine
+	 * which loader to use. The comparison of extensions is done case insensitive. Uses only {@link KeyframedModelLoader}
+	 * instances.
+	 * @param file the file to be loaded
+	 * @return the {@link Model}
+	 * @throws GdxRuntimeException in case the model could not be loaded. */
+	public static KeyframedModel loadKeyframedModel (FileHandle file) {
+		String name = file.name();
+		int dotIndex = name.lastIndexOf('.');
+		if (dotIndex == -1)
+			throw new GdxRuntimeException("file '" + file.name()
+				+ "' does not have an extension that can be matched to a ModelLoader");
+		String extension = name.substring(dotIndex + 1).toLowerCase();
+
+		Array<ModelLoader> loaders = ModelLoaderRegistry.loaders.get(extension);
+		Array<ModelLoaderHints> hints = ModelLoaderRegistry.defaultHints.get(extension);
+		if (loaders == null) throw new GdxRuntimeException("no loaders for extension '" + extension + "'");
+		if (hints == null) throw new GdxRuntimeException("no default hints for extension '" + extension + "'");
+
+		KeyframedModel model = null;
+		StringBuilder errors = new StringBuilder();
+		for (int i = 0; i < loaders.size; i++) {
+			ModelLoader loader = loaders.get(i);
+			ModelLoaderHints hint = hints.get(i);
+			try {
+				if (loader instanceof KeyframedModelLoader) {
+					model = ((KeyframedModelLoader)loader).load(file, hint);
+				}
+			} catch (GdxRuntimeException e) {
+				errors.append("Couldn't load '" + file.name() + "' with loader of type " + loader.getClass().getName() + ": "
+					+ e.getMessage() + "\n");
+			}
+		}
+
+		if (model == null)
+			throw new GdxRuntimeException(errors.toString());
+		else
+			return model;
+	}
+
+	/** Loads the specified file with one of the loaders registered with this ModelLoaderRegistry. Uses the extension to determine
+	 * which loader to use. The comparison of extensions is done case insensitive. Uses only {@link KeyframedModelLoader}
+	 * instances.
+	 * @param file the file to be loaded
+	 * @param hints the Model
+	 * @return the {@link Model}
+	 * @throws GdxRuntimeException in case the model could not be loaded. */
+	public static KeyframedModel loadKeyframedModel (FileHandle file, ModelLoaderHints hints) {
+		String name = file.name();
+		int dotIndex = name.lastIndexOf('.');
+		if (dotIndex == -1)
+			throw new GdxRuntimeException("file '" + file.name()
+				+ "' does not have an extension that can be matched to a ModelLoader");
+		String extension = name.substring(dotIndex + 1).toLowerCase();
+
+		Array<ModelLoader> loaders = ModelLoaderRegistry.loaders.get(extension);
+		if (loaders == null) throw new GdxRuntimeException("no loaders for extension '" + extension + "'");
+
+		KeyframedModel model = null;
+		StringBuilder errors = new StringBuilder();
+		for (int i = 0; i < loaders.size; i++) {
+			ModelLoader loader = loaders.get(i);
+			try {
+				if (loader instanceof KeyframedModelLoader) {
+					model = ((KeyframedModelLoader)loader).load(file, hints);
+				}
+			} catch (GdxRuntimeException e) {
+				errors.append("Couldn't load '" + file.name() + "' with loader of type " + loader.getClass().getName() + ": "
+					+ e.getMessage() + "\n");
+			}
+		}
+
+		if (model == null)
+			throw new GdxRuntimeException(errors.toString());
+		else
+			return model;
+	}
+
+	/** Loads the specified file with one of the loaders registered with this ModelLoaderRegistry. Uses the extension to determine
+	 * which loader to use. The comparison of extensions is done case insensitive. Uses only {@link SkeletonModelLoader} instances.
+	 * @param file the file to be loaded
+	 * @return the {@link Model}
+	 * @throws GdxRuntimeException in case the model could not be loaded. */
+	public static SkeletonModel loadSkeletonModel (FileHandle file) {
+		String name = file.name();
+		int dotIndex = name.lastIndexOf('.');
+		if (dotIndex == -1)
+			throw new GdxRuntimeException("file '" + file.name()
+				+ "' does not have an extension that can be matched to a ModelLoader");
+		String extension = name.substring(dotIndex + 1).toLowerCase();
+
+		Array<ModelLoader> loaders = ModelLoaderRegistry.loaders.get(extension);
+		Array<ModelLoaderHints> hints = ModelLoaderRegistry.defaultHints.get(extension);
+		if (loaders == null) throw new GdxRuntimeException("no loaders for extension '" + extension + "'");
+		if (hints == null) throw new GdxRuntimeException("no default hints for extension '" + extension + "'");
+
+		SkeletonModel model = null;
+		StringBuilder errors = new StringBuilder();
+		for (int i = 0; i < loaders.size; i++) {
+			ModelLoader loader = loaders.get(i);
+			ModelLoaderHints hint = hints.get(i);
+			try {
+				if (loader instanceof SkeletonModelLoader) {
+					model = ((SkeletonModelLoader)loader).load(file, hint);
+				}
+			} catch (GdxRuntimeException e) {
+				errors.append("Couldn't load '" + file.name() + "' with loader of type " + loader.getClass().getName() + ": "
+					+ e.getMessage());
+			}
+		}
+
+		if (model == null)
+			throw new GdxRuntimeException(errors.toString());
+		else
+			return model;
+	}
+
+	/** Loads the specified file with one of the loaders registered with this ModelLoaderRegistry. Uses the extension to determine
+	 * which loader to use. The comparison of extensions is done case insensitive. Uses only {@link SkeletonModelLoader} instances.
+	 * @param file the file to be loaded
+	 * @param hints the ModelLoaderHints to use
+	 * @return the {@link Model}
+	 * @throws GdxRuntimeException in case the model could not be loaded. */
+	public static SkeletonModel loadSkeletonModel (FileHandle file, ModelLoaderHints hints) {
+		String name = file.name();
+		int dotIndex = name.lastIndexOf('.');
+		if (dotIndex == -1)
+			throw new GdxRuntimeException("file '" + file.name()
+				+ "' does not have an extension that can be matched to a ModelLoader");
+		String extension = name.substring(dotIndex + 1).toLowerCase();
+
+		Array<ModelLoader> loaders = ModelLoaderRegistry.loaders.get(extension);
+		if (loaders == null) throw new GdxRuntimeException("no loaders for extension '" + extension + "'");
+
+		SkeletonModel model = null;
+		StringBuilder errors = new StringBuilder();
+		for (int i = 0; i < loaders.size; i++) {
+			ModelLoader loader = loaders.get(i);
+			try {
+				if (loader instanceof SkeletonModelLoader) {
+					model = ((SkeletonModelLoader)loader).load(file, hints);
+				}
+			} catch (GdxRuntimeException e) {
+				errors.append("Couldn't load '" + file.name() + "' with loader of type " + loader.getClass().getName() + ": "
+					+ e.getMessage());
+			}
+		}
+
+		if (model == null)
+			throw new GdxRuntimeException(errors.toString());
+		else
+			return model;
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/SkeletonModelLoader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/SkeletonModelLoader.java
new file mode 100644
index 0000000..6f783db
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/SkeletonModelLoader.java
@@ -0,0 +1,27 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.loaders;
+
+import com.badlogic.gdx.files.FileHandle;
+import com.badlogic.gdx.graphics.g3d.old.ModelLoaderHints;
+import com.badlogic.gdx.graphics.g3d.old.model.skeleton.SkeletonModel;
+
+/** Interface for classes loading {@link SkeletonModel} instances.
+ * @author mzechner */
+public interface SkeletonModelLoader extends ModelLoader {
+	public SkeletonModel load (FileHandle file, ModelLoaderHints hints);
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/StillModelLoader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/StillModelLoader.java
new file mode 100644
index 0000000..6281339
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/StillModelLoader.java
@@ -0,0 +1,27 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.loaders;
+
+import com.badlogic.gdx.files.FileHandle;
+import com.badlogic.gdx.graphics.g3d.old.ModelLoaderHints;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
+
+/** Interface for loaders loading {@link StillModel} instances.
+ * @author mzechner */
+public interface StillModelLoader extends ModelLoader {
+	public StillModel load (FileHandle handle, ModelLoaderHints hints);
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/g3d/ChunkReader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/g3d/ChunkReader.java
new file mode 100644
index 0000000..8a59cb3
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/g3d/ChunkReader.java
@@ -0,0 +1,332 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.loaders.g3d;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Arrays;
+
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+import static com.badlogic.gdx.graphics.g3d.old.loaders.g3d.G3dConstants.*;
+
+public class ChunkReader {
+	public static class Chunk {
+		int id;
+		Chunk parent;
+		Array<Chunk> children = new Array<Chunk>();
+		ByteArrayInputStream payload;
+		byte[] payloadBytes;
+		int offset = 0;
+		CountingDataInputStream in;
+
+		protected Chunk (int id, Chunk parent, byte[] bytes, int offset, int size) throws IOException {
+			this.id = id;
+			this.parent = parent;
+			this.payload = new ByteArrayInputStream(bytes, offset, size);
+			this.payloadBytes = bytes;
+			this.offset = offset;
+			this.in = new CountingDataInputStream(payload);
+		}
+
+		public int getId () {
+			return id;
+		}
+
+		public Chunk getParent () {
+			return parent;
+		}
+
+		public Array<Chunk> getChildren () {
+			return children;
+		}
+
+		public int readByte () {
+			try {
+				return in.readByte();
+			} catch (IOException e) {
+				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
+			}
+		}
+
+		public short readShort () {
+			try {
+				return in.readShort();
+			} catch (IOException e) {
+				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
+			}
+		}
+
+		public int readInt () {
+			try {
+				return in.readInt();
+			} catch (IOException e) {
+				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
+			}
+		}
+
+		public long readLong () {
+			try {
+				return in.readLong();
+			} catch (IOException e) {
+				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
+			}
+		}
+
+		public float readFloat () {
+			try {
+				return in.readFloat();
+			} catch (IOException e) {
+				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
+			}
+		}
+
+		public double readDouble () {
+			try {
+				return in.readDouble();
+			} catch (IOException e) {
+				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
+			}
+		}
+
+		public byte[] readBytes () {
+			try {
+				int len = in.readInt();
+				byte[] v = new byte[len];
+				for (int i = 0; i < len; i++) {
+					v[i] = in.readByte();
+				}
+				return v;
+			} catch (IOException e) {
+				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
+			}
+		}
+
+		public short[] readShorts () {
+			try {
+				int len = in.readInt();
+				short[] v = new short[len];
+				for (int i = 0; i < len; i++) {
+					v[i] = in.readShort();
+				}
+				return v;
+			} catch (IOException e) {
+				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
+			}
+		}
+
+		public int[] readInts () {
+			try {
+				int len = in.readInt();
+				int[] v = new int[len];
+				for (int i = 0; i < len; i++) {
+					v[i] = in.readInt();
+				}
+				return v;
+			} catch (IOException e) {
+				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
+			}
+		}
+
+		public long[] readLongs () {
+			try {
+				int len = in.readInt();
+				long[] v = new long[len];
+				for (int i = 0; i < len; i++) {
+					v[i] = in.readLong();
+				}
+				return v;
+			} catch (IOException e) {
+				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
+			}
+		}
+
+		public float[] readFloats () {
+			try {
+				int len = in.readInt();
+				float[] v = new float[len];
+				for (int i = 0; i < len; i++) {
+					v[i] = in.readFloat();
+				}
+				return v;
+			} catch (IOException e) {
+				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
+			}
+		}
+
+		public double[] readDoubles () {
+			try {
+				int len = in.readInt();
+				double[] v = new double[len];
+				for (int i = 0; i < len; i++) {
+					v[i] = in.readDouble();
+				}
+				return v;
+			} catch (IOException e) {
+				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
+			}
+		}
+
+		public String readString () {
+			try {
+				int len = in.readInt();
+				byte[] bytes = new byte[len];
+				in.readFully(bytes);
+				return new String(bytes, "UTF-8");
+			} catch (IOException e) {
+				throw new GdxRuntimeException("Couldn't read payload, " + e.getMessage(), e);
+			}
+		}
+
+		public Chunk getChild (int id) {
+			for (int i = 0; i < children.size; i++) {
+				Chunk child = children.get(i);
+				if (child.getId() == id) return child;
+			}
+			return null;
+		}
+
+		public Chunk[] getChildren (int id) {
+			Array<Chunk> meshes = new Array<Chunk>(true, 16, Chunk.class);
+			for (int i = 0; i < children.size; i++) {
+				Chunk child = children.get(i);
+				if (child.getId() == id) meshes.add(child);
+			}
+			meshes.shrink();
+			return meshes.items;
+		}
+	}
+
+	public static Chunk readChunks (InputStream in) throws IOException {
+		return loadChunks(in, 0);
+	}
+
+	private static Chunk loadChunks (InputStream in, int fileSize) throws IOException {
+		byte[] bytes = readStream(in, fileSize);
+		CountingDataInputStream din = new CountingDataInputStream(new ByteArrayInputStream(bytes));
+		return loadChunk(din, bytes);
+	}
+
+	private static Chunk loadChunk (CountingDataInputStream din, byte[] bytes) throws IOException {
+		int id = din.readInt();
+		int payloadSize = din.readInt();
+		int numChildren = din.readInt();
+		int offset = din.getReadBytes();
+		din.skipBytes(payloadSize);
+		Chunk chunk = new Chunk(id, null, bytes, offset, payloadSize);
+		for (int i = 0; i < numChildren; i++) {
+			Chunk child = loadChunk(din, bytes);
+			child.parent = chunk;
+			chunk.children.add(child);
+		}
+		return chunk;
+	}
+
+	private static byte[] readStream (InputStream in, int size) throws IOException {
+		if (size == 0) {
+			ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+			byte[] buffer = new byte[10 * 1024];
+			int readBytes = 0;
+			while ((readBytes = in.read(buffer)) != -1) {
+				bytes.write(buffer, 0, readBytes);
+			}
+			return bytes.toByteArray();
+		} else {
+			byte[] bytes = new byte[size];
+			DataInputStream din = new DataInputStream(in);
+			din.readFully(bytes);
+			return bytes;
+		}
+	}
+
+	/** Prints a textual representation of the given Chunk hierarchy
+	 * @param chunk the hierarchy root {@link Chunk} */
+	public static void printChunks (Chunk chunk) {
+		printChunks(chunk, 0);
+	}
+
+	private static void printChunks (Chunk chunk, int level) {
+		String id = null;
+		String payload = null;
+		switch (chunk.getId()) {
+		case G3D_ROOT:
+			id = "G3D_ROOT";
+			break;
+		case VERSION_INFO:
+			id = "VERSION_INFO";
+			int major = chunk.readByte();
+			int minor = chunk.readByte();
+			payload = rep("   ", level + 1) + "major: " + major + ", minor: " + minor;
+			break;
+		case STILL_MODEL:
+			id = "STILL_MODEL";
+			int subMeshes = chunk.readInt();
+			payload = rep("   ", level + 1) + "#submeshes: " + subMeshes;
+			break;
+		case STILL_SUBMESH:
+			id = "STILL_SUBMESH";
+			payload = rep("   ", level + 1) + "name: " + chunk.readString() + ", primitive type: " + chunk.readInt();
+			break;
+		case VERTEX_ATTRIBUTE:
+			id = "VERTEX_ATTRIBUTE";
+			int usage = chunk.readInt();
+			int components = chunk.readInt();
+			String name = chunk.readString();
+			payload = rep("   ", level + 1) + "usage: " + usage + ", components: " + components + ", name: " + name;
+			break;
+		case VERTEX_ATTRIBUTES:
+			id = "VERTEX_ATTRIBUTES";
+			int numAttributes = chunk.readInt();
+			payload = rep("   ", level + 1) + "#attributes: " + numAttributes;
+			break;
+		case VERTEX_LIST:
+			id = "VERTEX_LIST";
+			int numVertices = chunk.readInt();
+			float[] vertices = chunk.readFloats();
+			payload = rep("   ", level + 1) + "#vertices: " + numVertices + ": " + Arrays.toString(vertices).substring(0, 400);
+			break;
+		case INDEX_LIST:
+			id = "INDEX_LIST";
+			int numIndices = chunk.readInt();
+			short[] indices = chunk.readShorts();
+			payload = rep("   ", level + 1) + "#indices: " + numIndices + ": " + Arrays.toString(indices).substring(0, 400);
+			break;
+		default:
+			id = "unknown [" + id + "]";
+			payload = rep("   ", level + 1) + "unknown";
+			break;
+		}
+
+		System.out.println(rep("   ", level) + id + " {");
+		if (payload != null) System.out.println(payload);
+		for (Chunk child : chunk.getChildren()) {
+			printChunks(child, level + 1);
+		}
+		System.out.println(rep("   ", level) + "}");
+	}
+
+	private static String rep (String c, int n) {
+		StringBuffer buf = new StringBuffer();
+		for (int i = 0; i < n; i++)
+			buf.append(c);
+		return buf.toString();
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/g3d/ChunkWriter.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/g3d/ChunkWriter.java
new file mode 100644
index 0000000..62b160b
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/g3d/ChunkWriter.java
@@ -0,0 +1,202 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.loaders.g3d;
+
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+import com.badlogic.gdx.utils.Array;
+
+import static com.badlogic.gdx.graphics.g3d.old.loaders.g3d.G3dConstants.*;
+
+public class ChunkWriter {
+
+	class Chunk {
+		final int id;
+		final Chunk parent;
+		final Array<Chunk> children = new Array<Chunk>();
+		final ByteArrayOutputStream payload = new ByteArrayOutputStream();
+		final DataOutputStream out = new DataOutputStream(payload);
+
+		public Chunk (int id) {
+			this.id = id;
+			this.parent = null;
+		}
+
+		public Chunk (int id, Chunk parent) {
+			this.id = id;
+			this.parent = parent;
+		}
+	}
+
+	final Chunk root;
+	Chunk currChunk;
+
+	public ChunkWriter () {
+		root = new Chunk(G3D_ROOT);
+		currChunk = root;
+	}
+
+	public void newChunk (int id) {
+		Chunk chunk = new Chunk(id, currChunk);
+		currChunk.children.add(chunk);
+		currChunk = chunk;
+	}
+
+	public void endChunk () {
+		currChunk = currChunk.parent;
+	}
+
+	public void writeByte (int v) {
+		try {
+			currChunk.out.writeByte(v);
+		} catch (IOException e) {
+		}
+		;
+	}
+
+	public void writeShort (short v) {
+		try {
+			currChunk.out.writeShort(v);
+		} catch (IOException e) {
+		}
+		;
+	}
+
+	public void writeInt (int v) {
+		try {
+			currChunk.out.writeInt(v);
+		} catch (IOException e) {
+		}
+		;
+	}
+
+	public void writeLong (long v) {
+		try {
+			currChunk.out.writeLong(v);
+		} catch (IOException e) {
+		}
+		;
+	}
+
+	public void writeFloat (float v) {
+		try {
+			currChunk.out.writeFloat(v);
+		} catch (IOException e) {
+		}
+		;
+	}
+
+	public void writeDouble (double v) {
+		try {
+			currChunk.out.writeDouble(v);
+		} catch (IOException e) {
+		}
+		;
+	}
+
+	public void writeString (String v) {
+		try {
+			byte[] bytes = v.getBytes("UTF-8");
+			currChunk.out.writeInt(bytes.length);
+			currChunk.out.write(bytes);
+		} catch (IOException e) {
+		}
+	}
+
+	public void writeToStream (OutputStream out) throws IOException {
+		writeToStream(root, new DataOutputStream(out));
+	}
+
+	private void writeToStream (Chunk chunk, DataOutputStream out) throws IOException {
+		// write id, payload size in bytes and number of children
+		out.writeInt(chunk.id);
+		out.writeInt(chunk.payload.size());
+		out.writeInt(chunk.children.size);
+
+		// write payload
+		out.write(chunk.payload.toByteArray());
+
+		// recursively write children
+		for (int i = 0; i < chunk.children.size; i++) {
+			Chunk child = chunk.children.get(i);
+			writeToStream(child, out);
+		}
+	}
+
+	public void writeBytes (byte[] v) {
+		try {
+			currChunk.out.writeInt(v.length);
+			for (int i = 0; i < v.length; i++) {
+				currChunk.out.writeByte(v[i]);
+			}
+		} catch (IOException e) {
+		}
+	}
+
+	public void writeShorts (short[] v) {
+		try {
+			currChunk.out.writeInt(v.length);
+			for (int i = 0; i < v.length; i++) {
+				currChunk.out.writeShort(v[i]);
+			}
+		} catch (IOException e) {
+		}
+	}
+
+	public void writeInts (int[] v) {
+		try {
+			currChunk.out.writeInt(v.length);
+			for (int i = 0; i < v.length; i++) {
+				currChunk.out.writeInt(v[i]);
+			}
+		} catch (IOException e) {
+		}
+	}
+
+	public void writeLongs (long[] v) {
+		try {
+			currChunk.out.writeInt(v.length);
+			for (int i = 0; i < v.length; i++) {
+				currChunk.out.writeLong(v[i]);
+			}
+		} catch (IOException e) {
+		}
+	}
+
+	public void writeFloats (float[] v) {
+		try {
+			currChunk.out.writeInt(v.length);
+			for (int i = 0; i < v.length; i++) {
+				currChunk.out.writeFloat(v[i]);
+			}
+		} catch (IOException e) {
+		}
+	}
+
+	public void writeDoubles (double[] v) {
+		try {
+			currChunk.out.writeInt(v.length);
+			for (int i = 0; i < v.length; i++) {
+				currChunk.out.writeDouble(v[i]);
+			}
+		} catch (IOException e) {
+		}
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/g3d/CountingDataInputStream.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/g3d/CountingDataInputStream.java
new file mode 100644
index 0000000..218af13
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/g3d/CountingDataInputStream.java
@@ -0,0 +1,124 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.loaders.g3d;
+
+import java.io.DataInput;
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+public class CountingDataInputStream implements DataInput {
+	int readBytes = 0;
+	DataInputStream in;
+
+	public CountingDataInputStream (InputStream in) {
+		this.in = new DataInputStream(in);
+	}
+
+	public int getReadBytes () {
+		return readBytes;
+	}
+
+	@Override
+	public void readFully (byte[] b) throws IOException {
+		readBytes += b.length;
+		in.readFully(b);
+	}
+
+	@Override
+	public void readFully (byte[] b, int off, int len) throws IOException {
+		readBytes += len;
+		in.readFully(b, off, len);
+	}
+
+	@Override
+	public int skipBytes (int n) throws IOException {
+		int skipped = in.skipBytes(n);
+		readBytes += skipped;
+		return skipped;
+	}
+
+	@Override
+	public boolean readBoolean () throws IOException {
+		readBytes += 1;
+		return in.readBoolean();
+	}
+
+	@Override
+	public byte readByte () throws IOException {
+		readBytes += 1;
+		return in.readByte();
+	}
+
+	@Override
+	public int readUnsignedByte () throws IOException {
+		readBytes += 1;
+		return in.readUnsignedByte();
+	}
+
+	@Override
+	public short readShort () throws IOException {
+		readBytes += 2;
+		return in.readShort();
+	}
+
+	@Override
+	public int readUnsignedShort () throws IOException {
+		readBytes += 2;
+		return in.readUnsignedShort();
+	}
+
+	@Override
+	public char readChar () throws IOException {
+		readBytes += 2;
+		return in.readChar();
+	}
+
+	@Override
+	public int readInt () throws IOException {
+		readBytes += 4;
+		return in.readInt();
+	}
+
+	@Override
+	public long readLong () throws IOException {
+		readBytes += 8;
+		return in.readLong();
+	}
+
+	@Override
+	public float readFloat () throws IOException {
+		readBytes += 4;
+		return in.readFloat();
+	}
+
+	@Override
+	public double readDouble () throws IOException {
+		readBytes += 8;
+		return in.readDouble();
+	}
+
+	@Override
+	public String readLine () throws IOException {
+		throw new UnsupportedOperationException("Not implemented");
+	}
+
+	@Override
+	public String readUTF () throws IOException {
+		throw new UnsupportedOperationException("Not implemented");
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/g3d/G3dConstants.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/g3d/G3dConstants.java
new file mode 100644
index 0000000..064938b
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/g3d/G3dConstants.java
@@ -0,0 +1,57 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.loaders.g3d;
+
+public class G3dConstants {
+	// Version info for file format
+	public static final byte MAJOR_VERSION = 0;
+	public static final byte MINOR_VERSION = 1;
+
+	// Unique IDs for chunk declarations
+	public static final int G3D_ROOT = 0x4733441A;
+	public static final int VERSION_INFO = 0x0001;
+
+	// still model specific constants
+	public static final int STILL_MODEL = 0x1000;
+	public static final int STILL_SUBMESH = 0x1100;
+
+	// keyframed model specific constants
+	public static final int KEYFRAMED_MODEL = 0x2000;
+	public static final int KEYFRAMED_SUBMESH = 0x2200;
+	public static final int KEYFRAMED_ANIMATION = 0x2300;
+	public static final int KEYFRAMED_FRAME = 0x2400;
+	
+	// skeleton model specific constants
+	public static final int SKELETON_MODEL = 0x4000;
+	public static final int SKELETON_SUBMESH = 0x4200;
+	public static final int SKELETON_ANIMATIONS = 0x4300;
+	public static final int SKELETON_ANIMATION = 0x4400;
+	public static final int SKELETON = 0x4500;
+	public static final int SKELETON_HIERARCHY = 0x4600;
+	public static final int SKELETON_JOINT = 0x4700;
+	public static final int SKELETON_KEYFRAME = 0x4800;
+
+	// constants used for all types of models, mostly to describe a mesh
+	public static final int VERTEX_LIST = 0x1110;
+	public static final int INDEX_LIST = 0x1111;
+	public static final int VERTEX_ATTRIBUTES = 0x1120;
+	public static final int VERTEX_ATTRIBUTE = 0x1121;
+	public static final int BONE_WEIGHTS = 0x1130;
+	public static final int BONE_WEIGHT = 0x1131;
+	public static final int BONE_ASSIGNMENTS = 0x1140;
+	public static final int BONE_ASSIGNMENT = 0x1141;
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/g3d/G3dExporter.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/g3d/G3dExporter.java
new file mode 100644
index 0000000..ff82a47
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/g3d/G3dExporter.java
@@ -0,0 +1,364 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.loaders.g3d;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+import com.badlogic.gdx.files.FileHandle;
+import com.badlogic.gdx.graphics.VertexAttribute;
+import com.badlogic.gdx.graphics.g3d.old.model.keyframe.Keyframe;
+import com.badlogic.gdx.graphics.g3d.old.model.keyframe.KeyframedAnimation;
+import com.badlogic.gdx.graphics.g3d.old.model.keyframe.KeyframedModel;
+import com.badlogic.gdx.graphics.g3d.old.model.keyframe.KeyframedSubMesh;
+import com.badlogic.gdx.graphics.g3d.old.model.skeleton.SkeletonAnimation;
+import com.badlogic.gdx.graphics.g3d.old.model.skeleton.SkeletonJoint;
+import com.badlogic.gdx.graphics.g3d.old.model.skeleton.SkeletonKeyframe;
+import com.badlogic.gdx.graphics.g3d.old.model.skeleton.SkeletonModel;
+import com.badlogic.gdx.graphics.g3d.old.model.skeleton.SkeletonSubMesh;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillSubMesh;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+public class G3dExporter {
+	public static void export (StillModel model, FileHandle file) {
+		ChunkWriter writer = new ChunkWriter();
+
+		// write version info
+		writer.newChunk(G3dConstants.VERSION_INFO);
+		writer.writeByte(G3dConstants.MAJOR_VERSION);
+		writer.writeByte(G3dConstants.MINOR_VERSION);
+		writer.endChunk();
+
+		// write still model
+		writer.newChunk(G3dConstants.STILL_MODEL);
+		writer.writeInt(model.subMeshes.length);
+
+		// write sub mesh
+		for (StillSubMesh mesh : model.subMeshes) {
+			// start sub mesh
+			writer.newChunk(G3dConstants.STILL_SUBMESH);
+			writer.writeString(mesh.name == null ? "" : mesh.name);
+			writer.writeInt(mesh.primitiveType);
+
+			// write vertex attributes
+			writer.newChunk(G3dConstants.VERTEX_ATTRIBUTES);
+			writer.writeInt(mesh.mesh.getVertexAttributes().size());
+			for (int i = 0; i < mesh.mesh.getVertexAttributes().size(); i++) {
+				VertexAttribute attribute = mesh.mesh.getVertexAttributes().get(i);
+				writer.newChunk(G3dConstants.VERTEX_ATTRIBUTE);
+				writer.writeInt(attribute.usage);
+				writer.writeInt(attribute.numComponents);
+				writer.writeString(attribute.alias);
+				writer.endChunk();
+			}
+			writer.endChunk();
+
+			// write vertices
+			writer.newChunk(G3dConstants.VERTEX_LIST);
+			int numFloats = mesh.mesh.getNumVertices() * mesh.mesh.getVertexSize() / 4;
+			float[] vertices = new float[numFloats];
+			mesh.mesh.getVertices(vertices);
+			writer.writeInt(mesh.mesh.getNumVertices());
+			writer.writeFloats(vertices);
+			writer.endChunk();
+
+			// write indices
+			writer.newChunk(G3dConstants.INDEX_LIST);
+			int numShorts = mesh.mesh.getNumIndices();
+			short[] indices = new short[numShorts];
+			mesh.mesh.getIndices(indices);
+			writer.writeInt(numShorts);
+			writer.writeShorts(indices);
+			writer.endChunk();
+
+			// end sub mesh
+			writer.endChunk();
+		}
+
+		// end still model
+		writer.endChunk();
+
+		// write to file
+		OutputStream out = null;
+		try {
+			out = file.write(false);
+			writer.writeToStream(out);
+		} catch (IOException e) {
+			throw new GdxRuntimeException("An error occured while exporting the still model, " + e.getMessage(), e);
+		} finally {
+			if (out != null) try {
+				out.close();
+			} catch (IOException e) {
+			}
+		}
+	}
+
+	public static void export (KeyframedModel model, FileHandle file) {
+		ChunkWriter writer = new ChunkWriter();
+
+		// write version info
+		writer.newChunk(G3dConstants.VERSION_INFO);
+		writer.writeByte(G3dConstants.MAJOR_VERSION);
+		writer.writeByte(G3dConstants.MINOR_VERSION);
+		writer.endChunk();
+
+		// write keyframed model
+		writer.newChunk(G3dConstants.KEYFRAMED_MODEL);
+		writer.writeInt(model.subMeshes.length);
+
+		for (KeyframedSubMesh mesh : model.subMeshes) {
+			// writes keyframed submesh
+			writer.newChunk(G3dConstants.KEYFRAMED_SUBMESH);
+			writer.writeString(mesh.name == null ? "" : mesh.name);
+			writer.writeInt(mesh.primitiveType);
+			writer.writeInt(mesh.animatedComponents);
+			writer.writeInt(mesh.animations.size);
+
+			// write vertex attributes
+			writer.newChunk(G3dConstants.VERTEX_ATTRIBUTES);
+			writer.writeInt(mesh.mesh.getVertexAttributes().size());
+			for (int i = 0; i < mesh.mesh.getVertexAttributes().size(); i++) {
+				VertexAttribute attribute = mesh.mesh.getVertexAttributes().get(i);
+				writer.newChunk(G3dConstants.VERTEX_ATTRIBUTE);
+				writer.writeInt(attribute.usage);
+				writer.writeInt(attribute.numComponents);
+				writer.writeString(attribute.alias);
+				writer.endChunk();
+			}
+			writer.endChunk();
+
+			// write static components, sort of like a bind pose mesh
+			writer.newChunk(G3dConstants.VERTEX_LIST);
+			int numFloats = mesh.mesh.getNumVertices() * mesh.mesh.getVertexSize() / 4;
+			float[] vertices = new float[numFloats];
+			mesh.mesh.getVertices(vertices);
+			writer.writeInt(mesh.mesh.getNumVertices());
+			writer.writeFloats(vertices);
+			writer.endChunk();
+
+			// write indices
+			writer.newChunk(G3dConstants.INDEX_LIST);
+			int numShorts = mesh.mesh.getNumIndices();
+			short[] indices = new short[numShorts];
+			mesh.mesh.getIndices(indices);
+			writer.writeInt(mesh.mesh.getNumIndices());
+			writer.writeShorts(indices);
+			writer.endChunk();
+
+			// write animations
+			for (String animationName : mesh.animations.keys()) {
+				KeyframedAnimation animation = mesh.animations.get(animationName);
+
+				// write keyframed animation
+				writer.newChunk(G3dConstants.KEYFRAMED_ANIMATION);
+				writer.writeString(animation.name);
+				writer.writeFloat(animation.frameDuration);
+
+				// write key frames
+				writer.writeInt(animation.keyframes.length);
+				for (Keyframe keyframe : animation.keyframes) {
+					// write keyframed
+					writer.newChunk(G3dConstants.KEYFRAMED_FRAME);
+					writer.writeFloat(keyframe.timeStamp);
+					writer.writeFloats(keyframe.vertices);
+					writer.endChunk();
+				}
+				// end keyframed animation
+				writer.endChunk();
+			}
+
+			// end keyframed submesh
+			writer.endChunk();
+		}
+
+		// end keyframed model
+		writer.endChunk();
+
+		// write to file
+		OutputStream out = null;
+		try {
+			out = file.write(false);
+			writer.writeToStream(out);
+		} catch (IOException e) {
+			throw new GdxRuntimeException("An error occured while exporting the still model, " + e.getMessage(), e);
+		} finally {
+			if (out != null) try {
+				out.close();
+			} catch (IOException e) {
+			}
+		}
+	}
+	
+	public static void export (SkeletonModel model, FileHandle file) {
+		ChunkWriter writer = new ChunkWriter();
+
+		// write version info
+		writer.newChunk(G3dConstants.VERSION_INFO);
+		writer.writeByte(G3dConstants.MAJOR_VERSION);
+		writer.writeByte(G3dConstants.MINOR_VERSION);
+		writer.endChunk();
+
+		// write skeleton model
+		writer.newChunk(G3dConstants.SKELETON_MODEL);
+		writer.writeInt(model.subMeshes.length);
+
+		for (SkeletonSubMesh mesh : model.subMeshes) {
+			// writes skeleton submesh
+			writer.newChunk(G3dConstants.SKELETON_SUBMESH);
+			writer.writeString(mesh.name == null ? "" : mesh.name);
+			writer.writeInt(mesh.primitiveType);
+
+			// write vertex attributes
+			writer.newChunk(G3dConstants.VERTEX_ATTRIBUTES);
+			writer.writeInt(mesh.mesh.getVertexAttributes().size());
+			for (int i = 0; i < mesh.mesh.getVertexAttributes().size(); i++) {
+				VertexAttribute attribute = mesh.mesh.getVertexAttributes().get(i);
+				writer.newChunk(G3dConstants.VERTEX_ATTRIBUTE);
+				writer.writeInt(attribute.usage);
+				writer.writeInt(attribute.numComponents);
+				writer.writeString(attribute.alias);
+				writer.endChunk();
+			}
+			writer.endChunk();
+
+			// write static components, sort of like a bind pose mesh
+			writer.newChunk(G3dConstants.VERTEX_LIST);
+			int numFloats = mesh.mesh.getNumVertices() * mesh.mesh.getVertexSize() / 4;
+			writer.writeInt(mesh.mesh.getNumVertices());
+			writer.writeFloats(mesh.vertices);
+			writer.endChunk();
+
+			// write indices
+			writer.newChunk(G3dConstants.INDEX_LIST);
+			int numShorts = mesh.mesh.getNumIndices();
+			writer.writeInt(numShorts);
+			writer.writeShorts(mesh.indices);
+			writer.endChunk();
+			
+			// write bone weight
+			writer.newChunk(G3dConstants.BONE_WEIGHTS);
+			writer.writeInt(mesh.boneWeights.length);
+			for(float array[] : mesh.boneWeights) {
+				writer.newChunk(G3dConstants.BONE_WEIGHT);
+				writer.writeInt(array.length);
+				writer.writeFloats(array);
+				writer.endChunk();
+			}
+			writer.endChunk();
+			
+			// write bone assignment
+			writer.newChunk(G3dConstants.BONE_ASSIGNMENTS);
+			writer.writeInt(mesh.boneAssignments.length);
+			for(int array[] : mesh.boneAssignments) {
+				writer.newChunk(G3dConstants.BONE_ASSIGNMENT);
+				writer.writeInt(array.length);
+				writer.writeInts(array);
+				writer.endChunk();
+			}
+			writer.endChunk();
+
+			// end skeleton submesh
+			writer.endChunk();
+		}
+		
+		//Write Skeleton
+		writer.newChunk(G3dConstants.SKELETON);
+		
+		//Write Skeleton hierarchy
+		writer.newChunk(G3dConstants.SKELETON_HIERARCHY);
+		writer.writeInt(model.skeleton.hierarchy.size);
+		for(SkeletonJoint joint : model.skeleton.hierarchy) {
+			writeSkeletonJoint(writer,joint);
+		}
+		
+		// end Skeleton hierarchy
+		writer.endChunk();
+		
+		//Write Skeleton animations
+		writer.newChunk(G3dConstants.SKELETON_ANIMATIONS);
+		
+		writer.writeInt(model.skeleton.animations.size);
+		for(String animationName : model.skeleton.animations.keys()){
+			writer.newChunk(G3dConstants.SKELETON_ANIMATION);
+			writer.writeString(animationName);
+			SkeletonAnimation animation = model.skeleton.animations.get(animationName);
+			writer.writeFloat(animation.totalDuration);
+			writer.writeInt(animation.perJointkeyFrames.length);
+			for(SkeletonKeyframe array[] : animation.perJointkeyFrames){
+				writer.writeInt(array.length);
+				for(SkeletonKeyframe frame : array) {
+					writer.writeFloat(frame.timeStamp);
+					writer.writeInt(frame.parentIndex);
+					writer.writeFloat(frame.position.x);
+					writer.writeFloat(frame.position.y);
+					writer.writeFloat(frame.position.z);
+					writer.writeFloat(frame.rotation.w);
+					writer.writeFloat(frame.rotation.x);
+					writer.writeFloat(frame.rotation.y);
+					writer.writeFloat(frame.rotation.z);
+					writer.writeFloat(frame.scale.x);
+					writer.writeFloat(frame.scale.y);
+					writer.writeFloat(frame.scale.z);
+				}
+			}
+			writer.endChunk();
+		}
+		
+		// end Skeleton animations
+		writer.endChunk();
+		
+		// end Skeleton
+		writer.endChunk();
+
+		// end skeleton model
+		writer.endChunk();
+
+		// write to file
+		OutputStream out = null;
+		try {
+			out = file.write(false);
+			writer.writeToStream(out);
+		} catch (IOException e) {
+			throw new GdxRuntimeException("An error occured while exporting the still model, " + e.getMessage(), e);
+		} finally {
+			if (out != null) try {
+				out.close();
+			} catch (IOException e) {
+			}
+		}
+	}
+	
+	private static void writeSkeletonJoint(ChunkWriter writer, SkeletonJoint joint) {
+		writer.writeString(joint.name);
+		writer.writeFloat(joint.position.x);
+		writer.writeFloat(joint.position.y);
+		writer.writeFloat(joint.position.z);
+		writer.writeFloat(joint.rotation.w);
+		writer.writeFloat(joint.rotation.x);
+		writer.writeFloat(joint.rotation.y);
+		writer.writeFloat(joint.rotation.z);
+		writer.writeFloat(joint.scale.x);
+		writer.writeFloat(joint.scale.y);
+		writer.writeFloat(joint.scale.z);
+		
+		writer.writeInt(joint.children.size);
+		for(SkeletonJoint child : joint.children) {
+			writeSkeletonJoint(writer,child);
+		}
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/g3d/G3dLoader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/g3d/G3dLoader.java
new file mode 100644
index 0000000..29a22e8
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/g3d/G3dLoader.java
@@ -0,0 +1,447 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.loaders.g3d;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+import com.badlogic.gdx.files.FileHandle;
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.Mesh.VertexDataType;
+import com.badlogic.gdx.graphics.VertexAttribute;
+import com.badlogic.gdx.graphics.g3d.old.ModelLoaderHints;
+import com.badlogic.gdx.graphics.g3d.old.loaders.KeyframedModelLoader;
+import com.badlogic.gdx.graphics.g3d.old.loaders.SkeletonModelLoader;
+import com.badlogic.gdx.graphics.g3d.old.loaders.StillModelLoader;
+import com.badlogic.gdx.graphics.g3d.old.loaders.g3d.ChunkReader.Chunk;
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+import com.badlogic.gdx.graphics.g3d.old.model.keyframe.Keyframe;
+import com.badlogic.gdx.graphics.g3d.old.model.keyframe.KeyframedAnimation;
+import com.badlogic.gdx.graphics.g3d.old.model.keyframe.KeyframedModel;
+import com.badlogic.gdx.graphics.g3d.old.model.keyframe.KeyframedSubMesh;
+import com.badlogic.gdx.graphics.g3d.old.model.skeleton.Skeleton;
+import com.badlogic.gdx.graphics.g3d.old.model.skeleton.SkeletonAnimation;
+import com.badlogic.gdx.graphics.g3d.old.model.skeleton.SkeletonJoint;
+import com.badlogic.gdx.graphics.g3d.old.model.skeleton.SkeletonKeyframe;
+import com.badlogic.gdx.graphics.g3d.old.model.skeleton.SkeletonModel;
+import com.badlogic.gdx.graphics.g3d.old.model.skeleton.SkeletonSubMesh;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillSubMesh;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+import com.badlogic.gdx.utils.ObjectMap;
+
+public class G3dLoader {
+	public static StillModel loadStillModel (FileHandle handle) {
+		Chunk root = null;
+		InputStream in = null;
+		try {
+			in = handle.read();
+			root = ChunkReader.readChunks(in);
+
+			// check root tag
+			if (root.getId() != G3dConstants.G3D_ROOT) throw new GdxRuntimeException("Invalid root tag id: " + root.getId());
+
+			// check version
+			Chunk version = root.getChild(G3dConstants.VERSION_INFO);
+			if (version == null) throw new GdxRuntimeException("No version chunk found");
+			int major = version.readByte();
+			int minor = version.readByte();
+			if (major != 0 || minor != 1)
+				throw new GdxRuntimeException("Invalid version, required 0.1, got " + major + "." + minor);
+
+			// read stillmodel
+			Chunk stillModel = root.getChild(G3dConstants.STILL_MODEL);
+			if (stillModel == null) throw new GdxRuntimeException("No stillmodel chunk found");
+			int numSubMeshes = stillModel.readInt();
+
+			// read submeshes
+			StillSubMesh[] meshes = new StillSubMesh[numSubMeshes];
+			Chunk[] meshChunks = stillModel.getChildren(G3dConstants.STILL_SUBMESH);
+			if (meshChunks.length != numSubMeshes)
+				throw new GdxRuntimeException("Number of submeshes not equal to number specified in still model chunk, expected "
+					+ numSubMeshes + ", got " + meshChunks.length);
+			for (int i = 0; i < numSubMeshes; i++) {
+				// read submesh name and primitive type
+				Chunk subMesh = meshChunks[i];
+				String name = subMesh.readString();
+				int primitiveType = subMesh.readInt();
+
+				// read attributes
+				Chunk attributes = subMesh.getChild(G3dConstants.VERTEX_ATTRIBUTES);
+				if (attributes == null) throw new GdxRuntimeException("No vertex attribute chunk given");
+				int numAttributes = attributes.readInt();
+				Chunk[] attributeChunks = attributes.getChildren(G3dConstants.VERTEX_ATTRIBUTE);
+				if (attributeChunks.length != numAttributes)
+					new GdxRuntimeException("Number of attributes not equal to number specified in attributes chunk, expected "
+						+ numAttributes + ", got " + attributeChunks.length);
+				VertexAttribute[] vertAttribs = new VertexAttribute[numAttributes];
+				for (int j = 0; j < numAttributes; j++) {
+					vertAttribs[j] = new VertexAttribute(attributeChunks[j].readInt(), attributeChunks[j].readInt(),
+						attributeChunks[j].readString());
+				}
+
+				// read vertices
+				Chunk vertices = subMesh.getChild(G3dConstants.VERTEX_LIST);
+				int numVertices = vertices.readInt();
+				float[] vertexData = vertices.readFloats();
+
+				// read indices
+				Chunk indices = subMesh.getChild(G3dConstants.INDEX_LIST);
+				int numIndices = indices.readInt();
+				short[] indexData = indices.readShorts();
+
+				StillSubMesh mesh = new StillSubMesh(name, new Mesh(true, numVertices, numIndices, vertAttribs), primitiveType);
+				mesh.mesh.setVertices(vertexData);
+				mesh.mesh.setIndices(indexData);
+				mesh.material = new Material("default");
+				meshes[i] = mesh;
+			}
+
+			StillModel model = new StillModel(meshes);
+			model.setMaterial(new Material("default"));
+			return model;
+		} catch (IOException e) {
+			throw new GdxRuntimeException("Couldn't load still model from '" + handle.name() + "', " + e.getMessage(), e);
+		} finally {
+			if (in != null) try {
+				in.close();
+			} catch (IOException e) {
+			}
+		}
+	}
+
+	public static KeyframedModel loadKeyframedModel (FileHandle handle) {
+		Chunk root = null;
+		InputStream in = null;
+		try {
+			in = handle.read();
+			root = ChunkReader.readChunks(in);
+
+			// check root tag
+			if (root.getId() != G3dConstants.G3D_ROOT) throw new GdxRuntimeException("Invalid root tag id: " + root.getId());
+
+			// check version
+			Chunk version = root.getChild(G3dConstants.VERSION_INFO);
+			if (version == null) throw new GdxRuntimeException("No version chunk found");
+			int major = version.readByte();
+			int minor = version.readByte();
+			if (major != 0 || minor != 1)
+				throw new GdxRuntimeException("Invalid version, required 0.1, got " + major + "." + minor);
+
+			// read keyframed model
+			Chunk stillModel = root.getChild(G3dConstants.KEYFRAMED_MODEL);
+			if (stillModel == null) throw new GdxRuntimeException("No stillmodel chunk found");
+			int numSubMeshes = stillModel.readInt();
+
+			// read submeshes
+			KeyframedSubMesh[] meshes = new KeyframedSubMesh[numSubMeshes];
+			Chunk[] meshChunks = stillModel.getChildren(G3dConstants.KEYFRAMED_SUBMESH);
+			if (meshChunks.length != numSubMeshes)
+				throw new GdxRuntimeException("Number of submeshes not equal to number specified in still model chunk, expected "
+					+ numSubMeshes + ", got " + meshChunks.length);
+			for (int i = 0; i < numSubMeshes; i++) {
+				// read submesh name and primitive type
+				Chunk subMesh = meshChunks[i];
+				String meshName = subMesh.readString();
+				int primitiveType = subMesh.readInt();
+				int animatedComponents = subMesh.readInt();
+				int numAnimations = subMesh.readInt();
+
+				// read attributes
+				Chunk attributes = subMesh.getChild(G3dConstants.VERTEX_ATTRIBUTES);
+				if (attributes == null) throw new GdxRuntimeException("No vertex attribute chunk given");
+				int numAttributes = attributes.readInt();
+				Chunk[] attributeChunks = attributes.getChildren(G3dConstants.VERTEX_ATTRIBUTE);
+				if (attributeChunks.length != numAttributes)
+					new GdxRuntimeException("Number of attributes not equal to number specified in attributes chunk, expected "
+						+ numAttributes + ", got " + attributeChunks.length);
+				VertexAttribute[] vertAttribs = new VertexAttribute[numAttributes];
+				for (int j = 0; j < numAttributes; j++) {
+					vertAttribs[j] = new VertexAttribute(attributeChunks[j].readInt(), attributeChunks[j].readInt(),
+						attributeChunks[j].readString());
+				}
+
+				// read static components, sort of like a bind pose mesh
+				Chunk vertices = subMesh.getChild(G3dConstants.VERTEX_LIST);
+				int numVertices = vertices.readInt();
+				float[] vertexData = vertices.readFloats();
+
+				// read indices
+				Chunk indices = subMesh.getChild(G3dConstants.INDEX_LIST);
+				int numIndices = indices.readInt();
+				short[] indexData = indices.readShorts();
+
+				// read animations
+				ObjectMap<String, KeyframedAnimation> animations = new ObjectMap<String, KeyframedAnimation>();
+				Chunk[] animationChunks = subMesh.getChildren(G3dConstants.KEYFRAMED_ANIMATION);
+				if (numAnimations != animationChunks.length)
+					throw new GdxRuntimeException(
+						"number of keyframed animations not equal to number specified in keyframed submesh chunk, was "
+							+ animationChunks.length + ", expected " + numAnimations);
+				for (int j = 0; j < numAnimations; j++) {
+					Chunk animationChunk = animationChunks[j];
+					String animationName = animationChunk.readString();
+					float frameDuration = animationChunk.readFloat();
+
+					// read keyframes
+					int numKeyframes = animationChunk.readInt();
+					Keyframe[] keyframes = new Keyframe[numKeyframes];
+					Chunk[] keyframeChunks = animationChunk.getChildren(G3dConstants.KEYFRAMED_FRAME);
+					if (numKeyframes != keyframeChunks.length)
+						throw new GdxRuntimeException("number of keyframes not equal to number specified in keyframed animation, was "
+							+ keyframeChunks.length + ", expected " + numKeyframes);
+					for (int k = 0; k < numKeyframes; k++) {
+						Chunk keyframeChunk = keyframeChunks[k];
+						float timeStamp = keyframeChunk.readFloat();
+						float[] keyframeVertices = keyframeChunk.readFloats();
+
+						keyframes[k] = new Keyframe(timeStamp, keyframeVertices);
+					}
+
+					animations.put(animationName, new KeyframedAnimation(animationName, frameDuration, keyframes));
+				}
+
+				Mesh mesh = new Mesh(VertexDataType.VertexArray, false, numVertices, numIndices, vertAttribs);
+				meshes[i] = new KeyframedSubMesh(meshName, mesh, vertexData, animations, animatedComponents, primitiveType);
+				mesh.setVertices(vertexData);
+				mesh.setIndices(indexData);
+			}
+
+			KeyframedModel model = new KeyframedModel(meshes);
+			model.setMaterial(new Material("default"));
+			return model;
+		} catch (IOException e) {
+			throw new GdxRuntimeException("Couldn't load still model from '" + handle.name() + "', " + e.getMessage(), e);
+		} finally {
+			if (in != null) try {
+				in.close();
+			} catch (IOException e) {
+			}
+		}
+	}
+	
+	public static SkeletonModel loadSkeletonModel (FileHandle handle) {
+		Chunk root = null;
+		InputStream in = null;
+		try {
+			in = handle.read();
+			root = ChunkReader.readChunks(in);
+
+			// check root tag
+			if (root.getId() != G3dConstants.G3D_ROOT) throw new GdxRuntimeException("Invalid root tag id: " + root.getId());
+
+			// check version
+			Chunk version = root.getChild(G3dConstants.VERSION_INFO);
+			if (version == null) throw new GdxRuntimeException("No version chunk found");
+			int major = version.readByte();
+			int minor = version.readByte();
+			if (major != 0 || minor != 1)
+				throw new GdxRuntimeException("Invalid version, required 0.1, got " + major + "." + minor);
+
+			// read skeleton model
+			Chunk skeletonModel = root.getChild(G3dConstants.SKELETON_MODEL);
+			if (skeletonModel == null) throw new GdxRuntimeException("No skeletonModel chunk found");
+			int numSubMeshes = skeletonModel.readInt();
+
+			// read submeshes
+			SkeletonSubMesh[] meshes = new SkeletonSubMesh[numSubMeshes];
+			Chunk[] meshChunks = skeletonModel.getChildren(G3dConstants.SKELETON_SUBMESH);
+			if (meshChunks.length != numSubMeshes)
+				throw new GdxRuntimeException("Number of submeshes not equal to number specified in still model chunk, expected "
+					+ numSubMeshes + ", got " + meshChunks.length);
+			for (int i = 0; i < numSubMeshes; i++) {
+				Chunk subMeshChunk = meshChunks[i];
+				
+				// read attributes
+				Chunk attributes = subMeshChunk.getChild(G3dConstants.VERTEX_ATTRIBUTES);
+				if (attributes == null) throw new GdxRuntimeException("No vertex attribute chunk given");
+				int numAttributes = attributes.readInt();
+				Chunk[] attributeChunks = attributes.getChildren(G3dConstants.VERTEX_ATTRIBUTE);
+				if (attributeChunks.length != numAttributes)
+					new GdxRuntimeException("Number of attributes not equal to number specified in attributes chunk, expected "
+						+ numAttributes + ", got " + attributeChunks.length);
+				VertexAttribute[] vertAttribs = new VertexAttribute[numAttributes];
+				for (int j = 0; j < numAttributes; j++) {
+					vertAttribs[j] = new VertexAttribute(attributeChunks[j].readInt(), attributeChunks[j].readInt(),
+						attributeChunks[j].readString());
+				}
+
+				// read static components, sort of like a bind pose mesh
+				Chunk vertices = subMeshChunk.getChild(G3dConstants.VERTEX_LIST);
+				int numVertices = vertices.readInt();
+				float[] meshVertices = vertices.readFloats();
+
+				// read indices
+				Chunk indices = subMeshChunk.getChild(G3dConstants.INDEX_LIST);
+				int numIndices = indices.readInt();
+				short[] meshIndices = indices.readShorts();
+				
+				//read bone weight
+				Chunk boneWeights = subMeshChunk.getChild(G3dConstants.BONE_WEIGHTS);
+				int numBonesWeights = boneWeights.readInt();
+				Chunk[] boneWeightChunks = boneWeights.getChildren(G3dConstants.BONE_WEIGHT);
+				if (attributeChunks.length != numAttributes)
+					new GdxRuntimeException("Number of bone weights not equal to number specified in bone weights chunk, expected "
+						+ numBonesWeights + ", got " + boneWeightChunks.length);
+				float[][] meshBoneWeights = new float[numBonesWeights][];
+				for(int j=0;j<numBonesWeights;j++) {
+					int count = boneWeightChunks[j].readInt();
+					meshBoneWeights[j] = boneWeightChunks[j].readFloats();
+				}
+
+				//read bone assignment
+				Chunk boneAssignments = subMeshChunk.getChild(G3dConstants.BONE_ASSIGNMENTS);
+				int numBoneAssignments = boneAssignments.readInt();
+				Chunk[] boneAssignmentChunks = boneAssignments.getChildren(G3dConstants.BONE_ASSIGNMENT);
+				if (boneAssignmentChunks.length != numBoneAssignments)
+					new GdxRuntimeException("Number of bone assignment not equal to number specified in bone assignment chunk, expected "
+						+ numBoneAssignments + ", got " + boneAssignmentChunks.length);
+				int[][] meshBoneAssignments = new int[numBoneAssignments][];
+				for(int j=0;j<numBoneAssignments;j++) {
+					int count = boneAssignmentChunks[j].readInt();
+					meshBoneAssignments[j] = boneAssignmentChunks[j].readInts();
+				}
+				
+				SkeletonSubMesh subMesh = new SkeletonSubMesh(subMeshChunk.readString(), new Mesh(false, numVertices, numIndices, vertAttribs),
+					subMeshChunk.readInt());
+				
+				subMesh.indices = meshIndices;
+				subMesh.boneAssignments = meshBoneAssignments;
+				subMesh.boneWeights = meshBoneWeights;
+				subMesh.vertices = meshVertices;
+				
+				subMesh.mesh.setVertices(subMesh.vertices);
+				subMesh.mesh.setIndices(subMesh.indices);
+				subMesh.skinnedVertices = new float[subMesh.vertices.length];
+				System.arraycopy(subMesh.vertices, 0, subMesh.skinnedVertices, 0, subMesh.vertices.length);
+				meshes[i] = subMesh;
+			}
+			
+			//read Skeleton hierarchy
+			Skeleton skeleton = new Skeleton();
+			Chunk skeletonChunk = skeletonModel.getChild(G3dConstants.SKELETON);
+			{
+				// read Skeleton hierarchy
+				Chunk hierarchy = skeletonChunk.getChild(G3dConstants.SKELETON_HIERARCHY);
+				int numHierarchyJoints = hierarchy.readInt();
+				for(int i=0;i<numHierarchyJoints;i++) {
+					skeleton.hierarchy.add(readSkeletonJoint(hierarchy));
+				}
+				
+				
+				// read Skeleton animations
+				Chunk animations = skeletonChunk.getChild(G3dConstants.SKELETON_ANIMATIONS);
+				int numAnimations = animations.readInt();
+				Chunk[] animationChunks = animations.getChildren(G3dConstants.SKELETON_ANIMATION);
+				if (animationChunks.length != numAnimations)
+					new GdxRuntimeException("Number of animations not equal to number specified in animations chunk, expected "
+						+ numAnimations + ", got " + animationChunks.length);
+				for(int i=0;i<numAnimations; i++) {
+					Chunk animation = animationChunks[i];
+
+					String name = animation.readString();
+					float totalDuration = animation.readFloat();
+					
+					int numJoints = animation.readInt();
+					SkeletonKeyframe perJointKeyFrames[][] = new SkeletonKeyframe[numJoints][];
+					for(int j=0;j<numJoints;j++){
+						int numFrames = animation.readInt();
+						perJointKeyFrames[j] = new SkeletonKeyframe[numFrames];
+						
+						for(int k=0;k<numFrames;k++){
+							SkeletonKeyframe frame = new SkeletonKeyframe();
+
+							frame.timeStamp = animation.readFloat();
+							frame.parentIndex = animation.readInt();
+							frame.position.x = animation.readFloat();
+							frame.position.y = animation.readFloat();
+							frame.position.z = animation.readFloat();
+							frame.rotation.w = animation.readFloat();
+							frame.rotation.x = animation.readFloat();
+							frame.rotation.y = animation.readFloat();
+							frame.rotation.z = animation.readFloat();
+							frame.scale.x = animation.readFloat();
+							frame.scale.y = animation.readFloat();
+							frame.scale.z = animation.readFloat();
+							perJointKeyFrames[j][k] = frame;
+						}
+					}
+					
+					skeleton.animations.put(name, new SkeletonAnimation(name, totalDuration, perJointKeyFrames));
+				}
+			}
+			skeleton.buildFromHierarchy();
+
+			SkeletonModel model = new SkeletonModel(skeleton, meshes);
+			model.setMaterial(new Material("default"));
+			return model;
+		} catch (IOException e) {
+			throw new GdxRuntimeException("Couldn't load skeleton model from '" + handle.name() + "', " + e.getMessage(), e);
+		} finally {
+			if (in != null) try {
+				in.close();
+			} catch (IOException e) {
+			}
+		}
+	}
+	
+	private static SkeletonJoint readSkeletonJoint(Chunk jointChunk) {
+		SkeletonJoint joint = new SkeletonJoint();
+		
+		joint.name = jointChunk.readString();
+		joint.position.x = jointChunk.readFloat();
+		joint.position.y = jointChunk.readFloat();
+		joint.position.z = jointChunk.readFloat();
+		joint.rotation.w = jointChunk.readFloat();
+		joint.rotation.x = jointChunk.readFloat();
+		joint.rotation.y = jointChunk.readFloat();
+		joint.rotation.z = jointChunk.readFloat();
+		joint.scale.x = jointChunk.readFloat();
+		joint.scale.y = jointChunk.readFloat();
+		joint.scale.z = jointChunk.readFloat();
+		
+		int count = jointChunk.readInt();
+		for(int i=0;i<count;i++) {
+			SkeletonJoint child = readSkeletonJoint(jointChunk);
+			child.parent = joint;
+			joint.children.add(child);
+		}
+		
+		return joint;
+	}
+
+	public static class G3dStillModelLoader implements StillModelLoader {
+		@Override
+		public StillModel load (FileHandle handle, ModelLoaderHints hints) {
+			return G3dLoader.loadStillModel(handle);
+		}
+	}
+
+	public static class G3dKeyframedModelLoader implements KeyframedModelLoader {
+		@Override
+		public KeyframedModel load (FileHandle handle, ModelLoaderHints hints) {
+			return G3dLoader.loadKeyframedModel(handle);
+		}
+	}
+	
+	public static class G3dSkeletonModelLoader implements SkeletonModelLoader {
+		@Override
+		public SkeletonModel load (FileHandle handle, ModelLoaderHints hints) {
+			return G3dLoader.loadSkeletonModel(handle);
+		}
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/g3d/G3dtLoader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/g3d/G3dtLoader.java
new file mode 100644
index 0000000..0a4bde5
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/g3d/G3dtLoader.java
@@ -0,0 +1,345 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.loaders.g3d;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+
+import com.badlogic.gdx.files.FileHandle;
+import com.badlogic.gdx.graphics.GL10;
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.Mesh.VertexDataType;
+import com.badlogic.gdx.graphics.VertexAttribute;
+import com.badlogic.gdx.graphics.VertexAttributes;
+import com.badlogic.gdx.graphics.VertexAttributes.Usage;
+import com.badlogic.gdx.graphics.g3d.old.ModelLoaderHints;
+import com.badlogic.gdx.graphics.g3d.old.loaders.KeyframedModelLoader;
+import com.badlogic.gdx.graphics.g3d.old.loaders.StillModelLoader;
+import com.badlogic.gdx.graphics.g3d.old.model.keyframe.Keyframe;
+import com.badlogic.gdx.graphics.g3d.old.model.keyframe.KeyframedAnimation;
+import com.badlogic.gdx.graphics.g3d.old.model.keyframe.KeyframedModel;
+import com.badlogic.gdx.graphics.g3d.old.model.keyframe.KeyframedSubMesh;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillSubMesh;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.FloatArray;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+import com.badlogic.gdx.utils.IntArray;
+import com.badlogic.gdx.utils.ObjectMap;
+
+/** Class to import the G3D text format.
+ * @author mzechner */
+public class G3dtLoader {
+	public static KeyframedModel loadKeyframedModel (FileHandle handle, boolean flipV) {
+		return loadKeyframedModel(handle.read(), flipV);
+	}
+
+	public static StillModel loadStillModel (FileHandle handle, boolean flipV) {
+		return loadStillModel(handle.read(), flipV);
+	}
+
+	static int lineNum = 0;
+	static String line = null;
+
+	public static StillModel loadStillModel (InputStream stream, boolean flipV) {
+		BufferedReader in = new BufferedReader(new InputStreamReader(stream));
+
+		lineNum = 1;
+		try {
+			String version = readString(in);
+			if (!version.equals("g3dt-still-1.0")) throw new GdxRuntimeException("incorrect version");
+			int numMeshes = readInt(in);
+			StillSubMesh[] subMeshes = new StillSubMesh[numMeshes];
+			for (int i = 0; i < numMeshes; i++) {
+				subMeshes[i] = readStillSubMesh(in, flipV);
+			}
+			StillModel model = new StillModel(subMeshes);
+			return model;
+		} catch (Throwable e) {
+			throw new GdxRuntimeException("Couldn't read keyframed model, error in line " + lineNum + ", '" + line + "' : "
+				+ e.getMessage(), e);
+		}
+	}
+
+	private static StillSubMesh readStillSubMesh (BufferedReader in, boolean flipV) throws IOException {
+		String name = readString(in);
+		IntArray indices = readFaces(in);
+		int numVertices = readInt(in);
+		int numAttributes = readInt(in);
+
+		if (!readString(in).equals("position")) throw new GdxRuntimeException("first attribute must be position.");
+		int numUvs = 0;
+		boolean hasNormals = false;
+		for (int i = 1; i < numAttributes; i++) {
+			String attributeType = readString(in);
+
+			if (!attributeType.equals("normal") && !attributeType.equals("uv"))
+				throw new GdxRuntimeException("attribute name must be normal or uv");
+
+			if (attributeType.equals("normal")) {
+				if (i != 1) throw new GdxRuntimeException("attribute normal must be second attribute");
+				hasNormals = true;
+			}
+			if (attributeType.equals("uv")) {
+				numUvs++;
+			}
+		}
+		VertexAttribute[] vertexAttributes = createVertexAttributes(hasNormals, numUvs);
+		int vertexSize = new VertexAttributes(vertexAttributes).vertexSize / 4;
+		float[] vertices = new float[numVertices * vertexSize];
+		int idx = 0;
+		int uvOffset = hasNormals ? 6 : 3;
+		for (int i = 0; i < numVertices; i++) {
+			readFloatArray(in, vertices, idx);
+			if (flipV) {
+				for (int j = idx + uvOffset + 1; j < idx + uvOffset + numUvs * 2; j += 2) {
+					vertices[j] = 1 - vertices[j];
+				}
+			}
+			idx += vertexSize;
+		}
+
+		Mesh mesh = new Mesh(true, numVertices, indices.size, vertexAttributes);
+		mesh.setVertices(vertices);
+		mesh.setIndices(convertToShortArray(indices));
+		return new StillSubMesh(name, mesh, GL10.GL_TRIANGLES);
+	}
+
+	public static KeyframedModel loadKeyframedModel (InputStream stream, boolean flipV) {
+		BufferedReader in = new BufferedReader(new InputStreamReader(stream));
+
+		lineNum = 1;
+		try {
+			String version = readString(in);
+			if (!version.equals("g3dt-keyframed-1.0")) throw new GdxRuntimeException("incorrect version");
+			int numMeshes = readInt(in);
+			KeyframedSubMesh[] subMeshes = new KeyframedSubMesh[numMeshes];
+			for (int i = 0; i < numMeshes; i++) {
+				subMeshes[i] = readMesh(in, flipV);
+			}
+			KeyframedModel model = new KeyframedModel(subMeshes);
+			model.setAnimation(model.getAnimations()[0].name, 0, false);
+			return model;
+		} catch (Throwable e) {
+			throw new GdxRuntimeException("Couldn't read keyframed model, error in line " + lineNum + ", '" + line + "' : "
+				+ e.getMessage(), e);
+		}
+	}
+
+	private static KeyframedSubMesh readMesh (BufferedReader in, boolean flipV) throws IOException {
+		String name = readString(in);
+		IntArray indices = readFaces(in);
+		int numVertices = readInt(in);
+		int numAttributes = readInt(in);
+
+		if (!readString(in).equals("position")) throw new GdxRuntimeException("first attribute must be position.");
+		Array<FloatArray> uvSets = new Array<FloatArray>();
+		boolean hasNormals = false;
+		for (int i = 1; i < numAttributes; i++) {
+			String attributeType = readString(in);
+
+			if (!attributeType.equals("normal") && !attributeType.equals("uv"))
+				throw new GdxRuntimeException("attribute name must be normal or uv");
+
+			if (attributeType.equals("normal")) {
+				if (i != 1) throw new GdxRuntimeException("attribute normal must be second attribute");
+				hasNormals = true;
+			}
+			if (attributeType.equals("uv")) {
+				uvSets.add(readUVSet(in, numVertices, flipV));
+			}
+		}
+		int animatedComponents = hasNormals ? 6 : 3;
+
+		VertexAttribute[] vertexAttributes = createVertexAttributes(hasNormals, uvSets.size);
+
+		int numAnimations = readInt(in);
+		ObjectMap<String, KeyframedAnimation> animations = new ObjectMap<String, KeyframedAnimation>(numAnimations);
+		for (int i = 0; i < numAnimations; i++) {
+			String animationName = readString(in);
+			int numKeyframes = readInt(in);
+			float frameDuration = readFloat(in); // in seconds
+
+			Keyframe[] keyframes = new Keyframe[numKeyframes];
+			float time = 0;
+			FloatArray vertex = new FloatArray(animatedComponents);
+			for (int frame = 0; frame < numKeyframes; frame++) {
+				float[] vertices = new float[numVertices * (animatedComponents)];
+				int idx = 0;
+				for (int j = 0; j < numVertices; j++) {
+					idx = readFloatArray(in, vertices, idx);
+				}
+				Keyframe keyframe = new Keyframe(time, vertices);
+				keyframes[frame] = keyframe;
+				time += frameDuration;
+			}
+
+			KeyframedAnimation animation = new KeyframedAnimation(animationName, frameDuration, keyframes);
+			animations.put(animationName, animation);
+		}
+
+		KeyframedSubMesh mesh = new KeyframedSubMesh(name, new Mesh(VertexDataType.VertexArray, false, numVertices, indices.size,
+			createVertexAttributes(hasNormals, uvSets.size)), buildVertices(numVertices, hasNormals, uvSets), animations,
+			animatedComponents, GL10.GL_TRIANGLES);
+		mesh.mesh.setIndices(convertToShortArray(indices));
+		mesh.mesh.setVertices(mesh.blendedVertices);
+		return mesh;
+	}
+
+	private static float[] buildVertices (int numVertices, boolean hasNormals, Array<FloatArray> uvSets) {
+		float[] vertices = new float[numVertices * (3 + (hasNormals ? 3 : 0) + uvSets.size * 2)];
+
+		int idx = 0;
+		int idxUv = 0;
+		for (int i = 0; i < numVertices; i++) {
+			vertices[idx++] = 0;
+			vertices[idx++] = 0;
+			vertices[idx++] = 0;
+			if (hasNormals) {
+				vertices[idx++] = 0;
+				vertices[idx++] = 0;
+				vertices[idx++] = 0;
+			}
+			for (int j = 0; j < uvSets.size; j++) {
+				vertices[idx++] = uvSets.get(j).get(idxUv);
+				vertices[idx++] = uvSets.get(j).get(idxUv + 1);
+			}
+			idxUv += 2;
+		}
+		return vertices;
+	}
+
+	private static VertexAttribute[] createVertexAttributes (boolean hasNormals, int uvs) {
+		VertexAttribute[] attributes = new VertexAttribute[1 + (hasNormals ? 1 : 0) + uvs];
+		int idx = 0;
+		attributes[idx++] = new VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE);
+		if (hasNormals) attributes[idx++] = new VertexAttribute(Usage.Normal, 3, ShaderProgram.NORMAL_ATTRIBUTE);
+		for (int i = 0; i < uvs; i++) {
+			attributes[idx++] = new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + i);
+		}
+		return attributes;
+	}
+
+	private static FloatArray readUVSet (BufferedReader in, int numVertices, boolean flipV) throws IOException {
+		FloatArray uvSet = new FloatArray(numVertices * 2);
+		FloatArray uv = new FloatArray(2);
+		for (int i = 0; i < numVertices; i++) {
+			readFloatArray(in, uv);
+			uvSet.add(uv.items[0]);
+			uvSet.add(flipV ? 1 - uv.items[1] : uv.items[1]);
+		}
+		return uvSet;
+	}
+
+	private static IntArray readFaces (BufferedReader in) throws NumberFormatException, IOException {
+		int numFaces = readInt(in);
+		IntArray faceIndices = new IntArray();
+		IntArray triangles = new IntArray();
+		IntArray indices = new IntArray();
+
+		for (int face = 0; face < numFaces; face++) {
+			readIntArray(in, faceIndices);
+			int numIndices = faceIndices.get(0);
+			triangles.clear();
+			int baseIndex = faceIndices.get(1);
+			for (int i = 2; i < numIndices; i++) {
+				triangles.add(baseIndex);
+				triangles.add(faceIndices.items[i]);
+				triangles.add(faceIndices.items[i + 1]);
+			}
+			indices.addAll(triangles);
+		}
+
+		indices.shrink();
+		return indices;
+	}
+
+	private static short[] convertToShortArray (IntArray array) {
+		short[] shortArray = new short[array.size];
+		for (int i = 0; i < array.size; i++) {
+			shortArray[i] = (short)array.items[i];
+		}
+		return shortArray;
+	}
+
+	private static float readFloat (BufferedReader in) throws NumberFormatException, IOException {
+		lineNum++;
+		return Float.parseFloat(read(in).trim());
+	}
+
+	private static int readInt (BufferedReader in) throws NumberFormatException, IOException {
+		lineNum++;
+		return (int)(Math.floor(Float.parseFloat(read(in).trim())));
+	}
+
+	private static String readString (BufferedReader in) throws IOException {
+		lineNum++;
+		return read(in);
+	}
+
+	private static void readFloatArray (BufferedReader in, FloatArray array) throws IOException {
+		lineNum++;
+		String[] tokens = read(in).split(",");
+		int len = tokens.length;
+		array.clear();
+		for (int i = 0; i < len; i++) {
+			array.add(Float.parseFloat(tokens[i].trim()));
+		}
+	}
+
+	private static int readFloatArray (BufferedReader in, float[] array, int idx) throws IOException {
+		lineNum++;
+		String[] tokens = read(in).split(",");
+		int len = tokens.length;
+		for (int i = 0; i < len; i++) {
+			array[idx++] = Float.parseFloat(tokens[i].trim());
+		}
+		return idx;
+	}
+
+	private static void readIntArray (BufferedReader in, IntArray array) throws IOException {
+		String[] tokens = read(in).split(",");
+		int len = tokens.length;
+		array.clear();
+		for (int i = 0; i < len; i++) {
+			array.add(Integer.parseInt(tokens[i].trim()));
+		}
+	}
+
+	private static String read (BufferedReader in) throws IOException {
+		line = in.readLine();
+		return line;
+	}
+
+	public static class G3dtStillModelLoader implements StillModelLoader {
+
+		@Override
+		public StillModel load (FileHandle handle, ModelLoaderHints hints) {
+			return G3dtLoader.loadStillModel(handle, hints.flipV);
+		}
+	}
+
+	public static class G3dtKeyframedModelLoader implements KeyframedModelLoader {
+		@Override
+		public KeyframedModel load (FileHandle handle, ModelLoaderHints hints) {
+			return G3dtLoader.loadKeyframedModel(handle, hints.flipV);
+		}
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/md2/MD2Frame.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/md2/MD2Frame.java
new file mode 100644
index 0000000..97430f5
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/md2/MD2Frame.java
@@ -0,0 +1,23 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.loaders.md2;
+
+public class MD2Frame {
+	public float[] vertices;
+	public int[] normalIndices;
+	public String name;
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/md2/MD2Header.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/md2/MD2Header.java
new file mode 100644
index 0000000..a5caab9
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/md2/MD2Header.java
@@ -0,0 +1,37 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.loaders.md2;
+
+public class MD2Header {
+	public int ident;
+	public int version;
+	public int skinWidth;
+	public int skinHeight;
+	public int frameSize;
+	public int numSkins;
+	public int numVertices;
+	public int numTexCoords;
+	public int numTriangles;
+	public int numGLCommands;
+	public int numFrames;
+	public int offsetSkin;
+	public int offsetTexCoords;
+	public int offsetTriangles;
+	public int offsetFrames;
+	public int offsetGLCommands;
+	public int offsetEnd;
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/md2/MD2Loader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/md2/MD2Loader.java
new file mode 100644
index 0000000..2d1ce13
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/md2/MD2Loader.java
@@ -0,0 +1,421 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.loaders.md2;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+
+import com.badlogic.gdx.files.FileHandle;
+import com.badlogic.gdx.graphics.GL10;
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.Mesh.VertexDataType;
+import com.badlogic.gdx.graphics.VertexAttribute;
+import com.badlogic.gdx.graphics.VertexAttributes.Usage;
+import com.badlogic.gdx.graphics.g3d.old.ModelLoaderHints;
+import com.badlogic.gdx.graphics.g3d.old.loaders.KeyframedModelLoader;
+import com.badlogic.gdx.graphics.g3d.old.model.keyframe.Keyframe;
+import com.badlogic.gdx.graphics.g3d.old.model.keyframe.KeyframedAnimation;
+import com.badlogic.gdx.graphics.g3d.old.model.keyframe.KeyframedModel;
+import com.badlogic.gdx.graphics.g3d.old.model.keyframe.KeyframedSubMesh;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.badlogic.gdx.utils.LittleEndianInputStream;
+import com.badlogic.gdx.utils.ObjectMap;
+
+public class MD2Loader implements KeyframedModelLoader {
+	public KeyframedModel load (FileHandle file, ModelLoaderHints hints) {
+		float frameDuration = 0.2f;
+		if (hints instanceof MD2LoaderHints) {
+			frameDuration = ((MD2LoaderHints)hints).frameDuration;
+		}
+		return load(file, frameDuration);
+	}
+
+	public KeyframedModel load (FileHandle fileHandle, float frameDuration) {
+		InputStream in = fileHandle.read();
+		try {
+			return load(in, frameDuration);
+		} finally {
+			if (in != null) try {
+				in.close();
+			} catch (IOException e) {
+			}
+			;
+		}
+	}
+
+	public KeyframedModel load (InputStream in, float frameDuration) {
+		try {
+			byte[] bytes = loadBytes(in);
+
+			MD2Header header = loadHeader(bytes);
+			float[] texCoords = loadTexCoords(header, bytes);
+			MD2Triangle[] triangles = loadTriangles(header, bytes);
+			MD2Frame[] frames = loadFrames(header, bytes);
+
+			return buildModel(header, triangles, texCoords, frames, frameDuration);
+		} catch (Exception ex) {
+			ex.printStackTrace();
+			return null;
+		}
+	}
+
+	private KeyframedModel buildModel (MD2Header header, MD2Triangle[] triangles, float[] texCoords, MD2Frame[] frames,
+		float frameDuration) {
+		ArrayList<VertexIndices> vertCombos = new ArrayList<VertexIndices>();
+		short[] indices = new short[triangles.length * 3];
+		int idx = 0;
+		short vertIdx = 0;
+		for (int i = 0; i < triangles.length; i++) {
+			MD2Triangle triangle = triangles[i];
+			for (int j = 0; j < 3; j++) {
+				VertexIndices vert = null;
+				boolean contains = false;
+				for (int k = 0; k < vertCombos.size(); k++) {
+					VertexIndices vIdx = vertCombos.get(k);
+					if (vIdx.vIdx == triangle.vertices[j] && vIdx.tIdx == triangle.texCoords[j]) {
+						vert = vIdx;
+						contains = true;
+						break;
+					}
+				}
+				if (!contains) {
+					vert = new VertexIndices(triangle.vertices[j], triangle.texCoords[j], vertIdx);
+					vertCombos.add(vert);
+					vertIdx++;
+				}
+
+				indices[idx++] = vert.nIdx;
+			}
+		}
+
+		idx = 0;
+		float[] uvs = new float[vertCombos.size() * 2];
+		for (int i = 0; i < vertCombos.size(); i++) {
+			VertexIndices vtI = vertCombos.get(i);
+			uvs[idx++] = texCoords[vtI.tIdx * 2];
+			uvs[idx++] = texCoords[vtI.tIdx * 2 + 1];
+		}
+
+		for (int i = 0; i < frames.length; i++) {
+			MD2Frame frame = frames[i];
+			idx = 0;
+			float[] newVerts = new float[vertCombos.size() * 6];
+
+			for (int j = 0; j < vertCombos.size(); j++) {
+				VertexIndices vIdx = vertCombos.get(j);
+				newVerts[idx++] = frame.vertices[vIdx.vIdx * 3];
+				newVerts[idx++] = frame.vertices[vIdx.vIdx * 3 + 1];
+				newVerts[idx++] = frame.vertices[vIdx.vIdx * 3 + 2];
+				newVerts[idx++] = MD2Normals.normals[frame.normalIndices[vIdx.vIdx]][1];
+				newVerts[idx++] = MD2Normals.normals[frame.normalIndices[vIdx.vIdx]][2];
+				newVerts[idx++] = MD2Normals.normals[frame.normalIndices[vIdx.vIdx]][0];
+			}
+			frame.vertices = newVerts;
+		}
+
+		header.numVertices = vertCombos.size();
+
+		float[] blendedVertices = new float[header.numVertices * 8];
+		MD2Frame frame = frames[0];
+
+		idx = 0;
+		int idxV = 0;
+		int idxT = 0;
+		for (int i = 0; i < header.numVertices; i++) {
+			VertexIndices vIdx = vertCombos.get(i);
+
+			blendedVertices[idx++] = frame.vertices[idxV++];
+			blendedVertices[idx++] = frame.vertices[idxV++];
+			blendedVertices[idx++] = frame.vertices[idxV++];
+			blendedVertices[idx++] = frame.vertices[idxV++];
+			blendedVertices[idx++] = frame.vertices[idxV++];
+			blendedVertices[idx++] = frame.vertices[idxV++];
+			blendedVertices[idx++] = uvs[idxT++];
+			blendedVertices[idx++] = uvs[idxT++];
+		}
+
+		ObjectMap<String, KeyframedAnimation> animations = new ObjectMap<String, KeyframedAnimation>();
+
+		String lastName = frames[0].name;
+		int beginFrame = 0;
+
+		for (int frameNum = 1; frameNum < frames.length; frameNum++) {
+			if (!frames[frameNum].name.equals(lastName) || frameNum == frames.length - 1) {
+				int subAnimLen = frameNum - beginFrame;
+				KeyframedAnimation subAnim = new KeyframedAnimation(lastName, frameDuration, new Keyframe[subAnimLen]);
+
+				for (int subFrame = beginFrame; subFrame < frameNum; subFrame++) {
+					int absFrameNum = subFrame - beginFrame;
+
+					frame = frames[subFrame];
+					float[] vertices = new float[header.numVertices * 6];
+					idx = 0;
+					idxV = 0;
+					for (int i = 0; i < header.numVertices; i++) {
+						vertices[idx++] = frame.vertices[idxV++];
+						vertices[idx++] = frame.vertices[idxV++];
+						vertices[idx++] = frame.vertices[idxV++];
+						vertices[idx++] = frame.vertices[idxV++];
+						vertices[idx++] = frame.vertices[idxV++];
+						vertices[idx++] = frame.vertices[idxV++];
+					}
+
+					Keyframe keyFrame = new Keyframe(absFrameNum * frameDuration, vertices);
+					subAnim.keyframes[absFrameNum] = keyFrame;
+					animations.put(subAnim.name, subAnim);
+				}
+
+				lastName = frames[frameNum].name;
+				beginFrame = frameNum;
+			}
+		}
+
+		KeyframedAnimation animation = new KeyframedAnimation("all", frameDuration, new Keyframe[frames.length]);
+		float timeStamp = 0;
+		for (int frameNum = 0; frameNum < frames.length; frameNum++) {
+			frame = frames[frameNum];
+			float[] vertices = new float[header.numVertices * 6];
+			idx = 0;
+			idxV = 0;
+			for (int i = 0; i < header.numVertices; i++) {
+				vertices[idx++] = frame.vertices[idxV++];
+				vertices[idx++] = frame.vertices[idxV++];
+				vertices[idx++] = frame.vertices[idxV++];
+				vertices[idx++] = frame.vertices[idxV++];
+				vertices[idx++] = frame.vertices[idxV++];
+				vertices[idx++] = frame.vertices[idxV++];
+			}
+
+			Keyframe keyFrame = new Keyframe(frameNum * frameDuration, vertices);
+			animation.keyframes[frameNum] = keyFrame;
+		}
+
+		Mesh mesh = new Mesh(VertexDataType.VertexArray, false, header.numVertices, indices.length, new VertexAttribute(
+			Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE), new VertexAttribute(Usage.Normal, 3,
+			ShaderProgram.NORMAL_ATTRIBUTE),
+			new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + "0"));
+		mesh.setIndices(indices);
+		animations.put("all", animation);
+
+		KeyframedSubMesh subMesh = new KeyframedSubMesh("md2-mesh", mesh, blendedVertices, animations, 6, GL10.GL_TRIANGLES);
+		KeyframedModel model = new KeyframedModel(new KeyframedSubMesh[] {subMesh});
+		model.setAnimation("all", 0, false);
+		return model;
+	}
+
+	private float[] buildTexCoords (MD2Header header, MD2Triangle[] triangles, float[] texCoords) {
+		float[] uvs = new float[header.numVertices * 2];
+
+		for (int i = 0; i < triangles.length; i++) {
+			MD2Triangle triangle = triangles[i];
+			for (int j = 0; j < 3; j++) {
+				int vertIdx = triangle.vertices[j];
+				int uvIdx = vertIdx * 2;
+				uvs[uvIdx] = texCoords[triangle.texCoords[j] * 2];
+				uvs[uvIdx + 1] = texCoords[triangle.texCoords[j] * 2 + 1];
+			}
+		}
+
+		return uvs;
+	}
+
+	private short[] buildIndices (MD2Triangle[] triangles) {
+		short[] indices = new short[triangles.length * 3];
+
+		int idx = 0;
+		for (int i = 0; i < triangles.length; i++) {
+			MD2Triangle triangle = triangles[i];
+			indices[idx++] = triangle.vertices[0];
+			indices[idx++] = triangle.vertices[1];
+			indices[idx++] = triangle.vertices[2];
+		}
+		return indices;
+	}
+
+	private MD2Frame[] loadFrames (MD2Header header, byte[] bytes) throws IOException {
+		LittleEndianInputStream in = new LittleEndianInputStream(new ByteArrayInputStream(bytes));
+		in.skip(header.offsetFrames);
+
+		MD2Frame[] frames = new MD2Frame[header.numFrames];
+		for (int i = 0; i < header.numFrames; i++) {
+			frames[i] = loadFrame(header, in);
+		}
+
+		in.close();
+
+		return frames;
+	}
+
+	private final byte[] charBuffer = new byte[16];
+
+	private MD2Frame loadFrame (MD2Header header, LittleEndianInputStream in) throws IOException {
+		MD2Frame frame = new MD2Frame();
+		frame.vertices = new float[header.numVertices * 3];
+		frame.normalIndices = new int[header.numVertices];
+
+		float scaleX = in.readFloat(), scaleY = in.readFloat(), scaleZ = in.readFloat();
+		float transX = in.readFloat(), transY = in.readFloat(), transZ = in.readFloat();
+		in.read(charBuffer);
+
+		int len = 0;
+		for (int i = 0; i < charBuffer.length; i++)
+			if (charBuffer[i] == 0) {
+				len = i;
+				break;
+			}
+
+		frame.name = new String(charBuffer, 0, len);
+
+		int vertIdx = 0;
+
+		for (int i = 0; i < header.numVertices; i++) {
+			float x = in.read() * scaleX + transX;
+			float y = in.read() * scaleY + transY;
+			float z = in.read() * scaleZ + transZ;
+
+			frame.vertices[vertIdx++] = y;
+			frame.vertices[vertIdx++] = z;
+			frame.vertices[vertIdx++] = x;
+
+			frame.normalIndices[i] = in.read(); // normal index
+		}
+
+		return frame;
+	}
+
+	private MD2Triangle[] loadTriangles (MD2Header header, byte[] bytes) throws IOException {
+		LittleEndianInputStream in = new LittleEndianInputStream(new ByteArrayInputStream(bytes));
+		in.skip(header.offsetTriangles);
+		MD2Triangle[] triangles = new MD2Triangle[header.numTriangles];
+
+		for (int i = 0; i < header.numTriangles; i++) {
+			MD2Triangle triangle = new MD2Triangle();
+			triangle.vertices[0] = in.readShort();
+			triangle.vertices[1] = in.readShort();
+			triangle.vertices[2] = in.readShort();
+			triangle.texCoords[0] = in.readShort();
+			triangle.texCoords[1] = in.readShort();
+			triangle.texCoords[2] = in.readShort();
+			triangles[i] = triangle;
+		}
+
+		in.close();
+
+		return triangles;
+	}
+
+	private float[] loadTexCoords (MD2Header header, byte[] bytes) throws IOException {
+		LittleEndianInputStream in = new LittleEndianInputStream(new ByteArrayInputStream(bytes));
+		in.skip(header.offsetTexCoords);
+		float[] texCoords = new float[header.numTexCoords * 2];
+		float width = header.skinWidth;
+		float height = header.skinHeight;
+
+		for (int i = 0; i < header.numTexCoords * 2; i += 2) {
+			short u = in.readShort();
+			short v = in.readShort();
+			texCoords[i] = u / width;
+			texCoords[i + 1] = v / height;
+		}
+		in.close();
+		return texCoords;
+	}
+
+	private MD2Header loadHeader (byte[] bytes) throws IOException {
+		LittleEndianInputStream in = new LittleEndianInputStream(new ByteArrayInputStream(bytes));
+		MD2Header header = new MD2Header();
+
+		header.ident = in.readInt();
+		header.version = in.readInt();
+		header.skinWidth = in.readInt();
+		header.skinHeight = in.readInt();
+		header.frameSize = in.readInt();
+		header.numSkins = in.readInt();
+		header.numVertices = in.readInt();
+		header.numTexCoords = in.readInt();
+		header.numTriangles = in.readInt();
+		header.numGLCommands = in.readInt();
+		header.numFrames = in.readInt();
+		header.offsetSkin = in.readInt();
+		header.offsetTexCoords = in.readInt();
+		header.offsetTriangles = in.readInt();
+		header.offsetFrames = in.readInt();
+		header.offsetGLCommands = in.readInt();
+		header.offsetEnd = in.readInt();
+
+		in.close();
+
+		return header;
+	}
+
+	private byte[] loadBytes (InputStream in) throws IOException {
+		ByteArrayOutputStream out = new ByteArrayOutputStream();
+		byte[] buffer = new byte[1024];
+
+		int readBytes = 0;
+		while ((readBytes = in.read(buffer)) > 0) {
+			out.write(buffer, 0, readBytes);
+		}
+
+		out.close();
+		return out.toByteArray();
+	}
+
+	public class VertexIndices {
+		public VertexIndices (short vIdx, short tIdx, short nIdx) {
+			this.vIdx = vIdx;
+			this.tIdx = tIdx;
+			this.nIdx = nIdx;
+		}
+
+		@Override
+		public int hashCode () {
+			final int prime = 31;
+			int result = 1;
+			result = prime * result + tIdx;
+			result = prime * result + vIdx;
+			return result;
+		}
+
+		@Override
+		public boolean equals (Object obj) {
+			if (this == obj) return true;
+			if (obj == null) return false;
+			if (getClass() != obj.getClass()) return false;
+			VertexIndices other = (VertexIndices)obj;
+			if (tIdx != other.tIdx) return false;
+			if (vIdx != other.vIdx) return false;
+			return true;
+		}
+
+		public short vIdx;
+		public short tIdx;
+		public short nIdx;
+	}
+
+	public static class MD2LoaderHints extends ModelLoaderHints {
+		public final float frameDuration;
+
+		public MD2LoaderHints (float frameDuration) {
+			super(false);
+			this.frameDuration = frameDuration;
+		}
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/md2/MD2Normals.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/md2/MD2Normals.java
new file mode 100644
index 0000000..8307041
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/md2/MD2Normals.java
@@ -0,0 +1,75 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.loaders.md2;
+
+public class MD2Normals {
+	public static float[][] normals = { {-0.525731f, 0.000000f, 0.850651f}, {-0.442863f, 0.238856f, 0.864188f},
+		{-0.295242f, 0.000000f, 0.955423f}, {-0.309017f, 0.500000f, 0.809017f}, {-0.162460f, 0.262866f, 0.951056f},
+		{0.000000f, 0.000000f, 1.000000f}, {0.000000f, 0.850651f, 0.525731f}, {-0.147621f, 0.716567f, 0.681718f},
+		{0.147621f, 0.716567f, 0.681718f}, {0.000000f, 0.525731f, 0.850651f}, {0.309017f, 0.500000f, 0.809017f},
+		{0.525731f, 0.000000f, 0.850651f}, {0.295242f, 0.000000f, 0.955423f}, {0.442863f, 0.238856f, 0.864188f},
+		{0.162460f, 0.262866f, 0.951056f}, {-0.681718f, 0.147621f, 0.716567f}, {-0.809017f, 0.309017f, 0.500000f},
+		{-0.587785f, 0.425325f, 0.688191f}, {-0.850651f, 0.525731f, 0.000000f}, {-0.864188f, 0.442863f, 0.238856f},
+		{-0.716567f, 0.681718f, 0.147621f}, {-0.688191f, 0.587785f, 0.425325f}, {-0.500000f, 0.809017f, 0.309017f},
+		{-0.238856f, 0.864188f, 0.442863f}, {-0.425325f, 0.688191f, 0.587785f}, {-0.716567f, 0.681718f, -0.147621f},
+		{-0.500000f, 0.809017f, -0.309017f}, {-0.525731f, 0.850651f, 0.000000f}, {0.000000f, 0.850651f, -0.525731f},
+		{-0.238856f, 0.864188f, -0.442863f}, {0.000000f, 0.955423f, -0.295242f}, {-0.262866f, 0.951056f, -0.162460f},
+		{0.000000f, 1.000000f, 0.000000f}, {0.000000f, 0.955423f, 0.295242f}, {-0.262866f, 0.951056f, 0.162460f},
+		{0.238856f, 0.864188f, 0.442863f}, {0.262866f, 0.951056f, 0.162460f}, {0.500000f, 0.809017f, 0.309017f},
+		{0.238856f, 0.864188f, -0.442863f}, {0.262866f, 0.951056f, -0.162460f}, {0.500000f, 0.809017f, -0.309017f},
+		{0.850651f, 0.525731f, 0.000000f}, {0.716567f, 0.681718f, 0.147621f}, {0.716567f, 0.681718f, -0.147621f},
+		{0.525731f, 0.850651f, 0.000000f}, {0.425325f, 0.688191f, 0.587785f}, {0.864188f, 0.442863f, 0.238856f},
+		{0.688191f, 0.587785f, 0.425325f}, {0.809017f, 0.309017f, 0.500000f}, {0.681718f, 0.147621f, 0.716567f},
+		{0.587785f, 0.425325f, 0.688191f}, {0.955423f, 0.295242f, 0.000000f}, {1.000000f, 0.000000f, 0.000000f},
+		{0.951056f, 0.162460f, 0.262866f}, {0.850651f, -0.525731f, 0.000000f}, {0.955423f, -0.295242f, 0.000000f},
+		{0.864188f, -0.442863f, 0.238856f}, {0.951056f, -0.162460f, 0.262866f}, {0.809017f, -0.309017f, 0.500000f},
+		{0.681718f, -0.147621f, 0.716567f}, {0.850651f, 0.000000f, 0.525731f}, {0.864188f, 0.442863f, -0.238856f},
+		{0.809017f, 0.309017f, -0.500000f}, {0.951056f, 0.162460f, -0.262866f}, {0.525731f, 0.000000f, -0.850651f},
+		{0.681718f, 0.147621f, -0.716567f}, {0.681718f, -0.147621f, -0.716567f}, {0.850651f, 0.000000f, -0.525731f},
+		{0.809017f, -0.309017f, -0.500000f}, {0.864188f, -0.442863f, -0.238856f}, {0.951056f, -0.162460f, -0.262866f},
+		{0.147621f, 0.716567f, -0.681718f}, {0.309017f, 0.500000f, -0.809017f}, {0.425325f, 0.688191f, -0.587785f},
+		{0.442863f, 0.238856f, -0.864188f}, {0.587785f, 0.425325f, -0.688191f}, {0.688191f, 0.587785f, -0.425325f},
+		{-0.147621f, 0.716567f, -0.681718f}, {-0.309017f, 0.500000f, -0.809017f}, {0.000000f, 0.525731f, -0.850651f},
+		{-0.525731f, 0.000000f, -0.850651f}, {-0.442863f, 0.238856f, -0.864188f}, {-0.295242f, 0.000000f, -0.955423f},
+		{-0.162460f, 0.262866f, -0.951056f}, {0.000000f, 0.000000f, -1.000000f}, {0.295242f, 0.000000f, -0.955423f},
+		{0.162460f, 0.262866f, -0.951056f}, {-0.442863f, -0.238856f, -0.864188f}, {-0.309017f, -0.500000f, -0.809017f},
+		{-0.162460f, -0.262866f, -0.951056f}, {0.000000f, -0.850651f, -0.525731f}, {-0.147621f, -0.716567f, -0.681718f},
+		{0.147621f, -0.716567f, -0.681718f}, {0.000000f, -0.525731f, -0.850651f}, {0.309017f, -0.500000f, -0.809017f},
+		{0.442863f, -0.238856f, -0.864188f}, {0.162460f, -0.262866f, -0.951056f}, {0.238856f, -0.864188f, -0.442863f},
+		{0.500000f, -0.809017f, -0.309017f}, {0.425325f, -0.688191f, -0.587785f}, {0.716567f, -0.681718f, -0.147621f},
+		{0.688191f, -0.587785f, -0.425325f}, {0.587785f, -0.425325f, -0.688191f}, {0.000000f, -0.955423f, -0.295242f},
+		{0.000000f, -1.000000f, 0.000000f}, {0.262866f, -0.951056f, -0.162460f}, {0.000000f, -0.850651f, 0.525731f},
+		{0.000000f, -0.955423f, 0.295242f}, {0.238856f, -0.864188f, 0.442863f}, {0.262866f, -0.951056f, 0.162460f},
+		{0.500000f, -0.809017f, 0.309017f}, {0.716567f, -0.681718f, 0.147621f}, {0.525731f, -0.850651f, 0.000000f},
+		{-0.238856f, -0.864188f, -0.442863f}, {-0.500000f, -0.809017f, -0.309017f}, {-0.262866f, -0.951056f, -0.162460f},
+		{-0.850651f, -0.525731f, 0.000000f}, {-0.716567f, -0.681718f, -0.147621f}, {-0.716567f, -0.681718f, 0.147621f},
+		{-0.525731f, -0.850651f, 0.000000f}, {-0.500000f, -0.809017f, 0.309017f}, {-0.238856f, -0.864188f, 0.442863f},
+		{-0.262866f, -0.951056f, 0.162460f}, {-0.864188f, -0.442863f, 0.238856f}, {-0.809017f, -0.309017f, 0.500000f},
+		{-0.688191f, -0.587785f, 0.425325f}, {-0.681718f, -0.147621f, 0.716567f}, {-0.442863f, -0.238856f, 0.864188f},
+		{-0.587785f, -0.425325f, 0.688191f}, {-0.309017f, -0.500000f, 0.809017f}, {-0.147621f, -0.716567f, 0.681718f},
+		{-0.425325f, -0.688191f, 0.587785f}, {-0.162460f, -0.262866f, 0.951056f}, {0.442863f, -0.238856f, 0.864188f},
+		{0.162460f, -0.262866f, 0.951056f}, {0.309017f, -0.500000f, 0.809017f}, {0.147621f, -0.716567f, 0.681718f},
+		{0.000000f, -0.525731f, 0.850651f}, {0.425325f, -0.688191f, 0.587785f}, {0.587785f, -0.425325f, 0.688191f},
+		{0.688191f, -0.587785f, 0.425325f}, {-0.955423f, 0.295242f, 0.000000f}, {-0.951056f, 0.162460f, 0.262866f},
+		{-1.000000f, 0.000000f, 0.000000f}, {-0.850651f, 0.000000f, 0.525731f}, {-0.955423f, -0.295242f, 0.000000f},
+		{-0.951056f, -0.162460f, 0.262866f}, {-0.864188f, 0.442863f, -0.238856f}, {-0.951056f, 0.162460f, -0.262866f},
+		{-0.809017f, 0.309017f, -0.500000f}, {-0.864188f, -0.442863f, -0.238856f}, {-0.951056f, -0.162460f, -0.262866f},
+		{-0.809017f, -0.309017f, -0.500000f}, {-0.681718f, 0.147621f, -0.716567f}, {-0.681718f, -0.147621f, -0.716567f},
+		{-0.850651f, 0.000000f, -0.525731f}, {-0.688191f, 0.587785f, -0.425325f}, {-0.587785f, 0.425325f, -0.688191f},
+		{-0.425325f, 0.688191f, -0.587785f}, {-0.425325f, -0.688191f, -0.587785f}, {-0.587785f, -0.425325f, -0.688191f},
+		{-0.688191f, -0.587785f, -0.425325f}};
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/md2/MD2Triangle.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/md2/MD2Triangle.java
new file mode 100644
index 0000000..8ed772c
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/md2/MD2Triangle.java
@@ -0,0 +1,22 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.loaders.md2;
+
+public class MD2Triangle {
+	public short[] vertices = new short[3];
+	public short[] texCoords = new short[3];
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/wavefront/ObjLoader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/wavefront/ObjLoader.java
new file mode 100644
index 0000000..a8637d3
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/loaders/wavefront/ObjLoader.java
@@ -0,0 +1,394 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.loaders.wavefront;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.assets.AssetManager;
+import com.badlogic.gdx.files.FileHandle;
+import com.badlogic.gdx.graphics.Color;
+import com.badlogic.gdx.graphics.GL10;
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.Pixmap;
+import com.badlogic.gdx.graphics.Pixmap.Format;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.Texture.TextureFilter;
+import com.badlogic.gdx.graphics.VertexAttribute;
+import com.badlogic.gdx.graphics.VertexAttributes.Usage;
+import com.badlogic.gdx.graphics.g3d.old.ModelLoaderHints;
+import com.badlogic.gdx.graphics.g3d.old.loaders.StillModelLoader;
+import com.badlogic.gdx.graphics.g3d.old.materials.ColorAttribute;
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+import com.badlogic.gdx.graphics.g3d.old.materials.TextureAttribute;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillSubMesh;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.badlogic.gdx.utils.FloatArray;
+
+/** Loads Wavefront OBJ files.
+ * 
+ * @author mzechner, espitz */
+public class ObjLoader implements StillModelLoader {
+	final FloatArray verts;
+	final FloatArray norms;
+	final FloatArray uvs;
+	final ArrayList<Group> groups;
+
+	public ObjLoader () {
+		verts = new FloatArray(300);
+		norms = new FloatArray(300);
+		uvs = new FloatArray(200);
+		groups = new ArrayList<Group>(10);
+	}
+
+	/** Loads a Wavefront OBJ file from a given file handle.
+	 * 
+	 * @param file the FileHandle */
+	public StillModel loadObj (FileHandle file) {
+		return loadObj(file, false);
+	}
+
+	/** Loads a Wavefront OBJ file from a given file handle.
+	 * 
+	 * @param file the FileHandle
+	 * @param flipV whether to flip the v texture coordinate (Blender, Wings3D, et al) */
+	public StillModel loadObj (FileHandle file, boolean flipV) {
+		return loadObj(file, file.parent(), flipV);
+	}
+
+	/** Loads a Wavefront OBJ file from a given file handle.
+	 * 
+	 * @param file the FileHandle
+	 * @param textureDir
+	 * @param flipV whether to flip the v texture coordinate (Blender, Wings3D, et al) */
+	public StillModel loadObj (FileHandle file, FileHandle textureDir, boolean flipV) {
+		String line;
+		String[] tokens;
+		char firstChar;
+		MtlLoader mtl = new MtlLoader();
+
+		// Create a "default" Group and set it as the active group, in case
+		// there are no groups or objects defined in the OBJ file.
+		Group activeGroup = new Group("default");
+		groups.add(activeGroup);
+
+		BufferedReader reader = new BufferedReader(new InputStreamReader(file.read()), 4096);
+		try {
+			while ((line = reader.readLine()) != null) {
+
+				tokens = line.split("\\s+");
+
+				if (tokens[0].length() == 0) {
+					continue;
+				} else if ((firstChar = tokens[0].toLowerCase().charAt(0)) == '#') {
+					continue;
+				} else if (firstChar == 'v') {
+					if (tokens[0].length() == 1) {
+						verts.add(Float.parseFloat(tokens[1]));
+						verts.add(Float.parseFloat(tokens[2]));
+						verts.add(Float.parseFloat(tokens[3]));
+					} else if (tokens[0].charAt(1) == 'n') {
+						norms.add(Float.parseFloat(tokens[1]));
+						norms.add(Float.parseFloat(tokens[2]));
+						norms.add(Float.parseFloat(tokens[3]));
+					} else if (tokens[0].charAt(1) == 't') {
+						uvs.add(Float.parseFloat(tokens[1]));
+						uvs.add((flipV ? 1 - Float.parseFloat(tokens[2]) : Float.parseFloat(tokens[2])));
+					}
+				} else if (firstChar == 'f') {
+					String[] parts;
+					ArrayList<Integer> faces = activeGroup.faces;
+					for (int i = 1; i < tokens.length - 2; i--) {
+						parts = tokens[1].split("/");
+						faces.add(getIndex(parts[0], verts.size));
+						if (parts.length > 2) {
+							if (i == 1) activeGroup.hasNorms = true;
+							faces.add(getIndex(parts[2], norms.size));
+						}
+						if (parts.length > 1 && parts[1].length() > 0) {
+							if (i == 1) activeGroup.hasUVs = true;
+							faces.add(getIndex(parts[1], uvs.size));
+						}
+						parts = tokens[++i].split("/");
+						faces.add(getIndex(parts[0], verts.size));
+						if (parts.length > 2) faces.add(getIndex(parts[2], norms.size));
+						if (parts.length > 1 && parts[1].length() > 0) faces.add(getIndex(parts[1], uvs.size));
+						parts = tokens[++i].split("/");
+						faces.add(getIndex(parts[0], verts.size));
+						if (parts.length > 2) faces.add(getIndex(parts[2], norms.size));
+						if (parts.length > 1 && parts[1].length() > 0) faces.add(getIndex(parts[1], uvs.size));
+						activeGroup.numFaces++;
+					}
+				} else if (firstChar == 'o' || firstChar == 'g') {
+					// This implementation only supports single object or group
+					// definitions. i.e. "o group_a group_b" will set group_a
+					// as the active group, while group_b will simply be
+					// ignored.
+					if (tokens.length > 1)
+						activeGroup = setActiveGroup(tokens[1]);
+					else
+						activeGroup = setActiveGroup("default");
+				} else if (tokens[0].equals("mtllib")) {
+					String path = "";
+					if (file.path().contains("/")) {
+						path = file.path().substring(0, file.path().lastIndexOf('/') + 1);
+					}
+					mtl.load(path + tokens[1], textureDir);
+				} else if (tokens[0].equals("usemtl")) {
+					if (tokens.length == 1)
+						activeGroup.materialName = "default";
+					else
+						activeGroup.materialName = tokens[1];
+				}
+			}
+			reader.close();
+		} catch (IOException e) {
+			return null;
+		}
+
+		// If the "default" group or any others were not used, get rid of them
+		for (int i = 0; i < groups.size(); i++) {
+			if (groups.get(i).numFaces < 1) {
+				groups.remove(i);
+				i--;
+			}
+		}
+
+		// If there are no groups left, there is no valid Model to return
+		if (groups.size() < 1) return null;
+
+		// Get number of objects/groups remaining after removing empty ones
+		final int numGroups = groups.size();
+
+		final StillModel model = new StillModel(new StillSubMesh[numGroups]);
+
+		for (int g = 0; g < numGroups; g++) {
+			Group group = groups.get(g);
+			ArrayList<Integer> faces = group.faces;
+			final int numElements = faces.size();
+			final int numFaces = group.numFaces;
+			final boolean hasNorms = group.hasNorms;
+			final boolean hasUVs = group.hasUVs;
+
+			final float[] finalVerts = new float[(numFaces * 3) * (3 + (hasNorms ? 3 : 0) + (hasUVs ? 2 : 0))];
+
+			for (int i = 0, vi = 0; i < numElements;) {
+				int vertIndex = faces.get(i++) * 3;
+				finalVerts[vi++] = verts.get(vertIndex++);
+				finalVerts[vi++] = verts.get(vertIndex++);
+				finalVerts[vi++] = verts.get(vertIndex);
+				if (hasNorms) {
+					int normIndex = faces.get(i++) * 3;
+					finalVerts[vi++] = norms.get(normIndex++);
+					finalVerts[vi++] = norms.get(normIndex++);
+					finalVerts[vi++] = norms.get(normIndex);
+				}
+				if (hasUVs) {
+					int uvIndex = faces.get(i++) * 2;
+					finalVerts[vi++] = uvs.get(uvIndex++);
+					finalVerts[vi++] = uvs.get(uvIndex);
+				}
+			}
+
+			final int numIndices = numFaces * 3 >= Short.MAX_VALUE ? 0 : numFaces * 3;
+			final short[] finalIndices = new short[numIndices];
+			// if there are too many vertices in a mesh, we can't use indices
+			if (numIndices > 0) {
+				for (int i = 0; i < numIndices; i++) {
+					finalIndices[i] = (short)i;
+				}
+			}
+			final Mesh mesh;
+
+			ArrayList<VertexAttribute> attributes = new ArrayList<VertexAttribute>();
+			attributes.add(new VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE));
+			if (hasNorms) attributes.add(new VertexAttribute(Usage.Normal, 3, ShaderProgram.NORMAL_ATTRIBUTE));
+			if (hasUVs) attributes.add(new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + "0"));
+
+			mesh = new Mesh(true, numFaces * 3, numIndices, attributes.toArray(new VertexAttribute[attributes.size()]));
+			mesh.setVertices(finalVerts);
+			if (numIndices > 0) mesh.setIndices(finalIndices);
+
+			StillSubMesh subMesh = new StillSubMesh(group.name, mesh, GL10.GL_TRIANGLES);
+			subMesh.material = mtl.getMaterial(group.materialName);
+			model.subMeshes[g] = subMesh;
+
+		}
+
+		// An instance of ObjLoader can be used to load more than one OBJ.
+		// Clearing the ArrayList cache instead of instantiating new
+		// ArrayLists should result in slightly faster load times for
+		// subsequent calls to loadObj
+		if (verts.size > 0) verts.clear();
+		if (norms.size > 0) norms.clear();
+		if (uvs.size > 0) uvs.clear();
+		if (groups.size() > 0) groups.clear();
+
+		return model;
+	}
+
+	private Group setActiveGroup (String name) {
+		// TODO: Check if a HashMap.get calls are faster than iterating
+		// through an ArrayList
+		for (Group group : groups) {
+			if (group.name.equals(name)) return group;
+		}
+		Group group = new Group(name);
+		groups.add(group);
+		return group;
+	}
+
+	private int getIndex (String index, int size) {
+		if (index == null || index.length() == 0) return 0;
+		final int idx = Integer.parseInt(index);
+		if (idx < 0)
+			return size + idx;
+		else
+			return idx - 1;
+	}
+
+	private class Group {
+		final String name;
+		String materialName;
+		ArrayList<Integer> faces;
+		int numFaces;
+		boolean hasNorms;
+		boolean hasUVs;
+		Material mat;
+
+		Group (String name) {
+			this.name = name;
+			this.faces = new ArrayList<Integer>(200);
+			this.numFaces = 0;
+			this.mat = new Material("");
+			this.materialName = "default";
+		}
+	}
+
+	@Override
+	public StillModel load (FileHandle handle, ModelLoaderHints hints) {
+		return loadObj(handle, hints.flipV);
+	}
+}
+
+class MtlLoader {
+	private ArrayList<Material> materials = new ArrayList<Material>();
+	private static AssetManager assetManager;
+	private static Texture emptyTexture = null;
+
+	public MtlLoader () {
+		if (emptyTexture == null) {
+			assetManager = new AssetManager();
+			Pixmap pm = new Pixmap(1, 1, Format.RGB888);
+			pm.setColor(0.5f, 0.5f, 0.5f, 1);
+			pm.fill();
+			emptyTexture = new Texture(pm, false);
+		}
+	}
+
+	/** loads .mtl file
+	 * @param name */
+	public void load (String name, FileHandle textureDir) {
+		String line;
+		String[] tokens;
+		String curMatName = "default";
+		Color difcolor = Color.WHITE;
+		Color speccolor = Color.WHITE;
+		Texture texture = emptyTexture;
+
+		FileHandle file = Gdx.files.internal(name);
+		if (file == null || file.exists() == false) return;
+
+		BufferedReader reader = new BufferedReader(new InputStreamReader(file.read()), 4096);
+		try {
+			while ((line = reader.readLine()) != null) {
+
+				if (line.length() > 0 && line.charAt(0) == '\t') line = line.substring(1).trim();
+
+				tokens = line.split("\\s+");
+
+				if (tokens[0].length() == 0) {
+					continue;
+				} else if (tokens[0].charAt(0) == '#')
+					continue;
+				else if (tokens[0].toLowerCase().equals("newmtl")) {
+					Material mat = new Material(curMatName, new TextureAttribute(texture, 0, TextureAttribute.diffuseTexture),
+						new ColorAttribute(difcolor, ColorAttribute.diffuse), new ColorAttribute(speccolor, ColorAttribute.specular));
+					materials.add(mat);
+
+					if (tokens.length > 1) {
+						curMatName = tokens[1];
+						curMatName = curMatName.replace('.', '_');
+					} else
+						curMatName = "default";
+
+					difcolor = Color.WHITE;
+					speccolor = Color.WHITE;
+				} else if (tokens[0].toLowerCase().equals("kd") || tokens[0].toLowerCase().equals("ks")) // diffuse or specular
+				{
+					float r = Float.parseFloat(tokens[1]);
+					float g = Float.parseFloat(tokens[2]);
+					float b = Float.parseFloat(tokens[3]);
+					float a = 1;
+					if (tokens.length > 4) a = Float.parseFloat(tokens[4]);
+
+					if (tokens[0].toLowerCase().equals("kd")) {
+						difcolor = new Color();
+						difcolor.set(r, g, b, a);
+					} else {
+						speccolor = new Color();
+						speccolor.set(r, g, b, a);
+					}
+				} else if (tokens[0].toLowerCase().equals("map_kd")) {
+					String textureName = tokens[1];
+					if (textureName.length() > 0) {
+						String texname = textureDir.child(textureName).toString();
+						assetManager.load(texname, Texture.class);
+						assetManager.finishLoading();
+						texture = assetManager.get(texname, Texture.class);
+						texture.setFilter(TextureFilter.Linear, TextureFilter.Linear);
+					} else
+						texture = emptyTexture;
+
+				}
+
+			}
+			reader.close();
+		} catch (IOException e) {
+			return;
+		}
+
+		// last material
+		Material mat = new Material(curMatName, new TextureAttribute(texture, 0, TextureAttribute.diffuseTexture),
+			new ColorAttribute(difcolor, ColorAttribute.diffuse), new ColorAttribute(speccolor, ColorAttribute.specular));
+		materials.add(mat);
+
+		return;
+	}
+
+	public Material getMaterial (String name) {
+		name = name.replace('.', '_');
+		for (Material mat : materials) {
+			if (mat.getName().equals(name)) return mat;
+		}
+		return new Material("default");
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/materials/BlendingAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/materials/BlendingAttribute.java
new file mode 100644
index 0000000..360cc9a
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/materials/BlendingAttribute.java
@@ -0,0 +1,88 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.materials;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.GL10;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.badlogic.gdx.utils.Pool;
+
+public class BlendingAttribute extends MaterialAttribute {
+
+	/** if BlendingAttribute name is translucent then default tranparency mechanism is used in shader */
+	public static final String translucent = "translucent";
+
+	public int blendSrcFunc;
+	public int blendDstFunc;
+
+	protected BlendingAttribute () {
+	}
+
+	/** Utility constuctor for basic transparency blendSrcFunc = GL10.GL_SRC_ALPHA blendDstFunc = GL10.GL_ONE_MINUS_SRC_ALPHA
+	 * @param name */
+	public BlendingAttribute (String name) {
+		this(name, GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
+	}
+
+	public BlendingAttribute (String name, int srcFunc, int dstFunc) {
+		super(name);
+		blendSrcFunc = srcFunc;
+		blendDstFunc = dstFunc;
+	}
+
+	@Override
+	public void bind () {
+		Gdx.gl.glBlendFunc(blendSrcFunc, blendDstFunc);
+	}
+
+	@Override
+	public void bind (ShaderProgram program) {
+		Gdx.gl.glBlendFunc(blendSrcFunc, blendDstFunc);
+	}
+
+	@Override
+	public MaterialAttribute copy () {
+		return new BlendingAttribute(this.name, this.blendSrcFunc, this.blendDstFunc);
+	}
+
+	@Override
+	public void set (MaterialAttribute attr) {
+		BlendingAttribute blendAttr = (BlendingAttribute)attr;
+		name = blendAttr.name;
+		blendDstFunc = blendAttr.blendDstFunc;
+		blendSrcFunc = blendAttr.blendSrcFunc;
+	}
+
+	private final static Pool<BlendingAttribute> pool = new Pool<BlendingAttribute>() {
+		@Override
+		protected BlendingAttribute newObject () {
+			return new BlendingAttribute();
+		}
+	};
+
+	@Override
+	public MaterialAttribute pooledCopy () {
+		BlendingAttribute attr = pool.obtain();
+		attr.set(this);
+		return attr;
+	}
+
+	@Override
+	public void free () {
+		if (isPooled) pool.free(this);
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/materials/ColorAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/materials/ColorAttribute.java
new file mode 100644
index 0000000..feaa985
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/materials/ColorAttribute.java
@@ -0,0 +1,96 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.materials;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.Color;
+import com.badlogic.gdx.graphics.GL10;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.badlogic.gdx.utils.Pool;
+
+public class ColorAttribute extends MaterialAttribute {
+
+	static final public String diffuse = "diffuseColor";
+	static final public String specular = "specularColor";
+	static final public String emissive = "emissiveColor";
+	static final public String rim = "rimColor";
+	static final public String fog = "fogColor";
+
+	public final Color color = new Color();
+
+	protected ColorAttribute () {
+	}
+
+	/** Creates a {@link MaterialAttribute} that is a pure {@link Color}.
+	 * 
+	 * @param color The {@link Color} that you wish the attribute to represent.
+	 * @param name The name of the uniform in the {@link ShaderProgram} that will have its value set to this color. (A 'name' does
+	 *           not matter for a game that uses {@link GL10}). */
+	public ColorAttribute (Color color, String name) {
+		super(name);
+		this.color.set(color);
+	}
+
+	@Override
+	public void bind () {
+		if (Gdx.gl10 == null) throw new RuntimeException("Can't call ColorAttribute.bind() in a GL20 context");
+
+		// todo how about emissive or specular?
+		// TODO replace string equals with something more performant
+		if (diffuse.equals(diffuse)) Gdx.gl10.glColor4f(color.r, color.g, color.b, color.a);
+	}
+
+	@Override
+	public void bind (ShaderProgram program) {
+		program.setUniformf(name, color.r, color.g, color.b, color.a);
+	}
+
+	@Override
+	public MaterialAttribute copy () {
+		return new ColorAttribute(color, name);
+	}
+
+	@Override
+	public void set (MaterialAttribute attr) {
+		ColorAttribute colAttr = (ColorAttribute)attr;
+		name = colAttr.name;
+		final Color c = colAttr.color;
+		color.r = c.r;
+		color.g = c.g;
+		color.b = c.b;
+		color.a = c.a;
+	}
+
+	private final static Pool<ColorAttribute> pool = new Pool<ColorAttribute>() {
+		@Override
+		protected ColorAttribute newObject () {
+			return new ColorAttribute();
+		}
+	};
+
+	@Override
+	public MaterialAttribute pooledCopy () {
+		ColorAttribute attr = pool.obtain();
+		attr.set(this);
+		return attr;
+	}
+
+	@Override
+	public void free () {
+		if (isPooled) pool.free(this);
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/materials/Material.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/materials/Material.java
new file mode 100644
index 0000000..210d250
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/materials/Material.java
@@ -0,0 +1,226 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.materials;
+
+import java.util.Iterator;
+
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.badlogic.gdx.utils.Array;
+
+public class Material implements Iterable<MaterialAttribute> {
+	protected String name;
+	private Array<MaterialAttribute> attributes;
+
+	/** This flag is true if material contain blendingAttribute */
+	protected boolean needBlending;
+	/** This flag is true if material contain TextureAttribute */
+	protected boolean hasTexture;
+
+	protected ShaderProgram shader;
+
+	public Material () {
+		attributes = new Array<MaterialAttribute>(2);
+	}
+
+	public Material (String name, Array<MaterialAttribute> attributes) {
+		this.name = name;
+		this.attributes = attributes;
+
+		checkAttributes();
+	}
+
+	public Material (String name, MaterialAttribute... attributes) {
+		this(name, new Array<MaterialAttribute>(attributes));
+	}
+	
+	protected void checkAttributes() {
+		// this way we foresee if blending is needed with this material and rendering can deferred more easily
+		this.needBlending = false;
+		this.hasTexture = false;
+		for (int i = 0; i < this.attributes.size; i++) {
+			if (!needBlending && this.attributes.get(i) instanceof BlendingAttribute)
+				this.needBlending = true;
+			else if (!hasTexture && this.attributes.get(i) instanceof TextureAttribute)
+				this.hasTexture = true;
+		}		
+	}
+
+	public void bind () {
+		for (int i = 0; i < attributes.size; i++) {
+			attributes.get(i).bind();
+		}
+	}
+
+	public void bind (ShaderProgram program) {
+		for (int i = 0; i < attributes.size; i++) {
+			attributes.get(i).bind(program);
+		}
+	}
+
+	public String getName () {
+		return name;
+	}
+	
+	public void addAttribute(MaterialAttribute... attributes){
+		for (int i = 0; i < attributes.length; i++) {
+			if(attributes[i] instanceof BlendingAttribute)
+				needBlending = true;
+			else if (attributes[i] instanceof TextureAttribute)
+				hasTexture = true;
+			this.attributes.add(attributes[i]);
+		}
+	}
+	
+	public void removeAttribute(MaterialAttribute... attributes){
+		for (int i = 0; i < attributes.length; i++)
+			this.attributes.removeValue(attributes[i], true);
+		checkAttributes();
+	}
+	
+	public void clearAttributes(){
+		attributes.clear();
+		needBlending = false;
+	}
+	
+	public MaterialAttribute getAttribute(int index){
+		if(index >= 0 && index < attributes.size)
+			return attributes.get(index);
+		return null;
+	}
+	
+	public int getNumberOfAttributes(){
+		return attributes.size;
+	}
+	
+//	/** @return True if this material contains attribute of the specified type, false otherwise */
+//	public <T extends MaterialAttribute> boolean hasAttribute(Class<T> type) {
+//		return indexOfAttribute(type) >= 0;
+//	}
+//	
+//	/** @return The index of the first attribute of the specified type or -1 if not available */
+//	public <T extends MaterialAttribute> int indexOfAttribute(Class<T> type) {
+//		for (int i = 0; i < attributes.size; i++)
+//			if (type.isInstance(attributes.get(i)))
+//				return i;
+//		return -1;
+//	}
+//	
+//	/** @return The first attribute of the specified type, or null if not available */
+//	public <T extends MaterialAttribute> T getAttribute(Class<T> type) {
+//		return (T)getAttribute(indexOfAttribute(type));
+//	}
+
+	public Material copy () {
+		Array<MaterialAttribute> attributes = new Array<MaterialAttribute>(this.attributes.size);
+		for (int i = 0; i < attributes.size; i++) {
+			attributes.add(this.attributes.get(i).copy());
+		}
+		final Material copy = new Material(name, attributes);
+		copy.shader = this.shader;
+		return copy;
+	}
+
+	@Override
+	public int hashCode () {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + attributes.hashCode();
+		result = prime * result + ((name == null) ? 0 : name.hashCode());
+		return result;
+	}
+
+	@Override
+	public boolean equals (Object obj) {
+		if (this == obj) return true;
+		if (obj == null) return false;
+		if (getClass() != obj.getClass()) return false;
+		Material other = (Material)obj;
+		if (other.attributes.size != attributes.size) return false;
+		for (int i = 0; i < attributes.size; i++) {
+			if (!attributes.get(i).equals(other.attributes.get(i))) return false;
+		}
+		if (name == null) {
+			if (other.name != null) return false;
+		} else if (!name.equals(other.name)) return false;
+		return true;
+	}
+
+	public boolean shaderEquals (Material other) {
+		if (this == other) return true;
+
+		int len = this.attributes.size;
+		if (len != other.attributes.size) return false;
+
+		for (int i = 0; i < len; i++) {
+			final String str = this.attributes.get(i).name;
+			if (str == null) return false;
+
+			boolean matchFound = false;
+			for (int j = 0; j < len; j++) {
+				if (str.equals(other.attributes.get(j).name)) {
+					matchFound = true;
+					break;
+				}
+			}
+			if (!matchFound) return false;
+		}
+
+		return true;
+	}
+
+	public void setPooled (Material material) {
+		name = material.name;
+		shader = material.shader;
+		needBlending = material.needBlending;
+		hasTexture = material.hasTexture;
+		attributes.clear();
+		for (int i = 0, len = material.attributes.size; i < len; i++) {
+			attributes.add(material.attributes.get(i).pooledCopy());
+		}
+	}
+
+	public boolean isNeedBlending () {
+		return needBlending;
+	}
+	
+	public boolean hasTexture() {
+		return hasTexture;
+	}
+
+	public ShaderProgram getShader () {
+		return shader;
+	}
+	
+	public void setShader(final ShaderProgram shader) {
+		this.shader = shader;
+	}
+	
+	public void resetShader () {
+		shader = null;
+	}
+
+	@Override
+	public Iterator<MaterialAttribute> iterator () {
+		return attributes.iterator();
+	}
+
+	/* TODO: Sits in Experimental only used for ProtoRenderer
+	public void generateShader (MaterialShaderHandler materialShaderHandler) {
+		shader = materialShaderHandler.getShader(this);
+	}
+	*/
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/materials/MaterialAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/materials/MaterialAttribute.java
new file mode 100644
index 0000000..8ee4cc6
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/materials/MaterialAttribute.java
@@ -0,0 +1,50 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.materials;
+
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+
+public abstract class MaterialAttribute {
+	private static final String FLAG = "Flag";
+	public String name;
+	protected final boolean isPooled;
+
+	protected MaterialAttribute () {
+		isPooled = true;
+	}
+
+	public MaterialAttribute (String name) {
+		this.name = name;
+		isPooled = false;
+	}
+
+	public abstract void bind ();
+
+	public abstract void bind (ShaderProgram program);
+
+	public abstract MaterialAttribute copy ();
+
+	public abstract MaterialAttribute pooledCopy ();
+
+	public abstract void free ();
+
+	public abstract void set (MaterialAttribute attr);
+
+	public String getShaderFlag () {
+		return name + FLAG;
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/materials/TextureAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/materials/TextureAttribute.java
new file mode 100644
index 0000000..15d9568
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/materials/TextureAttribute.java
@@ -0,0 +1,128 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.materials;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.GL10;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.Texture.TextureFilter;
+import com.badlogic.gdx.graphics.Texture.TextureWrap;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.badlogic.gdx.utils.Pool;
+
+public class TextureAttribute extends MaterialAttribute {
+
+	public final static int MAX_TEXTURE_UNITS = 16;
+	static final public String diffuseTexture = "diffuseTexture";
+	static final public String lightmapTexture = "lightmapTexture";
+	static final public String specularTexture = "specularTexture";
+
+	public Texture texture;
+	public int unit;
+	public int minFilter;
+	public int magFilter;
+	public int uWrap;
+	public int vWrap;
+
+	protected TextureAttribute () {
+	}
+
+	public TextureAttribute (Texture texture, int unit, String name, TextureFilter minFilter, TextureFilter magFilter,
+		TextureWrap uWrap, TextureWrap vWrap) {
+		this(texture, unit, name, minFilter.getGLEnum(), magFilter.getGLEnum(), uWrap.getGLEnum(), vWrap.getGLEnum());
+	}
+
+	public TextureAttribute (Texture texture, int unit, String name, int minFilter, int magFilter, int uWrap, int vWrap) {
+		super(name);
+		this.texture = texture;
+		if (unit > MAX_TEXTURE_UNITS) throw new RuntimeException(MAX_TEXTURE_UNITS + " is max texture units supported");
+		this.unit = unit;
+		this.uWrap = uWrap;
+		this.vWrap = vWrap;
+		this.minFilter = minFilter;
+		this.magFilter = magFilter;
+	}
+
+	public TextureAttribute (Texture texture, int unit, String name) {
+		this(texture, unit, name, texture.getMinFilter(), texture.getMagFilter(), texture.getUWrap(), texture.getVWrap());
+	}
+
+	@Override
+	public void bind () {
+		texture.bind(unit);
+		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER, minFilter);
+		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER, magFilter);
+		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_S, uWrap);
+		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_T, vWrap);
+	}
+
+	@Override
+	public void bind (ShaderProgram program) {
+		texture.bind(unit);
+		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER, minFilter);
+		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER, magFilter);
+		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_S, uWrap);
+		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_T, vWrap);
+		program.setUniformi(name, unit);
+	}
+
+	@Override
+	public MaterialAttribute copy () {
+		return new TextureAttribute(texture, unit, name, minFilter, magFilter, uWrap, vWrap);
+	}
+
+	@Override
+	public void set (MaterialAttribute attr) {
+		TextureAttribute texAttr = (TextureAttribute)attr;
+		name = texAttr.name;
+		texture = texAttr.texture;
+		unit = texAttr.unit;
+		magFilter = texAttr.magFilter;
+		minFilter = texAttr.minFilter;
+		uWrap = texAttr.uWrap;
+		vWrap = texAttr.vWrap;
+	}
+
+	/** this method check if the texture portion of texture attribute is equal, name isn't used */
+	public boolean texturePortionEquals (TextureAttribute other) {
+		if (other == null) return false;
+		if (this == other) return true;
+
+		return (texture == other.texture) && (unit == other.unit) && (minFilter == other.minFilter)
+			&& (magFilter == other.magFilter) && (uWrap == other.uWrap) && (vWrap == other.vWrap);
+
+	}
+
+	private final static Pool<TextureAttribute> pool = new Pool<TextureAttribute>() {
+		@Override
+		protected TextureAttribute newObject () {
+			return new TextureAttribute();
+		}
+	};
+
+	@Override
+	public MaterialAttribute pooledCopy () {
+		TextureAttribute attr = pool.obtain();
+		attr.set(this);
+		return attr;
+	}
+
+	@Override
+	public void free () {
+		if (isPooled) pool.free(this);
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/AnimatedModel.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/AnimatedModel.java
new file mode 100644
index 0000000..6c26db3
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/AnimatedModel.java
@@ -0,0 +1,35 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.model;
+
+public interface AnimatedModel extends Model {
+	/** Start playing the given animation at the given time in the animation and specify wether or not the animation will loop.
+	 * @param animation The name of the animation in this {@link Model} that you should play.
+	 * @param time The time, in seconds, of the section to start the animation.
+	 * @param loop Whether or not the animation will loop if the time is after the end of the animation. (TODO what happens when
+	 *           you reach the end of the animation and this is not set?) */
+	public void setAnimation (String animation, float time, boolean loop);
+
+	/** Get a specific named animation out of the model.
+	 * @param name The name of the animation that you wish to get.
+	 * @return The Animation that you requested; or, if the animation does not exist, null is returned. */
+	public Animation getAnimation (String name);
+
+	/** Get an array containing all of the animations in this model.
+	 * @return An array containing a list of all of the animations in this model. */
+	public Animation[] getAnimations ();
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/Animation.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/Animation.java
new file mode 100644
index 0000000..309fd7a
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/Animation.java
@@ -0,0 +1,27 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.model;
+
+public class Animation {
+	public final String name;
+	public final float totalDuration;
+
+	public Animation (String name, float totalDuration) {
+		this.name = name;
+		this.totalDuration = totalDuration;
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/Model.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/Model.java
new file mode 100644
index 0000000..87267ca
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/Model.java
@@ -0,0 +1,72 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.model;
+
+import com.badlogic.gdx.graphics.GL10;
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.badlogic.gdx.math.collision.BoundingBox;
+
+public interface Model {
+	/** Renders the model using the {@link GL10} pipeline.<br />
+	 * <br />
+	 * <strong>Important:</strong> This model must have materials set before you can use this render function. Do that by using
+	 * {@link Model#setMaterials(Material...)}. */
+	public void render ();
+
+	/** Renders this model using the {@link GL20} shader pipeline.<br />
+	 * <br />
+	 * <strong>IMPORTANT:</strong> This model must have materials set before you can use this render function. Do that by using
+	 * {@link Model#setMaterials(Material...)}.
+	 * @param program The shader program that you will use to draw this object to the screen. It must be non-null. */
+	public void render (ShaderProgram program);
+
+	/** Returns a {@link Model} that is made up of the sub-meshes with the provided names.
+	 * @param subMeshNames A list of names of each {@link SubMesh} that is to be extracted from this model.
+	 * @return A new {@link Model} that is only made up of the parts you requested. */
+	public Model getSubModel (String... subMeshNames);
+
+	/** @param name The name of the {@link SubMesh} to be acquired.
+	 * @return The {@link SubMesh} that matches that name; or null, if one does not exist. */
+	public SubMesh getSubMesh (String name);
+
+	/** @return An array of every {@link SubMesh} that makes up this model. */
+	public SubMesh[] getSubMeshes ();
+
+	/** Generates the bounding box for the Model.<br />
+	 * <br />
+	 * For every finite 3D object there exists a box that can enclose the object. This function sets the give {@link BoundingBox}
+	 * to be one such enclosing box.<br />
+	 * Bounding boxes are useful for very basic collision detection amongst other tasks.
+	 * @param bbox The provided {@link BoundingBox} will have its internal values correctly set. (To allow Java Object reuse) */
+	public void getBoundingBox (BoundingBox bbox);
+
+	/** Sets every {@link Material} of every {@link SubMesh} in this {@link Model} to be the materials provided.
+	 * @param materials A list of the materials to set the submeshes to for this model. (The length of the list of materials must
+	 *           be the same as the number of SubMeshes in this Model. Failure to do so will result in an
+	 *           {@link UnsupportedOperationException}) */
+	public void setMaterials (Material... materials);
+
+	/** Sets the {@link Material} of every {@link SubMesh} in this Model to be the material provided.
+	 * @param material The Material that you wish the whole object to be rendered with. */
+	public void setMaterial (Material material);
+
+	/** This function releases memory once you are done with the Model. Once you are finished with the Model you MUST call this
+	 * function or else you will suffer memory leaks. */
+	public void dispose ();
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/SubMesh.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/SubMesh.java
new file mode 100644
index 0000000..39ab755
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/SubMesh.java
@@ -0,0 +1,53 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.model;
+
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+import com.badlogic.gdx.math.collision.BoundingBox;
+
+public abstract class SubMesh {
+	public String name;
+	public Material material;
+	public int primitiveType;
+	public Mesh mesh;
+
+
+	public SubMesh (String name, Mesh mesh, int primitiveType, Material material) {
+		this.name = name;
+		this.setMesh(mesh);
+		this.primitiveType = primitiveType;
+		this.material = material;
+	}
+	
+	public SubMesh (String name, Mesh mesh, int primitiveType) {
+		this(name, mesh, primitiveType, null);
+	}
+
+	/** Obtain the {@link BoundingBox} of this {@link SubMesh}.
+	 * 
+	 * @param bbox This {@link BoundingBox} will be modified so that its contain values that are the bounding box for this SubMesh. */
+	public abstract void getBoundingBox (BoundingBox bbox);
+
+	public Mesh getMesh() {
+		return mesh;
+	}
+
+	public void setMesh(Mesh mesh) {
+		this.mesh = mesh;
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/keyframe/Keyframe.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/keyframe/Keyframe.java
new file mode 100644
index 0000000..13b118e
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/keyframe/Keyframe.java
@@ -0,0 +1,27 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.model.keyframe;
+
+public class Keyframe {
+	public final float timeStamp;
+	public final float[] vertices;
+
+	public Keyframe (float timeStamp, float[] vertices) {
+		this.timeStamp = timeStamp;
+		this.vertices = vertices;
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/keyframe/KeyframedAnimation.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/keyframe/KeyframedAnimation.java
new file mode 100644
index 0000000..9d35e23
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/keyframe/KeyframedAnimation.java
@@ -0,0 +1,30 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.model.keyframe;
+
+import com.badlogic.gdx.graphics.g3d.old.model.Animation;
+
+public class KeyframedAnimation extends Animation {
+	public final float frameDuration;
+	public final Keyframe[] keyframes;
+
+	public KeyframedAnimation (String name, float frameDuration, Keyframe[] keyframes) {
+		super(name, frameDuration * keyframes.length);
+		this.frameDuration = frameDuration;
+		this.keyframes = keyframes;
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/keyframe/KeyframedModel.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/keyframe/KeyframedModel.java
new file mode 100644
index 0000000..21083a5
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/keyframe/KeyframedModel.java
@@ -0,0 +1,200 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.model.keyframe;
+
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+import com.badlogic.gdx.graphics.g3d.old.model.AnimatedModel;
+import com.badlogic.gdx.graphics.g3d.old.model.Model;
+import com.badlogic.gdx.graphics.g3d.old.model.SubMesh;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.badlogic.gdx.math.collision.BoundingBox;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.Disposable;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+public class KeyframedModel implements AnimatedModel, Disposable {
+	public final KeyframedSubMesh[] subMeshes;
+	protected final KeyframedAnimation[] animations;
+
+	public KeyframedModel (KeyframedSubMesh[] subMeshes) {
+		this.subMeshes = subMeshes;
+
+		Array<KeyframedAnimation> meshAnims = subMeshes[0].animations.values().toArray();
+		animations = new KeyframedAnimation[meshAnims.size];
+		for (int i = 0; i < animations.length; i++) {
+			animations[i] = meshAnims.get(i);
+		}
+
+		checkValidity();
+	}
+
+	private void checkValidity () {
+		for (int i = 0; i < subMeshes.length; i++) {
+			if (subMeshes[i].animations.size != animations.length)
+				throw new GdxRuntimeException("number of animations in subMesh[0] is not the same in subMesh[" + i
+					+ "]. All sub-meshes must have the same animations and number of frames");
+		}
+
+		for (int i = 0; i < animations.length; i++) {
+			KeyframedAnimation anim = animations[i];
+			for (int j = 0; j < subMeshes.length; j++) {
+				KeyframedAnimation otherAnim = subMeshes[j].animations.get(anim.name);
+				if (otherAnim == null) throw new GdxRuntimeException("animation '" + anim.name + "' missing in subMesh[" + j + "]");
+				if (otherAnim.frameDuration != anim.frameDuration)
+					throw new GdxRuntimeException("animation '" + anim.name + "' in subMesh[" + j
+						+ "] has different frame duration than the same animation in subMesh[0]");
+				if (otherAnim.keyframes.length != anim.keyframes.length)
+					throw new GdxRuntimeException("animation '" + anim.name + "' in subMesh[" + j
+						+ "] has different number of keyframes than the same animation in subMesh[0]");
+			}
+		}
+	}
+
+	@Override
+	public void render () {
+		int len = subMeshes.length;
+		for (int i = 0; i < len; i++) {
+			KeyframedSubMesh subMesh = subMeshes[i];
+			if (i == 0 || !subMeshes[i - 1].material.equals(subMesh.material)) {
+				subMesh.material.bind();
+			}
+			subMesh.mesh.render(subMesh.primitiveType);
+		}
+	}
+
+	@Override
+	public void render (ShaderProgram program) {
+		int len = subMeshes.length;
+		for (int i = 0; i < len; i++) {
+			KeyframedSubMesh subMesh = subMeshes[i];
+			if (i == 0 || !subMeshes[i - 1].material.equals(subMesh.material)) {
+				subMesh.material.bind(program);
+			}
+			subMesh.mesh.render(program, subMesh.primitiveType);
+		}
+	}
+
+	@Override
+	public void setMaterials (Material... materials) {
+		if (materials.length != subMeshes.length)
+			throw new UnsupportedOperationException("number of materials must equal number of sub-meshes");
+		int len = materials.length;
+		for (int i = 0; i < len; i++) {
+			subMeshes[i].material = materials[i];
+		}
+	}
+
+	@Override
+	public void setMaterial (Material material) {
+		int len = subMeshes.length;
+		for (int i = 0; i < len; i++) {
+			subMeshes[i].material = material;
+		}
+	}
+
+	@Override
+	public KeyframedSubMesh getSubMesh (String name) {
+		int len = subMeshes.length;
+		for (int i = 0; i < len; i++) {
+			if (subMeshes[i].name.equals(name)) return subMeshes[i];
+		}
+		return null;
+	}
+
+	@Override
+	public SubMesh[] getSubMeshes () {
+		return subMeshes;
+	}
+
+	@Override
+	public void setAnimation (String animation, float time, boolean loop) {
+		int len = subMeshes.length;
+		for (int i = 0; i < len; i++) {
+			final KeyframedSubMesh subMesh = subMeshes[i];
+			final KeyframedAnimation anim = subMesh.animations.get(animation);
+			if (anim == null) throw new IllegalArgumentException("No animation with name '" + animation + "' in submesh #" + i);
+			if (time < 0 || time > anim.totalDuration)
+				throw new IllegalArgumentException("time must be 0 <= time <= animation duration");
+
+			final int startIndex = (int)Math.floor((time / anim.frameDuration));
+			final Keyframe startFrame = anim.keyframes[startIndex];
+			final Keyframe endFrame = anim.keyframes[anim.keyframes.length - 1 == startIndex ? loop ? 0 : startIndex
+				: startIndex + 1];
+
+			final int numComponents = subMesh.animatedComponents;
+			final float[] src = startFrame.vertices;
+			final int srcLen = numComponents * subMesh.mesh.getNumVertices();
+
+			final float[] dst = subMesh.blendedVertices;
+			final int dstInc = subMesh.mesh.getVertexSize() / 4 - numComponents;
+
+			if (startFrame == endFrame) {
+				for (int srcIdx = 0, dstIdx = 0; srcIdx < srcLen; dstIdx += dstInc) {
+					for (int j = 0; j < numComponents; j++) {
+						dst[dstIdx++] = src[srcIdx++];
+					}
+				}
+			} else {
+				float[] src2 = endFrame.vertices;
+				float alpha = (time - (startIndex * anim.frameDuration)) / anim.frameDuration;
+				for (int srcIdx = 0, dstIdx = 0; srcIdx < srcLen; dstIdx += dstInc) {
+					for (int j = 0; j < numComponents; j++) {
+						final float valSrc = src[srcIdx];
+						final float valSrc2 = src2[srcIdx++];
+						dst[dstIdx++] = valSrc + (valSrc2 - valSrc) * alpha;
+					}
+				}
+			}
+
+			subMesh.mesh.setVertices(dst);
+		}
+	}
+
+	@Override
+	public KeyframedAnimation getAnimation (String name) {
+		return subMeshes[0].animations.get(name);
+	}
+
+	@Override
+	public KeyframedAnimation[] getAnimations () {
+		return animations;
+	}
+
+	@Override
+	public Model getSubModel (String... subMeshNames) {
+		// FIXME
+		return null;
+	}
+
+	private final static BoundingBox tmpBox = new BoundingBox();
+
+	@Override
+	public void getBoundingBox (BoundingBox bbox) {
+		bbox.inf();
+		for (int i = 0; i < subMeshes.length; i++) {
+			subMeshes[i].mesh.calculateBoundingBox(tmpBox);
+			bbox.ext(tmpBox);
+		}
+	}
+
+	@Override
+	public void dispose () {
+		for (int i = 0; i < subMeshes.length; i++) {
+			subMeshes[i].mesh.dispose();
+		}
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/keyframe/KeyframedSubMesh.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/keyframe/KeyframedSubMesh.java
new file mode 100644
index 0000000..d613ccd
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/keyframe/KeyframedSubMesh.java
@@ -0,0 +1,44 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.model.keyframe;
+
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.g3d.old.model.SubMesh;
+import com.badlogic.gdx.math.collision.BoundingBox;
+import com.badlogic.gdx.utils.ObjectMap;
+
+public class KeyframedSubMesh extends SubMesh {
+	public final float[] blendedVertices;
+	public final int animatedComponents;
+	public final ObjectMap<String, KeyframedAnimation> animations;
+
+	public KeyframedSubMesh (String name, Mesh mesh, float[] blendedVertices, ObjectMap<String, KeyframedAnimation> animations,
+		int animatedComponents, int primitiveType) {
+		
+		super(name, mesh, primitiveType);
+		
+		this.blendedVertices = blendedVertices;
+		this.animations = animations;
+		this.animatedComponents = animatedComponents;
+	}
+
+	@Override
+	public void getBoundingBox (BoundingBox bbox) {
+		mesh.calculateBoundingBox(bbox);
+	}
+
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/skeleton/Skeleton.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/skeleton/Skeleton.java
new file mode 100644
index 0000000..b1436d2
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/skeleton/Skeleton.java
@@ -0,0 +1,156 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.model.skeleton;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import com.badlogic.gdx.math.Matrix4;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.ObjectMap;
+
+public class Skeleton {
+	/** each joint is a root joint in the hierachy **/
+	public final Array<SkeletonJoint> hierarchy = new Array<SkeletonJoint>();
+	/** the names of each joint in breadth first order **/
+	public final Array<String> jointNames = new Array<String>();
+	/** names to indices **/
+	public final Map<String, Integer> namesToIndices = new HashMap<String, Integer>();
+	/** the bind pose joints in breadth first order **/
+	public final Array<SkeletonKeyframe> bindPoseJoints = new Array<SkeletonKeyframe>();
+	/** the joints in breadth first order for the last calculates animation pose **/
+	public final Array<SkeletonKeyframe> animPoseJoints = new Array<SkeletonKeyframe>();
+	/** the offset matrices for each joint in the same order as the bindPoseJoints **/
+	public final Array<Matrix4> offsetMatrices = new Array<Matrix4>();
+	/** the scene matrices for each joint in the same order as bindPoseJoints **/
+	public final Array<Matrix4> sceneMatrices = new Array<Matrix4>();
+	/** combined scene and offset matrices **/
+	public final Array<Matrix4> combinedMatrices = new Array<Matrix4>();
+	/** map of animations, indexed by name **/
+	public final ObjectMap<String, SkeletonAnimation> animations = new ObjectMap<String, SkeletonAnimation>();
+
+	private static final Matrix4 IDENTITY = new Matrix4();
+	private final Matrix4 rotMatrix = new Matrix4();
+
+	/** Fills the baseJoints, offsetMatrices and sceneMatrices Array instances with joints and Matrix4 instances in an breadth first
+	 * order. This allows one to iterate over the joint arrays instead of recursing over the hierarchy when calculating the scene
+	 * matrices. */
+	public void buildFromHierarchy () {
+		jointNames.clear();
+		namesToIndices.clear();
+		bindPoseJoints.clear();
+		animPoseJoints.clear();
+		offsetMatrices.clear();
+		sceneMatrices.clear();
+
+		for (int i = 0; i < hierarchy.size; i++) {
+			recursiveFill(hierarchy.get(i));
+		}
+
+		calculateMatrices(bindPoseJoints);
+		calculateOffsetMatrices();
+	}
+
+	private void recursiveFill (SkeletonJoint joint) {
+		joint.index = bindPoseJoints.size;
+		joint.parentIndex = joint.parent != null ? joint.parent.index : -1;
+
+		SkeletonKeyframe keyFrame = new SkeletonKeyframe();
+		keyFrame.position.set(joint.position);
+		keyFrame.scale.set(joint.scale);
+		keyFrame.rotation.set(joint.rotation);
+		keyFrame.parentIndex = joint.parentIndex;
+
+		jointNames.add(joint.name);
+		namesToIndices.put(joint.name, joint.index);
+		bindPoseJoints.add(keyFrame);
+		SkeletonKeyframe animKeyframe = new SkeletonKeyframe();
+		animKeyframe.parentIndex = joint.parentIndex;
+		animPoseJoints.add(animKeyframe);
+		offsetMatrices.add(new Matrix4());
+		sceneMatrices.add(new Matrix4());
+		combinedMatrices.add(new Matrix4());
+
+		int len = joint.children.size;
+		for (int i = 0; i < len; i++) {
+			recursiveFill(joint.children.get(i));
+		}
+	}
+
+	protected void calculateOffsetMatrices () {
+		for (int i = 0; i < offsetMatrices.size; i++) {
+			offsetMatrices.get(i).set(sceneMatrices.get(i)).inv();
+		}
+	}
+
+	protected void calculateMatrices (Array<SkeletonKeyframe> joints) {
+		for (int i = 0; i < joints.size; i++) {
+			SkeletonKeyframe joint = joints.get(i);
+			Matrix4 sceneMatrix = sceneMatrices.get(i);
+			Matrix4 parentMatrix = joint.parentIndex != -1 ? sceneMatrices.get(joint.parentIndex) : IDENTITY;
+			Matrix4 combinedMatrix = combinedMatrices.get(i);
+
+			joint.rotation.toMatrix(rotMatrix.val);
+			rotMatrix.trn(joint.position);
+			rotMatrix.scl(joint.scale);
+			sceneMatrix.set(parentMatrix);
+			sceneMatrix.mul(rotMatrix);
+
+			combinedMatrix.set(sceneMatrix);
+			combinedMatrix.mul(offsetMatrices.get(i));
+		}
+	}
+
+	public void setAnimation (String name, float time) {
+		SkeletonAnimation anim = animations.get(name);
+		if (anim == null) throw new IllegalArgumentException("Animation with name '" + name + "' does not exist");
+		if (time < 0 || time > anim.totalDuration)
+			throw new IllegalArgumentException("time must be 0 <= time <= animation duration");
+
+		int len = anim.perJointkeyFrames.length;
+		for (int i = 0; i < len; i++) {
+			SkeletonKeyframe[] jointTrack = anim.perJointkeyFrames[i];
+			int idx = 0;
+			int len2 = jointTrack.length;
+			for (int j = 0; j < len2; j++) {
+				SkeletonKeyframe jointFrame = jointTrack[j];
+				if (jointFrame.timeStamp >= time) {
+					idx = Math.max(0, j - 1);
+					break;
+				}
+			}
+
+			SkeletonKeyframe startFrame = jointTrack[idx];
+			SkeletonKeyframe endFrame = idx + 1 == len2 ? startFrame : jointTrack[idx + 1];
+			float alpha = 0;
+
+			if (startFrame != endFrame) {
+				alpha = Math.min(1, (time - startFrame.timeStamp) / (endFrame.timeStamp - startFrame.timeStamp));
+			}
+			SkeletonKeyframe animFrame = animPoseJoints.get(i);
+			animFrame.position.set(startFrame.position).lerp(endFrame.position, alpha);
+			animFrame.scale.set(startFrame.scale).lerp(endFrame.scale, alpha);
+			animFrame.rotation.set(startFrame.rotation).slerp(endFrame.rotation, alpha);
+		}
+
+		calculateMatrices(animPoseJoints);
+	}
+
+	public void setBindPose () {
+		calculateMatrices(bindPoseJoints);
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/skeleton/SkeletonAnimation.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/skeleton/SkeletonAnimation.java
new file mode 100644
index 0000000..128f073
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/skeleton/SkeletonAnimation.java
@@ -0,0 +1,28 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.model.skeleton;
+
+import com.badlogic.gdx.graphics.g3d.old.model.Animation;
+
+public class SkeletonAnimation extends Animation {
+	public final SkeletonKeyframe[][] perJointkeyFrames;
+
+	public SkeletonAnimation (String name, float totalDuration, SkeletonKeyframe[][] perJointKeyFrames) {
+		super(name, totalDuration);
+		this.perJointkeyFrames = perJointKeyFrames;
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/skeleton/SkeletonJoint.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/skeleton/SkeletonJoint.java
new file mode 100644
index 0000000..8d79717
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/skeleton/SkeletonJoint.java
@@ -0,0 +1,34 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.model.skeleton;
+
+import com.badlogic.gdx.math.Quaternion;
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.utils.Array;
+
+public class SkeletonJoint {
+	public String name;
+
+	public int index;
+	public int parentIndex;
+	public SkeletonJoint parent;
+	public final Array<SkeletonJoint> children = new Array<SkeletonJoint>(1);
+
+	public final Vector3 position = new Vector3();
+	public final Quaternion rotation = new Quaternion(new Vector3(0, 1, 0), 0);
+	public final Vector3 scale = new Vector3(1, 1, 1);
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/skeleton/SkeletonKeyframe.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/skeleton/SkeletonKeyframe.java
new file mode 100644
index 0000000..fd086c3
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/skeleton/SkeletonKeyframe.java
@@ -0,0 +1,33 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.model.skeleton;
+
+import com.badlogic.gdx.math.Quaternion;
+import com.badlogic.gdx.math.Vector3;
+
+public class SkeletonKeyframe {
+	public float timeStamp = 0;
+	public int parentIndex = -1;
+	public final Vector3 position = new Vector3();
+	public final Vector3 scale = new Vector3(1, 1, 1);
+	public final Quaternion rotation = new Quaternion(0, 0, 0, 1);
+
+	public String toString () {
+		return "time: " + timeStamp + ", " + "parent: " + parentIndex + ", " + "position: " + position + ", " + "scale: " + scale
+			+ ", " + "rotation: " + rotation;
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/skeleton/SkeletonModel.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/skeleton/SkeletonModel.java
new file mode 100644
index 0000000..eafd4b3
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/skeleton/SkeletonModel.java
@@ -0,0 +1,222 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.model.skeleton;
+
+import com.badlogic.gdx.graphics.VertexAttributes.Usage;
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+import com.badlogic.gdx.graphics.g3d.old.model.AnimatedModel;
+import com.badlogic.gdx.graphics.g3d.old.model.Model;
+import com.badlogic.gdx.graphics.g3d.old.model.SubMesh;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.badlogic.gdx.math.Matrix4;
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.math.collision.BoundingBox;
+import com.badlogic.gdx.utils.Array;
+
+public class SkeletonModel implements AnimatedModel {
+	public final Skeleton skeleton;
+	public final SkeletonSubMesh[] subMeshes;
+
+	public SkeletonModel (Skeleton skeleton, SubMesh[] subMeshes) {
+		this.skeleton = skeleton;
+		this.subMeshes = new SkeletonSubMesh[subMeshes.length];
+		
+		for (int i=0; i < subMeshes.length; ++i) {
+			this.subMeshes[i] = (SkeletonSubMesh)subMeshes[i];
+		}
+		setMaterial(new Material("default"));
+	}
+
+	public void setBindPose () {
+		skeleton.setBindPose();
+		for (int i = 0; i < subMeshes.length; i++) {
+			skin(subMeshes[i], skeleton.combinedMatrices);
+		}
+	}
+
+	@Override
+	public void setAnimation (String animation, float time, boolean loop) {
+		skeleton.setAnimation(animation, time);
+		for (int i = 0; i < subMeshes.length; i++) {
+			skin(subMeshes[i], skeleton.combinedMatrices);
+		}
+	}
+
+	final Vector3 v = new Vector3();
+
+	public void skin (SkeletonSubMesh subMesh, Array<Matrix4> boneMatrices) {
+		final int stride = subMesh.mesh.getVertexSize() / 4;
+		final int numVertices = subMesh.mesh.getNumVertices();
+		int idx = 0;
+		int nidx = subMesh.mesh.getVertexAttribute(Usage.Normal) == null ? -1
+			: subMesh.mesh.getVertexAttribute(Usage.Normal).offset / 4;
+		final float[] vertices = subMesh.vertices;
+		final float[] skinnedVertices = subMesh.skinnedVertices;
+
+		System.arraycopy(subMesh.vertices, 0, skinnedVertices, 0, subMesh.vertices.length);
+
+		for (int i = 0; i < numVertices; i++, idx += stride, nidx += stride) {
+			final int[] boneIndices = subMesh.boneAssignments[i];
+			final float[] boneWeights = subMesh.boneWeights[i];
+
+			final float ox = vertices[idx], oy = vertices[idx + 1], oz = vertices[idx + 2];
+			float x = 0, y = 0, z = 0;
+			float onx = 0, ony = 0, onz = 0;
+			float nx = 0, ny = 0, nz = 0;
+
+			if (nidx != -1) {
+				onx = vertices[nidx];
+				ony = vertices[nidx + 1];
+				onz = vertices[nidx + 2];
+			}
+
+			for (int j = 0; j < boneIndices.length; j++) {
+				int boneIndex = boneIndices[j];
+				float weight = boneWeights[j];
+				v.set(ox, oy, oz);
+				v.mul(boneMatrices.get(boneIndex));
+				x += v.x * weight;
+				y += v.y * weight;
+				z += v.z * weight;
+
+				if (nidx != -1) {
+					v.set(onx, ony, onz);
+					v.rot(boneMatrices.get(boneIndex));
+					nx += v.x * weight;
+					ny += v.y * weight;
+					nz += v.z * weight;
+				}
+			}
+
+			skinnedVertices[idx] = x;
+			skinnedVertices[idx + 1] = y;
+			skinnedVertices[idx + 2] = z;
+
+			if (nidx != -1) {
+				skinnedVertices[nidx] = nx;
+				skinnedVertices[nidx + 1] = ny;
+				skinnedVertices[nidx + 2] = nz;
+			}
+		}
+
+		subMesh.mesh.setVertices(skinnedVertices);
+	}
+
+	@Override
+	public void render () {
+		int len = subMeshes.length;
+		for (int i = 0; i < len; i++) {
+			SkeletonSubMesh subMesh = subMeshes[i];
+			if (i == 0) {
+				subMesh.material.bind();
+			} else if (!subMeshes[i - 1].material.equals(subMesh.material)) {
+				subMesh.material.bind();
+			}
+			subMesh.mesh.render(subMesh.primitiveType);
+		}
+	}
+
+	@Override
+	public void render (ShaderProgram program) {
+		int len = subMeshes.length;
+		for (int i = 0; i < len; i++) {
+			SkeletonSubMesh subMesh = subMeshes[i];
+			if (i == 0) {
+				subMesh.material.bind(program);
+			} else if (!subMeshes[i - 1].material.equals(subMesh.material)) {
+				subMesh.material.bind(program);
+			}
+			subMesh.mesh.render(program, subMesh.primitiveType);
+		}
+	}
+
+	@Override
+	public void setMaterials (Material... materials) {
+		if (materials.length != subMeshes.length)
+			throw new UnsupportedOperationException("number of materials must equal number of sub-meshes");
+		int len = materials.length;
+		for (int i = 0; i < len; i++) {
+			subMeshes[i].material = materials[i];
+		}
+	}
+
+	@Override
+	public void setMaterial (Material material) {
+		int len = subMeshes.length;
+		for (int i = 0; i < len; i++) {
+			subMeshes[i].material = material;
+		}
+	}
+
+	@Override
+	public SubMesh getSubMesh (String name) {
+		int len = subMeshes.length;
+		for (int i = 0; i < len; i++) {
+			if (subMeshes[i].name.equals(name)) return subMeshes[i];
+		}
+		return null;
+	}
+
+	@Override
+	public SubMesh[] getSubMeshes () {
+		return subMeshes;
+	}
+
+	@Override
+	public SkeletonAnimation getAnimation (String name) {
+		return skeleton.animations.get(name);
+	}
+
+	// FIXME, ugh...
+	protected SkeletonAnimation[] animations;
+
+	@Override
+	public SkeletonAnimation[] getAnimations () {
+		if (animations == null || animations.length != skeleton.animations.size) {
+			animations = new SkeletonAnimation[skeleton.animations.size];
+			int i = 0;
+			for (SkeletonAnimation anim : skeleton.animations.values()) {
+				animations[i++] = anim;
+			}
+		}
+		return animations;
+	}
+
+	@Override
+	public Model getSubModel (String... subMeshNames) {
+		// FIXME
+		return null;
+	}
+
+	private final static BoundingBox tmpBox = new BoundingBox();
+
+	@Override
+	public void getBoundingBox (BoundingBox bbox) {
+		bbox.inf();
+		for (int i = 0; i < subMeshes.length; i++) {
+			subMeshes[i].mesh.calculateBoundingBox(tmpBox);
+			bbox.ext(tmpBox);
+		}
+	}
+
+	@Override
+	public void dispose () {
+		for (int i = 0; i < subMeshes.length; i++) {
+			subMeshes[i].mesh.dispose();
+		}
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/skeleton/SkeletonModelGpuSkinned.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/skeleton/SkeletonModelGpuSkinned.java
new file mode 100644
index 0000000..bb69893
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/skeleton/SkeletonModelGpuSkinned.java
@@ -0,0 +1,121 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package com.badlogic.gdx.graphics.g3d.old.model.skeleton;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.VertexAttribute;
+import com.badlogic.gdx.graphics.VertexAttributes;
+import com.badlogic.gdx.graphics.VertexAttributes.Usage;
+import com.badlogic.gdx.graphics.g3d.old.model.skeleton.Skeleton;
+import com.badlogic.gdx.graphics.g3d.old.model.skeleton.SkeletonModel;
+import com.badlogic.gdx.graphics.g3d.old.model.skeleton.SkeletonSubMesh;
+
+public class SkeletonModelGpuSkinned extends SkeletonModel {
+	public final static String BoneIndexAttribue = "a_boneIndex";
+	public final static String BoneWeightAttribue = "a_boneWeight";
+
+	public SkeletonModelGpuSkinned(Skeleton skeleton, SkeletonSubMesh[] subMeshes) {
+		super(skeleton,subMeshes);
+	}
+	
+	// Factory Method to create a SkeletonModelGpuSkinned from a SkeletonModel
+	// This will destroy the skeletonModel passed in.
+	public static SkeletonModel CreateFromSkeletonModel(SkeletonModel skeletonModel){
+		if (Gdx.gl20 == null){
+			return skeletonModel;
+		}
+		SkeletonModelGpuSkinned model = new SkeletonModelGpuSkinned(skeletonModel.skeleton, skeletonModel.subMeshes);
+		model.setupGpuSkin();
+		return model;
+	}
+	
+	public void setupGpuSkin(){
+		for (int i = 0; i < subMeshes.length; i++) {
+			setupGpuSkin(subMeshes[i]);
+		}
+	}
+	
+	private void setupGpuSkin(SkeletonSubMesh subMesh){
+		VertexAttributes oldAttributes =  subMesh.mesh.getVertexAttributes();
+		final int oldAttributeCount = oldAttributes.size();
+		VertexAttribute[] attributeArray = new VertexAttribute[oldAttributeCount+2];
+		for(int i=0;i<oldAttributeCount;i++){
+			attributeArray[i] = oldAttributes.get(i);
+		}
+		final int boneIndex = oldAttributeCount;
+		final int weightIndex = oldAttributeCount+1;
+		attributeArray[boneIndex] = new VertexAttribute(Usage.Generic, 4, BoneIndexAttribue);
+		attributeArray[weightIndex] = new VertexAttribute(Usage.Generic, 4, BoneWeightAttribue);
+		VertexAttributes newAttributes = new VertexAttributes(attributeArray);
+		
+		//TODO: not sure if I want to generate a new mesh. But VertexAttributes was final inside mesh
+		Mesh newMesh = new Mesh(true, subMesh.mesh.getMaxVertices(), subMesh.mesh.getMaxIndices(), newAttributes);
+		
+		final int stride = subMesh.mesh.getVertexSize() / 4;
+		final int newStride = newMesh.getVertexSize() / 4;
+		final int numVertices = subMesh.mesh.getNumVertices();
+		int idx = 0;
+		int newIdx = 0;
+		int bidx = -1;
+		int widx = -1;
+		for(int i=0;i<newAttributes.size();i++)
+		{
+			VertexAttribute a = newAttributes.get(i);
+			if(a.alias.equals(BoneIndexAttribue)){
+				bidx = a.offset/4;
+			} else if(a.alias.equals(BoneWeightAttribue)){
+				widx = a.offset/4;
+			}
+		}
+		
+		if(bidx <0 || widx < 0){
+			throw new IllegalArgumentException("Need Shader with bone index and bone wieght vectors to use GPU skinning");
+		}
+		
+		final float[] vertices = subMesh.vertices;
+		final float[] skinnedVertices = new float[newStride * numVertices];
+
+		for (int i = 0; i < numVertices; i++, idx += stride, newIdx += newStride, bidx += newStride, widx += newStride) {
+			final int[] boneIndices = subMesh.boneAssignments[i];
+			final float[] boneWeights = subMesh.boneWeights[i];
+			
+			System.arraycopy(vertices, idx, skinnedVertices, newIdx, stride);
+			
+			skinnedVertices[bidx] = boneIndices.length>0?boneIndices[0]:0;
+			skinnedVertices[bidx + 1] = boneIndices.length>1?boneIndices[1]:0;
+			skinnedVertices[bidx + 2] = boneIndices.length>2?boneIndices[2]:0;
+			skinnedVertices[bidx + 3] = boneIndices.length>3?boneIndices[3]:0;
+			
+			skinnedVertices[widx] = boneWeights.length>0?boneWeights[0]:0;
+			skinnedVertices[widx + 1] = boneWeights.length>1?boneWeights[1]:0;
+			skinnedVertices[widx + 2] = boneWeights.length>2?boneWeights[2]:0;
+			skinnedVertices[widx + 3] = boneWeights.length>3?boneWeights[3]:0;
+		}
+
+		newMesh.setVertices(skinnedVertices);
+		newMesh.setIndices(subMesh.indices);
+		subMesh.mesh.dispose();
+		subMesh.mesh = newMesh;
+		subMesh.skinnedVertices = null;
+		subMesh.vertices = skinnedVertices;
+	}
+	
+	@Override
+	public void setAnimation(String animation, float time, boolean loop) {
+		skeleton.setAnimation(animation, time);
+	}
+}
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/skeleton/SkeletonSubMesh.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/skeleton/SkeletonSubMesh.java
new file mode 100644
index 0000000..4e16328
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/skeleton/SkeletonSubMesh.java
@@ -0,0 +1,49 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.model.skeleton;
+
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.g3d.old.model.SubMesh;
+import com.badlogic.gdx.math.collision.BoundingBox;
+
+public class SkeletonSubMesh extends SubMesh {
+
+	public SkeletonSubMesh (String name, Mesh mesh, int primitiveType) {
+		super(name, mesh, primitiveType);
+	}
+
+	public short[] indices;
+	public float[] vertices;
+	public float[] skinnedVertices;
+
+	public int[][] boneAssignments;
+	public float[][] boneWeights;
+
+	@Override
+	public void getBoundingBox (BoundingBox bbox) {
+		mesh.calculateBoundingBox(bbox);
+	}
+
+	public void setVertices (float[] vertices) {
+		this.vertices = vertices;
+	}
+
+	public void setIndices (short[] indices) {
+		this.indices = indices;
+	}
+
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/still/StillModel.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/still/StillModel.java
new file mode 100644
index 0000000..eecdb5a
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/still/StillModel.java
@@ -0,0 +1,123 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.model.still;
+
+import java.util.ArrayList;
+
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+import com.badlogic.gdx.graphics.g3d.old.model.Model;
+import com.badlogic.gdx.graphics.g3d.old.model.SubMesh;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.badlogic.gdx.math.collision.BoundingBox;
+
+public class StillModel implements Model {
+	final public StillSubMesh[] subMeshes;
+
+	public StillModel (SubMesh... subMeshes) {
+		this.subMeshes = new StillSubMesh[subMeshes.length];
+		for (int i = 0; i < subMeshes.length ; ++i) {
+			this.subMeshes[i] = (StillSubMesh)subMeshes[i];
+		}	
+	}
+
+	@Override
+	public void render () {
+		int len = subMeshes.length;
+		for (int i = 0; i < len; i++) {
+			StillSubMesh subMesh = subMeshes[i];
+			if (i == 0) {
+				subMesh.material.bind();
+			} else if (!subMeshes[i - 1].material.equals(subMesh.material)) {
+				subMesh.material.bind();
+			}
+			subMesh.mesh.render(subMesh.primitiveType);
+		}
+	}
+
+	@Override
+	public void render (ShaderProgram program) {
+		int len = subMeshes.length;
+		for (int i = 0; i < len; i++) {
+			StillSubMesh subMesh = subMeshes[i];
+			if (i == 0) {
+				subMesh.material.bind(program);
+			} else if (!subMeshes[i - 1].material.equals(subMesh.material)) {
+				subMesh.material.bind(program);
+			}
+			subMesh.mesh.render(program, subMesh.primitiveType);
+		}
+	}
+
+	@Override
+	public Model getSubModel (String... subMeshNames) {
+		ArrayList<SubMesh> subMeshes = new ArrayList<SubMesh>();
+		for (String name : subMeshNames)
+			for (StillSubMesh subMesh : this.subMeshes)
+				if (name.equals(subMesh.name)) subMeshes.add(subMesh);
+		if (subMeshes.size() > 0) return new StillModel(subMeshes.toArray(new StillSubMesh[subMeshes.size()]));
+		return null;
+	}
+
+	@Override
+	public StillSubMesh getSubMesh (String name) {
+		for (StillSubMesh subMesh : subMeshes) {
+			if (subMesh.name.equals(name)) return subMesh;
+		}
+		return null;
+	}
+
+	@Override
+	public SubMesh[] getSubMeshes () {
+		return subMeshes;
+	}
+
+	@Override
+	public void setMaterials (Material... materials) {
+		if (materials.length != subMeshes.length)
+			throw new UnsupportedOperationException("number of materials must equal number of sub-meshes");
+		int len = materials.length;
+		for (int i = 0; i < len; i++) {
+			subMeshes[i].material = materials[i];
+		}
+	}
+
+	@Override
+	public void setMaterial (Material material) {
+		int len = subMeshes.length;
+		for (int i = 0; i < len; i++) {
+			subMeshes[i].material = material;
+		}
+	}
+
+	private final static BoundingBox tmpBox = new BoundingBox();
+
+	@Override
+	public void getBoundingBox (BoundingBox bbox) {
+		bbox.inf();
+		for (int i = 0; i < subMeshes.length; i++) {
+			subMeshes[i].mesh.calculateBoundingBox(tmpBox);
+			bbox.ext(tmpBox);
+		}
+	}
+
+	@Override
+	public void dispose () {
+		for (int i = 0; i < subMeshes.length; i++) {
+			subMeshes[i].mesh.dispose();
+		}
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/still/StillSubMesh.java b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/still/StillSubMesh.java
new file mode 100644
index 0000000..7bc25d1
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/old/model/still/StillSubMesh.java
@@ -0,0 +1,39 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.old.model.still;
+
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+import com.badlogic.gdx.graphics.g3d.old.model.SubMesh;
+import com.badlogic.gdx.math.collision.BoundingBox;
+
+public class StillSubMesh extends SubMesh {
+
+	public StillSubMesh (String name, Mesh mesh, int primitiveType, Material material) {
+		super(name, mesh, primitiveType, material);
+	}
+	
+	public StillSubMesh (String name, Mesh mesh, int primitiveType) {
+		super(name, mesh, primitiveType);
+	}
+
+	@Override
+	public void getBoundingBox (BoundingBox bbox) {
+		mesh.calculateBoundingBox(bbox);
+	}
+
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/test/InterimModel.java b/gdx/src/com/badlogic/gdx/graphics/g3d/test/InterimModel.java
new file mode 100644
index 0000000..c57499c
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/test/InterimModel.java
@@ -0,0 +1,71 @@
+package com.badlogic.gdx.graphics.g3d.test;
+
+import com.badlogic.gdx.graphics.g3d.RenderInstance;
+import com.badlogic.gdx.graphics.g3d.Renderable;
+import com.badlogic.gdx.graphics.g3d.materials.BlendingAttribute;
+import com.badlogic.gdx.graphics.g3d.materials.ColorAttribute;
+import com.badlogic.gdx.graphics.g3d.materials.NewMaterial;
+import com.badlogic.gdx.graphics.g3d.materials.TextureAttribute;
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+import com.badlogic.gdx.graphics.g3d.old.materials.MaterialAttribute;
+import com.badlogic.gdx.graphics.g3d.old.model.Model;
+import com.badlogic.gdx.graphics.g3d.old.model.SubMesh;
+import com.badlogic.gdx.graphics.g3d.utils.TextureDescription;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+public class InterimModel implements NewModel {
+	public final Array<Renderable> parts;
+	
+	public final static NewMaterial convertMaterial(final Material mtl) {
+		NewMaterial result = new NewMaterial();
+		for (MaterialAttribute attr : mtl) {
+			if (attr instanceof com.badlogic.gdx.graphics.g3d.old.materials.BlendingAttribute) {
+				com.badlogic.gdx.graphics.g3d.old.materials.BlendingAttribute a = (com.badlogic.gdx.graphics.g3d.old.materials.BlendingAttribute)attr;
+				result.add(new BlendingAttribute(a.blendSrcFunc, a.blendDstFunc));
+			} else if (attr instanceof com.badlogic.gdx.graphics.g3d.old.materials.ColorAttribute) {
+				com.badlogic.gdx.graphics.g3d.old.materials.ColorAttribute a = (com.badlogic.gdx.graphics.g3d.old.materials.ColorAttribute)attr;
+				if (a.name.compareTo(com.badlogic.gdx.graphics.g3d.old.materials.ColorAttribute.specular)==0)
+					result.add(ColorAttribute.createSpecular(a.color));
+				else
+					result.add(ColorAttribute.createDiffuse(a.color));
+			} else if (attr instanceof com.badlogic.gdx.graphics.g3d.old.materials.TextureAttribute) {
+				com.badlogic.gdx.graphics.g3d.old.materials.TextureAttribute a = (com.badlogic.gdx.graphics.g3d.old.materials.TextureAttribute)attr;
+				final TextureDescription tex = new TextureDescription(a.texture, a.minFilter, a.magFilter, a.uWrap, a.vWrap);
+				if (a.name.compareTo(com.badlogic.gdx.graphics.g3d.old.materials.TextureAttribute.specularTexture)==0)
+					result.add(new TextureAttribute(TextureAttribute.Specular, tex));
+				else // if (a.name.compareTo(com.badlogic.gdx.graphics.g3d.materials.TextureAttribute.diffuseTexture)==0)
+					result.add(new TextureAttribute(TextureAttribute.Diffuse, tex));
+				// else unknown texture attribute
+			} // else throw new GdxRuntimeException("Unkown material attribute");
+		}
+		return result;
+	}
+	
+	public InterimModel(final Model model) {
+		SubMesh[] meshes = model.getSubMeshes();
+		parts = new Array<Renderable>(meshes.length);
+		for (int i = 0; i < meshes.length; i++) {
+			final Renderable inst = new Renderable();
+			inst.mesh = meshes[i].mesh;
+			inst.meshPartOffset = 0;
+			inst.meshPartSize = meshes[i].mesh.getMaxIndices() > 0 ? meshes[i].mesh.getNumIndices() : meshes[i].mesh.getNumVertices();
+			inst.primitiveType = meshes[i].primitiveType;
+			inst.material = convertMaterial(meshes[i].material);
+			parts.add(inst);
+		}
+	}
+	
+	public InterimModel(final Renderable... parts) {
+		this.parts = new Array<Renderable>(parts);
+	}
+	
+	public InterimModel(final Array<Renderable> parts) {
+		this.parts = new Array<Renderable>(parts);
+	}
+
+	@Override
+	public Iterable<Renderable> getParts (float distance) {
+		return parts;
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/test/Light.java b/gdx/src/com/badlogic/gdx/graphics/g3d/test/Light.java
new file mode 100644
index 0000000..780386d
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/test/Light.java
@@ -0,0 +1,35 @@
+package com.badlogic.gdx.graphics.g3d.test;
+
+import com.badlogic.gdx.graphics.Color;
+import com.badlogic.gdx.math.Vector3;
+
+public class Light {
+	public final Color color = new Color();
+	public final Vector3 position = new Vector3();
+	public float power = 1f;
+	
+	public Light(final Color color, final Vector3 position, final float power) {
+		this(color.r, color.g, color.b, color.a, position.x, position.y, position.z, power);
+	}
+	
+	public Light(final float red, final float green, final float blue, final float alpha, 
+					final float x, final float y, final float z, final float power) {
+		color.set(red, green, blue, alpha);
+		position.set(x, y, z);
+		this.power = power;
+	}
+	
+	public boolean equals(Light other) {
+		if (other == null) return false;
+		if (other == this) return true;
+		return color.equals(other.color) && position.equals(other.position) && power == other.power;
+	}
+	
+	@Override
+	public boolean equals (Object arg0) {
+		if (arg0 == null) return false;
+		if (arg0 == this) return true;
+		if (!(arg0 instanceof Light)) return false;
+		return equals((Light)arg0);
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/test/NewModel.java b/gdx/src/com/badlogic/gdx/graphics/g3d/test/NewModel.java
new file mode 100644
index 0000000..b60f768
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/test/NewModel.java
@@ -0,0 +1,8 @@
+package com.badlogic.gdx.graphics.g3d.test;
+
+import com.badlogic.gdx.graphics.g3d.RenderInstance;
+import com.badlogic.gdx.graphics.g3d.Renderable;
+
+public interface NewModel {
+	Iterable<Renderable> getParts(float distance);
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/test/OldBatchRenderer.java b/gdx/src/com/badlogic/gdx/graphics/g3d/test/OldBatchRenderer.java
new file mode 100644
index 0000000..fc00bde
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/test/OldBatchRenderer.java
@@ -0,0 +1,13 @@
+package com.badlogic.gdx.graphics.g3d.test;
+
+import java.util.Comparator;
+
+import com.badlogic.gdx.graphics.Camera;
+import com.badlogic.gdx.graphics.g3d.RenderInstance;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.badlogic.gdx.utils.Array;
+
+public interface OldBatchRenderer extends Comparator<RenderInstance> {
+	ShaderProgram getShader(RenderInstance instance);
+	void render(Camera camera, Array<RenderInstance> instances /*, Array<Light> lights*/);
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/test/OldBatchRendererGLES11.java b/gdx/src/com/badlogic/gdx/graphics/g3d/test/OldBatchRendererGLES11.java
new file mode 100644
index 0000000..78534b3
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/test/OldBatchRendererGLES11.java
@@ -0,0 +1,149 @@
+package com.badlogic.gdx.graphics.g3d.test;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.Camera;
+import com.badlogic.gdx.graphics.GL10;
+import com.badlogic.gdx.graphics.GL11;
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.VertexAttribute;
+import com.badlogic.gdx.graphics.VertexAttributes.Usage;
+import com.badlogic.gdx.graphics.g3d.RenderInstance;
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+import com.badlogic.gdx.graphics.g3d.old.materials.MaterialAttribute;
+import com.badlogic.gdx.graphics.g3d.old.materials.TextureAttribute;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.badlogic.gdx.utils.Array;
+
+public class OldBatchRendererGLES11 implements OldBatchRenderer {
+	final float[] lightColor = {1, 1, 1, 0};
+	final float[] lightPosition = {2, 5, 10, 0};
+
+	public final int textureUnitOffset = 3;
+	public final int textureCount;
+	final Texture[] textures;
+	final int[] textureWeights;
+	public int bindCount = 0;
+	public int reuseCount = 0;
+	
+	public OldBatchRendererGLES11() {
+		textureCount = Math.min(GL10.GL_MAX_TEXTURE_UNITS, 16) - textureUnitOffset;
+		textures = new Texture[textureCount];
+		textureWeights = new int[textureCount];
+	}
+	
+	@Override
+	public int compare (RenderInstance o1, RenderInstance o2) {
+		return o1.distance > o2.distance ? 1 : (o1.distance < o2.distance ? -1 : 0);
+	}
+
+	@Override
+	public ShaderProgram getShader (RenderInstance instance) {
+		return null;
+	}
+	
+	Material currentMaterial;
+	boolean useTexture;
+	int currentTexture; // for now only allow one textureattribute to be used at a time
+	private final void setMaterial(final GL11 gl, final Material mat) {
+		if (mat == currentMaterial) 
+			return;
+		
+		final boolean hasTex = mat.hasTexture();
+		
+		if (useTexture != hasTex || currentMaterial == null) {
+			useTexture = hasTex;
+			if (hasTex)
+				gl.glEnable(GL11.GL_TEXTURE_2D);
+			else
+				gl.glDisable(GL11.GL_TEXTURE_2D);
+		}
+		
+		currentMaterial = mat;
+		for (MaterialAttribute attr : currentMaterial) {
+			if (attr instanceof TextureAttribute)
+				bindTextureAttribute(gl, (TextureAttribute)attr);
+			else
+				attr.bind();
+		}
+	}
+
+	private final void bindTextureAttribute(final GL11 gl, final TextureAttribute attribute) {
+		currentTexture = bindTexture(gl, attribute.texture);
+		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER, attribute.minFilter);
+		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER, attribute.magFilter);
+		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_S, attribute.uWrap);
+		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_T, attribute.vWrap);
+	}
+	
+	private final int bindTexture(final GL11 gl, final Texture texture) {
+		int result = -1;
+		int weight = textureWeights[0];
+		int windex = 0;
+		for (int i = 0; i < textureCount; i++) {
+			if (textures[i] == texture) {
+				result = i;
+				textureWeights[i]++;
+			} else if (--textureWeights[i] < weight || textureWeights[i] < 0) {
+				weight = textureWeights[i];
+				windex = i;
+			}
+		}
+		if (result < 0) {
+			textures[windex] = texture;
+			textureWeights[windex] = 100;
+			result = windex;
+			texture.bind(textureUnitOffset + windex);
+			bindCount++;
+		} else
+			reuseCount++;
+		return textureUnitOffset + result;
+	}
+	
+	Mesh currentMesh;
+	@Override
+	public void render (Camera camera, Array<RenderInstance> instances) {
+		final GL11 gl = Gdx.gl11;
+		gl.glViewport(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
+		gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
+		gl.glEnable(GL10.GL_DEPTH_TEST);
+		gl.glEnable(GL10.GL_LIGHTING);
+		gl.glEnable(GL10.GL_COLOR_MATERIAL);
+		gl.glEnable(GL10.GL_TEXTURE_2D);
+
+		gl.glEnable(GL10.GL_LIGHT0);
+		gl.glLightfv(GL10.GL_LIGHT0, GL10.GL_DIFFUSE, lightColor, 0);
+		gl.glLightfv(GL10.GL_LIGHT0, GL10.GL_POSITION, lightPosition, 0);
+
+		camera.apply(gl);
+		currentMaterial = null;
+		gl.glDisable(GL10.GL_TEXTURE_2D);
+		
+		for (int i = 0; i < textureCount; i++) {
+			textureWeights[i] = 0;
+			textures[i] = null;
+		}
+
+		for (int i = 0; i < instances.size; i++) {
+			final RenderInstance instance = instances.get(i);
+			// setMaterial(gl, instance.material);
+			//if (instance.mesh != currentMesh) { // uncomment for GLES20
+				if (currentMesh != null)
+					currentMesh.unbind();
+				currentMesh = instance.renderable.mesh;
+				VertexAttribute a = currentMesh.getVertexAttribute(Usage.TextureCoordinates);
+				if (a != null)
+					a.alias = ShaderProgram.TEXCOORD_ATTRIBUTE + currentTexture;
+				currentMesh.bind();
+			//}
+			gl.glPushMatrix();
+			gl.glMultMatrixf(instance.transform.val, 0);
+			instance.renderable.mesh.render(instance.renderable.primitiveType);
+			gl.glPopMatrix();
+		}
+		if (currentMesh != null) {
+			currentMesh.unbind();
+			currentMesh = null;
+		}
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/test/OldBatchRendererGLES20.java b/gdx/src/com/badlogic/gdx/graphics/g3d/test/OldBatchRendererGLES20.java
new file mode 100644
index 0000000..2dd5ff2
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/test/OldBatchRendererGLES20.java
@@ -0,0 +1,169 @@
+package com.badlogic.gdx.graphics.g3d.test;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.Camera;
+import com.badlogic.gdx.graphics.GL10;
+import com.badlogic.gdx.graphics.GL11;
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.g3d.RenderInstance;
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+import com.badlogic.gdx.graphics.g3d.old.materials.MaterialAttribute;
+import com.badlogic.gdx.graphics.g3d.old.materials.TextureAttribute;
+import com.badlogic.gdx.graphics.g3d.utils.ExclusiveTextures;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.badlogic.gdx.math.Matrix4;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+public class OldBatchRendererGLES20 implements OldBatchRenderer {
+	public final static String PROJECTION_TRANSFORM = "u_projTrans";
+	public final static String MODEL_TRANSFORM = "u_modelTrans";
+	
+	public final static String DEFAULT_VERTEX_SHADER = 
+			"attribute vec3 " + ShaderProgram.POSITION_ATTRIBUTE + ";" +
+			"attribute vec2 " + ShaderProgram.TEXCOORD_ATTRIBUTE + "0;" +
+			"uniform mat4 " + PROJECTION_TRANSFORM + ";" +
+			"uniform mat4 " + MODEL_TRANSFORM + ";" +
+			"varying vec2 v_texCoords;" +
+			"void main() {"+
+			"	v_texCoords = " + ShaderProgram.TEXCOORD_ATTRIBUTE + "0;" +
+			"	gl_Position = " + PROJECTION_TRANSFORM + " * (" + MODEL_TRANSFORM + " * vec4(" + ShaderProgram.POSITION_ATTRIBUTE + ", 1.0));" +
+			"}";
+	
+	public final static String DEFAULT_FRAGMENT_SHADER = 
+			"#ifdef GL_ES\n" + 
+			"#define LOWP lowp\n" +
+			"#define MED mediump\n" +
+			"#define HIGH highp\n" +
+			"precision mediump float;\n" +
+			"#else\n" +
+			"#define MED\n" +
+			"#define LOWP\n" +
+			"#endif\n" + 
+			"uniform sampler2D " + TextureAttribute.diffuseTexture + ";" +
+			"varying MED vec2 v_texCoords;" +
+			"void main() {" +
+			"	gl_FragColor = texture2D(" + TextureAttribute.diffuseTexture + ", v_texCoords);" +
+			"}";
+	
+	public final ShaderProgram defaultShader;
+		
+	protected ExclusiveTextures textures;
+	
+	public OldBatchRendererGLES20(final ExclusiveTextures textures) {
+		this.textures = textures;
+		defaultShader = new ShaderProgram(DEFAULT_VERTEX_SHADER, DEFAULT_FRAGMENT_SHADER);
+		if (!defaultShader.isCompiled())
+			throw new GdxRuntimeException(defaultShader.getLog());
+		
+	}
+	
+	@Override
+	public int compare (RenderInstance arg0, RenderInstance arg1) {
+		// TODO
+		return arg0.distance > arg1.distance ? 1 : (arg0.distance < arg1.distance ? -1 : 0);
+	}
+
+	@Override
+	public ShaderProgram getShader (RenderInstance instance) {
+		// TODO
+		return defaultShader;
+	}
+	
+	@Override
+	public void render (final Camera camera, final Array<RenderInstance> instances) {
+		// breakdown this method into smaller inline pieces for easy testing
+		final GL20 gl = Gdx.gl20;
+		begin(gl, camera);
+		for (int i = 0; i < instances.size; i++) {
+			final RenderInstance instance = instances.get(i);
+			bindShader(gl, camera, instance);
+			bindMaterial(gl, camera, instance);
+			renderMesh(gl, camera, instance);
+		}
+		end(gl);
+	}
+	
+	/////// bindShader /////////
+	private ShaderProgram currentShader;
+	private ShaderProgram previousShader;
+	private boolean shaderChanged;
+	private final void bindShader(final GL20 gl, final Camera camera, final RenderInstance instance) {
+		shaderChanged = instance.shader != currentShader;
+		if (!shaderChanged)
+			return;
+		if (currentShader != null)
+			currentShader.end();
+		previousShader = currentShader;
+		//currentShader = instance.shader;
+		currentShader.begin();
+		
+		currentShader.setUniformMatrix(PROJECTION_TRANSFORM, camera.combined);
+	}
+
+	/////// bindMaterial /////////
+	Material currentMaterial;
+	private final void bindMaterial(final GL20 gl, final Camera camera, final RenderInstance instance) {
+		/*if (currentMaterial == instance.material)
+			return;
+		currentMaterial = instance.material;
+		for (MaterialAttribute attr : currentMaterial) {
+			if (attr instanceof TextureAttribute)
+				bindTextureAttribute(gl, (TextureAttribute)attr);
+			else
+				attr.bind(currentShader);
+		}*/
+	}
+
+	/////// bindTextureAttribute /////////
+	TextureAttribute currentTextureAttribute;
+	int unittmp = 0;
+	private final void bindTextureAttribute(final GL20 gl, final TextureAttribute attribute) {
+		if (attribute == currentTextureAttribute && !shaderChanged)
+			return;
+		final int unit = textures.bindTexture(attribute.texture);
+		attribute.texture.bind(unit);
+		gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER, attribute.minFilter);
+		gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER, attribute.magFilter);
+		gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_S, attribute.uWrap);
+		gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_T, attribute.vWrap);
+		currentShader.setUniformi(TextureAttribute.diffuseTexture, unit);
+		currentTextureAttribute = attribute;
+	}
+
+	/////// renderMesh /////////
+	private Mesh currentMesh;
+	private Matrix4 currentTransform;
+	private final void renderMesh(final GL20 gl, final Camera camera, final RenderInstance instance) {
+		if (currentMesh != instance.renderable.mesh || shaderChanged) {
+			if (currentMesh != null)
+				currentMesh.unbind(shaderChanged ? previousShader : currentShader);
+			(currentMesh = instance.renderable.mesh).bind(currentShader);
+		}
+		if (currentTransform != instance.transform || shaderChanged)
+			currentShader.setUniformMatrix(MODEL_TRANSFORM, currentTransform = instance.transform);
+		instance.renderable.mesh.render(currentShader, instance.renderable.primitiveType);
+	}
+
+	/////// begin /////////
+	private final void begin(final GL20 gl, final Camera camera) {
+		Gdx.gl.glEnable(GL10.GL_DEPTH_TEST);
+		Gdx.gl.glDepthFunc(GL10.GL_LEQUAL);
+		Gdx.gl.glEnable(GL10.GL_BLEND);
+		Gdx.gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
+	}
+
+	/////// end /////////
+	private final void end(final GL20 gl) {
+		if (currentMesh != null) {
+			currentMesh.unbind(currentShader);
+			currentMesh = null;
+		}
+		if (currentShader != null) {
+			currentShader.end();
+			currentShader = null;
+		}
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/test/TestShader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/test/TestShader.java
new file mode 100644
index 0000000..bbd5274
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/test/TestShader.java
@@ -0,0 +1,252 @@
+package com.badlogic.gdx.graphics.g3d.test;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.Camera;
+import com.badlogic.gdx.graphics.GL10;
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.g3d.RenderContext;
+import com.badlogic.gdx.graphics.g3d.RenderInstance;
+import com.badlogic.gdx.graphics.g3d.Renderable;
+import com.badlogic.gdx.graphics.g3d.Shader;
+import com.badlogic.gdx.graphics.g3d.materials.BlendingAttribute;
+import com.badlogic.gdx.graphics.g3d.materials.ColorAttribute;
+import com.badlogic.gdx.graphics.g3d.materials.NewMaterial;
+import com.badlogic.gdx.graphics.g3d.materials.TextureAttribute;
+import com.badlogic.gdx.graphics.g3d.utils.ExclusiveTextures;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.badlogic.gdx.math.Matrix3;
+import com.badlogic.gdx.math.Matrix4;
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+public class TestShader implements Shader {
+	public final static String PROJECTION_TRANSFORM = "u_projTrans";
+	public final static String MODEL_TRANSFORM = "u_modelTrans";
+	public final static String NORMAL_TRANSFORM = "u_normalMatrix";
+	
+	private static String defaultVertexShader = null;
+	public final static String getDefaultVertexShader() {
+		if (defaultVertexShader == null)
+			defaultVertexShader = Gdx.files.classpath("com/badlogic/gdx/graphics/g3d/test/test.vertex.glsl").readString();
+		return defaultVertexShader;
+	}
+	
+	private static String defaultFragmentShader = null;
+	public final static String getDefaultFragmentShader() {
+		if (defaultFragmentShader == null)
+			defaultFragmentShader = Gdx.files.classpath("com/badlogic/gdx/graphics/g3d/test/test.fragment.glsl").readString();
+		return defaultFragmentShader;
+	}
+
+	protected static long implementedFlags = BlendingAttribute.Type | TextureAttribute.Diffuse | ColorAttribute.Diffuse;
+	protected static boolean ignoreUnimplemented = false;
+	
+	protected final ShaderProgram program;
+	protected int projTransLoc;
+	protected int modelTransLoc;
+	protected int normalTransLoc;
+	protected int diffuseTextureLoc;
+	protected int diffuseColorLoc;
+	protected int lightsCount = 5;
+	protected int lightsLoc;
+	protected int lightSize;
+	protected int lightPositionOffset;
+	protected int lightPowerOffset;
+	
+	private Light[] currentLights = new Light[lightsCount];
+	
+	protected RenderContext context;
+	protected long mask;
+	
+	public TestShader(final NewMaterial material) {
+		this(getDefaultVertexShader(), getDefaultFragmentShader(), material);
+	}
+	
+	public TestShader(final long mask) {
+		this(getDefaultVertexShader(), getDefaultFragmentShader(), mask);
+	}
+
+	public TestShader(final String vertexShader, final String fragmentShader, final NewMaterial material) {
+		this(vertexShader, fragmentShader, material.getMask());
+	}
+	
+	public TestShader(final String vertexShader, final String fragmentShader, final long mask) {
+		String prefix = "";
+		this.mask = mask;
+		
+		if (!ignoreUnimplemented && (implementedFlags & mask) != mask)
+			throw new GdxRuntimeException("Some attributes not implemented yet ("+mask+")");
+		
+		if (lightsCount > 0)
+			prefix += "#define lightsCount "+lightsCount+"\n";
+		if ((mask & BlendingAttribute.Type) == BlendingAttribute.Type)
+			prefix += "#define "+BlendingAttribute.Alias+"Flag\n";
+		if ((mask & TextureAttribute.Diffuse) == TextureAttribute.Diffuse)
+			prefix += "#define "+TextureAttribute.DiffuseAlias+"Flag\n";
+		if ((mask & ColorAttribute.Diffuse) == ColorAttribute.Diffuse)
+			prefix += "#define "+ColorAttribute.DiffuseAlias+"Flag\n";
+		
+		program = new ShaderProgram(prefix + vertexShader, prefix + fragmentShader);
+		if (!program.isCompiled())
+			throw new GdxRuntimeException(program.getLog());
+		
+		projTransLoc = program.getUniformLocation(PROJECTION_TRANSFORM);
+		modelTransLoc = program.getUniformLocation(MODEL_TRANSFORM);
+		normalTransLoc = program.getUniformLocation(NORMAL_TRANSFORM);
+		diffuseTextureLoc = ((mask & TextureAttribute.Diffuse) != TextureAttribute.Diffuse) ? -1 : program.getUniformLocation(TextureAttribute.DiffuseAlias);
+		diffuseColorLoc = ((mask & ColorAttribute.Diffuse) != ColorAttribute.Diffuse) ? -1 : program.getUniformLocation(ColorAttribute.DiffuseAlias);
+		lightsLoc = lightsCount > 0 ? program.getUniformLocation("lights[0].color") : -1;
+		lightSize = (lightsLoc >= 0 && lightsCount > 1) ? (program.getUniformLocation("lights[1].color") - lightsLoc) : -1;
+		lightPositionOffset = lightsLoc >= 0 ? program.getUniformLocation("lights[0].position") - lightsLoc : -1;
+		lightPowerOffset = lightsLoc >= 0 ? program.getUniformLocation("lights[0].power") - lightsLoc : -1;
+	}
+	
+	@Override
+	public boolean canRender(final RenderInstance instance) {
+		return mask == instance.renderable.material.getMask();
+	}
+	
+	/*@Override
+	public int compareTo (final Object other) {
+		return (other instanceof RenderShader) ? compareTo((RenderShader)other) : -1;
+	}*/
+	
+	@Override
+	public int compareTo(Shader other) {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+	
+	@Override
+	public boolean equals (Object obj) {
+		return (obj instanceof TestShader) ? equals((TestShader)obj) : false;
+	}
+	
+	public boolean equals (TestShader obj) {
+		return (obj == this);
+	}
+	
+	@Override
+	public int compare (final RenderInstance arg0, final RenderInstance arg1) {
+		final boolean b1 = arg0.renderable.material.has(BlendingAttribute.Type);
+		final boolean b2 = arg1.renderable.material.has(BlendingAttribute.Type);
+		if (b1 != b2) return b1 ? 1 : -1;
+		return arg0.distance > arg1.distance ? (b1 ? -1 : 1) : (arg0.distance < arg1.distance ? (b1 ? 1 : -1) : 0);
+	}
+
+	private Mesh currentMesh;
+	private Matrix4 currentTransform;
+	private Matrix3 normalMatrix = new Matrix3();
+	private Camera camera;
+	
+	@Override
+	public void begin (final Camera camera, final RenderContext context) {
+		this.context = context;
+		this.camera = camera;
+		program.begin();
+		context.setDepthTest(true, GL10.GL_LEQUAL);
+		program.setUniformMatrix(projTransLoc, camera.combined);
+		for (int i = 0; i < currentLights.length; i++)
+			currentLights[i] = null;
+	}
+
+	@Override
+	public void render (NewModel model, Matrix4 transform, final Light[] lights) {
+		transform.getTranslation(Vector3.tmp);
+		float dist = Vector3.tmp2.set(Vector3.tmp.x - camera.position.x, Vector3.tmp.y - camera.position.y , Vector3.tmp.z - camera.position.z).len();
+		if (Vector3.tmp2.div(dist).dot(camera.direction) < 0)
+			dist = -dist;
+		for (Renderable renderable : model.getParts(dist)) {
+			final RenderInstance instance = RenderInstance.pool.obtain(renderable, transform, dist, lights, null);
+			render(instance);
+			RenderInstance.pool.free(instance);
+		}
+	}
+	
+	@Override
+	public void render (final RenderInstance instance) {
+		if (!instance.renderable.material.has(BlendingAttribute.Type))
+			context.setBlending(false, GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
+		if (currentTransform != instance.transform) {
+			program.setUniformMatrix(modelTransLoc, currentTransform = instance.transform);
+			program.setUniformMatrix(normalTransLoc, normalMatrix.set(currentTransform));
+		}
+		bindMaterial(instance);
+		if (lightsLoc >= 0)
+			bindLights(instance);
+		if (currentMesh != instance.renderable.mesh) {
+			if (currentMesh != null)
+				currentMesh.unbind(program);
+			(currentMesh = instance.renderable.mesh).bind(program);
+		}
+		instance.renderable.mesh.render(program, instance.renderable.primitiveType, instance.renderable.meshPartOffset, instance.renderable.meshPartSize);
+	}
+
+	@Override
+	public void end () {
+		if (currentMesh != null) {
+			currentMesh.unbind(program);
+			currentMesh = null;
+		}
+		currentTransform = null;
+		currentTextureAttribute = null;
+		currentMaterial = null;
+		program.end();
+	}
+	
+	/////// bindMaterial /////////
+	NewMaterial currentMaterial;
+	private final void bindMaterial(final RenderInstance instance) {
+		if (currentMaterial == instance.renderable.material)
+			return;
+		currentMaterial = instance.renderable.material;
+		for (NewMaterial.Attribute attr : currentMaterial) {
+			long t = attr.getType();
+			if (BlendingAttribute.is(t))
+				context.setBlending(true, ((BlendingAttribute)attr).sourceFunction, ((BlendingAttribute)attr).destFunction);
+			else if (ColorAttribute.is(t)) {
+				ColorAttribute col = (ColorAttribute)attr;
+				if ((t & ColorAttribute.Diffuse) == ColorAttribute.Diffuse)
+					program.setUniformf(diffuseColorLoc, col.color);
+				// TODO else if (..)
+			}
+			else if (TextureAttribute.is(t)) {
+				TextureAttribute tex = (TextureAttribute)attr;
+				if ((t & TextureAttribute.Diffuse) == TextureAttribute.Diffuse)
+					bindTextureAttribute(diffuseTextureLoc, tex);
+				// TODO else if (..)
+			}  
+			else 
+				throw new GdxRuntimeException("unknown attribute");
+		}
+	}
+
+	/////// bindTextureAttribute /////////
+	TextureAttribute currentTextureAttribute;
+	private final void bindTextureAttribute(final int uniform, final TextureAttribute attribute) {
+		final int unit = context.textures.bindTexture(attribute.textureDescription);
+		program.setUniformi(uniform, unit);
+		currentTextureAttribute = attribute;
+	}
+	 
+	private final void bindLights(final RenderInstance instance) {
+		for (int i = 0; i < lightsCount; i++) {
+			final int loc = lightsLoc + i * lightSize;
+			if (instance.lights.length <= i) {
+				if (currentLights[i] != null) {
+					program.setUniformf(loc + lightPowerOffset, 0f);
+					currentLights[i] = null;
+				}
+			}
+			else {
+				if (currentLights[i] != instance.lights[i]) {
+					program.setUniformf(loc, instance.lights[i].color);
+					program.setUniformf(loc + lightPositionOffset, instance.lights[i].position);
+					program.setUniformf(loc + lightPowerOffset, instance.lights[i].power);
+					currentLights[i] = instance.lights[i];
+				}
+			}
+		}
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/test/test.fragment.glsl b/gdx/src/com/badlogic/gdx/graphics/g3d/test/test.fragment.glsl
new file mode 100644
index 0000000..c983060
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/test/test.fragment.glsl
@@ -0,0 +1,74 @@
+#ifdef GL_ES 
+#define LOWP lowp
+#define MED mediump
+#define HIGH highp
+precision mediump float;
+#else
+#define MED
+#define LOWP
+#endif
+
+varying vec3 v_normal;
+
+#if defined(diffuseTextureFlag) || defined(specularTextureFlag)
+varying MED vec2 v_texCoords0;
+#endif
+
+#ifdef diffuseColorFlag
+uniform vec4 diffuseColor;
+#endif
+
+#ifdef diffuseTextureFlag
+uniform sampler2D diffuseTexture;
+#endif
+
+#ifdef specularColorFlag
+uniform vec4 specularColor;
+#endif
+
+#ifdef specularTextureFlag
+uniform sampler2D specularTexture;
+#endif
+
+#if defined(lightsCount)
+#if (lightsCount > 0)
+#define NUM_LIGHTS lightsCount
+struct Light
+{
+	vec4 color;
+	vec3 position;
+	float power;
+};
+uniform Light lights[NUM_LIGHTS];
+
+varying vec3 v_lightLambert;
+#endif
+#endif
+
+void main() {
+	#if defined(diffuseTextureFlag) && defined(diffuseColorFlag)
+		vec4 diffuse = texture2D(diffuseTexture, v_texCoords0) * diffuseColor;
+	#elif defined(diffuseTextureFlag)
+		vec4 diffuse = texture2D(diffuseTexture, v_texCoords0);
+	#elif defined(diffuseColorFlag)
+		vec4 diffuse = diffuseColor;
+	#else
+		vec4 diffuse = vec4(1.0);
+	#endif
+
+	#if defined(specularTextureFlag) && defined(specularColorFlag)
+		vec4 specular = texture2D(specularTexture, v_texCoords0) * specularColor;
+	#elif defined(specularTextureFlag)
+		vec4 specular = texture2D(specularTexture, v_texCoords0);
+	#elif defined(specularColorFlag)
+		vec4 specular = specularColor;
+	#else
+		vec4 specular = vec4(1.0);
+	#endif
+	
+	#ifdef NUM_LIGHTS
+		diffuse.rgb *= v_lightLambert;
+	#endif
+	
+	gl_FragColor.rgb = diffuse.rgb;
+}
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/test/test.vertex.glsl b/gdx/src/com/badlogic/gdx/graphics/g3d/test/test.vertex.glsl
new file mode 100644
index 0000000..6ca4d05
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/test/test.vertex.glsl
@@ -0,0 +1,63 @@
+#if defined(diffuseTextureFlag) || defined(specularTextureFlag)
+#define textureFlag
+#endif
+
+attribute vec3 a_position;
+attribute vec3 a_normal;
+
+uniform mat3 u_normalMatrix;
+varying vec3 v_normal;
+
+#ifdef textureFlag
+attribute vec2 a_texCoord0;
+varying vec2 v_texCoords0;
+#endif
+
+#if defined(lightsCount) 
+#if (lightsCount > 0)
+#define NUM_LIGHTS lightsCount
+struct Light
+{
+	vec4 color;
+	vec3 position;
+	float power;
+};
+uniform Light lights[NUM_LIGHTS];
+
+varying vec3 v_lightLambert;
+#endif
+#endif
+
+uniform mat4 u_projTrans;
+uniform mat4 u_modelTrans;
+
+void main() {
+	#ifdef textureFlag
+		v_texCoords0 = a_texCoord0;
+	#endif
+		
+	vec4 pos = u_modelTrans * vec4(a_position, 1.0);
+	gl_Position = u_projTrans * pos;
+	v_normal = u_normalMatrix * a_normal;
+	
+	#ifdef NUM_LIGHTS
+	vec3 aggDir = vec3(0.0);
+	float aggWeight = 0.0;
+	vec3 aggCol = vec3(0.0);
+	
+	for (int i = 0; i < NUM_LIGHTS; i++) {
+		if (lights[i].power > 0.0) {
+			vec3 diff = lights[i].position - vec3(pos);
+			
+			float invLen = inversesqrt(dot(diff, diff));
+			vec3 intensity = lights[i].color.rgb * invLen;
+			
+			float lambert = dot(normalize(v_normal), diff * invLen) * 0.5 + 0.5;
+			float weight = lights[i].power * invLen * lambert; 
+
+			aggCol += vec3(lights[i].color) * weight;
+		}
+	}
+	v_lightLambert = clamp(aggCol, 0.0, 1.0);
+	#endif
+}
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/utils/Binder.java b/gdx/src/com/badlogic/gdx/graphics/g3d/utils/Binder.java
new file mode 100644
index 0000000..18cf3eb
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/utils/Binder.java
@@ -0,0 +1,12 @@
+package com.badlogic.gdx.graphics.g3d.utils;
+
+
+public class Binder {
+	public final ExclusiveTextures textures;
+	
+	public Binder(final ExclusiveTextures textures) {
+		this.textures = textures;
+	}
+	
+	
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/utils/ExclusiveTextures.java b/gdx/src/com/badlogic/gdx/graphics/g3d/utils/ExclusiveTextures.java
new file mode 100644
index 0000000..8b41ef1
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/utils/ExclusiveTextures.java
@@ -0,0 +1,171 @@
+package com.badlogic.gdx.graphics.g3d.utils;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.GL10;
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+/** Class that you assign a range of texture units and binds textures for you within that range.
+ * It does some basic usage tracking to avoid unnessecary bind calls. 
+ * @author xoppa */
+public final class ExclusiveTextures {
+	public final static int ROUNDROBIN = 0;
+	public final static int WEIGHTED = 1;
+	/** GLES only supports up to 32 textures */
+	public final static int MAX_GLES_UNITS = 32;
+	/** The index of the first exclusive texture unit */
+	private final int offset;
+	/** The amount of exclusive textures that may be used */
+	private final int count;
+	/** The weight added to a texture when its reused */
+	private final int reuseWeight;
+	/** The textures currently exclusive bound */
+	private final TextureDescription[] textures;
+	/** The weight (reuseWeight * reused - discarded) of the textures */
+	private final int[] weights;
+	/** The method of binding to use */
+	private final int method;
+	/** Flag to indicate the current texture is reused */
+	private boolean reused;
+	
+	private int reuseCount = 0; // TODO remove debug code
+	private int bindCount = 0; // TODO remove debug code
+	
+	/** Uses all available texture units and reuse weight of 3 */
+	public ExclusiveTextures(final int method) {
+		this(method, 0);
+	}
+	
+	/** Uses all remaining texture units and reuse weight of 3 */
+	public ExclusiveTextures(final int method, final int offset) {
+		this(method, offset, GL10.GL_MAX_TEXTURE_UNITS - offset);
+	}
+	
+	/** Uses reuse weight of 10 */
+	public ExclusiveTextures(final int method, final int offset, final int count) {
+		this(method, offset, count, 10);
+	}
+	
+	public ExclusiveTextures(final int method, final int offset, final int count, final int reuseWeight) {
+		int max = Math.max(GL10.GL_MAX_TEXTURE_UNITS, MAX_GLES_UNITS - offset);
+		if (offset < 0 || count < 0 || (offset + count) > max || reuseWeight < 1)
+			throw new GdxRuntimeException("Illegal arguments");
+		this.method = method;
+		this.offset = offset;
+		this.count = count;
+		this.textures = new TextureDescription[count];
+		for (int i = 0; i < count; i++)
+			this.textures[i] = new TextureDescription();
+		this.reuseWeight = reuseWeight;
+		this.weights = (method == WEIGHTED) ? new int[count] : null;
+	}
+
+	private final TextureDescription tempDesc = new TextureDescription();
+	/** @deprecated
+	 * Binds the texture if needed and sets it active, returns the unit */
+	public final int bindTexture(final Texture texture) {
+		tempDesc.reset();
+		tempDesc.texture = texture;
+		return bindTexture(tempDesc, false);
+	}
+	
+	/** Binds the texture if needed and sets it active, returns the unit */
+	public final int bindTexture(final TextureDescription textureDesc) {
+		return bindTexture(textureDesc, false);
+	}
+
+	/** @deprecated 
+	 * Force binds the texture and sets it active, returns the unit */
+	public final int rebindTexture(final Texture texture) {
+		tempDesc.reset();
+		tempDesc.texture = texture;
+		return bindTexture(tempDesc, true);
+	}
+	
+	/** Force binds the texture and sets it active, returns the unit */
+	public final int rebindTexture(final TextureDescription textureDesc) {
+		return bindTexture(textureDesc, true);
+	}
+	
+	/** Removes the reference to the texture, to assure that it will be rebound at the next bind call */
+	public final void unbindTexture(final Texture texture) {
+		for (int i = 0; i < count; i++) {
+			if (textures[i].texture == texture) {
+				textures[i] = null;
+				weights[i] = 0;
+				return;
+			}
+		}
+	}
+	
+	private final int bindTexture(final TextureDescription textureDesc, final boolean rebind) {
+		int idx, result;
+		reused = false;
+		
+		switch (method) {
+		case ROUNDROBIN: result = offset + (idx = bindTextureRoundRobin(textureDesc.texture)); break;
+		case WEIGHTED: result = offset + (idx = bindTextureWeighted(textureDesc.texture)); break;
+		default: return -1; 
+		}
+		
+		if (reused) {
+			reuseCount++;
+			if (rebind)
+				textureDesc.texture.bind(result);
+			else
+				Gdx.gl.glActiveTexture(GL10.GL_TEXTURE0 + result);
+		} else
+			bindCount++;
+		if (textureDesc.minFilter != GL10.GL_INVALID_VALUE && textureDesc.minFilter != textures[idx].minFilter)
+			Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER, textures[idx].minFilter = textureDesc.minFilter);
+		if (textureDesc.magFilter != GL10.GL_INVALID_VALUE && textureDesc.magFilter != textures[idx].magFilter)
+			Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER, textures[idx].magFilter = textureDesc.magFilter);
+		if (textureDesc.uWrap != GL10.GL_INVALID_VALUE && textureDesc.uWrap != textures[idx].uWrap)
+			Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_S, textures[idx].uWrap = textureDesc.uWrap);
+		if (textureDesc.vWrap != GL10.GL_INVALID_VALUE && textureDesc.vWrap != textures[idx].vWrap)
+			Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_T, textures[idx].vWrap = textureDesc.vWrap);
+		return result;
+	}
+
+	private int currentTexture = 0;
+	private final int bindTextureRoundRobin(final Texture texture) {
+		for (int i = 0; i < count; i++) {
+			final int idx = (currentTexture + i) % count;
+			if (textures[idx].texture == texture) {
+				reused = true;
+				return idx;
+			}
+		}
+		currentTexture = (currentTexture + 1) % count;
+		textures[currentTexture].texture = texture;
+		texture.bind(offset + currentTexture);
+		return currentTexture;
+	}
+	
+	private final int bindTextureWeighted(final Texture texture) {
+		int result = -1;
+		int weight = weights[0];
+		int windex = 0;
+		for (int i = 0; i < count; i++) {
+			if (textures[i].texture == texture) {
+				result = i;
+				weights[i]+=reuseWeight;
+			} else if (weights[i] < 0 || --weights[i] < weight) {
+				weight = weights[i];
+				windex = i;
+			}
+		}
+		if (result < 0) {
+			textures[windex].texture = texture;
+			weights[windex] = 100;
+			texture.bind(offset + (result = windex));
+		} else 
+			reused = true;
+		return result;
+	}
+	
+	public final int getBindCount() { return bindCount; }
+	public final int getReuseCount() { return reuseCount; }
+	public final void resetCounter() { bindCount = reuseCount = 0; }
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/utils/TextureDescription.java b/gdx/src/com/badlogic/gdx/graphics/g3d/utils/TextureDescription.java
new file mode 100644
index 0000000..9986cc3
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/utils/TextureDescription.java
@@ -0,0 +1,58 @@
+package com.badlogic.gdx.graphics.g3d.utils;
+
+import com.badlogic.gdx.graphics.GL10;
+import com.badlogic.gdx.graphics.Texture;
+
+public class TextureDescription {
+	public Texture texture = null;
+	public int minFilter = GL10.GL_INVALID_VALUE;
+	public int magFilter = GL10.GL_INVALID_VALUE;
+	public int uWrap = GL10.GL_INVALID_VALUE;
+	public int vWrap = GL10.GL_INVALID_VALUE;
+	// TODO add other values, see http://www.opengl.org/sdk/docs/man/xhtml/glTexParameter.xml
+	
+	public TextureDescription(final Texture texture, final int minFilter, final int magFilter, final int uWrap, final int vWrap) {
+		set(texture, minFilter, magFilter, uWrap, vWrap);
+	}
+	
+	public TextureDescription(final Texture texture) {
+		this.texture = texture;
+	}
+	
+	public TextureDescription() {
+	}
+	
+	public void set(final Texture texture, final int minFilter, final int magFilter, final int uWrap, final int vWrap) {
+		this.texture = texture;
+		this.minFilter = minFilter;
+		this.magFilter = magFilter;
+		this.uWrap = uWrap;
+		this.vWrap = vWrap;
+	}
+	
+	public void set(final TextureDescription other) {
+		texture = other.texture;
+		minFilter = other.minFilter;
+		magFilter = other.magFilter;
+		uWrap = other.uWrap;
+		vWrap = other.vWrap;
+	}
+	
+	public void reset() {
+		texture = null;
+		minFilter = GL10.GL_INVALID_VALUE;
+		magFilter = GL10.GL_INVALID_VALUE;
+		uWrap = GL10.GL_INVALID_VALUE;
+		vWrap = GL10.GL_INVALID_VALUE;
+	}
+	
+	@Override
+	public boolean equals (Object obj) {
+		if (obj == null) return false;
+		if (obj == this) return true;
+		if (!(obj instanceof TextureDescription)) return false;
+		final TextureDescription other = (TextureDescription)obj;
+		return other.texture == texture && other.minFilter == minFilter && other.magFilter == magFilter &&
+			other.uWrap == uWrap && other.vWrap == vWrap;
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/DefaultShader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/DefaultShader.java
deleted file mode 100644
index 59fee0a..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/DefaultShader.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.xoppa;
-
-import com.badlogic.gdx.graphics.g3d.xoppa.test.TestShader;
-import com.badlogic.gdx.graphics.g3d.xoppa.utils.ExclusiveTextures;
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-
-public class DefaultShader extends TestShader {
-// TODO implement a default shader, for now it's just a stub to TestShader
-	public DefaultShader (long mask) {
-		super(mask);
-		// TODO Auto-generated constructor stub
-	}
-
-	/* public DefaultShader (ShaderProgram program) {
-		super(program);
-		// TODO Auto-generated constructor stub
-	}
-
-	public DefaultShader (String vertexShader, String fragmentShader) {
-		super(vertexShader, fragmentShader);
-		// TODO Auto-generated constructor stub
-	}*/
-
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/RenderBatch.java b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/RenderBatch.java
deleted file mode 100644
index 9868555..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/RenderBatch.java
+++ /dev/null
@@ -1,143 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.xoppa;
-
-import com.badlogic.gdx.graphics.Camera;
-import com.badlogic.gdx.graphics.g3d.model.Model;
-import com.badlogic.gdx.graphics.g3d.model.SubMesh;
-import com.badlogic.gdx.graphics.g3d.xoppa.test.Light;
-import com.badlogic.gdx.graphics.g3d.xoppa.test.NewModel;
-import com.badlogic.gdx.graphics.g3d.xoppa.test.InterimModel;
-import com.badlogic.gdx.graphics.g3d.xoppa.utils.ExclusiveTextures;
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-import com.badlogic.gdx.math.Matrix4;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.Pool;
-
-public class RenderBatch {
-	protected RenderContext context;
-	protected RenderBatchListener listener;
-	protected Camera camera;
-	// TODO: perhaps its better to use a sorted list?
-	protected final Array<RenderInstance> instances = new Array<RenderInstance>();
-	/* protected final Pool<RenderInstance> instancePool = new Pool<RenderInstance>() {
-		@Override
-		protected RenderInstance newObject () {
-			return new RenderInstance();
-		}
-	}; */
-	
-	/** Construct a BaseRenderBatch with the specified listener */
-	public RenderBatch(RenderBatchListener listener, ExclusiveTextures textures) {
-		this.listener = listener;
-		this.context = new RenderContext(textures);
-	}
-	
-	/** Construct a BaseRenderBatch with the default implementation and the specified texture range */
-	public RenderBatch(ExclusiveTextures textures) {
-		this(new RenderBatchAdapter(), textures);
-	}
-	
-	/** Construct a BaseRenderBatch with the default implementation */
-	public RenderBatch() {
-		this((ExclusiveTextures)null);
-	}
-
-	public void begin (Camera cam) {
-		this.camera = cam;
-	}
-
-	public void end () {
-		instances.sort(listener);
-		context.begin();
-		Shader currentShader = null;
-		for (int i = 0; i < instances.size; i++) {
-			final RenderInstance instance = instances.get(i);
-			if (currentShader != instance.shader) {
-				if (currentShader != null)
-					currentShader.end();
-				currentShader = instance.shader;
-				currentShader.begin(camera, context);
-			}
-			currentShader.render(instance);
-		}
-		if (currentShader != null)
-			currentShader.end();
-		context.end();
-		RenderInstance.pool.freeAll(instances);
-		instances.clear();
-		camera = null;
-	}
-
-	/** Add an instance to render, the shader property of the instance will be overwritten by this method */
-	protected void addInstance(final RenderInstance instance, final Shader shader) {
-		instance.shader = listener.getShader(instance, shader);
-		instance.renderable.mesh.setAutoBind(false);
-		instances.add(instance);
-	}
-	
-	public void addModelPart(final Renderable renderable, final Matrix4 transform, final float distance, final Light[] lights, final Shader shader) {
-		addInstance(RenderInstance.pool.obtain(renderable, transform, distance, lights, null), shader);
-	}
-	
-	public void addModel(final NewModel model, final Matrix4 transform) {
-		addModel(model, transform, null, null);
-	}
-	
-	public void addModel(final NewModel model, final Matrix4 transform, final Light[] lights) {
-		addModel(model, transform, lights, null);
-	}
-	
-	public void addModel(final NewModel model, final Matrix4 transform, final Light[] lights, final Shader shader) {
-		transform.getTranslation(Vector3.tmp);
-		float dist = Vector3.tmp2.set(Vector3.tmp.x - camera.position.x, Vector3.tmp.y - camera.position.y , Vector3.tmp.z - camera.position.z).len();
-		if (Vector3.tmp2.div(dist).dot(camera.direction) < 0)
-			dist = -dist;
-		Iterable<Renderable> parts = model.getParts(dist);
-		if (instances != null)
-			for (Renderable part : parts)
-				addModelPart(part, transform, dist, lights, null);
-	}
-	
-	
-	// Old methods:
-	
-	/*public void addMesh (final SubMesh mesh, final Matrix4 transform) {
-		addInstance(subMesh2Instance(instancePool.obtain(), mesh, transform, camera));
-	}
-	
-	public void addMesh (final SubMesh mesh, final Matrix4 transform, float distance) {
-		addInstance(subMesh2Instance(instancePool.obtain(), mesh, transform, distance));
-	}*/
-
-	/*public void addModel(final Model model, final Matrix4 transform) {
-		SubMesh[] meshes = model.getSubMeshes();
-		for (int i = 0; i < meshes.length; i++)
-			addMesh(meshes[i], transform);
-	}
-	
-	public void addModel(final Model model, final Matrix4 transform, float distance) {
-		SubMesh[] meshes = model.getSubMeshes();
-		for (int i = 0; i < meshes.length; i++)
-			addMesh(meshes[i], transform, distance);		
-	}*/
-	
-	/*public static RenderInstance subMesh2Instance(final RenderInstance instance, final SubMesh mesh, final Matrix4 transform, final Camera camera) {
-		transform.getTranslation(Vector3.tmp);
-		float dist = Vector3.tmp2.set(Vector3.tmp.x - camera.position.x, Vector3.tmp.y - camera.position.y , Vector3.tmp.z - camera.position.z).len();
-		if (Vector3.tmp2.div(dist).dot(camera.direction) < 0)
-			dist = -dist;
-		return subMesh2Instance(instance, mesh, transform, dist);
-	}
-	
-	public static RenderInstance subMesh2Instance(final RenderInstance instance, final SubMesh mesh, final Matrix4 transform, final float distance) {
-		instance.distance = distance;
-		instance.material = InterimModel.convertMaterial(mesh.material);
-		instance.mesh = mesh.mesh;
-		instance.meshPartOffset = 0;
-		instance.meshPartSize = mesh.mesh.getMaxIndices() > 0 ? mesh.mesh.getNumIndices() : mesh.mesh.getNumVertices();
-		instance.primitiveType = mesh.primitiveType;
-		instance.transform = transform;
-		instance.shader = null;
-		return instance;
-	}*/
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/RenderBatchAdapter.java b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/RenderBatchAdapter.java
deleted file mode 100644
index 337764f..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/RenderBatchAdapter.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.xoppa;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.graphics.g3d.materials.Material;
-import com.badlogic.gdx.graphics.g3d.xoppa.materials.BlendingAttribute;
-import com.badlogic.gdx.graphics.g3d.xoppa.materials.NewMaterial;
-import com.badlogic.gdx.graphics.g3d.xoppa.test.TestShader;
-import com.badlogic.gdx.graphics.g3d.xoppa.utils.ExclusiveTextures;
-import com.badlogic.gdx.utils.Array;
-
-public class RenderBatchAdapter implements RenderBatchListener {
-	protected Array<Shader> shaders = new Array<Shader>();
-		
-	@Override
-	public int compare (final RenderInstance o1, final RenderInstance o2) {
-		final boolean b1 = o1.renderable.material.has(BlendingAttribute.Type);
-		final boolean b2 = o2.renderable.material.has(BlendingAttribute.Type);
-		if (b1 != b2) 
-			return b1 ? 1 : -1;
-		final int result = (o1.shader == o2.shader) ? 0 : o1.shader.compareTo(o2.shader);
-		return result != 0 ? result : o1.shader.compare(o1, o2);
-	}
-
-	@Override
-	public Shader getShader (final RenderInstance instance, final Shader suggestedShader) {
-		if (suggestedShader != null && suggestedShader.canRender(instance))
-			return suggestedShader;
-		for (int i = 0; i < shaders.size; i++) {
-			final Shader shader = shaders.get(i);
-			if (shader.canRender(instance))
-				return shader;
-		}
-		final Shader result = createShader(instance.renderable.material);
-		shaders.add(result);
-		return result;
-	}
-	
-	protected Shader createShader(final NewMaterial material) {
-		Gdx.app.log("test", "Creating new shader");
-		return new TestShader(material);
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/RenderBatchListener.java b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/RenderBatchListener.java
deleted file mode 100644
index 2534bb6..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/RenderBatchListener.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.xoppa;
-
-import java.util.Comparator;
-
-public interface RenderBatchListener extends Comparator<RenderInstance> {
-	/** Returns the shader to be used for this instance. If the suggestedShader isn't null the preferred action is to return
-	 * that shader, but the implementation can choose to return another shader. */
-	Shader getShader(RenderInstance instance, Shader suggestedShader);
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/RenderContext.java b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/RenderContext.java
deleted file mode 100644
index efaef37..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/RenderContext.java
+++ /dev/null
@@ -1,60 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.xoppa;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.graphics.GL10;
-import com.badlogic.gdx.graphics.g3d.xoppa.utils.ExclusiveTextures;
-
-public class RenderContext {
-	public final ExclusiveTextures textures;
-	
-	private boolean blending;
-	private int blendSFactor;
-	private int blendDFactor;
-	private boolean depthTest;
-	private int depthFunc;
-	
-	public RenderContext(ExclusiveTextures textures) {
-		this.textures = textures;
-	}
-	
-	public final void begin() {
-		Gdx.gl.glDisable(GL10.GL_DEPTH_TEST);
-		depthTest = false;
-		Gdx.gl.glDisable(GL10.GL_BLEND);
-		blending = false;
-		blendSFactor = blendDFactor = depthFunc = 0;
-	}
-	
-	public final void end() {
-		
-	}
-	
-	public final void setDepthTest(final boolean enabled, final int depthFunction) {
-		if (enabled != depthTest) {
-			depthTest = enabled;
-			if (enabled)
-				Gdx.gl.glEnable(GL10.GL_DEPTH_TEST);
-			else
-				Gdx.gl.glDisable(GL10.GL_DEPTH_TEST);
-		}
-		if (enabled && depthFunc != depthFunction) {
-			Gdx.gl.glDepthFunc(depthFunction);
-			depthFunc = depthFunction;
-		}
-	}
-	
-	public final void setBlending(final boolean enabled, final int sFactor, final int dFactor) {
-		if (enabled != blending) {
-			blending = enabled;
-			if (enabled)
-				Gdx.gl.glEnable(GL10.GL_BLEND);
-			else
-				Gdx.gl.glDisable(GL10.GL_BLEND);
-		}
-		if (enabled && (blendSFactor != sFactor || blendDFactor != dFactor)) {
-			Gdx.gl.glBlendFunc(sFactor, dFactor);
-			blendSFactor = sFactor;
-			blendDFactor = dFactor;
-		}
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/RenderInstance.java b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/RenderInstance.java
deleted file mode 100644
index 90f9628..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/RenderInstance.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.xoppa;
-
-import com.badlogic.gdx.graphics.Mesh;
-import com.badlogic.gdx.graphics.g3d.materials.Material;
-import com.badlogic.gdx.graphics.g3d.xoppa.materials.NewMaterial;
-import com.badlogic.gdx.graphics.g3d.xoppa.test.Light;
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-import com.badlogic.gdx.math.Matrix4;
-import com.badlogic.gdx.utils.Pool;
-
-public class RenderInstance {
-	public Renderable renderable;
-	public Matrix4 transform;
-	public float distance;
-	public Shader shader;
-	public Light[] lights;
-	
-	public final static class RenderInstancePool extends Pool<RenderInstance> {
-		@Override
-		protected final RenderInstance newObject () {
-			return new RenderInstance();
-		}
-		
-		public final RenderInstance obtain(final Renderable renderable, final Matrix4 transform, final float distance, final Light[] lights, final Shader shader) {
-			final RenderInstance result = obtain();
-			result.renderable = renderable;
-			result.transform = transform;
-			result.distance = distance;
-			result.lights = lights;
-			result.shader = shader;
-			return result;
-		}
-	};
-	
-	public final static RenderInstancePool pool = new RenderInstancePool(); 
-}
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/Renderable.java b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/Renderable.java
deleted file mode 100644
index bbb0913..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/Renderable.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.xoppa;
-
-import com.badlogic.gdx.graphics.Mesh;
-import com.badlogic.gdx.graphics.g3d.xoppa.materials.NewMaterial;
-
-public class Renderable {
-	public Mesh mesh;
-	public int meshPartOffset;
-	public int meshPartSize;
-	public int primitiveType;
-	public NewMaterial material;
-}
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/Shader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/Shader.java
deleted file mode 100644
index 923e34a..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/Shader.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.xoppa;
-
-import java.util.Comparator;
-
-import com.badlogic.gdx.graphics.Camera;
-import com.badlogic.gdx.graphics.g3d.materials.Material;
-import com.badlogic.gdx.graphics.g3d.xoppa.materials.NewMaterial;
-import com.badlogic.gdx.graphics.g3d.xoppa.test.Light;
-import com.badlogic.gdx.graphics.g3d.xoppa.test.NewModel;
-import com.badlogic.gdx.math.Matrix4;
-
-public interface Shader extends Comparator<RenderInstance> {
-	int compareTo(Shader other); // TODO: probably better to add some weight value to sort on
-	boolean canRender(RenderInstance instance);
-	void begin(Camera camera, RenderContext context);
-	void render(final RenderInstance instance);
-	void render(final NewModel model, final Matrix4 transform, final Light[] lights);
-	void end();
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/materials/BlendingAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/materials/BlendingAttribute.java
deleted file mode 100644
index 30a4ee1..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/materials/BlendingAttribute.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.xoppa.materials;
-
-import com.badlogic.gdx.graphics.g3d.xoppa.materials.NewMaterial.Attribute;
-
-public class BlendingAttribute extends NewMaterial.Attribute {
-	public final static String Alias = "blended";
-	public final static long Type = register(Alias);
-	
-	public final static boolean is(final long mask) {
-		return (mask & Type) == mask;
-	}
- 
-	public int sourceFunction;
-	public int destFunction;
-
-	public BlendingAttribute() { 
-		super(Type); 
-	}
-	
-	public BlendingAttribute(final int sourceFunc, final int destFunc) {
-		this();
-		sourceFunction = sourceFunc;
-		destFunction = destFunc;
-	}
-	
-	public BlendingAttribute(final BlendingAttribute copyFrom) {
-		this(copyFrom == null ? 0 : copyFrom.sourceFunction, copyFrom == null ? 0 : copyFrom.destFunction);
-	}
-	
-	@Override
-	public BlendingAttribute copy () {
-		return new BlendingAttribute(this);
-	}
-	
-	@Override
-	protected boolean equals (final Attribute other) {
-		return ((BlendingAttribute)other).sourceFunction == sourceFunction && 
-			((BlendingAttribute)other).destFunction == destFunction; 
-	}
-}
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/materials/ColorAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/materials/ColorAttribute.java
deleted file mode 100644
index 06e9eb5..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/materials/ColorAttribute.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.xoppa.materials;
-
-import com.badlogic.gdx.graphics.Color;
-import com.badlogic.gdx.graphics.g3d.xoppa.materials.NewMaterial.Attribute;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-
-public class ColorAttribute extends NewMaterial.Attribute {
-	public final static String DiffuseAlias = "diffuseColor";
-	public final static long Diffuse = register(DiffuseAlias);
-	public final static String SpecularAlias = "specularColor";
-	public final static long Specular = register(SpecularAlias);
-	
-	// Might be useful:...
-	protected static long Mask = Diffuse | Specular;
-	
-	public final static boolean is(final long mask) {
-		return (mask & Mask) != 0;
-	}
-	
-	public final static ColorAttribute createDiffuse(final Color color) {
-		return new ColorAttribute(Diffuse, color);
-	}
-	
-	public final static ColorAttribute createSpecular(final Color color) {
-		return new ColorAttribute(Specular, color);
-	}
-	
-	public final Color color = new Color();
-	
-	public ColorAttribute(final long type) {
-		this(type, null);
-	}
-	
-	public ColorAttribute(final long type, final Color color) {
-		super(type);
-		if (!is(type))
-			throw new GdxRuntimeException("Invalid type specified");
-		if (color != null)
-			this.color.set(color);
-	}
-	
-	public ColorAttribute(final ColorAttribute copyFrom) {
-		this(copyFrom.type, copyFrom.color);
-	}
-
-	@Override
-	public Attribute copy () {
-		return new ColorAttribute(this);
-	}
-
-	@Override
-	protected boolean equals (Attribute other) {
-		return ((ColorAttribute)other).color.equals(color);
-	}
-}
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/materials/NewMaterial.java b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/materials/NewMaterial.java
deleted file mode 100644
index a11fb25..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/materials/NewMaterial.java
+++ /dev/null
@@ -1,230 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.xoppa.materials;
-
-import java.util.Comparator;
-import java.util.Iterator;
-
-import com.badlogic.gdx.graphics.Texture;
-import com.badlogic.gdx.utils.Array;
-
-public class NewMaterial implements Iterable<NewMaterial.Attribute>, Comparator<NewMaterial.Attribute> {
-	/** Extend this class to implement a material attribute.
-	 *  Register the attribute type by statically calling the {@link #register(String)} method, 
-	 *  whose return value should be used to instantiate the attribute. 
-	 *  A class can implement multiple types*/
-	public static abstract class Attribute {
-		protected static long register(final String type) {
-			return NewMaterial.register(type);
-		}
-		/** The type of this attribute */
-		protected long type;
-		protected Attribute(final long type) {
-			this.type = type;
-		}
-		/** @return The type of material */
-		public final long getType() {
-			return type;
-		}
-		/** @return An exact copy of this attribute */
-		public abstract Attribute copy(); 
-		protected abstract boolean equals(Attribute other);
-		@Override
-		public boolean equals (Object obj) {
-			if (obj == null) return false;
-			if (obj == this) return true;
-			if (!(obj instanceof Attribute)) return false;
-			final Attribute other = (Attribute)obj;
-			if (other.type != other.type) return false; 
-			return equals(other);
-		}
-	}
-	
-	/** The registered type aliases */
-	private final static Array<String> types = new Array<String>();
-	
-	/** @return The ID of the specified attribute type, or zero if not available */
-	protected final static long getAttributeType(final String alias) {
-		for (int i = 0; i < types.size; i++)
-			if (types.get(i).compareTo(alias)==0)
-				return 1L << i;
-		return 0;
-	}
-	
-	/** Use {@link Attribute#register(String)} instead */ 
-	protected final static long register(final String alias) {
-		long result = getAttributeType(alias);
-		if (result > 0)
-			return result;
-		types.add(alias);
-		return 1L << (types.size - 1);
-	}
-	
-	protected long mask;
-	protected Array<Attribute> attributes = new Array<Attribute>();
-	protected boolean sorted = true;
-	
-	/** Create an empty material */
-	public NewMaterial() {	}
-	/** Create a material with the specified attributes */
-	public NewMaterial(final Attribute... attributes) {
-		add(attributes);
-	}
-	/** Create a material with the specified attributes */
-	public NewMaterial(final Array<Attribute> attributes) {
-		add(attributes);
-	}
-	/** Create a material which is an exact copy of the specified material */
-	public NewMaterial(final NewMaterial copyFrom) {
-		for (Attribute attr : copyFrom)
-			add(attr.copy());
-	}
-	
-	private final void enable(final long mask) {
-		this.mask |= mask; 
-	}
-	private final void disable(final long mask) {
-		this.mask &= -1L ^ mask;
-	}
-	
-	/** @return Bitwise mask of the ID's of all the containing attributes */  
-	public final long getMask() {
-		return mask;
-	}
-	
-	/** @return True if this material has the specified attribute, i.e. material.has(BlendingAttribute.ID); */
-	public final boolean has(final long type) {
-		return type > 0 && (this.mask & type) == type;
-	}
-	
-	/** @deprecated Use {@link #has(long)} instead
-	 * @return True if this material has the specified attribute, i.e. material.has(BlendingAttribute.class); */
-	public final boolean has(final String type) {
-		return has(getAttributeType(type));
-	}
-	
-	/** Add one or more attributes to this material */
-	public final void add(final Attribute... attributes) {
-		for (int i = 0; i < attributes.length; i++) {
-			final Attribute attr = attributes[i];
-			if (!has(attr.type)) {
-				enable(attr.type);
-				this.attributes.add(attr);
-				sorted = false;
-			}
-		}
-	}
-
-	/** Add an array of attributes to this material */
-	public final void add(final Array<Attribute> attributes) {
-		for (int i = 0; i < attributes.size; i++) {
-			final Attribute attr = attributes.get(i);
-			if (!has(attr.type)) {
-				enable(attr.type);
-				this.attributes.add(attr);
-				sorted = false;
-			}
-		}
-	}
-	
-	/** Removes the attribute from the material, i.e.: material.remove(BlendingAttribute.ID);
-	 * Can also be used to remove multiple attributes also, i.e. remove(AttributeA.ID | AttributeB.ID); */
-	public final void remove(final long mask) {
-		for (int i = 0; i < attributes.size; i++) {
-			final long type = attributes.get(i).type;
-			if ((mask & type) == type) {
-				attributes.removeIndex(i);
-				disable(type);
-				sorted = false;
-			}
-		}
-	}
-	
-	/** @deprecated Use {@link #remove(long)} instead
-	 * Removes the attribute from the material, i.e.: material.remove(BlendingAttribute.class); */
-	public final void remove(final String alias) {
-		final long type = getAttributeType(alias);
-		if (has(type)) {
-			for (int i = 0; i < attributes.size; i++)
-				if (attributes.get(i).type == type) {
-					attributes.removeIndex(i);
-					break;
-				}
-			sorted = false;
-			disable(type);
-		}
-	}
-	
-	/** Example usage: ((BlendingAttribute)material.get(BlendingAttribute.ID)).sourceFunction;
-	 * @return The attribute (which can safely be cast) if any, otherwise null */
-	public final Attribute get(final long type) {
-		if (has(type))
-			for (int i = 0; i < attributes.size; i++)
-				if (attributes.get(i).type == type)
-					return attributes.get(i);
-		return null;
-	}
-	
-	/** Get multiple attributes at once.
-	 * Example: material.get(out, AttributeA.ID | AttributeB.ID | AttributeC.ID); */
-	public final Array<Attribute> get(final Array<Attribute> out, final long type) {
-		for (int i = 0; i < attributes.size; i++)
-			if ((attributes.get(i).type & type) != 0)
-				out.add(attributes.get(i));
-		return out;
-	}
-	
-	/** Removes all attributes */
-	public final void clear() {
-		mask = 0;
-		attributes.clear();
-	}
-	
-	/** Create a copy of this material */
-	public final NewMaterial copy() {
-		return new NewMaterial(this); 
-	}
-
-	/** Used for sorting attributes */
-	@Override
-	public final int compare (final Attribute arg0, final Attribute arg1) {
-		return (int)(arg0.type - arg1.type);
-	}
-	
-	/** Sort the attributes by their ID */
-	public final void sort() {
-		if (!sorted) {
-			attributes.sort(this);
-			sorted = true;
-		}
-	}
-	
-	/** @return True if this material contains the same attributes as the other, 
-	 * use {@link #equals(NewMaterial)} to see if the values are also the same */
-	public final boolean same(final NewMaterial other) {
-		return mask == other.mask;
-	}
-	
-	/** @return True if this material equals the other material in every aspect */
-	public final boolean equals (final NewMaterial other) {
-		if (other == null) return false;
-		if (other == this) return true;
-		if (!same(other)) return false;
-		sort();
-		other.sort();
-		for (int i = 0; i < attributes.size; i++)
-			if (!attributes.get(i).equals(other.attributes.get(i)))
-				return false;
-		return true;
-	}
-	
-	/** @return True if this material equals the other material in every aspect */
-	@Override
-	public final boolean equals (final Object obj) {
-		return obj instanceof NewMaterial ? equals((NewMaterial)obj) : false;
-	}
-	
-	/** Used for iterating through the attributes */
-	@Override
-	public final Iterator<Attribute> iterator () {
-		return attributes.iterator();
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/materials/TextureAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/materials/TextureAttribute.java
deleted file mode 100644
index ae5157b..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/materials/TextureAttribute.java
+++ /dev/null
@@ -1,47 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.xoppa.materials;
-
-import com.badlogic.gdx.graphics.Texture;
-import com.badlogic.gdx.graphics.g3d.xoppa.materials.NewMaterial.Attribute;
-import com.badlogic.gdx.graphics.g3d.xoppa.utils.TextureDescription;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-
-public class TextureAttribute extends NewMaterial.Attribute {
-	public final static String DiffuseAlias = "diffuseTexture";
-	public final static long Diffuse = register(DiffuseAlias);
-	public final static String SpecularAlias = "specularTexture";
-	public final static long Specular = register(SpecularAlias);
-	
-	// Might be useful:...
-	protected static long Mask = Diffuse | Specular;
-	
-	public final static boolean is(final long mask) {
-		return (mask & Mask) != 0;
-	}
-	
-	public final TextureDescription textureDescription;
-	
-	public TextureAttribute(final long type, final TextureDescription textureDescription) {
-		super(type);
-		if (!is(type))
-			throw new GdxRuntimeException("Invalid type specified");
-		this.textureDescription = textureDescription;
-	}
-	
-	public TextureAttribute(final long type) {
-		this(type, null);
-	}
-	
-	public TextureAttribute(final TextureAttribute copyFrom) {
-		this(copyFrom.getType(), copyFrom.textureDescription);
-	}
-	
-	@Override
-	public Attribute copy () {
-		return new TextureAttribute(this);
-	}
-
-	@Override
-	protected boolean equals (Attribute other) {
-		return ((TextureAttribute)other).textureDescription.equals(textureDescription);
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/InterimModel.java b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/InterimModel.java
deleted file mode 100644
index cd24c67..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/InterimModel.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.xoppa.test;
-
-import com.badlogic.gdx.graphics.g3d.materials.Material;
-import com.badlogic.gdx.graphics.g3d.materials.MaterialAttribute;
-import com.badlogic.gdx.graphics.g3d.model.Model;
-import com.badlogic.gdx.graphics.g3d.model.SubMesh;
-import com.badlogic.gdx.graphics.g3d.xoppa.RenderInstance;
-import com.badlogic.gdx.graphics.g3d.xoppa.Renderable;
-import com.badlogic.gdx.graphics.g3d.xoppa.materials.BlendingAttribute;
-import com.badlogic.gdx.graphics.g3d.xoppa.materials.ColorAttribute;
-import com.badlogic.gdx.graphics.g3d.xoppa.materials.NewMaterial;
-import com.badlogic.gdx.graphics.g3d.xoppa.materials.TextureAttribute;
-import com.badlogic.gdx.graphics.g3d.xoppa.utils.TextureDescription;
-import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-
-public class InterimModel implements NewModel {
-	public final Array<Renderable> parts;
-	
-	public final static NewMaterial convertMaterial(final Material mtl) {
-		NewMaterial result = new NewMaterial();
-		for (MaterialAttribute attr : mtl) {
-			if (attr instanceof com.badlogic.gdx.graphics.g3d.materials.BlendingAttribute) {
-				com.badlogic.gdx.graphics.g3d.materials.BlendingAttribute a = (com.badlogic.gdx.graphics.g3d.materials.BlendingAttribute)attr;
-				result.add(new BlendingAttribute(a.blendSrcFunc, a.blendDstFunc));
-			} else if (attr instanceof com.badlogic.gdx.graphics.g3d.materials.ColorAttribute) {
-				com.badlogic.gdx.graphics.g3d.materials.ColorAttribute a = (com.badlogic.gdx.graphics.g3d.materials.ColorAttribute)attr;
-				if (a.name.compareTo(com.badlogic.gdx.graphics.g3d.materials.ColorAttribute.specular)==0)
-					result.add(ColorAttribute.createSpecular(a.color));
-				else
-					result.add(ColorAttribute.createDiffuse(a.color));
-			} else if (attr instanceof com.badlogic.gdx.graphics.g3d.materials.TextureAttribute) {
-				com.badlogic.gdx.graphics.g3d.materials.TextureAttribute a = (com.badlogic.gdx.graphics.g3d.materials.TextureAttribute)attr;
-				final TextureDescription tex = new TextureDescription(a.texture, a.minFilter, a.magFilter, a.uWrap, a.vWrap);
-				if (a.name.compareTo(com.badlogic.gdx.graphics.g3d.materials.TextureAttribute.specularTexture)==0)
-					result.add(new TextureAttribute(TextureAttribute.Specular, tex));
-				else // if (a.name.compareTo(com.badlogic.gdx.graphics.g3d.materials.TextureAttribute.diffuseTexture)==0)
-					result.add(new TextureAttribute(TextureAttribute.Diffuse, tex));
-				// else unknown texture attribute
-			} // else throw new GdxRuntimeException("Unkown material attribute");
-		}
-		return result;
-	}
-	
-	public InterimModel(final Model model) {
-		SubMesh[] meshes = model.getSubMeshes();
-		parts = new Array<Renderable>(meshes.length);
-		for (int i = 0; i < meshes.length; i++) {
-			final Renderable inst = new Renderable();
-			inst.mesh = meshes[i].mesh;
-			inst.meshPartOffset = 0;
-			inst.meshPartSize = meshes[i].mesh.getMaxIndices() > 0 ? meshes[i].mesh.getNumIndices() : meshes[i].mesh.getNumVertices();
-			inst.primitiveType = meshes[i].primitiveType;
-			inst.material = convertMaterial(meshes[i].material);
-			parts.add(inst);
-		}
-	}
-	
-	public InterimModel(final Renderable... parts) {
-		this.parts = new Array<Renderable>(parts);
-	}
-	
-	public InterimModel(final Array<Renderable> parts) {
-		this.parts = new Array<Renderable>(parts);
-	}
-
-	@Override
-	public Iterable<Renderable> getParts (float distance) {
-		return parts;
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/Light.java b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/Light.java
deleted file mode 100644
index e5cfab2..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/Light.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.xoppa.test;
-
-import com.badlogic.gdx.graphics.Color;
-import com.badlogic.gdx.math.Vector3;
-
-public class Light {
-	public final Color color = new Color();
-	public final Vector3 position = new Vector3();
-	public float power = 1f;
-	
-	public Light(final Color color, final Vector3 position, final float power) {
-		this(color.r, color.g, color.b, color.a, position.x, position.y, position.z, power);
-	}
-	
-	public Light(final float red, final float green, final float blue, final float alpha, 
-					final float x, final float y, final float z, final float power) {
-		color.set(red, green, blue, alpha);
-		position.set(x, y, z);
-		this.power = power;
-	}
-	
-	public boolean equals(Light other) {
-		if (other == null) return false;
-		if (other == this) return true;
-		return color.equals(other.color) && position.equals(other.position) && power == other.power;
-	}
-	
-	@Override
-	public boolean equals (Object arg0) {
-		if (arg0 == null) return false;
-		if (arg0 == this) return true;
-		if (!(arg0 instanceof Light)) return false;
-		return equals((Light)arg0);
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/NewModel.java b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/NewModel.java
deleted file mode 100644
index 49e1369..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/NewModel.java
+++ /dev/null
@@ -1,8 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.xoppa.test;
-
-import com.badlogic.gdx.graphics.g3d.xoppa.RenderInstance;
-import com.badlogic.gdx.graphics.g3d.xoppa.Renderable;
-
-public interface NewModel {
-	Iterable<Renderable> getParts(float distance);
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/OldBatchRenderer.java b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/OldBatchRenderer.java
deleted file mode 100644
index 037efad..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/OldBatchRenderer.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.xoppa.test;
-
-import java.util.Comparator;
-
-import com.badlogic.gdx.graphics.Camera;
-import com.badlogic.gdx.graphics.g3d.xoppa.RenderInstance;
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-import com.badlogic.gdx.utils.Array;
-
-public interface OldBatchRenderer extends Comparator<RenderInstance> {
-	ShaderProgram getShader(RenderInstance instance);
-	void render(Camera camera, Array<RenderInstance> instances /*, Array<Light> lights*/);
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/OldBatchRendererGLES11.java b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/OldBatchRendererGLES11.java
deleted file mode 100644
index 160c132..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/OldBatchRendererGLES11.java
+++ /dev/null
@@ -1,149 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.xoppa.test;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.graphics.Camera;
-import com.badlogic.gdx.graphics.GL10;
-import com.badlogic.gdx.graphics.GL11;
-import com.badlogic.gdx.graphics.Mesh;
-import com.badlogic.gdx.graphics.Texture;
-import com.badlogic.gdx.graphics.VertexAttribute;
-import com.badlogic.gdx.graphics.VertexAttributes.Usage;
-import com.badlogic.gdx.graphics.g3d.materials.Material;
-import com.badlogic.gdx.graphics.g3d.materials.MaterialAttribute;
-import com.badlogic.gdx.graphics.g3d.materials.TextureAttribute;
-import com.badlogic.gdx.graphics.g3d.xoppa.RenderInstance;
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-import com.badlogic.gdx.utils.Array;
-
-public class OldBatchRendererGLES11 implements OldBatchRenderer {
-	final float[] lightColor = {1, 1, 1, 0};
-	final float[] lightPosition = {2, 5, 10, 0};
-
-	public final int textureUnitOffset = 3;
-	public final int textureCount;
-	final Texture[] textures;
-	final int[] textureWeights;
-	public int bindCount = 0;
-	public int reuseCount = 0;
-	
-	public OldBatchRendererGLES11() {
-		textureCount = Math.min(GL10.GL_MAX_TEXTURE_UNITS, 16) - textureUnitOffset;
-		textures = new Texture[textureCount];
-		textureWeights = new int[textureCount];
-	}
-	
-	@Override
-	public int compare (RenderInstance o1, RenderInstance o2) {
-		return o1.distance > o2.distance ? 1 : (o1.distance < o2.distance ? -1 : 0);
-	}
-
-	@Override
-	public ShaderProgram getShader (RenderInstance instance) {
-		return null;
-	}
-	
-	Material currentMaterial;
-	boolean useTexture;
-	int currentTexture; // for now only allow one textureattribute to be used at a time
-	private final void setMaterial(final GL11 gl, final Material mat) {
-		if (mat == currentMaterial) 
-			return;
-		
-		final boolean hasTex = mat.hasTexture();
-		
-		if (useTexture != hasTex || currentMaterial == null) {
-			useTexture = hasTex;
-			if (hasTex)
-				gl.glEnable(GL11.GL_TEXTURE_2D);
-			else
-				gl.glDisable(GL11.GL_TEXTURE_2D);
-		}
-		
-		currentMaterial = mat;
-		for (MaterialAttribute attr : currentMaterial) {
-			if (attr instanceof TextureAttribute)
-				bindTextureAttribute(gl, (TextureAttribute)attr);
-			else
-				attr.bind();
-		}
-	}
-
-	private final void bindTextureAttribute(final GL11 gl, final TextureAttribute attribute) {
-		currentTexture = bindTexture(gl, attribute.texture);
-		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER, attribute.minFilter);
-		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER, attribute.magFilter);
-		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_S, attribute.uWrap);
-		Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_T, attribute.vWrap);
-	}
-	
-	private final int bindTexture(final GL11 gl, final Texture texture) {
-		int result = -1;
-		int weight = textureWeights[0];
-		int windex = 0;
-		for (int i = 0; i < textureCount; i++) {
-			if (textures[i] == texture) {
-				result = i;
-				textureWeights[i]++;
-			} else if (--textureWeights[i] < weight || textureWeights[i] < 0) {
-				weight = textureWeights[i];
-				windex = i;
-			}
-		}
-		if (result < 0) {
-			textures[windex] = texture;
-			textureWeights[windex] = 100;
-			result = windex;
-			texture.bind(textureUnitOffset + windex);
-			bindCount++;
-		} else
-			reuseCount++;
-		return textureUnitOffset + result;
-	}
-	
-	Mesh currentMesh;
-	@Override
-	public void render (Camera camera, Array<RenderInstance> instances) {
-		final GL11 gl = Gdx.gl11;
-		gl.glViewport(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
-		gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
-		gl.glEnable(GL10.GL_DEPTH_TEST);
-		gl.glEnable(GL10.GL_LIGHTING);
-		gl.glEnable(GL10.GL_COLOR_MATERIAL);
-		gl.glEnable(GL10.GL_TEXTURE_2D);
-
-		gl.glEnable(GL10.GL_LIGHT0);
-		gl.glLightfv(GL10.GL_LIGHT0, GL10.GL_DIFFUSE, lightColor, 0);
-		gl.glLightfv(GL10.GL_LIGHT0, GL10.GL_POSITION, lightPosition, 0);
-
-		camera.apply(gl);
-		currentMaterial = null;
-		gl.glDisable(GL10.GL_TEXTURE_2D);
-		
-		for (int i = 0; i < textureCount; i++) {
-			textureWeights[i] = 0;
-			textures[i] = null;
-		}
-
-		for (int i = 0; i < instances.size; i++) {
-			final RenderInstance instance = instances.get(i);
-			// setMaterial(gl, instance.material);
-			//if (instance.mesh != currentMesh) { // uncomment for GLES20
-				if (currentMesh != null)
-					currentMesh.unbind();
-				currentMesh = instance.renderable.mesh;
-				VertexAttribute a = currentMesh.getVertexAttribute(Usage.TextureCoordinates);
-				if (a != null)
-					a.alias = ShaderProgram.TEXCOORD_ATTRIBUTE + currentTexture;
-				currentMesh.bind();
-			//}
-			gl.glPushMatrix();
-			gl.glMultMatrixf(instance.transform.val, 0);
-			instance.renderable.mesh.render(instance.renderable.primitiveType);
-			gl.glPopMatrix();
-		}
-		if (currentMesh != null) {
-			currentMesh.unbind();
-			currentMesh = null;
-		}
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/OldBatchRendererGLES20.java b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/OldBatchRendererGLES20.java
deleted file mode 100644
index 28c8ce8..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/OldBatchRendererGLES20.java
+++ /dev/null
@@ -1,169 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.xoppa.test;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.graphics.Camera;
-import com.badlogic.gdx.graphics.GL10;
-import com.badlogic.gdx.graphics.GL11;
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.Mesh;
-import com.badlogic.gdx.graphics.Texture;
-import com.badlogic.gdx.graphics.g3d.materials.Material;
-import com.badlogic.gdx.graphics.g3d.materials.MaterialAttribute;
-import com.badlogic.gdx.graphics.g3d.materials.TextureAttribute;
-import com.badlogic.gdx.graphics.g3d.xoppa.RenderInstance;
-import com.badlogic.gdx.graphics.g3d.xoppa.utils.ExclusiveTextures;
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-import com.badlogic.gdx.math.Matrix4;
-import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-
-public class OldBatchRendererGLES20 implements OldBatchRenderer {
-	public final static String PROJECTION_TRANSFORM = "u_projTrans";
-	public final static String MODEL_TRANSFORM = "u_modelTrans";
-	
-	public final static String DEFAULT_VERTEX_SHADER = 
-			"attribute vec3 " + ShaderProgram.POSITION_ATTRIBUTE + ";" +
-			"attribute vec2 " + ShaderProgram.TEXCOORD_ATTRIBUTE + "0;" +
-			"uniform mat4 " + PROJECTION_TRANSFORM + ";" +
-			"uniform mat4 " + MODEL_TRANSFORM + ";" +
-			"varying vec2 v_texCoords;" +
-			"void main() {"+
-			"	v_texCoords = " + ShaderProgram.TEXCOORD_ATTRIBUTE + "0;" +
-			"	gl_Position = " + PROJECTION_TRANSFORM + " * (" + MODEL_TRANSFORM + " * vec4(" + ShaderProgram.POSITION_ATTRIBUTE + ", 1.0));" +
-			"}";
-	
-	public final static String DEFAULT_FRAGMENT_SHADER = 
-			"#ifdef GL_ES\n" + 
-			"#define LOWP lowp\n" +
-			"#define MED mediump\n" +
-			"#define HIGH highp\n" +
-			"precision mediump float;\n" +
-			"#else\n" +
-			"#define MED\n" +
-			"#define LOWP\n" +
-			"#endif\n" + 
-			"uniform sampler2D " + TextureAttribute.diffuseTexture + ";" +
-			"varying MED vec2 v_texCoords;" +
-			"void main() {" +
-			"	gl_FragColor = texture2D(" + TextureAttribute.diffuseTexture + ", v_texCoords);" +
-			"}";
-	
-	public final ShaderProgram defaultShader;
-		
-	protected ExclusiveTextures textures;
-	
-	public OldBatchRendererGLES20(final ExclusiveTextures textures) {
-		this.textures = textures;
-		defaultShader = new ShaderProgram(DEFAULT_VERTEX_SHADER, DEFAULT_FRAGMENT_SHADER);
-		if (!defaultShader.isCompiled())
-			throw new GdxRuntimeException(defaultShader.getLog());
-		
-	}
-	
-	@Override
-	public int compare (RenderInstance arg0, RenderInstance arg1) {
-		// TODO
-		return arg0.distance > arg1.distance ? 1 : (arg0.distance < arg1.distance ? -1 : 0);
-	}
-
-	@Override
-	public ShaderProgram getShader (RenderInstance instance) {
-		// TODO
-		return defaultShader;
-	}
-	
-	@Override
-	public void render (final Camera camera, final Array<RenderInstance> instances) {
-		// breakdown this method into smaller inline pieces for easy testing
-		final GL20 gl = Gdx.gl20;
-		begin(gl, camera);
-		for (int i = 0; i < instances.size; i++) {
-			final RenderInstance instance = instances.get(i);
-			bindShader(gl, camera, instance);
-			bindMaterial(gl, camera, instance);
-			renderMesh(gl, camera, instance);
-		}
-		end(gl);
-	}
-	
-	/////// bindShader /////////
-	private ShaderProgram currentShader;
-	private ShaderProgram previousShader;
-	private boolean shaderChanged;
-	private final void bindShader(final GL20 gl, final Camera camera, final RenderInstance instance) {
-		shaderChanged = instance.shader != currentShader;
-		if (!shaderChanged)
-			return;
-		if (currentShader != null)
-			currentShader.end();
-		previousShader = currentShader;
-		//currentShader = instance.shader;
-		currentShader.begin();
-		
-		currentShader.setUniformMatrix(PROJECTION_TRANSFORM, camera.combined);
-	}
-
-	/////// bindMaterial /////////
-	Material currentMaterial;
-	private final void bindMaterial(final GL20 gl, final Camera camera, final RenderInstance instance) {
-		/*if (currentMaterial == instance.material)
-			return;
-		currentMaterial = instance.material;
-		for (MaterialAttribute attr : currentMaterial) {
-			if (attr instanceof TextureAttribute)
-				bindTextureAttribute(gl, (TextureAttribute)attr);
-			else
-				attr.bind(currentShader);
-		}*/
-	}
-
-	/////// bindTextureAttribute /////////
-	TextureAttribute currentTextureAttribute;
-	int unittmp = 0;
-	private final void bindTextureAttribute(final GL20 gl, final TextureAttribute attribute) {
-		if (attribute == currentTextureAttribute && !shaderChanged)
-			return;
-		final int unit = textures.bindTexture(attribute.texture);
-		attribute.texture.bind(unit);
-		gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER, attribute.minFilter);
-		gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER, attribute.magFilter);
-		gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_S, attribute.uWrap);
-		gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_T, attribute.vWrap);
-		currentShader.setUniformi(TextureAttribute.diffuseTexture, unit);
-		currentTextureAttribute = attribute;
-	}
-
-	/////// renderMesh /////////
-	private Mesh currentMesh;
-	private Matrix4 currentTransform;
-	private final void renderMesh(final GL20 gl, final Camera camera, final RenderInstance instance) {
-		if (currentMesh != instance.renderable.mesh || shaderChanged) {
-			if (currentMesh != null)
-				currentMesh.unbind(shaderChanged ? previousShader : currentShader);
-			(currentMesh = instance.renderable.mesh).bind(currentShader);
-		}
-		if (currentTransform != instance.transform || shaderChanged)
-			currentShader.setUniformMatrix(MODEL_TRANSFORM, currentTransform = instance.transform);
-		instance.renderable.mesh.render(currentShader, instance.renderable.primitiveType);
-	}
-
-	/////// begin /////////
-	private final void begin(final GL20 gl, final Camera camera) {
-		Gdx.gl.glEnable(GL10.GL_DEPTH_TEST);
-		Gdx.gl.glDepthFunc(GL10.GL_LEQUAL);
-		Gdx.gl.glEnable(GL10.GL_BLEND);
-		Gdx.gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
-	}
-
-	/////// end /////////
-	private final void end(final GL20 gl) {
-		if (currentMesh != null) {
-			currentMesh.unbind(currentShader);
-			currentMesh = null;
-		}
-		if (currentShader != null) {
-			currentShader.end();
-			currentShader = null;
-		}
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/TestShader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/TestShader.java
deleted file mode 100644
index 64a199e..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/TestShader.java
+++ /dev/null
@@ -1,252 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.xoppa.test;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.graphics.Camera;
-import com.badlogic.gdx.graphics.GL10;
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.Mesh;
-import com.badlogic.gdx.graphics.g3d.xoppa.RenderContext;
-import com.badlogic.gdx.graphics.g3d.xoppa.RenderInstance;
-import com.badlogic.gdx.graphics.g3d.xoppa.Renderable;
-import com.badlogic.gdx.graphics.g3d.xoppa.Shader;
-import com.badlogic.gdx.graphics.g3d.xoppa.materials.BlendingAttribute;
-import com.badlogic.gdx.graphics.g3d.xoppa.materials.ColorAttribute;
-import com.badlogic.gdx.graphics.g3d.xoppa.materials.NewMaterial;
-import com.badlogic.gdx.graphics.g3d.xoppa.materials.TextureAttribute;
-import com.badlogic.gdx.graphics.g3d.xoppa.utils.ExclusiveTextures;
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-
-public class TestShader implements Shader {
-	public final static String PROJECTION_TRANSFORM = "u_projTrans";
-	public final static String MODEL_TRANSFORM = "u_modelTrans";
-	public final static String NORMAL_TRANSFORM = "u_normalMatrix";
-	
-	private static String defaultVertexShader = null;
-	public final static String getDefaultVertexShader() {
-		if (defaultVertexShader == null)
-			defaultVertexShader = Gdx.files.classpath("com/badlogic/gdx/graphics/g3d/xoppa/test/test.vertex.glsl").readString();
-		return defaultVertexShader;
-	}
-	
-	private static String defaultFragmentShader = null;
-	public final static String getDefaultFragmentShader() {
-		if (defaultFragmentShader == null)
-			defaultFragmentShader = Gdx.files.classpath("com/badlogic/gdx/graphics/g3d/xoppa/test/test.fragment.glsl").readString();
-		return defaultFragmentShader;
-	}
-
-	protected static long implementedFlags = BlendingAttribute.Type | TextureAttribute.Diffuse | ColorAttribute.Diffuse;
-	protected static boolean ignoreUnimplemented = false;
-	
-	protected final ShaderProgram program;
-	protected int projTransLoc;
-	protected int modelTransLoc;
-	protected int normalTransLoc;
-	protected int diffuseTextureLoc;
-	protected int diffuseColorLoc;
-	protected int lightsCount = 5;
-	protected int lightsLoc;
-	protected int lightSize;
-	protected int lightPositionOffset;
-	protected int lightPowerOffset;
-	
-	private Light[] currentLights = new Light[lightsCount];
-	
-	protected RenderContext context;
-	protected long mask;
-	
-	public TestShader(final NewMaterial material) {
-		this(getDefaultVertexShader(), getDefaultFragmentShader(), material);
-	}
-	
-	public TestShader(final long mask) {
-		this(getDefaultVertexShader(), getDefaultFragmentShader(), mask);
-	}
-
-	public TestShader(final String vertexShader, final String fragmentShader, final NewMaterial material) {
-		this(vertexShader, fragmentShader, material.getMask());
-	}
-	
-	public TestShader(final String vertexShader, final String fragmentShader, final long mask) {
-		String prefix = "";
-		this.mask = mask;
-		
-		if (!ignoreUnimplemented && (implementedFlags & mask) != mask)
-			throw new GdxRuntimeException("Some attributes not implemented yet ("+mask+")");
-		
-		if (lightsCount > 0)
-			prefix += "#define lightsCount "+lightsCount+"\n";
-		if ((mask & BlendingAttribute.Type) == BlendingAttribute.Type)
-			prefix += "#define "+BlendingAttribute.Alias+"Flag\n";
-		if ((mask & TextureAttribute.Diffuse) == TextureAttribute.Diffuse)
-			prefix += "#define "+TextureAttribute.DiffuseAlias+"Flag\n";
-		if ((mask & ColorAttribute.Diffuse) == ColorAttribute.Diffuse)
-			prefix += "#define "+ColorAttribute.DiffuseAlias+"Flag\n";
-		
-		program = new ShaderProgram(prefix + vertexShader, prefix + fragmentShader);
-		if (!program.isCompiled())
-			throw new GdxRuntimeException(program.getLog());
-		
-		projTransLoc = program.getUniformLocation(PROJECTION_TRANSFORM);
-		modelTransLoc = program.getUniformLocation(MODEL_TRANSFORM);
-		normalTransLoc = program.getUniformLocation(NORMAL_TRANSFORM);
-		diffuseTextureLoc = ((mask & TextureAttribute.Diffuse) != TextureAttribute.Diffuse) ? -1 : program.getUniformLocation(TextureAttribute.DiffuseAlias);
-		diffuseColorLoc = ((mask & ColorAttribute.Diffuse) != ColorAttribute.Diffuse) ? -1 : program.getUniformLocation(ColorAttribute.DiffuseAlias);
-		lightsLoc = lightsCount > 0 ? program.getUniformLocation("lights[0].color") : -1;
-		lightSize = (lightsLoc >= 0 && lightsCount > 1) ? (program.getUniformLocation("lights[1].color") - lightsLoc) : -1;
-		lightPositionOffset = lightsLoc >= 0 ? program.getUniformLocation("lights[0].position") - lightsLoc : -1;
-		lightPowerOffset = lightsLoc >= 0 ? program.getUniformLocation("lights[0].power") - lightsLoc : -1;
-	}
-	
-	@Override
-	public boolean canRender(final RenderInstance instance) {
-		return mask == instance.renderable.material.getMask();
-	}
-	
-	/*@Override
-	public int compareTo (final Object other) {
-		return (other instanceof RenderShader) ? compareTo((RenderShader)other) : -1;
-	}*/
-	
-	@Override
-	public int compareTo(Shader other) {
-		// TODO Auto-generated method stub
-		return 0;
-	}
-	
-	@Override
-	public boolean equals (Object obj) {
-		return (obj instanceof TestShader) ? equals((TestShader)obj) : false;
-	}
-	
-	public boolean equals (TestShader obj) {
-		return (obj == this);
-	}
-	
-	@Override
-	public int compare (final RenderInstance arg0, final RenderInstance arg1) {
-		final boolean b1 = arg0.renderable.material.has(BlendingAttribute.Type);
-		final boolean b2 = arg1.renderable.material.has(BlendingAttribute.Type);
-		if (b1 != b2) return b1 ? 1 : -1;
-		return arg0.distance > arg1.distance ? (b1 ? -1 : 1) : (arg0.distance < arg1.distance ? (b1 ? 1 : -1) : 0);
-	}
-
-	private Mesh currentMesh;
-	private Matrix4 currentTransform;
-	private Matrix3 normalMatrix = new Matrix3();
-	private Camera camera;
-	
-	@Override
-	public void begin (final Camera camera, final RenderContext context) {
-		this.context = context;
-		this.camera = camera;
-		program.begin();
-		context.setDepthTest(true, GL10.GL_LEQUAL);
-		program.setUniformMatrix(projTransLoc, camera.combined);
-		for (int i = 0; i < currentLights.length; i++)
-			currentLights[i] = null;
-	}
-
-	@Override
-	public void render (NewModel model, Matrix4 transform, final Light[] lights) {
-		transform.getTranslation(Vector3.tmp);
-		float dist = Vector3.tmp2.set(Vector3.tmp.x - camera.position.x, Vector3.tmp.y - camera.position.y , Vector3.tmp.z - camera.position.z).len();
-		if (Vector3.tmp2.div(dist).dot(camera.direction) < 0)
-			dist = -dist;
-		for (Renderable renderable : model.getParts(dist)) {
-			final RenderInstance instance = RenderInstance.pool.obtain(renderable, transform, dist, lights, null);
-			render(instance);
-			RenderInstance.pool.free(instance);
-		}
-	}
-	
-	@Override
-	public void render (final RenderInstance instance) {
-		if (!instance.renderable.material.has(BlendingAttribute.Type))
-			context.setBlending(false, GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
-		if (currentTransform != instance.transform) {
-			program.setUniformMatrix(modelTransLoc, currentTransform = instance.transform);
-			program.setUniformMatrix(normalTransLoc, normalMatrix.set(currentTransform));
-		}
-		bindMaterial(instance);
-		if (lightsLoc >= 0)
-			bindLights(instance);
-		if (currentMesh != instance.renderable.mesh) {
-			if (currentMesh != null)
-				currentMesh.unbind(program);
-			(currentMesh = instance.renderable.mesh).bind(program);
-		}
-		instance.renderable.mesh.render(program, instance.renderable.primitiveType, instance.renderable.meshPartOffset, instance.renderable.meshPartSize);
-	}
-
-	@Override
-	public void end () {
-		if (currentMesh != null) {
-			currentMesh.unbind(program);
-			currentMesh = null;
-		}
-		currentTransform = null;
-		currentTextureAttribute = null;
-		currentMaterial = null;
-		program.end();
-	}
-	
-	/////// bindMaterial /////////
-	NewMaterial currentMaterial;
-	private final void bindMaterial(final RenderInstance instance) {
-		if (currentMaterial == instance.renderable.material)
-			return;
-		currentMaterial = instance.renderable.material;
-		for (NewMaterial.Attribute attr : currentMaterial) {
-			long t = attr.getType();
-			if (BlendingAttribute.is(t))
-				context.setBlending(true, ((BlendingAttribute)attr).sourceFunction, ((BlendingAttribute)attr).destFunction);
-			else if (ColorAttribute.is(t)) {
-				ColorAttribute col = (ColorAttribute)attr;
-				if ((t & ColorAttribute.Diffuse) == ColorAttribute.Diffuse)
-					program.setUniformf(diffuseColorLoc, col.color);
-				// TODO else if (..)
-			}
-			else if (TextureAttribute.is(t)) {
-				TextureAttribute tex = (TextureAttribute)attr;
-				if ((t & TextureAttribute.Diffuse) == TextureAttribute.Diffuse)
-					bindTextureAttribute(diffuseTextureLoc, tex);
-				// TODO else if (..)
-			}  
-			else 
-				throw new GdxRuntimeException("unknown attribute");
-		}
-	}
-
-	/////// bindTextureAttribute /////////
-	TextureAttribute currentTextureAttribute;
-	private final void bindTextureAttribute(final int uniform, final TextureAttribute attribute) {
-		final int unit = context.textures.bindTexture(attribute.textureDescription);
-		program.setUniformi(uniform, unit);
-		currentTextureAttribute = attribute;
-	}
-	 
-	private final void bindLights(final RenderInstance instance) {
-		for (int i = 0; i < lightsCount; i++) {
-			final int loc = lightsLoc + i * lightSize;
-			if (instance.lights.length <= i) {
-				if (currentLights[i] != null) {
-					program.setUniformf(loc + lightPowerOffset, 0f);
-					currentLights[i] = null;
-				}
-			}
-			else {
-				if (currentLights[i] != instance.lights[i]) {
-					program.setUniformf(loc, instance.lights[i].color);
-					program.setUniformf(loc + lightPositionOffset, instance.lights[i].position);
-					program.setUniformf(loc + lightPowerOffset, instance.lights[i].power);
-					currentLights[i] = instance.lights[i];
-				}
-			}
-		}
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/test.fragment.glsl b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/test.fragment.glsl
deleted file mode 100644
index c983060..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/test.fragment.glsl
+++ /dev/null
@@ -1,74 +0,0 @@
-#ifdef GL_ES 
-#define LOWP lowp
-#define MED mediump
-#define HIGH highp
-precision mediump float;
-#else
-#define MED
-#define LOWP
-#endif
-
-varying vec3 v_normal;
-
-#if defined(diffuseTextureFlag) || defined(specularTextureFlag)
-varying MED vec2 v_texCoords0;
-#endif
-
-#ifdef diffuseColorFlag
-uniform vec4 diffuseColor;
-#endif
-
-#ifdef diffuseTextureFlag
-uniform sampler2D diffuseTexture;
-#endif
-
-#ifdef specularColorFlag
-uniform vec4 specularColor;
-#endif
-
-#ifdef specularTextureFlag
-uniform sampler2D specularTexture;
-#endif
-
-#if defined(lightsCount)
-#if (lightsCount > 0)
-#define NUM_LIGHTS lightsCount
-struct Light
-{
-	vec4 color;
-	vec3 position;
-	float power;
-};
-uniform Light lights[NUM_LIGHTS];
-
-varying vec3 v_lightLambert;
-#endif
-#endif
-
-void main() {
-	#if defined(diffuseTextureFlag) && defined(diffuseColorFlag)
-		vec4 diffuse = texture2D(diffuseTexture, v_texCoords0) * diffuseColor;
-	#elif defined(diffuseTextureFlag)
-		vec4 diffuse = texture2D(diffuseTexture, v_texCoords0);
-	#elif defined(diffuseColorFlag)
-		vec4 diffuse = diffuseColor;
-	#else
-		vec4 diffuse = vec4(1.0);
-	#endif
-
-	#if defined(specularTextureFlag) && defined(specularColorFlag)
-		vec4 specular = texture2D(specularTexture, v_texCoords0) * specularColor;
-	#elif defined(specularTextureFlag)
-		vec4 specular = texture2D(specularTexture, v_texCoords0);
-	#elif defined(specularColorFlag)
-		vec4 specular = specularColor;
-	#else
-		vec4 specular = vec4(1.0);
-	#endif
-	
-	#ifdef NUM_LIGHTS
-		diffuse.rgb *= v_lightLambert;
-	#endif
-	
-	gl_FragColor.rgb = diffuse.rgb;
-}
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/test.vertex.glsl b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/test.vertex.glsl
deleted file mode 100644
index 6ca4d05..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/test/test.vertex.glsl
+++ /dev/null
@@ -1,63 +0,0 @@
-#if defined(diffuseTextureFlag) || defined(specularTextureFlag)
-#define textureFlag
-#endif
-
-attribute vec3 a_position;
-attribute vec3 a_normal;
-
-uniform mat3 u_normalMatrix;
-varying vec3 v_normal;
-
-#ifdef textureFlag
-attribute vec2 a_texCoord0;
-varying vec2 v_texCoords0;
-#endif
-
-#if defined(lightsCount) 
-#if (lightsCount > 0)
-#define NUM_LIGHTS lightsCount
-struct Light
-{
-	vec4 color;
-	vec3 position;
-	float power;
-};
-uniform Light lights[NUM_LIGHTS];
-
-varying vec3 v_lightLambert;
-#endif
-#endif
-
-uniform mat4 u_projTrans;
-uniform mat4 u_modelTrans;
-
-void main() {
-	#ifdef textureFlag
-		v_texCoords0 = a_texCoord0;
-	#endif
-		
-	vec4 pos = u_modelTrans * vec4(a_position, 1.0);
-	gl_Position = u_projTrans * pos;
-	v_normal = u_normalMatrix * a_normal;
-	
-	#ifdef NUM_LIGHTS
-	vec3 aggDir = vec3(0.0);
-	float aggWeight = 0.0;
-	vec3 aggCol = vec3(0.0);
-	
-	for (int i = 0; i < NUM_LIGHTS; i++) {
-		if (lights[i].power > 0.0) {
-			vec3 diff = lights[i].position - vec3(pos);
-			
-			float invLen = inversesqrt(dot(diff, diff));
-			vec3 intensity = lights[i].color.rgb * invLen;
-			
-			float lambert = dot(normalize(v_normal), diff * invLen) * 0.5 + 0.5;
-			float weight = lights[i].power * invLen * lambert; 
-
-			aggCol += vec3(lights[i].color) * weight;
-		}
-	}
-	v_lightLambert = clamp(aggCol, 0.0, 1.0);
-	#endif
-}
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/utils/Binder.java b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/utils/Binder.java
deleted file mode 100644
index 73fcaed..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/utils/Binder.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.xoppa.utils;
-
-
-public class Binder {
-	public final ExclusiveTextures textures;
-	
-	public Binder(final ExclusiveTextures textures) {
-		this.textures = textures;
-	}
-	
-	
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/utils/ExclusiveTextures.java b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/utils/ExclusiveTextures.java
deleted file mode 100644
index 779ea66..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/utils/ExclusiveTextures.java
+++ /dev/null
@@ -1,171 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.xoppa.utils;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.graphics.GL10;
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.Texture;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-
-/** Class that you assign a range of texture units and binds textures for you within that range.
- * It does some basic usage tracking to avoid unnessecary bind calls. 
- * @author xoppa */
-public final class ExclusiveTextures {
-	public final static int ROUNDROBIN = 0;
-	public final static int WEIGHTED = 1;
-	/** GLES only supports up to 32 textures */
-	public final static int MAX_GLES_UNITS = 32;
-	/** The index of the first exclusive texture unit */
-	private final int offset;
-	/** The amount of exclusive textures that may be used */
-	private final int count;
-	/** The weight added to a texture when its reused */
-	private final int reuseWeight;
-	/** The textures currently exclusive bound */
-	private final TextureDescription[] textures;
-	/** The weight (reuseWeight * reused - discarded) of the textures */
-	private final int[] weights;
-	/** The method of binding to use */
-	private final int method;
-	/** Flag to indicate the current texture is reused */
-	private boolean reused;
-	
-	private int reuseCount = 0; // TODO remove debug code
-	private int bindCount = 0; // TODO remove debug code
-	
-	/** Uses all available texture units and reuse weight of 3 */
-	public ExclusiveTextures(final int method) {
-		this(method, 0);
-	}
-	
-	/** Uses all remaining texture units and reuse weight of 3 */
-	public ExclusiveTextures(final int method, final int offset) {
-		this(method, offset, GL10.GL_MAX_TEXTURE_UNITS - offset);
-	}
-	
-	/** Uses reuse weight of 10 */
-	public ExclusiveTextures(final int method, final int offset, final int count) {
-		this(method, offset, count, 10);
-	}
-	
-	public ExclusiveTextures(final int method, final int offset, final int count, final int reuseWeight) {
-		int max = Math.max(GL10.GL_MAX_TEXTURE_UNITS, MAX_GLES_UNITS - offset);
-		if (offset < 0 || count < 0 || (offset + count) > max || reuseWeight < 1)
-			throw new GdxRuntimeException("Illegal arguments");
-		this.method = method;
-		this.offset = offset;
-		this.count = count;
-		this.textures = new TextureDescription[count];
-		for (int i = 0; i < count; i++)
-			this.textures[i] = new TextureDescription();
-		this.reuseWeight = reuseWeight;
-		this.weights = (method == WEIGHTED) ? new int[count] : null;
-	}
-
-	private final TextureDescription tempDesc = new TextureDescription();
-	/** @deprecated
-	 * Binds the texture if needed and sets it active, returns the unit */
-	public final int bindTexture(final Texture texture) {
-		tempDesc.reset();
-		tempDesc.texture = texture;
-		return bindTexture(tempDesc, false);
-	}
-	
-	/** Binds the texture if needed and sets it active, returns the unit */
-	public final int bindTexture(final TextureDescription textureDesc) {
-		return bindTexture(textureDesc, false);
-	}
-
-	/** @deprecated 
-	 * Force binds the texture and sets it active, returns the unit */
-	public final int rebindTexture(final Texture texture) {
-		tempDesc.reset();
-		tempDesc.texture = texture;
-		return bindTexture(tempDesc, true);
-	}
-	
-	/** Force binds the texture and sets it active, returns the unit */
-	public final int rebindTexture(final TextureDescription textureDesc) {
-		return bindTexture(textureDesc, true);
-	}
-	
-	/** Removes the reference to the texture, to assure that it will be rebound at the next bind call */
-	public final void unbindTexture(final Texture texture) {
-		for (int i = 0; i < count; i++) {
-			if (textures[i].texture == texture) {
-				textures[i] = null;
-				weights[i] = 0;
-				return;
-			}
-		}
-	}
-	
-	private final int bindTexture(final TextureDescription textureDesc, final boolean rebind) {
-		int idx, result;
-		reused = false;
-		
-		switch (method) {
-		case ROUNDROBIN: result = offset + (idx = bindTextureRoundRobin(textureDesc.texture)); break;
-		case WEIGHTED: result = offset + (idx = bindTextureWeighted(textureDesc.texture)); break;
-		default: return -1; 
-		}
-		
-		if (reused) {
-			reuseCount++;
-			if (rebind)
-				textureDesc.texture.bind(result);
-			else
-				Gdx.gl.glActiveTexture(GL10.GL_TEXTURE0 + result);
-		} else
-			bindCount++;
-		if (textureDesc.minFilter != GL10.GL_INVALID_VALUE && textureDesc.minFilter != textures[idx].minFilter)
-			Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER, textures[idx].minFilter = textureDesc.minFilter);
-		if (textureDesc.magFilter != GL10.GL_INVALID_VALUE && textureDesc.magFilter != textures[idx].magFilter)
-			Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER, textures[idx].magFilter = textureDesc.magFilter);
-		if (textureDesc.uWrap != GL10.GL_INVALID_VALUE && textureDesc.uWrap != textures[idx].uWrap)
-			Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_S, textures[idx].uWrap = textureDesc.uWrap);
-		if (textureDesc.vWrap != GL10.GL_INVALID_VALUE && textureDesc.vWrap != textures[idx].vWrap)
-			Gdx.gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_WRAP_T, textures[idx].vWrap = textureDesc.vWrap);
-		return result;
-	}
-
-	private int currentTexture = 0;
-	private final int bindTextureRoundRobin(final Texture texture) {
-		for (int i = 0; i < count; i++) {
-			final int idx = (currentTexture + i) % count;
-			if (textures[idx].texture == texture) {
-				reused = true;
-				return idx;
-			}
-		}
-		currentTexture = (currentTexture + 1) % count;
-		textures[currentTexture].texture = texture;
-		texture.bind(offset + currentTexture);
-		return currentTexture;
-	}
-	
-	private final int bindTextureWeighted(final Texture texture) {
-		int result = -1;
-		int weight = weights[0];
-		int windex = 0;
-		for (int i = 0; i < count; i++) {
-			if (textures[i].texture == texture) {
-				result = i;
-				weights[i]+=reuseWeight;
-			} else if (weights[i] < 0 || --weights[i] < weight) {
-				weight = weights[i];
-				windex = i;
-			}
-		}
-		if (result < 0) {
-			textures[windex].texture = texture;
-			weights[windex] = 100;
-			texture.bind(offset + (result = windex));
-		} else 
-			reused = true;
-		return result;
-	}
-	
-	public final int getBindCount() { return bindCount; }
-	public final int getReuseCount() { return reuseCount; }
-	public final void resetCounter() { bindCount = reuseCount = 0; }
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/utils/TextureDescription.java b/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/utils/TextureDescription.java
deleted file mode 100644
index 3dcc9db..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/xoppa/utils/TextureDescription.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package com.badlogic.gdx.graphics.g3d.xoppa.utils;
-
-import com.badlogic.gdx.graphics.GL10;
-import com.badlogic.gdx.graphics.Texture;
-
-public class TextureDescription {
-	public Texture texture = null;
-	public int minFilter = GL10.GL_INVALID_VALUE;
-	public int magFilter = GL10.GL_INVALID_VALUE;
-	public int uWrap = GL10.GL_INVALID_VALUE;
-	public int vWrap = GL10.GL_INVALID_VALUE;
-	// TODO add other values, see http://www.opengl.org/sdk/docs/man/xhtml/glTexParameter.xml
-	
-	public TextureDescription(final Texture texture, final int minFilter, final int magFilter, final int uWrap, final int vWrap) {
-		set(texture, minFilter, magFilter, uWrap, vWrap);
-	}
-	
-	public TextureDescription(final Texture texture) {
-		this.texture = texture;
-	}
-	
-	public TextureDescription() {
-	}
-	
-	public void set(final Texture texture, final int minFilter, final int magFilter, final int uWrap, final int vWrap) {
-		this.texture = texture;
-		this.minFilter = minFilter;
-		this.magFilter = magFilter;
-		this.uWrap = uWrap;
-		this.vWrap = vWrap;
-	}
-	
-	public void set(final TextureDescription other) {
-		texture = other.texture;
-		minFilter = other.minFilter;
-		magFilter = other.magFilter;
-		uWrap = other.uWrap;
-		vWrap = other.vWrap;
-	}
-	
-	public void reset() {
-		texture = null;
-		minFilter = GL10.GL_INVALID_VALUE;
-		magFilter = GL10.GL_INVALID_VALUE;
-		uWrap = GL10.GL_INVALID_VALUE;
-		vWrap = GL10.GL_INVALID_VALUE;
-	}
-	
-	@Override
-	public boolean equals (Object obj) {
-		if (obj == null) return false;
-		if (obj == this) return true;
-		if (!(obj instanceof TextureDescription)) return false;
-		final TextureDescription other = (TextureDescription)obj;
-		return other.texture == texture && other.minFilter == minFilter && other.magFilter == magFilter &&
-			other.uWrap == uWrap && other.vWrap == vWrap;
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/ETC1.java b/gdx/src/com/badlogic/gdx/graphics/glutils/ETC1.java
index 6b8880e..492441a 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/ETC1.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/ETC1.java
@@ -23,9 +23,11 @@ import java.nio.ByteBuffer;
 import java.util.zip.GZIPInputStream;
 import java.util.zip.GZIPOutputStream;
 
+import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.files.FileHandle;
 import com.badlogic.gdx.graphics.Pixmap;
 import com.badlogic.gdx.graphics.Pixmap.Format;
+import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.utils.BufferUtils;
 import com.badlogic.gdx.utils.Disposable;
 import com.badlogic.gdx.utils.GdxRuntimeException;
@@ -54,6 +56,7 @@ public class ETC1 {
 			this.height = height;
 			this.compressedData = compressedData;
 			this.dataOffset = dataOffset;
+			checkNPOT();
 		}
 
 		public ETC1Data (FileHandle pkmFile) {
@@ -82,6 +85,13 @@ public class ETC1 {
 			height = getHeightPKM(compressedData, 0);
 			dataOffset = PKM_HEADER_SIZE;
 			compressedData.position(dataOffset);
+			checkNPOT();
+		}
+		
+		private void checkNPOT() {
+			if(!MathUtils.isPowerOfTwo(width) || !MathUtils.isPowerOfTwo(height)) {
+				Gdx.app.debug("ETC1Data", "warning: non-power-of-two ETC1 textures may crash the driver of PowerVR GPUs");
+			}
 		}
 
 		/** @return whether this ETC1Data has a PKM header */
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/FrameBuffer.java b/gdx/src/com/badlogic/gdx/graphics/glutils/FrameBuffer.java
index 0b5bc7f..00b0044 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/FrameBuffer.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/FrameBuffer.java
@@ -119,7 +119,7 @@ public class FrameBuffer implements Disposable {
 		   if (Gdx.app.getType() == ApplicationType.iOS) {
 		     IntBuffer intbuf = ByteBuffer.allocateDirect(16 * Integer.SIZE / 8).order(ByteOrder.nativeOrder()).asIntBuffer();
 		     gl.glGetIntegerv(GL20.GL_FRAMEBUFFER_BINDING, intbuf);
-		     defaultFramebufferHandle = intbuf.get();
+		     defaultFramebufferHandle = intbuf.get(0);
 		   }
 		   else {
 		     defaultFramebufferHandle = 0;
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/ShaderProgram.java b/gdx/src/com/badlogic/gdx/graphics/glutils/ShaderProgram.java
index 9403f88..8a91c61 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/ShaderProgram.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/ShaderProgram.java
@@ -99,6 +99,9 @@ public class ShaderProgram implements Disposable {
 	/** uniform types **/
 	private final ObjectIntMap<String> uniformTypes = new ObjectIntMap<String>();
 
+	/** uniform sizes **/
+	private final ObjectIntMap<String> uniformSizes = new ObjectIntMap<String>();
+
 	/** uniform names **/
 	private String[] uniformNames;
 
@@ -108,6 +111,9 @@ public class ShaderProgram implements Disposable {
 	/** attribute types **/
 	private final ObjectIntMap<String> attributeTypes = new ObjectIntMap<String>();
 
+	/** attribute sizes **/
+	private final ObjectIntMap<String> attributeSizes = new ObjectIntMap<String>();
+
 	/** attribute names **/
 	private String[] attributeNames;
 
@@ -829,12 +835,13 @@ public class ShaderProgram implements Disposable {
 
 		for (int i = 0; i < numUniforms; i++) {
 			params.clear();
-			params.put(0, 256);
+			params.put(0, 1);
 			type.clear();
 			String name = Gdx.gl20.glGetActiveUniform(program, i, params, type);
 			int location = Gdx.gl20.glGetUniformLocation(program, name);
 			uniforms.put(name, location);
 			uniformTypes.put(name, type.get(0));
+			uniformSizes.put(name, params.get(0));
 			uniformNames[i] = name;
 		}
 	}
@@ -848,12 +855,13 @@ public class ShaderProgram implements Disposable {
 
 		for (int i = 0; i < numAttributes; i++) {
 			params.clear();
-			params.put(0, 256);
+			params.put(0, 1);
 			type.clear();
 			String name = Gdx.gl20.glGetActiveAttrib(program, i, params, type);
 			int location = Gdx.gl20.glGetAttribLocation(program, name);
 			attributes.put(name, location);
 			attributeTypes.put(name, type.get(0));
+			attributeSizes.put(name, params.get(0));
 			attributeNames[i] = name;
 		}
 	}
@@ -884,6 +892,16 @@ public class ShaderProgram implements Disposable {
 			return location;
 	}
 
+	/** @param name the name of the attribute
+	 * @return the size of the attribute or 0. */
+	public int getAttributeSize (String name) {
+		int size = attributeSizes.get(name, -1);
+		if (size == -1)
+			return 0;
+		else
+			return size;
+	}
+
 	/** @param name the name of the uniform
 	 * @return whether the uniform is available in the shader */
 	public boolean hasUniform (String name) {
@@ -910,6 +928,16 @@ public class ShaderProgram implements Disposable {
 			return location;
 	}
 
+	/** @param name the name of the uniform
+	 * @return the size of the uniform or 0. */
+	public int getUniformSize (String name) {
+		int size = uniformSizes.get(name, -1);
+		if (size == -1)
+			return 0;
+		else
+			return size;
+	}
+
 	/** @return the attributes */
 	public String[] getAttributes () {
 		return attributeNames;
diff --git a/gdx/src/com/badlogic/gdx/maps/MapLayers.java b/gdx/src/com/badlogic/gdx/maps/MapLayers.java
index 73240fc..850bbc1 100644
--- a/gdx/src/com/badlogic/gdx/maps/MapLayers.java
+++ b/gdx/src/com/badlogic/gdx/maps/MapLayers.java
@@ -14,7 +14,7 @@ public class MapLayers implements Iterable<MapLayer> {
 	 * @param index
 	 * @return layer at index
 	 */
-	public MapLayer getLayer(int index) {
+	public MapLayer get(int index) {
 		return layers.get(index);
 	}
 	
@@ -22,7 +22,7 @@ public class MapLayers implements Iterable<MapLayer> {
 	 * @param name
 	 * @return first layer matching the name, null otherwise
 	 */
-	public MapLayer getLayer(String name) {
+	public MapLayer get(String name) {
 		for (MapLayer layer : layers) {
 			if (name.equals(layer.getName())) {
 				return layer;
@@ -31,24 +31,29 @@ public class MapLayers implements Iterable<MapLayer> {
 		return null;
 	}
 	
+	/** @return number of layers in the collection */
+	public int getCount() {
+		return layers.size;
+	}
+
 	/**
 	 * @param layer layer to be added to the set
 	 */
-	public void addLayer(MapLayer layer) {
+	public void add(MapLayer layer) {
 		this.layers.add(layer);
 	}
 	
 	/**
 	 * @param index removes layer at index
 	 */
-	public void removeLayer(int index) {
+	public void remove(int index) {
 		layers.removeIndex(index);
 	}
 	
 	/**
 	 * @param layer layer to be removed
 	 */
-	public void removeLayer(MapLayer layer) {
+	public void remove(MapLayer layer) {
 		layers.removeValue(layer, true);
 	}
 
@@ -56,8 +61,8 @@ public class MapLayers implements Iterable<MapLayer> {
 	 * @param type
 	 * @return array with all the layers matching type
 	 */
-	public <T extends MapLayer> Array<T> getLayersByType(Class<T> type) {
-		return getLayersByType(type, new Array<T>());	
+	public <T extends MapLayer> Array<T> getByType(Class<T> type) {
+		return getByType(type, new Array<T>());
 	}
 	
 	/**
@@ -66,7 +71,7 @@ public class MapLayers implements Iterable<MapLayer> {
 	 * @param fill array to be filled with the matching layers
 	 * @return array with all the layers matching type
 	 */
-	public <T extends MapLayer> Array<T> getLayersByType(Class<T> type, Array<T> fill) {
+	public <T extends MapLayer> Array<T> getByType(Class<T> type, Array<T> fill) {
 		fill.clear();
 		for (MapLayer layer : layers) {
 			if (type.isInstance(layer)) {
diff --git a/gdx/src/com/badlogic/gdx/maps/MapObjects.java b/gdx/src/com/badlogic/gdx/maps/MapObjects.java
index 80ecce5..2099ec0 100644
--- a/gdx/src/com/badlogic/gdx/maps/MapObjects.java
+++ b/gdx/src/com/badlogic/gdx/maps/MapObjects.java
@@ -15,14 +15,14 @@ public class MapObjects implements Iterable<MapObject> {
 	 * Creates and empty set of MapObject instances
 	 */
 	public MapObjects() {
-		objects = new Array<MapObject>();		
+		objects = new Array<MapObject>();
 	}
 	
 	/**
 	 * @param index
 	 * @return MapObject at index
 	 */
-	public MapObject getObject(int index) {
+	public MapObject get(int index) {
 		return objects.get(index);
 	}
 	
@@ -30,7 +30,7 @@ public class MapObjects implements Iterable<MapObject> {
 	 * @param name
 	 * @return name matching object, null if it´s not in the set
 	 */
-	public MapObject getObject(String name) {
+	public MapObject get(String name) {
 		for (MapObject object : objects) {
 			if (name.equals(object.getName())) {
 				return object;
@@ -42,28 +42,28 @@ public class MapObjects implements Iterable<MapObject> {
 	/**
 	 * @param object instance to be added to the collection
 	 */
-	public void addObject(MapObject object) {
+	public void add(MapObject object) {
 		this.objects.add(object);
 	}
 	
 	/**
 	 * @param index removes MapObject instance at index
 	 */
-	public void removeObject(int index) {
+	public void remove(int index) {
 		objects.removeIndex(index);
 	}
 	
 	/**
 	 * @param object instance to be removed
 	 */
-	public void removeObject(MapObject object) {
+	public void remove(MapObject object) {
 		objects.removeValue(object, true);
 	}
 	
 	/**
 	 * @return number of objects in the collection
 	 */
-	public int getNumObjects() {
+	public int getCount() {
 		return objects.size;
 	}
 
@@ -71,8 +71,8 @@ public class MapObjects implements Iterable<MapObject> {
 	 * @param type class of the objects we want to retrieve
 	 * @return array filled with all the objects in the collection matching type
 	 */
-	public <T extends MapObject> Array<T> getObjectsByType(Class<T> type) {
-		return getObjectsByType(type, new Array<T>());	
+	public <T extends MapObject> Array<T> getByType(Class<T> type) {
+		return getByType(type, new Array<T>());
 	}
 	
 	/**
@@ -80,7 +80,7 @@ public class MapObjects implements Iterable<MapObject> {
 	 * @param fill collection to put the returned objects in
 	 * @return array filled with all the objects in the collection matching type
 	 */
-	public <T extends MapObject> Array<T> getObjectsByType(Class<T> type, Array<T> fill) {
+	public <T extends MapObject> Array<T> getByType(Class<T> type, Array<T> fill) {
 		fill.clear();
 		for (MapObject object : objects) {
 			if (type.isInstance(object)) {
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/TideMapLoader.java b/gdx/src/com/badlogic/gdx/maps/tiled/TideMapLoader.java
index ca39741..a287df5 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/TideMapLoader.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/TideMapLoader.java
@@ -182,7 +182,7 @@ public class TideMapLoader extends SynchronousAssetLoader<TiledMap, TideMapLoade
 				}
 			}
 			
-			Element properties = element.getChildByName("Proeprties");
+			Element properties = element.getChildByName("Properties");
 			if (properties != null) {
 				loadProperties(tileset.getProperties(), properties);
 			}
@@ -252,7 +252,7 @@ public class TideMapLoader extends SynchronousAssetLoader<TiledMap, TideMapLoade
 					}
 				}
 			}
-			map.getLayers().addLayer(layer);
+			map.getLayers().add(layer);
 		}
 	}
 	
@@ -264,11 +264,11 @@ public class TideMapLoader extends SynchronousAssetLoader<TiledMap, TideMapLoade
 				String value = property.getText();
 				
 				if (type.equals("Int32")) {
-					
+					properties.put(key, Integer.parseInt(value));
 				} else if (type.equals("String")) {
-					
+					properties.put(key, value);
 				} else if (type.equals("Boolean")) {
-					
+					properties.put(key, value.equalsIgnoreCase("true"));
 				} else {
 					properties.put(key, value);					
 				}
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/TiledMap.java b/gdx/src/com/badlogic/gdx/maps/tiled/TiledMap.java
index e8a0552..75a2b10 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/TiledMap.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/TiledMap.java
@@ -34,7 +34,7 @@ public class TiledMap extends Map {
 	 * {@link #dispose()}.
 	 * @param textures
 	 */
-	void setOwnedTextures(Array<Texture> textures) {
+	public void setOwnedTextures(Array<Texture> textures) {
 		this.ownedTextures = textures;
 	}
 	
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/TmxMapLoader.java b/gdx/src/com/badlogic/gdx/maps/tiled/TmxMapLoader.java
index 31270ad..1941297 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/TmxMapLoader.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/TmxMapLoader.java
@@ -12,6 +12,8 @@ import com.badlogic.gdx.assets.AssetLoaderParameters;
 import com.badlogic.gdx.assets.AssetManager;
 import com.badlogic.gdx.assets.loaders.FileHandleResolver;
 import com.badlogic.gdx.assets.loaders.SynchronousAssetLoader;
+import com.badlogic.gdx.assets.loaders.TextureLoader;
+import com.badlogic.gdx.assets.loaders.TextureLoader.TextureParameter;
 import com.badlogic.gdx.assets.loaders.resolvers.InternalFileHandleResolver;
 import com.badlogic.gdx.files.FileHandle;
 import com.badlogic.gdx.graphics.Texture;
@@ -44,7 +46,9 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 
 	public static class Parameters extends AssetLoaderParameters<TiledMap> {
 		/** Whether to load the map for a y-up coordinate system */
-		boolean yUp = true;
+		public boolean yUp = true;
+		/** generate mipmaps? **/
+		public boolean generateMipMaps = false;
 	}
 	
 	protected static final int FLAG_FLIP_HORIZONTALLY = 0x80000000;
@@ -81,7 +85,7 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 	 * @return the TiledMap
 	 */
 	public TiledMap load(String fileName) {
-		return load(fileName, true);
+		return load(fileName, new TmxMapLoader.Parameters());
 	}
 
 	/**
@@ -89,17 +93,17 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 	 * resolved via the {@link FileHandleResolver} set in the constructor
 	 * of this class. By default it will resolve to an internal file.
 	 * @param fileName the filename
-	 * @param yUp whether to load the map for a y-up coordinate system
+	 * @param parameters specifies whether to use y-up, generate mip maps etc.
 	 * @return the TiledMap
 	 */
-	public TiledMap load(String fileName, boolean yUp) {
+	public TiledMap load(String fileName, TmxMapLoader.Parameters parameters) {
 		try {
-			this.yUp = yUp;
+			this.yUp = parameters.yUp;
 			FileHandle tmxFile = resolve(fileName);
 			root = xml.parse(tmxFile);
 			ObjectMap<String, Texture> textures = new ObjectMap<String, Texture>();
 			for(FileHandle textureFile: loadTilesets(root, tmxFile)) {
-				textures.put(textureFile.path(), new Texture(textureFile));
+				textures.put(textureFile.path(), new Texture(textureFile, parameters.generateMipMaps));
 			}
 			DirectImageResolver imageResolver = new DirectImageResolver(textures);
 			TiledMap map = loadTilemap(root, tmxFile, imageResolver);
@@ -138,8 +142,11 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 		try {
 			FileHandle tmxFile = resolve(fileName);
 			root = xml.parse(tmxFile);
+			boolean generateMipMaps = (parameter!=null?parameter.generateMipMaps: false);
+			TextureLoader.TextureParameter texParams = new TextureParameter();
+			texParams.genMipMaps = generateMipMaps;
 			for(FileHandle image: loadTilesets(root, tmxFile)) {
-				dependencies.add(new AssetDescriptor(image.path(), Texture.class));
+				dependencies.add(new AssetDescriptor(image.path(), Texture.class, texParams));
 			}
 			return dependencies;
 		} catch (IOException e) {
@@ -225,6 +232,34 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 		return images;
 	}
 
+	/**
+	 * Loads the specified tileset data, adding it to the collection of the specified map, given the XML element, the tmxFile 
+	 * and an {@link ImageResolver} used to retrieve the tileset Textures.
+	 *
+	 * <p>
+	 * Default tileset's property keys that are loaded by default are:
+	 * </p>
+	 *
+	 * <ul>
+	 * <li><em>firstgid</em>, (int, defaults to 1) the first valid global id used for tile numbering</li>
+	 * <li><em>imagesource</em>, (String, defaults to empty string) the tileset source image filename</li>
+	 * <li><em>imagewidth</em>, (int, defaults to 0) the tileset source image width</li>
+	 * <li><em>imageheight</em>, (int, defaults to 0) the tileset source image height</li>
+	 * <li><em>tilewidth</em>, (int, defaults to 0) the tile width</li>
+	 * <li><em>tileheight</em>, (int, defaults to 0) the tile height</li>
+	 * <li><em>margin</em>, (int, defaults to 0) the tileset margin</li>
+	 * <li><em>spacing</em>, (int, defaults to 0) the tileset spacing</li>
+	 * </ul>
+	 *
+	 * <p>
+	 * The values are extracted from the specified Tmx file, if a value can't be found then the default is used.
+	 * </p>
+	 * @param map the Map whose tilesets collection will be populated
+	 * @param element the XML element identifying the tileset to load
+	 * @param tmxFile the Filehandle of the tmx file
+	 * @param imageResolver the {@link ImageResolver}
+	 */
+
 	protected void loadTileSet(TiledMap map, Element element, FileHandle tmxFile, ImageResolver imageResolver) {
 		if (element.getName().equals("tileset")) {
 			String name = element.get("name", null);
@@ -234,6 +269,10 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 			int spacing = element.getIntAttribute("spacing", 0);
 			int margin = element.getIntAttribute("margin", 0);			
 			String source = element.getAttribute("source", null);
+
+			String imageSource = "";
+			int imageWidth = 0, imageHeight = 0;
+
 			FileHandle image = null;
 			if (source != null) {
 				FileHandle tsx = getRelativeFileHandle(tmxFile, source);
@@ -244,21 +283,34 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 					tileheight = element.getIntAttribute("tileheight", 0);
 					spacing = element.getIntAttribute("spacing", 0);
 					margin = element.getIntAttribute("margin", 0);
-					String imageSource = element.getChildByName("image").getAttribute("source");
+					imageSource = element.getChildByName("image").getAttribute("source");
+					imageWidth = element.getChildByName("image").getIntAttribute("width", 0);
+					imageHeight = element.getChildByName("image").getIntAttribute("height", 0);
 					image = getRelativeFileHandle(tsx, imageSource);
 				} catch (IOException e) {
 					throw new GdxRuntimeException("Error parsing external tileset.");
 				}
 			} else {
-				String imageSource = element.getChildByName("image").getAttribute("source");
+				imageSource = element.getChildByName("image").getAttribute("source");
+				imageWidth = element.getChildByName("image").getIntAttribute("width", 0);
+				imageHeight = element.getChildByName("image").getIntAttribute("height", 0);
 				image = getRelativeFileHandle(tmxFile, imageSource);
 			}
 
 			TextureRegion texture = imageResolver.getImage(image.path());
 
 			TiledMapTileSet tileset = new TiledMapTileSet();
+			MapProperties props = tileset.getProperties();
 			tileset.setName(name);
-			
+			props.put("firstgid", firstgid);
+			props.put("imagesource", imageSource);
+			props.put("imagewidth", imageWidth);
+			props.put("imageheight", imageHeight);
+			props.put("tilewidth", tilewidth);
+			props.put("tileheight", tileheight);
+			props.put("margin", margin);
+			props.put("spacing", spacing);
+
 			int stopWidth = texture.getRegionWidth() - tilewidth;
 			int stopHeight = texture.getRegionHeight() - tileheight;
 
@@ -266,7 +318,7 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 			
 			for (int y = margin; y <= stopHeight; y += tileheight + spacing) {
 				for (int x = margin; x <= stopWidth; x += tilewidth + spacing) {
-					TextureRegion tileRegion = new TextureRegion(new TextureRegion(texture, x, y, tilewidth, tileheight));
+					TextureRegion tileRegion = new TextureRegion(texture, x, y, tilewidth, tileheight);
 					if (!yUp) {
 						tileRegion.flip(false, true);
 					}
@@ -335,14 +387,14 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 							if (flipDiagonally) {
 								if (flipHorizontally && flipVertically) {
 									cell.setFlipHorizontally(true);
-									cell.setRotation(Cell.ROTATE_90);
+									cell.setRotation(Cell.ROTATE_270);
 								} else if (flipHorizontally) {
-									cell.setRotation(Cell.ROTATE_90);
-								} else if (flipVertically) {
 									cell.setRotation(Cell.ROTATE_270);
+								} else if (flipVertically) {
+									cell.setRotation(Cell.ROTATE_90);
 								} else {
 									cell.setFlipVertically(true);
-									cell.setRotation(Cell.ROTATE_90);
+									cell.setRotation(Cell.ROTATE_270);
 								}
 							} else {
 								cell.setFlipHorizontally(flipHorizontally);
@@ -380,14 +432,14 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 									if (flipDiagonally) {
 										if (flipHorizontally && flipVertically) {
 											cell.setFlipHorizontally(true);
-											cell.setRotation(Cell.ROTATE_90);
+											cell.setRotation(Cell.ROTATE_270);
 										} else if (flipHorizontally) {
-											cell.setRotation(Cell.ROTATE_90);
-										} else if (flipVertically) {
 											cell.setRotation(Cell.ROTATE_270);
+										} else if (flipVertically) {
+											cell.setRotation(Cell.ROTATE_90);
 										} else {
 											cell.setFlipVertically(true);
-											cell.setRotation(Cell.ROTATE_90);
+											cell.setRotation(Cell.ROTATE_270);
 										}
 									} else {
 										cell.setFlipHorizontally(flipHorizontally);
@@ -430,14 +482,14 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 										if (flipDiagonally) {
 											if (flipHorizontally && flipVertically) {
 												cell.setFlipHorizontally(true);
-												cell.setRotation(Cell.ROTATE_90);
+												cell.setRotation(Cell.ROTATE_270);
 											} else if (flipHorizontally) {
-												cell.setRotation(Cell.ROTATE_90);
-											} else if (flipVertically) {
 												cell.setRotation(Cell.ROTATE_270);
+											} else if (flipVertically) {
+												cell.setRotation(Cell.ROTATE_90);
 											} else {
 												cell.setFlipVertically(true);
-												cell.setRotation(Cell.ROTATE_90);
+												cell.setRotation(Cell.ROTATE_270);
 											}
 										} else {
 											cell.setFlipHorizontally(flipHorizontally);
@@ -481,14 +533,14 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 										if (flipDiagonally) {
 											if (flipHorizontally && flipVertically) {
 												cell.setFlipHorizontally(true);
-												cell.setRotation(-90);
+												cell.setRotation(Cell.ROTATE_270);
 											} else if (flipHorizontally) {
-												cell.setRotation(-90);
+												cell.setRotation(Cell.ROTATE_270);
 											} else if (flipVertically) {
-												cell.setRotation(+90);
+												cell.setRotation(Cell.ROTATE_90);
 											} else {
 												cell.setFlipVertically(true);
-												cell.setRotation(-90);
+												cell.setRotation(Cell.ROTATE_270);
 											}
 										} else {
 											cell.setFlipHorizontally(flipHorizontally);
@@ -510,7 +562,7 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 			if (properties != null) {
 				loadProperties(layer.getProperties(), properties);
 			}
-			map.getLayers().addLayer(layer);
+			map.getLayers().add(layer);
 		}		
 	}
 	
@@ -528,7 +580,7 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 				loadObject(layer, objectElement);
 			}
 
-			map.getLayers().addLayer(layer);
+			map.getLayers().add(layer);
 		}
 	}
 	
@@ -584,12 +636,14 @@ public class TmxMapLoader extends SynchronousAssetLoader<TiledMap, TmxMapLoader.
 			if (type != null) {
 				object.getProperties().put("type", type);
 			}
+			object.getProperties().put("x", x);
+			object.getProperties().put("y", yUp ? y - height : y);
 			object.setVisible(element.getIntAttribute("visible", 1) == 1);
 			Element properties = element.getChildByName("properties");
 			if (properties != null) {
 				loadProperties(object.getProperties(), properties);
 			}
-			layer.getObjects().addObject(object);
+			layer.getObjects().add(object);
 		}
 	}
 	
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/BatchTiledMapRenderer.java b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/BatchTiledMapRenderer.java
index 742ce12..b4d7188 100755
--- a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/BatchTiledMapRenderer.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/BatchTiledMapRenderer.java
@@ -86,7 +86,7 @@ public abstract class BatchTiledMapRenderer implements TiledMapRenderer, Disposa
 	public void render (int[] layers) {
 		spriteBatch.begin();
 		for (int layerIdx : layers) {
-			MapLayer layer = map.getLayers().getLayer(layerIdx);
+			MapLayer layer = map.getLayers().get(layerIdx);
 			if (layer.isVisible()) {
 				if (layer instanceof TiledMapTileLayer) {
 					renderTileLayer((TiledMapTileLayer) layer);
diff --git a/gdx/src/com/badlogic/gdx/math/BSpline.java b/gdx/src/com/badlogic/gdx/math/BSpline.java
index df3c89a..9eaa0c8 100644
--- a/gdx/src/com/badlogic/gdx/math/BSpline.java
+++ b/gdx/src/com/badlogic/gdx/math/BSpline.java
@@ -50,10 +50,10 @@ public class BSpline<T extends Vector<T>> implements Path<T> {
 		final float dt = 1f - u;
 		final float t2 = u * u;
 		final float t3 = t2 * u;
-		out.set(points[i]).mul((3f * t3 - 6f * t2 + 4f) * d6);
-		if (continuous || i > 0) out.add(tmp.set(points[(n+i-1)%n]).mul(dt * dt * dt * d6));
-		if (continuous || i < (n - 1)) out.add(tmp.set(points[(i + 1)%n]).mul((-3f * t3 + 3f * t2 + 3f * u + 1f) * d6));
-		if (continuous || i < (n - 2)) out.add(tmp.set(points[(i + 2)%n]).mul(t3 * d6));
+		out.set(points[i]).scl((3f * t3 - 6f * t2 + 4f) * d6);
+		if (continuous || i > 0) out.add(tmp.set(points[(n+i-1)%n]).scl(dt * dt * dt * d6));
+		if (continuous || i < (n - 1)) out.add(tmp.set(points[(i + 1)%n]).scl((-3f * t3 + 3f * t2 + 3f * u + 1f) * d6));
+		if (continuous || i < (n - 2)) out.add(tmp.set(points[(i + 2)%n]).scl(t3 * d6));
 		return out;
 	}
 	
@@ -188,4 +188,10 @@ public class BSpline<T extends Vector<T>> implements Path<T> {
 		float u = MathUtils.clamp((L1-s)/L1, 0f, 1f);
 		return ((float)n + u) / spanCount;
 	}
+	
+	@Override
+	public float locate (T v) {
+		// TODO Add a precise method
+		return approximate(v);
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/math/Bezier.java b/gdx/src/com/badlogic/gdx/math/Bezier.java
index 7a5c6ab..b3196d2 100644
--- a/gdx/src/com/badlogic/gdx/math/Bezier.java
+++ b/gdx/src/com/badlogic/gdx/math/Bezier.java
@@ -32,7 +32,7 @@ public class Bezier<T extends Vector<T>> implements Path<T> {
 	 * @param tmp A temporary vector to be used by the calculation.
 	 * @return The value specified by out for chaining */
 	public static <T extends Vector<T>> T linear(final T out, final float t, final T p0, final T p1, final T tmp) {
-		return out.set(p0).mul(1f - t).add(tmp.set(p1).mul(t)); // Could just use lerp...
+		return out.set(p0).scl(1f - t).add(tmp.set(p1).scl(t)); // Could just use lerp...
 	}
 	
 	/** Quadratic Bezier curve 
@@ -45,7 +45,7 @@ public class Bezier<T extends Vector<T>> implements Path<T> {
 	 * @return The value specified by out for chaining */
 	public static <T extends Vector<T>> T quadratic(final T out, final float t, final T p0, final T p1, final T p2, final T tmp) {
 		final float dt = 1f - t;
-		return out.set(p0).mul(dt*dt).add(tmp.set(p1).mul(2*dt*t)).add(tmp.set(p2).mul(t*t));
+		return out.set(p0).scl(dt*dt).add(tmp.set(p1).scl(2*dt*t)).add(tmp.set(p2).scl(t*t));
 	}
 	
 	/** Cubic Bezier curve
@@ -61,7 +61,7 @@ public class Bezier<T extends Vector<T>> implements Path<T> {
 		final float dt = 1f - t;
 		final float dt2 = dt * dt;
 		final float t2 = t * t;
-		return out.set(p0).mul(dt2*dt).add(tmp.set(p1).mul(3*dt2*t)).add(tmp.set(p2).mul(3*dt*t2)).add(tmp.set(p3).mul(t2*t));
+		return out.set(p0).scl(dt2*dt).add(tmp.set(p1).scl(3*dt2*t)).add(tmp.set(p2).scl(3*dt*t2)).add(tmp.set(p3).scl(t2*t));
 	}
 	
 	public Array<T> points = new Array<T>();
@@ -122,4 +122,10 @@ public class Bezier<T extends Vector<T>> implements Path<T> {
 		float s = (l2*l2 + l1*l1 - l3*l3) / (2*l1);
 		return MathUtils.clamp((l1-s)/l1, 0f, 1f);
 	}
+	
+	@Override
+	public float locate (T v) {
+		// TODO implement a precise method
+		return approximate(v);
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/math/CatmullRomSpline.java b/gdx/src/com/badlogic/gdx/math/CatmullRomSpline.java
index 1537ad1..3105f03 100644
--- a/gdx/src/com/badlogic/gdx/math/CatmullRomSpline.java
+++ b/gdx/src/com/badlogic/gdx/math/CatmullRomSpline.java
@@ -16,6 +16,7 @@
 
 package com.badlogic.gdx.math;
 
+import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.utils.Array;
 
 /** @author Xoppa */
@@ -47,10 +48,10 @@ public class CatmullRomSpline<T extends Vector<T>> implements Path<T> {
 		final int n = points.length;
 		final float u2 = u * u;
 		final float u3 = u2 * u;
-		out.set(points[i]).mul(1.5f * u3 - 2.5f * u2 + 1.0f);
-		if (continuous || i > 0) out.add(tmp.set(points[(n+i-1)%n]).mul(-0.5f * u3 + u2 - 0.5f * u));
-		if (continuous || i < (n - 1)) out.add(tmp.set(points[(i + 1)%n]).mul(-1.5f * u3 + 2f * u2 + 0.5f * u));
-		if (continuous || i < (n - 2)) out.add(tmp.set(points[(i + 2)%n]).mul(0.5f * u3 - 0.5f * u2));
+		out.set(points[i]).scl(1.5f * u3 - 2.5f * u2 + 1.0f);
+		if (continuous || i > 0) out.add(tmp.set(points[(n+i-1)%n]).scl(-0.5f * u3 + u2 - 0.5f * u));
+		if (continuous || i < (n - 1)) out.add(tmp.set(points[(i + 1)%n]).scl(-1.5f * u3 + 2f * u2 + 0.5f * u));
+		if (continuous || i < (n - 2)) out.add(tmp.set(points[(i + 2)%n]).scl(0.5f * u3 - 0.5f * u2));
 		return out;
 	}
 	
@@ -58,6 +59,7 @@ public class CatmullRomSpline<T extends Vector<T>> implements Path<T> {
 	public boolean continuous;
 	public int spanCount;
 	private T tmp;
+	private T tmp2;
 	
 	public CatmullRomSpline() { }
 	public CatmullRomSpline(final T[] controlPoints, final boolean continuous) {
@@ -67,6 +69,8 @@ public class CatmullRomSpline<T extends Vector<T>> implements Path<T> {
 	public CatmullRomSpline set(final T[] controlPoints, final boolean continuous) {
 		if (tmp == null)
 			tmp = controlPoints[0].cpy();
+		if (tmp2 == null)
+			tmp2 = controlPoints[0].cpy();
 		this.controlPoints = controlPoints;
 		this.continuous = continuous;
 		this.spanCount = continuous ? controlPoints.length : controlPoints.length - 3;
@@ -142,4 +146,9 @@ public class CatmullRomSpline<T extends Vector<T>> implements Path<T> {
 		float u = MathUtils.clamp((L1-s)/L1, 0f, 1f);
 		return ((float)n + u) / spanCount;
 	}
+	
+	@Override
+	public float locate (T v) {
+		return approximate(v);
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/math/MathUtils.java b/gdx/src/com/badlogic/gdx/math/MathUtils.java
index 800b249..36ce643 100644
--- a/gdx/src/com/badlogic/gdx/math/MathUtils.java
+++ b/gdx/src/com/badlogic/gdx/math/MathUtils.java
@@ -128,6 +128,10 @@ public class MathUtils {
 			add = 0;
 		}
 		float invDiv = 1 / ((x < y ? y : x) * INV_ATAN2_DIM_MINUS_1);
+		
+		if (invDiv == Float.POSITIVE_INFINITY)
+			return ((float)Math.atan2(y, x) + add) * mul;
+		
 		int xi = (int)(x * invDiv);
 		int yi = (int)(y * invDiv);
 		return (Atan2.table[yi * ATAN2_DIM + xi] + add) * mul;
@@ -147,20 +151,22 @@ public class MathUtils {
 		return start + random.nextInt(end - start + 1);
 	}
 
+	/** Returns a random boolean value. */
 	static public final boolean randomBoolean () {
 		return random.nextBoolean();
 	}
 
+	/** Returns random number between 0.0 (inclusive) and 1.0 (exclusive). */
 	static public final float random () {
 		return random.nextFloat();
 	}
 
-	/** Returns a random number between 0 (inclusive) and the specified value (inclusive). */
+	/** Returns a random number between 0 (inclusive) and the specified value (exclusive). */
 	static public final float random (float range) {
 		return random.nextFloat() * range;
 	}
 
-	/** Returns a random number between start (inclusive) and end (inclusive). */
+	/** Returns a random number between start (inclusive) and end (exclusive). */
 	static public final float random (float start, float end) {
 		return start + random.nextFloat() * (end - start);
 	}
@@ -208,8 +214,9 @@ public class MathUtils {
 	static private final int BIG_ENOUGH_INT = 16 * 1024;
 	static private final double BIG_ENOUGH_FLOOR = BIG_ENOUGH_INT;
 	static private final double CEIL = 0.9999999;
-	static private final double BIG_ENOUGH_CEIL = NumberUtils
-		.longBitsToDouble(NumberUtils.doubleToLongBits(BIG_ENOUGH_INT + 1) - 1);
+//	static private final double BIG_ENOUGH_CEIL = NumberUtils
+//		.longBitsToDouble(NumberUtils.doubleToLongBits(BIG_ENOUGH_INT + 1) - 1);
+	static private final double BIG_ENOUGH_CEIL = 16384.999999999996;
 	static private final double BIG_ENOUGH_ROUND = BIG_ENOUGH_INT + 0.5f;
 
 	/** Returns the largest integer less than or equal to the specified float. This method will only properly floor floats from
diff --git a/gdx/src/com/badlogic/gdx/math/Matrix4.java b/gdx/src/com/badlogic/gdx/math/Matrix4.java
index ce21b40..99a0bba 100644
--- a/gdx/src/com/badlogic/gdx/math/Matrix4.java
+++ b/gdx/src/com/badlogic/gdx/math/Matrix4.java
@@ -100,16 +100,26 @@ public class Matrix4 implements Serializable {
 	 * @param quaternion The quaternion that is to be used to set this matrix.
 	 * @return This matrix for the purpose of chaining methods together. */
 	public Matrix4 set (Quaternion quaternion) {
-		// Compute quaternion factors
-		float l_xx = quaternion.x * quaternion.x;
-		float l_xy = quaternion.x * quaternion.y;
-		float l_xz = quaternion.x * quaternion.z;
-		float l_xw = quaternion.x * quaternion.w;
-		float l_yy = quaternion.y * quaternion.y;
-		float l_yz = quaternion.y * quaternion.z;
-		float l_yw = quaternion.y * quaternion.w;
-		float l_zz = quaternion.z * quaternion.z;
-		float l_zw = quaternion.z * quaternion.w;
+		return set(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
+	}
+	
+	/** Sets the matrix to a rotation matrix representing the quaternion.
+	 * 
+	 * @param x The X component of the quaternion that is to be used to set this matrix.
+	 * @param y The Y component of the quaternion that is to be used to set this matrix.
+	 * @param z The Z component of the quaternion that is to be used to set this matrix.
+	 * @param w The W component of the quaternion that is to be used to set this matrix.
+	 * @return This matrix for the purpose of chaining methods together. */
+	public Matrix4 set(float x, float y, float z, float w) {
+		float l_xx = x * x;
+		float l_xy = x * y;
+		float l_xz = x * z;
+		float l_xw = x * w;
+		float l_yy = y * y;
+		float l_yz = y * z;
+		float l_yw = y * w;
+		float l_zz = z * z;
+		float l_zw = z * w;
 		// Set matrix from quaternion
 		val[M00] = 1 - 2 * (l_yy + l_zz);
 		val[M01] = 2 * (l_xy - l_zw);
@@ -431,6 +441,17 @@ public class Matrix4 implements Serializable {
 		return this;
 	}
 
+	/** Sets the 4th column to the translation vector.
+	 * 
+	 * @param vector The translation vector
+	 * @return This matrix for the purpose of chaining methods together. */
+	public Matrix4 setTranslation (Vector3 vector) {
+		val[M03] = vector.x;
+		val[M13] = vector.y;
+		val[M23] = vector.z;
+		return this;
+	}
+
 	/** Sets this matrix to a translation matrix, overwriting it first by an identity matrix and then setting the 4th column to the
 	 * translation vector.
 	 * 
@@ -525,7 +546,7 @@ public class Matrix4 implements Serializable {
 			idt();
 			return this;
 		}
-		return set(quat.set(tmpV.set(axisX, axisY, axisZ), angle));
+		return set(quat.setFromAxis(axisX, axisY, axisZ, angle));
 	}
 
 	/** Set the matrix to a rotation matrix between two vectors.
@@ -533,7 +554,6 @@ public class Matrix4 implements Serializable {
 	 * @param v2 The target vector
 	 * @return This matrix for the purpose of chaining methods together */
 	public Matrix4 setToRotation (final Vector3 v1, final Vector3 v2) {
-		idt();
 		return set(quat.setFromCross(v1, v2));
 	}
 	
@@ -545,13 +565,10 @@ public class Matrix4 implements Serializable {
 	 * @param y2 The target vector y value
 	 * @param z2 The target vector z value
 	 * @return This matrix for the purpose of chaining methods together */
-		public Matrix4 setToRotation (final float x1, final float y1, final float z1, final float x2, final float y2, final float z2) {
-		idt();
+	public Matrix4 setToRotation (final float x1, final float y1, final float z1, final float x2, final float y2, final float z2) {
 		return set(quat.setFromCross(x1, y1, z1, x2, y2, z2));
 	}
 	
-	static final Vector3 tmpV = new Vector3();
-	
 	/** Sets this matrix to a rotation matrix from the given euler angles.
 	 * @param yaw the yaw in degrees
 	 * @param pitch the pitch in degress
@@ -588,9 +605,9 @@ public class Matrix4 implements Serializable {
 		return this;
 	}
 
-	static Vector3 l_vez = new Vector3();
-	static Vector3 l_vex = new Vector3();
-	static Vector3 l_vey = new Vector3();
+	static final Vector3 l_vez = new Vector3();
+	static final Vector3 l_vex = new Vector3();
+	static final Vector3 l_vey = new Vector3();
 
 	/** Sets the matrix to a look at matrix with a direction and an up vector. Multiply with a translation matrix to get a camera
 	 * model view matrix.
@@ -634,9 +651,9 @@ public class Matrix4 implements Serializable {
 		return this;
 	}
 
-	static Vector3 right = new Vector3();
-	static Vector3 tmpForward = new Vector3();
-	static Vector3 tmpUp = new Vector3();
+	static final Vector3 right = new Vector3();
+	static final Vector3 tmpForward = new Vector3();
+	static final Vector3 tmpUp = new Vector3();
 
 	public Matrix4 setToWorld (Vector3 position, Vector3 forward, Vector3 up) {
 		tmpForward.set(forward).nor();
@@ -1035,7 +1052,7 @@ public class Matrix4 implements Serializable {
 	 * @return This matrix for the purpose of chaining methods together. */
 	public Matrix4 rotate (float axisX, float axisY, float axisZ, float angle) {
 		if (angle == 0) return this;
-		quat.set(tmpV.set(axisX, axisY, axisZ), angle);
+		quat.setFromAxis(axisX, axisY, axisZ, angle);
 		return rotate(quat);
 	}
 
@@ -1049,6 +1066,14 @@ public class Matrix4 implements Serializable {
 		mul(val, tmp);
 		return this;
 	}
+	
+	/** Postmultiplies this matrix by the rotation between two vectors.
+	 * @param v1 The base vector
+	 * @param v2 The target vector
+	 * @return This matrix for the purpose of chaining methods together */	
+	public Matrix4 rotate (final Vector3 v1, final Vector3 v2) {
+		return rotate(quat.setFromCross(v1, v2));
+	}
 
 	/** Postmultiplies this matrix with a scale matrix. Postmultiplication is also used by OpenGL ES' 1.x
 	 * glTranslate/glRotate/glScale.
diff --git a/gdx/src/com/badlogic/gdx/math/Path.java b/gdx/src/com/badlogic/gdx/math/Path.java
index e66f78e..9e0b158 100644
--- a/gdx/src/com/badlogic/gdx/math/Path.java
+++ b/gdx/src/com/badlogic/gdx/math/Path.java
@@ -6,6 +6,11 @@ public interface Path<T> {
 	/** @return The value of the path at t where 0<=t<=1 */
 	T valueAt(T out, float t);
 	/** @return The approximated value (between 0 and 1) on the path which is closest to the specified value.
-	 * Note that the implementation of this method might be optimized for speed against precision. */
+	 * Note that the implementation of this method might be optimized for speed against precision, 
+	 * see {@link #locate(Object)} for a more precise (but more intensive) method. */
 	float approximate(T v);
+	/** @return The precise location (between 0 and 1) on the path which is closest to the specified value.
+	 * Note that the implementation of this method might be CPU intensive, see {@link #approximate(Object)} for
+	 * a faster (but less precise) method. */
+	float locate(T v);
 }
diff --git a/gdx/src/com/badlogic/gdx/math/Quaternion.java b/gdx/src/com/badlogic/gdx/math/Quaternion.java
index a4e8846..757510d 100644
--- a/gdx/src/com/badlogic/gdx/math/Quaternion.java
+++ b/gdx/src/com/badlogic/gdx/math/Quaternion.java
@@ -90,10 +90,7 @@ public class Quaternion implements Serializable {
 	 * @param angle The angle in degrees
 	 * @return This quaternion for chaining. */
 	public Quaternion set (Vector3 axis, float angle) {
-		float l_ang = (float)Math.toRadians(angle);
-		float l_sin = (float)Math.sin(l_ang / 2);
-		float l_cos = (float)Math.cos(l_ang / 2);
-		return this.set(axis.x * l_sin, axis.y * l_sin, axis.z * l_sin, l_cos).nor();
+		return setFromAxis(axis.x, axis.y, axis.z, angle);
 	}
 
 	/** @return a copy of this quaternion */
@@ -174,7 +171,7 @@ public class Quaternion implements Serializable {
 	/** Transforms the given vector using this quaternion
 	 * 
 	 * @param v Vector to transform */
-	public void transform (Vector3 v) {
+	public Vector3 transform (Vector3 v) {
 		tmp2.set(this);
 		tmp2.conjugate();
 		tmp2.mulLeft(tmp1.set(v.x, v.y, v.z, 0)).mulLeft(this);
@@ -182,6 +179,7 @@ public class Quaternion implements Serializable {
 		v.x = tmp2.x;
 		v.y = tmp2.y;
 		v.z = tmp2.z;
+		return v;
 	}
 
 	/** Multiplies this quaternion with another one
@@ -189,10 +187,10 @@ public class Quaternion implements Serializable {
 	 * @param q Quaternion to multiply with
 	 * @return This quaternion for chaining */
 	public Quaternion mul (Quaternion q) {
-		float newX = w * q.x + x * q.w + y * q.z - z * q.y;
-		float newY = w * q.y + y * q.w + z * q.x - x * q.z;
-		float newZ = w * q.z + z * q.w + x * q.y - y * q.x;
-		float newW = w * q.w - x * q.x - y * q.y - z * q.z;
+		final float newX = w * q.x + x * q.w + y * q.z - z * q.y;
+		final float newY = w * q.y + y * q.w + z * q.x - x * q.z;
+		final float newZ = w * q.z + z * q.w + x * q.y - y * q.x;
+		final float newW = w * q.w - x * q.x - y * q.y - z * q.z;
 		x = newX;
 		y = newY;
 		z = newZ;
@@ -205,10 +203,10 @@ public class Quaternion implements Serializable {
 	 * @param q Quaternion to multiply with
 	 * @return This quaternion for chaining */
 	public Quaternion mulLeft (Quaternion q) {
-		float newX = q.w * x + q.x * w + q.y * z - q.z * y;
-		float newY = q.w * y + q.y * w + q.z * x - q.x * z;
-		float newZ = q.w * z + q.z * w + q.x * y - q.y * x;
-		float newW = q.w * w - q.x * x - q.y * y - q.z * z;
+		final float newX = q.w * x + q.x * w + q.y * z - q.z * y;
+		final float newY = q.w * y + q.y * w + q.z * x - q.x * z;
+		final float newZ = q.w * z + q.z * w + q.x * y - q.y * x;
+		final float newW = q.w * w - q.x * x - q.y * y - q.z * z;
 		x = newX;
 		y = newY;
 		z = newZ;
@@ -221,16 +219,16 @@ public class Quaternion implements Serializable {
 	/** Fills a 4x4 matrix with the rotation matrix represented by this quaternion.
 	 * 
 	 * @param matrix Matrix to fill */
-	public void toMatrix (float[] matrix) {
-		float xx = x * x;
-		float xy = x * y;
-		float xz = x * z;
-		float xw = x * w;
-		float yy = y * y;
-		float yz = y * z;
-		float yw = y * w;
-		float zz = z * z;
-		float zw = z * w;
+	public void toMatrix (final float[] matrix) {
+		final float xx = x * x;
+		final float xy = x * y;
+		final float xz = x * z;
+		final float xw = x * w;
+		final float yy = y * y;
+		final float yz = y * z;
+		final float yw = y * w;
+		final float zz = z * z;
+		final float zw = z * w;
 		// Set matrix from quaternion
 		matrix[Matrix4.M00] = 1 - 2 * (yy + zz);
 		matrix[Matrix4.M01] = 2 * (xy - zw);
@@ -253,8 +251,7 @@ public class Quaternion implements Serializable {
 	/** Sets the quaternion to an identity Quaternion
 	 * @return this quaternion for chaining */
 	public Quaternion idt () {
-		this.set(0, 0, 0, 1);
-		return this;
+		return this.set(0, 0, 0, 1);
 	}
 
 	// todo : the setFromAxis(v3,float) method should replace the set(v3,float) method
@@ -263,22 +260,25 @@ public class Quaternion implements Serializable {
 	 * @param axis The axis
 	 * @param angle The angle in degrees
 	 * @return This quaternion for chaining. */
-	public Quaternion setFromAxis (Vector3 axis, float angle) {
+	public Quaternion setFromAxis (final Vector3 axis, final float angle) {
 		return setFromAxis(axis.x, axis.y, axis.z, angle);
 	}
 
 	/** Sets the quaternion components from the given axis and angle around that axis.
-	 * 
 	 * @param x X direction of the axis
 	 * @param y Y direction of the axis
 	 * @param z Z direction of the axis
 	 * @param angle The angle in degrees
 	 * @return This quaternion for chaining. */
-	public Quaternion setFromAxis (float x, float y, float z, float angle) {
+	public Quaternion setFromAxis (final float x, final float y, final float z, final float angle) {
+		float d = Vector3.len(x, y, z);
+		if (d == 0f)
+			return idt();
+		d = 1f /d;
 		float l_ang = angle * MathUtils.degreesToRadians;
-		float l_sin = MathUtils.sin(l_ang / 2);
-		float l_cos = MathUtils.cos(l_ang / 2);
-		return this.set(x * l_sin, y * l_sin, z * l_sin, l_cos).nor();
+		float l_sin = (float)Math.sin(l_ang / 2);
+		float l_cos = (float)Math.cos(l_ang / 2);
+		return this.set(d * x * l_sin, d * y * l_sin, d * z * l_sin, l_cos).nor();
 	}
 
 // fromRotationMatrix(xAxis.x, yAxis.x, zAxis.x, xAxis.y, yAxis.y, zAxis.y,
diff --git a/gdx/src/com/badlogic/gdx/math/Vector.java b/gdx/src/com/badlogic/gdx/math/Vector.java
index 86dbcf5..73783d2 100644
--- a/gdx/src/com/badlogic/gdx/math/Vector.java
+++ b/gdx/src/com/badlogic/gdx/math/Vector.java
@@ -33,6 +33,12 @@ public interface Vector<T extends Vector> {
 	 * @return This vector for chaining */
 	T limit (float limit);
 
+	/** Clamps this vector's length to given value
+	 * @param min Min length
+	 * @param max Max length
+	 * @return This vector for chaining */
+	T clamp (float min, float max);
+	
 	/** Sets this vector from the given vector
 	 * @param v The vector
 	 * @return This vector for chaining */
@@ -56,18 +62,14 @@ public interface Vector<T extends Vector> {
 	 * @return The dot product between this and the other vector */
 	float dot (T v);
 
-	/** Multiplies this vector by a scalar
+	/** Scales this vector by a scalar
 	 * @param scalar The scalar
 	 * @return This vector for chaining */
-	T mul (float scalar);
+	T scl (float scalar);
 
-	/** Multiplies this vector by another vector
+	/** Scales this vector by another vector
 	 * @return This vector for chaining */
-	T mul (T v);
-
-	T div (float scalar);
-
-	T div (T v);
+	T scl (T v);
 
 	/** @param v The other vector
 	 * @return the distance between this and the other vector */
@@ -79,7 +81,6 @@ public interface Vector<T extends Vector> {
 
 	/** Linearly interpolates between this vector and the target vector by alpha which is in the range [0,1]. The result is stored
 	 * in this vector.
-	 * 
 	 * @param target The target vector
 	 * @param alpha The interpolation coefficient
 	 * @return This vector for chaining. */
diff --git a/gdx/src/com/badlogic/gdx/math/Vector2.java b/gdx/src/com/badlogic/gdx/math/Vector2.java
index 01c8d78..48bad38 100644
--- a/gdx/src/com/badlogic/gdx/math/Vector2.java
+++ b/gdx/src/com/badlogic/gdx/math/Vector2.java
@@ -134,27 +134,42 @@ public class Vector2 implements Serializable, Vector<Vector2> {
 	/** Multiplies this vector by a scalar
 	 * @param scalar The scalar
 	 * @return This vector for chaining */
-	public Vector2 mul (float scalar) {
+	public Vector2 scl (float scalar) {
 		x *= scalar;
 		y *= scalar;
 		return this;
 	}
+	
+	/** @deprecated Use {@link #scl(float)} instead. */
+	public Vector2 mul (float scalar) {
+		return scl(scalar);
+	}
 
 	/** Multiplies this vector by a scalar
 	 * @return This vector for chaining */
-	public Vector2 mul (float x, float y) {
+	public Vector2 scl (float x, float y) {
 		this.x *= x;
 		this.y *= y;
 		return this;
 	}
 	
+	/** @deprecated Use {@link #scl(float, float)} instead. */
+	public Vector2 mul (float x, float y) {
+		return scl(x,y);
+	}
+	
 	/** Multiplies this vector by a vector
 	 * @return This vector for chaining */
-	public Vector2 mul (Vector2 v) {
+	public Vector2 scl (Vector2 v) {
 		this.x *= v.x;
 		this.y *= v.y;
 		return this;
 	}
+	
+	/** @deprecated Use {@link #scl(Vector2)} instead. */
+	public Vector2 mul (Vector2 v) {
+		return scl(v);
+	}
 
 	public Vector2 div (float value) {
 		return this.mul(1 / value);
@@ -212,6 +227,21 @@ public class Vector2 implements Serializable, Vector<Vector2> {
 		}
 		return this;
 	}
+	
+	/** Clamps this vector's length to given value
+	 * @param min Min length
+	 * @param max Max length
+	 * @return This vector for chaining */
+	public Vector2 clamp (float min, float max) {
+		final float l2 = len2();
+		if (l2 == 0f)
+			return this;
+		if (l2 > max * max)
+			return nor().mul(max);
+		if (l2 < min * min)
+			return nor().mul(min);
+		return this;
+	}
 
 	public String toString () {
 		return "[" + x + ":" + y + "]";
diff --git a/gdx/src/com/badlogic/gdx/math/Vector3.java b/gdx/src/com/badlogic/gdx/math/Vector3.java
index b7b8332..c51ed22 100644
--- a/gdx/src/com/badlogic/gdx/math/Vector3.java
+++ b/gdx/src/com/badlogic/gdx/math/Vector3.java
@@ -32,13 +32,16 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	/** the x-component of this vector **/
 	public float z;
 
-	/** Static temporary vector. Use with care! Use only when sure other code will not also use this.
+	/** @deprecated
+	 * Static temporary vector. Use with care! Use only when sure other code will not also use this.
 	 * @see #tmp() **/
 	public final static Vector3 tmp = new Vector3();
-	/** Static temporary vector. Use with care! Use only when sure other code will not also use this.
+	/** @deprecated
+	 * Static temporary vector. Use with care! Use only when sure other code will not also use this.
 	 * @see #tmp() **/
 	public final static Vector3 tmp2 = new Vector3();
-	/** Static temporary vector. Use with care! Use only when sure other code will not also use this.
+	/** @deprecated
+	 * Static temporary vector. Use with care! Use only when sure other code will not also use this.
 	 * @see #tmp() **/
 	public final static Vector3 tmp3 = new Vector3();
 
@@ -63,14 +66,14 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 
 	/** Creates a vector from the given vector
 	 * @param vector The vector */
-	public Vector3 (Vector3 vector) {
+	public Vector3 (final Vector3 vector) {
 		this.set(vector);
 	}
 
 	/** Creates a vector from the given array. The array must have at least 3 elements.
 	 * 
 	 * @param values The array */
-	public Vector3 (float[] values) {
+	public Vector3 (final float[] values) {
 		this.set(values[0], values[1], values[2]);
 	}
 
@@ -91,7 +94,7 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	 * 
 	 * @param vector The vector
 	 * @return This vector for chaining */
-	public Vector3 set (Vector3 vector) {
+	public Vector3 set (final Vector3 vector) {
 		return this.set(vector.x, vector.y, vector.z);
 	}
 
@@ -99,7 +102,7 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	 * 
 	 * @param values The array
 	 * @return this vector for chaining */
-	public Vector3 set (float[] values) {
+	public Vector3 set (final float[] values) {
 		return this.set(values[0], values[1], values[2]);
 	}
 
@@ -108,7 +111,8 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 		return new Vector3(this);
 	}
 
-	/** NEVER EVER SAVE THIS REFERENCE! Do not use this unless you are aware of the side-effects, e.g. other methods might call this
+	/** @deprecated
+	 * NEVER EVER SAVE THIS REFERENCE! Do not use this unless you are aware of the side-effects, e.g. other methods might call this
 	 * as well.
 	 * 
 	 * @return a temporary copy of this vector */
@@ -116,7 +120,8 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 		return tmp.set(this);
 	}
 
-	/** NEVER EVER SAVE THIS REFERENCE! Do not use this unless you are aware of the side-effects, e.g. other methods might call this
+	/** @deprecated
+	 * NEVER EVER SAVE THIS REFERENCE! Do not use this unless you are aware of the side-effects, e.g. other methods might call this
 	 * as well.
 	 * 
 	 * @return a temporary copy of this vector */
@@ -124,7 +129,8 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 		return tmp2.set(this);
 	}
 
-	/** NEVER EVER SAVE THIS REFERENCE! Do not use this unless you are aware of the side-effects, e.g. other methods might call this
+	/** @deprecated
+	 * NEVER EVER SAVE THIS REFERENCE! Do not use this unless you are aware of the side-effects, e.g. other methods might call this
 	 * as well.
 	 * 
 	 * @return a temporary copy of this vector */
@@ -136,7 +142,7 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	 * 
 	 * @param vector The other vector
 	 * @return This vector for chaining */
-	public Vector3 add (Vector3 vector) {
+	public Vector3 add (final Vector3 vector) {
 		return this.add(vector.x, vector.y, vector.z);
 	}
 
@@ -160,7 +166,7 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	/** Subtracts the given vector from this vector
 	 * @param a_vec The other vector
 	 * @return This vector for chaining */
-	public Vector3 sub (Vector3 a_vec) {
+	public Vector3 sub (final Vector3 a_vec) {
 		return this.sub(a_vec.x, a_vec.y, a_vec.z);
 	}
 
@@ -182,46 +188,72 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 		return this.set(this.x - value, this.y - value, this.z - value);
 	}
 
-	/** Multiplies all components of this vector by the given value
-	 * 
+	/** Scales this vector by the given value
 	 * @param value The value
 	 * @return This vector for chaining */
-	public Vector3 mul (float value) {
+	public Vector3 scl (float value) {
 		return this.set(this.x * value, this.y * value, this.z * value);
 	}
+	
+	/** @deprecated Use {@link #scl(float)} instead. */
+	public Vector3 mul (float value) {
+		return scl(value);
+	}
 
-	/** Multiplies all components of this vector by the given vector3's values
-	 * 
+	/** Scales this vector by the given vector3's values
 	 * @param other The vector3 to multiply by
 	 * @return This vector for chaining */
-	public Vector3 mul (Vector3 other) {
-		return this.mul(other.x, other.y, other.z);
+	public Vector3 scl (final Vector3 other) {
+		return this.set(x * other.x, y * other.y, z * other.z);
+	}
+	
+	/** @deprecated Use {@link #scl(Vector3)} instead. */
+	public Vector3 mul (final Vector3 other) {
+		return scl(other);
 	}
 
-	/** Multiplies all components of this vector by the given values
-	 * 
+	/** Scales this vector by the given values
 	 * @param vx X value
 	 * @param vy Y value
 	 * @param vz Z value
 	 * @return This vector for chaining */
-	public Vector3 mul (float vx, float vy, float vz) {
+	public Vector3 scl (float vx, float vy, float vz) {
 		return this.set(this.x * vx, this.y * vy, this.z * vz);
 	}
+	
+	/** @deprecated Use {@link #scl(float, float, float)} instead. */
+	public Vector3 mul (float vx, float vy, float vz) {
+		return scl(vx, vy, vz);
+	}
 
-	/** Divides all components of this vector by the given value
-	 * 
+	/** @deprecated Use {@link #scl(float, float, float)} instead. */
+	public Vector3 scale (float scalarX, float scalarY, float scalarZ) {
+		return scl(scalarX, scalarY, scalarZ);
+	}
+	
+	/** @deprecated Use {@link #scl(float)} instead.
+	 * Divides all components of this vector by the given value
 	 * @param value The value
 	 * @return This vector for chaining */
 	public Vector3 div (float value) {
-		return this.mul(1/value);
+		return this.scl(1f/value);
 	}
 
+	/** @deprecated Use {@link #scl(float, float, float)} instead.
+	 * Divides this vector by the given vector */
 	public Vector3 div (float vx, float vy, float vz) {
-		return this.mul(1/vx, 1/vy, 1/vz);
+		return this.set(x/vx, y/vy, z/vz);
 	}
 
-	public Vector3 div (Vector3 other) {
-		return this.mul(1/other.x, 1/other.y, 1/other.z);
+	/** @deprecated Use {@link #scl(Vector3)} instead. 
+	 * Divides this vector by the given vector */
+	public Vector3 div (final Vector3 other) {
+		return this.set(x/other.x, y/other.y, z/other.z);
+	}
+	
+	/** @return The euclidian length */
+	public static float len (final float x, final float y, final float z) {
+		return (float)Math.sqrt(x * x + y * y + z * z);
 	}
 
 	/** @return The euclidian length */
@@ -230,40 +262,83 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	}
 
 	/** @return The squared euclidian length */
+	public static float len2 (final float x, final float y, final float z) {
+		return x * x + y * y + z * z;
+	}
+	
+	/** @return The squared euclidian length */
 	public float len2 () {
 		return x * x + y * y + z * z;
 	}
 
 	/** @param vector The other vector
 	 * @return Wether this and the other vector are equal */
-	public boolean idt (Vector3 vector) {
+	public boolean idt (final Vector3 vector) {
 		return x == vector.x && y == vector.y && z == vector.z;
 	}
+	
+	/** @return The euclidian distance between the two specified vectors */
+	public static float dst (final float x1, final float y1, final float z1, final float x2, final float y2, final float z2) {
+		final float a = x2 - x1;
+		final float b = y2 - y1;
+		final float c = z2 - z1;
+		return (float)Math.sqrt(a * a + b * b + c * c); 
+	}
 
 	/** @param vector The other vector
 	 * @return The euclidian distance between this and the other vector */
-	public float dst (Vector3 vector) {
-		float a = vector.x - x;
-		float b = vector.y - y;
-		float c = vector.z - z;
-
-		a *= a;
-		b *= b;
-		c *= c;
+	public float dst (final Vector3 vector) {
+		final float a = vector.x - x;
+		final float b = vector.y - y;
+		final float c = vector.z - z;
+		return (float)Math.sqrt(a * a + b * b + c * c);
+	}
 
-		return (float)Math.sqrt(a + b + c);
+	/** @return the distance between this point and the given point */
+	public float dst (float x, float y, float z) {
+		final float a = x - this.x;
+		final float b = y - this.y;
+		final float c = z - this.z;
+		return (float)Math.sqrt(a * a + b * b + c * c);
+	}
+	
+	/** @return the squared distance between the given points */
+	public static float dst2(final float x1, final float y1, final float z1, final float x2, final float y2, final float z2) {
+		final float a = x2 - x1;
+		final float b = y2 - y1;
+		final float c = z2 - z1;
+		return a * a + b * b + c * c; 
+	}
+	
+	/** Returns the squared distance between this point and the given point
+	 * @param point The other point
+	 * @return The squared distance */
+	public float dst2 (Vector3 point) {
+		final float a = point.x - x;
+		final float b = point.y - y;
+		final float c = point.z - z;
+		return a * a + b * b + c * c;
+	}
+	
+	/** Returns the squared distance between this point and the given point
+	 * @param x The x-component of the other point
+	 * @param y The y-component of the other point
+	 * @param z The z-component of the other point
+	 * @return The squared distance */
+	public float dst2 (float x, float y, float z) {
+		final float a = x - this.x;
+		final float b = y - this.y;
+		final float c = z - this.z;
+		return a * a + b * b + c * c;
 	}
 
 	/** Normalizes this vector to unit length
-	 * 
 	 * @return This vector for chaining */
 	public Vector3 nor () {
-		float len = this.len();
-		if (len == 0) {
+		final float len2 = this.len2();
+		if (len2 == 0f || len2 == 1f)
 			return this;
-		} else {
-			return this.div(len);
-		}
+		return this.scl(1f/(float)Math.sqrt(len2));
 	}
 	
 	/** @return The dot product between the two vectors */
@@ -273,14 +348,23 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 
 	/** @param vector The other vector
 	 * @return The dot product between this and the other vector */
-	public float dot (Vector3 vector) {
+	public float dot (final Vector3 vector) {
 		return x * vector.x + y * vector.y + z * vector.z;
 	}
 
+	/** Returns the dot product between this and the given vector.
+	 * @param x The x-component of the other vector
+	 * @param y The y-component of the other vector
+	 * @param z The z-component of the other vector
+	 * @return The dot product */
+	public float dot (float x, float y, float z) {
+		return this.x * x + this.y * y + this.z * z;
+	}
+	
 	/** Sets this vector to the cross product between it and the other vector.
 	 * @param vector The other vector
 	 * @return This vector for chaining */
-	public Vector3 crs (Vector3 vector) {
+	public Vector3 crs (final Vector3 vector) {
 		return this.set(y * vector.z - z * vector.y, z * vector.x - x * vector.z, x * vector.y - y * vector.x);
 	}
 
@@ -296,32 +380,38 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	/** Multiplies the vector by the given matrix.
 	 * @param matrix The matrix
 	 * @return This vector for chaining */
-	public Vector3 mul (Matrix4 matrix) {
-		float l_mat[] = matrix.val;
+	public Vector3 mul (final Matrix4 matrix) {
+		final float l_mat[] = matrix.val;
 		return this.set(x * l_mat[Matrix4.M00] + y * l_mat[Matrix4.M01] + z * l_mat[Matrix4.M02] + l_mat[Matrix4.M03], x
 			* l_mat[Matrix4.M10] + y * l_mat[Matrix4.M11] + z * l_mat[Matrix4.M12] + l_mat[Matrix4.M13], x * l_mat[Matrix4.M20] + y
 			* l_mat[Matrix4.M21] + z * l_mat[Matrix4.M22] + l_mat[Matrix4.M23]);
 	}
 
+	/** Multiplies the vector by the given {@link Quaternion}.
+	 * @return This vector for chaining */	
+	public Vector3 mul (final Quaternion quat) {
+		return quat.transform(this);
+	}
+	
 	/** Multiplies this vector by the given matrix dividing by w. This is mostly used to project/unproject vectors via a perspective
 	 * projection matrix.
 	 * 
 	 * @param matrix The matrix.
 	 * @return This vector for chaining */
-	public Vector3 prj (Matrix4 matrix) {
-		float l_mat[] = matrix.val;
-		float l_w = x * l_mat[Matrix4.M30] + y * l_mat[Matrix4.M31] + z * l_mat[Matrix4.M32] + l_mat[Matrix4.M33];
-		return this.set((x * l_mat[Matrix4.M00] + y * l_mat[Matrix4.M01] + z * l_mat[Matrix4.M02] + l_mat[Matrix4.M03]) / l_w, (x
+	public Vector3 prj (final Matrix4 matrix) {
+		final float l_mat[] = matrix.val;
+		final float l_w = 1f / (x * l_mat[Matrix4.M30] + y * l_mat[Matrix4.M31] + z * l_mat[Matrix4.M32] + l_mat[Matrix4.M33]);
+		return this.set((x * l_mat[Matrix4.M00] + y * l_mat[Matrix4.M01] + z * l_mat[Matrix4.M02] + l_mat[Matrix4.M03]) * l_w, (x
 			* l_mat[Matrix4.M10] + y * l_mat[Matrix4.M11] + z * l_mat[Matrix4.M12] + l_mat[Matrix4.M13])
-			/ l_w, (x * l_mat[Matrix4.M20] + y * l_mat[Matrix4.M21] + z * l_mat[Matrix4.M22] + l_mat[Matrix4.M23]) / l_w);
+			* l_w, (x * l_mat[Matrix4.M20] + y * l_mat[Matrix4.M21] + z * l_mat[Matrix4.M22] + l_mat[Matrix4.M23]) * l_w);
 	}
 
 	/** Multiplies this vector by the first three columns of the matrix, essentially only applying rotation and scaling.
 	 * 
 	 * @param matrix The matrix
 	 * @return This vector for chaining */
-	public Vector3 rot (Matrix4 matrix) {
-		float l_mat[] = matrix.val;
+	public Vector3 rot (final Matrix4 matrix) {
+		final float l_mat[] = matrix.val;
 		return this.set(x * l_mat[Matrix4.M00] + y * l_mat[Matrix4.M01] + z * l_mat[Matrix4.M02], x * l_mat[Matrix4.M10] + y
 			* l_mat[Matrix4.M11] + z * l_mat[Matrix4.M12], x * l_mat[Matrix4.M20] + y * l_mat[Matrix4.M21] + z * l_mat[Matrix4.M22]);
 	}
@@ -333,7 +423,7 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	 * @param axisZ the z-component of the axis
 	 * @return This vector for chaining */
 	public Vector3 rotate (float angle, float axisX, float axisY, float axisZ) {
-		return rotate(tmp.set(axisX, axisY, axisZ), angle);
+		return this.mul(tmpMat.setToRotation(axisX, axisY, axisZ, angle));
 	}
 	
 	/** Rotates this vector by the given angle around the given axis.
@@ -341,20 +431,30 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	 * @param axis
 	 * @param angle the angle
 	 * @return This vector for chaining */
-	public Vector3 rotate (Vector3 axis, float angle) {
+	public Vector3 rotate (final Vector3 axis, float angle) {
 		tmpMat.setToRotation(axis, angle);
 		return this.mul(tmpMat);
 	}
 
 	/** @return Whether this vector is a unit length vector */
 	public boolean isUnit () {
-		return this.len() == 1;
+		return isUnit(0.000000001f);
+	}
+	
+	/** @return Whether this vector is a unit length vector within the given margin */
+	public boolean isUnit(final float margin) {
+		return Math.abs(len2() - 1f) < margin * margin;
 	}
 
 	/** @return Whether this vector is a zero vector */
 	public boolean isZero () {
 		return x == 0 && y == 0 && z == 0;
 	}
+	
+	/** @return Whether the length of this vector is smaller than the given margin */
+	public boolean isZero (final float margin) {
+		return len2() < margin * margin;
+	}
 
 	/** Linearly interpolates between this vector and the target vector by alpha which is in the range [0,1]. The result is stored
 	 * in this vector.
@@ -362,10 +462,10 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	 * @param target The target vector
 	 * @param alpha The interpolation coefficient
 	 * @return This vector for chaining. */
-	public Vector3 lerp (Vector3 target, float alpha) {
-		Vector3 r = this.mul(1.0f - alpha);
-		r.add(target.tmp().mul(alpha));
-		return r;
+	public Vector3 lerp (final Vector3 target, float alpha) {
+		scl(1.0f - alpha);
+		add(target.x * alpha, target.y * alpha, target.z * alpha);
+		return this;
 	}
 
 	/** Spherically interpolates between this vector and the target vector by alpha which is in the range [0,1]. The result is
@@ -374,90 +474,55 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	 * @param target The target vector
 	 * @param alpha The interpolation coefficient
 	 * @return This vector for chaining. */
-	public Vector3 slerp (Vector3 target, float alpha) {
-		float dot = dot(target);
-		if (dot > 0.99995 || dot < 0.9995) {
-			this.add(target.tmp().sub(this).mul(alpha));
-			this.nor();
-			return this;
-		}
-
-		if (dot > 1) dot = 1;
-		if (dot < -1) dot = -1;
-
-		float theta0 = (float)Math.acos(dot);
-		float theta = theta0 * alpha;
-		Vector3 v2 = target.tmp().sub(x * dot, y * dot, z * dot);
-		v2.nor();
-		return this.mul((float)Math.cos(theta)).add(v2.mul((float)Math.sin(theta))).nor();
+	public Vector3 slerp (final Vector3 target, float alpha) {
+		final float dot = dot(target);
+		// If the inputs are too close for comfort, simply linearly interpolate.
+		if (dot > 0.9995 || dot < -0.9995)
+			return lerp(target, alpha);
+
+		// theta0 = angle between input vectors
+		final float theta0 = (float)Math.acos(dot);
+		// theta = angle between this vector and result
+		final float theta = theta0 * alpha;
+		
+		final float st = (float)Math.sin(theta);
+		final float tx = target.x - x * dot;
+		final float ty = target.y - y * dot;
+		final float tz = target.z - z * dot;
+		final float l2 = tx * tx + ty * ty + tz * tz;
+		final float dl = st * ((l2 < 0.0001f) ? 1f : 1f / (float)Math.sqrt(l2));
+		
+		return scl((float)Math.cos(theta)).add(tx * dl, ty * dl, tz * dl).nor();
 	}
 
-	/** {@inheritDoc} */
 	public String toString () {
 		return x + "," + y + "," + z;
 	}
-
-	/** Returns the dot product between this and the given vector.
-	 * 
-	 * @param x The x-component of the other vector
-	 * @param y The y-component of the other vector
-	 * @param z The z-component of the other vector
-	 * @return The dot product */
-	public float dot (float x, float y, float z) {
-		return this.x * x + this.y * y + this.z * z;
-	}
-
-	/** Returns the squared distance between this point and the given point
-	 * 
-	 * @param point The other point
-	 * @return The squared distance */
-	public float dst2 (Vector3 point) {
-
-		float a = point.x - x;
-		float b = point.y - y;
-		float c = point.z - z;
-
-		a *= a;
-		b *= b;
-		c *= c;
-
-		return a + b + c;
-	}
 	
 	/** Limits this vector's length to given value
 	 * @param limit Max length
 	 * @return This vector for chaining */
 	public Vector3 limit (float limit) {
-		if (len2() > limit * limit) {
-			nor();
-			mul(limit);
-		}
+		if (len2() > limit * limit)
+			nor().scl(limit);
 		return this;
 	}
-
-	/** Returns the squared distance between this point and the given point
-	 * 
-	 * @param x The x-component of the other point
-	 * @param y The y-component of the other point
-	 * @param z The z-component of the other point
-	 * @return The squared distance */
-	public float dst2 (float x, float y, float z) {
-		float a = x - this.x;
-		float b = y - this.y;
-		float c = z - this.z;
-
-		a *= a;
-		b *= b;
-		c *= c;
-
-		return a + b + c;
-	}
-
-	public float dst (float x, float y, float z) {
-		return (float)Math.sqrt(dst2(x, y, z));
+	
+	/** Clamps this vector's length to given value
+	 * @param min Min length
+	 * @param max Max length
+	 * @return This vector for chaining */
+	public Vector3 clamp (float min, float max) {
+		final float l2 = len2();
+		if (l2 == 0f)
+			return this;
+		if (l2 > max * max)
+			return nor().scl(max);
+		if (l2 < min * min)
+			return nor().scl(min);
+		return this;
 	}
 
-	/** {@inheritDoc} */
 	@Override
 	public int hashCode () {
 		final int prime = 31;
@@ -468,7 +533,6 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 		return result;
 	}
 
-	/** {@inheritDoc} */
 	@Override
 	public boolean equals (Object obj) {
 		if (this == obj) return true;
@@ -485,7 +549,7 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 	 * @param obj
 	 * @param epsilon
 	 * @return whether the vectors are the same. */
-	public boolean epsilonEquals (Vector3 obj, float epsilon) {
+	public boolean epsilonEquals (final Vector3 obj, float epsilon) {
 		if (obj == null) return false;
 		if (Math.abs(obj.x - x) > epsilon) return false;
 		if (Math.abs(obj.y - y) > epsilon) return false;
@@ -501,16 +565,4 @@ public class Vector3 implements Serializable, Vector<Vector3> {
 		if (Math.abs(z - this.z) > epsilon) return false;
 		return true;
 	}
-
-	/** Scales the vector components by the given scalars.
-	 * 
-	 * @param scalarX
-	 * @param scalarY
-	 * @param scalarZ */
-	public Vector3 scale (float scalarX, float scalarY, float scalarZ) {
-		x *= scalarX;
-		y *= scalarY;
-		z *= scalarZ;
-		return this;
-	}
 }
diff --git a/gdx/src/com/badlogic/gdx/net/HttpStatus.java b/gdx/src/com/badlogic/gdx/net/HttpStatus.java
new file mode 100644
index 0000000..973a083
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/net/HttpStatus.java
@@ -0,0 +1,154 @@
+package com.badlogic.gdx.net;
+
+import com.badlogic.gdx.Net;
+import com.badlogic.gdx.Net.HttpRequest;
+import com.badlogic.gdx.Net.HttpResponse;
+
+/** This implementation is widely based Apache's HttpStatus which uses license (Apache license 2.0) -
+ * http://www.apache.org/licenses/LICENSE-2.0 For more information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ * 
+ * Contains information about the HTTP status line returned with the {@link HttpResponse} after a {@link HttpRequest} was
+ * performed. Also contains constants enumerating the HTTP Status Codes. All status codes defined in RFC1945 (HTTP/1.0), RFC2616
+ * (HTTP/1.1), and RFC2518 (WebDAV) are listed. */
+public class HttpStatus {
+
+	int statusCode;
+
+	/** Returns the status code of the HTTP response, normally 2xx status codes indicate success while 4xx and 5xx indicate client
+	 * and server errors, respectively (see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">HTTP/1.1: Status Code
+	 * Definitions</a> for more information about HTTP status codes). */
+	public int getStatusCode () {
+		return statusCode;
+	}
+
+	public HttpStatus (int statusCode) {
+		this.statusCode = statusCode;
+	}
+
+	/*
+	 * Constants enumerating the HTTP status codes. All status codes defined in RFC1945 (HTTP/1.0), RFC2616 (HTTP/1.1), and RFC2518
+	 * (WebDAV) are listed.
+	 */
+
+	// --- 1xx Informational ---
+
+	/** <tt>100 Continue</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_CONTINUE = 100;
+	/** <tt>101 Switching Protocols</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_SWITCHING_PROTOCOLS = 101;
+	/** <tt>102 Processing</tt> (WebDAV - RFC 2518) */
+	public static final int SC_PROCESSING = 102;
+
+	// --- 2xx Success ---
+
+	/** <tt>200 OK</tt> (HTTP/1.0 - RFC 1945) */
+	public static final int SC_OK = 200;
+	/** <tt>201 Created</tt> (HTTP/1.0 - RFC 1945) */
+	public static final int SC_CREATED = 201;
+	/** <tt>202 Accepted</tt> (HTTP/1.0 - RFC 1945) */
+	public static final int SC_ACCEPTED = 202;
+	/** <tt>203 Non Authoritative Information</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_NON_AUTHORITATIVE_INFORMATION = 203;
+	/** <tt>204 No Content</tt> (HTTP/1.0 - RFC 1945) */
+	public static final int SC_NO_CONTENT = 204;
+	/** <tt>205 Reset Content</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_RESET_CONTENT = 205;
+	/** <tt>206 Partial Content</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_PARTIAL_CONTENT = 206;
+	/** <tt>207 Multi-Status</tt> (WebDAV - RFC 2518) or <tt>207 Partial Update
+	 * OK</tt> (HTTP/1.1 - draft-ietf-http-v11-spec-rev-01?) */
+	public static final int SC_MULTI_STATUS = 207;
+
+	// --- 3xx Redirection ---
+
+	/** <tt>300 Mutliple Choices</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_MULTIPLE_CHOICES = 300;
+	/** <tt>301 Moved Permanently</tt> (HTTP/1.0 - RFC 1945) */
+	public static final int SC_MOVED_PERMANENTLY = 301;
+	/** <tt>302 Moved Temporarily</tt> (Sometimes <tt>Found</tt>) (HTTP/1.0 - RFC 1945) */
+	public static final int SC_MOVED_TEMPORARILY = 302;
+	/** <tt>303 See Other</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_SEE_OTHER = 303;
+	/** <tt>304 Not Modified</tt> (HTTP/1.0 - RFC 1945) */
+	public static final int SC_NOT_MODIFIED = 304;
+	/** <tt>305 Use Proxy</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_USE_PROXY = 305;
+	/** <tt>307 Temporary Redirect</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_TEMPORARY_REDIRECT = 307;
+
+	// --- 4xx Client Error ---
+
+	/** <tt>400 Bad Request</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_BAD_REQUEST = 400;
+	/** <tt>401 Unauthorized</tt> (HTTP/1.0 - RFC 1945) */
+	public static final int SC_UNAUTHORIZED = 401;
+	/** <tt>402 Payment Required</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_PAYMENT_REQUIRED = 402;
+	/** <tt>403 Forbidden</tt> (HTTP/1.0 - RFC 1945) */
+	public static final int SC_FORBIDDEN = 403;
+	/** <tt>404 Not Found</tt> (HTTP/1.0 - RFC 1945) */
+	public static final int SC_NOT_FOUND = 404;
+	/** <tt>405 Method Not Allowed</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_METHOD_NOT_ALLOWED = 405;
+	/** <tt>406 Not Acceptable</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_NOT_ACCEPTABLE = 406;
+	/** <tt>407 Proxy Authentication Required</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_PROXY_AUTHENTICATION_REQUIRED = 407;
+	/** <tt>408 Request Timeout</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_REQUEST_TIMEOUT = 408;
+	/** <tt>409 Conflict</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_CONFLICT = 409;
+	/** <tt>410 Gone</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_GONE = 410;
+	/** <tt>411 Length Required</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_LENGTH_REQUIRED = 411;
+	/** <tt>412 Precondition Failed</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_PRECONDITION_FAILED = 412;
+	/** <tt>413 Request Entity Too Large</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_REQUEST_TOO_LONG = 413;
+	/** <tt>414 Request-URI Too Long</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_REQUEST_URI_TOO_LONG = 414;
+	/** <tt>415 Unsupported Media Type</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_UNSUPPORTED_MEDIA_TYPE = 415;
+	/** <tt>416 Requested Range Not Satisfiable</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_REQUESTED_RANGE_NOT_SATISFIABLE = 416;
+	/** <tt>417 Expectation Failed</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_EXPECTATION_FAILED = 417;
+
+	/** Static constant for a 418 error. <tt>418 Unprocessable Entity</tt> (WebDAV drafts?) or
+	 * <tt>418 Reauthentication Required</tt> (HTTP/1.1 drafts?) */
+	// not used
+	// public static final int SC_UNPROCESSABLE_ENTITY = 418;
+
+	/** Static constant for a 419 error. <tt>419 Insufficient Space on Resource</tt> (WebDAV - draft-ietf-webdav-protocol-05?) or
+	 * <tt>419 Proxy Reauthentication Required</tt> (HTTP/1.1 drafts?) */
+	public static final int SC_INSUFFICIENT_SPACE_ON_RESOURCE = 419;
+	/** Static constant for a 420 error. <tt>420 Method Failure</tt> (WebDAV - draft-ietf-webdav-protocol-05?) */
+	public static final int SC_METHOD_FAILURE = 420;
+	/** <tt>422 Unprocessable Entity</tt> (WebDAV - RFC 2518) */
+	public static final int SC_UNPROCESSABLE_ENTITY = 422;
+	/** <tt>423 Locked</tt> (WebDAV - RFC 2518) */
+	public static final int SC_LOCKED = 423;
+	/** <tt>424 Failed Dependency</tt> (WebDAV - RFC 2518) */
+	public static final int SC_FAILED_DEPENDENCY = 424;
+
+	// --- 5xx Server Error ---
+
+	/** <tt>500 Server Error</tt> (HTTP/1.0 - RFC 1945) */
+	public static final int SC_INTERNAL_SERVER_ERROR = 500;
+	/** <tt>501 Not Implemented</tt> (HTTP/1.0 - RFC 1945) */
+	public static final int SC_NOT_IMPLEMENTED = 501;
+	/** <tt>502 Bad Gateway</tt> (HTTP/1.0 - RFC 1945) */
+	public static final int SC_BAD_GATEWAY = 502;
+	/** <tt>503 Service Unavailable</tt> (HTTP/1.0 - RFC 1945) */
+	public static final int SC_SERVICE_UNAVAILABLE = 503;
+	/** <tt>504 Gateway Timeout</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_GATEWAY_TIMEOUT = 504;
+	/** <tt>505 HTTP Version Not Supported</tt> (HTTP/1.1 - RFC 2616) */
+	public static final int SC_HTTP_VERSION_NOT_SUPPORTED = 505;
+
+	/** <tt>507 Insufficient Storage</tt> (WebDAV - RFC 2518) */
+	public static final int SC_INSUFFICIENT_STORAGE = 507;
+
+}
diff --git a/gdx/src/com/badlogic/gdx/net/NetJavaImpl.java b/gdx/src/com/badlogic/gdx/net/NetJavaImpl.java
index 61249f8..d16fab5 100644
--- a/gdx/src/com/badlogic/gdx/net/NetJavaImpl.java
+++ b/gdx/src/com/badlogic/gdx/net/NetJavaImpl.java
@@ -1,4 +1,3 @@
-
 package com.badlogic.gdx.net;
 
 import java.io.BufferedReader;
@@ -21,7 +20,6 @@ import com.badlogic.gdx.Net.HttpMethods;
 import com.badlogic.gdx.Net.HttpRequest;
 import com.badlogic.gdx.Net.HttpResponse;
 import com.badlogic.gdx.Net.HttpResponseListener;
-import com.badlogic.gdx.Net.HttpStatus;
 import com.badlogic.gdx.StreamUtils;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/InputListener.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/InputListener.java
index 029f081..ef95e43 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/InputListener.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/InputListener.java
@@ -33,9 +33,7 @@ import com.badlogic.gdx.math.Vector2;
  * </pre>
  */
 public class InputListener implements EventListener {
-	
-	/** Scratch object used by handle().  Event dispatch should only be invoked by the render thread. */
-	private static final Vector2 coords = new Vector2();
+	static private final Vector2 tmpCoords = new Vector2();
 	
 	public boolean handle (Event e) {
 		if (!(e instanceof InputEvent)) return false;
@@ -50,27 +48,27 @@ public class InputListener implements EventListener {
 			return keyTyped(event, event.getCharacter());
 		}
 
-		coords.set(event.getStageX(), event.getStageY());
-		event.getListenerActor().stageToLocalCoordinates(coords);
+		tmpCoords.set(event.getStageX(), event.getStageY());
+		event.getListenerActor().stageToLocalCoordinates(tmpCoords);
 
 		switch (event.getType()) {
 		case touchDown:
-			return touchDown(event, coords.x, coords.y, event.getPointer(), event.getButton());
+			return touchDown(event, tmpCoords.x, tmpCoords.y, event.getPointer(), event.getButton());
 		case touchUp:
-			touchUp(event, coords.x, coords.y, event.getPointer(), event.getButton());
+			touchUp(event, tmpCoords.x, tmpCoords.y, event.getPointer(), event.getButton());
 			return true;
 		case touchDragged:
-			touchDragged(event, coords.x, coords.y, event.getPointer());
+			touchDragged(event, tmpCoords.x, tmpCoords.y, event.getPointer());
 			return true;
 		case mouseMoved:
-			return mouseMoved(event, coords.x, coords.y);
+			return mouseMoved(event, tmpCoords.x, tmpCoords.y);
 		case scrolled:
-			return scrolled(event, coords.x, coords.y, event.getScrollAmount());
+			return scrolled(event, tmpCoords.x, tmpCoords.y, event.getScrollAmount());
 		case enter:
-			enter(event, coords.x, coords.y, event.getPointer(), event.getRelatedActor());
+			enter(event, tmpCoords.x, tmpCoords.y, event.getPointer(), event.getRelatedActor());
 			return false;
 		case exit:
-			exit(event, coords.x, coords.y, event.getPointer(), event.getRelatedActor());
+			exit(event, tmpCoords.x, tmpCoords.y, event.getPointer(), event.getRelatedActor());
 			return false;
 		}
 		return false;
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/Stage.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/Stage.java
index 21f7bed..38de320 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/Stage.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/Stage.java
@@ -54,6 +54,9 @@ import com.badlogic.gdx.utils.SnapshotArray;
  * @author mzechner
  * @author Nathan Sweet */
 public class Stage extends InputAdapter implements Disposable {
+	static private final Vector2 actorCoords = new Vector2();
+	static private final Vector3 cameraCoords = new Vector3();
+
 	private float width, height;
 	private float gutterWidth, gutterHeight;
 	private float centerX, centerY;
@@ -71,12 +74,6 @@ public class Stage extends InputAdapter implements Disposable {
 	private Actor keyboardFocus, scrollFocus;
 	private SnapshotArray<TouchFocus> touchFocuses = new SnapshotArray(true, 4, TouchFocus.class);
 
-	/* Scratch object used by hit(). */
-	private static final Vector2 actorCoords = new Vector2();
-
-	/* Scratch object used by screenToStageCoordinates() and stageToScreenCoordinates(). */
-	private static final Vector3 cameraCoords = new Vector3();
-
 	/** Creates a stage with a {@link #setViewport(float, float, boolean) viewport} equal to the device screen resolution. The stage
 	 * will use its own {@link SpriteBatch}. */
 	public Stage () {
@@ -662,7 +659,7 @@ public class Stage extends InputAdapter implements Disposable {
 		return screenCoords;
 	}
 
-	/** Transforms the stage coordinates to screen coordinates. 
+	/** Transforms the stage coordinates to screen coordinates.
 	 * 
 	 * @param stageCoords input stage coordinates and output for resulting screen coordinates */
 	public Vector2 stageToScreenCoordinates (Vector2 stageCoords) {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/Actions.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/Actions.java
index 31344da..57431f7 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/Actions.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/Actions.java
@@ -20,6 +20,7 @@ import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.math.Interpolation;
 import com.badlogic.gdx.scenes.scene2d.Action;
 import com.badlogic.gdx.scenes.scene2d.Actor;
+import com.badlogic.gdx.scenes.scene2d.EventListener;
 import com.badlogic.gdx.scenes.scene2d.Touchable;
 import com.badlogic.gdx.utils.Pool;
 import com.badlogic.gdx.utils.Pools;
@@ -35,13 +36,32 @@ public class Actions {
 		return action;
 	}
 
-	static public AddAction add (Actor targetActor, Action action) {
+	static public AddAction addAction (Action action) {
+		AddAction addAction = action(AddAction.class);
+		addAction.setAction(action);
+		return addAction;
+	}
+
+	static public AddAction addAction (Action action, Actor targetActor) {
 		AddAction addAction = action(AddAction.class);
 		addAction.setTargetActor(targetActor);
 		addAction.setAction(action);
 		return addAction;
 	}
 
+	static public RemoveAction removeAction (Action action) {
+		RemoveAction removeAction = action(RemoveAction.class);
+		removeAction.setAction(action);
+		return removeAction;
+	}
+
+	static public RemoveAction removeAction (Action action, Actor targetActor) {
+		RemoveAction removeAction = action(RemoveAction.class);
+		removeAction.setTargetActor(targetActor);
+		removeAction.setAction(action);
+		return removeAction;
+	}
+
 	/** Moves the actor instantly. */
 	static public MoveToAction moveTo (float x, float y) {
 		return moveTo(x, y, 0, null);
@@ -420,4 +440,34 @@ public class Actions {
 		afterAction.setAction(action);
 		return afterAction;
 	}
+
+	static public AddListenerAction addListener (EventListener listener, boolean capture) {
+		AddListenerAction addAction = action(AddListenerAction.class);
+		addAction.setListener(listener);
+		addAction.setCapture(capture);
+		return addAction;
+	}
+
+	static public AddListenerAction addListener (EventListener listener, boolean capture, Actor targetActor) {
+		AddListenerAction addAction = action(AddListenerAction.class);
+		addAction.setTargetActor(targetActor);
+		addAction.setListener(listener);
+		addAction.setCapture(capture);
+		return addAction;
+	}
+
+	static public RemoveListenerAction removeListener (EventListener listener, boolean capture) {
+		RemoveListenerAction addAction = action(RemoveListenerAction.class);
+		addAction.setListener(listener);
+		addAction.setCapture(capture);
+		return addAction;
+	}
+
+	static public RemoveListenerAction removeListener (EventListener listener, boolean capture, Actor targetActor) {
+		RemoveListenerAction addAction = action(RemoveListenerAction.class);
+		addAction.setTargetActor(targetActor);
+		addAction.setListener(listener);
+		addAction.setCapture(capture);
+		return addAction;
+	}
 }
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/AddAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/AddAction.java
index 8933c58..dd11d0b 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/AddAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/AddAction.java
@@ -12,7 +12,8 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- ******************************************************************************/
+ ******************************************************************************/
+
 package com.badlogic.gdx.scenes.scene2d.actions;
 
 import com.badlogic.gdx.scenes.scene2d.Action;
@@ -25,7 +26,7 @@ public class AddAction extends Action {
 	private Action action;
 
 	public boolean act (float delta) {
-		targetActor.addAction(action);
+		(targetActor != null ? targetActor : actor).addAction(action);
 		return true;
 	}
 
@@ -33,6 +34,7 @@ public class AddAction extends Action {
 		return targetActor;
 	}
 
+	/** Sets the actor to add an action to. If null (the default), the {@link #getActor() actor} will be used. */
 	public void setTargetActor (Actor actor) {
 		this.targetActor = actor;
 	}
@@ -54,4 +56,4 @@ public class AddAction extends Action {
 		targetActor = null;
 		action = null;
 	}
-}
\ No newline at end of file
+}
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/AddListenerAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/AddListenerAction.java
new file mode 100644
index 0000000..8509aed
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/AddListenerAction.java
@@ -0,0 +1,69 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.scenes.scene2d.actions;
+
+import com.badlogic.gdx.scenes.scene2d.Action;
+import com.badlogic.gdx.scenes.scene2d.Actor;
+import com.badlogic.gdx.scenes.scene2d.EventListener;
+
+/** Adds a listener to an actor.
+ * @author Nathan Sweet */
+public class AddListenerAction extends Action {
+	private Actor targetActor;
+	private EventListener listener;
+	private boolean capture;
+
+	public boolean act (float delta) {
+		Actor actor = (targetActor != null ? targetActor : this.actor);
+		if (capture)
+			targetActor.addCaptureListener(listener);
+		else
+			targetActor.addListener(listener);
+		return true;
+	}
+
+	public Actor getTargetActor () {
+		return targetActor;
+	}
+
+	/** Sets the actor to add a listneer to. If null (the default), the {@link #getActor() actor} will be used. */
+	public void setTargetActor (Actor actor) {
+		this.targetActor = actor;
+	}
+
+	public EventListener getListener () {
+		return listener;
+	}
+
+	public void setListener (EventListener listener) {
+		this.listener = listener;
+	}
+
+	public boolean getCapture () {
+		return capture;
+	}
+
+	public void setCapture (boolean capture) {
+		this.capture = capture;
+	}
+
+	public void reset () {
+		super.reset();
+		targetActor = null;
+		listener = null;
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RemoveAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RemoveAction.java
new file mode 100644
index 0000000..3460108
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RemoveAction.java
@@ -0,0 +1,55 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.scenes.scene2d.actions;
+
+import com.badlogic.gdx.scenes.scene2d.Action;
+import com.badlogic.gdx.scenes.scene2d.Actor;
+
+/** Removes an action from an actor.
+ * @author Nathan Sweet */
+public class RemoveAction extends Action {
+	private Actor targetActor;
+	private Action action;
+
+	public boolean act (float delta) {
+		(targetActor != null ? targetActor : actor).removeAction(action);
+		return true;
+	}
+
+	public Actor getTargetActor () {
+		return targetActor;
+	}
+
+	/** Sets the actor to remove an action from. If null (the default), the {@link #getActor() actor} will be used. */
+	public void setTargetActor (Actor actor) {
+		this.targetActor = actor;
+	}
+
+	public Action getAction () {
+		return action;
+	}
+
+	public void setAction (Action action) {
+		this.action = action;
+	}
+
+	public void reset () {
+		super.reset();
+		targetActor = null;
+		action = null;
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RemoveActorAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RemoveActorAction.java
index 0a83d5f..25ce733 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RemoveActorAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RemoveActorAction.java
@@ -19,7 +19,7 @@ package com.badlogic.gdx.scenes.scene2d.actions;
 import com.badlogic.gdx.scenes.scene2d.Action;
 import com.badlogic.gdx.scenes.scene2d.Actor;
 
-/** Removes the actor the action is attached to or another actor.
+/** Removes an actor from the stage.
  * @author Nathan Sweet */
 public class RemoveActorAction extends Action {
 	private Actor removeActor;
@@ -46,7 +46,7 @@ public class RemoveActorAction extends Action {
 		return removeActor;
 	}
 
-	/** Sets the actor to remove. If null (the default), the {@link #getActor() actor} will be removed. */
+	/** Sets the actor to remove. If null (the default), the {@link #getActor() actor} will be used. */
 	public void setRemoveActor (Actor removeActor) {
 		this.removeActor = removeActor;
 	}
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RemoveListenerAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RemoveListenerAction.java
new file mode 100644
index 0000000..2869484
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/RemoveListenerAction.java
@@ -0,0 +1,69 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.scenes.scene2d.actions;
+
+import com.badlogic.gdx.scenes.scene2d.Action;
+import com.badlogic.gdx.scenes.scene2d.Actor;
+import com.badlogic.gdx.scenes.scene2d.EventListener;
+
+/** Removes a listener from an actor.
+ * @author Nathan Sweet */
+public class RemoveListenerAction extends Action {
+	private Actor targetActor;
+	private EventListener listener;
+	private boolean capture;
+
+	public boolean act (float delta) {
+		Actor actor = (targetActor != null ? targetActor : this.actor);
+		if (capture)
+			actor.removeCaptureListener(listener);
+		else
+			actor.removeListener(listener);
+		return true;
+	}
+
+	public Actor getTargetActor () {
+		return targetActor;
+	}
+
+	/** Sets the actor to remove a listner from. If null (the default), the {@link #getActor() actor} will be used. */
+	public void setTargetActor (Actor actor) {
+		this.targetActor = actor;
+	}
+
+	public EventListener getListener () {
+		return listener;
+	}
+
+	public void setListener (EventListener listener) {
+		this.listener = listener;
+	}
+
+	public boolean getCapture () {
+		return capture;
+	}
+
+	public void setCapture (boolean capture) {
+		this.capture = capture;
+	}
+
+	public void reset () {
+		super.reset();
+		targetActor = null;
+		listener = null;
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ButtonGroup.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ButtonGroup.java
index 3de1422..244c7c3 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ButtonGroup.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ButtonGroup.java
@@ -71,7 +71,7 @@ public class ButtonGroup {
 		if (text == null) throw new IllegalArgumentException("text cannot be null.");
 		for (int i = 0, n = buttons.size; i < n; i++) {
 			Button button = buttons.get(i);
-			if (button instanceof TextButton && text.equals(((TextButton)button).getText())) {
+			if (button instanceof TextButton && text.contentEquals(((TextButton)button).getText())) {
 				button.setChecked(true);
 				return;
 			}
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Dialog.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Dialog.java
index 871bcf7..d03a754 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Dialog.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Dialog.java
@@ -19,7 +19,6 @@ package com.badlogic.gdx.scenes.scene2d.ui;
 import static com.badlogic.gdx.scenes.scene2d.actions.Actions.*;
 
 import com.badlogic.gdx.Input.Keys;
-import com.badlogic.gdx.graphics.g2d.SpriteBatch;
 import com.badlogic.gdx.math.Interpolation;
 import com.badlogic.gdx.scenes.scene2d.Actor;
 import com.badlogic.gdx.scenes.scene2d.Group;
@@ -29,10 +28,8 @@ import com.badlogic.gdx.scenes.scene2d.Stage;
 import com.badlogic.gdx.scenes.scene2d.actions.Actions;
 import com.badlogic.gdx.scenes.scene2d.ui.Label.LabelStyle;
 import com.badlogic.gdx.scenes.scene2d.ui.TextButton.TextButtonStyle;
-import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
 import com.badlogic.gdx.scenes.scene2d.utils.FocusListener;
-import com.badlogic.gdx.scenes.scene2d.utils.FocusListener.FocusEvent;
 import com.badlogic.gdx.utils.ObjectMap;
 
 /** Displays a dialog, which is a modal window containing a content table with a button table underneath it. Methods are provided
@@ -49,6 +46,13 @@ public class Dialog extends Window {
 	boolean cancelHide;
 	Actor previousKeyboardFocus, previousScrollFocus;
 
+	InputListener ignoreTouchDown = new InputListener() {
+		public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
+			event.cancel();
+			return false;
+		}
+	};
+
 	public Dialog (String title, Skin skin) {
 		super(title, skin.get(WindowStyle.class));
 		this.skin = skin;
@@ -79,6 +83,7 @@ public class Dialog extends Window {
 
 		buttonTable.addListener(new ChangeListener() {
 			public void changed (ChangeEvent event, Actor actor) {
+				if (!values.containsKey(actor)) return;
 				while (actor.getParent() != buttonTable)
 					actor = actor.getParent();
 				result(values.get(actor));
@@ -98,7 +103,8 @@ public class Dialog extends Window {
 
 			private void focusChanged (FocusEvent event) {
 				Stage stage = getStage();
-				if (isModal && stage != null && stage.getRoot().getChildren().peek() == Dialog.this) { // Dialog is top most actor.
+				if (isModal && stage != null && stage.getRoot().getChildren().size > 0
+					&& stage.getRoot().getChildren().peek() == Dialog.this) { // Dialog is top most actor.
 					Actor newFocusedActor = event.getRelatedActor();
 					if (newFocusedActor == null || !newFocusedActor.isDescendantOf(Dialog.this)) event.cancel();
 				}
@@ -168,6 +174,7 @@ public class Dialog extends Window {
 	/** {@link #pack() Packs} the dialog and adds it to the stage, centered. */
 	public Dialog show (Stage stage) {
 		clearActions();
+		removeCaptureListener(ignoreTouchDown);
 		previousKeyboardFocus = stage.getKeyboardFocus();
 		previousScrollFocus = stage.getScrollFocus();
 		pack();
@@ -185,7 +192,12 @@ public class Dialog extends Window {
 	/** Hides the dialog. Called automatically when a button is clicked. The default implementation fades out the dialog over
 	 * {@link #fadeDuration} seconds and then removes it from the stage. */
 	public void hide () {
-		addAction(sequence(fadeOut(fadeDuration, Interpolation.fade), Actions.removeActor()));
+		if (fadeDuration > 0) {
+			addCaptureListener(ignoreTouchDown);
+			addAction(sequence(fadeOut(fadeDuration, Interpolation.fade), Actions.removeListener(ignoreTouchDown, true),
+				Actions.removeActor()));
+		} else
+			remove();
 	}
 
 	protected void setParent (Group parent) {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/List.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/List.java
index 895e18a..6f1b523 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/List.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/List.java
@@ -72,9 +72,11 @@ public class List extends Widget implements Cullable {
 		selectedIndex = (int)((getHeight() - y) / itemHeight);
 		selectedIndex = Math.max(0, selectedIndex);
 		selectedIndex = Math.min(items.length - 1, selectedIndex);
-		ChangeEvent changeEvent = Pools.obtain(ChangeEvent.class);
-		if (fire(changeEvent)) selectedIndex = oldIndex;
-		Pools.free(changeEvent);
+		if (oldIndex != selectedIndex) {
+			ChangeEvent changeEvent = Pools.obtain(ChangeEvent.class);
+			if (fire(changeEvent)) selectedIndex = oldIndex;
+			Pools.free(changeEvent);
+		}
 	}
 
 	public void setStyle (ListStyle style) {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ScrollPane.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ScrollPane.java
index 8a064c8..caea4a2 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ScrollPane.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ScrollPane.java
@@ -96,9 +96,8 @@ public class ScrollPane extends WidgetGroup {
 	/** @param widget May be null. */
 	public ScrollPane (Actor widget, ScrollPaneStyle style) {
 		if (style == null) throw new IllegalArgumentException("style cannot be null.");
-		this.widget = widget;
 		this.style = style;
-		if (widget != null) setWidget(widget);
+		setWidget(widget);
 		setWidth(150);
 		setHeight(150);
 
@@ -568,6 +567,7 @@ public class ScrollPane extends WidgetGroup {
 	/** Sets the {@link Actor} embedded in this scroll pane.
 	 * @param widget May be null to remove any current actor. */
 	public void setWidget (Actor widget) {
+		if(widget == this) throw new IllegalArgumentException("widget cannot be same object");
 		if (this.widget != null) super.removeActor(this.widget);
 		this.widget = widget;
 		if (widget != null) super.addActor(widget);
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SelectBox.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SelectBox.java
index 9bb6374..6e0a7cc 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SelectBox.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SelectBox.java
@@ -43,6 +43,8 @@ import com.badlogic.gdx.utils.Pools;
  * @author mzechner
  * @author Nathan Sweet */
 public class SelectBox extends Widget {
+	static final Vector2 tmpCoords = new Vector2();
+
 	SelectBoxStyle style;
 	String[] items;
 	int selectedIndex = 0;
@@ -52,9 +54,6 @@ public class SelectBox extends Widget {
 	private float prefWidth, prefHeight;
 	private ClickListener clickListener;
 
-	/** Scratch space for converting to/from stage coordinates. Only used in listener callbacks (so only on render thread). */
-	static final Vector2 tmpCoords = new Vector2();
-
 	public SelectBox (Object[] items, Skin skin) {
 		this(items, skin.get(SelectBoxStyle.class));
 	}
@@ -196,12 +195,14 @@ public class SelectBox extends Widget {
 	}
 
 	public void hideList () {
-		if (list.getParent() == null) return;
+		if (list == null || list.getParent() == null) return;
+
+		getStage().removeCaptureListener(list.stageListener);
 		list.addAction(sequence(fadeOut(0.15f, Interpolation.fade), removeActor()));
 	}
 
 	class SelectList extends Actor {
-		Vector2 oldScreenCoords = new Vector2();
+		final Vector2 oldScreenCoords = new Vector2();
 		float itemHeight;
 		float textOffsetX, textOffsetY;
 		int listSelectedIndex = SelectBox.this.selectedIndex;
@@ -213,7 +214,7 @@ public class SelectBox extends Widget {
 				x = tmpCoords.x;
 				y = tmpCoords.y;
 				if (x > 0 && x < getWidth() && y > 0 && y < getHeight()) {
-					listSelectedIndex = (int)((getHeight() - y) / itemHeight);
+					listSelectedIndex = (int) ((getHeight() - style.listBackground.getTopHeight() - y) / itemHeight);
 					listSelectedIndex = Math.max(0, listSelectedIndex);
 					listSelectedIndex = Math.min(items.length - 1, listSelectedIndex);
 					selectedIndex = listSelectedIndex;
@@ -228,7 +229,6 @@ public class SelectBox extends Widget {
 
 			public void touchUp (InputEvent event, float x, float y, int pointer, int button) {
 				hideList();
-				event.getStage().removeCaptureListener(stageListener);
 			}
 
 			public boolean mouseMoved (InputEvent event, float x, float y) {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextField.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextField.java
index 3685d77..67bebe9 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextField.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextField.java
@@ -63,6 +63,10 @@ public class TextField extends Widget {
 	static private final char DELETE = 127;
 	static private final char BULLET = 149;
 
+	static private final Vector2 tmp1 = new Vector2();
+	static private final Vector2 tmp2 = new Vector2();
+	static private final Vector2 tmp3 = new Vector2();
+
 	TextFieldStyle style;
 	String text, messageText;
 	private CharSequence displayText;
@@ -100,7 +104,7 @@ public class TextField extends Widget {
 	float keyRepeatInitialTime = 0.4f;
 	float keyRepeatTime = 0.1f;
 	boolean rightAligned;
-	
+
 	int maxLength = 0;
 
 	public TextField (String text, Skin skin) {
@@ -129,7 +133,7 @@ public class TextField extends Widget {
 			public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
 				if (!super.touchDown(event, x, y, pointer, button)) return false;
 				if (pointer == 0 && button != 0) return false;
-				if (disabled) return true;				
+				if (disabled) return true;
 				clearSelection();
 				setCursorPosition(x);
 				selectionStart = cursor;
@@ -360,12 +364,12 @@ public class TextField extends Widget {
 			}
 		});
 	}
-	
-	public void setMaxLength(int maxLength) {
+
+	public void setMaxLength (int maxLength) {
 		this.maxLength = maxLength;
 	}
-	
-	public int getMaxLength() {
+
+	public int getMaxLength () {
 		return this.maxLength;
 	}
 
@@ -482,7 +486,7 @@ public class TextField extends Widget {
 				} else
 					font.setColor(0.7f, 0.7f, 0.7f, parentAlpha);
 				BitmapFont messageFont = style.messageFont != null ? style.messageFont : font;
-				font.draw(batch, messageText, x + bgLeftWidth, y + textY + yOffset);
+				messageFont.draw(batch, messageText, x + bgLeftWidth, y + textY + yOffset);
 			}
 		} else {
 			font.setColor(fontColor.r, fontColor.g, fontColor.b, fontColor.a * parentAlpha);
@@ -583,14 +587,6 @@ public class TextField extends Widget {
 		cursor = minIndex;
 		clearSelection();
 	}
-	
-	/*
-	 * Three hacks to work around the inability to stack allocate small scratch-space objects in Java.  
-	 * Used by #next() and #findNextTextField.
-	 */
-	private static final Vector2 tmp1 = new Vector2();
-	private static final Vector2 tmp2 = new Vector2();
-	private static final Vector2 tmp3 = new Vector2();
 
 	/** Focuses the next TextField. If none is found, the keyboard is hidden. Does nothing if the text field is not in a stage.
 	 * @param up If true, the TextField with the same or next smallest y coordinate is found, else the next highest. */
@@ -773,16 +769,16 @@ public class TextField extends Widget {
 	public boolean isDisabled () {
 		return disabled;
 	}
-	
-	public boolean isPasswordMode(){
+
+	public boolean isPasswordMode () {
 		return passwordMode;
 	}
-	
-	public TextFieldFilter getTextFieldFilter(){
+
+	public TextFieldFilter getTextFieldFilter () {
 		return filter;
 	}
 
- 	class KeyRepeatTask extends Task {
+	class KeyRepeatTask extends Task {
 		int keycode;
 
 		public void run () {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Window.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Window.java
index 476f1f0..ed4d439 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Window.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Window.java
@@ -36,6 +36,9 @@ import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
  * children to the window, it can be convenient to call {@link #pack()} to size the window to the size of the children.
  * @author Nathan Sweet */
 public class Window extends Table {
+	static private final Vector2 tmpPosition = new Vector2();
+	static private final Vector2 tmpSize = new Vector2();
+
 	private WindowStyle style;
 	private String title;
 	private BitmapFontCache titleCache;
@@ -135,22 +138,16 @@ public class Window extends Table {
 		}
 		super.draw(batch, parentAlpha);
 	}
-	
-	/*
-	 * Hacks to work around the inability to stack allocate small scratch objects in Java.
-	 */
-	
-	private static final Vector2 tmpPosition = new Vector2();
-	private static final Vector2 tmpSize = new Vector2();
 
 	protected void drawBackground (SpriteBatch batch, float parentAlpha) {
 		if (style.stageBackground != null) {
 			Color color = getColor();
 			batch.setColor(color.r, color.g, color.b, color.a * parentAlpha);
 			Stage stage = getStage();
-			stageToLocalCoordinates(/*in/out*/tmpPosition.set(0, 0));
-			stageToLocalCoordinates(/*in/out*/tmpSize.set(stage.getWidth(), stage.getHeight()));
-			style.stageBackground.draw(batch, getX() + tmpPosition.x, getY() + tmpPosition.y, getX() + tmpSize.x, getY() + tmpSize.y);
+			stageToLocalCoordinates(/* in/out */tmpPosition.set(0, 0));
+			stageToLocalCoordinates(/* in/out */tmpSize.set(stage.getWidth(), stage.getHeight()));
+			style.stageBackground
+				.draw(batch, getX() + tmpPosition.x, getY() + tmpPosition.y, getX() + tmpSize.x, getY() + tmpSize.y);
 		}
 
 		super.drawBackground(batch, parentAlpha);
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/ActorGestureListener.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/ActorGestureListener.java
index 403af8a..dc42434 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/ActorGestureListener.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/ActorGestureListener.java
@@ -29,13 +29,12 @@ import com.badlogic.gdx.scenes.scene2d.InputEvent;
  * @see GestureDetector
  * @author Nathan Sweet */
 public class ActorGestureListener implements EventListener {
+	static final Vector2 tmpCoords = new Vector2();
+
 	private final GestureDetector detector;
 	InputEvent event;
 	Actor actor, touchDownTarget;
-	
-	/** Scratch coordinates used to convert event coordinates into local coordinates. */
-	static final Vector2 tmpCoords = new Vector2();
-	
+
 	/** @see GestureDetector#GestureDetector(com.badlogic.gdx.input.GestureDetector.GestureListener) */
 	public ActorGestureListener () {
 		this(20, 0.4f, 1.1f, 0.15f);
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/ClickListener.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/ClickListener.java
index ce6fef7..bf96bff 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/ClickListener.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/ClickListener.java
@@ -68,9 +68,9 @@ public class ClickListener extends InputListener {
 	public void touchUp (InputEvent event, float x, float y, int pointer, int button) {
 		if (pointer == pressedPointer) {
 			if (!cancelled) {
-				boolean validClick = isOver(event.getListenerActor(), x, y);
-				if (validClick && pointer == 0 && this.button != -1 && button != this.button) validClick = false;
-				if (validClick) {
+				over = isOver(event.getListenerActor(), x, y);
+				if (over && pointer == 0 && this.button != -1 && button != this.button) over = false;
+				if (over) {
 					long time = TimeUtils.nanoTime();
 					if (time - lastTapTime > tapCountInterval) tapCount = 0;
 					tapCount++;
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/DragAndDrop.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/DragAndDrop.java
index 6937eb1..2be80c4 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/DragAndDrop.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/DragAndDrop.java
@@ -28,6 +28,8 @@ import com.badlogic.gdx.utils.ObjectMap;
 /** Manages drag and drop operations through registered drag sources and drop targets.
  * @author Nathan Sweet */
 public class DragAndDrop {
+	static final Vector2 tmpVector = new Vector2();
+
 	Source source;
 	Payload payload;
 	Actor dragActor;
@@ -42,9 +44,6 @@ public class DragAndDrop {
 	int dragTime = 250;
 	int activePointer = -1;
 
-	/* Scratch vector used to convert event's stage coordinates to local coordinates. */
-	static final Vector2 tmpVector = new Vector2();
-
 	public void addSource (final Source source) {
 		DragListener listener = new DragListener() {
 			public void dragStart (InputEvent event, float x, float y, int pointer) {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/NinePatchDrawable.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/NinePatchDrawable.java
index 7e7bfc4..ee57246 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/NinePatchDrawable.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/NinePatchDrawable.java
@@ -31,7 +31,7 @@ import com.badlogic.gdx.graphics.g2d.SpriteBatch;
 public class NinePatchDrawable extends BaseDrawable {
 	private NinePatch patch;
 
-	/** Creates an unitialized NinePatchDrawable. The ninepatch must be set before use. */
+	/** Creates an uninitialized NinePatchDrawable. The ninepatch must be {@link #setPatch(NinePatch) set} before use. */
 	public NinePatchDrawable () {
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/utils/Json.java b/gdx/src/com/badlogic/gdx/utils/Json.java
index da4b9bf..a519e84 100644
--- a/gdx/src/com/badlogic/gdx/utils/Json.java
+++ b/gdx/src/com/badlogic/gdx/utils/Json.java
@@ -35,6 +35,7 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 
 /** Reads/writes Java objects to/from JSON, automatically.
@@ -483,7 +484,7 @@ public class Json {
 				return;
 			}
 
-			if (actualType.isEnum()) {
+			if (Enum.class.isAssignableFrom(actualType)) {
 				writer.value(value);
 				return;
 			}
@@ -831,9 +832,8 @@ public class Json {
 					newArray.add(readValue(elementType, null, array.get(i)));
 				return (T)newArray;
 			}
-			if (ArrayList.class.isAssignableFrom(type)) {
-				ArrayList newArray = type == null ? new ArrayList() : (ArrayList)newInstance(type);
-				newArray.ensureCapacity(array.size);
+			if (List.class.isAssignableFrom(type)) {
+				List newArray = type == null ? new ArrayList(array.size) : (List)newInstance(type);
 				for (int i = 0, n = array.size; i < n; i++)
 					newArray.add(readValue(elementType, null, array.get(i)));
 				return (T)newArray;
@@ -879,7 +879,7 @@ public class Json {
 			}
 			if (type == boolean.class || type == Boolean.class) return (T)Boolean.valueOf(string);
 			if (type == char.class || type == Character.class) return (T)(Character)string.charAt(0);
-			if (type.isEnum()) {
+			if (Enum.class.isAssignableFrom(type)) {
 				Object[] constants = type.getEnumConstants();
 				for (int i = 0, n = constants.length; i < n; i++)
 					if (string.equals(constants[i].toString())) return (T)constants[i];
diff --git a/gdx/src/com/badlogic/gdx/utils/Scaling.java b/gdx/src/com/badlogic/gdx/utils/Scaling.java
index b2151b2..d399079 100644
--- a/gdx/src/com/badlogic/gdx/utils/Scaling.java
+++ b/gdx/src/com/badlogic/gdx/utils/Scaling.java
@@ -44,7 +44,7 @@ public enum Scaling {
 	/** The source is not scaled. */
 	none;
 
-	static private Vector2 temp = new Vector2();
+	static private final Vector2 temp = new Vector2();
 
 	/** Returns the size of the source scaled to the target. Note the same Vector2 instance is always returned and should never be
 	 * cached. */
diff --git a/gdx/src/com/badlogic/gdx/utils/SharedLibraryLoader.java b/gdx/src/com/badlogic/gdx/utils/SharedLibraryLoader.java
index 726125e..f49f1d8 100644
--- a/gdx/src/com/badlogic/gdx/utils/SharedLibraryLoader.java
+++ b/gdx/src/com/badlogic/gdx/utils/SharedLibraryLoader.java
@@ -30,7 +30,8 @@ import java.util.zip.ZipFile;
 /** Loads shared libraries from a natives jar file (desktop) or arm folders (Android). For desktop projects, have the natives jar
  * in the classpath, for Android projects put the shared libraries in the libs/armeabi and libs/armeabi-v7a folders.
  * 
- * @author mzechner */
+ * @author mzechner
+ * @author Nathan Sweet */
 public class SharedLibraryLoader {
 	static public boolean isWindows = System.getProperty("os.name").contains("Windows");
 	static public boolean isLinux = System.getProperty("os.name").contains("Linux");
@@ -106,8 +107,17 @@ public class SharedLibraryLoader {
 		try {
 			if (isAndroid)
 				System.loadLibrary(libraryName);
-			else
-				System.load(extractFile(libraryName, null).getAbsolutePath());
+			else {
+				File f = extractFile(libraryName, null);
+				if (f != null){
+					System.load(f.getAbsolutePath());
+				}else{
+					// fallback for applets, see https://code.google.com/p/libgdx/issues/detail?id=1290
+					String fallback = new File(System.getProperty("java.library.path")+"/"+libraryName).getAbsolutePath();
+					System.load(fallback);
+				}
+			}
+			
 		} catch (Throwable ex) {
 			throw new GdxRuntimeException("Couldn't load shared library '" + libraryName + "' for target: "
 				+ System.getProperty("os.name") + (is64Bit ? ", 64-bit" : ", 32-bit"), ex);
diff --git a/gdx/src/com/badlogic/gdx/utils/ShortArray.java b/gdx/src/com/badlogic/gdx/utils/ShortArray.java
new file mode 100644
index 0000000..cc3cc9c
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/utils/ShortArray.java
@@ -0,0 +1,317 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.utils;
+
+import java.util.Arrays;
+
+import com.badlogic.gdx.math.MathUtils;
+
+/** A resizable, ordered or unordered short array. Avoids the boxing that occurs with ArrayList<Short>. If unordered, this class
+ * avoids a memory copy when removing elements (the last element is moved to the removed element's position).
+ * @author Nathan Sweet */
+public class ShortArray {
+	public short[] items;
+	public int size;
+	public boolean ordered;
+
+	/** Creates an ordered array with a capacity of 16. */
+	public ShortArray () {
+		this(true, 16);
+	}
+
+	/** Creates an ordered array with the specified capacity. */
+	public ShortArray (int capacity) {
+		this(true, capacity);
+	}
+
+	/** @param ordered If false, methods that remove elements may change the order of other elements in the array, which avoids a
+	 *           memory copy.
+	 * @param capacity Any elements added beyond this will cause the backing array to be grown. */
+	public ShortArray (boolean ordered, int capacity) {
+		this.ordered = ordered;
+		items = new short[capacity];
+	}
+
+	/** Creates a new array containing the elements in the specific array. The new array will be ordered if the specific array is
+	 * ordered. The capacity is set to the number of elements, so any subsequent elements added will cause the backing array to be
+	 * grown. */
+	public ShortArray (ShortArray array) {
+		this.ordered = array.ordered;
+		size = array.size;
+		items = new short[size];
+		System.arraycopy(array.items, 0, items, 0, size);
+	}
+
+	/** Creates a new ordered array containing the elements in the specified array. The capacity is set to the number of elements,
+	 * so any subsequent elements added will cause the backing array to be grown. */
+	public ShortArray (short[] array) {
+		this(true, array);
+	}
+
+	/** Creates a new array containing the elements in the specified array. The capacity is set to the number of elements, so any
+	 * subsequent elements added will cause the backing array to be grown.
+	 * @param ordered If false, methods that remove elements may change the order of other elements in the array, which avoids a
+	 *           memory copy. */
+	public ShortArray (boolean ordered, short[] array) {
+		this(ordered, array.length);
+		size = array.length;
+		System.arraycopy(array, 0, items, 0, size);
+	}
+
+	public void add (short value) {
+		short[] items = this.items;
+		if (size == items.length) items = resize(Math.max(8, (int)(size * 1.75f)));
+		items[size++] = value;
+	}
+
+	public void addAll (ShortArray array) {
+		addAll(array, 0, array.size);
+	}
+
+	public void addAll (ShortArray array, int offset, int length) {
+		if (offset + length > array.size)
+			throw new IllegalArgumentException("offset + length must be <= size: " + offset + " + " + length + " <= " + array.size);
+		addAll(array.items, offset, length);
+	}
+
+	public void addAll (short[] array) {
+		addAll(array, 0, array.length);
+	}
+
+	public void addAll (short[] array, int offset, int length) {
+		short[] items = this.items;
+		int sizeNeeded = size + length - offset;
+		if (sizeNeeded >= items.length) items = resize(Math.max(8, (int)(sizeNeeded * 1.75f)));
+		System.arraycopy(array, offset, items, size, length);
+		size += length;
+	}
+
+	public short get (int index) {
+		if (index >= size) throw new IndexOutOfBoundsException(String.valueOf(index));
+		return items[index];
+	}
+
+	public void set (int index, short value) {
+		if (index >= size) throw new IndexOutOfBoundsException(String.valueOf(index));
+		items[index] = value;
+	}
+
+	public void insert (int index, short value) {
+		short[] items = this.items;
+		if (size == items.length) items = resize(Math.max(8, (int)(size * 1.75f)));
+		if (ordered)
+			System.arraycopy(items, index, items, index + 1, size - index);
+		else
+			items[size] = items[index];
+		size++;
+		items[index] = value;
+	}
+
+	public void swap (int first, int second) {
+		if (first >= size) throw new IndexOutOfBoundsException(String.valueOf(first));
+		if (second >= size) throw new IndexOutOfBoundsException(String.valueOf(second));
+		short[] items = this.items;
+		short firstValue = items[first];
+		items[first] = items[second];
+		items[second] = firstValue;
+	}
+
+	public boolean contains (short value) {
+		int i = size - 1;
+		short[] items = this.items;
+		while (i >= 0)
+			if (items[i--] == value) return true;
+		return false;
+	}
+
+	public int indexOf (short value) {
+		short[] items = this.items;
+		for (int i = 0, n = size; i < n; i++)
+			if (items[i] == value) return i;
+		return -1;
+	}
+
+	public int lastIndexOf (char value) {
+		short[] items = this.items;
+		for (int i = size - 1; i >= 0; i--)
+			if (items[i] == value) return i;
+		return -1;
+	}
+
+	public boolean removeValue (short value) {
+		short[] items = this.items;
+		for (int i = 0, n = size; i < n; i++) {
+			if (items[i] == value) {
+				removeIndex(i);
+				return true;
+			}
+		}
+		return false;
+	}
+
+	/** Removes and returns the item at the specified index. */
+	public short removeIndex (int index) {
+		if (index >= size) throw new IndexOutOfBoundsException(String.valueOf(index));
+		short[] items = this.items;
+		short value = items[index];
+		size--;
+		if (ordered)
+			System.arraycopy(items, index + 1, items, index, size - index);
+		else
+			items[index] = items[size];
+		return value;
+	}
+
+	/** Removes from this array all of elements contained in the specified array.
+	 * @return true if this array was modified. */
+	public boolean removeAll (ShortArray array) {
+		int size = this.size;
+		int startSize = size;
+		short[] items = this.items;
+		for (int i = 0, n = array.size; i < n; i++) {
+			short item = array.get(i);
+			for (int ii = 0; ii < size; ii++) {
+				if (item == items[ii]) {
+					removeIndex(ii);
+					size--;
+					break;
+				}
+			}
+		}
+		return size != startSize;
+	}
+
+	/** Removes and returns the last item. */
+	public short pop () {
+		return items[--size];
+	}
+
+	/** Returns the last item. */
+	public short peek () {
+		return items[size - 1];
+	}
+
+	/** Returns the first item. */
+	public short first () {
+		if (size == 0) throw new IllegalStateException("Array is empty.");
+		return items[0];
+	}
+
+	public void clear () {
+		size = 0;
+	}
+
+	/** Reduces the size of the backing array to the size of the actual items. This is useful to release memory when many items have
+	 * been removed, or if it is known that more items will not be added. */
+	public void shrink () {
+		resize(size);
+	}
+
+	/** Increases the size of the backing array to acommodate the specified number of additional items. Useful before adding many
+	 * items to avoid multiple backing array resizes.
+	 * @return {@link #items} */
+	public short[] ensureCapacity (int additionalCapacity) {
+		int sizeNeeded = size + additionalCapacity;
+		if (sizeNeeded >= items.length) resize(Math.max(8, sizeNeeded));
+		return items;
+	}
+
+	protected short[] resize (int newSize) {
+		short[] newItems = new short[newSize];
+		short[] items = this.items;
+		System.arraycopy(items, 0, newItems, 0, Math.min(size, newItems.length));
+		this.items = newItems;
+		return newItems;
+	}
+
+	public void sort () {
+		Arrays.sort(items, 0, size);
+	}
+
+	public void reverse () {
+		for (int i = 0, lastIndex = size - 1, n = size / 2; i < n; i++) {
+			int ii = lastIndex - i;
+			short temp = items[i];
+			items[i] = items[ii];
+			items[ii] = temp;
+		}
+	}
+
+	public void shuffle () {
+		for (int i = size - 1; i >= 0; i--) {
+			int ii = MathUtils.random(i);
+			short temp = items[i];
+			items[i] = items[ii];
+			items[ii] = temp;
+		}
+	}
+
+	/** Reduces the size of the array to the specified size. If the array is already smaller than the specified size, no action is
+	 * taken. */
+	public void truncate (int newSize) {
+		if (size > newSize) size = newSize;
+	}
+
+	/** Returns a random item from the array, or zero if the array is empty. */
+	public short random () {
+		if (size == 0) return 0;
+		return items[MathUtils.random(0, size - 1)];
+	}
+
+	public short[] toArray () {
+		short[] array = new short[size];
+		System.arraycopy(items, 0, array, 0, size);
+		return array;
+	}
+
+	public boolean equals (Object object) {
+		if (object == this) return true;
+		if (!(object instanceof ShortArray)) return false;
+		ShortArray array = (ShortArray)object;
+		int n = size;
+		if (n != array.size) return false;
+		for (int i = 0; i < n; i++)
+			if (items[i] != array.items[i]) return false;
+		return true;
+	}
+
+	public String toString () {
+		if (size == 0) return "[]";
+		short[] items = this.items;
+		StringBuilder buffer = new StringBuilder(32);
+		buffer.append('[');
+		buffer.append(items[0]);
+		for (int i = 1; i < size; i++) {
+			buffer.append(", ");
+			buffer.append(items[i]);
+		}
+		buffer.append(']');
+		return buffer.toString();
+	}
+
+	public String toString (String separator) {
+		if (size == 0) return "";
+		short[] items = this.items;
+		StringBuilder buffer = new StringBuilder(32);
+		buffer.append(items[0]);
+		for (int i = 1; i < size; i++) {
+			buffer.append(separator);
+			buffer.append(items[i]);
+		}
+		return buffer.toString();
+	}
+}
diff --git a/tests/gdx-tests-gwt/.settings/com.google.gdt.eclipse.core.prefs b/tests/gdx-tests-gwt/.settings/com.google.gdt.eclipse.core.prefs
index 920a7e7..f2d1bdc 100644
--- a/tests/gdx-tests-gwt/.settings/com.google.gdt.eclipse.core.prefs
+++ b/tests/gdx-tests-gwt/.settings/com.google.gdt.eclipse.core.prefs
@@ -1,5 +1,5 @@
 eclipse.preferences.version=1
 jarsExcludedFromWebInfLib=
-lastWarOutDir=D\:/workspaces/libgdx-new/libgdx/tests/gdx-tests-gwt/war
+lastWarOutDir=/Users/badlogic/workspace/libgdx/tests/gdx-tests-gwt/war
 warSrcDir=war
 warSrcDirIsOutput=false
diff --git a/tests/gdx-tests-jglfw/.classpath b/tests/gdx-tests-jglfw/.classpath
new file mode 100644
index 0000000..212e591
--- /dev/null
+++ b/tests/gdx-tests-jglfw/.classpath
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="tests-assets"/>
+	<classpathentry combineaccessrules="false" exported="true" kind="src" path="/gdx"/>
+	<classpathentry combineaccessrules="false" exported="true" kind="src" path="/gdx-backend-jglfw"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/gdx-bullet"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/gdx-controllers"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/gdx-freetype"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/gdx-image"/>
+	<classpathentry combineaccessrules="false" exported="true" kind="src" path="/gdx-tests"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/gdx-controllers-desktop"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/tests/gdx-tests-jglfw/.project b/tests/gdx-tests-jglfw/.project
new file mode 100644
index 0000000..722e77e
--- /dev/null
+++ b/tests/gdx-tests-jglfw/.project
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>gdx-tests-jglfw</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+	<linkedResources>
+		<link>
+			<name>tests-assets</name>
+			<type>2</type>
+			<locationURI>PARENT-1-PROJECT_LOC/gdx-tests-android/assets</locationURI>
+		</link>
+	</linkedResources>
+</projectDescription>
diff --git a/tests/gdx-tests-jglfw/.settings/org.eclipse.jdt.core.prefs b/tests/gdx-tests-jglfw/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..8000cd6
--- /dev/null
+++ b/tests/gdx-tests-jglfw/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,11 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.6
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.6
diff --git a/tests/gdx-tests-jglfw/src/com/badlogic/gdx/jglfw/tests/JglfwDebugStarter.java b/tests/gdx-tests-jglfw/src/com/badlogic/gdx/jglfw/tests/JglfwDebugStarter.java
new file mode 100644
index 0000000..2ada9cb
--- /dev/null
+++ b/tests/gdx-tests-jglfw/src/com/badlogic/gdx/jglfw/tests/JglfwDebugStarter.java
@@ -0,0 +1,26 @@
+
+package com.badlogic.gdx.jglfw.tests;
+
+import com.badlogic.gdx.backends.jglfw.JglfwApplication;
+import com.badlogic.gdx.backends.jglfw.JglfwApplicationConfiguration;
+import com.badlogic.gdx.tests.superkoalio.SuperKoalio;
+import com.badlogic.gdx.tests.utils.GdxTest;
+import com.badlogic.gdx.utils.SharedLibraryLoader;
+
+public class JglfwDebugStarter {
+	public static void main (String[] argv) {
+		// this is only here for me to debug native code faster
+		new SharedLibraryLoader("../../extensions/gdx-audio/libs/gdx-audio-natives.jar").load("gdx-audio");
+		new SharedLibraryLoader("../../extensions/gdx-image/libs/gdx-image-natives.jar").load("gdx-image");
+		new SharedLibraryLoader("../../extensions/gdx-freetype/libs/gdx-freetype-natives.jar").load("gdx-freetype");
+		new SharedLibraryLoader("../../extensions/gdx-controllers/gdx-controllers-desktop/libs/gdx-controllers-desktop-natives.jar")
+			.load("gdx-controllers-desktop");
+		new SharedLibraryLoader("../../gdx/libs/gdx-natives.jar").load("gdx");
+
+		GdxTest test = new SuperKoalio();
+		JglfwApplicationConfiguration config = new JglfwApplicationConfiguration();
+		config.vSync = true;
+		config.useGL20 = test.needsGL20();
+		new JglfwApplication(test, config);
+	}
+}
diff --git a/tests/gdx-tests-jglfw/src/com/badlogic/gdx/jglfw/tests/JglfwTestStarter.java b/tests/gdx-tests-jglfw/src/com/badlogic/gdx/jglfw/tests/JglfwTestStarter.java
new file mode 100644
index 0000000..9bcaf36
--- /dev/null
+++ b/tests/gdx-tests-jglfw/src/com/badlogic/gdx/jglfw/tests/JglfwTestStarter.java
@@ -0,0 +1,146 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.jglfw.tests;
+
+import com.badlogic.gdx.LifecycleListener;
+import com.badlogic.gdx.Preferences;
+import com.badlogic.gdx.backends.jglfw.JglfwApplication;
+import com.badlogic.gdx.backends.jglfw.JglfwApplicationConfiguration;
+import com.badlogic.gdx.backends.jglfw.JglfwFiles;
+import com.badlogic.gdx.backends.jglfw.JglfwPreferences;
+import com.badlogic.gdx.files.FileHandle;
+import com.badlogic.gdx.tests.utils.GdxTest;
+import com.badlogic.gdx.tests.utils.GdxTests;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+import java.awt.BorderLayout;
+import java.awt.EventQueue;
+import java.awt.HeadlessException;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.awt.event.KeyAdapter;
+import java.awt.event.KeyEvent;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+
+import javax.swing.DefaultListSelectionModel;
+import javax.swing.JButton;
+import javax.swing.JFrame;
+import javax.swing.JList;
+import javax.swing.JPanel;
+import javax.swing.JScrollPane;
+import javax.swing.ListSelectionModel;
+import javax.swing.UIManager;
+
+public class JglfwTestStarter extends JFrame {
+	public JglfwTestStarter () throws HeadlessException {
+		super("JGLFW libgdx Tests");
+		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+		setContentPane(new TestList());
+		pack();
+		setSize(getWidth(), 600);
+		setLocationRelativeTo(null);
+		setVisible(true);
+	}
+
+	/** Runs the {@link GdxTest} with the given name.
+	 * @param testName the name of a test class
+	 * @return {@code true} if the test was found and run, {@code false} otherwise */
+	public static JglfwApplication runTest (String testName) {
+		final GdxTest test = GdxTests.newTest(testName);
+		if (test == null) throw new GdxRuntimeException("Test not found: " + testName);
+
+		final JglfwApplicationConfiguration config = new JglfwApplicationConfiguration();
+		config.width = 640;
+		config.height = 480;
+		config.title = testName;
+		config.useGL20 = test.needsGL20();
+		config.forceExit = false;
+		return new JglfwApplication(test, config);
+	}
+
+	class TestList extends JPanel {
+		public TestList () {
+			setLayout(new BorderLayout());
+
+			final JButton button = new JButton("Run Test");
+
+			final JList list = new JList(GdxTests.getNames().toArray());
+			JScrollPane pane = new JScrollPane(list);
+
+			DefaultListSelectionModel m = new DefaultListSelectionModel();
+			m.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+			m.setLeadAnchorNotificationEnabled(false);
+			list.setSelectionModel(m);
+
+			list.addMouseListener(new MouseAdapter() {
+				public void mouseClicked (MouseEvent event) {
+					if (event.getClickCount() == 2) button.doClick();
+				}
+			});
+
+			list.addKeyListener(new KeyAdapter() {
+				public void keyPressed (KeyEvent e) {
+					if (e.getKeyCode() == KeyEvent.VK_ENTER) button.doClick();
+				}
+			});
+
+			final Preferences prefs = new JglfwPreferences(new FileHandle(new JglfwFiles().getExternalStoragePath()
+				+ ".prefs/jglfw-tests"));
+			list.setSelectedValue(prefs.getString("last", null), true);
+
+			button.addActionListener(new ActionListener() {
+				@Override
+				public void actionPerformed (ActionEvent e) {
+					String testName = (String)list.getSelectedValue();
+					prefs.putString("last", testName);
+					prefs.flush();
+					JglfwTestStarter.this.setVisible(false);
+					runTest(testName).addLifecycleListener(new LifecycleListener() {
+						public void resume () {
+						}
+
+						public void pause () {
+						}
+
+						public void dispose () {
+							JglfwTestStarter.this.setVisible(true);
+						}
+					});
+				}
+			});
+
+			add(pane, BorderLayout.CENTER);
+			add(button, BorderLayout.SOUTH);
+		}
+	}
+
+	/** Runs a libgdx test.
+	 * 
+	 * If no arguments are provided on the command line, shows a list of tests to choose from. If an argument is present, the test
+	 * with that name will immediately be run.
+	 * 
+	 * @param argv command line arguments */
+	public static void main (String[] argv) throws Exception {
+		if (argv.length > 0) {
+			runTest(argv[0]);
+			return;
+		}
+		UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
+		new JglfwTestStarter();
+	}
+}
diff --git a/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java b/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java
index 0449a69..c45b4d1 100644
--- a/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java
+++ b/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java
@@ -18,12 +18,19 @@ package com.badlogic.gdx.tests.lwjgl;
 
 import com.badlogic.gdx.backends.lwjgl.LwjglApplication;
 import com.badlogic.gdx.backends.lwjgl.LwjglApplicationConfiguration;
+import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.tests.AnimationTest;
+import com.badlogic.gdx.tests.ETC1Test;
+import com.badlogic.gdx.tests.FullscreenTest;
 import com.badlogic.gdx.tests.InputTest;
+import com.badlogic.gdx.tests.SpriteCacheTest;
 import com.badlogic.gdx.tests.TideMapAssetManagerTest;
 import com.badlogic.gdx.tests.TideMapDirectLoaderTest;
 import com.badlogic.gdx.tests.TiledMapAssetManagerTest;
 import com.badlogic.gdx.tests.TiledMapDirectLoaderTest;
 import com.badlogic.gdx.tests.bench.TiledMapBench;
+import com.badlogic.gdx.tests.g3d.BatchRenderTest;
+import com.badlogic.gdx.tests.g3d.JsonModelLoaderTest;
 import com.badlogic.gdx.tests.superkoalio.SuperKoalio;
 import com.badlogic.gdx.tests.utils.GdxTest;
 import com.badlogic.gdx.utils.SharedLibraryLoader;
@@ -37,7 +44,8 @@ public class LwjglDebugStarter {
 		new SharedLibraryLoader("../../extensions/gdx-controllers/gdx-controllers-desktop/libs/gdx-controllers-desktop-natives.jar").load("gdx-controllers-desktop");
 		new SharedLibraryLoader("../../gdx/libs/gdx-natives.jar").load("gdx");
 
-		GdxTest test = new SuperKoalio();
+		
+		GdxTest test = new BatchRenderTest();
 		LwjglApplicationConfiguration config = new LwjglApplicationConfiguration();
 		config.useGL20 = test.needsGL20();
 		new LwjglApplication(test, config);
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/BulletTestCollection.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/BulletTestCollection.java
index 1bc3d1c..59c1a30 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/BulletTestCollection.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/BulletTestCollection.java
@@ -36,6 +36,7 @@ import com.badlogic.gdx.tests.bullet.CollisionTest;
 import com.badlogic.gdx.tests.bullet.CollisionWorldTest;
 import com.badlogic.gdx.tests.bullet.ConstraintsTest;
 import com.badlogic.gdx.tests.bullet.ConvexHullTest;
+import com.badlogic.gdx.tests.bullet.FrustumCullingTest;
 import com.badlogic.gdx.tests.bullet.InternalTickTest;
 import com.badlogic.gdx.tests.bullet.KinematicTest;
 import com.badlogic.gdx.tests.bullet.MeshShapeTest;
@@ -50,7 +51,7 @@ import com.badlogic.gdx.tests.utils.GdxTest;
 public class BulletTestCollection extends GdxTest implements InputProcessor, GestureListener {
 	protected final BulletTest[] tests = {new ShootTest(), new KinematicTest(), new ConstraintsTest(), 
 		new MeshShapeTest(), new ConvexHullTest(), new RayCastTest(), new RayPickRagdollTest(), new InternalTickTest(), 
-		new CollisionWorldTest(), new CollisionTest(), new SoftBodyTest(), new SoftMeshTest()};
+		new CollisionWorldTest(), new CollisionTest(), new FrustumCullingTest(), new SoftBodyTest(), new SoftMeshTest()};
 	
 	protected int testIndex = 0;
 	
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/CullTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/CullTest.java
index a330b51..b31b9ed 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/CullTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/CullTest.java
@@ -27,8 +27,8 @@ import com.badlogic.gdx.graphics.Mesh;
 import com.badlogic.gdx.graphics.OrthographicCamera;
 import com.badlogic.gdx.graphics.g2d.BitmapFont;
 import com.badlogic.gdx.graphics.g2d.SpriteBatch;
-import com.badlogic.gdx.graphics.g3d.loaders.ModelLoaderRegistry;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.old.loaders.ModelLoaderRegistry;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
 import com.badlogic.gdx.math.Vector3;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/EdgeDetectionTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/EdgeDetectionTest.java
index e22b579..8c0757c 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/EdgeDetectionTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/EdgeDetectionTest.java
@@ -26,8 +26,8 @@ import com.badlogic.gdx.graphics.PerspectiveCamera;
 import com.badlogic.gdx.graphics.Pixmap.Format;
 import com.badlogic.gdx.graphics.g2d.SpriteBatch;
 import com.badlogic.gdx.graphics.g2d.TextureRegion;
-import com.badlogic.gdx.graphics.g3d.loaders.ModelLoaderRegistry;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.old.loaders.ModelLoaderRegistry;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
 import com.badlogic.gdx.graphics.glutils.FrameBuffer;
 import com.badlogic.gdx.graphics.glutils.ShaderProgram;
 import com.badlogic.gdx.math.Matrix4;
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/FilesTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/FilesTest.java
index 59bed7f..1eb87c2 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/FilesTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/FilesTest.java
@@ -403,7 +403,7 @@ public class FilesTest extends GdxTest {
 		if (handle.delete()) fail();
 		if (handle.list().length != 0) fail();
 		if (handle.child("meow").exists()) fail();
-		if (!handle.parent().exists()) fail();
+		if (handle.parent().exists()) fail();
 		try {
 			handle.read().close();
 			fail();
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/FramebufferToTextureTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/FramebufferToTextureTest.java
index dd692ac..81b6c1e 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/FramebufferToTextureTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/FramebufferToTextureTest.java
@@ -25,8 +25,8 @@ import com.badlogic.gdx.graphics.Texture.TextureFilter;
 import com.badlogic.gdx.graphics.g2d.BitmapFont;
 import com.badlogic.gdx.graphics.g2d.SpriteBatch;
 import com.badlogic.gdx.graphics.g2d.TextureRegion;
-import com.badlogic.gdx.graphics.g3d.loaders.ModelLoaderRegistry;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.old.loaders.ModelLoaderRegistry;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
 import com.badlogic.gdx.tests.utils.GdxTest;
 import com.badlogic.gdx.utils.ScreenUtils;
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/FrustumTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/FrustumTest.java
index f7a3011..9330b31 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/FrustumTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/FrustumTest.java
@@ -23,8 +23,8 @@ import com.badlogic.gdx.graphics.OrthographicCamera;
 import com.badlogic.gdx.graphics.PerspectiveCamera;
 import com.badlogic.gdx.graphics.VertexAttribute;
 import com.badlogic.gdx.graphics.VertexAttributes.Usage;
-import com.badlogic.gdx.graphics.g3d.loaders.ModelLoaderRegistry;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.old.loaders.ModelLoaderRegistry;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
 import com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer10;
 import com.badlogic.gdx.graphics.glutils.ShaderProgram;
 import com.badlogic.gdx.math.Frustum;
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/FullscreenTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/FullscreenTest.java
index 5511a48..069451d 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/FullscreenTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/FullscreenTest.java
@@ -29,6 +29,7 @@ public class FullscreenTest extends GdxTest {
 
 	Mesh mesh;
 	Texture texture;
+	boolean fullscreen = false;
 
 	@Override
 	public void create () {
@@ -41,7 +42,6 @@ public class FullscreenTest extends GdxTest {
 		for (DisplayMode mode : modes) {
 			System.out.println(mode);
 		}
-		Gdx.graphics.setDisplayMode(800, 600, true);
 		Gdx.app.log("FullscreenTest", Gdx.graphics.getBufferFormat().toString());
 	}
 
@@ -59,7 +59,14 @@ public class FullscreenTest extends GdxTest {
 		mesh.render(GL10.GL_TRIANGLES);
 
 		if (Gdx.input.justTouched()) {
-			Gdx.graphics.setDisplayMode(480, 320, false);
+			if(fullscreen) {
+				Gdx.graphics.setDisplayMode(480, 320, false);
+				fullscreen = false;
+			} else {
+				DisplayMode desktopDisplayMode = Gdx.graphics.getDesktopDisplayMode();
+				Gdx.graphics.setDisplayMode(desktopDisplayMode.width, desktopDisplayMode.height, true);
+				fullscreen = true;
+			}
 		}
 	}
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/GamepadTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/GamepadTest.java
index f016624..e6434b8 100755
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/GamepadTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/GamepadTest.java
@@ -107,7 +107,7 @@ public class GamepadTest extends GdxTest {
 		});
 	}
 	
-	private void print(String message) {
+	void print(String message) {
 		String[] lines = console.getItems();
 		String[] newLines = new String[lines.length + 1];
 		System.arraycopy(lines, 0, newLines, 0, lines.length);
@@ -118,7 +118,7 @@ public class GamepadTest extends GdxTest {
 		scrollPane.setScrollPercentY(1.0f);
 	}
 	
-	private void clear() {
+	void clear() {
 		console.setItems(new Object[0]);
 	}
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/MaterialTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/MaterialTest.java
index 5cf5834..b10de62 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/MaterialTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/MaterialTest.java
@@ -22,12 +22,12 @@ import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.PerspectiveCamera;
 import com.badlogic.gdx.graphics.Texture;
-import com.badlogic.gdx.graphics.g3d.loaders.ModelLoaderRegistry;
-import com.badlogic.gdx.graphics.g3d.materials.BlendingAttribute;
-import com.badlogic.gdx.graphics.g3d.materials.ColorAttribute;
-import com.badlogic.gdx.graphics.g3d.materials.Material;
-import com.badlogic.gdx.graphics.g3d.materials.TextureAttribute;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.old.loaders.ModelLoaderRegistry;
+import com.badlogic.gdx.graphics.g3d.old.materials.BlendingAttribute;
+import com.badlogic.gdx.graphics.g3d.old.materials.ColorAttribute;
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+import com.badlogic.gdx.graphics.g3d.old.materials.TextureAttribute;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
 public class MaterialTest extends GdxTest {
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/NinePatchTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/NinePatchTest.java
new file mode 100644
index 0000000..85920d0
--- /dev/null
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/NinePatchTest.java
@@ -0,0 +1,211 @@
+package com.badlogic.gdx.tests;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.Color;
+import com.badlogic.gdx.graphics.GL10;
+import com.badlogic.gdx.graphics.OrthographicCamera;
+import com.badlogic.gdx.graphics.Pixmap;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.g2d.NinePatch;
+import com.badlogic.gdx.graphics.g2d.SpriteBatch;
+import com.badlogic.gdx.graphics.g2d.TextureRegion;
+import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
+import com.badlogic.gdx.math.Interpolation;
+import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.scenes.scene2d.Action;
+import com.badlogic.gdx.tests.utils.GdxTest;
+import com.badlogic.gdx.utils.Array;
+
+public class NinePatchTest extends GdxTest {
+	/** A string name for the type of test, and the NinePatch being tested. */
+	private static class TestPatch {
+		public final String name;
+		public final NinePatch ninePatch;
+		
+		TestPatch(String n) {
+			this.name = n;
+			this.ninePatch = NinePatchTest.newNinePatch(); 
+		}
+
+		TestPatch(String n, NinePatch np) {
+			this.name = n;
+			this.ninePatch = np;
+		}
+	}
+	
+	private OrthographicCamera camera;
+	private SpriteBatch b;
+	private Array<TestPatch> ninePatches = new Array<TestPatch>(10);
+
+	private final long start = System.currentTimeMillis();
+	
+	@Override
+	public void create () { 
+		TestPatch tp;
+
+		// Create all the NinePatches to test
+		ninePatches.add(new TestPatch("default"));
+		
+		tp = new TestPatch("20px width");
+		int bWidth = 20;
+		tp.ninePatch.setLeftWidth(bWidth);
+		tp.ninePatch.setRightWidth(bWidth);
+		tp.ninePatch.setTopHeight(bWidth);
+		tp.ninePatch.setBottomHeight(bWidth);
+		ninePatches.add(tp);
+		
+		tp = new TestPatch("fat left");
+		tp.ninePatch.setLeftWidth(3 * tp.ninePatch.getRightWidth());
+		ninePatches.add(tp);
+		
+		tp = new TestPatch("fat top");
+		tp.ninePatch.setTopHeight(3 * tp.ninePatch.getBottomHeight());
+		ninePatches.add(tp);
+		
+		tp = new TestPatch("degenerate", newDegenerateNinePatch());
+		ninePatches.add(tp);
+		
+		tp = new TestPatch("upper-left quad", newULQuadPatch());
+		ninePatches.add(tp);
+		
+		tp = new TestPatch("no middle row", newMidlessPatch());
+		ninePatches.add(tp);
+		
+		b = new SpriteBatch();
+	}
+	
+	// Make a new 'pixmapSize' square texture region with 'patchSize' patches in it.  Each patch is a different color.
+	static TextureRegion newPatchPix(int patchSize, int pixmapSize) {
+		final int pixmapDim = MathUtils.nextPowerOfTwo(pixmapSize);  
+
+		Pixmap p = new Pixmap(pixmapDim, pixmapDim, Pixmap.Format.RGBA8888);
+		p.setColor(1, 1, 1, 0);
+		p.fill();
+						
+		for (int x = 0; x < pixmapSize; x += patchSize) {
+			for (int y = 0; y < pixmapSize; y += patchSize) {
+				p.setColor(x/(float)pixmapSize, y/(float)pixmapSize, 1.0f, 1.0f);
+				p.fillRectangle(x, y, patchSize, patchSize);
+			}
+		}
+		
+		return new TextureRegion(new Texture(p), pixmapSize, pixmapSize); 
+	}
+	
+	// Make a degenerate NinePatch 
+	static NinePatch newDegenerateNinePatch() {
+		final int patchSize = 8; 
+		final int pixmapSize = patchSize * 3;
+		TextureRegion tr = newPatchPix(patchSize, pixmapSize);
+		return new NinePatch(tr);
+	}
+
+	// Make a basic NinePatch with different colors in each of the nine patches
+	static NinePatch newNinePatch() {
+		final int patchSize = 8; 
+		final int pixmapSize = patchSize * 3;
+		TextureRegion tr = newPatchPix(patchSize, pixmapSize);
+		
+		return new NinePatch(tr, patchSize, patchSize, patchSize, patchSize);
+	}
+		
+	// Make a upper-left "quad" patch (only 4 patches defined in the top-left corner of the ninepatch)
+	static NinePatch newULQuadPatch() {
+		final int patchSize = 8; 
+		final int pixmapSize = patchSize * 2;
+		TextureRegion tr = newPatchPix(patchSize, pixmapSize);		
+		
+		return new NinePatch(tr, patchSize, 0, patchSize, 0);
+	}
+
+	// Make a ninepatch with no middle band, just top three and bottom three.
+	static NinePatch newMidlessPatch() {
+		final int patchSize = 8; 
+		final int fullPatchHeight = patchSize * 2;
+		final int fullPatchWidth = patchSize * 3;
+		final int pixmapDim = MathUtils.nextPowerOfTwo(Math.max(fullPatchWidth, fullPatchHeight));  
+		
+		Pixmap testPatch = new Pixmap(pixmapDim, pixmapDim, Pixmap.Format.RGBA8888);
+		testPatch.setColor(1, 1, 1, 0);
+		testPatch.fill();
+						
+		for (int x = 0; x < fullPatchWidth; x += patchSize) {
+			for (int y = 0; y < fullPatchHeight; y += patchSize) {
+				testPatch.setColor(x/(float)fullPatchWidth, y/(float)fullPatchHeight, 1.0f, 1.0f);
+				testPatch.fillRectangle(x, y, patchSize, patchSize);
+			}
+		}
+		
+		return new NinePatch(new TextureRegion(new Texture(testPatch), fullPatchWidth, fullPatchHeight), 
+			patchSize, patchSize, patchSize, patchSize);
+	}
+
+	private float timePassed = 0;
+	private final Color filterColor = new Color();
+	private final Color oldColor = new Color();
+	
+	@Override
+	public void render () {
+		final int screenWidth = Gdx.graphics.getWidth();
+		final int screenHeight = Gdx.graphics.getHeight();
+		
+		Gdx.gl.glClearColor(0, 0, 0, 0);
+		Gdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
+		
+		timePassed += Gdx.graphics.getDeltaTime();
+		
+		b.begin();
+		final int sz = ninePatches.size;
+		final int XGAP = 10;
+		final int pheight = (int)((screenHeight * 0.5f) / ((sz+1) / 2));
+		int x = XGAP;
+		int y = 10;
+		
+		// Test that batch color is applied to NinePatch
+		if (timePassed < 2) {
+			b.setColor(1, 1, 1, Interpolation.sine.apply(timePassed / 2f));
+		}
+		
+		// Test that the various nine patches render
+		for (int i = 0; i < sz; i += 2) {
+			int pwidth = (int)(0.44f * screenWidth); 
+
+			final NinePatch np1 = ninePatches.get(i).ninePatch;	
+			np1.draw(b, x, y, pwidth, pheight);			
+			
+			if (i+1 < sz) {
+				final NinePatch np2 = ninePatches.get(i+1).ninePatch;
+				final int x2 = x + pwidth + XGAP;
+				final int pwidth2 = screenWidth - XGAP - x2;
+				
+				np2.draw(b, x2 , y, pwidth2, pheight);
+			}
+			
+			y += pheight + 2; 
+		}
+		
+		// Dim a np by setting its color.  Also test sending same np to batch twice
+		NinePatch np = ninePatches.get(0).ninePatch;
+		oldColor.set(np.getColor());
+		filterColor.set(0.3f, 0.3f, 0.3f, 1.0f);
+		np.setColor(filterColor);
+		np.draw(b, x, y, 100, 30);
+		np.setColor(oldColor);
+		
+		b.end();
+	}
+	
+	@Override
+	public void resize (int width, int height) {
+		float ratio = ((float)Gdx.graphics.getWidth() / (float)Gdx.graphics.getHeight());
+		int h = 10;
+		int w = (int)(h * ratio);
+		camera = new OrthographicCamera(w, h);
+	}
+	
+	@Override
+	public boolean needsGL20 () {
+		return false;
+	}
+
+}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/ObjTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/ObjTest.java
index 70694c1..ec953f6 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/ObjTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/ObjTest.java
@@ -22,8 +22,8 @@ import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.PerspectiveCamera;
 import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.graphics.Texture.TextureFilter;
-import com.badlogic.gdx.graphics.g3d.loaders.ModelLoaderRegistry;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.old.loaders.ModelLoaderRegistry;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
 import com.badlogic.gdx.math.collision.BoundingBox;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/PickingTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/PickingTest.java
index ac81844..b9c24d9 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/PickingTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/PickingTest.java
@@ -25,8 +25,8 @@ import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.PerspectiveCamera;
 import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.graphics.g2d.SpriteBatch;
-import com.badlogic.gdx.graphics.g3d.loaders.ModelLoaderRegistry;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.old.loaders.ModelLoaderRegistry;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
 import com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer10;
 import com.badlogic.gdx.math.Intersector;
 import com.badlogic.gdx.math.Vector3;
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/ProjectTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/ProjectTest.java
index 0c33ef4..e762d5b 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/ProjectTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/ProjectTest.java
@@ -27,8 +27,8 @@ import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.graphics.g2d.BitmapFont;
 import com.badlogic.gdx.graphics.g2d.SpriteBatch;
 import com.badlogic.gdx.graphics.g2d.TextureRegion;
-import com.badlogic.gdx.graphics.g3d.loaders.ModelLoaderRegistry;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.old.loaders.ModelLoaderRegistry;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
 import com.badlogic.gdx.math.Vector3;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/ProjectiveTextureTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/ProjectiveTextureTest.java
index 9774d5c..df0575b 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/ProjectiveTextureTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/ProjectiveTextureTest.java
@@ -27,8 +27,8 @@ import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.graphics.Texture.TextureFilter;
 import com.badlogic.gdx.graphics.VertexAttribute;
 import com.badlogic.gdx.graphics.VertexAttributes.Usage;
-import com.badlogic.gdx.graphics.g3d.loaders.ModelLoaderRegistry;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.old.loaders.ModelLoaderRegistry;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
 import com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20;
 import com.badlogic.gdx.graphics.glutils.ShaderProgram;
 import com.badlogic.gdx.math.Matrix4;
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/ShadowMappingTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/ShadowMappingTest.java
index a91493d..5bd9061 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/ShadowMappingTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/ShadowMappingTest.java
@@ -24,8 +24,8 @@ import com.badlogic.gdx.graphics.PerspectiveCamera;
 import com.badlogic.gdx.graphics.Pixmap.Format;
 import com.badlogic.gdx.graphics.VertexAttribute;
 import com.badlogic.gdx.graphics.VertexAttributes.Usage;
-import com.badlogic.gdx.graphics.g3d.loaders.ModelLoaderRegistry;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.old.loaders.ModelLoaderRegistry;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
 import com.badlogic.gdx.graphics.glutils.FrameBuffer;
 import com.badlogic.gdx.graphics.glutils.ShaderProgram;
 import com.badlogic.gdx.scenes.scene2d.Actor;
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/SpriteCacheTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/SpriteCacheTest.java
index 14e6f64..23df674 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/SpriteCacheTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/SpriteCacheTest.java
@@ -82,9 +82,8 @@ public class SpriteCacheTest extends GdxTest implements InputProcessor {
 	}
 
 	private void renderSprites () {
-		GL10 gl = Gdx.graphics.getGL10();
-		gl.glClearColor(0.7f, 0.7f, 0.7f, 1);
-		gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
+		Gdx.gl.glClearColor(0.7f, 0.7f, 0.7f, 1);
+		Gdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
 
 		float begin = 0;
 		float end = 0;
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/UITest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/UITest.java
index 9fcd3f4..e3e5ef0 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/UITest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/UITest.java
@@ -163,7 +163,6 @@ public class UITest extends GdxTest {
 					.key(Keys.ESCAPE, false).show(stage);
 			}
 		});
-
 	}
 
 	@Override
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bench/TiledMapBench.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bench/TiledMapBench.java
index a14b387..1462cc1 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bench/TiledMapBench.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bench/TiledMapBench.java
@@ -64,7 +64,7 @@ public class TiledMapBench extends GdxTest {
 						layer.setCell(x, y, cell);
 					}
 				}
-				layers.addLayer(layer);
+				layers.add(layer);
 			}
 		}
 		
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseBulletTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseBulletTest.java
index cf6e25a..4ccfbda 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseBulletTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseBulletTest.java
@@ -24,9 +24,9 @@ import com.badlogic.gdx.graphics.Mesh;
 import com.badlogic.gdx.graphics.PerspectiveCamera;
 import com.badlogic.gdx.graphics.VertexAttribute;
 import com.badlogic.gdx.graphics.VertexAttributes.Usage;
-import com.badlogic.gdx.graphics.g3d.materials.Material;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
-import com.badlogic.gdx.graphics.g3d.model.still.StillSubMesh;
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillSubMesh;
 import com.badlogic.gdx.math.collision.Ray;
 import com.badlogic.gdx.physics.bullet.Bullet;
 import com.badlogic.gdx.physics.bullet.btIDebugDraw;
@@ -122,24 +122,34 @@ public class BaseBulletTest extends BulletTest {
 		if (update)
 			update();
 		
+		beginRender(true);
+
+		renderWorld();
+		
+		performance.setLength(0);
+		performance.append("FPS: ").append(fpsCounter.value).append(", Bullet: ")
+			.append((int)(performanceCounter.load.value*100f)).append("%");
+	}
+	
+	protected void beginRender(boolean lighting) {
 		GL10 gl = Gdx.gl10;
 		gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
 		gl.glEnable(GL10.GL_DEPTH_TEST);
 		gl.glDepthFunc(GL10.GL_LEQUAL);
 		gl.glEnable(GL10.GL_COLOR_MATERIAL);
-		gl.glEnable(GL10.GL_LIGHTING);
-		gl.glEnable(GL10.GL_LIGHT0);
-		gl.glLightfv(GL10.GL_LIGHT0, GL10.GL_AMBIENT, lightAmbient, 0);
-		gl.glLightfv(GL10.GL_LIGHT0, GL10.GL_POSITION, lightPosition, 0);
-		gl.glLightfv(GL10.GL_LIGHT0, GL10.GL_DIFFUSE, lightDiffuse, 0);
-
+		if (lighting) {
+			gl.glEnable(GL10.GL_LIGHTING);
+			gl.glEnable(GL10.GL_LIGHT0);
+			gl.glLightfv(GL10.GL_LIGHT0, GL10.GL_AMBIENT, lightAmbient, 0);
+			gl.glLightfv(GL10.GL_LIGHT0, GL10.GL_POSITION, lightPosition, 0);
+			gl.glLightfv(GL10.GL_LIGHT0, GL10.GL_DIFFUSE, lightDiffuse, 0);
+		} else
+			gl.glDisable(GL10.GL_LIGHTING);
 		camera.apply(Gdx.gl10);
-		
+	}
+	
+	protected void renderWorld() {
 		world.render();
-		
-		performance.setLength(0);
-		performance.append("FPS: ").append(fpsCounter.value).append(", Bullet: ")
-			.append((int)(performanceCounter.load.value*100f)).append("%");
 	}
 	
 	public void update() {
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseEntity.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseEntity.java
index 8954959..4ae4499 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseEntity.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseEntity.java
@@ -17,7 +17,7 @@ package com.badlogic.gdx.tests.bullet;
 
 import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.Mesh;
-import com.badlogic.gdx.graphics.g3d.model.Model;
+import com.badlogic.gdx.graphics.g3d.old.model.Model;
 import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.utils.Disposable;
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseWorld.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseWorld.java
index 992ebce..c611591 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseWorld.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BaseWorld.java
@@ -19,7 +19,7 @@ import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.Mesh;
-import com.badlogic.gdx.graphics.g3d.model.Model;
+import com.badlogic.gdx.graphics.g3d.old.model.Model;
 import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.Disposable;
@@ -66,16 +66,21 @@ public class BaseWorld<T extends BaseEntity> implements Disposable {
 	}
 	
 	public void render() {
-		GL10 gl = Gdx.gl10;
-
-		for (int i = 0; i < entities.size; i++) {
-			final T entity = entities.get(i);
-			gl.glPushMatrix();
-			gl.glMultMatrixf(entity.transform.val, 0);
-			gl.glColor4f(entity.color.r, entity.color.g, entity.color.b, entity.color.a);
-			entity.model.render();
-			gl.glPopMatrix();
-		}		
+		render(entities);
+	}
+	
+	public void render(final Iterable<T> entities) {
+		for (final T e : entities)
+			render(e);
+	}
+	
+	public void render(final T entity) {
+		final GL10 gl = Gdx.gl10;
+		gl.glPushMatrix();
+		gl.glMultMatrixf(entity.transform.val, 0);
+		gl.glColor4f(entity.color.r, entity.color.g, entity.color.b, entity.color.a);
+		entity.model.render();
+		gl.glPopMatrix();
 	}
 	
 	public void update() {	}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletConstructor.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletConstructor.java
index 307d518..d81651e 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletConstructor.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletConstructor.java
@@ -16,7 +16,7 @@
 package com.badlogic.gdx.tests.bullet;
 
 import com.badlogic.gdx.graphics.Mesh;
-import com.badlogic.gdx.graphics.g3d.model.Model;
+import com.badlogic.gdx.graphics.g3d.old.model.Model;
 import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.math.Vector3;
 import com.badlogic.gdx.math.collision.BoundingBox;
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletEntity.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletEntity.java
index 4919743..36157ba 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletEntity.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletEntity.java
@@ -16,7 +16,7 @@
 package com.badlogic.gdx.tests.bullet;
 
 import com.badlogic.gdx.graphics.Mesh;
-import com.badlogic.gdx.graphics.g3d.model.Model;
+import com.badlogic.gdx.graphics.g3d.old.model.Model;
 import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.physics.bullet.btCollisionObject;
 import com.badlogic.gdx.physics.bullet.btCollisionShape;
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletWorld.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletWorld.java
index 800c26c..014dd20 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletWorld.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletWorld.java
@@ -39,8 +39,7 @@ import com.badlogic.gdx.utils.PerformanceCounter;
  * Bullet physics world that holds all bullet entities and constructors.  
  */
 public class BulletWorld extends BaseWorld<BulletEntity> {
-	// For debugging purposes:
-	private DebugDrawer debugDrawer = null;
+	public DebugDrawer debugDrawer = null;
 	public boolean renderMeshes = true;
 	
 	public final btCollisionConfiguration collisionConfiguration;
@@ -93,6 +92,8 @@ public class BulletWorld extends BaseWorld<BulletEntity> {
 				((btDiscreteDynamicsWorld)collisionWorld).addRigidBody((btRigidBody)entity.body);
 			else
 				collisionWorld.addCollisionObject(entity.body);
+			// Store the index of the entity in the collision object.  
+			entity.body.setUserValue(entities.size-1);
 		}
 	}
 	
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/CollisionWorldTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/CollisionWorldTest.java
index 9611f94..9ebdc7f 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/CollisionWorldTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/CollisionWorldTest.java
@@ -18,7 +18,7 @@ package com.badlogic.gdx.tests.bullet;
 
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.Color;
-import com.badlogic.gdx.graphics.g3d.model.Model;
+import com.badlogic.gdx.graphics.g3d.old.model.Model;
 import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.math.Vector3;
 import com.badlogic.gdx.physics.bullet.ContactResultCallback;
@@ -66,6 +66,8 @@ public class CollisionWorldTest extends BaseBulletTest {
 	public void create () {
 		super.create();
 		
+		instructions = "Long press to toggle debug mode\nSwipe for next test";
+		
 		contactCB = new TestContactResultCallback();
 		
 		Model groundModel = world.getConstructor("ground").model;
@@ -96,18 +98,37 @@ public class CollisionWorldTest extends BaseBulletTest {
 		movingBox.transform.rotate(Vector3.Y, Gdx.graphics.getDeltaTime() * 45f);
 		movingBox.transform.translate(-5f, 1f, 0f);
 		movingBox.body.setWorldTransform(movingBox.transform);
+		
+		super.render();
+	}
+	
+	@Override
+	public void update () {
+		super.update();
+		// Not using dynamics, so update the collision world manually
+		if (world.performanceCounter != null)
+			world.performanceCounter.start();
 		world.collisionWorld.performDiscreteCollisionDetection();
+		if (world.performanceCounter != null)
+			world.performanceCounter.stop();
+	}
+	
+	@Override
+	protected void renderWorld () {
 		hit = false;
 		other = null;
 		world.collisionWorld.contactTest(movingBox.body, contactCB);
 		movingBox.color.set(hit ? Color.RED : normalColor);
+		
 		BulletEntity e = null;
 		if (other != null && other.userData != null && other.userData instanceof BulletEntity) { 
 			e = (BulletEntity)(other.userData);
 			tmpColor.set(e.color);
 			e.color.set(Color.RED);
 		}
-		super.render();
+		
+		super.renderWorld();
+
 		if (e != null)
 			e.color.set(tmpColor);
 	}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConstraintsTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConstraintsTest.java
index 9445175..66992c0 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConstraintsTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConstraintsTest.java
@@ -21,9 +21,9 @@ import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.Mesh;
 import com.badlogic.gdx.graphics.VertexAttribute;
 import com.badlogic.gdx.graphics.VertexAttributes.Usage;
-import com.badlogic.gdx.graphics.g3d.materials.Material;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
-import com.badlogic.gdx.graphics.g3d.model.still.StillSubMesh;
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillSubMesh;
 import com.badlogic.gdx.math.Vector3;
 import com.badlogic.gdx.physics.bullet.btDiscreteDynamicsWorld;
 import com.badlogic.gdx.physics.bullet.btDynamicsWorld;
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConvexHullTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConvexHullTest.java
index dc3ddd5..35526fd 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConvexHullTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/ConvexHullTest.java
@@ -19,10 +19,10 @@ package com.badlogic.gdx.tests.bullet;
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.Mesh;
-import com.badlogic.gdx.graphics.g3d.loaders.ModelLoaderRegistry;
-import com.badlogic.gdx.graphics.g3d.loaders.wavefront.ObjLoader;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
-import com.badlogic.gdx.graphics.g3d.model.still.StillSubMesh;
+import com.badlogic.gdx.graphics.g3d.old.loaders.ModelLoaderRegistry;
+import com.badlogic.gdx.graphics.g3d.old.loaders.wavefront.ObjLoader;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillSubMesh;
 import com.badlogic.gdx.physics.bullet.btConvexHullShape;
 import com.badlogic.gdx.physics.bullet.btShapeHull;
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/FrustumCullingTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/FrustumCullingTest.java
new file mode 100644
index 0000000..a63d05a
--- /dev/null
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/FrustumCullingTest.java
@@ -0,0 +1,289 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package com.badlogic.gdx.tests.bullet;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.Color;
+import com.badlogic.gdx.graphics.GL10;
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.PerspectiveCamera;
+import com.badlogic.gdx.graphics.VertexAttribute;
+import com.badlogic.gdx.graphics.VertexAttributes.Usage;
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+import com.badlogic.gdx.graphics.g3d.old.model.Model;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillSubMesh;
+import com.badlogic.gdx.math.Matrix4;
+import com.badlogic.gdx.math.Quaternion;
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.physics.bullet.btBroadphasePair;
+import com.badlogic.gdx.physics.bullet.btBroadphasePairArray;
+import com.badlogic.gdx.physics.bullet.btCollisionAlgorithm;
+import com.badlogic.gdx.physics.bullet.btCollisionDispatcher;
+import com.badlogic.gdx.physics.bullet.btCollisionObject;
+import com.badlogic.gdx.physics.bullet.btCollisionShape;
+import com.badlogic.gdx.physics.bullet.btCollisionWorld;
+import com.badlogic.gdx.physics.bullet.btCompoundShape;
+import com.badlogic.gdx.physics.bullet.btConvexHullShape;
+import com.badlogic.gdx.physics.bullet.btDbvtBroadphase;
+import com.badlogic.gdx.physics.bullet.btDefaultCollisionConfiguration;
+import com.badlogic.gdx.physics.bullet.btGhostPairCallback;
+import com.badlogic.gdx.physics.bullet.btManifoldArray;
+import com.badlogic.gdx.physics.bullet.btPairCachingGhostObject;
+import com.badlogic.gdx.physics.bullet.btPersistentManifold;
+import com.badlogic.gdx.physics.bullet.gdxBulletJNI;
+import com.badlogic.gdx.utils.Array;
+
+/** @author Xoppa */
+public class FrustumCullingTest extends BaseBulletTest {
+	/** Only show entities inside the frustum */
+	final static int CULL_FRUSTUM = 1;
+	/** Transform the render cam with the frustum */
+	final static int FRUSTUM_CAM = 2;
+	
+	final static boolean USE_BULLET_FRUSTUM_CULLING = true;
+	
+	int state = 0; // 0 = No culling, look from above
+	
+	final static int BOXCOUNT = 200;
+	
+	final static float BOX_X_MIN = -25;
+	final static float BOX_Y_MIN = -25;
+	final static float BOX_Z_MIN = -25;
+	
+	final static float BOX_X_MAX = 25;
+	final static float BOX_Y_MAX = 25;
+	final static float BOX_Z_MAX = 25;
+	
+	final static float SPEED_X = 360f/7f;
+	final static float SPEED_Y = 360f/19f;
+	final static float SPEED_Z = 360f/13f;
+	
+	final static Vector3 tmpV = new Vector3();
+	final static Matrix4 tmpM = new Matrix4();
+	
+	final static int ptrs[] = new int[512];
+	final static Array<btCollisionObject> visibleObjects = new Array<btCollisionObject>(); 
+	
+	public static btPairCachingGhostObject createFrustumObject(final Vector3... points) {
+		final btPairCachingGhostObject result = new TestPairCachingGhostObject();
+		final boolean USE_COMPOUND = true;
+		// Using a compound shape is not necessary, but it's good practice to create shapes around the center.
+		if (USE_COMPOUND) {
+			final Vector3 centerNear = new Vector3(points[2]).sub(points[0]).scl(0.5f).add(points[0]);
+			final Vector3 centerFar = new Vector3(points[6]).sub(points[4]).scl(0.5f).add(points[4]);
+			final Vector3 center = new Vector3(centerFar).sub(centerNear).scl(0.5f).add(centerNear);
+			final btConvexHullShape hullShape = new btConvexHullShape();
+			for (int i = 0; i < points.length; i++)
+				hullShape.addPoint(tmpV.set(points[i]).sub(center));
+			final btCompoundShape shape = new btCompoundShape();
+			shape.addChildShape(tmpM.setToTranslation(center), hullShape, true);
+			result.setCollisionShape(shape);
+		} else {
+			final btConvexHullShape shape = new btConvexHullShape();
+			for (int i = 0; i < points.length; i++)
+				shape.addPoint(points[i]);
+			result.setCollisionShape(shape);
+		}
+		result.setCollisionFlags(btCollisionObject.CollisionFlags.CF_NO_CONTACT_RESPONSE);
+		return result;
+	}
+	
+	public static Array<BulletEntity> getEntitiesCollidingWithObject(final BulletWorld world, final btPairCachingGhostObject object, final Array<BulletEntity> out, final btManifoldArray tmpArr) {
+		// Fetch the array of contacts
+		btBroadphasePairArray arr = world.broadphase.getOverlappingPairCache().getOverlappingPairArray();
+		// Get the user values (which are indices in the entities array) of all objects colliding with the object
+		final int n = arr.getCollisionObjectsValue(ptrs, object);
+		// Fill the array of entities
+		out.clear();
+		for (int i = 0; i < n; i++)
+			out.add(world.entities.get(ptrs[i]));
+		return out;
+	}
+	
+	public static Model createFrustumModel(final Vector3... p) {
+		final Mesh mesh = new Mesh(true, 8, 32, new VertexAttribute(Usage.Position, 3, "a_position"));
+		mesh.setVertices(new float[] {
+			p[0].x, p[0].y, p[0].z, p[1].x, p[1].y, p[1].z, p[2].x, p[2].y, p[2].z, p[3].x, p[3].y, p[3].z, // near
+			p[4].x, p[4].y, p[4].z, p[5].x, p[5].y, p[5].z, p[6].x, p[6].y, p[6].z, p[7].x, p[7].y, p[7].z});// far
+		mesh.setIndices(new short[] {0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7});
+		return new StillModel(new StillSubMesh("frustum", mesh, GL10.GL_LINES, new Material()));
+	}
+	
+	private float angleX, angleY, angleZ;
+	private btPairCachingGhostObject frustumObject;
+	private BulletEntity frustumEntity;
+	private final Array<BulletEntity> visibleEntities = new Array<BulletEntity>();
+	private btManifoldArray tempManifoldArr;
+	private PerspectiveCamera frustumCam;
+	private PerspectiveCamera overviewCam;
+
+	@Override
+	public void create () {
+		super.create();
+		
+		instructions = "Tap to toggle view\nLong press to toggle debug mode\nSwipe for next test";
+		
+		tempManifoldArr = new btManifoldArray();
+
+		world.addConstructor("collisionBox", new BulletConstructor(world.getConstructor("box").model));
+		
+		// Create the entities
+		final float dX = BOX_X_MAX - BOX_X_MIN;
+		final float dY = BOX_Y_MAX - BOX_Y_MIN;
+		final float dZ = BOX_Z_MAX - BOX_Z_MIN;
+		for (int i = 0; i < BOXCOUNT; i++)
+			world.add("collisionBox", 
+					BOX_X_MIN + dX * (float)Math.random(), 
+					BOX_Y_MIN + dY * (float)Math.random(), 
+					BOX_Z_MIN + dZ * (float)Math.random()
+				).color.set(Color.GRAY);
+		
+		frustumCam = new PerspectiveCamera(camera.fieldOfView, camera.viewportWidth, camera.viewportHeight);
+		overviewCam = camera;
+		overviewCam.position.set(BOX_X_MAX, BOX_Y_MAX, BOX_Z_MAX);
+		overviewCam.lookAt(Vector3.Zero);
+		overviewCam.update();
+		
+		final Model frustumModel = createFrustumModel(frustumCam.frustum.planePoints);
+		frustumObject = createFrustumObject(frustumCam.frustum.planePoints);
+		world.add(frustumEntity = new BulletEntity(frustumModel, frustumObject, 0, 0, 0));
+		frustumEntity.color.set(Color.BLUE);
+		
+		world.renderMeshes = false;
+	}
+	
+	@Override
+	public BulletWorld createWorld () {
+		// No need to use dynamics for this test
+		btDbvtBroadphase broadphase = new btDbvtBroadphase();
+		btDefaultCollisionConfiguration collisionConfig = new btDefaultCollisionConfiguration();
+		btCollisionDispatcher dispatcher = new btCollisionDispatcher(collisionConfig);
+		btCollisionWorld collisionWorld = new btCollisionWorld(dispatcher, broadphase, collisionConfig);
+		return new BulletWorld(collisionConfig, dispatcher, broadphase, null, collisionWorld);
+	}
+
+	@Override
+	public void update () {
+		super.update();
+		// Not using dynamics, so update the collision world manually
+		if (USE_BULLET_FRUSTUM_CULLING) {
+			if (world.performanceCounter != null)
+				world.performanceCounter.start();
+			world.collisionWorld.performDiscreteCollisionDetection();
+			if (world.performanceCounter != null)
+				world.performanceCounter.stop();
+		}
+	}
+	
+	@Override
+	public void render () {
+		final float dt = Gdx.graphics.getDeltaTime();
+		frustumEntity.transform.idt();
+		frustumEntity.transform.rotate(Vector3.X, angleX = (angleX + dt * SPEED_X) % 360);
+		frustumEntity.transform.rotate(Vector3.Y, angleY = (angleY + dt * SPEED_Y) % 360);
+		frustumEntity.transform.rotate(Vector3.Z, angleZ = (angleZ + dt * SPEED_Z) % 360);
+
+		// Transform the ghost object
+		frustumEntity.body.setWorldTransform(frustumEntity.transform);
+		// Transform the frustum cam
+		frustumCam.direction.set(0, 0, -1);
+		frustumCam.up.set(0, 1, 0);
+		frustumCam.position.set(0,0,0);
+		frustumCam.rotate(frustumEntity.transform);
+		frustumCam.update();
+
+		super.render();
+		
+		performance.append(" visible: ").append(visibleEntities.size);
+	}
+	
+	@Override
+	protected void renderWorld () {
+		if (world.performanceCounter != null)
+			world.performanceCounter.start();
+		if (USE_BULLET_FRUSTUM_CULLING)
+			getEntitiesCollidingWithObject(world, frustumObject, visibleEntities, tempManifoldArr);
+		else {
+			visibleEntities.clear();
+			for (int i = 0; i < world.entities.size; i++) {
+				final BulletEntity e = world.entities.get(i);
+				if (e == frustumEntity)
+					continue;
+				e.transform.getTranslation(tmpV);
+				if (frustumCam.frustum.sphereInFrustum(tmpV, 1))
+					visibleEntities.add(e);
+			}
+		}
+		if (world.performanceCounter != null)
+			world.performanceCounter.stop();
+		
+		for (int i = 0; i < visibleEntities.size; i++)
+			visibleEntities.get(i).color.set(Color.RED);
+		
+		if ((state & CULL_FRUSTUM) == CULL_FRUSTUM) {
+			world.render(visibleEntities);
+			world.render(frustumEntity);
+		} else
+			world.render(world.entities);
+		
+		for (int i = 0; i < visibleEntities.size; i++)
+			visibleEntities.get(i).color.set(Color.GRAY);
+	}
+	
+	@Override
+	protected void beginRender (boolean lighting) {
+		super.beginRender(false);
+	}
+	
+	@Override
+	public void dispose () {
+		frustumObject = null;
+		
+		super.dispose();
+		
+		if (tempManifoldArr != null)
+			tempManifoldArr.delete();
+		tempManifoldArr = null;
+	}
+	
+	@Override
+	public boolean tap (float x, float y, int count, int button) {
+		state = (state + 1) % 3;
+		if ((state & FRUSTUM_CAM) == FRUSTUM_CAM)
+			camera = frustumCam;
+		else
+			camera = overviewCam;
+		return true;
+	}
+	
+	// Simple helper class to keep a reference to the collision shape
+	public static class TestPairCachingGhostObject extends btPairCachingGhostObject {
+		public btCollisionShape shape; 
+		@Override
+		public void setCollisionShape (btCollisionShape collisionShape) {
+			shape = collisionShape;
+			super.setCollisionShape(collisionShape);
+		}
+		@Override
+		public void dispose () {
+			super.dispose();
+			if (shape != null)
+				shape.delete();
+			shape = null;
+		}
+	}
+}
\ No newline at end of file
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/MeshShapeTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/MeshShapeTest.java
index a76f29d..2bffad8 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/MeshShapeTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/MeshShapeTest.java
@@ -17,8 +17,8 @@
 package com.badlogic.gdx.tests.bullet;
 
 import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.graphics.g3d.loaders.ModelLoaderRegistry;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.old.loaders.ModelLoaderRegistry;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
 import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.math.Vector3;
 import com.badlogic.gdx.math.collision.BoundingBox;
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/RayPickRagdollTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/RayPickRagdollTest.java
index a7fe760..399e93e 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/RayPickRagdollTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/RayPickRagdollTest.java
@@ -20,10 +20,10 @@ import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.Mesh;
 import com.badlogic.gdx.graphics.VertexAttribute;
 import com.badlogic.gdx.graphics.VertexAttributes.Usage;
-import com.badlogic.gdx.graphics.g3d.materials.Material;
-import com.badlogic.gdx.graphics.g3d.model.Model;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
-import com.badlogic.gdx.graphics.g3d.model.still.StillSubMesh;
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+import com.badlogic.gdx.graphics.g3d.old.model.Model;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillSubMesh;
 import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.math.Vector3;
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/SoftMeshTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/SoftMeshTest.java
index 1ff8203..ad15f4b 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/SoftMeshTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/SoftMeshTest.java
@@ -21,9 +21,9 @@ import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.Mesh;
 import com.badlogic.gdx.graphics.VertexAttributes.Usage;
-import com.badlogic.gdx.graphics.g3d.loaders.ModelLoaderRegistry;
-import com.badlogic.gdx.graphics.g3d.loaders.wavefront.ObjLoader;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.old.loaders.ModelLoaderRegistry;
+import com.badlogic.gdx.graphics.g3d.old.loaders.wavefront.ObjLoader;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
 import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.math.Vector3;
 import com.badlogic.gdx.physics.bullet.Material;
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/BatchRenderTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/BatchRenderTest.java
index 8955425..54ff842 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/BatchRenderTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/BatchRenderTest.java
@@ -8,26 +8,26 @@ import com.badlogic.gdx.graphics.OrthographicCamera;
 import com.badlogic.gdx.graphics.PerspectiveCamera;
 import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.graphics.Pixmap.Format;
-import com.badlogic.gdx.graphics.g3d.loaders.ModelLoaderRegistry;
-import com.badlogic.gdx.graphics.g3d.loaders.json.JsonModelLoader;
-import com.badlogic.gdx.graphics.g3d.materials.Material;
-import com.badlogic.gdx.graphics.g3d.materials.TextureAttribute;
-import com.badlogic.gdx.graphics.g3d.model.Model;
-import com.badlogic.gdx.graphics.g3d.model.SubMesh;
-import com.badlogic.gdx.graphics.g3d.model.still.StillModel;
-import com.badlogic.gdx.graphics.g3d.model.still.StillSubMesh;
-import com.badlogic.gdx.graphics.g3d.xoppa.RenderBatch;
-import com.badlogic.gdx.graphics.g3d.xoppa.RenderContext;
-import com.badlogic.gdx.graphics.g3d.xoppa.RenderInstance;
-import com.badlogic.gdx.graphics.g3d.xoppa.materials.ColorAttribute;
-import com.badlogic.gdx.graphics.g3d.xoppa.materials.NewMaterial;
-import com.badlogic.gdx.graphics.g3d.xoppa.test.Light;
-import com.badlogic.gdx.graphics.g3d.xoppa.test.NewModel;
-import com.badlogic.gdx.graphics.g3d.xoppa.test.OldBatchRendererGLES11;
-import com.badlogic.gdx.graphics.g3d.xoppa.test.OldBatchRendererGLES20;
-import com.badlogic.gdx.graphics.g3d.xoppa.test.InterimModel;
-import com.badlogic.gdx.graphics.g3d.xoppa.test.TestShader;
-import com.badlogic.gdx.graphics.g3d.xoppa.utils.ExclusiveTextures;
+import com.badlogic.gdx.graphics.g3d.RenderBatch;
+import com.badlogic.gdx.graphics.g3d.RenderContext;
+import com.badlogic.gdx.graphics.g3d.RenderInstance;
+import com.badlogic.gdx.graphics.g3d.loader.JsonModelLoader;
+import com.badlogic.gdx.graphics.g3d.materials.ColorAttribute;
+import com.badlogic.gdx.graphics.g3d.materials.NewMaterial;
+import com.badlogic.gdx.graphics.g3d.old.loaders.ModelLoaderRegistry;
+import com.badlogic.gdx.graphics.g3d.old.materials.Material;
+import com.badlogic.gdx.graphics.g3d.old.materials.TextureAttribute;
+import com.badlogic.gdx.graphics.g3d.old.model.Model;
+import com.badlogic.gdx.graphics.g3d.old.model.SubMesh;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillModel;
+import com.badlogic.gdx.graphics.g3d.old.model.still.StillSubMesh;
+import com.badlogic.gdx.graphics.g3d.test.InterimModel;
+import com.badlogic.gdx.graphics.g3d.test.Light;
+import com.badlogic.gdx.graphics.g3d.test.NewModel;
+import com.badlogic.gdx.graphics.g3d.test.OldBatchRendererGLES11;
+import com.badlogic.gdx.graphics.g3d.test.OldBatchRendererGLES20;
+import com.badlogic.gdx.graphics.g3d.test.TestShader;
+import com.badlogic.gdx.graphics.g3d.utils.ExclusiveTextures;
 import com.badlogic.gdx.graphics.glutils.FrameBuffer;
 import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.math.Vector3;
@@ -91,7 +91,7 @@ public class BatchRenderTest extends GdxTest {
 		for (int i = 0; i < textures.size; i++)
 			cubes.add(new InterimModel(new StillModel(new StillSubMesh(mesh.name, mesh.mesh, mesh.primitiveType, new Material("mat", new TextureAttribute(textures.get(i), 0, TextureAttribute.diffuseTexture))))));
 		
-		createScene1();
+		createScene2();
 		
 		cam = new PerspectiveCamera(67, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
 		cam.near = 1f;
@@ -121,7 +121,7 @@ public class BatchRenderTest extends GdxTest {
 		instances.add(new ModelInstance(testModel, (new Matrix4()).setToTranslation(0, 5, 4)));
 		instances.add(new ModelInstance(carModel, (new Matrix4()).setToTranslation(6, 0, -4)));
 		
-		for (int i = 0; i < 10; i++)
+		for (int i = 0; i < 1000; i++)
 			instances.add(new ModelInstance(sphereModel, (new Matrix4()).setToTranslation(MIN_X + (float)Math.random() * SIZE_X, MIN_Y + (float)Math.random() * SIZE_Y, MIN_Z + (float)Math.random() * SIZE_Z).scl(0.25f + (float)Math.random())));		
 	}
 	
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/JsonModelLoaderTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/JsonModelLoaderTest.java
index 7d64aa4..fc1393e 100755
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/JsonModelLoaderTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/JsonModelLoaderTest.java
@@ -3,8 +3,8 @@ package com.badlogic.gdx.tests.g3d;
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.GL10;
 import com.badlogic.gdx.graphics.PerspectiveCamera;
-import com.badlogic.gdx.graphics.g3d.loaders.json.JsonModelLoader;
-import com.badlogic.gdx.graphics.g3d.model.Model;
+import com.badlogic.gdx.graphics.g3d.loader.JsonModelLoader;
+import com.badlogic.gdx.graphics.g3d.old.model.Model;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
 public class JsonModelLoaderTest extends GdxTest {
@@ -21,7 +21,7 @@ public class JsonModelLoaderTest extends GdxTest {
 	@Override
 	public void create () {
 		JsonModelLoader loader = new JsonModelLoader();
-		model = loader.load(Gdx.files.internal("data/g3d/head_parented.g3dj"), null);
+		model = loader.load(Gdx.files.internal("data/g3d/head.g3dj"), null);
 		
 		cam = new PerspectiveCamera(67, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
 		cam.position.set(1f, 1.5f, 1f);
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/superkoalio/SuperKoalio.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/superkoalio/SuperKoalio.java
index be5ee00..2ebe487 100755
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/superkoalio/SuperKoalio.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/superkoalio/SuperKoalio.java
@@ -16,6 +16,7 @@ import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
 import com.badlogic.gdx.maps.tiled.TiledMapTileLayer.Cell;
 import com.badlogic.gdx.maps.tiled.TmxMapLoader;
 import com.badlogic.gdx.maps.tiled.renderers.OrthogonalTiledMapRenderer;
+import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.math.Rectangle;
 import com.badlogic.gdx.math.Vector2;
 import com.badlogic.gdx.tests.utils.GdxTest;
@@ -36,12 +37,12 @@ public class SuperKoalio extends GdxTest {
 	/**
 	 * The player character, has state and state time, 
 	 */
-	private static class Koala {
-		private static float WIDTH;
-		private static float HEIGHT;
-		private static float MAX_VELOCITY = 10f;
-		private static float JUMP_VELOCITY = 40f;
-		private static float DAMPING = 0.87f;
+	static class Koala {
+		static float WIDTH;
+		static float HEIGHT;
+		static float MAX_VELOCITY = 10f;
+		static float JUMP_VELOCITY = 40f;
+		static float DAMPING = 0.87f;
 		
 		enum State {
 			Standing,
@@ -132,6 +133,7 @@ public class SuperKoalio extends GdxTest {
 	
 	private Vector2 tmp = new Vector2();
 	private void updateKoala(float deltaTime) {
+		if(deltaTime == 0) return;
 		koala.stateTime += deltaTime;	
 		
 		// check input and apply to velocity & state
@@ -213,7 +215,7 @@ public class SuperKoalio extends GdxTest {
 				if(koala.velocity.y > 0) {
 					koala.position.y = tile.y - Koala.HEIGHT;
 					// we hit a block jumping upwards, let's destroy it!
-					TiledMapTileLayer layer = (TiledMapTileLayer)map.getLayers().getLayer(1);
+					TiledMapTileLayer layer = (TiledMapTileLayer)map.getLayers().get(1);
 					layer.setCell((int)tile.x, (int)tile.y, null);
 				} else {
 					koala.position.y = tile.y + tile.height;
@@ -250,7 +252,7 @@ public class SuperKoalio extends GdxTest {
 	}
 	
 	private void getTiles(int startX, int startY, int endX, int endY, Array<Rectangle> tiles) {
-		TiledMapTileLayer layer = (TiledMapTileLayer)map.getLayers().getLayer(1);
+		TiledMapTileLayer layer = (TiledMapTileLayer)map.getLayers().get(1);
 		rectPool.freeAll(tiles);
 		tiles.clear();
 		for(int y = startY; y <= endY; y++) {
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
index ca1fe3a..55fccaf 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
@@ -37,7 +37,7 @@ import com.badlogic.gdx.tests.*;
 import com.badlogic.gdx.tests.bench.TiledMapBench;
 import com.badlogic.gdx.tests.examples.MoveSpriteExample;
 import com.badlogic.gdx.tests.g3d.BatchRenderTest;
-import com.badlogic.gdx.tests.g3d.JsonModelLoaderTest;
+import com.badlogic.gdx.tests.g3d.JsonModelLoaderTest;
 import com.badlogic.gdx.tests.gles2.HelloTriangle;
 import com.badlogic.gdx.tests.gles2.SimpleVertexShader;
 import com.badlogic.gdx.tests.net.NetAPITest;
@@ -77,9 +77,10 @@ public class GdxTests {
 		// SoundTouchTest.class, Mpg123Test.class, WavTest.class, FreeTypeTest.class,
 		// InternationalFontsTest.class, VorbisTest.class
 		TextButtonTest.class, TextButtonTestGL2.class, TextureBindTest.class, SortedSpriteTest.class,
-		ExternalMusicTest.class, SoftKeyboardTest.class, DirtyRenderingTest.class, YDownTest.class,  BatchRenderTest.class,
+		ExternalMusicTest.class, SoftKeyboardTest.class, DirtyRenderingTest.class, YDownTest.class,
 		ScreenCaptureTest.class, BitmapFontTest.class, LabelScaleTest.class, GamepadTest.class, NetAPITest.class, TideMapAssetManagerTest.class, TideMapDirectLoaderTest.class, TiledMapAssetManagerTest.class, TiledMapBench.class,
-		RunnablePostTest.class, Vector2dTest.class, SuperKoalio.class));
+		RunnablePostTest.class, Vector2dTest.class, SuperKoalio.class, NinePatchTest.class,
+		JsonModelLoaderTest.class, BatchRenderTest.class));
 	
 	public static List<String> getNames () {
 		List<String> names = new ArrayList<String>(tests.size());
