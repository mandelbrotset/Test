diff --git a/gdx/src/com/badlogic/gdx/graphics/OrthographicCamera.java b/gdx/src/com/badlogic/gdx/graphics/OrthographicCamera.java
index 263b80f..5010399 100644
--- a/gdx/src/com/badlogic/gdx/graphics/OrthographicCamera.java
+++ b/gdx/src/com/badlogic/gdx/graphics/OrthographicCamera.java
@@ -33,8 +33,8 @@ public class OrthographicCamera extends Camera {
 	}
 
 	/** Constructs a new OrthographicCamera, using the given viewport width and height. For pixel perfect 2D rendering just supply
-	 * the screen size, for other unit scales (e.g. meters for box2d) proceed accordingly. The camera will show the region [-viewportWidth/2, -viewportHeight / 2]- [viewportWidth/2, viewportHeight/2]
-	 * 
+	 * the screen size, for other unit scales (e.g. meters for box2d) proceed accordingly. The camera will show the region
+	 * [-viewportWidth/2, -(viewportHeight/2-1)] - [(viewportWidth/2-1), viewportHeight/2]
 	 * @param viewportWidth the viewport width
 	 * @param viewportHeight the viewport height */
 	public OrthographicCamera (float viewportWidth, float viewportHeight) {
@@ -44,6 +44,65 @@ public class OrthographicCamera extends Camera {
 		update();
 	}
 
+	/** Constructs a new OrthographicCamera, using the given viewport width and height. This will create a camera useable for
+	 * iso-metric views. The diamond angle is specifies the angle of a tile viewed isometrically.
+	 * @param viewportWidth the viewport width
+	 * @param viewportHeight the viewport height
+	 * @param diamondAngle the angle in degrees */
+	public OrthographicCamera (float viewportWidth, float viewportHeight, float diamondAngle) {
+		this.viewportWidth = viewportWidth;
+		this.viewportHeight = viewportHeight;
+		this.near = 0;
+		findDirectionForIsoView(diamondAngle, 0.00000001f, 20);
+		update();
+	}
+
+	public void findDirectionForIsoView (float targetAngle, float epsilon, int maxIterations) {
+		float start = targetAngle - 5;
+		float end = targetAngle + 5;
+		float mid = targetAngle;
+
+		int iterations = 0;
+		float aMid = 0;
+		while (Math.abs(targetAngle - aMid) > epsilon && iterations++ < maxIterations) {
+			aMid = calculateAngle(mid);
+
+			if (targetAngle < aMid) {
+				end = mid;
+			} else {
+				start = mid;
+			}
+			mid = start + (end - start) / 2;
+		}
+		position.set(calculateDirection(mid));
+		position.y = -position.y;
+		lookAt(0, 0, 0);
+		normalizeUp();
+	}
+
+	private float calculateAngle (float a) {
+		Vector3 camPos = calculateDirection(a);
+		position.set(camPos.scl(30));
+		lookAt(0, 0, 0);
+		normalizeUp();
+		update();
+
+		Vector3 orig = new Vector3(0, 0, 0);
+		Vector3 vec = new Vector3(1, 0, 0);
+		project(orig);
+		project(vec);
+		Vector2 d = new Vector2(vec.x - orig.x, -(vec.y - orig.y));
+		return d.angle();
+	}
+
+	private Vector3 calculateDirection (float angle) {
+		Matrix4 transform = new Matrix4();
+		Vector3 dir = new Vector3(-1, 0, 1).nor();
+		transform.setToRotation(new Vector3(1, 0, 1).nor(), angle);
+		dir.mul(transform).nor();
+		return dir;
+	}
+
 	private final Vector3 tmp = new Vector3();
 
 	@Override
@@ -53,7 +112,7 @@ public class OrthographicCamera extends Camera {
 
 	@Override
 	public void update (boolean updateFrustum) {
-		projection.setToOrtho(zoom * -viewportWidth / 2, zoom * viewportWidth / 2, zoom * -viewportHeight / 2, zoom
+		projection.setToOrtho(zoom * -viewportWidth / 2, zoom * (viewportWidth / 2 - 1), zoom * -(viewportHeight / 2 - 1), zoom
 			* viewportHeight / 2, Math.abs(near), Math.abs(far));
 		view.setToLookAt(position, tmp.set(position).add(direction), up);
 		combined.set(projection);
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/Stage.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/Stage.java
index 8d60c4a..dc46f72 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/Stage.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/Stage.java
@@ -82,6 +82,12 @@ public class Stage extends InputAdapter implements Disposable {
 		this(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), false, null);
 	}
 
+	/** Creates a stage with the specified {@link #setViewport(float, float, boolean) viewport} that doesn't keep the aspect ratio.
+	 * The stage will use its own {@link SpriteBatch}, which will be disposed when the stage is disposed. */
+	public Stage (float width, float height) {
+		this(width, height, false, null);
+	}
+
 	/** Creates a stage with the specified {@link #setViewport(float, float, boolean) viewport}. The stage will use its own
 	 * {@link SpriteBatch}, which will be disposed when the stage is disposed. */
 	public Stage (float width, float height, boolean keepAspectRatio) {
@@ -106,6 +112,12 @@ public class Stage extends InputAdapter implements Disposable {
 		setViewport(width, height, keepAspectRatio);
 	}
 
+	/** Sets up the stage size using a viewport that fills the entire screen without keeping the aspect ratio.
+	 * @see #setViewport(float, float, boolean, float, float, float, float) */
+	public void setViewport (float width, float height) {
+		setViewport(width, height, false, 0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
+	}
+
 	/** Sets up the stage size using a viewport that fills the entire screen.
 	 * @see #setViewport(float, float, boolean, float, float, float, float) */
 	public void setViewport (float width, float height, boolean keepAspectRatio) {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ScrollPane.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ScrollPane.java
index 55c5248..c030e5f 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ScrollPane.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ScrollPane.java
@@ -56,6 +56,8 @@ public class ScrollPane extends WidgetGroup {
 	private ActorGestureListener flickScrollListener;
 
 	boolean scrollX, scrollY;
+	boolean vScrollOnRight = true;
+	boolean hScrollOnBottom = true;
 	float amountX, amountY;
 	float visualAmountX, visualAmountY;
 	float maxX, maxY;
@@ -416,7 +418,21 @@ public class ScrollPane extends WidgetGroup {
 				if (scrollY) widgetAreaBounds.width += scrollbarWidth;
 			} else {
 				// Offset widget area y for horizontal scrollbar.
-				if (scrollX) widgetAreaBounds.y += scrollbarHeight;
+				if (scrollX) {
+					if (hScrollOnBottom) {
+						widgetAreaBounds.y += scrollbarHeight;
+					} else {
+						widgetAreaBounds.y = 0;
+					}
+				}
+				// Offset widget area x for vertical scrollbar.
+				if (scrollY) {
+					if (vScrollOnRight) {
+						widgetAreaBounds.x = 0;
+					} else {
+						widgetAreaBounds.x += scrollbarWidth;
+					}
+				}
 			}
 		}
 
@@ -438,7 +454,20 @@ public class ScrollPane extends WidgetGroup {
 		if (scrollX) {
 			if (hScrollKnob != null) {
 				float hScrollHeight = style.hScroll != null ? style.hScroll.getMinHeight() : hScrollKnob.getMinHeight();
-				hScrollBounds.set(bgLeftWidth, bgBottomHeight, areaWidth, hScrollHeight);
+				// the small gap where the two scroll bars intersect might have to flip from right to left
+				float boundsX, boundsY;
+				if (vScrollOnRight) {
+					boundsX = bgLeftWidth;
+				} else {
+					boundsX = bgLeftWidth + scrollbarWidth;
+				}
+				// bar on the top or bottom
+				if (hScrollOnBottom) {
+					boundsY = bgBottomHeight;
+				} else {
+					boundsY = height - bgTopHeight - hScrollHeight;
+				}
+				hScrollBounds.set(boundsX, boundsY, areaWidth, hScrollHeight);
 				hKnobBounds.width = Math.max(hScrollKnob.getMinWidth(), (int)(hScrollBounds.width * areaWidth / widgetWidth));
 				hKnobBounds.height = hScrollKnob.getMinHeight();
 				hKnobBounds.x = hScrollBounds.x + (int)((hScrollBounds.width - hKnobBounds.width) * getScrollPercentX());
@@ -451,10 +480,27 @@ public class ScrollPane extends WidgetGroup {
 		if (scrollY) {
 			if (vScrollKnob != null) {
 				float vScrollWidth = style.vScroll != null ? style.vScroll.getMinWidth() : vScrollKnob.getMinWidth();
-				vScrollBounds.set(width - bgRightWidth - vScrollWidth, height - bgTopHeight - areaHeight, vScrollWidth, areaHeight);
+				// the small gap where the two scroll bars intersect might have to flip from bottom to top
+				float boundsX, boundsY;
+				if (hScrollOnBottom) {
+					boundsY = height - bgTopHeight - areaHeight;
+				} else {
+					boundsY = bgBottomHeight;
+				}
+				// bar on the left or right
+				if (vScrollOnRight) {
+					boundsX = width - bgRightWidth - vScrollWidth;
+				} else {
+					boundsX = bgLeftWidth;
+				}
+				vScrollBounds.set(boundsX, boundsY, vScrollWidth, areaHeight);
 				vKnobBounds.width = vScrollKnob.getMinWidth();
 				vKnobBounds.height = Math.max(vScrollKnob.getMinHeight(), (int)(vScrollBounds.height * areaHeight / widgetHeight));
-				vKnobBounds.x = width - bgRightWidth - vScrollKnob.getMinWidth();
+				if (vScrollOnRight) {
+					vKnobBounds.x = width - bgRightWidth - vScrollKnob.getMinWidth();
+				} else {
+					vKnobBounds.x = bgLeftWidth;
+				}
 				vKnobBounds.y = vScrollBounds.y + (int)((vScrollBounds.height - vKnobBounds.height) * (1 - getScrollPercentY()));
 			} else {
 				vScrollBounds.set(0, 0, 0, 0);
@@ -848,6 +894,14 @@ public class ScrollPane extends WidgetGroup {
 		this.clamp = clamp;
 	}
 
+	/** Set the position of the vertical and horizontal scroll bars (if they exist).
+	 * @param bottom sets horizontal scroll bar to be at the bottom or the top
+	 * @param right sets vertical scroll bar to be at the right or the left */
+	public void setScrollBarPositions (boolean bottom, boolean right) {
+		hScrollOnBottom = bottom;
+		vScrollOnRight = right;
+	}
+
 	/** When true the scroll bars fade out after some time of not being used. */
 	public void setFadeScrollBars (boolean fadeScrollBars) {
 		if (this.fadeScrollBars == fadeScrollBars) return;
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Window.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Window.java
index 1e95ba3..c3e246d 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Window.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Window.java
@@ -156,8 +156,8 @@ public class Window extends Table {
 			Color color = getColor();
 			batch.setColor(color.r, color.g, color.b, color.a * parentAlpha);
 			Stage stage = getStage();
-			stageToLocalCoordinates(/* in/out */tmpPosition.set(0, -1));
-			stageToLocalCoordinates(/* in/out */tmpSize.set(stage.getWidth() + 1, stage.getHeight()));
+			stageToLocalCoordinates(/* in/out */tmpPosition.set(0, 0));
+			stageToLocalCoordinates(/* in/out */tmpSize.set(stage.getWidth(), stage.getHeight()));
 			style.stageBackground.draw(batch, x + tmpPosition.x, y + tmpPosition.y, x + tmpSize.x, y + tmpSize.y);
 		}
 
diff --git a/gdx/src/com/badlogic/gdx/utils/Json.java b/gdx/src/com/badlogic/gdx/utils/Json.java
index 452a7db..faaa2a4 100644
--- a/gdx/src/com/badlogic/gdx/utils/Json.java
+++ b/gdx/src/com/badlogic/gdx/utils/Json.java
@@ -225,6 +225,7 @@ public class Json {
 		return writer;
 	}
 
+	/** Writes all fields of the specified object to the current JSON object. */
 	public void writeFields (Object object) {
 		Class type = object.getClass();
 
@@ -295,20 +296,24 @@ public class Json {
 		return values;
 	}
 
+	/** @see #writeField(Object, String, String, Class) */
 	public void writeField (Object object, String name) {
 		writeField(object, name, name, null);
 	}
 
-	/** @param elementType May be null if the type is unknown. */
+	/** @param elementType May be null if the type is unknown.
+	 * @see #writeField(Object, String, String, Class) */
 	public void writeField (Object object, String name, Class elementType) {
 		writeField(object, name, name, elementType);
 	}
 
+	/** @see #writeField(Object, String, String, Class) */
 	public void writeField (Object object, String fieldName, String jsonName) {
 		writeField(object, fieldName, jsonName, null);
 	}
 
-	/** @param elementType May be null if the type is unknown. */
+	/** Writes the specified field to the current JSON object.
+	 * @param elementType May be null if the type is unknown. */
 	public void writeField (Object object, String fieldName, String jsonName, Class elementType) {
 		Class type = object.getClass();
 		ObjectMap<String, FieldMetadata> fields = typeToFields.get(type);
@@ -333,7 +338,9 @@ public class Json {
 		}
 	}
 
-	/** @param value May be null. */
+	/** Writes the value as a field on the current JSON object, without writing the actual class.
+	 * @param value May be null.
+	 * @see #writeValue(String, Object, Class, Class) */
 	public void writeValue (String name, Object value) {
 		try {
 			writer.name(name);
@@ -346,8 +353,11 @@ public class Json {
 			writeValue(value, value.getClass(), null);
 	}
 
-	/** @param value May be null.
-	 * @param knownType May be null if the type is unknown. */
+	/** Writes the value as a field on the current JSON object, writing the class of the object if it differs from the specified
+	 * known type.
+	 * @param value May be null.
+	 * @param knownType May be null if the type is unknown.
+	 * @see #writeValue(String, Object, Class, Class) */
 	public void writeValue (String name, Object value, Class knownType) {
 		try {
 			writer.name(name);
@@ -357,7 +367,9 @@ public class Json {
 		writeValue(value, knownType, null);
 	}
 
-	/** @param value May be null.
+	/** Writes the value as a field on the current JSON object, writing the class of the object if it differs from the specified
+	 * known type. The specified element type is used as the default type for collections.
+	 * @param value May be null.
 	 * @param knownType May be null if the type is unknown.
 	 * @param elementType May be null if the type is unknown. */
 	public void writeValue (String name, Object value, Class knownType, Class elementType) {
@@ -369,7 +381,8 @@ public class Json {
 		writeValue(value, knownType, elementType);
 	}
 
-	/** @param value May be null. */
+	/** Writes the value, without writing the class of the object.
+	 * @param value May be null. */
 	public void writeValue (Object value) {
 		if (value == null)
 			writeValue(value, null, null);
@@ -377,13 +390,16 @@ public class Json {
 			writeValue(value, value.getClass(), null);
 	}
 
-	/** @param value May be null.
+	/** Writes the value, writing the class of the object if it differs from the specified known type.
+	 * @param value May be null.
 	 * @param knownType May be null if the type is unknown. */
 	public void writeValue (Object value, Class knownType) {
 		writeValue(value, knownType, null);
 	}
 
-	/** @param value May be null.
+	/** Writes the value, writing the class of the object if it differs from the specified known type. The specified element type is
+	 * used as the default type for collections.
+	 * @param value May be null.
 	 * @param knownType May be null if the type is unknown.
 	 * @param elementType May be null if the type is unknown. */
 	public void writeValue (Object value, Class knownType, Class elementType) {
@@ -550,7 +566,8 @@ public class Json {
 		}
 	}
 
-	/** @param knownType May be null if the type is unknown. */
+	/** Starts writing an object, writing the actualType to a field if needed.
+	 * @param knownType May be null if the type is unknown. */
 	public void writeObjectStart (Class actualType, Class knownType) {
 		try {
 			writer.object();
diff --git a/gdx/src/com/badlogic/gdx/utils/QuickSelect.java b/gdx/src/com/badlogic/gdx/utils/QuickSelect.java
index 460e877..7ecd3cb 100644
--- a/gdx/src/com/badlogic/gdx/utils/QuickSelect.java
+++ b/gdx/src/com/badlogic/gdx/utils/QuickSelect.java
@@ -1,3 +1,19 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
 package com.badlogic.gdx.utils;
 
 import java.util.Comparator;
diff --git a/gdx/src/com/badlogic/gdx/utils/Select.java b/gdx/src/com/badlogic/gdx/utils/Select.java
index 515b36d..00dae19 100644
--- a/gdx/src/com/badlogic/gdx/utils/Select.java
+++ b/gdx/src/com/badlogic/gdx/utils/Select.java
@@ -1,3 +1,19 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
 package com.badlogic.gdx.utils;
 
 import java.util.Comparator;
diff --git a/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java b/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java
index 8d13ab9..2726c39 100644
--- a/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java
+++ b/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java
@@ -31,7 +31,6 @@ import com.badlogic.gdx.tests.DelaunayTriangulatorTest;
 import com.badlogic.gdx.tests.EarClippingTriangulatorTest;
 import com.badlogic.gdx.tests.MeshShaderTest;
 import com.badlogic.gdx.tests.MipMapTest;
-import com.badlogic.gdx.tests.PixelPerfectTest;
 import com.badlogic.gdx.tests.TextureAtlasTest;
 import com.badlogic.gdx.tests.TimerTest;
 import com.badlogic.gdx.tests.g3d.Basic3DSceneTest;
@@ -54,11 +53,11 @@ public class LwjglDebugStarter {
 //		new SharedLibraryLoader("../../extensions/gdx-controllers/gdx-controllers-desktop/libs/gdx-controllers-desktop-natives.jar").load("gdx-controllers-desktop");
 //		new SharedLibraryLoader("../../gdx/libs/gdx-natives.jar").load("gdx");
 
-		GdxTest test = new PixelPerfectTest();
+		GdxTest test = new NetAPITest();
 		LwjglApplicationConfiguration config = new LwjglApplicationConfiguration();
 		config.useGL20 = test.needsGL20();
-		config.width = 320;
-		config.height = 240;
+		config.width = 1024;
+		config.height = 768;
 		new LwjglApplication(test, config);
 	}
 }
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/IsoCamTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/IsoCamTest.java
new file mode 100644
index 0000000..8b33eb8
--- /dev/null
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/IsoCamTest.java
@@ -0,0 +1,151 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.tests;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.InputAdapter;
+import com.badlogic.gdx.graphics.Camera;
+import com.badlogic.gdx.graphics.GL10;
+import com.badlogic.gdx.graphics.OrthographicCamera;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.g2d.Sprite;
+import com.badlogic.gdx.graphics.g2d.SpriteBatch;
+import com.badlogic.gdx.math.Intersector;
+import com.badlogic.gdx.math.Matrix4;
+import com.badlogic.gdx.math.Plane;
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.math.collision.Ray;
+import com.badlogic.gdx.tests.utils.GdxTest;
+
+public class IsoCamTest extends GdxTest {
+	private static final int TARGET_WIDTH = 480;
+	private static final float UNIT_TO_PIXEL = TARGET_WIDTH * 0.15f;
+	Texture texture;
+	OrthographicCamera cam;
+	SpriteBatch batch;
+	final Sprite[][] sprites = new Sprite[10][10];
+	final Matrix4 matrix = new Matrix4();
+
+	@Override
+	public void create () {
+		texture = new Texture(Gdx.files.internal("data/badlogicsmall.jpg"));
+		float unitsOnX = (float)Math.sqrt(2) * TARGET_WIDTH / (UNIT_TO_PIXEL);
+		float pixelsOnX = Gdx.graphics.getWidth() / unitsOnX;
+		float unitsOnY = Gdx.graphics.getHeight() / pixelsOnX;
+		cam = new OrthographicCamera(unitsOnX, unitsOnY, 25);
+		cam.position.scl(30);
+		cam.near = 1;
+		cam.far = 1000;
+		matrix.setToRotation(new Vector3(1, 0, 0), 90);
+
+		for (int z = 0; z < 10; z++) {
+			for (int x = 0; x < 10; x++) {
+				sprites[x][z] = new Sprite(texture);
+				sprites[x][z].setPosition(x, z);
+				sprites[x][z].setSize(1, 1);
+			}
+		}
+
+		batch = new SpriteBatch();
+
+		Gdx.input.setInputProcessor(new IsoCamController(cam));
+	}
+
+	@Override
+	public void dispose () {
+		texture.dispose();
+		batch.dispose();
+	}
+
+	@Override
+	public void render () {
+		Gdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
+		cam.update();
+
+		batch.setProjectionMatrix(cam.combined);
+		batch.setTransformMatrix(matrix);
+		batch.begin();
+		for (int z = 0; z < 10; z++) {
+			for (int x = 0; x < 10; x++) {
+				sprites[x][z].draw(batch);
+			}
+		}
+		batch.end();
+
+		checkTileTouched();
+	}
+
+	final Plane xzPlane = new Plane(new Vector3(0, 1, 0), 0);
+	final Vector3 intersection = new Vector3();
+	Sprite lastSelectedTile = null;
+
+	private void checkTileTouched () {
+		if (Gdx.input.justTouched()) {
+			Ray pickRay = cam.getPickRay(Gdx.input.getX(), Gdx.input.getY());
+			Intersector.intersectRayPlane(pickRay, xzPlane, intersection);
+			System.out.println(intersection);
+			int x = (int)intersection.x;
+			int z = (int)intersection.z;
+			if (x >= 0 && x < 10 && z >= 0 && z < 10) {
+				if (lastSelectedTile != null) lastSelectedTile.setColor(1, 1, 1, 1);
+				Sprite sprite = sprites[x][z];
+				sprite.setColor(1, 0, 0, 1);
+				lastSelectedTile = sprite;
+			}
+		}
+	}
+
+	public class IsoCamController extends InputAdapter {
+		final Plane xzPlane = new Plane(new Vector3(0, 1, 0), 0);
+		final Vector3 intersection = new Vector3();
+		final Vector3 curr = new Vector3();
+		final Vector3 last = new Vector3(-1, -1, -1);
+		final Vector3 delta = new Vector3();
+		final Camera camera;
+
+		public IsoCamController (Camera camera) {
+			this.camera = camera;
+		}
+
+		@Override
+		public boolean touchDragged (int x, int y, int pointer) {
+			Ray pickRay = camera.getPickRay(x, y);
+			Intersector.intersectRayPlane(pickRay, xzPlane, curr);
+
+			if (!(last.x == -1 && last.y == -1 && last.z == -1)) {
+				pickRay = camera.getPickRay(last.x, last.y);
+				Intersector.intersectRayPlane(pickRay, xzPlane, delta);
+				delta.sub(curr);
+				camera.position.add(delta.x, 0, delta.z);
+			}
+			last.set(x, y, 0);
+			return false;
+		}
+
+		@Override
+		public boolean touchUp (int x, int y, int pointer, int button) {
+			last.set(-1, -1, -1);
+			return false;
+		}
+	}
+
+	@Override
+	public boolean needsGL20 () {
+		return false;
+	}
+
+}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/PixelPerfectTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/PixelPerfectTest.java
deleted file mode 100644
index c4d05e8..0000000
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/PixelPerfectTest.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package com.badlogic.gdx.tests;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.graphics.Color;
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.OrthographicCamera;
-import com.badlogic.gdx.graphics.Pixmap;
-import com.badlogic.gdx.graphics.Texture;
-import com.badlogic.gdx.graphics.g2d.SpriteBatch;
-import com.badlogic.gdx.tests.utils.GdxTest;
-
-public class PixelPerfectTest extends GdxTest {
-	SpriteBatch batch;
-	OrthographicCamera cam;
-	Texture tex;
-
-	@Override
-	public void create () {
-		Pixmap pixmap = new Pixmap(16, 16, Pixmap.Format.RGBA8888);
-		pixmap.setColor(Color.BLUE);
-		pixmap.fill();
-		pixmap.setColor(Color.RED);
-		pixmap.drawLine(0, 0, 15, 15);
-		pixmap.drawLine(0, 15, 15, 0);
-		
-		tex = new Texture(pixmap);
-		batch = new SpriteBatch();
-		cam = new OrthographicCamera();
-		cam.setToOrtho(false, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
-	}
-
-	@Override
-	public void render () {
-		Gdx.gl.glClearColor(1, 0, 1, 1);
-		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
-		cam.update();
-		batch.setProjectionMatrix(cam.combined);
-		batch.begin();
-		batch.draw(tex, 1, 1);
-		batch.end();
-	}
-}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/ScrollPaneScrollBarsTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/ScrollPaneScrollBarsTest.java
new file mode 100644
index 0000000..76020be
--- /dev/null
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/ScrollPaneScrollBarsTest.java
@@ -0,0 +1,243 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.tests;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.GL10;
+import com.badlogic.gdx.scenes.scene2d.Actor;
+import com.badlogic.gdx.scenes.scene2d.Stage;
+import com.badlogic.gdx.scenes.scene2d.ui.Label;
+import com.badlogic.gdx.scenes.scene2d.ui.ScrollPane;
+import com.badlogic.gdx.scenes.scene2d.ui.Skin;
+import com.badlogic.gdx.scenes.scene2d.ui.Table;
+import com.badlogic.gdx.scenes.scene2d.ui.TextButton;
+import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
+import com.badlogic.gdx.tests.utils.GdxTest;
+import com.badlogic.gdx.utils.Array;
+
+/** Test switch of scroll bars + knobs from right to left, and bottom to top */
+public class ScrollPaneScrollBarsTest extends GdxTest {
+	private Stage stage;
+	private Array<ScrollPane> scrollPanes = new Array<ScrollPane>();
+	private boolean doFade = true;
+	private boolean doOnTop = true;
+	private Table bottomLeft, bottomRight, topLeft, topRight, horizOnlyTop, horizOnlyBottom, vertOnlyLeft, vertOnlyRight;
+
+	public void create () {
+		float width = Gdx.graphics.getWidth();
+		float height = Gdx.graphics.getHeight();
+		float btnWidth = 200;
+		float btnHeight = 40;
+		stage = new Stage(0, 0, false);
+		Skin skin = new Skin(Gdx.files.internal("data/uiskin.json"));
+		Gdx.input.setInputProcessor(stage);
+
+		final TextButton fadeBtn = new TextButton("Fade: " + doFade, skin);
+		fadeBtn.setSize(btnWidth, btnHeight);
+		fadeBtn.setPosition(0, height - fadeBtn.getHeight());
+		stage.addActor(fadeBtn);
+		fadeBtn.addListener(new ChangeListener() {
+			@Override
+			public void changed (ChangeEvent event, Actor actor) {
+				doFade = !doFade;
+				fadeBtn.setText("Fade: " + doFade);
+				for (ScrollPane pane : scrollPanes) {
+					pane.setFadeScrollBars(doFade);
+				}
+			}
+		});
+
+		final TextButton onTopBtn = new TextButton("ScrollbarsOnTop: " + doOnTop, skin);
+		onTopBtn.setSize(btnWidth, btnHeight);
+		onTopBtn.setPosition(0 + fadeBtn.getWidth() + 20, height - onTopBtn.getHeight());
+		stage.addActor(onTopBtn);
+		onTopBtn.addListener(new ChangeListener() {
+			@Override
+			public void changed (ChangeEvent event, Actor actor) {
+				doOnTop = !doOnTop;
+				onTopBtn.setText("ScrollbarOnTop: " + doOnTop);
+				onTopBtn.invalidate();
+				for (ScrollPane pane : scrollPanes) {
+					pane.setScrollbarsOnTop(doOnTop);
+				}
+			}
+		});
+
+		// Gdx.graphics.setVSync(false);
+
+		float gap = 8;
+		float x = gap;
+		float y = gap;
+		float contWidth = width / 2 - gap * 1.5f;
+		float contHeight = height / 4.5f - gap * 1.25f;
+
+		bottomLeft = new Table();
+		bottomLeft.setPosition(x, y);
+		bottomLeft.setSize(contWidth, contHeight);
+		stage.addActor(bottomLeft);
+
+		bottomRight = new Table();
+		bottomRight.setSize(contWidth, contHeight);
+		x = bottomLeft.getX() + bottomLeft.getWidth() + gap;
+		bottomRight.setPosition(x, y);
+		stage.addActor(bottomRight);
+
+		topLeft = new Table();
+		topLeft.setSize(contWidth, contHeight);
+		x = bottomLeft.getX();
+		y = bottomLeft.getY() + bottomLeft.getHeight() + gap;
+		topLeft.setPosition(x, y);
+		stage.addActor(topLeft);
+
+		topRight = new Table();
+		topRight.setSize(contWidth, contHeight);
+		x = bottomRight.getX();
+		y = topLeft.getY();
+		topRight.setPosition(x, y);
+		stage.addActor(topRight);
+
+		horizOnlyTop = new Table();
+		horizOnlyTop.setSize(contWidth, contHeight);
+		x = topRight.getX();
+		y = topRight.getY() + topRight.getHeight() + gap;
+		horizOnlyTop.setPosition(x, y);
+		stage.addActor(horizOnlyTop);
+
+		horizOnlyBottom = new Table();
+		horizOnlyBottom.setSize(contWidth, contHeight);
+		x = topLeft.getX();
+		y = topLeft.getY() + topLeft.getHeight() + gap;
+		horizOnlyBottom.setPosition(x, y);
+		stage.addActor(horizOnlyBottom);
+
+		vertOnlyLeft = new Table();
+		vertOnlyLeft.setSize(contWidth, contHeight);
+		x = horizOnlyBottom.getX();
+		y = horizOnlyBottom.getY() + horizOnlyBottom.getHeight() + gap;
+		vertOnlyLeft.setPosition(x, y);
+		stage.addActor(vertOnlyLeft);
+
+		vertOnlyRight = new Table();
+		vertOnlyRight.setSize(contWidth, contHeight);
+		x = horizOnlyTop.getX();
+		y = horizOnlyTop.getY() + horizOnlyTop.getHeight() + gap;
+		vertOnlyRight.setPosition(x, y);
+		stage.addActor(vertOnlyRight);
+
+		Table bottomLeftTable = new Table();
+		Table bottomRightTable = new Table();
+		Table topLeftTable = new Table();
+		Table topRightTable = new Table();
+		Table horizOnlyTopTable = new Table();
+		Table horizOnlyBottomTable = new Table();
+		Table vertOnlyLeftTable = new Table();
+		Table vertOnlyRightTable = new Table();
+
+		final ScrollPane bottomLeftScroll = new ScrollPane(bottomLeftTable, skin);
+		bottomLeftScroll.setScrollBarPositions(true, false);
+
+		final ScrollPane bottomRightScroll = new ScrollPane(bottomRightTable, skin);
+		bottomRightScroll.setScrollBarPositions(true, true);
+
+		final ScrollPane topLeftScroll = new ScrollPane(topLeftTable, skin);
+		topLeftScroll.setScrollBarPositions(false, false);
+
+		final ScrollPane topRightScroll = new ScrollPane(topRightTable, skin);
+		topRightScroll.setScrollBarPositions(false, true);
+
+		final ScrollPane horizOnlyTopScroll = new ScrollPane(horizOnlyTopTable, skin);
+		horizOnlyTopScroll.setScrollBarPositions(false, true);
+
+		final ScrollPane horizOnlyBottomScroll = new ScrollPane(horizOnlyBottomTable, skin);
+		horizOnlyBottomScroll.setScrollBarPositions(true, true);
+
+		final ScrollPane vertOnlyLeftScroll = new ScrollPane(vertOnlyLeftTable, skin);
+		vertOnlyLeftScroll.setScrollBarPositions(true, false);
+
+		final ScrollPane vertOnlyRightScroll = new ScrollPane(vertOnlyRightTable, skin);
+		vertOnlyRightScroll.setScrollBarPositions(true, true);
+
+		ScrollPane[] panes = new ScrollPane[] {bottomLeftScroll, bottomRightScroll, topLeftScroll, topRightScroll,
+			horizOnlyTopScroll, horizOnlyBottomScroll, vertOnlyLeftScroll, vertOnlyRightScroll};
+		for (ScrollPane pane : panes) {
+			scrollPanes.add(pane);
+		}
+
+		Table[] tables = new Table[] {bottomLeftTable, bottomRightTable, topLeftTable, topRightTable, horizOnlyTopTable,
+			horizOnlyBottomTable, vertOnlyLeftTable, vertOnlyRightTable};
+		for (Table t : tables) {
+			t.pad(10).defaults().expandX().space(4);
+		}
+
+		horizOnlyTopTable
+			.add(new Label("HORIZONTAL-ONLY-TOP verify HORIZONTAL scroll bar is on the TOP and properly aligned", skin));
+		horizOnlyBottomTable.add(new Label(
+			"HORIZONTAL-ONLY-BOTTOM verify HORIZONTAL scroll bar is on the BOTTOM and properly aligned", skin));
+
+		for (int i = 0; i < 12; i++) {
+			bottomLeftTable.row();
+			bottomRightTable.row();
+			topLeftTable.row();
+			topRightTable.row();
+
+			bottomLeftTable.add(new Label(i
+				+ " BOTTOM-LEFT verify scroll bars are on the BOTTOM and the LEFT, and are properly aligned", skin));
+			bottomRightTable.add(new Label(i
+				+ " BOTTOM-RIGHT verify scroll bars are on the BOTTOM and the RIGHT, and are properly aligned", skin));
+			topLeftTable.add(new Label(i + " TOP-LEFT verify scroll bars are on the TOP and the LEFT, and are properly aligned",
+				skin));
+			topRightTable.add(new Label(i + " TOP-RIGHT verify scroll bars are on the TOP and the RIGHT, and are properly aligned",
+				skin));
+
+			vertOnlyLeftTable.row();
+			vertOnlyRightTable.row();
+
+			vertOnlyLeftTable.add(new Label("VERT-ONLY-LEFT", skin));
+			vertOnlyRightTable.add(new Label("VERT-ONLY-RIGHT", skin));
+		}
+
+		bottomLeft.add(bottomLeftScroll).expand().fill().colspan(4);
+		bottomRight.add(bottomRightScroll).expand().fill().colspan(4);
+		topLeft.add(topLeftScroll).expand().fill().colspan(4);
+		topRight.add(topRightScroll).expand().fill().colspan(4);
+		horizOnlyTop.add(horizOnlyTopScroll).expand().fill().colspan(4);
+		horizOnlyBottom.add(horizOnlyBottomScroll).expand().fill().colspan(4);
+		vertOnlyLeft.add(vertOnlyLeftScroll).expand().fill().colspan(4);
+		vertOnlyRight.add(vertOnlyRightScroll).expand().fill().colspan(4);
+	}
+
+	public void render () {
+		Gdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
+		stage.act(Gdx.graphics.getDeltaTime());
+		stage.draw();
+		Table.drawDebug(stage);
+	}
+
+	public void resize (int width, int height) {
+		stage.setViewport(width, height, false);
+		// Gdx.gl.glViewport(100, 100, width - 200, height - 200);
+		// stage.setViewport(800, 600, false, 100, 100, width - 200, height - 200);
+	}
+
+	public void dispose () {
+		stage.dispose();
+	}
+
+	public boolean needsGL20 () {
+		return false;
+	}
+}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/SelectTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/SelectTest.java
index 93b09f6..bc62d98 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/SelectTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/SelectTest.java
@@ -1,3 +1,18 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
 
 package com.badlogic.gdx.tests;
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/gwt/GwtTestWrapper.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/gwt/GwtTestWrapper.java
index 5427b87..4b3ce83 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/gwt/GwtTestWrapper.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/gwt/GwtTestWrapper.java
@@ -63,6 +63,7 @@ import com.badlogic.gdx.tests.ImageTest;
 import com.badlogic.gdx.tests.IndexBufferObjectShaderTest;
 import com.badlogic.gdx.tests.IntegerBitmapFontTest;
 import com.badlogic.gdx.tests.InverseKinematicsTest;
+import com.badlogic.gdx.tests.IsoCamTest;
 import com.badlogic.gdx.tests.IsometricTileTest;
 import com.badlogic.gdx.tests.KinematicBodyTest;
 import com.badlogic.gdx.tests.LabelScaleTest;
@@ -77,6 +78,7 @@ import com.badlogic.gdx.tests.ParticleEmitterTest;
 import com.badlogic.gdx.tests.PixelsPerInchTest;
 import com.badlogic.gdx.tests.ProjectiveTextureTest;
 import com.badlogic.gdx.tests.RotationTest;
+import com.badlogic.gdx.tests.RunnablePostTest;
 import com.badlogic.gdx.tests.ShadowMappingTest;
 import com.badlogic.gdx.tests.ShapeRendererTest;
 import com.badlogic.gdx.tests.SimpleAnimationTest;
@@ -528,6 +530,10 @@ public class GwtTestWrapper extends GdxTest {
 			}
 		}, new Instancer() {
 			public GdxTest instance () {
+				return new IsoCamTest();
+			}
+		}, new Instancer() {
+			public GdxTest instance () {
 				return new IsometricTileTest();
 			}
 		}, new Instancer() {
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
index 43dedb6..e697968 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
@@ -55,41 +55,182 @@ import com.badlogic.gdx.tests.superkoalio.SuperKoalio;
  * @author badlogicgames@gmail.com */
 public class GdxTests {
 	public static final List<Class<? extends GdxTest>> tests = new ArrayList<Class<? extends GdxTest>>(Arrays.asList(
-		AnimationTest.class, AccelerometerTest.class, ActionTest.class, ActionSequenceTest.class, LetterBoxTest3.class,
-		GroupTest.class, AlphaTest.class, AtlasIssueTest.class, AssetManagerTest.class, FilterPerformanceTest.class,
-		AudioDeviceTest.class, AudioRecorderTest.class, BitmapFontAlignmentTest.class, BitmapFontDistanceFieldTest.class, BitmapFontFlipTest.class,
-		GroupCullingTest.class, GestureDetectorTest.class, LabelTest.class, BitmapFontMetricsTest.class, BlitTest.class, TableTest.class,
-		BobTest.class, ImageScaleTest.class, TableLayoutTest.class, Box2DTest.class, BulletTestCollection.class, InterpolationTest.class, TouchpadTest.class,
-		Box2DTestCollection.class, BufferUtilsTest.class, ImageTest.class, CompassTest.class, ComplexActionTest.class,
-		CullTest.class, DeltaTimeTest.class, EarClippingTriangulatorTest.class, EdgeDetectionTest.class, ETC1Test.class, ExitTest.class, FilesTest.class,
-		ScrollPaneTest.class, FloatTest.class, FloatTextureTest.class, FrameBufferTest.class, FramebufferToTextureTest.class, FrustumTest.class,
-		FullscreenTest.class, Gdx2DTest.class, GroupFadeTest.class, ImmediateModeRendererTest.class, Scene2dTest.class,
-		ImmediateModeRendererAlphaTest.class, IndexBufferObjectClassTest.class, TreeTest.class, IndexBufferObjectShaderTest.class,
-		InputTest.class, IntegerBitmapFontTest.class, InverseKinematicsTest.class, IsometricTileTest.class,
-		KinematicBodyTest.class, LifeCycleTest.class, LineDrawingTest.class, ScrollPane2Test.class, ManagedTest.class,
-		ManualBindTest.class, MaterialTest.class, MatrixJNITest.class, MeshMultitextureTest.class, MeshShaderTest.class, MeshTest.class,
-		MipMapTest.class, MultitouchTest.class, MusicTest.class, MyFirstTriangle.class, ObjTest.class, OnscreenKeyboardTest.class,
-		OrthoCamBorderTest.class, ParallaxTest.class, ParticleEmitterTest.class, PickingTest.class, PixelsPerInchTest.class,
-		PixmapBlendingTest.class, PixmapTest.class, PixmapPackerTest.class, PolygonRegionTest.class, PolygonSpriteTest.class, PreferencesTest.class,
-		ProjectiveTextureTest.class, Pong.class, ProjectTest.class, RemoteTest.class, RotationTest.class, DragAndDropTest.class,
+		// @off
+		AccelerometerTest.class,
+		ActionSequenceTest.class,
+		ActionTest.class,
+		AlphaTest.class,
+		Animation3DTest.class,
+		AnimationTest.class,
+		AssetManagerTest.class,
+		AtlasIssueTest.class,
+		AudioDeviceTest.class,
+		AudioRecorderTest.class,
+		Basic3DSceneTest.class,
+		Basic3DTest.class,
+		BitmapFontAlignmentTest.class,
+		BitmapFontDistanceFieldTest.class,
+		BitmapFontFlipTest.class,
+		BitmapFontMetricsTest.class,
+		BitmapFontTest.class,
+		BlitTest.class,
+		BobTest.class,
+		Box2DTest.class,
+		Box2DTestCollection.class,
+		Bresenham2Test.class,
+		BufferUtilsTest.class,
+		BulletTestCollection.class,
+		CompassTest.class,
+		ComplexActionTest.class,
+		CullTest.class,
+		DelaunayTriangulatorTest.class,
+		DeltaTimeTest.class,
+		DirtyRenderingTest.class,
+		DragAndDropTest.class,
+		ETC1Test.class,
+		EarClippingTriangulatorTest.class,
+		EdgeDetectionTest.class,
+		ExitTest.class,
+		ExternalMusicTest.class,
+		FilesTest.class,
+		FilterPerformanceTest.class,
+		FloatTest.class,
+		FloatTextureTest.class,
+		FogTest.class,
+		FrameBufferTest.class,
+		FramebufferToTextureTest.class,
+		FrustumTest.class,
+		FullscreenTest.class,
+		GamepadTest.class,
+		Gdx2DTest.class,
+		GestureDetectorTest.class,
+		GroupCullingTest.class,
+		GroupFadeTest.class,
+		GroupTest.class,
+		HelloTriangle.class,
+		HexagonalTiledMapTest.class,
+		ImageScaleTest.class,
+		ImageTest.class,
+		ImmediateModeRendererAlphaTest.class,
+		ImmediateModeRendererTest.class,
+		IndexBufferObjectClassTest.class,
+		IndexBufferObjectShaderTest.class,
+		InputTest.class,
+		IntegerBitmapFontTest.class,
+		InterpolationTest.class,
+		InverseKinematicsTest.class,
+		IsoCamTest.class,
+		IsometricTileTest.class,
+		KinematicBodyTest.class,
+		LabelScaleTest.class,
+		LabelTest.class,
+		LetterBoxTest1.class,
+		LetterBoxTest2.class,
+		LetterBoxTest3.class,
+		LifeCycleTest.class,
+		LineDrawingTest.class,
+		ManagedTest.class,
+		ManualBindTest.class,
+		MaterialTest.class,
+		MatrixJNITest.class,
+		MeshMultitextureTest.class,
+		MeshShaderTest.class,
+		MeshTest.class,
+		MipMapTest.class,
+		ModelTest.class,
+		MoveSpriteExample.class,
+		MultitouchTest.class,
+		MusicTest.class,
+		MyFirstTriangle.class,
+		NetAPITest.class,
+		NinePatchTest.class,
+		ObjTest.class,
+		OnscreenKeyboardTest.class,
+		OrthoCamBorderTest.class,
+		ParallaxTest.class,
+		ParticleEmitterTest.class,
+		PathTest.class,
+		PickingTest.class,
+		PixelsPerInchTest.class,
+		PixmapBlendingTest.class,
+		PixmapPackerTest.class,
+		PixmapTest.class,
+		PolygonRegionTest.class,
+		PolygonSpriteTest.class,
+		Pong.class,
+		PreferencesTest.class,
+		ProjectTest.class,
+		ProjectiveTextureTest.class,
+		RemoteTest.class,
+		RotationTest.class,
+		RunnablePostTest.class,
+		Scene2dTest.class,
+		ScreenCaptureTest.class,
+		ScrollPane2Test.class,
+		ScrollPaneScrollBarsTest.class,
+		ScrollPaneTest.class,
 		SelectTest.class,
-		ShaderMultitextureTest.class, ShadowMappingTest.class, PathTest.class, SimpleAnimationTest.class, SimpleDecalTest.class,
-		SimpleStageCullingTest.class, SoundTest.class, SpriteCacheTest.class, SpriteCacheOffsetTest.class, LetterBoxTest1.class,
-		SpriteBatchRotationTest.class, SpriteBatchShaderTest.class, SpriteBatchTest.class, SpritePerformanceTest.class,
-		SpritePerformanceTest2.class, StagePerformanceTest.class, StageTest.class, TerrainTest.class, TextureDataTest.class,
-		TextureDownloadTest.class, TextureFormatTest.class, TextureAtlasTest.class, TextInputDialogTest.class,
-		TextureRenderTest.class, TileTest.class, UITest.class, VBOVATest.class, VertexArrayTest.class,
-		VertexBufferObjectTest.class, VertexArrayClassTest.class, VertexBufferObjectClassTest.class, LetterBoxTest2.class,
-		VertexBufferObjectShaderTest.class, VibratorTest.class, WaterRipples.class, HelloTriangle.class,
-		SimpleVertexShader.class, ShapeRendererTest.class, MoveSpriteExample.class, UISimpleTest.class,
+		ShaderCollectionTest.class,
+		ShaderMultitextureTest.class,
+		ShaderTest.class,
+		ShadowMappingTest.class,
+		ShapeRendererTest.class,
+		SimpleAnimationTest.class,
+		SimpleDecalTest.class,
+		SimpleStageCullingTest.class,
+		SimpleVertexShader.class,
+		SkeletonTest.class,
+		SoftKeyboardTest.class,
+		SortedSpriteTest.class,
+		SoundTest.class,
+		SpriteBatchRotationTest.class,
+		SpriteBatchShaderTest.class,
+		SpriteBatchTest.class,
+		SpriteCacheOffsetTest.class,
+		SpriteCacheTest.class,
+		SpritePerformanceTest.class,
+		SpritePerformanceTest2.class,
+		StagePerformanceTest.class,
+		StageTest.class,
+		SuperKoalio.class,
+		TableLayoutTest.class,
+		TableTest.class,
+		TerrainTest.class,
+		TextButtonTest.class,
+		TextButtonTestGL2.class,
+		TextInputDialogTest.class,
+		TextureAtlasTest.class,
+		TextureBindTest.class,
+		TextureDataTest.class,
+		TextureDownloadTest.class,
+		TextureFormatTest.class,
+		TextureRenderTest.class,
+		TideMapAssetManagerTest.class,
+		TideMapDirectLoaderTest.class,
+		TileTest.class,
+		TiledMapAssetManagerTest.class,
+		TiledMapBench.class,
+		TimerTest.class,
+		TouchpadTest.class,
+		TreeTest.class,
+		UISimpleTest.class,
+		UITest.class,
+		VBOVATest.class,
+		Vector2dTest.class,
+		VertexArrayClassTest.class,
+		VertexArrayTest.class,
+		VertexBufferObjectClassTest.class,
+		VertexBufferObjectShaderTest.class,
+		VertexBufferObjectTest.class,
+		VibratorTest.class,
+		WaterRipples.class,
+		YDownTest.class
+		// @on
+
 		// SoundTouchTest.class, Mpg123Test.class, WavTest.class, FreeTypeTest.class,
 		// InternationalFontsTest.class, VorbisTest.class
-		TextButtonTest.class, TextButtonTestGL2.class, TextureBindTest.class, SortedSpriteTest.class, DelaunayTriangulatorTest.class,
-		ExternalMusicTest.class, SoftKeyboardTest.class, DirtyRenderingTest.class, YDownTest.class, ShaderCollectionTest.class,
-		ScreenCaptureTest.class, BitmapFontTest.class, LabelScaleTest.class, GamepadTest.class, NetAPITest.class, TideMapAssetManagerTest.class, TideMapDirectLoaderTest.class, TiledMapAssetManagerTest.class, TiledMapBench.class,
-		RunnablePostTest.class, Vector2dTest.class, SuperKoalio.class, NinePatchTest.class, Basic3DSceneTest.class, Animation3DTest.class,
-		ModelTest.class, Basic3DTest.class, ShaderTest.class, SkeletonTest.class, HexagonalTiledMapTest.class, FogTest.class, TimerTest.class, Bresenham2Test.class));
-	
+		));
+
 	public static List<String> getNames () {
 		List<String> names = new ArrayList<String>(tests.size());
 		for (Class clazz : tests)
@@ -98,11 +239,9 @@ public class GdxTests {
 		return names;
 	}
 
-	private static Class<? extends GdxTest> forName (String name)
-	{
+	private static Class<? extends GdxTest> forName (String name) {
 		for (Class clazz : tests)
-			if (clazz.getSimpleName().equals(name))
-				return clazz;
+			if (clazz.getSimpleName().equals(name)) return clazz;
 		return null;
 	}
 
