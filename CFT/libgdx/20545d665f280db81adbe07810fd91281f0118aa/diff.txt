diff --git a/CHANGES b/CHANGES
index 33beeaf..d6970c0 100644
--- a/CHANGES
+++ b/CHANGES
@@ -7,8 +7,6 @@
 - added userObject to Actor in scene2d, allowing for custom data storage
 - altered Android's hide status bar behavior
 - changed the way wakelocks are implemented. You no longer need any special permissions for the libgdx wakelock
-- BitmapFontCache setColor changes to match SpriteBatch and friends. http://www.badlogicgames.com/forum/viewtopic.php?f=23&t=12112
-
 [0.9.9]
 - added setCursorImage method to Input interface to support custom mouse cursors on the desktop
 - removed Xamarin backend, see http://www.badlogicgames.com/wordpress/?p=3213
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
deleted file mode 100644
index 5716215..0000000
--- a/CONTRIBUTING.md
+++ /dev/null
@@ -1,59 +0,0 @@
-Contributing to libgdx is easy:
-
-  * Fork libgdx on http://github.com/libgdx/libgdx
-  * Learn how to [[Work with the source | Running Demos & Tests]]
-  * Hack away and sent a pull request on Github!
-
-### API Changes & Additions
-If you modify a public API, or add a new one, make sure to add these changes to the [CHANGES](https://github.com/libgdx/libgdx/blob/master/CHANGES) file in the root of the repository. In addition to the CHANGES file, such modifications are also published on the [blog](http://www.badlogicgames.com) and on [Twitter](http://www.twitter.com/badlogicgames) to reach all of the community.
-
-If you want to poll the brains of other devs, either send a pull request and start a conversation on Github, or start a new thread in [this sub-forum](http://www.badlogicgames.com/forum/viewforum.php?f=23). You will need special forum permissions, write an e-mail to contact at badlogicgames dot com and tell me your forum id. You should also subscribe to that forum via e-mail, there's a button at the bottom of the page. You can also drop by on IRC (irc.freenode.org, #libgdx), where most core devs are lurking.
-
-### Contributor License Agreement
-Libgdx is licensed under the [Apache 2.0 license](http://en.wikipedia.org/wiki/Apache_License). Before we can accept code contributions, we need you to sign our [contributor license agreement](https://github.com/libgdx/libgdx/blob/master/CLA.txt). Just print it out, fill in the blanks and send a copy to contact@badlogicgames.com, with the subject `[Libgdx] CLA`.
-
-Signing the CLA will allow us to use and distribute your code. This is a non-exclusive license, so you retain all rights to your code. It's a fail-safe for us should someone contribute essential code and later decide to take it back.
-
-### Eclipse Formatter 
-If you work on libgdx code, we require you to use the [Eclipse formatter](https://github.com/libgdx/libgdx/blob/master/eclipse-formatter.xml) located in the root directory of the repository.
-
-Failure to use the formatter will result in Nate being very upset.
-
-### Code Style 
-Libgdx does not have an official coding standard. We mostly follow the usual [Java style](http://www.oracle.com/technetwork/java/codeconv-138413.html), and so should you.
-
-A few things we'd rather not like to see:
-
-  * underscores in any kind of identifier
-  * [Hungarian notation](http://en.wikipedia.org/wiki/Hungarian_notation)
-  * Prefixes for fields or arguments
-  * Curlies on new lines
-  * Conditional block bodies without curlies
-
-If you modify an existing file, follow the style of the code in there.
-
-If you create a new file, make sure to add the Apache file header, as seen [here](https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/Application.java).
-
-If you create a new class, please add at least class documentation that explains the usage and scope of he class. You can omit Javadoc for methods that are self-explanatory.
-
-If your class is explicitly thread-safe, mention it in the Javadoc. The default assumption is that classes are not thread-safe, to reduce the amount of costly locks in the code base.
-
-### Performance Considerations
-Libgdx is meant to run on both desktop and mobile platforms, including browsers (JavaScript!). While the desktop HotSpot VM can take quite a beating in terms of unnecessary allocations, Dalvik and consorts don't.
-
-A couple of guidelines:
-
-  * Avoid temporary object allocation wherever possible
-  * Do not make defensive copies
-  * Avoid locking, libgdx classes are by default not thread-safe unless explicitly specified
-  * Do not use boxed primitives
-  * Use the collection classes in the [com.badlogic.gdx.utils package](https://github.com/libgdx/libgdx/tree/master/gdx/src/com/badlogic/gdx/utils)
-  * Do not perform argument checks for methods that may be called thousands of times per frame
-  * Use pooling if necessary, if possible, avoid exposing the pooling to the user as it complicates the API
-
-### Git
-Most of the libdgx team members are Git novices, as such we are just learning the ropes ourself. To lower the risk of getting something wrong, we'd kindly ask you to keep your pull requests small if possible. A change-set of 3000 files is likely not to get merged.
-
-We do open new branches for bigger API changes. If you help out with a new API, make sure your pull request targets that specific branch.
-
-Pull requests for the master repository will be checked by multiple core contributors before inclusion. We may reject your pull requests to master if we do not deem them to be ready or fitting. Please don't take offense in that case. Libgdx is used by thousands of projects around the world, we need to make sure things stay somewhat sane and stable.
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwApplication.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwApplication.java
index 15d6142..b350da7 100644
--- a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwApplication.java
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwApplication.java
@@ -54,7 +54,6 @@ public class JglfwApplication implements Application {
 	private int logLevel = LOG_INFO;
 	volatile boolean running = true;
 	boolean isPaused;
-	protected String preferencesdir;
 
 	private boolean forceExit, runOnEDT;
 	private int foregroundFPS, backgroundFPS, hiddenFPS;
@@ -110,7 +109,6 @@ public class JglfwApplication implements Application {
 		foregroundFPS = config.foregroundFPS;
 		backgroundFPS = config.backgroundFPS;
 		hiddenFPS = config.hiddenFPS;
-		preferencesdir = config.preferencesLocation;
 
 		final Thread glThread = Thread.currentThread();
 
@@ -314,7 +312,7 @@ public class JglfwApplication implements Application {
 		if (preferences.containsKey(name))
 			return preferences.get(name);
 		else {
-			Preferences prefs = new JglfwPreferences(name, this.preferencesdir);
+			Preferences prefs = new JglfwPreferences(name);
 			preferences.put(name, prefs);
 			return prefs;
 		}
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwApplicationConfiguration.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwApplicationConfiguration.java
index bdb82de..3ff231d 100644
--- a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwApplicationConfiguration.java
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwApplicationConfiguration.java
@@ -71,9 +71,7 @@ public class JglfwApplicationConfiguration {
 	public int backgroundFPS;
 	/** Target framerate when the window is hidden or minimized. The CPU sleeps as needed. Use 0 to never sleep, -1 to not render. **/
 	public int hiddenFPS = -1;
-	/** Prefrences location on desktop. Default: current directory + ".prefs" */
-	public String preferencesLocation = ".prefs/";
-	
+
 	static public DisplayMode[] getDisplayModes () {
 		GraphicsDevice device = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice();
 		java.awt.DisplayMode desktopMode = device.getDisplayMode();
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwPreferences.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwPreferences.java
index 87468f9..7daf02f 100644
--- a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwPreferences.java
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwPreferences.java
@@ -37,8 +37,8 @@ public class JglfwPreferences implements Preferences {
 	private final Properties properties = new Properties();
 	private final FileHandle file;
 
-	public JglfwPreferences (String name, String directory) {
-		this(new JglfwFileHandle(new File(directory, name), FileType.External));
+	public JglfwPreferences (String name) {
+		this(new JglfwFileHandle(new File(".prefs/" + name), FileType.External));
 	}
 
 	public JglfwPreferences (FileHandle file) {
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglAWTCanvas.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglAWTCanvas.java
index b3f440d..09c6d41 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglAWTCanvas.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglAWTCanvas.java
@@ -317,7 +317,7 @@ public class LwjglAWTCanvas implements Application {
 		if (preferences.containsKey(name)) {
 			return preferences.get(name);
 		} else {
-			Preferences prefs = new LwjglPreferences(name, ".prefs/");
+			Preferences prefs = new LwjglPreferences(name);
 			preferences.put(name, prefs);
 			return prefs;
 		}
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplication.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplication.java
index f13249a..9b8d516 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplication.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplication.java
@@ -50,7 +50,6 @@ public class LwjglApplication implements Application {
 	protected final Array<Runnable> executedRunnables = new Array<Runnable>();
 	protected final Array<LifecycleListener> lifecycleListeners = new Array<LifecycleListener>();
 	protected int logLevel = LOG_INFO;
-	protected String preferencesdir;
 
 	public LwjglApplication (ApplicationListener listener, String title, int width, int height, boolean useGL2) {
 		this(listener, createConfig(title, width, height, useGL2));
@@ -85,8 +84,7 @@ public class LwjglApplication implements Application {
 		input = new LwjglInput();
 		net = new LwjglNet();
 		this.listener = listener;
-		this.preferencesdir = config.preferencesDirectory;
-		
+
 		Gdx.app = this;
 		Gdx.graphics = graphics;
 		Gdx.audio = audio;
@@ -306,7 +304,7 @@ public class LwjglApplication implements Application {
 		if (preferences.containsKey(name)) {
 			return preferences.get(name);
 		} else {
-			Preferences prefs = new LwjglPreferences(name, this.preferencesdir);
+			Preferences prefs = new LwjglPreferences(name);
 			preferences.put(name, prefs);
 			return prefs;
 		}
@@ -403,4 +401,4 @@ public class LwjglApplication implements Application {
 			lifecycleListeners.removeValue(listener, true);
 		}
 	}
-}
+}
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplicationConfiguration.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplicationConfiguration.java
index fdd2055..9c64d3f 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplicationConfiguration.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplicationConfiguration.java
@@ -68,8 +68,6 @@ public class LwjglApplicationConfiguration {
 	/** Allows software OpenGL rendering if hardware acceleration was not available.
 	 * @see LwjglGraphics#isSoftwareMode() */
 	public boolean allowSoftwareMode = false;
-	/** Preferences directory on the desktop. Default is ".prefs/". */
-	public String preferencesDirectory = ".prefs/";
 
 	Array<String> iconPaths = new Array();
 	Array<FileType> iconFileTypes = new Array();
@@ -145,4 +143,4 @@ public class LwjglApplicationConfiguration {
 
 		return modes.toArray(new DisplayMode[modes.size()]);
 	}
-}
+}
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglCanvas.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglCanvas.java
index 2c8fb23f..270c244 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglCanvas.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglCanvas.java
@@ -316,7 +316,7 @@ public class LwjglCanvas implements Application {
 		if (preferences.containsKey(name)) {
 			return preferences.get(name);
 		} else {
-			Preferences prefs = new LwjglPreferences(name, ".prefs/");
+			Preferences prefs = new LwjglPreferences(name);
 			preferences.put(name, prefs);
 			return prefs;
 		}
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglHeadlessApplication.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglHeadlessApplication.java
index 7c90913..b03fee2 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglHeadlessApplication.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglHeadlessApplication.java
@@ -30,8 +30,6 @@ import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.Clipboard;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 import com.badlogic.gdx.utils.ObjectMap;
-import com.badlogic.gdx.utils.TimeUtils;
-
 import org.lwjgl.LWJGLException;
 import org.lwjgl.opengl.Display;
 
@@ -47,16 +45,8 @@ public class LwjglHeadlessApplication implements Application {
 	protected final Array<Runnable> executedRunnables = new Array<Runnable>();
 	protected final Array<LifecycleListener> lifecycleListeners = new Array<LifecycleListener>();
 	protected int logLevel = LOG_INFO;
-	private final long renderInterval;
 
 	public LwjglHeadlessApplication(ApplicationListener listener) {
-		this(listener, null);
-	}
-	
-	public LwjglHeadlessApplication(ApplicationListener listener, LwjglHeadlessApplicationConfiguration config) {
-		if (config == null)
-			config = new LwjglHeadlessApplicationConfiguration();
-		
 		LwjglNativesLoader.load();
 		this.listener = listener;
 		this.files = new LwjglFiles();
@@ -65,9 +55,6 @@ public class LwjglHeadlessApplication implements Application {
 		Gdx.app = this;
 		Gdx.files = files;
 		Gdx.net = net;
-		
-		renderInterval = config.renderInterval > 0 ? (long)(config.renderInterval * 1000000000f) : (config.renderInterval < 0 ? -1 : 0);
-		
 		initialize();
 	}
 
@@ -97,24 +84,12 @@ public class LwjglHeadlessApplication implements Application {
 
 		// unlike LwjglApplication, a headless application will eat up CPU in this while loop
 		// it is up to the implementation to call Thread.sleep as necessary
-		long t = TimeUtils.nanoTime() + renderInterval;
-		if (renderInterval >= 0f) {
-			while (running) {
-				final long n = TimeUtils.nanoTime();
-				if (t > n) {
-					try {
-						Thread.sleep((t - n) / 1000000);
-					} catch (InterruptedException e) {}
-					t = TimeUtils.nanoTime() + renderInterval;
-				} else
-					t = n + renderInterval;
-				
-				executeRunnables();
-				listener.render();
-	
-				// If one of the runnables set running to false, for example after an exit().
-				if (!running) break;
-			}
+		while (running) {
+			executeRunnables();
+			listener.render();
+
+			// If one of the runnables set running to false, for example after an exit().
+			if (!running) break;
 		}
 
 		synchronized (lifecycleListeners) {
@@ -199,7 +174,7 @@ public class LwjglHeadlessApplication implements Application {
 		if (preferences.containsKey(name)) {
 			return preferences.get(name);
 		} else {
-			Preferences prefs = new LwjglPreferences(name, ".prefs/");
+			Preferences prefs = new LwjglPreferences(name);
 			preferences.put(name, prefs);
 			return prefs;
 		}
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglHeadlessApplicationConfiguration.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglHeadlessApplicationConfiguration.java
deleted file mode 100644
index 1d078a1..0000000
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglHeadlessApplicationConfiguration.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package com.badlogic.gdx.backends.lwjgl;
-
-public class LwjglHeadlessApplicationConfiguration {
-	/** The minimum time (in seconds) between each call to the render method or negative to not call the render method at all. */
-	public float renderInterval = 1f / 60f;
-}
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglPreferences.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglPreferences.java
index 52724e4..306115b 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglPreferences.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglPreferences.java
@@ -37,8 +37,8 @@ public class LwjglPreferences implements Preferences {
 	private final Properties properties = new Properties();
 	private final FileHandle file;
 
-	public LwjglPreferences (String name, String directory) {
-		this(new LwjglFileHandle(new File(directory, name), FileType.External));
+	public LwjglPreferences (String name) {
+		this(new LwjglFileHandle(new File(".prefs/" + name), FileType.External));
 	}
 
 	public LwjglPreferences (FileHandle file) {
@@ -184,4 +184,4 @@ public class LwjglPreferences implements Preferences {
 	public void remove (String key) {
 		properties.remove(key);
 	}
-}
\ No newline at end of file
+}
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSGraphics.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSGraphics.java
index 0ee60bd..c7aac58 100644
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSGraphics.java
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSGraphics.java
@@ -12,473 +12,478 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.backends.iosrobovm;
-
-import org.robovm.cocoatouch.coregraphics.CGPoint;
-import org.robovm.cocoatouch.coregraphics.CGRect;
-import org.robovm.cocoatouch.coregraphics.CGSize;
-import org.robovm.cocoatouch.foundation.NSObject;
-import org.robovm.cocoatouch.foundation.NSSet;
-import org.robovm.cocoatouch.glkit.GLKView;
-import org.robovm.cocoatouch.glkit.GLKViewController;
-import org.robovm.cocoatouch.glkit.GLKViewControllerDelegate;
-import org.robovm.cocoatouch.glkit.GLKViewDelegate;
-import org.robovm.cocoatouch.glkit.GLKViewDrawableColorFormat;
-import org.robovm.cocoatouch.glkit.GLKViewDrawableDepthFormat;
-import org.robovm.cocoatouch.glkit.GLKViewDrawableMultisample;
-import org.robovm.cocoatouch.glkit.GLKViewDrawableStencilFormat;
-import org.robovm.cocoatouch.opengles.EAGLContext;
-import org.robovm.cocoatouch.opengles.EAGLRenderingAPI;
-import org.robovm.cocoatouch.uikit.UIDevice;
-import org.robovm.cocoatouch.uikit.UIEvent;
-import org.robovm.cocoatouch.uikit.UIInterfaceOrientation;
-import org.robovm.cocoatouch.uikit.UIScreen;
-import org.robovm.cocoatouch.uikit.UIUserInterfaceIdiom;
-import org.robovm.objc.Selector;
-import org.robovm.objc.annotation.BindSelector;
-import org.robovm.rt.bro.annotation.Callback;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.Graphics;
-import com.badlogic.gdx.LifecycleListener;
-import com.badlogic.gdx.graphics.GL10;
-import com.badlogic.gdx.graphics.GL11;
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.GLCommon;
-import com.badlogic.gdx.utils.Array;
-
-// FIXME add GL 1.x support by ripping Android's classes
-public class IOSGraphics extends NSObject implements Graphics, GLKViewDelegate, GLKViewControllerDelegate {
-
-	private static final String tag = "IOSGraphics";
-
-	static class IOSUIViewController extends GLKViewController {
-		final IOSApplication app;
-		final IOSGraphics graphics;
-		boolean created = false;
-
-		IOSUIViewController (IOSApplication app, IOSGraphics graphics) {
-			this.app = app;
-			this.graphics = graphics;
-		}
-
-		@Override
-		public void didRotate (UIInterfaceOrientation orientation) {
-			super.didRotate(orientation);
-			// get the view size and update graphics
-			// FIXME: supporting BOTH (landscape+portrait at same time) is
-			// currently not working correctly (needs fix)
-			// FIXME screen orientation needs to be stored for
-			// Input#getNativeOrientation
-			CGSize bounds = app.getBounds(this);
-			graphics.width = (int)bounds.width();
-			graphics.height = (int)bounds.height();
-			graphics.makeCurrent();
-			app.listener.resize(graphics.width, graphics.height);
-		}
-
-		public boolean shouldAutorotateToInterfaceOrientation (UIInterfaceOrientation orientation) {
-			// we return "true" if we support the orientation
-			switch (orientation) {
-			case LandscapeLeft:
-			case LandscapeRight:
-				return app.config.orientationLandscape;
-			default:
-				// assume portrait
-				return app.config.orientationPortrait;
-			}
-		}
-
-		@Callback
-		@BindSelector("shouldAutorotateToInterfaceOrientation:")
-		private static boolean shouldAutorotateToInterfaceOrientation (IOSUIViewController self, Selector sel,
-			UIInterfaceOrientation orientation) {
-			return self.shouldAutorotateToInterfaceOrientation(orientation);
-		}
-	}
-
-	static class IOSUIView extends GLKView {
-
-		public IOSUIView (CGRect frame, EAGLContext context) {
-			super(frame, context);
-		}
-	}
-
-	IOSApplication app;
-	IOSInput input;
-	GL20 gl20;
-	int width;
-	int height;
-	long lastFrameTime;
-	float deltaTime;
-	long framesStart;
-	int frames;
-	int fps;
-	BufferFormat bufferFormat;
-	String extensions;
-
-	private float ppiX = 0;
-	private float ppiY = 0;
-	private float ppcX = 0;
-	private float ppcY = 0;
-	private float density = 1;
-
-	volatile boolean paused;
-
-	IOSApplicationConfiguration config;
-	EAGLContext context;
-	GLKView view;
-	IOSUIViewController viewController;
-
-	public IOSGraphics (CGSize bounds, IOSApplication app, IOSApplicationConfiguration config, IOSInput input, GL20 gl20) {
-		this.config = config;
-		// setup view and OpenGL
-		width = (int)bounds.width();
-		height = (int)bounds.height();
-		app.debug(tag, bounds.width() + "x" + bounds.height() + ", " + UIScreen.getMainScreen().getScale());
-		this.gl20 = gl20;
-
-		context = new EAGLContext(EAGLRenderingAPI.OpenGLES2);
-
-		view = new GLKView(new CGRect(new CGPoint(0, 0), bounds), context) {
-			@Override
-			public void touchesBegan (NSSet touches, UIEvent event) {
-				super.touchesBegan(touches, event);
-				IOSGraphics.this.input.touchDown(touches, event);
-			}
-
-			@Override
-			public void touchesCancelled (NSSet touches, UIEvent event) {
-				super.touchesCancelled(touches, event);
-				IOSGraphics.this.input.touchUp(touches, event);
-			}
-
-			@Override
-			public void touchesEnded (NSSet touches, UIEvent event) {
-				super.touchesEnded(touches, event);
-				IOSGraphics.this.input.touchUp(touches, event);
-			}
-
-			@Override
-			public void touchesMoved (NSSet touches, UIEvent event) {
-				super.touchesMoved(touches, event);
-				IOSGraphics.this.input.touchMoved(touches, event);
-			}
-
-			@Override
-			public void draw (CGRect rect) {
-				IOSGraphics.this.draw(this, rect);
-			}
-
-		};
-		view.setDelegate(this);
-		view.setDrawableColorFormat(config.colorFormat);
-		view.setDrawableDepthFormat(config.depthFormat);
-		view.setDrawableStencilFormat(config.stencilFormat);
-		view.setDrawableMultisample(config.multisample);
-		view.setMultipleTouchEnabled(true);
-
-		viewController = new IOSUIViewController(app, this);
-		viewController.setView(view);
-		viewController.setDelegate(this);
-		viewController.setPreferredFramesPerSecond(config.preferredFramesPerSecond);
-
-		this.app = app;
-		this.input = input;
-
-		// FIXME fix this if we add rgba/depth/stencil flags to
-		// IOSApplicationConfiguration
-		int r = 0, g = 0, b = 0, a = 0, depth = 0, stencil = 0, samples = 0;
-		if (config.colorFormat == GLKViewDrawableColorFormat.RGB565) {
-			r = 5;
-			g = 6;
-			b = 5;
-			a = 0;
-		} else {
-			r = g = b = a = 8;
-		}
-		if (config.depthFormat == GLKViewDrawableDepthFormat.Format16) {
-			depth = 16;
-		} else if (config.depthFormat == GLKViewDrawableDepthFormat.Format24) {
-			depth = 24;
-		} else {
-			depth = 0;
-		}
-		if (config.stencilFormat == GLKViewDrawableStencilFormat.Format8) {
-			stencil = 8;
-		}
-		if (config.multisample == GLKViewDrawableMultisample.Sample4X) {
-			samples = 4;
-		}
-		bufferFormat = new BufferFormat(r, g, b, a, depth, stencil, samples, false);
-		this.gl20 = gl20;
-
-		// determine display density and PPI (PPI values via Wikipedia!)
-		density = 1f;
-
-		// if ((UIScreen.getMainScreen().respondsToSelector(new
-		// Selector("scale")))) {
-		float scale = UIScreen.getMainScreen().getScale();
-		app.debug(tag, "Calculating density, UIScreen.mainScreen.scale: " + scale);
-		if (scale == 2f) density = 2f;
-
-		int ppi;
-		if (UIDevice.getCurrentDevice().getUserInterfaceIdiom() == UIUserInterfaceIdiom.Pad) {
-			// iPad
-			ppi = Math.round(density * 132);
-		} else {
-			// iPhone or iPodTouch
-			ppi = Math.round(density * 163);
-		}
-		ppiX = ppi;
-		ppiY = ppi;
-		ppcX = ppiX / 2.54f;
-		ppcY = ppiY / 2.54f;
-		app.debug(tag, "Display: ppi=" + ppi + ", density=" + density);
-
-		// time + FPS
-		lastFrameTime = System.nanoTime();
-		framesStart = lastFrameTime;
-
-		paused = false;
-	}
-
-	public void resume () {
-		if (!paused) return;
-		paused = false;
-
-		Array<LifecycleListener> listeners = app.lifecycleListeners;
-		synchronized (listeners) {
-			for (LifecycleListener listener : listeners) {
-				listener.resume();
-			}
-		}
-		app.listener.resume();
-	}
-
-	public void pause () {
-		if (paused) return;
-		paused = true;
-		
-		Array<LifecycleListener> listeners = app.lifecycleListeners;
-		synchronized (listeners) {
-			for (LifecycleListener listener : listeners) {
-				listener.pause();
-			}
-		}
-		app.listener.pause();
-	}
-
-	boolean created = false;
-
-	@Override
-	public void draw (GLKView view, CGRect rect) {
-		if (!created) {
-			app.graphics.makeCurrent();
-			app.listener.create();
-			app.listener.resize(width, height);
-			created = true;
-		}
-		if (paused) {
-			return;
-		}
-
-		long time = System.nanoTime();
-		deltaTime = (time - lastFrameTime) / 1000000000.0f;
-		lastFrameTime = time;
-
-		frames++;
-		if (time - framesStart >= 1000000000l) {
-			framesStart = time;
-			fps = frames;
-			frames = 0;
-		}
-
-		makeCurrent();
-		input.processEvents();
-		app.listener.render();
-	}
-
-	void makeCurrent () {
-		EAGLContext.setCurrentContext(context);
-	}
-
-	@Override
-	public void update (GLKViewController controller) {
-		makeCurrent();
-		app.processRunnables();
-	}
-
-	@Override
-	public void willPause (GLKViewController controller, boolean pause) {
-		if (pause) {
-			if (paused) return;
-			pause();
-		} else {
-			if (!paused) return;
-			resume();
-		}
-	}
-
-	@Override
-	public boolean isGL11Available () {
-		return false;
-	}
-
-	@Override
-	public boolean isGL20Available () {
-		return true;
-	}
-
-	@Override
-	public GLCommon getGLCommon () {
-		return gl20;
-	}
-
-	@Override
-	public GL10 getGL10 () {
-		return null;
-	}
-
-	@Override
-	public GL11 getGL11 () {
-		return null;
-	}
-
-	@Override
-	public GL20 getGL20 () {
-		return gl20;
-	}
-
-	@Override
-	public int getWidth () {
-		return width;
-	}
-
-	@Override
-	public int getHeight () {
-		return height;
-	}
-
-	@Override
-	public float getDeltaTime () {
-		return deltaTime;
-	}
-
-	@Override
-	public float getRawDeltaTime () {
-		return deltaTime;
-	}
-
-	@Override
-	public int getFramesPerSecond () {
-		return fps;
-	}
-
-	@Override
-	public GraphicsType getType () {
-		return GraphicsType.iOSGL;
-	}
-
-	@Override
-	public float getPpiX () {
-		return ppiX;
-	}
-
-	@Override
-	public float getPpiY () {
-		return ppiY;
-	}
-
-	@Override
-	public float getPpcX () {
-		return ppcX;
-	}
-
-	@Override
-	public float getPpcY () {
-		return ppcY;
-	}
-
-	/** Returns the display density.
-	 * 
-	 * @return 1.0f for non-retina devices, 2.0f for retina devices. */
-	@Override
-	public float getDensity () {
-		return density;
-	}
-
-	@Override
-	public boolean supportsDisplayModeChange () {
-		return false;
-	}
-
-	@Override
-	public DisplayMode[] getDisplayModes () {
-		return new DisplayMode[] {getDesktopDisplayMode()};
-	}
-
-	@Override
-	public DisplayMode getDesktopDisplayMode () {
-		return new IOSDisplayMode(getWidth(), getHeight(), config.preferredFramesPerSecond, bufferFormat.r + bufferFormat.g
-			+ bufferFormat.b + bufferFormat.a);
-	}
-
-	private class IOSDisplayMode extends DisplayMode {
-		protected IOSDisplayMode (int width, int height, int refreshRate, int bitsPerPixel) {
-			super(width, height, refreshRate, bitsPerPixel);
-		}
-	}
-
-	@Override
-	public boolean setDisplayMode (DisplayMode displayMode) {
-		return false;
-	}
-
-	@Override
-	public boolean setDisplayMode (int width, int height, boolean fullscreen) {
-		return false;
-	}
-
-	@Override
-	public void setTitle (String title) {
-	}
-
-	@Override
-	public void setVSync (boolean vsync) {
-	}
-
-	@Override
-	public BufferFormat getBufferFormat () {
-		return bufferFormat;
-	}
-
-	@Override
-	public boolean supportsExtension (String extension) {
-		if (extensions == null) extensions = Gdx.gl.glGetString(GL10.GL_EXTENSIONS);
-		return extensions.contains(extension);
-	}
-
-	@Override
-	public void setContinuousRendering (boolean isContinuous) {
-		// FIXME implement this if possible
-	}
-
-	@Override
-	public boolean isContinuousRendering () {
-		// FIXME implement this if possible
-		return true;
-	}
-
-	@Override
-	public void requestRendering () {
-		// FIXME implement this if possible
-	}
-
-	@Override
-	public boolean isFullscreen () {
-		return true;
-	}
-}
+ ******************************************************************************/
+
+package com.badlogic.gdx.backends.iosrobovm;
+
+import org.robovm.cocoatouch.coregraphics.CGPoint;
+import org.robovm.cocoatouch.coregraphics.CGRect;
+import org.robovm.cocoatouch.coregraphics.CGSize;
+import org.robovm.cocoatouch.foundation.NSObject;
+import org.robovm.cocoatouch.foundation.NSSet;
+import org.robovm.cocoatouch.glkit.GLKView;
+import org.robovm.cocoatouch.glkit.GLKViewController;
+import org.robovm.cocoatouch.glkit.GLKViewControllerDelegate;
+import org.robovm.cocoatouch.glkit.GLKViewDelegate;
+import org.robovm.cocoatouch.glkit.GLKViewDrawableColorFormat;
+import org.robovm.cocoatouch.glkit.GLKViewDrawableDepthFormat;
+import org.robovm.cocoatouch.glkit.GLKViewDrawableMultisample;
+import org.robovm.cocoatouch.glkit.GLKViewDrawableStencilFormat;
+import org.robovm.cocoatouch.opengles.EAGLContext;
+import org.robovm.cocoatouch.opengles.EAGLRenderingAPI;
+import org.robovm.cocoatouch.uikit.UIDevice;
+import org.robovm.cocoatouch.uikit.UIEvent;
+import org.robovm.cocoatouch.uikit.UIInterfaceOrientation;
+import org.robovm.cocoatouch.uikit.UIScreen;
+import org.robovm.cocoatouch.uikit.UIUserInterfaceIdiom;
+import org.robovm.objc.Selector;
+import org.robovm.objc.annotation.BindSelector;
+import org.robovm.rt.bro.annotation.Callback;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.Graphics;
+import com.badlogic.gdx.LifecycleListener;
+import com.badlogic.gdx.graphics.GL10;
+import com.badlogic.gdx.graphics.GL11;
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.gdx.graphics.GLCommon;
+import com.badlogic.gdx.utils.Array;
+
+// FIXME add GL 1.x support by ripping Android's classes
+public class IOSGraphics extends NSObject implements Graphics, GLKViewDelegate,
+		GLKViewControllerDelegate {
+
+	private static final String tag = "IOSGraphics";
+
+	static class IOSUIViewController extends GLKViewController {
+		final IOSApplication app;
+		final IOSGraphics graphics;
+		boolean created = false;
+
+		IOSUIViewController(IOSApplication app, IOSGraphics graphics) {
+			this.app = app;
+			this.graphics = graphics;
+		}
+
+		@Override
+		public void didRotate(UIInterfaceOrientation orientation) {
+			super.didRotate(orientation);
+			// get the view size and update graphics
+			// FIXME: supporting BOTH (landscape+portrait at same time) is
+			// currently not working correctly (needs fix)
+			// FIXME screen orientation needs to be stored for
+			// Input#getNativeOrientation
+			CGSize bounds = app.getBounds(this);
+			graphics.width = (int) bounds.width();
+			graphics.height = (int) bounds.height();
+			graphics.makeCurrent();
+			app.listener.resize(graphics.width, graphics.height);
+		}
+
+		public boolean shouldAutorotateToInterfaceOrientation(
+				UIInterfaceOrientation orientation) {
+			// we return "true" if we support the orientation
+			switch (orientation) {
+			case LandscapeLeft:
+			case LandscapeRight:
+				return app.config.orientationLandscape;
+			default:
+				// assume portrait
+				return app.config.orientationPortrait;
+			}
+		}
+
+		@Callback
+		@BindSelector("shouldAutorotateToInterfaceOrientation:")
+		private static boolean shouldAutorotateToInterfaceOrientation(
+				IOSUIViewController self, Selector sel,
+				UIInterfaceOrientation orientation) {
+			return self.shouldAutorotateToInterfaceOrientation(orientation);
+		}
+	}
+
+	static class IOSUIView extends GLKView {
+
+		public IOSUIView(CGRect frame, EAGLContext context) {
+			super(frame, context);
+		}
+	}
+
+	IOSApplication app;
+	IOSInput input;
+	GL20 gl20;
+	int width;
+	int height;
+	long lastFrameTime;
+	float deltaTime;
+	long framesStart;
+	int frames;
+	int fps;
+	BufferFormat bufferFormat;
+	String extensions;
+
+	private float ppiX = 0;
+	private float ppiY = 0;
+	private float ppcX = 0;
+	private float ppcY = 0;
+	private float density = 1;
+
+	volatile boolean paused;
+	boolean wasPaused;
+
+	IOSApplicationConfiguration config;
+	EAGLContext context;
+	GLKView view;
+	IOSUIViewController viewController;
+
+	public IOSGraphics(CGSize bounds, IOSApplication app, IOSApplicationConfiguration config, IOSInput input, GL20 gl20) {
+		this.config = config;
+		// setup view and OpenGL
+		width = (int) bounds.width();
+		height = (int) bounds.height();
+		app.debug(tag, bounds.width() + "x" + bounds.height() + ", " + UIScreen.getMainScreen().getScale());
+		this.gl20 = gl20;
+
+		context = new EAGLContext(EAGLRenderingAPI.OpenGLES2);
+
+		view = new GLKView(new CGRect(new CGPoint(0, 0), bounds), context) {
+			@Override
+			public void touchesBegan(NSSet touches, UIEvent event) {
+				super.touchesBegan(touches, event);
+				IOSGraphics.this.input.touchDown(touches, event);
+			}
+
+			@Override
+			public void touchesCancelled(NSSet touches, UIEvent event) {
+				super.touchesCancelled(touches, event);
+				IOSGraphics.this.input.touchUp(touches, event);
+			}
+
+			@Override
+			public void touchesEnded(NSSet touches, UIEvent event) {
+				super.touchesEnded(touches, event);
+				IOSGraphics.this.input.touchUp(touches, event);
+			}
+
+			@Override
+			public void touchesMoved(NSSet touches, UIEvent event) {
+				super.touchesMoved(touches, event);
+				IOSGraphics.this.input.touchMoved(touches, event);
+			}
+
+			@Override
+			public void draw(CGRect rect) {
+				IOSGraphics.this.draw(this, rect);
+			}
+
+		};
+		view.setDelegate(this);
+		view.setDrawableColorFormat(config.colorFormat);
+		view.setDrawableDepthFormat(config.depthFormat);
+		view.setDrawableStencilFormat(config.stencilFormat);
+		view.setDrawableMultisample(config.multisample);
+		view.setMultipleTouchEnabled(true);
+
+		viewController = new IOSUIViewController(app, this);
+		viewController.setView(view);
+		viewController.setDelegate(this);
+		viewController.setPreferredFramesPerSecond(config.preferredFramesPerSecond);
+
+		this.app = app;
+		this.input = input;
+
+		// FIXME fix this if we add rgba/depth/stencil flags to
+		// IOSApplicationConfiguration
+		int r = 0, g = 0, b = 0, a = 0, depth = 0, stencil = 0, samples = 0;
+		if(config.colorFormat == GLKViewDrawableColorFormat.RGB565) {
+			r = 5; g = 6; b = 5; a = 0;
+		} else {
+			r = g = b = a = 8;
+		}
+		if(config.depthFormat == GLKViewDrawableDepthFormat.Format16) {
+			depth = 16;
+		} else if (config.depthFormat == GLKViewDrawableDepthFormat.Format24) {
+			depth = 24;
+		} else {
+			depth = 0;
+		}
+		if(config.stencilFormat == GLKViewDrawableStencilFormat.Format8) {
+			stencil = 8;
+		}
+		if(config.multisample == GLKViewDrawableMultisample.Sample4X) {
+			samples = 4;
+		}
+		bufferFormat = new BufferFormat(r, g, b, a, depth, stencil, samples, false);
+		this.gl20 = gl20;
+
+		// determine display density and PPI (PPI values via Wikipedia!)
+		density = 1f;
+
+		// if ((UIScreen.getMainScreen().respondsToSelector(new
+		// Selector("scale")))) {
+		float scale = UIScreen.getMainScreen().getScale();
+		app.debug(tag, "Calculating density, UIScreen.mainScreen.scale: " + scale);
+		if (scale == 2f) density = 2f;
+
+		int ppi;
+		if (UIDevice.getCurrentDevice().getUserInterfaceIdiom() == UIUserInterfaceIdiom.Pad) {
+			// iPad
+			ppi = Math.round(density * 132);
+		} else {
+			// iPhone or iPodTouch
+			ppi = Math.round(density * 163);
+		}
+		ppiX = ppi;
+		ppiY = ppi;
+		ppcX = ppiX / 2.54f;
+		ppcY = ppiY / 2.54f;
+		app.debug(tag, "Display: ppi=" + ppi + ", density=" + density);
+
+		// time + FPS
+		lastFrameTime = System.nanoTime();
+		framesStart = lastFrameTime;
+
+		paused = false;
+		wasPaused = true;
+	}
+
+	public void resume() {
+		paused = false;
+	}
+
+	public void pause() {
+		paused = true;
+	}
+
+	boolean created = false;
+	@Override
+	public void draw(GLKView view, CGRect rect) {
+		if(!created) {
+			app.graphics.makeCurrent();
+			app.listener.create();
+			app.listener.resize(width, height);
+			created = true;
+		}
+		if (paused) {
+			if (!wasPaused) {
+				Array<LifecycleListener> listeners = app.lifecycleListeners;
+				synchronized (listeners) {
+					for (LifecycleListener listener : listeners) {
+						listener.pause();
+					}
+				}
+				app.listener.pause();
+				wasPaused = true;
+			}
+			return;
+		} else {
+			if (wasPaused) {
+				Array<LifecycleListener> listeners = app.lifecycleListeners;
+				synchronized (listeners) {
+					for (LifecycleListener listener : listeners) {
+						listener.resume();
+					}
+				}
+				app.listener.resume();
+				wasPaused = false;
+			}
+		}
+
+		long time = System.nanoTime();
+		deltaTime = (time - lastFrameTime) / 1000000000.0f;
+		lastFrameTime = time;
+
+		frames++;
+		if (time - framesStart >= 1000000000l) {
+			framesStart = time;
+			fps = frames;
+			frames = 0;
+		}
+
+		makeCurrent();
+		input.processEvents();
+		app.listener.render();
+	}
+
+	void makeCurrent() {
+		EAGLContext.setCurrentContext(context);
+	}
+
+	@Override
+	public void update(GLKViewController controller) {
+		makeCurrent();
+		app.processRunnables();
+	}
+
+	@Override
+	public void willPause(GLKViewController controller, boolean pause) {
+		if (pause) {
+			pause();
+		} else {
+			resume();
+		}
+	}
+
+	@Override
+	public boolean isGL11Available() {
+		return false;
+	}
+
+	@Override
+	public boolean isGL20Available() {
+		return true;
+	}
+
+	@Override
+	public GLCommon getGLCommon() {
+		return gl20;
+	}
+
+	@Override
+	public GL10 getGL10() {
+		return null;
+	}
+
+	@Override
+	public GL11 getGL11() {
+		return null;
+	}
+
+	@Override
+	public GL20 getGL20() {
+		return gl20;
+	}
+
+	@Override
+	public int getWidth() {
+		return width;
+	}
+
+	@Override
+	public int getHeight() {
+		return height;
+	}
+
+	@Override
+	public float getDeltaTime() {
+		return deltaTime;
+	}
+
+	@Override
+	public float getRawDeltaTime() {
+		return deltaTime;
+	}
+
+	@Override
+	public int getFramesPerSecond() {
+		return fps;
+	}
+
+	@Override
+	public GraphicsType getType() {
+		return GraphicsType.iOSGL;
+	}
+
+	@Override
+	public float getPpiX() {
+		return ppiX;
+	}
+
+	@Override
+	public float getPpiY() {
+		return ppiY;
+	}
+
+	@Override
+	public float getPpcX() {
+		return ppcX;
+	}
+
+	@Override
+	public float getPpcY() {
+		return ppcY;
+	}
+
+	/**
+	 * Returns the display density.
+	 * 
+	 * @return 1.0f for non-retina devices, 2.0f for retina devices.
+	 */
+	@Override
+	public float getDensity() {
+		return density;
+	}
+
+	@Override
+	public boolean supportsDisplayModeChange() {
+		return false;
+	}
+
+	@Override
+	public DisplayMode[] getDisplayModes() {
+		return new DisplayMode[] { getDesktopDisplayMode() };
+	}
+
+	@Override
+	public DisplayMode getDesktopDisplayMode() {
+		return new IOSDisplayMode(getWidth(), getHeight(), config.preferredFramesPerSecond, bufferFormat.r + bufferFormat.g + bufferFormat.b + bufferFormat.a);
+	}
+
+	private class IOSDisplayMode extends DisplayMode {
+		protected IOSDisplayMode(int width, int height, int refreshRate,
+				int bitsPerPixel) {
+			super(width, height, refreshRate, bitsPerPixel);
+		}
+	}
+
+	@Override
+	public boolean setDisplayMode(DisplayMode displayMode) {
+		return false;
+	}
+
+	@Override
+	public boolean setDisplayMode(int width, int height, boolean fullscreen) {
+		return false;
+	}
+
+	@Override
+	public void setTitle(String title) {
+	}
+
+	@Override
+	public void setVSync(boolean vsync) {
+	}
+
+	@Override
+	public BufferFormat getBufferFormat() {
+		return bufferFormat;
+	}
+
+	@Override
+	public boolean supportsExtension(String extension) {
+		if (extensions == null)
+			extensions = Gdx.gl.glGetString(GL10.GL_EXTENSIONS);
+		return extensions.contains(extension);
+	}
+
+	@Override
+	public void setContinuousRendering(boolean isContinuous) {
+		// FIXME implement this if possible
+	}
+
+	@Override
+	public boolean isContinuousRendering() {
+		// FIXME implement this if possible
+		return true;
+	}
+
+	@Override
+	public void requestRendering() {
+		// FIXME implement this if possible
+	}
+
+	@Override
+	public boolean isFullscreen() {
+		return true;
+	}
+}
\ No newline at end of file
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/BufferUtils.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/BufferUtils.java
index 00fe549..696fe50 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/BufferUtils.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/BufferUtils.java
@@ -45,7 +45,14 @@ public class BufferUtils {
 	 * @param numFloats the number of floats to copy
 	 * @param offset the offset in src to start copying from */
 	public static void copy (float[] src, Buffer dst, int numFloats, int offset) {
-		FloatBuffer floatBuffer = asFloatBuffer(dst);
+		FloatBuffer floatBuffer = null;
+		if (dst instanceof ByteBuffer) {
+			floatBuffer = ((ByteBuffer)dst).asFloatBuffer();
+		} else if (dst instanceof FloatBuffer) {
+			floatBuffer = (FloatBuffer)dst;
+		} else {
+			throw new GdxRuntimeException("dst must be a ByteBuffer or FloatBuffer");
+		}
 
 		floatBuffer.clear();
 		dst.position(0);
@@ -174,7 +181,11 @@ public class BufferUtils {
 	 * @param dst the destination Buffer, its position is used as an offset.
 	 * @param numElements the number of elements to copy. */
 	public static void copy (float[] src, int srcOffset, Buffer dst, int numElements) {
-		FloatBuffer buffer = asFloatBuffer(dst);
+		FloatBuffer buffer = null;
+		if (dst instanceof ByteBuffer)
+			buffer = ((ByteBuffer)dst).asFloatBuffer();
+		else if (dst instanceof FloatBuffer) buffer = (FloatBuffer)dst;
+		if (buffer == null) throw new GdxRuntimeException("dst must be a ByteBuffer or FloatBuffer");
 
 		int oldPosition = buffer.position();
 		buffer.put(src, srcOffset, numElements);
@@ -273,7 +284,12 @@ public class BufferUtils {
 	 * @param numElements the number of elements to copy.
 	 * @param dst the destination Buffer, its position is used as an offset. */
 	public static void copy (float[] src, int srcOffset, int numElements, Buffer dst) {
-		FloatBuffer buffer = asFloatBuffer(dst);
+		FloatBuffer buffer = null;
+		if (dst instanceof ByteBuffer)
+			buffer = ((ByteBuffer)dst).asFloatBuffer();
+		else if (dst instanceof FloatBuffer) buffer = (FloatBuffer)dst;
+		if (buffer == null) throw new GdxRuntimeException("dst must be a ByteBuffer or FloatBuffer");
+
 		int oldPosition = buffer.position();
 		buffer.put(src, srcOffset, numElements);
 		buffer.position(oldPosition);
@@ -314,23 +330,6 @@ public class BufferUtils {
 // dst.limit(dst.position() + bytesToElements(dst, numBytes));
 // }
 	
-	private final static FloatBuffer asFloatBuffer(final Buffer data) {
-		FloatBuffer buffer = null;
-		if (data instanceof ByteBuffer)
-			buffer = ((ByteBuffer)data).asFloatBuffer();
-		else if (data instanceof FloatBuffer) buffer = (FloatBuffer)data;
-		if (buffer == null) throw new GdxRuntimeException("data must be a ByteBuffer or FloatBuffer");
-		return buffer;
-	}
-	
-	private final static float[] asFloatArray(final FloatBuffer buffer) {
-		final int pos = buffer.position();
-		final float[] result = new float[buffer.remaining()];
-		buffer.get(result);
-		buffer.position(pos);
-		return result;
-	}
-	
 	/** Multiply float vector components within the buffer with the specified matrix. The {@link Buffer#position()} is used as
 	 * the offset.
 	 * @param data The buffer to transform.
@@ -339,10 +338,16 @@ public class BufferUtils {
 	 * @param count The number of vectors to transform
 	 * @param matrix The matrix to multiply the vector with */
 	public static void transform (Buffer data, int dimensions, int strideInBytes, int count, Matrix4 matrix) {
-		FloatBuffer buffer = asFloatBuffer(data);
-		final int pos = buffer.position();
-		int idx = pos;
-		float[] arr = asFloatArray(buffer);
+		FloatBuffer buffer = null;
+		if (data instanceof ByteBuffer)
+			buffer = ((ByteBuffer)data).asFloatBuffer();
+		else if (data instanceof FloatBuffer) buffer = (FloatBuffer)data;
+		if (buffer == null) throw new GdxRuntimeException("data must be a ByteBuffer or FloatBuffer");
+		// FIXME untested code:
+		int pos = buffer.position();
+		float[] arr = new float[buffer.remaining()];
+		buffer.get(arr);
+		int idx = buffer.position();
 		int stride = strideInBytes / 4;
 		float[] m = matrix.val;
 		for (int i = 0; i < count; i++) {
@@ -359,6 +364,7 @@ public class BufferUtils {
 					arr[idx+3] = x * m[ 3] + y * m[ 7] + z * m[11] + w * m[15];
 			}
 		}
+		buffer.position(pos);
 		buffer.put(arr);
 		buffer.position(pos);
 	}
@@ -371,11 +377,16 @@ public class BufferUtils {
 	 * @param count The number of vectors to transform
 	 * @param matrix The matrix to multiply the vector with */
 	public static void transform (Buffer data, int dimensions, int strideInBytes, int count, Matrix3 matrix) {
-		FloatBuffer buffer = asFloatBuffer(data);
+		FloatBuffer buffer = null;
+		if (data instanceof ByteBuffer)
+			buffer = ((ByteBuffer)data).asFloatBuffer();
+		else if (data instanceof FloatBuffer) buffer = (FloatBuffer)data;
+		if (buffer == null) throw new GdxRuntimeException("dst must be a ByteBuffer or FloatBuffer");
 		// FIXME untested code:
-		final int pos = buffer.position();
-		int idx = pos;
-		float[] arr = asFloatArray(buffer);
+		int pos = buffer.position();
+		float[] arr = new float[buffer.remaining()];
+		buffer.get(arr);
+		int idx = buffer.position();
 		int stride = strideInBytes / 4;
 		float[] m = matrix.val;
 		for (int i = 0; i < count; i++) {
@@ -388,62 +399,11 @@ public class BufferUtils {
 			if (dimensions >= 3)
 				arr[idx+2] = x * m[ 2] + y * m[ 5] + z * m[8];
 		}
+		buffer.position(pos);
 		buffer.put(arr);
 		buffer.position(pos);
 	}
 
-	public static long findFloats(Buffer vertex, int strideInBytes, Buffer vertices, int numVertices) {
-		return findFloats(asFloatArray(asFloatBuffer(vertex)), strideInBytes, asFloatArray(asFloatBuffer(vertices)), numVertices);
-	}
-
-	public static long findFloats(float[] vertex, int strideInBytes, Buffer vertices, int numVertices) {
-		return findFloats(vertex, strideInBytes, asFloatArray(asFloatBuffer(vertices)), numVertices);
-	}
-	
-	public static long findFloats(Buffer vertex, int strideInBytes, float[] vertices, int numVertices) {
-		return findFloats(asFloatArray(asFloatBuffer(vertex)), strideInBytes, vertices, numVertices);
-	}
-	
-	public static long findFloats(float[] vertex, int strideInBytes, float[] vertices, int numVertices) {
-		final int size = strideInBytes / 4;
-		for (int i = 0; i < numVertices; i++) {
-			final int offset = i * size;
-			boolean found = true;
-			for (int j = 0; !found && j < size; j++)
-				if (vertices[offset+j] != vertex[j])
-					found = false;
-			if (found)
-				return (long)i;
-		}
-		return -1;
-	}
-	
-	public static long findFloats(Buffer vertex, int strideInBytes, Buffer vertices, int numVertices, float epsilon) {
-		return findFloats(asFloatArray(asFloatBuffer(vertex)), strideInBytes, asFloatArray(asFloatBuffer(vertices)), numVertices, epsilon);
-	}
-
-	public static long findFloats(float[] vertex, int strideInBytes, Buffer vertices, int numVertices, float epsilon) {
-		return findFloats(vertex, strideInBytes, asFloatArray(asFloatBuffer(vertices)), numVertices, epsilon);
-	}
-	
-	public static long findFloats(Buffer vertex, int strideInBytes, float[] vertices, int numVertices, float epsilon) {
-		return findFloats(asFloatArray(asFloatBuffer(vertex)), strideInBytes, vertices, numVertices, epsilon);
-	}
-	
-	public static long findFloats(float[] vertex, int strideInBytes, float[] vertices, int numVertices, float epsilon) {
-		final int size = strideInBytes / 4;
-		for (int i = 0; i < numVertices; i++) {
-			final int offset = i * size;
-			boolean found = true;
-			for (int j = 0; !found && j < size; j++)
-				if ((vertices[offset+j] > vertex[j] ? vertices[offset+j] - vertex[j] : vertex[j] - vertices[offset+j]) > epsilon)
-					found = false;
-			if (found)
-				return (long)i;
-		}
-		return -1;
-	}
-	
 	public static FloatBuffer newFloatBuffer (int numFloats) {
 		if (GWT.isProdMode()) {
 			ByteBuffer buffer = ByteBuffer.allocateDirect(numFloats * 4);
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/async/AsyncExecutor.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/async/AsyncExecutor.java
index f41e975..447524b 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/async/AsyncExecutor.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/async/AsyncExecutor.java
@@ -12,38 +12,59 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.utils.async;
-
-import com.badlogic.gdx.utils.Disposable;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-
-/** GWT emulation of AsynchExecutor, will call tasks immediately :D
- * @author badlogic */
-public class AsyncExecutor implements Disposable {
-
-	/** Creates a new AsynchExecutor that allows maxConcurrent {@link Runnable} instances to run in parallel.
-	 * @param maxConcurrent */
-	public AsyncExecutor (int maxConcurrent) {
-	}
-
-	/** Submits a {@link Runnable} to be executed asynchronously. If maxConcurrent runnables are already running, the runnable will
-	 * be queued.
-	 * @param task the task to execute asynchronously */
-	public <T> AsyncResult<T> submit (final AsyncTask<T> task) {
-		T result = null;
-		try {
-			result = task.call();
-		} catch (Throwable t) {
-			throw new GdxRuntimeException("Could not submit AsyncTask: " + t.getMessage(), t);
-		}
-		return new AsyncResult(result);
-	}
-
-	/** Waits for running {@link AsyncTask} instances to finish, then destroys any resources like threads. Can not be used after
-	 * this method is called. */
-	@Override
-	public void dispose () {
-	}
-}
+ ******************************************************************************/
+
+package com.badlogic.gdx.utils.async;
+
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
+
+import com.badlogic.gdx.utils.Disposable;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+import com.badlogic.gdx.utils.async.AsyncResult;
+import com.badlogic.gdx.utils.async.AsyncTask;
+
+/**
+ * GWT emulation of AsynchExecutor, will call tasks immediately :D
+ * @author badlogic
+ *
+ */
+public class AsyncExecutor implements Disposable {
+	
+	/**
+	 * Creates a new AsynchExecutor that allows maxConcurrent
+	 * {@link Runnable} instances to run in parallel.
+	 * @param maxConcurrent
+	 */
+	public AsyncExecutor(int maxConcurrent) {
+	}
+	
+	/**
+	 * Submits a {@link Runnable} to be executed asynchronously. If
+	 * maxConcurrent runnables are already running, the runnable 
+	 * will be queued.
+	 * @param task the task to execute asynchronously
+	 */
+	public <T> AsyncResult<T> submit(final AsyncTask<T> task) {
+		T result = null;
+		boolean error = false;
+		try {
+			result = task.call();
+		} catch(Throwable t) {
+			error = true;
+		}
+		return new AsyncResult(result);
+	}
+	
+	/**
+	 * Waits for running {@link AsyncTask} instances to finish,
+	 * then destroys any resources like threads. Can not be used
+	 * after this method is called.
+	 */
+	@Override
+	public void dispose () {
+	}
+}
\ No newline at end of file
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/ClassReflection.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/ClassReflection.java
index 6eb6532..5241b9a 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/ClassReflection.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/ClassReflection.java
@@ -12,176 +12,153 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.utils.reflect;
-
-import com.badlogic.gwtref.client.ReflectionCache;
-import com.badlogic.gwtref.client.Type;
-
-/** Utilities for Class reflection.
- * @author nexsoftware */
-public final class ClassReflection {
-
-	/** Returns the Class object associated with the class or interface with the supplied string name. */
-	static public Class forName (String name) throws ReflectionException {
-		try {
-			return ReflectionCache.forName(name).getClassOfType();
-		} catch (ClassNotFoundException e) {
-			throw new ReflectionException("Class not found: " + name);
-		}
-	}
-
-	/** Returns the simple name of the underlying class as supplied in the source code. */
-	static public String getSimpleName (Class c) {
-		return c.getName();
-	}
-
-	/** Determines if the supplied Object is assignment-compatible with the object represented by supplied Class. */
-	static public boolean isInstance (Class c, Object obj) {
-		return isAssignableFrom(c, obj.getClass());
-	}
-
-	/** Determines if the class or interface represented by first Class parameter is either the same as, or is a superclass or
-	 * superinterface of, the class or interface represented by the second Class parameter. */
-	static public boolean isAssignableFrom (Class c1, Class c2) {
-		Type c1Type = ReflectionCache.getType(c1);
-		Type c2Type = ReflectionCache.getType(c2);
-		return c1Type.isAssignableFrom(c2Type);
-	}
-
-	/** Returns true if the class or interface represented by the supplied Class is a member class. */
-	static public boolean isMemberClass (Class c) {
-		return ReflectionCache.getType(c).isMemberClass();
-	}
-
-	/** Returns true if the class or interface represented by the supplied Class is a static class. */
-	static public boolean isStaticClass (Class c) {
-		return ReflectionCache.getType(c).isStatic();
-	}
-
-	/** Creates a new instance of the class represented by the supplied Class. */
-	static public <T> T newInstance (Class<T> c) throws ReflectionException {
-		try {
-			return (T)ReflectionCache.getType(c).newInstance();
-		} catch (NoSuchMethodException e) {
-			throw new ReflectionException("Could not use default constructor of " + c.getName(), e);
-		}
-	}
-
-	/** Returns an array of {@link Constructor} containing the public constructors of the class represented by the supplied Class. */
-	static public Constructor[] getConstructors (Class c) {
-		com.badlogic.gwtref.client.Constructor[] constructors = ReflectionCache.getType(c).getConstructors();
-		Constructor[] result = new Constructor[constructors.length];
-		for (int i = 0, j = constructors.length; i < j; i++) {
-			result[i] = new Constructor(constructors[i]);
-		}
-		return result;
-	}
-
-	/** Returns a {@link Constructor} that represents the public constructor for the supplied class which takes the supplied
-	 * parameter types. */
-	static public Constructor getConstructor (Class c, Class... parameterTypes) throws ReflectionException {
-		try {
-			return new Constructor(ReflectionCache.getType(c).getConstructor(parameterTypes));
-		} catch (SecurityException e) {
-			throw new ReflectionException("Security violation while getting constructor for class: " + c.getName(), e);
-		} catch (NoSuchMethodException e) {
-			throw new ReflectionException("Constructor not found for class: " + c.getName(), e);
-		}
-	}
-
-	/** Returns a {@link Constructor} that represents the constructor for the supplied class which takes the supplied parameter
-	 * types. */
-	static public Constructor getDeclaredConstructor (Class c, Class... parameterTypes) throws ReflectionException {
-		try {
-			return new Constructor(ReflectionCache.getType(c).getDeclaredConstructor(parameterTypes));
-		} catch (SecurityException e) {
-			throw new ReflectionException("Security violation while getting constructor for class: " + c.getName(), e);
-		} catch (NoSuchMethodException e) {
-			throw new ReflectionException("Constructor not found for class: " + c.getName(), e);
-		}
-	}
-
-	/** Returns an array of {@link Method} containing the public member methods of the class represented by the supplied Class. */
-	static public Method[] getMethods (Class c) {
-		com.badlogic.gwtref.client.Method[] methods = ReflectionCache.getType(c).getMethods();
-		Method[] result = new Method[methods.length];
-		for (int i = 0, j = methods.length; i < j; i++) {
-			result[i] = new Method(methods[i]);
-		}
-		return result;
-	}
-
-	/** Returns a {@link Method} that represents the public member method for the supplied class which takes the supplied parameter
-	 * types. */
-	static public Method getMethod (Class c, String name, Class... parameterTypes) throws ReflectionException {
-		try {
-			return new Method(ReflectionCache.getType(c).getMethod(name, parameterTypes));
-		} catch (SecurityException e) {
-			throw new ReflectionException("Security violation while getting method: " + name + ", for class: " + c.getName(), e);
-		} catch (NoSuchMethodException e) {
-			throw new ReflectionException("Method not found: " + name + ", for class: " + c.getName(), e);
-		}
-	}
-
-	/** Returns an array of {@link Method} containing the methods declared by the class represented by the supplied Class. */
-	static public Method[] getDeclaredMethods (Class c) {
-		com.badlogic.gwtref.client.Method[] methods = ReflectionCache.getType(c).getDeclaredMethods();
-		Method[] result = new Method[methods.length];
-		for (int i = 0, j = methods.length; i < j; i++) {
-			result[i] = new Method(methods[i]);
-		}
-		return result;
-	}
-
-	/** Returns a {@link Method} that represents the method declared by the supplied class which takes the supplied parameter types. */
-	static public Method getDeclaredMethod (Class c, String name, Class... parameterTypes) throws ReflectionException {
-		try {
-			return new Method(ReflectionCache.getType(c).getMethod(name, parameterTypes));
-		} catch (SecurityException e) {
-			throw new ReflectionException("Security violation while getting method: " + name + ", for class: " + c.getName(), e);
-		} catch (NoSuchMethodException e) {
-			throw new ReflectionException("Method not found: " + name + ", for class: " + c.getName(), e);
-		}
-	}
-
-	/** Returns an array of {@link Field} containing the public fields of the class represented by the supplied Class. */
-	static public Field[] getFields (Class c) {
-		com.badlogic.gwtref.client.Field[] fields = ReflectionCache.getType(c).getFields();
-		Field[] result = new Field[fields.length];
-		for (int i = 0, j = fields.length; i < j; i++) {
-			result[i] = new Field(fields[i]);
-		}
-		return result;
-	}
-
-	/** Returns a {@link Field} that represents the specified public member field for the supplied class. */
-	static public Field getField (Class c, String name) throws ReflectionException {
-		try {
-			return new Field(ReflectionCache.getType(c).getField(name));
-		} catch (SecurityException e) {
-			throw new ReflectionException("Security violation while getting field: " + name + ", for class: " + c.getName(), e);
-		}
-	}
-
-	/** Returns an array of {@link Field} objects reflecting all the fields declared by the supplied class. */
-	static public Field[] getDeclaredFields (Class c) {
-		com.badlogic.gwtref.client.Field[] fields = ReflectionCache.getType(c).getDeclaredFields();
-		Field[] result = new Field[fields.length];
-		for (int i = 0, j = fields.length; i < j; i++) {
-			result[i] = new Field(fields[i]);
-		}
-		return result;
-	}
-
-	/** Returns a {@link Field} that represents the specified declared field for the supplied class. */
-	static public Field getDeclaredField (Class c, String name) throws ReflectionException {
-		try {
-			return new Field(ReflectionCache.getType(c).getField(name));
-		} catch (SecurityException e) {
-			throw new ReflectionException("Security violation while getting field: " + name + ", for class: " + c.getName(), e);
-		}
-	}
-
-}
+ ******************************************************************************/
+
+package com.badlogic.gdx.utils.reflect;
+
+import com.badlogic.gdx.utils.GdxRuntimeException;
+import com.badlogic.gwtref.client.ReflectionCache;
+import com.badlogic.gwtref.client.Type;
+
+/** Utilities for Class reflection.
+ * @author nexsoftware */
+public final class ClassReflection {
+
+	/** Returns the Class object associated with the class or interface with the supplied string name. */
+	static public Class forName (String name) throws ReflectionException {
+		try {
+			return ReflectionCache.forName(name).getClassOfType();
+		} catch (ClassNotFoundException e) {
+			throw new ReflectionException("Class not found: " + name);
+		}
+	}
+
+	/** Returns the simple name of the underlying class as supplied in the source code. */
+	static public String getSimpleName(Class c) {
+		return c.getName();
+	}
+	
+	/** Determines if the supplied Object is assignment-compatible with the object represented by supplied Class. */
+	static public boolean isInstance (Class c, Object obj) {
+		return isAssignableFrom(c, obj.getClass());
+	}
+
+	/** Determines if the class or interface represented by first Class parameter is either the same as, or is a superclass or
+	 * superinterface of, the class or interface represented by the second Class parameter. */	
+	static public boolean isAssignableFrom (Class c1, Class c2) {
+		Type c1Type = ReflectionCache.getType(c1);
+		Type c2Type = ReflectionCache.getType(c2);
+		return c1Type.isAssignableFrom(c2Type);
+	}
+
+	/** Returns true if the class or interface represented by the supplied Class is a member class. */
+	static public boolean isMemberClass (Class c) {
+		return ReflectionCache.getType(c).isMemberClass();
+	}
+
+	/** Returns true if the class or interface represented by the supplied Class is a static class. */
+	static public boolean isStaticClass (Class c) {
+		return ReflectionCache.getType(c).isStatic();
+	}
+
+	/** Creates a new instance of the class represented by the supplied Class. */
+	static public <T> T newInstance (Class<T> c) throws ReflectionException {
+		return (T)ReflectionCache.getType(c).newInstance();
+	}
+
+	/** Returns an array of {@link Constructor} containing the public constructors of the class represented by the supplied Class. */
+	static public Constructor[] getConstructors (Class c) {
+		throw new GdxRuntimeException("Not implemented.");
+	}
+
+	/** Returns a {@link Constructor} that represents the public constructor for the supplied class which takes the supplied parameter types. */
+	static public Constructor getConstructor (Class c, Class... parameterTypes) throws ReflectionException {
+		throw new GdxRuntimeException("Not implemented.");
+	}
+
+	/** Returns a {@link Constructor} that represents the constructor for the supplied class which takes the supplied parameter types. */
+	static public Constructor getDeclaredConstructor (Class c, Class... parameterTypes) throws ReflectionException {
+		throw new GdxRuntimeException("Not implemented.");
+	}
+
+	/** Returns an array of {@link Method} containing the public member methods of the class represented by the supplied Class. */
+	static public Method[] getMethods (Class c) {
+		com.badlogic.gwtref.client.Method[] methods = ReflectionCache.getType(c).getMethods();
+		Method[] result = new Method[methods.length];
+		for (int i = 0, j = methods.length; i < j; i++) {
+			result[i] = new Method(methods[i]);
+		}
+		return result;
+	}
+
+	/** Returns a {@link Method} that represents the public member method for the supplied class which takes the supplied parameter types. */
+	static public Method getMethod (Class c, String name, Class... parameterTypes) throws ReflectionException {
+		try {
+			return new Method(ReflectionCache.getType(c).getMethod(name, parameterTypes));
+		} catch (SecurityException e) {
+			throw new ReflectionException("Security violation while getting method: " + name + ", for class: " + c.getName(), e);
+		} catch (NoSuchMethodException e) {
+			throw new ReflectionException("Method not found: " + name + ", for class: " + c.getName(), e);
+		}
+	}
+
+	/** Returns an array of {@link Method} containing the methods declared by the class represented by the supplied Class. */
+	static public Method[] getDeclaredMethods (Class c) {
+		com.badlogic.gwtref.client.Method[] methods = ReflectionCache.getType(c).getDeclaredMethods();
+		Method[] result = new Method[methods.length];
+		for (int i = 0, j = methods.length; i < j; i++) {
+			result[i] = new Method(methods[i]);
+		}
+		return result;
+	}
+
+	/** Returns a {@link Method} that represents the method declared by the supplied class which takes the supplied parameter types. */
+	static public Method getDeclaredMethod (Class c, String name, Class... parameterTypes) throws ReflectionException {
+		try {
+			return new Method(ReflectionCache.getType(c).getMethod(name, parameterTypes));
+		} catch (SecurityException e) {
+			throw new ReflectionException("Security violation while getting method: " + name + ", for class: " + c.getName(), e);
+		} catch (NoSuchMethodException e) {
+			throw new ReflectionException("Method not found: " + name + ", for class: " + c.getName(), e);
+		}
+	}
+
+	/** Returns an array of {@link Field} containing the public fields of the class represented by the supplied Class. */
+	static public Field[] getFields (Class c) {
+		com.badlogic.gwtref.client.Field[] fields = ReflectionCache.getType(c).getFields();
+		Field[] result = new Field[fields.length];
+		for (int i = 0, j = fields.length; i < j; i++) {
+			result[i] = new Field(fields[i]);
+		}
+		return result;
+	}
+
+	/** Returns a {@link Field} that represents the specified public member field for the supplied class. */
+	static public Field getField (Class c, String name) throws ReflectionException {
+		try {
+			return new Field(ReflectionCache.getType(c).getField(name));
+		} catch (SecurityException e) {
+			throw new ReflectionException("Security violation while getting field: " + name + ", for class: " + c.getName(), e);
+		}
+	}
+
+	/** Returns an array of {@link Field} objects reflecting all the fields declared by the supplied class. */
+	static public Field[] getDeclaredFields (Class c) {
+		com.badlogic.gwtref.client.Field[] fields = ReflectionCache.getType(c).getDeclaredFields();
+		Field[] result = new Field[fields.length];
+		for (int i = 0, j = fields.length; i < j; i++) {
+			result[i] = new Field(fields[i]);
+		}
+		return result;
+	}
+
+	/** Returns a {@link Field} that represents the specified declared field for the supplied class. */
+	static public Field getDeclaredField (Class c, String name) throws ReflectionException {
+		try {
+			return new Field(ReflectionCache.getType(c).getField(name));
+		} catch (SecurityException e) {
+			throw new ReflectionException("Security violation while getting field: " + name + ", for class: " + c.getName(), e);
+		}
+	}
+
+}
\ No newline at end of file
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/Constructor.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/Constructor.java
index 257ce29..5ad1388 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/Constructor.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/Constructor.java
@@ -12,47 +12,47 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.utils.reflect;
-
-/** Provides information about, and access to, a single constructor for a Class.
- * @author nexsoftware */
-public final class Constructor {
-
-	private final com.badlogic.gwtref.client.Constructor constructor;
-
-	Constructor (com.badlogic.gwtref.client.Constructor constructor) {
-		this.constructor = constructor;
-	}
-
-	/** Returns an array of Class objects that represent the formal parameter types, in declaration order, of the constructor. */
-	public Class[] getParameterTypes () {
-		return null;
-	}
-
-	/** Returns the Class object representing the class or interface that declares the constructor. */
-	public Class getDeclaringClass () {
-		return constructor.getEnclosingType();
-	}
-
-	public boolean isAccessible () {
-		return constructor.isPublic();
-	}
-
-	public void setAccessible (boolean accessible) {
-		// NOOP in GWT
-	}
-
-	/** Uses the constructor to create and initialize a new instance of the constructor's declaring class, with the supplied
-	 * initialization parameters. */
-	public Object newInstance (Object... args) throws ReflectionException {
-		try {
-			return constructor.newInstance(args);
-		} catch (IllegalArgumentException e) {
-			throw new ReflectionException("Illegal argument(s) supplied to constructor for class: " + getDeclaringClass().getName(),
-				e);
-		}
-	}
-
-}
+ ******************************************************************************/
+
+package com.badlogic.gdx.utils.reflect;
+
+import java.lang.reflect.InvocationTargetException;
+
+/** Provides information about, and access to, a single constructor for a Class.
+ * @author nexsoftware */
+public final class Constructor {
+	
+	private final com.badlogic.gwtref.client.Constructor constructor;
+	
+	Constructor(com.badlogic.gwtref.client.Constructor constructor) {
+		this.constructor = constructor;
+	}
+
+	/** Returns an array of Class objects that represent the formal parameter types, in declaration order, of the constructor. */
+	public Class[] getParameterTypes() {
+		return null;
+	}
+	
+	/** Returns the Class object representing the class or interface that declares the constructor. */
+	public Class getDeclaringClass() {
+		return constructor.getEnclosingType().getClassOfType();
+	}
+	
+	public boolean isAccessible() {
+		return constructor.isAccessible();		
+	}
+	
+	public void setAccessible(boolean accessible) {
+		constructor.setAccessible(accessible);
+	}
+	
+	/** Uses the constructor to create and initialize a new instance of the constructor's declaring class, with the supplied initialization parameters. */
+	public Object newInstance(Object... args) throws ReflectionException {
+		try {
+			return constructor.newInstance();
+		} catch (IllegalArgumentException e) {
+			throw new ReflectionException("Illegal argument(s) supplied to constructor for class: " + getDeclaringClass().getName(), e);
+		}		
+	}
+	
+}
\ No newline at end of file
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/Field.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/Field.java
index 38df772..b83d69c 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/Field.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/Field.java
@@ -45,11 +45,11 @@ public final class Field {
 	}
 
 	public boolean isAccessible () {
-		return field.isPublic();
+		return field.isAccessible();
 	}
 
 	public void setAccessible (boolean accessible) {
-		// NOOP in GWT
+		field.setAccessible(accessible);
 	}
 
 	/** Return true if the field does not include any of the {@code private}, {@code protected}, or {@code public} modifiers. */
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/Method.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/Method.java
index ce23cb6..4f32b58 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/Method.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/Method.java
@@ -12,110 +12,110 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.utils.reflect;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Modifier;
-
-import com.badlogic.gwtref.client.Parameter;
-
-/** Provides information about, and access to, a single method on a class or interface.
- * @author nexsoftware */
-public final class Method {
-
-	private final com.badlogic.gwtref.client.Method method;
-
-	Method (com.badlogic.gwtref.client.Method method) {
-		this.method = method;
-	}
-
-	/** Returns the name of the method. */
-	public String getName () {
-		return method.getName();
-	}
-
-	/** Returns a Class object that represents the formal return type of the method. */
-	public Class getReturnType () {
-		return method.getReturnType();
-	}
-
-	/** Returns an array of Class objects that represent the formal parameter types, in declaration order, of the method. */
-	public Class[] getParameterTypes () {
-		Parameter[] parameters = method.getParameters();
-		Class[] parameterTypes = new Class[parameters.length];
-		for (int i = 0, j = parameters.length; i < j; i++) {
-			parameterTypes[i] = parameters[i].getType();
-		}
-		return parameterTypes;
-	}
-
-	/** Returns the Class object representing the class or interface that declares the method. */
-	public Class getDeclaringClass () {
-		return method.getEnclosingType();
-	}
-
-	public boolean isAccessible () {
-		return method.isPublic();
-	}
-
-	public void setAccessible (boolean accessible) {
-		// NOOP in GWT
-	}
-
-	/** Return true if the method includes the {@code abstract} modifier. */
-	public boolean isAbstract () {
-		return method.isAbstract();
-	}
-
-	/** Return true if the method does not include any of the {@code private}, {@code protected}, or {@code public} modifiers. */
-	public boolean isDefaultAccess () {
-		return !isPrivate() && !isProtected() && !isPublic();
-	}
-
-	/** Return true if the method includes the {@code final} modifier. */
-	public boolean isFinal () {
-		return method.isFinal();
-	}
-
-	/** Return true if the method includes the {@code private} modifier. */
-	public boolean isPrivate () {
-		return method.isPrivate();
-	}
-
-	/** Return true if the method includes the {@code protected} modifier. */
-	public boolean isProtected () {
-		return method.isProtected();
-	}
-
-	/** Return true if the method includes the {@code public} modifier. */
-	public boolean isPublic () {
-		return method.isPublic();
-	}
-
-	/** Return true if the method includes the {@code native} modifier. */
-	public boolean isNative () {
-		return method.isNative();
-	}
-
-	/** Return true if the method includes the {@code static} modifier. */
-	public boolean isStatic () {
-		return method.isStatic();
-	}
-
-	/** Return true if the method takes a variable number of arguments. */
-	public boolean isVarArgs () {
-		return method.isVarArgs();
-	}
-
-	/** Invokes the underlying method on the supplied object with the supplied parameters. */
-	public Object invoke (Object obj, Object... args) throws ReflectionException {
-		try {
-			return method.invoke(obj, args);
-		} catch (IllegalArgumentException e) {
-			throw new ReflectionException("Illegal argument(s) supplied to method: " + getName(), e);
-		}
-	}
-
-}
+ ******************************************************************************/
+
+package com.badlogic.gdx.utils.reflect;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Modifier;
+
+import com.badlogic.gwtref.client.Parameter;
+
+/** Provides information about, and access to, a single method on a class or interface.
+ * @author nexsoftware */
+public final class Method {
+	
+	private final com.badlogic.gwtref.client.Method method;
+	
+	Method(com.badlogic.gwtref.client.Method method) {
+		this.method = method;
+	}
+
+	/** Returns the name of the method. */
+	public String getName() {
+		return method.getName();
+	}
+	
+	/** Returns a Class object that represents the formal return type of the method. */
+	public Class getReturnType() {
+		return method.getReturnType();
+	}
+	
+	/** Returns an array of Class objects that represent the formal parameter types, in declaration order, of the method. */
+	public Class[] getParameterTypes() {
+		Parameter[] parameters = method.getParameters();
+		Class[] parameterTypes = new Class[parameters.length];
+		for (int i = 0, j = parameters.length; i < j; i++) {
+			parameterTypes[i] = parameters[i].getType();
+		}
+		return parameterTypes;
+	}
+	
+	/** Returns the Class object representing the class or interface that declares the method. */
+	public Class getDeclaringClass() {
+		return method.getEnclosingType();
+	}
+	
+	public boolean isAccessible() {
+		return method.isAccessible();		
+	}
+	
+	public void setAccessible(boolean accessible) {
+		method.setAccessible(accessible);
+	}
+
+	/** Return true if the method includes the {@code abstract} modifier. */
+	public boolean isAbstract() {
+		return method.isAbstract();
+	}
+	
+	/** Return true if the method does not include any of the {@code private}, {@code protected}, or {@code public} modifiers. */
+	public boolean isDefaultAccess() {
+		return !isPrivate() && ! isProtected() && ! isPublic();
+	}
+	
+	/** Return true if the method includes the {@code final} modifier. */
+	public boolean isFinal() {
+		return method.isFinal();
+	}
+
+	/** Return true if the method includes the {@code private} modifier. */
+	public boolean isPrivate() {
+		return method.isPrivate();
+	}
+	
+	/** Return true if the method includes the {@code protected} modifier. */
+	public boolean isProtected() {
+		return method.isProtected();
+	}
+	
+	/** Return true if the method includes the {@code public} modifier. */
+	public boolean isPublic() {
+		return method.isPublic();
+	}
+	
+	/** Return true if the method includes the {@code native} modifier. */
+	public boolean isNative() {
+		return method.isNative();
+	}
+	
+	/** Return true if the method includes the {@code static} modifier. */
+	public boolean isStatic() {
+		return method.isStatic();
+	}
+	
+	/** Return true if the method takes a variable number of arguments. */
+	public boolean isVarArgs() {
+		return method.isVarArgs();
+	}
+
+	/** Invokes the underlying method on the supplied object with the supplied parameters. */
+	public Object invoke(Object obj, Object... args) throws ReflectionException {
+		try {
+			return method.invoke(obj, args);
+		} catch (IllegalArgumentException e) {
+			throw new ReflectionException("Illegal argument(s) supplied to method: " + getName(), e);
+		}
+	}
+	
+}
\ No newline at end of file
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/java/io/BufferedInputStream.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/java/io/BufferedInputStream.java
index e96157d..81c6fe8 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/java/io/BufferedInputStream.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/java/io/BufferedInputStream.java
@@ -16,12 +16,19 @@
 
 package java.io;
 
-public class BufferedInputStream extends FilterInputStream {
+public class BufferedInputStream extends InputStream {
+	InputStream in;
+
 	public BufferedInputStream (InputStream in) {
-		super(in);
+		this.in = in;
 	}
 
 	public BufferedInputStream (InputStream in, int size) {
-		super(in);
+		this.in = in;
+	}
+
+	@Override
+	public int read () throws IOException {
+		return in.read();
 	}
 }
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/java/io/FilterInputStream.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/java/io/FilterInputStream.java
index a08dc47..8bd331f 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/java/io/FilterInputStream.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/java/io/FilterInputStream.java
@@ -13,47 +13,46 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  ******************************************************************************/
-
 package java.io;
 
 public class FilterInputStream extends InputStream {
-	protected InputStream in;
+    protected InputStream in;
 
-	protected FilterInputStream (InputStream in) {
-		this.in = in;
-	}
+    protected FilterInputStream(InputStream in) {
+        this.in = in;
+    }
 
-	public int read () throws IOException {
-		return in.read();
-	}
+    public int read() throws IOException {
+        return in.read();
+    }
 
-	public int read (byte b[]) throws IOException {
-		return read(b, 0, b.length);
-	}
+    public int read(byte b[]) throws IOException {
+        return read(b, 0, b.length);
+    }
 
-	public int read (byte b[], int off, int len) throws IOException {
-		return in.read(b, off, len);
-	}
+    public int read(byte b[], int off, int len) throws IOException {
+        return in.read(b, off, len);
+    }
 
-	public long skip (long n) throws IOException {
-		return 0;
-	}
+    public long skip(long n) throws IOException {
+        return 0;
+    }
 
-	public int available () {
-		return in.available();
-	}
+    public int available() {
+        return 0;
+    }
 
-	public void close () throws IOException {
-		in.close();
-	}
+    public void close() throws IOException {
+        in.close();
+    }
 
-	public synchronized void mark (int readlimit) {
-	}
+    public synchronized void mark(int readlimit) {
+    }
 
-	public synchronized void reset () throws IOException {
-	}
+    public synchronized void reset() throws IOException {
+    }
 
-	public boolean markSupported () {
-		return false;
-	}
-}
+    public boolean markSupported() {
+   	 return false;
+    }
+}
\ No newline at end of file
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Constructor.java b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Constructor.java
index fb3eff5..95816ae 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Constructor.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Constructor.java
@@ -16,18 +16,31 @@
 
 package com.badlogic.gwtref.client;
 
-/** A constructor for the enclosing type.
+/** The default constructor for the enclosing type.
  * @author mzechner */
-public class Constructor extends Method {
-	Constructor (String name, Class enclosingType, Class returnType, Parameter[] parameters, boolean isAbstract, boolean isFinal,
-		boolean isStatic, boolean isDefaultAccess, boolean isPrivate, boolean isProtected, boolean isPublic, boolean isNative,
-		boolean isVarArgs, boolean isMethod, boolean isConstructor, String methodId) {
-		super(name, enclosingType, returnType, parameters, isAbstract, isFinal, isStatic, isDefaultAccess, isPrivate, isProtected,
-			isPublic, isNative, isVarArgs, isMethod, isConstructor, methodId);
+public class Constructor {
+	final Class enclosingType;
+	boolean isAccessible = false;
+
+	Constructor (Class enclosingType) {
+		this.enclosingType = enclosingType;
 	}
 
 	/** @return a new instance of the enclosing type of this constructor. */
-	public Object newInstance (Object... params) {
-		return super.invoke(null, params);
+	public Object newInstance () {
+		return ReflectionCache.getType(enclosingType).newInstance();
+	}
+
+	/** @return the enclosing type this constructor belongs to. */
+	public Type getEnclosingType () {
+		return ReflectionCache.getType(enclosingType);
+	}
+
+	public boolean isAccessible () {
+		return isAccessible;
+	}
+
+	public void setAccessible (boolean accessible) throws SecurityException {
+		isAccessible = accessible;
 	}
 }
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Field.java b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Field.java
index ce08a03..b784093 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Field.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Field.java
@@ -31,6 +31,7 @@ public class Field {
 	final boolean isStatic;
 	final boolean isTransient;
 	final boolean isVolatile;
+	boolean accessible;
 	final String getter;
 	final String setter;
 	final Class[] elementTypes;
@@ -52,6 +53,7 @@ public class Field {
 		this.getter = getter;
 		this.setter = setter;
 		this.elementTypes = elementTypes;
+		accessible = isPublic;
 	}
 
 	public Object get (Object obj) throws IllegalAccessException {
@@ -83,6 +85,14 @@ public class Field {
 		return false;
 	}
 
+	public boolean isAccessible () {
+		return accessible;
+	}
+
+	public void setAccessible (boolean accessible) throws AccessControlException {
+		this.accessible = accessible;
+	}
+
 	public boolean isFinal () {
 		return isFinal;
 	}
@@ -119,7 +129,7 @@ public class Field {
 	public String toString () {
 		return "Field [name=" + name + ", enclosingType=" + enclosingType + ", type=" + type + ", isFinal=" + isFinal
 			+ ", isDefaultAccess=" + isDefaultAccess + ", isPrivate=" + isPrivate + ", isProtected=" + isProtected + ", isPublic="
-			+ isPublic + ", isStatic=" + isStatic + ", isTransient=" + isTransient + ", isVolatile=" + isVolatile + ", getter="
-			+ getter + ", setter=" + setter + ", elementTypes=" + Arrays.toString(elementTypes) + "]";
+			+ isPublic + ", isStatic=" + isStatic + ", isTransient=" + isTransient + ", isVolatile=" + isVolatile + ", accessible="
+			+ accessible + ", getter=" + getter + ", setter=" + setter + ", elementTypes=" + Arrays.toString(elementTypes) + "]";
 	}
 }
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/IReflectionCache.java b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/IReflectionCache.java
index 521094c..3398762 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/IReflectionCache.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/IReflectionCache.java
@@ -26,6 +26,9 @@ public interface IReflectionCache {
 
 	public Object newArray (Class componentType, int size);
 
+	// Type methods
+	public Object newInstance (Type type);
+
 	public int getArrayLength (Type type, Object obj);
 
 	public Object getArrayElement (Type type, Object obj, int i);
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Method.java b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Method.java
index 8252d66..0c0f673 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Method.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Method.java
@@ -21,7 +21,6 @@ import java.util.Arrays;
 /** Describes a method of a {@link Type}.
  * @author mzechner */
 public class Method {
-	private static final Parameter[] EMPTY_PARAMS = new Parameter[0];
 	final String name;
 	final Class enclosingType;
 	final Class returnType;
@@ -38,13 +37,14 @@ public class Method {
 	final boolean isConstructor;
 	final Parameter[] parameters;
 	final String methodId;
+	boolean accessible;
 
 	public Method (String name, Class enclosingType, Class returnType, Parameter[] parameters, boolean isAbstract,
 		boolean isFinal, boolean isStatic, boolean isDefaultAccess, boolean isPrivate, boolean isProtected, boolean isPublic,
 		boolean isNative, boolean isVarArgs, boolean isMethod, boolean isConstructor, String methodId) {
 		this.name = name;
 		this.enclosingType = enclosingType;
-		this.parameters = parameters != null ? parameters : EMPTY_PARAMS;
+		this.parameters = parameters;
 		this.returnType = returnType;
 		this.isAbstract = isAbstract;
 		this.isFinal = isFinal;
@@ -60,6 +60,14 @@ public class Method {
 		this.methodId = methodId;
 	}
 
+	public boolean isAccessible () {
+		return accessible;
+	}
+
+	public void setAccessible (boolean accessible) {
+		this.accessible = accessible;
+	}
+
 	/** @return the {@link Class} of the enclosing type. */
 	public Class getEnclosingType () {
 		return enclosingType;
@@ -139,11 +147,7 @@ public class Method {
 	}
 
 	boolean match (String name, Class... types) {
-		return this.name.equals(name) && match(types);
-	}
-
-	boolean match (Class... types) {
-		if (types == null) return parameters.length == 0;
+		if (!this.name.equals(name)) return false;
 		if (types.length != parameters.length) return false;
 		for (int i = 0; i < types.length; i++) {
 			Type t1 = ReflectionCache.instance.forName(parameters[i].getType().getName());
@@ -159,6 +163,6 @@ public class Method {
 			+ isAbstract + ", isFinal=" + isFinal + ", isStatic=" + isStatic + ", isNative=" + isNative + ", isDefaultAccess="
 			+ isDefaultAccess + ", isPrivate=" + isPrivate + ", isProtected=" + isProtected + ", isPublic=" + isPublic
 			+ ", isVarArgs=" + isVarArgs + ", isMethod=" + isMethod + ", isConstructor=" + isConstructor + ", parameters="
-			+ Arrays.toString(parameters) + "]";
+			+ Arrays.toString(parameters) + ", accessible=" + accessible + "]";
 	}
 }
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Test.java b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Test.java
index 4c8a0c1..81d4eb6 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Test.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Test.java
@@ -79,20 +79,22 @@ public class Test implements EntryPoint {
 
 	@Override
 	public void onModuleLoad () {
-		try {
-			Type ta = ReflectionCache.getType(A.class);
-			Type tb = ReflectionCache.getType(B.class);
-			B b = (B)tb.newInstance();
-			for (Field f : tb.getFields())
-				System.out.println(f);
-			for (Method m : tb.getMethods())
-				System.out.println(m);
+		Type ta = ReflectionCache.getType(A.class);
+		Type tb = ReflectionCache.getType(B.class);
+		B b = (B)tb.newInstance();
+		for (Field f : tb.getFields())
+			System.out.println(f);
+		for (Method m : tb.getMethods())
+			System.out.println(m);
 
+		try {
 			tb.getDeclaredFields()[0].set(b, "Field of B");
 			ta.getDeclaredFields()[0].set(b, "Field of A");
 			System.out.println(ta.getMethod("getText").invoke(b));
 			System.out.println(ta.getMethod("getSum", float.class, float.class).invoke(b, 1, 2));
-		} catch (Exception e) {
+		} catch (IllegalAccessException e) {
+			e.printStackTrace();
+		} catch (NoSuchMethodException e) {
 			e.printStackTrace();
 		}
 	}
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Type.java b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Type.java
index 959fe7e..26e729d 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Type.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/client/Type.java
@@ -25,10 +25,6 @@ import java.util.Set;
  * interfaces of the type. Only types that are visible (public) can be described by this class.
  * @author mzechner */
 public class Type {
-	private static final Field[] EMPTY_FIELDS = new Field[0];
-	private static final Method[] EMPTY_METHODS = new Method[0];
-	private static final Constructor[] EMPTY_CONSTRUCTORS = new Constructor[0];
-
 	String name;
 	Class clazz;
 	Class superClass;
@@ -41,16 +37,15 @@ public class Type {
 	boolean isMemberClass;
 	boolean isStatic;
 
-	Field[] fields = EMPTY_FIELDS;
-	Method[] methods = EMPTY_METHODS;
-	Constructor[] constructors = EMPTY_CONSTRUCTORS;
-
+	Field[] fields;
+	Method[] methods;
+	Constructor constructor;
 	Class componentType;
 	Object[] enumConstants;
 
 	/** @return a new instance of this type created via the default constructor which must be public. */
-	public Object newInstance () throws NoSuchMethodException {
-		return getConstructor().newInstance();
+	public Object newInstance () {
+		return ReflectionCache.instance.newInstance(this);
 	}
 
 	/** @return the fully qualified name of this type. */
@@ -157,21 +152,8 @@ public class Type {
 		return methods;
 	}
 
-	public Constructor[] getConstructors () {
-		return constructors;
-	}
-
-	public Constructor getDeclaredConstructor (Class... parameterTypes) throws NoSuchMethodException {
-		return getConstructor(parameterTypes);
-	}
-
-	public Constructor getConstructor (Class... parameterTypes) throws NoSuchMethodException {
-		if (constructors != null) {
-			for (Constructor c : constructors) {
-				if (c.isPublic() && c.match(parameterTypes)) return c;
-			}
-		}
-		throw new NoSuchMethodException();
+	public Constructor getDeclaredConstructor () throws NoSuchMethodException {
+		return constructor;
 	}
 
 	public boolean isAbstract () {
@@ -238,8 +220,7 @@ public class Type {
 		return "Type [name=" + name + ",\n clazz=" + clazz + ",\n superClass=" + superClass + ",\n assignables=" + assignables
 			+ ",\n isAbstract=" + isAbstract + ",\n isInterface=" + isInterface + ",\n isPrimitive=" + isPrimitive + ",\n isEnum="
 			+ isEnum + ",\n isArray=" + isArray + ",\n isMemberClass=" + isMemberClass + ",\n isStatic=" + isStatic + ",\n fields="
-			+ Arrays.toString(fields) + ",\n methods=" + Arrays.toString(methods) + ",\n constructors="
-			+ Arrays.toString(constructors) + ",\n componentType=" + componentType + ",\n enumConstants="
-			+ Arrays.toString(enumConstants) + "]";
+			+ Arrays.toString(fields) + ",\n methods=" + Arrays.toString(methods) + ",\n constructor=" + constructor
+			+ ",\n componentType=" + componentType + ",\n enumConstants=" + Arrays.toString(enumConstants) + "]";
 	}
 }
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/gen/ReflectionCacheSourceCreator.java b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/gen/ReflectionCacheSourceCreator.java
index 5ed9989..48b1ebe 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/gen/ReflectionCacheSourceCreator.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/gen/ReflectionCacheSourceCreator.java
@@ -30,7 +30,6 @@ import com.google.gwt.core.ext.ConfigurationProperty;
 import com.google.gwt.core.ext.GeneratorContext;
 import com.google.gwt.core.ext.TreeLogger;
 import com.google.gwt.core.ext.TreeLogger.Type;
-import com.google.gwt.core.ext.typeinfo.JAbstractMethod;
 import com.google.gwt.core.ext.typeinfo.JArrayType;
 import com.google.gwt.core.ext.typeinfo.JClassType;
 import com.google.gwt.core.ext.typeinfo.JConstructor;
@@ -80,10 +79,6 @@ public class ReflectionCacheSourceCreator {
 		String methodId;
 		boolean isStatic;
 		boolean isAbstract;
-		boolean isFinal;
-		boolean isNative;
-		boolean isConstructor;
-		boolean isMethod;
 		String name;
 		boolean unused;
 	}
@@ -105,7 +100,7 @@ public class ReflectionCacheSourceCreator {
 		if (printWriter == null) {
 			return packageName + "." + simpleName;
 		}
-		sw = composer.createSourceWriter(context, printWriter);
+		sw = composer.createSourceWriter(context, printWriter);		
 
 		generateLookups();
 
@@ -113,6 +108,7 @@ public class ReflectionCacheSourceCreator {
 		forNameC();
 		newArrayC();
 
+		newInstanceT();
 		getArrayLengthT();
 		getArrayElementT();
 		setArrayElementT();
@@ -177,7 +173,7 @@ public class ReflectionCacheSourceCreator {
 		int id = 0;
 		for (JType t : types) {
 			String typeGen = createTypeGenerator(t);
-			p("private void c" + (id++) + "() {");
+			p("public void c" + (id++) + "() {");
 			p(typeGen);
 			p("}\n");
 		}
@@ -219,7 +215,6 @@ public class ReflectionCacheSourceCreator {
 			if (stubSource.equals("")) stub.unused = true;
 			p(stubSource);
 		}
-
 		logger.log(Type.INFO, types.size() + " types reflected");
 	}
 
@@ -374,44 +369,26 @@ public class ReflectionCacheSourceCreator {
 		stub.enclosingType = stub.enclosingType.replace(".class", "");
 		stub.returnType = stub.returnType.replace(".class", "");
 
-		if (stub.isMethod) {
-			pbn("private native " + stub.returnType + " " + stub.methodId + "(");
-			if (!stub.isStatic) pbn(stub.enclosingType + " obj" + (stub.parameterTypes.size() > 0 ? ", " : ""));
-			int i = 0;
-			for (String paramType : stub.parameterTypes) {
-				pbn(paramType + " p" + i + (i < stub.parameterTypes.size() - 1 ? "," : ""));
-				i++;
-			}
-			pb(") /*-{");
-
-			if (!stub.returnType.equals("void")) pbn("return ");
-			if (stub.isStatic)
-				pbn("@" + stub.enclosingType + "::" + stub.name + "(" + stub.jnsi + ")(");
-			else
-				pbn("obj.@" + stub.enclosingType + "::" + stub.name + "(" + stub.jnsi + ")(");
-
-			for (i = 0; i < stub.parameterTypes.size(); i++) {
-				pbn("p" + i + (i < stub.parameterTypes.size() - 1 ? ", " : ""));
-			}
-			pb(");");
-			pb("}-*/;");
-		} else {
-			pbn("private static " + stub.returnType + " " + stub.methodId + "(");
-			int i = 0;
-			for (String paramType : stub.parameterTypes) {
-				pbn(paramType + " p" + i + (i < stub.parameterTypes.size() - 1 ? "," : ""));
-				i++;
-			}
-			pb(") {");
+		pbn("public native " + stub.returnType + " " + stub.methodId + "(");
+		pbn(stub.enclosingType + " obj" + (stub.parameterTypes.size() > 0 ? ", " : ""));
+		int i = 0;
+		for (String paramType : stub.parameterTypes) {
+			pbn(paramType + " p" + i + (i < stub.parameterTypes.size() - 1 ? "," : ""));
+			i++;
+		}
+		pb(") /*-{");
 
-			pbn("return new " + stub.returnType + "(");
-			for (i = 0; i < stub.parameterTypes.size(); i++) {
-				pbn("p" + i + (i < stub.parameterTypes.size() - 1 ? ", " : ""));
-			}
-			pb(");");
+		if (!stub.returnType.equals("void")) pbn("return ");
+		if (stub.isStatic)
+			pbn("@" + stub.enclosingType + "::" + stub.name + "(" + stub.jnsi + ")(");
+		else
+			pbn("obj.@" + stub.enclosingType + "::" + stub.name + "(" + stub.jnsi + ")(");
 
-			pb("}");
+		for (i = 0; i < stub.parameterTypes.size(); i++) {
+			pbn("p" + i + (i < stub.parameterTypes.size() - 1 ? ", " : ""));
 		}
+		pb(");");
+		pb("}-*/;");
 
 		return buffer.toString();
 	}
@@ -446,7 +423,10 @@ public class ReflectionCacheSourceCreator {
 		pb("}-*/;");
 
 		if (!stub.isFinal) {
-			pb("private native void " + stub.setter + "(" + stub.enclosingType + " obj, Object value)  /*-{");
+			pb("public native void " + stub.setter + "(" + stub.enclosingType + " obj, Object value)  /*-{");
+			// TODO changes from PR #1005 break things
+//			String vType = isPrimitive(stub.type) ? stub.type : "Object";
+//			pb("public native void " + stub.setter + "(" + stub.enclosingType + " obj, " + vType + " value)  /*-{");
 			if (stub.isStatic)
 				pb("    @" + stub.enclosingType + "::" + stub.name + " = value");
 			else
@@ -532,8 +512,45 @@ public class ReflectionCacheSourceCreator {
 				pb("};");
 			}
 
-			printMethods(c, varName, "Method", c.getMethods());
-			if (!c.isAbstract()) printMethods(c, varName, "Constructor", c.getConstructors());
+			if (c.getMethods() != null) {
+				pb(varName + ".methods = new Method[] {");
+				for (JMethod m : c.getMethods()) {
+					String enclosingType = getType(c);
+					String returnType = getType(m.getReturnType());
+					String methodId = "m" + (nextStub++);
+
+					MethodStub stub = new MethodStub();
+					stub.enclosingType = enclosingType;
+					stub.returnType = returnType;
+					stub.jnsi = "";
+					stub.isStatic = m.isStatic();
+					stub.isAbstract = m.isAbstract();
+					stub.methodId = methodId;
+					stub.name = m.getName();
+					methodStubs.add(stub);
+
+					pb("new Method(\"" + m.getName() + "\", ");
+					pb(enclosingType + ", ");
+					pb(returnType + ", ");
+
+					if (m.getParameters() != null) {
+						pb("new Parameter[] {");
+						for (JParameter p : m.getParameters()) {
+							String paramType = getType(p.getType());
+							stub.parameterTypes.add(paramType);
+							stub.jnsi += p.getType().getErasedType().getJNISignature();
+							pb("new Parameter(\"" + p.getName() + "\", " + paramType + ", \"" + p.getType().getJNISignature() + "\"), ");
+						}
+						pb("}, ");
+					} else {
+						pb("new Parameter[0], ");
+					}
+					pb(m.isAbstract() + ", " + m.isFinal() + ", " + m.isStatic() + ", " + m.isDefaultAccess() + ", " + m.isPrivate()
+						+ ", " + m.isProtected() + ", " + m.isPublic() + ", " + m.isNative() + ", " + m.isVarArgs() + ", "
+						+ (m.isMethod() != null) + ", " + (m.isConstructor() != null) + ", " + "\"" + methodId + "\"" + "),");
+				}
+				pb("};");
+			}
 
 			if (c.isArray() != null) {
 				pb(varName + ".componentType = " + getType(c.isArray().getComponentType()) + ";");
@@ -556,51 +573,6 @@ public class ReflectionCacheSourceCreator {
 		return buffer.toString();
 	}
 
-	private void printMethods (JClassType c, String varName, String methodType, JAbstractMethod[] methodTypes) {
-		if (methodTypes != null) {
-			pb(varName + "." + methodType.toLowerCase() + "s = new " + methodType + "[] {");
-			for (JAbstractMethod m : methodTypes) {
-				MethodStub stub = new MethodStub();
-				stub.enclosingType = getType(c);
-				if (m.isMethod() != null) {
-					stub.isMethod = true;
-					stub.returnType = getType(m.isMethod().getReturnType());
-					stub.isStatic = m.isMethod().isStatic();
-					stub.isAbstract = m.isMethod().isAbstract();
-					stub.isNative = m.isMethod().isAbstract();
-					stub.isFinal = m.isMethod().isFinal();
-				} else {
-					stub.isConstructor = true;
-					stub.returnType = stub.enclosingType;
-				}
-				stub.jnsi = "";
-				stub.methodId = "m" + (nextStub++);
-				stub.name = m.getName();
-				methodStubs.add(stub);
-
-				pb("new " + methodType + "(\"" + m.getName() + "\", ");
-				pb(stub.enclosingType + ", ");
-				pb(stub.returnType + ", ");
-
-				pb("new Parameter[] {");
-				if (m.getParameters() != null) {
-					for (JParameter p : m.getParameters()) {
-						stub.parameterTypes.add(getType(p.getType()));
-						stub.jnsi += p.getType().getErasedType().getJNISignature();
-						pb("new Parameter(\"" + p.getName() + "\", " + getType(p.getType()) + ", \"" + p.getType().getJNISignature()
-							+ "\"), ");
-					}
-				}
-				pb("}, ");
-
-				pb(stub.isAbstract + ", " + stub.isFinal + ", " + stub.isStatic + ", " + m.isDefaultAccess() + ", " + m.isPrivate()
-					+ ", " + m.isProtected() + ", " + m.isPublic() + ", " + stub.isNative + ", " + m.isVarArgs() + ", "
-					+ stub.isMethod + ", " + stub.isConstructor + ", " + "\"" + stub.methodId + "\"" + "),");
-			}
-			pb("};");
-		}
-	}
-
 	private String getElementTypes (JField f) {
 		StringBuilder b = new StringBuilder();
 		JParameterizedType params = f.getType().isParameterized();
@@ -610,7 +582,7 @@ public class ReflectionCacheSourceCreator {
 			for (JClassType typeArg : typeArgs) {
 				if (typeArg.isWildcard() != null)
 					b.append("Object.class");
-				else if (!isVisible(typeArg))
+				else if(!isVisible(typeArg))
 					b.append("null");
 				else if (typeArg.isClassOrInterface() != null)
 					b.append(typeArg.isClassOrInterface().getQualifiedSourceName()).append(".class");
@@ -625,7 +597,7 @@ public class ReflectionCacheSourceCreator {
 		}
 		return "null";
 	}
-
+	
 	private String getType (JType type) {
 		if (!isVisible(type)) return null;
 		return type.getErasedType().getQualifiedSourceName() + ".class";
@@ -643,7 +615,6 @@ public class ReflectionCacheSourceCreator {
 		SwitchedCodeBlocks pc = new SwitchedCodeBlocks();
 		int subN = 0;
 		int nDispatch = 0;
-
 		for (MethodStub stub : methodStubs) {
 			if (stub.enclosingType == null) continue;
 			if (stub.enclosingType.contains("[]")) continue;
@@ -656,7 +627,6 @@ public class ReflectionCacheSourceCreator {
 					break;
 				}
 			}
-
 			if (!paramsOk) continue;
 			buffer.setLength(0);
 			if (stub.returnType.equals("void")) {
@@ -682,14 +652,12 @@ public class ReflectionCacheSourceCreator {
 			}
 		}
 
-		pc.print();
-		p("   throw new IllegalArgumentException(\"Missing method-stub \" + m.methodId + \" for method \" + m.name);");
+		p("   return null;");
 		p("}");
 	}
 
 	private void addParameters (MethodStub stub) {
-		if (!stub.isStatic && !stub.isConstructor)
-			pbn("(" + stub.enclosingType + ")obj" + (stub.parameterTypes.size() > 0 ? "," : ""));
+		pbn("(" + stub.enclosingType + ")obj" + (stub.parameterTypes.size() > 0 ? "," : ""));
 		for (int i = 0; i < stub.parameterTypes.size(); i++) {
 			String paramType = stub.parameterTypes.get(i);
 			if (isPrimitive(paramType)) {
@@ -724,7 +692,12 @@ public class ReflectionCacheSourceCreator {
 		SwitchedCodeBlocks pc = new SwitchedCodeBlocks();
 		for (SetterGetterStub stub : setterGetterStubs) {
 			if (stub.enclosingType == null || stub.type == null || stub.isFinal || stub.unused) continue;
-			pc.add(stub.setter, stub.setter + "((" + stub.enclosingType + ")obj, value);");
+			 pc.add(stub.setter, stub.setter + "((" + stub.enclosingType + ")obj, value);");
+			 // TODO changes from PR #1005 break things
+//			if(isPrimitive(stub.type))
+//				pc.add(stub.setter, stub.setter + "((" + stub.enclosingType + ")obj, " + castPrimitive(stub.type, "value") + ");");
+//			else
+//				pc.add(stub.setter, stub.setter + "((" + stub.enclosingType + ")obj, value);");
 		}
 		pc.print();
 		p("}");
@@ -736,13 +709,34 @@ public class ReflectionCacheSourceCreator {
 		SwitchedCodeBlocks pc = new SwitchedCodeBlocks();
 		for (SetterGetterStub stub : setterGetterStubs) {
 			if (stub.enclosingType == null || stub.type == null || stub.unused) continue;
-			pc.add(stub.getter, "return " + stub.getter + "((" + stub.enclosingType + ")obj);");
+			pc.add( stub.getter, "return " + stub.getter + "((" + stub.enclosingType + ")obj);");
 		}
 		pc.print();
 		p("   return null;");
 		p("}");
 	}
 
+	private void newInstanceT () {
+		p("public Object newInstance (Type type) {");
+		p("    String param = type.getName();");
+		SwitchedCodeBlocks pc = new SwitchedCodeBlocks();
+		for (JType type : types) {
+			if (type instanceof JClassType) {
+				if (isInstantiableWithNewOperator((JClassType)type)) {
+					pc.add(type.getErasedType().getQualifiedSourceName(), "return new "+ type.getErasedType().getQualifiedSourceName() + "();");
+				} else {
+					logger.log(Type.INFO, "No public default constructor for '" + type.getQualifiedSourceName()
+						+ "', or type is an array, enum, abstract class or interface type");
+				}
+			} else {
+				logger.log(Type.INFO, "No public default constructor for primitive type '" + type.getQualifiedSourceName() + "'");
+			}
+		}
+		pc.print();
+		p("return null;");
+		p("}");
+	}
+
 	private static boolean isInstantiableWithNewOperator (JClassType t) {
 		if (!t.isDefaultInstantiable() || t instanceof JArrayType || t instanceof JEnumType) return false;
 		try {
@@ -765,7 +759,7 @@ public class ReflectionCacheSourceCreator {
 			} else {
 				value = "(" + value + ")value";
 			}
-			pc.add(type.getQualifiedSourceName(), "((" + type.getQualifiedSourceName() + ")obj)[i] = " + value + ";");
+			pc.add(type.getQualifiedSourceName() , "((" + type.getQualifiedSourceName() + ")obj)[i] = " + value + ";");
 		}
 		pc.print();
 		p("}");
@@ -867,8 +861,6 @@ public class ReflectionCacheSourceCreator {
 		}
 
 		void print () {
-			if (keyHash2CodeBlock.isEmpty()) return;
-
 			p("    switch(param.hashCode()) {");
 			for (Entry<Integer, List<KeyedCodeBlock>> e : keyHash2CodeBlock.entrySet()) {
 				p("    case " + e.getKey() + ":");
diff --git a/demos/cuboc/cuboc-android/AndroidManifest.xml b/demos/cuboc/cuboc-android/AndroidManifest.xml
index 77fd04e..c8512c4 100644
--- a/demos/cuboc/cuboc-android/AndroidManifest.xml
+++ b/demos/cuboc/cuboc-android/AndroidManifest.xml
@@ -5,6 +5,7 @@
       android:versionName="1.0"
       android:installLocation="preferExternal">
     <uses-sdk android:minSdkVersion="3" android:targetSdkVersion="10"/>
+    <uses-permission android:name="android.permission.WAKE_LOCK"/>
 
     <application android:icon="@drawable/icon" android:label="@string/app_name">
         <activity android:name=".Cuboc"
diff --git a/demos/invaders/gdx-invaders-android/AndroidManifest.xml b/demos/invaders/gdx-invaders-android/AndroidManifest.xml
index 102b0c0..d0b4229 100644
--- a/demos/invaders/gdx-invaders-android/AndroidManifest.xml
+++ b/demos/invaders/gdx-invaders-android/AndroidManifest.xml
@@ -17,4 +17,5 @@
 
     </application>
     <uses-sdk android:minSdkVersion="3" android:targetSdkVersion="5"/>
+    <uses-permission android:name="android.permission.WAKE_LOCK"/>
 </manifest> 
\ No newline at end of file
diff --git a/demos/pax-britannica/pax-britannica-android/AndroidManifest.xml b/demos/pax-britannica/pax-britannica-android/AndroidManifest.xml
index c8d2155..647bd8d 100755
--- a/demos/pax-britannica/pax-britannica-android/AndroidManifest.xml
+++ b/demos/pax-britannica/pax-britannica-android/AndroidManifest.xml
@@ -5,6 +5,7 @@
 
     <uses-sdk android:minSdkVersion="5" android:targetSdkVersion="15" />
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+    <uses-permission android:name="android.permission.WAKE_LOCK"/>
 
     <application
         android:icon="@drawable/ic_launcher"
diff --git a/demos/very-angry-robots/very-angry-robots-android/AndroidManifest.xml b/demos/very-angry-robots/very-angry-robots-android/AndroidManifest.xml
index f4e91da..9f8095a 100644
--- a/demos/very-angry-robots/very-angry-robots-android/AndroidManifest.xml
+++ b/demos/very-angry-robots/very-angry-robots-android/AndroidManifest.xml
@@ -6,6 +6,8 @@
       android:versionName="0.1.0.2">
     <uses-sdk android:minSdkVersion="7" android:targetSdkVersion="8" />
     
+    <!-- Permission configuration (sort of) required by Very Angry Robots -->
+    <uses-permission android:name="android.permission.WAKE_LOCK" />
     
     <application android:icon="@drawable/icon" android:label="@string/app_name">
         <activity android:name=".VeryAngryRobotsActivity"
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/GdxSetup.java b/extensions/gdx-setup/src/com/badlogic/gdx/setup/GdxSetup.java
index d3c620a..180fecd 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/GdxSetup.java
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/GdxSetup.java
@@ -12,192 +12,202 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.setup;
-
-import java.io.BufferedOutputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.UnsupportedEncodingException;
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * Command line tool to generate libgdx projects
- * @author badlogic
- *
- */
+ ******************************************************************************/
+
+package com.badlogic.gdx.setup;
+
+import java.io.BufferedOutputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.UnsupportedEncodingException;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Command line tool to generate libgdx projects
+ * @author badlogic
+ *
+ */
 public class GdxSetup {
-	public void build (String outputDir, String appName, String packageName, String mainClass) {
-		Project project = new Project();
-		
-		String packageDir = packageName.replace('.', '/');
-
-		// root dir/gradle files
-		project.files.add(new ProjectFile("build.gradle", true));
-		project.files.add(new ProjectFile("settings.gradle"));
-		project.files.add(new ProjectFile("gradlew", false));
-		project.files.add(new ProjectFile("gradlew.bat", false));
-		project.files.add(new ProjectFile("gradle/wrapper/gradle-wrapper.jar", false));
-		project.files.add(new ProjectFile("gradle/wrapper/gradle-wrapper.properties", false));
-		
-		// core project
-		project.files.add(new ProjectFile("core/build.gradle"));
-		project.files.add(new ProjectFile("core/src/MainClass", "core/src/" + packageDir + "/" + mainClass + ".java", true));
-        //core but gwt required
-        project.files.add(new ProjectFile("core/CoreGdxDefinition", "core/src/" + packageDir + "/" + mainClass + ".gwt.xml", true));
-		
-		// desktop project
-		project.files.add(new ProjectFile("desktop/build.gradle"));
-		project.files.add(new ProjectFile("desktop/src/DesktopLauncher", "desktop/src/" + packageDir + "/desktop/DesktopLauncher.java", true));
-
-		// android project
-		project.files.add(new ProjectFile("android/assets/badlogic.jpg", false));
-		project.files.add(new ProjectFile("android/res/values/strings.xml", false));
-		project.files.add(new ProjectFile("android/res/values/styles.xml", false));
-		project.files.add(new ProjectFile("android/res/drawable-hdpi/ic_launcher.png", false));
-		project.files.add(new ProjectFile("android/res/drawable-mdpi/ic_launcher.png", false));
-		project.files.add(new ProjectFile("android/res/drawable-xhdpi/ic_launcher.png", false));
-		project.files.add(new ProjectFile("android/res/drawable-xxhdpi/ic_launcher.png", false));
-		project.files.add(new ProjectFile("android/src/AndroidLauncher", "android/src/" + packageDir + "/android/AndroidLauncher.java", true));
-		project.files.add(new ProjectFile("android/AndroidManifest.xml"));
-		project.files.add(new ProjectFile("android/build.gradle"));
-		project.files.add(new ProjectFile("android/ic_launcher-web.png", false));
-		project.files.add(new ProjectFile("android/proguard-project.txt", false));
-		project.files.add(new ProjectFile("android/project.properties", false));
-
-        //gwt project
-        project.files.add(new ProjectFile("gwt/build.gradle"));
-        project.files.add(new ProjectFile("gwt/src/GwtLauncher", "gwt/src/" + packageDir + "/client/GwtLauncher.java", true));
-        project.files.add(new ProjectFile("gwt/GdxDefinition", "gwt/src/" + packageDir + "/GdxDefinition.gwt.xml", true));
-        project.files.add(new ProjectFile("gwt/war/index", "gwt/webapp/" + "index.html", true));
-        project.files.add(new ProjectFile("gwt/war/WEB-INF/web.xml", "gwt/webapp/WEB-INF/web.xml", true));
-
-
-		Map<String, String> values = new HashMap<String, String>();
-		values.put("%APP_NAME%", appName);
-		values.put("%PACKAGE%", packageName);
+	final static String[] GDX_VERSIONS = {"0.9.9", "1.0-SNAPSHOT"};
+	
+	public void build (String outputDir, String appName, String packageName, String mainClass, String gdxVersion) {
+		Project project = new Project();
+		
+		String packageDir = packageName.replace('.', '/');
+		
+		// root dir/gradle files
+		project.files.add(new ProjectFile("build.gradle"));
+		project.files.add(new ProjectFile("settings.gradle"));
+		project.files.add(new ProjectFile("gradlew", false));
+		project.files.add(new ProjectFile("gradlew.bat", false));
+		project.files.add(new ProjectFile("gradle/wrapper/gradle-wrapper.jar", false));
+		project.files.add(new ProjectFile("gradle/wrapper/gradle-wrapper.properties", false));
+		
+		// core project
+		project.files.add(new ProjectFile("core/build.gradle"));
+		project.files.add(new ProjectFile("core/src/MainClass", "core/src/" + packageDir + "/" + mainClass + ".java", true));
+		
+		// desktop project
+		project.files.add(new ProjectFile("desktop/build.gradle"));
+		project.files.add(new ProjectFile("desktop/src/DesktopLauncher", "desktop/src/" + packageDir + "/desktop/DesktopLauncher.java", true));
+		
+		// android project
+		project.files.add(new ProjectFile("android/assets/badlogic.jpg", false));
+		project.files.add(new ProjectFile("android/res/values/strings.xml", false));
+		project.files.add(new ProjectFile("android/res/values/styles.xml", false));
+		project.files.add(new ProjectFile("android/res/drawable-hdpi/ic_launcher.png", false));
+		project.files.add(new ProjectFile("android/res/drawable-mdpi/ic_launcher.png", false));
+		project.files.add(new ProjectFile("android/res/drawable-xhdpi/ic_launcher.png", false));
+		project.files.add(new ProjectFile("android/res/drawable-xxhdpi/ic_launcher.png", false));
+		project.files.add(new ProjectFile("android/src/AndroidLauncher", "android/src/" + packageDir + "/android/AndroidLauncher.java", true));
+		project.files.add(new ProjectFile("android/AndroidManifest.xml"));
+		project.files.add(new ProjectFile("android/build.gradle"));
+		project.files.add(new ProjectFile("android/ic_launcher-web.png", false));
+		project.files.add(new ProjectFile("android/proguard-project.txt", false));
+		project.files.add(new ProjectFile("android/project.properties", false));
+		
+		Map<String, String> values = new HashMap<String, String>();
+		values.put("%APP_NAME%", appName);
+		values.put("%PACKAGE%", packageName);
 		values.put("%MAIN_CLASS%", mainClass);
-		
-		copyAndReplace(outputDir, project, values);
-		
-		// HACK executable flag isn't preserved for whatever reason...
+		values.put("%GDX_VERSION%", gdxVersion);
+		
+		copyAndReplace(outputDir, project, values);
+		
+		// HACK executable flag isn't preserved for whatever reason...
 		new File(outputDir, "gradlew").setExecutable(true);
-	}
-
-	private void copyAndReplace (String outputDir, Project project, Map<String, String> values) {
-		File out = new File(outputDir);
-		if(!out.exists() && !out.mkdirs()) {
-			throw new RuntimeException("Couldn't create output directory '" + out.getAbsolutePath() + "'");
-		}
-		
-		for(ProjectFile file: project.files) {
-			copyFile(file, out, values);
-		}
-	}
-	
-	private byte[] readResource(String resource) {
-		InputStream in = null;
-		try {
-			ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-			byte[] buffer = new byte[1024*10];
-			in = GdxSetup.class.getResourceAsStream("/com/badlogic/gdx/setup/resources/" + resource);
-			if(in == null) throw new RuntimeException("Couldn't read resource '" + resource + "'");
-			int read = 0;
-			while((read = in.read(buffer)) > 0) {
-				bytes.write(buffer, 0, read);
-			}
-			return bytes.toByteArray();
-		} catch(IOException e) {
-			throw new RuntimeException("Couldn't read resource '" + resource + "'", e);
-		} finally {
-			if(in != null) try { in.close(); } catch(IOException e) {}
-		}
-	}
-	
-	private String readResourceAsString(String resource) {
-		try {
-			return new String(readResource(resource), "UTF-8");
-		} catch (UnsupportedEncodingException e) {
-			throw new RuntimeException(e);
-		}
-	}
-	
-	private void writeFile (File outFile, byte[] bytes) {
-		OutputStream out = null;
-		
-		try {
-			out = new BufferedOutputStream(new FileOutputStream(outFile));
-			out.write(bytes);
-		} catch(IOException e) {
-			throw new RuntimeException("Couldn't write file '" + outFile.getAbsolutePath() + "'", e);
-		} finally {
-			if(out != null) try { out.close(); } catch(IOException e) {}
-		}
-	}
-	
-	private void writeFile(File outFile, String text) {
-		try {
-			writeFile(outFile, text.getBytes("UTF-8"));
-		} catch (UnsupportedEncodingException e) {
-			throw new RuntimeException(e);
-		}
-	}
-
-	private void copyFile(ProjectFile file, File out, Map<String, String> values) {
-		File outFile = new File(out, file.outputName);
-		if(!outFile.getParentFile().exists() && !outFile.getParentFile().mkdirs()) {
-			throw new RuntimeException("Couldn't create dir '" + outFile.getAbsolutePath() + "'");
-		}
-		
-		if(file.isTemplate) {
-			String txt = readResourceAsString(file.resourceName);
-			txt = replace(txt, values);
-			writeFile(outFile, txt);
-		} else {
-			writeFile(outFile, readResource(file.resourceName));
-		}
-	}
-
-	private String replace (String txt, Map<String, String> values) {
-		for(String key: values.keySet()) {
-			String value = values.get(key);
-			txt = txt.replace(key, value);
-		}
-		return txt;
-	}
-	
-	private static void printHelp() {
+		System.out.println("Done! project created in " + outputDir +" directory");
+	}
+
+	private void copyAndReplace (String outputDir, Project project, Map<String, String> values) {
+		File out = new File(outputDir);
+		if(!out.exists() && !out.mkdirs()) {
+			throw new RuntimeException("Couldn't create output directory '" + out.getAbsolutePath() + "'");
+		}
+		
+		for(ProjectFile file: project.files) {
+			copyFile(file, out, values);
+		}
+	}
+	
+	private byte[] readResource(String resource) {
+		InputStream in = null;
+		try {
+			ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+			byte[] buffer = new byte[1024*10];
+			in = GdxSetup.class.getResourceAsStream("/com/badlogic/gdx/setup/resources/" + resource);
+			if(in == null) throw new RuntimeException("Couldn't read resource '" + resource + "'");
+			int read = 0;
+			while((read = in.read(buffer)) > 0) {
+				bytes.write(buffer, 0, read);
+			}
+			return bytes.toByteArray();
+		} catch(IOException e) {
+			throw new RuntimeException("Couldn't read resource '" + resource + "'", e);
+		} finally {
+			if(in != null) try { in.close(); } catch(IOException e) {}
+		}
+	}
+	
+	private String readResourceAsString(String resource) {
+		try {
+			return new String(readResource(resource), "UTF-8");
+		} catch (UnsupportedEncodingException e) {
+			throw new RuntimeException(e);
+		}
+	}
+	
+	private void writeFile (File outFile, byte[] bytes) {
+		OutputStream out = null;
+		
+		try {
+			out = new BufferedOutputStream(new FileOutputStream(outFile));
+			out.write(bytes);
+		} catch(IOException e) {
+			throw new RuntimeException("Couldn't write file '" + outFile.getAbsolutePath() + "'", e);
+		} finally {
+			if(out != null) try { out.close(); } catch(IOException e) {}
+		}
+	}
+	
+	private void writeFile(File outFile, String text) {
+		try {
+			writeFile(outFile, text.getBytes("UTF-8"));
+		} catch (UnsupportedEncodingException e) {
+			throw new RuntimeException(e);
+		}
+	}
+
+	private void copyFile(ProjectFile file, File out, Map<String, String> values) {
+		File outFile = new File(out, file.outputName);
+		if(!outFile.getParentFile().exists() && !outFile.getParentFile().mkdirs()) {
+			throw new RuntimeException("Couldn't create dir '" + outFile.getAbsolutePath() + "'");
+		}
+		
+		if(file.isTemplate) {
+			String txt = readResourceAsString(file.resourceName);
+			txt = replace(txt, values);
+			writeFile(outFile, txt);
+		} else {
+			writeFile(outFile, readResource(file.resourceName));
+		}
+	}
+
+	private String replace (String txt, Map<String, String> values) {
+		for(String key: values.keySet()) {
+			String value = values.get(key);
+			txt = txt.replace(key, value);
+		}
+		return txt;
+	}
+	
+	private static void printHelp() {
 		System.out.println("Usage: GdxSetup --dir <dir-name> --name <app-name> --package <package> --mainClass <mainClass>");
-	}
-	
-	private static Map<String, String> parseArgs(String[] args) {
-		if(args.length % 2 != 0) {
-			printHelp();
-			System.exit(-1);
-		}
-		
-		Map<String, String> params = new HashMap<String, String>();
-		for(int i = 0; i < args.length; i+=2) {
-			String param = args[i].replace("--", "");
-			String value = args[i+1];
-			params.put(param, value);
+		System.out.println("[OPTIONAL]");
+		System.out.println("--gdxVersion <version> defaults to " + GDX_VERSIONS[0] + " if not specified");
+	}
+	
+	private static Map<String, String> parseArgs(String[] args) {
+		if(args.length % 2 != 0) {
+			printHelp();
+			System.exit(-1);
+		}
+		
+		Map<String, String> params = new HashMap<String, String>();
+		for(int i = 0; i < args.length; i+=2) {
+			String param = args[i].replace("--", "");
+			String value = args[i+1];
+			params.put(param, value);
+		}
+		return params;
+	}
+	
+	public static void main (String[] args) {
+		Map<String, String> params = parseArgs(args);
+		if(!params.containsKey("dir") || !params.containsKey("name") || !params.containsKey("package") || !params.containsKey("mainClass")) {
+			printHelp();
+			System.exit(-1);
 		}
-		return params;
-	}
-	
-	public static void main (String[] args) {
-		Map<String, String> params = parseArgs(args);
-		if(!params.containsKey("dir") || !params.containsKey("name") || !params.containsKey("package") || !params.containsKey("mainClass")) {
-			printHelp();
-			System.exit(-1);
+		if(params.containsKey("gdxVersion")){
+			List<String> versions = Arrays.asList(GDX_VERSIONS);
+			if(!versions.contains(params.get("gdxVersion"))){
+				System.out.println("Invalid gdxVersion : use one of the following versions");
+				System.out.println(versions);
+				System.exit(-1);
+			}
 		}
-		
-		new GdxSetup().build(params.get("dir"), params.get("name"), params.get("package"), params.get("mainClass"));
-	}
+		if(!params.containsKey("gdxVersion")){
+			params.put("gdxVersion", GDX_VERSIONS[0]);
+			System.out.println("No gdxVersion specified: using default [" + GDX_VERSIONS[0] + "]");
+		}
+		
+		new GdxSetup().build(params.get("dir"), params.get("name"), params.get("package"), params.get("mainClass"), params.get("gdxVersion"));
+	}
 }
\ No newline at end of file
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/android/build.gradle b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/android/build.gradle
index 7f01886..849df04 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/android/build.gradle
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/android/build.gradle
@@ -34,13 +34,13 @@ task copyAndroidNatives() {
         def outputDir = null
         if(jar.name.endsWith("natives-armeabi-v7a.jar")) outputDir = file("libs/armeabi-v7a")
         if(jar.name.endsWith("natives-armeabi.jar")) outputDir = file("libs/armeabi")
-        if(jar.name.endsWith("natives-x86.jar")) outputDir = file("libs/x86")
-        if(outputDir != null) {
+        if(jar.name.endsWith("natives-x86.jar")) outputDir = file("libs/x86")                  
+        if(outputDir != null) {            
             copy {
-                from zipTree(jar)
-                into outputDir
-                include "*.so"
-            }
+				from zipTree(jar)
+				into outputDir
+				include "*.so"
+			}
         }
     }
 }
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/build.gradle b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/build.gradle
index 6e6dec2..10fe18c 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/build.gradle
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/build.gradle
@@ -1,23 +1,14 @@
 buildscript {
-    repositories {
-        maven {
-            url 'https://github.com/steffenschaefer/gwt-gradle-plugin/raw/maven-repo/'
-        }
-        mavenCentral()
-    }
-    dependencies {
-        classpath 'de.richsource.gradle.plugins:gwt-gradle-plugin:0.2'
-        classpath 'com.android.tools.build:gradle:0.6.1+'
-    }
+    repositories { mavenCentral() }
+    dependencies { classpath 'com.android.tools.build:gradle:0.5.+' }
 }
 
 allprojects {
-    apply plugin: "eclipse"
     apply plugin: "idea"
     
     version = "1.0"
     ext.appName = "%APP_NAME%"
-    ext.gdxVersion = "1.0-SNAPSHOT"
+    ext.gdxVersion = "%GDX_VERSION%"
     
     repositories {
         mavenCentral()
@@ -26,6 +17,10 @@ allprojects {
     }
 }
 
+subprojects {
+    apply plugin: "eclipse"    
+}
+
 project(":core") {
     apply plugin: "java"
     
@@ -52,43 +47,8 @@ project(":android") {
 
     dependencies {
         compile project(":core")
-        compile "com.badlogicgames.gdx:gdx-backend-android:$gdxVersion"        
+        compile "com.badlogicgames.gdx:gdx-backend-android:$gdxVersion"
         natives "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-armeabi"
         natives "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-armeabi-v7a"
     }
-}
-
-project(":gwt") {
-    apply plugin: "gwt"
-    apply plugin: "war"
-    webAppDirName = 'webapp'
-
-    dependencies {
-        compile project(":core")
-        compile "com.badlogicgames.gdx:gdx-backend-gwt:$gdxVersion"
-        compile "com.badlogicgames.gdx:gdx:$gdxVersion:sources"
-        compile "com.badlogicgames.gdx:gdx-backend-gwt:$gdxVersion:sources"
-    }
-
-    gwt {
-        gwtVersion='2.5.0' // Should match the gwt version used for building the gwt backend
-
-        maxHeapSize="1G" // Default 256m is not enough for gwt compiler. GWT is HUNGRY
-        minHeapSize="1G"
-
-        src = files(file("src/")) // Needs to be in front of "modules" below.
-        modules '%PACKAGE%.GdxDefinition'
-
-        compiler {
-            strict = true;
-            enableClosureCompiler = true;
-            disableClassMetadata = true;
-            disableCastChecking = true;
-        }
-    }
-}
-
-
-tasks.eclipse.doLast {
-	delete ".project"
 }
\ No newline at end of file
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/core/CoreGdxDefinition b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/core/CoreGdxDefinition
deleted file mode 100644
index e25659d..0000000
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/core/CoreGdxDefinition
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE module PUBLIC "-//Google Inc.//DTD Google Web Toolkit trunk//EN" "http://google-web-toolkit.googlecode.com/svn/trunk/distro-source/core/src/gwt-module.dtd">
-<module>
-	<source path="" />
-</module>
\ No newline at end of file
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gradle/wrapper/gradle-wrapper.properties b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gradle/wrapper/gradle-wrapper.properties
index 009e13d..387ff5e 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gradle/wrapper/gradle-wrapper.properties
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-all.zip
+distributionUrl=http\://services.gradle.org/distributions/gradle-1.7-bin.zip
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gwt/GdxDefinition b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gwt/GdxDefinition
deleted file mode 100644
index 88561f6..0000000
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gwt/GdxDefinition
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE module PUBLIC "-//Google Inc.//DTD Google Web Toolkit trunk//EN" "http://google-web-toolkit.googlecode.com/svn/trunk/distro-source/core/src/gwt-module.dtd">
-<module>
-	<inherits name='com.badlogic.gdx.backends.gdx_backends_gwt' />
-	<inherits name='%PACKAGE%.%MAIN_CLASS%' />
-	<entry-point class='%PACKAGE%.client.GwtLauncher' />
-	<set-configuration-property name="gdx.assetpath" value="../android/assets" />
-</module>
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gwt/build.gradle b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gwt/build.gradle
deleted file mode 100644
index 92d79c4..0000000
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gwt/build.gradle
+++ /dev/null
@@ -1,23 +0,0 @@
-apply plugin: "java"
-apply plugin: "application"
-
-sourceCompatibility = 1.6
-mainClassName = "%PACKAGE%.client.GwtLauncher"
-sourceSets.main.java.srcDirs = [ "src/" ]
-sourceSets.main.resources.srcDirs = [file("../android/assets").getAbsolutePath()]
-
-// Helps gwt find the proper .gwt.xml files.
-sourceSets.main.compileClasspath += files(project(':core').sourceSets.main.allJava.srcDirs)
-
-// idea doesn't like relative paths outside of content root...
-tasks.ideaModule.doFirst {
-    sourceSets.main.resources.srcDirs = []
-}
-
-eclipse.project {
-    name = appName + "-gwt"
-}
-
-run {
-    ignoreExitValue = true
-}
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gwt/src/GwtLauncher b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gwt/src/GwtLauncher
deleted file mode 100644
index ed5ab7f..0000000
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/gwt/src/GwtLauncher
+++ /dev/null
@@ -1,19 +0,0 @@
-package %PACKAGE%.client;
-
-import com.badlogic.gdx.ApplicationListener;
-import com.badlogic.gdx.backends.gwt.GwtApplication;
-import com.badlogic.gdx.backends.gwt.GwtApplicationConfiguration;
-import %PACKAGE%.%MAIN_CLASS%;
-
-public class GwtLauncher extends GwtApplication {
-
-        @Override
-        public GwtApplicationConfiguration getConfig () {
-                return new GwtApplicationConfiguration(480, 320);
-        }
-
-        @Override
-        public ApplicationListener getApplicationListener () {
-                return new %MAIN_CLASS%();
-        }
-}
\ No newline at end of file
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/settings.gradle b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/settings.gradle
index 43bbe44..ba685ed 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/settings.gradle
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/resources/settings.gradle
@@ -1 +1 @@
-include "core", "desktop", "android", "gwt"
\ No newline at end of file
+include "core", "desktop", "android"
\ No newline at end of file
diff --git a/gdx/jni/com.badlogic.gdx.physics.box2d.World.cpp b/gdx/jni/com.badlogic.gdx.physics.box2d.World.cpp
index 7441914..15ec469 100644
--- a/gdx/jni/com.badlogic.gdx.physics.box2d.World.cpp
+++ b/gdx/jni/com.badlogic.gdx.physics.box2d.World.cpp
@@ -166,7 +166,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_setUseDefaultCo
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateBody(JNIEnv* env, jobject object, jlong addr, jint type, jfloat positionX, jfloat positionY, jfloat angle, jfloat linearVelocityX, jfloat linearVelocityY, jfloat angularVelocity, jfloat linearDamping, jfloat angularDamping, jboolean allowSleep, jboolean awake, jboolean fixedRotation, jboolean bullet, jboolean active, jfloat inertiaScale) {
 
 
-//@line:287
+//@line:284
 
 		b2BodyDef bodyDef;
 		bodyDef.type = getBodyType(type);
@@ -193,7 +193,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateBody(
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDestroyBody(JNIEnv* env, jobject object, jlong addr, jlong bodyAddr) {
 
 
-//@line:326
+//@line:323
 
 		b2World* world = (b2World*)addr;
 		b2Body* body = (b2Body*)bodyAddr;
@@ -211,7 +211,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDestroyBody(
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateWheelJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat localAxisAX, jfloat localAxisAY, jboolean enableMotor, jfloat maxMotorTorque, jfloat motorSpeed, jfloat frequencyHz, jfloat dampingRatio) {
 
 
-//@line:425
+//@line:422
 
 		b2World* world = (b2World*)addr;
 		b2WheelJointDef def;
@@ -235,7 +235,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateWheel
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateRopeJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat maxLength) {
 
 
-//@line:444
+//@line:441
 
 		b2World* world = (b2World*)addr;
 		b2RopeJointDef def;
@@ -254,7 +254,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateRopeJ
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateDistanceJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat length, jfloat frequencyHz, jfloat dampingRatio) {
 
 
-//@line:458
+//@line:455
 
 		b2World* world = (b2World*)addr;
 		b2DistanceJointDef def;
@@ -275,7 +275,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateDista
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateFrictionJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat maxForce, jfloat maxTorque) {
 
 
-//@line:474
+//@line:471
 
 		b2World* world = (b2World*)addr;
 		b2FrictionJointDef def;
@@ -294,7 +294,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateFrict
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateGearJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jlong joint1, jlong joint2, jfloat ratio) {
 
 
-//@line:488
+//@line:485
 
 		b2World* world = (b2World*)addr;
 		b2GearJointDef def;
@@ -312,7 +312,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateGearJ
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateMouseJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat targetX, jfloat targetY, jfloat maxForce, jfloat frequencyHz, jfloat dampingRatio) {
 
 
-//@line:501
+//@line:498
 
 		b2World* world = (b2World*)addr;
 		b2MouseJointDef def;
@@ -331,7 +331,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateMouse
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreatePrismaticJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat localAxisAX, jfloat localAxisAY, jfloat referenceAngle, jboolean enableLimit, jfloat lowerTranslation, jfloat upperTranslation, jboolean enableMotor, jfloat maxMotorForce, jfloat motorSpeed) {
 
 
-//@line:517
+//@line:514
 
 		b2World* world = (b2World*)addr;
 		b2PrismaticJointDef def;
@@ -356,7 +356,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreatePrism
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreatePulleyJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat groundAnchorAX, jfloat groundAnchorAY, jfloat groundAnchorBX, jfloat groundAnchorBY, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat lengthA, jfloat lengthB, jfloat ratio) {
 
 
-//@line:538
+//@line:535
 
 		b2World* world = (b2World*)addr;
 		b2PulleyJointDef def;
@@ -379,7 +379,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreatePulle
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateRevoluteJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat referenceAngle, jboolean enableLimit, jfloat lowerAngle, jfloat upperAngle, jboolean enableMotor, jfloat motorSpeed, jfloat maxMotorTorque) {
 
 
-//@line:557
+//@line:554
 
 		b2World* world = (b2World*)addr;
 		b2RevoluteJointDef def;
@@ -403,7 +403,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateRevol
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateWeldJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat referenceAngle) {
 
 
-//@line:576
+//@line:573
 
 		b2World* world = (b2World*)addr;
 		b2WeldJointDef def;
@@ -422,7 +422,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateWeldJ
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDestroyJoint(JNIEnv* env, jobject object, jlong addr, jlong jointAddr) {
 
 
-//@line:599
+//@line:596
 
 		b2World* world = (b2World*)addr;
 		b2Joint* joint = (b2Joint*)jointAddr;
@@ -440,7 +440,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDestroyJoint
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniStep(JNIEnv* env, jobject object, jlong addr, jfloat timeStep, jint velocityIterations, jint positionIterations) {
 
 
-//@line:619
+//@line:616
 
 		b2World* world = (b2World*)addr;
 		CustomContactFilter contactFilter(env, object);
@@ -457,7 +457,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniStep(JNIEnv*
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniClearForces(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:639
+//@line:636
 
 		b2World* world = (b2World*)addr;
 		world->ClearForces();
@@ -468,7 +468,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniClearForces(
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniSetWarmStarting(JNIEnv* env, jobject object, jlong addr, jboolean flag) {
 
 
-//@line:649
+//@line:646
 
 		b2World* world = (b2World*)addr;
 		world->SetWarmStarting(flag);
@@ -479,7 +479,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniSetWarmStart
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniSetContiousPhysics(JNIEnv* env, jobject object, jlong addr, jboolean flag) {
 
 
-//@line:659
+//@line:656
 
 		b2World* world = (b2World*)addr;
 		world->SetContinuousPhysics(flag);
@@ -490,7 +490,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniSetContiousP
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetProxyCount(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:669
+//@line:666
 
 		b2World* world = (b2World*)addr;
 		return world->GetProxyCount();
@@ -501,7 +501,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetProxyCoun
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetBodyCount(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:679
+//@line:676
 
 		b2World* world = (b2World*)addr;
 		return world->GetBodyCount();
@@ -512,7 +512,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetBodyCount
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetJointcount(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:689
+//@line:686
 
 		b2World* world = (b2World*)addr;
 		return world->GetJointCount();
@@ -523,7 +523,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetJointcoun
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetContactCount(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:699
+//@line:696
 
 		b2World* world = (b2World*)addr;
 		return world->GetContactCount();
@@ -534,7 +534,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetContactCo
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniSetGravity(JNIEnv* env, jobject object, jlong addr, jfloat gravityX, jfloat gravityY) {
 
 
-//@line:709
+//@line:706
 
 		b2World* world = (b2World*)addr;
 		world->SetGravity( b2Vec2( gravityX, gravityY ) );
@@ -546,7 +546,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetGravity(J
 	float* gravity = (float*)env->GetPrimitiveArrayCritical(obj_gravity, 0);
 
 
-//@line:725
+//@line:722
 
 		b2World* world = (b2World*)addr;
 		b2Vec2 g = world->GetGravity();
@@ -560,7 +560,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetGravity(J
 JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniIsLocked(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:737
+//@line:734
 
 		b2World* world = (b2World*)addr;
 		return world->IsLocked();
@@ -571,7 +571,7 @@ JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniIsLocked
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniSetAutoClearForces(JNIEnv* env, jobject object, jlong addr, jboolean flag) {
 
 
-//@line:747
+//@line:744
 
 		b2World* world = (b2World*)addr;
 		world->SetAutoClearForces(flag);
@@ -582,7 +582,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniSetAutoClear
 JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetAutoClearForces(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:757
+//@line:754
 
 		b2World* world = (b2World*)addr;
 		return world->GetAutoClearForces();
@@ -593,7 +593,7 @@ JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetAutoC
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniQueryAABB(JNIEnv* env, jobject object, jlong addr, jfloat lowX, jfloat lowY, jfloat upX, jfloat upY) {
 
 
-//@line:775
+//@line:772
 
 		b2World* world = (b2World*)addr;
 		b2AABB aabb;
@@ -610,7 +610,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetContactLi
 	long long* contacts = (long long*)env->GetPrimitiveArrayCritical(obj_contacts, 0);
 
 
-//@line:851
+//@line:848
 
 		b2World* world = (b2World*)addr;
 	
@@ -629,7 +629,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetContactLi
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDispose(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:867
+//@line:864
 
 		b2World* world = (b2World*)(addr);
 		delete world;
@@ -640,7 +640,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDispose(JNIE
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_setVelocityThreshold(JNIEnv* env, jclass clazz, jfloat threshold) {
 
 
-//@line:927
+//@line:924
 
 		b2_velocityThreshold = threshold;
 	
@@ -650,7 +650,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_setVelocityThre
 JNIEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_box2d_World_getVelocityThreshold(JNIEnv* env, jclass clazz) {
 
 
-//@line:932
+//@line:929
 
 		return b2_velocityThreshold;
 	
@@ -660,7 +660,7 @@ JNIEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_box2d_World_getVelocityTh
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniRayCast(JNIEnv* env, jobject object, jlong addr, jfloat aX, jfloat aY, jfloat bX, jfloat bY) {
 
 
-//@line:947
+//@line:944
 
 		b2World *world = (b2World*)addr;
 		CustomRayCastCallback callback( env, object );	
diff --git a/gdx/jni/com.badlogic.gdx.utils.BufferUtils.cpp b/gdx/jni/com.badlogic.gdx.utils.BufferUtils.cpp
index 2ac2696..4d73106 100644
--- a/gdx/jni/com.badlogic.gdx.utils.BufferUtils.cpp
+++ b/gdx/jni/com.badlogic.gdx.utils.BufferUtils.cpp
@@ -1,6 +1,6 @@
 #include <com.badlogic.gdx.utils.BufferUtils.h>
 
-//@line:454
+//@line:374
  
 	#include <stdio.h>
 	#include <stdlib.h>
@@ -9,7 +9,7 @@
 	char* buffer = (char*)(obj_buffer?env->GetDirectBufferAddress(obj_buffer):0);
 
 
-//@line:516
+//@line:436
 
 		free(buffer);
 	 
@@ -19,9 +19,10 @@
 JNIEXPORT jobject JNICALL Java_com_badlogic_gdx_utils_BufferUtils_newDisposableByteBuffer(JNIEnv* env, jclass clazz, jint numBytes) {
 
 
-//@line:520
+//@line:440
 
-		return env->NewDirectByteBuffer((char*)malloc(numBytes), numBytes);
+		char* ptr = (char*)malloc(numBytes);
+		return env->NewDirectByteBuffer(ptr, numBytes);
 	
 
 }
@@ -29,7 +30,7 @@ JNIEXPORT jobject JNICALL Java_com_badlogic_gdx_utils_BufferUtils_newDisposableB
 static inline jlong wrapped_Java_com_badlogic_gdx_utils_BufferUtils_getBufferAddress
 (JNIEnv* env, jclass clazz, jobject obj_buffer, unsigned char* buffer) {
 
-//@line:524
+//@line:445
 
 	    return (jlong) buffer;
 	
@@ -48,7 +49,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_clear(JNIEnv* env
 	char* buffer = (char*)(obj_buffer?env->GetDirectBufferAddress(obj_buffer):0);
 
 
-//@line:529
+//@line:450
 
 		memset(buffer, 0, numBytes);
 	
@@ -60,7 +61,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_copyJni___3FLjava
 	float* src = (float*)env->GetPrimitiveArrayCritical(obj_src, 0);
 
 
-//@line:533
+//@line:454
 
 		memcpy(dst, src + offset, numFloats << 2 );
 	
@@ -73,7 +74,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_copyJni___3BILjav
 	char* src = (char*)env->GetPrimitiveArrayCritical(obj_src, 0);
 
 
-//@line:537
+//@line:458
 
 		memcpy(dst + dstOffset, src + srcOffset, numBytes);
 	
@@ -86,7 +87,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_copyJni___3CILjav
 	unsigned short* src = (unsigned short*)env->GetPrimitiveArrayCritical(obj_src, 0);
 
 
-//@line:541
+//@line:462
 
 		memcpy(dst + dstOffset, src + srcOffset, numBytes);
 	
@@ -99,7 +100,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_copyJni___3SILjav
 	short* src = (short*)env->GetPrimitiveArrayCritical(obj_src, 0);
 
 
-//@line:545
+//@line:466
 
 		memcpy(dst + dstOffset, src + srcOffset, numBytes);
 	 
@@ -112,7 +113,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_copyJni___3IILjav
 	int* src = (int*)env->GetPrimitiveArrayCritical(obj_src, 0);
 
 
-//@line:549
+//@line:470
 
 		memcpy(dst + dstOffset, src + srcOffset, numBytes);
 	
@@ -125,7 +126,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_copyJni___3JILjav
 	long long* src = (long long*)env->GetPrimitiveArrayCritical(obj_src, 0);
 
 
-//@line:553
+//@line:474
 
 		memcpy(dst + dstOffset, src + srcOffset, numBytes);
 	
@@ -138,7 +139,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_copyJni___3FILjav
 	float* src = (float*)env->GetPrimitiveArrayCritical(obj_src, 0);
 
 
-//@line:557
+//@line:478
 
 		memcpy(dst + dstOffset, src + srcOffset, numBytes);
 	
@@ -151,7 +152,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_copyJni___3DILjav
 	double* src = (double*)env->GetPrimitiveArrayCritical(obj_src, 0);
 
 
-//@line:561
+//@line:482
 
 		memcpy(dst + dstOffset, src + srcOffset, numBytes);
 	
@@ -164,7 +165,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_copyJni__Ljava_ni
 	unsigned char* dst = (unsigned char*)(obj_dst?env->GetDirectBufferAddress(obj_dst):0);
 
 
-//@line:565
+//@line:486
 
 		memcpy(dst + dstOffset, src + srcOffset, numBytes);
 	
@@ -172,322 +173,112 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_copyJni__Ljava_ni
 }
 
 
-//@line:569
+//@line:490
 
-	template<size_t n1, size_t n2> void transform(float * const &src, float * const &m, float * const &dst) {}
-	
-	template<> inline void transform<4, 4>(float * const &src, float * const &m, float * const &dst) {
-		const float x = src[0], y = src[1], z = src[2], w = src[3];
-		dst[0] = x * m[ 0] + y * m[ 4] + z * m[ 8] + w * m[12]; 
-		dst[1] = x * m[ 1] + y * m[ 5] + z * m[ 9] + w * m[13];
-		dst[2] = x * m[ 2] + y * m[ 6] + z * m[10] + w * m[14];
-		dst[3] = x * m[ 3] + y * m[ 7] + z * m[11] + w * m[15]; 
-	}
+	template<size_t n1, size_t n2> void transform(float * const &v, const float * const &m) {}
 	
-	template<> inline void transform<3, 4>(float * const &src, float * const &m, float * const &dst) {
-		const float x = src[0], y = src[1], z = src[2];
-		dst[0] = x * m[ 0] + y * m[ 4] + z * m[ 8] + m[12]; 
-		dst[1] = x * m[ 1] + y * m[ 5] + z * m[ 9] + m[13];
-		dst[2] = x * m[ 2] + y * m[ 6] + z * m[10] + m[14]; 
+	template<> inline void transform<4, 4>(float * const &v, const float * const &m) {
+		const float x = v[0], y = v[1], z = v[2], w = v[3];
+		v[0] = x * m[ 0] + y * m[ 4] + z * m[ 8] + w * m[12]; 
+		v[1] = x * m[ 1] + y * m[ 5] + z * m[ 9] + w * m[13];
+		v[2] = x * m[ 2] + y * m[ 6] + z * m[10] + w * m[14];
+		v[3] = x * m[ 3] + y * m[ 7] + z * m[11] + w * m[15]; 
 	}
 	
-	template<> inline void transform<2, 4>(float * const &src, float * const &m, float * const &dst) {
-		const float x = src[0], y = src[1];
-		dst[0] = x * m[ 0] + y * m[ 4] + m[12]; 
-		dst[1] = x * m[ 1] + y * m[ 5] + m[13]; 
+	template<> inline void transform<3, 4>(float * const &v, const float * const &m) {
+		const float x = v[0], y = v[1], z = v[2];
+		v[0] = x * m[ 0] + y * m[ 4] + z * m[ 8] + m[12]; 
+		v[1] = x * m[ 1] + y * m[ 5] + z * m[ 9] + m[13];
+		v[2] = x * m[ 2] + y * m[ 6] + z * m[10] + m[14]; 
 	}
 	
-	template<> inline void transform<3, 3>(float * const &src, float * const &m, float * const &dst) {
-		const float x = src[0], y = src[1], z = src[2];
-		dst[0] = x * m[0] + y * m[3] + z * m[6]; 
-		dst[1] = x * m[1] + y * m[4] + z * m[7];
-		dst[2] = x * m[2] + y * m[5] + z * m[8]; 
+	template<> inline void transform<2, 4>(float * const &v, const float * const &m) {
+		const float x = v[0], y = v[1], z = v[2], w = v[3];
+		v[0] = x * m[ 0] + y * m[ 4] + m[12]; 
+		v[1] = x * m[ 1] + y * m[ 5] + m[13]; 
 	}
 	
-	template<> inline void transform<2, 3>(float * const &src, float * const &m, float * const &dst) {
-		const float x = src[0], y = src[1];
-		dst[0] = x * m[0] + y * m[3] + m[6]; 
-		dst[1] = x * m[1] + y * m[4] + m[7]; 
+	template<> inline void transform<3, 3>(float * const &v, const float * const &m) {
+		const float x = v[0], y = v[1], z = v[2];
+		v[0] = x * m[0] + y * m[3] + z * m[6]; 
+		v[1] = x * m[1] + y * m[4] + z * m[7];
+		v[2] = x * m[2] + y * m[5] + z * m[8]; 
 	}
 	
-	template<size_t n1, size_t n2> void transform(float * const &v, int const &stride, int const &count, float * const &m, int offset) {
-		for (int i = 0; i < count; i++) {
-			transform<n1, n2>(&v[offset], m, &v[offset]);
-			offset += stride;
-		}
+	template<> inline void transform<2, 3>(float * const &v, const float * const &m) {
+		const float x = v[0], y = v[1];
+		v[0] = x * m[0] + y * m[3] + m[6]; 
+		v[1] = x * m[1] + y * m[4] + m[7]; 
 	}
 	
-	template<size_t n1, size_t n2> void transform(float * const &v, int const &stride, unsigned short * const &indices, int const &count, float * const &m, int offset) {
+	template<size_t n1, size_t n2> void transform(float * const &v, int offset, int const &stride, int const &count, const float * const &m) {
 		for (int i = 0; i < count; i++) {
-			transform<n1, n2>(&v[offset], m, &v[offset]);
+			transform<n1, n2>(&v[offset], m);
 			offset += stride;
 		}
 	}
-	
-	inline bool compare(float * const &lhs, float * const & rhs, const unsigned int &size, const float &epsilon) {
-   	for (unsigned int i = 0; i < size; i++)
-   		if ((*(unsigned int*)&lhs[i] != *(unsigned int*)&rhs[i]) && ((lhs[i] > rhs[i] ? lhs[i] - rhs[i] : rhs[i] - lhs[i]) > epsilon))
-         	return false;
-		return true;
-	}
-	
-	long find(float * const &vertex, const unsigned int &size, float * const &vertices, const unsigned int &count, const float &epsilon) {
-		for (unsigned int i = 0; i < count; i++)
-			if (compare(&vertices[i*size], vertex, size, epsilon))
-				return (long)i;
-		return -1;
-	}
-
-	inline bool compare(float * const &lhs, float * const & rhs, const unsigned int &size) {
-   	for (unsigned int i = 0; i < size; i++)
-      	if ((*(unsigned int*)&lhs[i] != *(unsigned int*)&rhs[i]) && lhs[i] != rhs[i])
-         	return false;
-		return true;
-	}
-	
-	long find(float * const &vertex, const unsigned int &size, float * const &vertices, const unsigned int &count) {
-		for (unsigned int i = 0; i < count; i++)
-			if (compare(&vertices[i*size], vertex, size))
-				return (long)i;
-		return -1;
-	}
-
-	inline unsigned int calcHash(float * const &vertex, const unsigned int &size) {
-		unsigned int result = 0;
-		for (unsigned int i = 0; i < size; ++i)
-			result += ((*((unsigned int *)&vertex[i])) & 0xffffff80) >> (i & 0x7);
-		return result & 0x7fffffff;
-	}
-	
-	long find(float * const &vertex, const unsigned int &size, float * const &vertices, unsigned int * const &hashes, const unsigned int &count) {
-		const unsigned int hash = calcHash(vertex, size);
-		for (unsigned int i = 0; i < count; i++)
-			if (hashes[i] == hash && compare(&vertices[i*size], vertex, size))
-				return (long)i;
-		return -1;
-	}
-	JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_transformV4M4Jni(JNIEnv* env, jclass clazz, jobject obj_data, jint strideInBytes, jint count, jfloatArray obj_matrix, jint offsetInBytes) {
+	JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_transformV4M4Jni(JNIEnv* env, jclass clazz, jobject obj_data, jint offsetInBytes, jint strideInBytes, jint count, jfloatArray obj_matrix) {
 	unsigned char* data = (unsigned char*)(obj_data?env->GetDirectBufferAddress(obj_data):0);
 	float* matrix = (float*)env->GetPrimitiveArrayCritical(obj_matrix, 0);
 
 
-//@line:664
+//@line:535
 
-		transform<4, 4>((float*)data, strideInBytes / 4, count, (float*)matrix, offsetInBytes / 4);  
+		transform<4, 4>((float*)data, offsetInBytes / 4, strideInBytes / 4, count, (float*)matrix);  
 	
 	env->ReleasePrimitiveArrayCritical(obj_matrix, matrix, 0);
 
 }
 
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_transformV3M4Jni(JNIEnv* env, jclass clazz, jobject obj_data, jint strideInBytes, jint count, jfloatArray obj_matrix, jint offsetInBytes) {
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_transformV3M4Jni(JNIEnv* env, jclass clazz, jobject obj_data, jint offsetInBytes, jint strideInBytes, jint count, jfloatArray obj_matrix) {
 	unsigned char* data = (unsigned char*)(obj_data?env->GetDirectBufferAddress(obj_data):0);
 	float* matrix = (float*)env->GetPrimitiveArrayCritical(obj_matrix, 0);
 
 
-//@line:668
+//@line:539
 
-		transform<3, 4>((float*)data, strideInBytes / 4, count, (float*)matrix, offsetInBytes / 4);
+		transform<3, 4>((float*)data, offsetInBytes / 4, strideInBytes / 4, count, (float*)matrix);
 	
 	env->ReleasePrimitiveArrayCritical(obj_matrix, matrix, 0);
 
 }
 
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_transformV2M4Jni(JNIEnv* env, jclass clazz, jobject obj_data, jint strideInBytes, jint count, jfloatArray obj_matrix, jint offsetInBytes) {
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_transformV2M4Jni(JNIEnv* env, jclass clazz, jobject obj_data, jint offsetInBytes, jint strideInBytes, jint count, jfloatArray obj_matrix) {
 	unsigned char* data = (unsigned char*)(obj_data?env->GetDirectBufferAddress(obj_data):0);
 	float* matrix = (float*)env->GetPrimitiveArrayCritical(obj_matrix, 0);
 
 
-//@line:672
+//@line:543
 
-		transform<2, 4>((float*)data, strideInBytes / 4, count, (float*)matrix, offsetInBytes / 4);
+		transform<2, 4>((float*)data, offsetInBytes / 4, strideInBytes / 4, count, (float*)matrix);
 	
 	env->ReleasePrimitiveArrayCritical(obj_matrix, matrix, 0);
 
 }
 
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_transformV3M3Jni(JNIEnv* env, jclass clazz, jobject obj_data, jint strideInBytes, jint count, jfloatArray obj_matrix, jint offsetInBytes) {
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_transformV3M3Jni(JNIEnv* env, jclass clazz, jobject obj_data, jint offsetInBytes, jint strideInBytes, jint count, jfloatArray obj_matrix) {
 	unsigned char* data = (unsigned char*)(obj_data?env->GetDirectBufferAddress(obj_data):0);
 	float* matrix = (float*)env->GetPrimitiveArrayCritical(obj_matrix, 0);
 
 
-//@line:676
+//@line:547
 
-		transform<3, 3>((float*)data, strideInBytes / 4, count, (float*)matrix, offsetInBytes / 4);
+		transform<3, 3>((float*)data, offsetInBytes / 4, strideInBytes / 4, count, (float*)matrix);
 	
 	env->ReleasePrimitiveArrayCritical(obj_matrix, matrix, 0);
 
 }
 
-JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_transformV2M3Jni(JNIEnv* env, jclass clazz, jobject obj_data, jint strideInBytes, jint count, jfloatArray obj_matrix, jint offsetInBytes) {
+JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_transformV2M3Jni(JNIEnv* env, jclass clazz, jobject obj_data, jint offsetInBytes, jint strideInBytes, jint count, jfloatArray obj_matrix) {
 	unsigned char* data = (unsigned char*)(obj_data?env->GetDirectBufferAddress(obj_data):0);
 	float* matrix = (float*)env->GetPrimitiveArrayCritical(obj_matrix, 0);
 
 
-//@line:680
+//@line:551
 
-		transform<2, 3>((float*)data, strideInBytes / 4, count, (float*)matrix, offsetInBytes / 4);
+		transform<2, 3>((float*)data, offsetInBytes / 4, strideInBytes / 4, count, (float*)matrix);
 	
 	env->ReleasePrimitiveArrayCritical(obj_matrix, matrix, 0);
 
 }
 
-static inline jlong wrapped_Java_com_badlogic_gdx_utils_BufferUtils_find__Ljava_nio_Buffer_2IILjava_nio_Buffer_2II
-(JNIEnv* env, jclass clazz, jobject obj_vertex, jint vertexOffsetInBytes, jint strideInBytes, jobject obj_vertices, jint verticesOffsetInBytes, jint numVertices, unsigned char* vertex, unsigned char* vertices) {
-
-//@line:692
-
-		return find((float *)&vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices);
-	
-}
-
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_utils_BufferUtils_find__Ljava_nio_Buffer_2IILjava_nio_Buffer_2II(JNIEnv* env, jclass clazz, jobject obj_vertex, jint vertexOffsetInBytes, jint strideInBytes, jobject obj_vertices, jint verticesOffsetInBytes, jint numVertices) {
-	unsigned char* vertex = (unsigned char*)(obj_vertex?env->GetDirectBufferAddress(obj_vertex):0);
-	unsigned char* vertices = (unsigned char*)(obj_vertices?env->GetDirectBufferAddress(obj_vertices):0);
-
-	jlong JNI_returnValue = wrapped_Java_com_badlogic_gdx_utils_BufferUtils_find__Ljava_nio_Buffer_2IILjava_nio_Buffer_2II(env, clazz, obj_vertex, vertexOffsetInBytes, strideInBytes, obj_vertices, verticesOffsetInBytes, numVertices, vertex, vertices);
-
-
-	return JNI_returnValue;
-}
-
-static inline jlong wrapped_Java_com_badlogic_gdx_utils_BufferUtils_find___3FIILjava_nio_Buffer_2II
-(JNIEnv* env, jclass clazz, jfloatArray obj_vertex, jint vertexOffsetInBytes, jint strideInBytes, jobject obj_vertices, jint verticesOffsetInBytes, jint numVertices, unsigned char* vertices, float* vertex) {
-
-//@line:696
-
-		return find((float *)&vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices);
-	
-}
-
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_utils_BufferUtils_find___3FIILjava_nio_Buffer_2II(JNIEnv* env, jclass clazz, jfloatArray obj_vertex, jint vertexOffsetInBytes, jint strideInBytes, jobject obj_vertices, jint verticesOffsetInBytes, jint numVertices) {
-	unsigned char* vertices = (unsigned char*)(obj_vertices?env->GetDirectBufferAddress(obj_vertices):0);
-	float* vertex = (float*)env->GetPrimitiveArrayCritical(obj_vertex, 0);
-
-	jlong JNI_returnValue = wrapped_Java_com_badlogic_gdx_utils_BufferUtils_find___3FIILjava_nio_Buffer_2II(env, clazz, obj_vertex, vertexOffsetInBytes, strideInBytes, obj_vertices, verticesOffsetInBytes, numVertices, vertices, vertex);
-
-	env->ReleasePrimitiveArrayCritical(obj_vertex, vertex, 0);
-
-	return JNI_returnValue;
-}
-
-static inline jlong wrapped_Java_com_badlogic_gdx_utils_BufferUtils_find__Ljava_nio_Buffer_2II_3FII
-(JNIEnv* env, jclass clazz, jobject obj_vertex, jint vertexOffsetInBytes, jint strideInBytes, jfloatArray obj_vertices, jint verticesOffsetInBytes, jint numVertices, unsigned char* vertex, float* vertices) {
-
-//@line:700
-
-		return find((float *)&vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices);
-	
-}
-
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_utils_BufferUtils_find__Ljava_nio_Buffer_2II_3FII(JNIEnv* env, jclass clazz, jobject obj_vertex, jint vertexOffsetInBytes, jint strideInBytes, jfloatArray obj_vertices, jint verticesOffsetInBytes, jint numVertices) {
-	unsigned char* vertex = (unsigned char*)(obj_vertex?env->GetDirectBufferAddress(obj_vertex):0);
-	float* vertices = (float*)env->GetPrimitiveArrayCritical(obj_vertices, 0);
-
-	jlong JNI_returnValue = wrapped_Java_com_badlogic_gdx_utils_BufferUtils_find__Ljava_nio_Buffer_2II_3FII(env, clazz, obj_vertex, vertexOffsetInBytes, strideInBytes, obj_vertices, verticesOffsetInBytes, numVertices, vertex, vertices);
-
-	env->ReleasePrimitiveArrayCritical(obj_vertices, vertices, 0);
-
-	return JNI_returnValue;
-}
-
-static inline jlong wrapped_Java_com_badlogic_gdx_utils_BufferUtils_find___3FII_3FII
-(JNIEnv* env, jclass clazz, jfloatArray obj_vertex, jint vertexOffsetInBytes, jint strideInBytes, jfloatArray obj_vertices, jint verticesOffsetInBytes, jint numVertices, float* vertex, float* vertices) {
-
-//@line:704
-
-		return find((float *)&vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices);
-	
-}
-
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_utils_BufferUtils_find___3FII_3FII(JNIEnv* env, jclass clazz, jfloatArray obj_vertex, jint vertexOffsetInBytes, jint strideInBytes, jfloatArray obj_vertices, jint verticesOffsetInBytes, jint numVertices) {
-	float* vertex = (float*)env->GetPrimitiveArrayCritical(obj_vertex, 0);
-	float* vertices = (float*)env->GetPrimitiveArrayCritical(obj_vertices, 0);
-
-	jlong JNI_returnValue = wrapped_Java_com_badlogic_gdx_utils_BufferUtils_find___3FII_3FII(env, clazz, obj_vertex, vertexOffsetInBytes, strideInBytes, obj_vertices, verticesOffsetInBytes, numVertices, vertex, vertices);
-
-	env->ReleasePrimitiveArrayCritical(obj_vertex, vertex, 0);
-	env->ReleasePrimitiveArrayCritical(obj_vertices, vertices, 0);
-
-	return JNI_returnValue;
-}
-
-static inline jlong wrapped_Java_com_badlogic_gdx_utils_BufferUtils_find__Ljava_nio_Buffer_2IILjava_nio_Buffer_2IIF
-(JNIEnv* env, jclass clazz, jobject obj_vertex, jint vertexOffsetInBytes, jint strideInBytes, jobject obj_vertices, jint verticesOffsetInBytes, jint numVertices, jfloat epsilon, unsigned char* vertex, unsigned char* vertices) {
-
-//@line:708
-
-		return find((float *)&vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices, epsilon);
-	
-}
-
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_utils_BufferUtils_find__Ljava_nio_Buffer_2IILjava_nio_Buffer_2IIF(JNIEnv* env, jclass clazz, jobject obj_vertex, jint vertexOffsetInBytes, jint strideInBytes, jobject obj_vertices, jint verticesOffsetInBytes, jint numVertices, jfloat epsilon) {
-	unsigned char* vertex = (unsigned char*)(obj_vertex?env->GetDirectBufferAddress(obj_vertex):0);
-	unsigned char* vertices = (unsigned char*)(obj_vertices?env->GetDirectBufferAddress(obj_vertices):0);
-
-	jlong JNI_returnValue = wrapped_Java_com_badlogic_gdx_utils_BufferUtils_find__Ljava_nio_Buffer_2IILjava_nio_Buffer_2IIF(env, clazz, obj_vertex, vertexOffsetInBytes, strideInBytes, obj_vertices, verticesOffsetInBytes, numVertices, epsilon, vertex, vertices);
-
-
-	return JNI_returnValue;
-}
-
-static inline jlong wrapped_Java_com_badlogic_gdx_utils_BufferUtils_find___3FIILjava_nio_Buffer_2IIF
-(JNIEnv* env, jclass clazz, jfloatArray obj_vertex, jint vertexOffsetInBytes, jint strideInBytes, jobject obj_vertices, jint verticesOffsetInBytes, jint numVertices, jfloat epsilon, unsigned char* vertices, float* vertex) {
-
-//@line:712
-
-		return find((float *)&vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices, epsilon);
-	
-}
-
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_utils_BufferUtils_find___3FIILjava_nio_Buffer_2IIF(JNIEnv* env, jclass clazz, jfloatArray obj_vertex, jint vertexOffsetInBytes, jint strideInBytes, jobject obj_vertices, jint verticesOffsetInBytes, jint numVertices, jfloat epsilon) {
-	unsigned char* vertices = (unsigned char*)(obj_vertices?env->GetDirectBufferAddress(obj_vertices):0);
-	float* vertex = (float*)env->GetPrimitiveArrayCritical(obj_vertex, 0);
-
-	jlong JNI_returnValue = wrapped_Java_com_badlogic_gdx_utils_BufferUtils_find___3FIILjava_nio_Buffer_2IIF(env, clazz, obj_vertex, vertexOffsetInBytes, strideInBytes, obj_vertices, verticesOffsetInBytes, numVertices, epsilon, vertices, vertex);
-
-	env->ReleasePrimitiveArrayCritical(obj_vertex, vertex, 0);
-
-	return JNI_returnValue;
-}
-
-static inline jlong wrapped_Java_com_badlogic_gdx_utils_BufferUtils_find__Ljava_nio_Buffer_2II_3FIIF
-(JNIEnv* env, jclass clazz, jobject obj_vertex, jint vertexOffsetInBytes, jint strideInBytes, jfloatArray obj_vertices, jint verticesOffsetInBytes, jint numVertices, jfloat epsilon, unsigned char* vertex, float* vertices) {
-
-//@line:716
-
-		return find((float *)&vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices, epsilon);
-	
-}
-
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_utils_BufferUtils_find__Ljava_nio_Buffer_2II_3FIIF(JNIEnv* env, jclass clazz, jobject obj_vertex, jint vertexOffsetInBytes, jint strideInBytes, jfloatArray obj_vertices, jint verticesOffsetInBytes, jint numVertices, jfloat epsilon) {
-	unsigned char* vertex = (unsigned char*)(obj_vertex?env->GetDirectBufferAddress(obj_vertex):0);
-	float* vertices = (float*)env->GetPrimitiveArrayCritical(obj_vertices, 0);
-
-	jlong JNI_returnValue = wrapped_Java_com_badlogic_gdx_utils_BufferUtils_find__Ljava_nio_Buffer_2II_3FIIF(env, clazz, obj_vertex, vertexOffsetInBytes, strideInBytes, obj_vertices, verticesOffsetInBytes, numVertices, epsilon, vertex, vertices);
-
-	env->ReleasePrimitiveArrayCritical(obj_vertices, vertices, 0);
-
-	return JNI_returnValue;
-}
-
-static inline jlong wrapped_Java_com_badlogic_gdx_utils_BufferUtils_find___3FII_3FIIF
-(JNIEnv* env, jclass clazz, jfloatArray obj_vertex, jint vertexOffsetInBytes, jint strideInBytes, jfloatArray obj_vertices, jint verticesOffsetInBytes, jint numVertices, jfloat epsilon, float* vertex, float* vertices) {
-
-//@line:720
-
-		return find((float *)&vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices, epsilon);
-	
-}
-
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_utils_BufferUtils_find___3FII_3FIIF(JNIEnv* env, jclass clazz, jfloatArray obj_vertex, jint vertexOffsetInBytes, jint strideInBytes, jfloatArray obj_vertices, jint verticesOffsetInBytes, jint numVertices, jfloat epsilon) {
-	float* vertex = (float*)env->GetPrimitiveArrayCritical(obj_vertex, 0);
-	float* vertices = (float*)env->GetPrimitiveArrayCritical(obj_vertices, 0);
-
-	jlong JNI_returnValue = wrapped_Java_com_badlogic_gdx_utils_BufferUtils_find___3FII_3FIIF(env, clazz, obj_vertex, vertexOffsetInBytes, strideInBytes, obj_vertices, verticesOffsetInBytes, numVertices, epsilon, vertex, vertices);
-
-	env->ReleasePrimitiveArrayCritical(obj_vertex, vertex, 0);
-	env->ReleasePrimitiveArrayCritical(obj_vertices, vertices, 0);
-
-	return JNI_returnValue;
-}
-
diff --git a/gdx/jni/com.badlogic.gdx.utils.BufferUtils.h b/gdx/jni/com.badlogic.gdx.utils.BufferUtils.h
index 510f453..591d699 100644
--- a/gdx/jni/com.badlogic.gdx.utils.BufferUtils.h
+++ b/gdx/jni/com.badlogic.gdx.utils.BufferUtils.h
@@ -114,106 +114,42 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_copyJni__Ljava_ni
 /*
  * Class:     com_badlogic_gdx_utils_BufferUtils
  * Method:    transformV4M4Jni
- * Signature: (Ljava/nio/Buffer;II[FI)V
+ * Signature: (Ljava/nio/Buffer;III[F)V
  */
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_transformV4M4Jni
-  (JNIEnv *, jclass, jobject, jint, jint, jfloatArray, jint);
+  (JNIEnv *, jclass, jobject, jint, jint, jint, jfloatArray);
 
 /*
  * Class:     com_badlogic_gdx_utils_BufferUtils
  * Method:    transformV3M4Jni
- * Signature: (Ljava/nio/Buffer;II[FI)V
+ * Signature: (Ljava/nio/Buffer;III[F)V
  */
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_transformV3M4Jni
-  (JNIEnv *, jclass, jobject, jint, jint, jfloatArray, jint);
+  (JNIEnv *, jclass, jobject, jint, jint, jint, jfloatArray);
 
 /*
  * Class:     com_badlogic_gdx_utils_BufferUtils
  * Method:    transformV2M4Jni
- * Signature: (Ljava/nio/Buffer;II[FI)V
+ * Signature: (Ljava/nio/Buffer;III[F)V
  */
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_transformV2M4Jni
-  (JNIEnv *, jclass, jobject, jint, jint, jfloatArray, jint);
+  (JNIEnv *, jclass, jobject, jint, jint, jint, jfloatArray);
 
 /*
  * Class:     com_badlogic_gdx_utils_BufferUtils
  * Method:    transformV3M3Jni
- * Signature: (Ljava/nio/Buffer;II[FI)V
+ * Signature: (Ljava/nio/Buffer;III[F)V
  */
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_transformV3M3Jni
-  (JNIEnv *, jclass, jobject, jint, jint, jfloatArray, jint);
+  (JNIEnv *, jclass, jobject, jint, jint, jint, jfloatArray);
 
 /*
  * Class:     com_badlogic_gdx_utils_BufferUtils
  * Method:    transformV2M3Jni
- * Signature: (Ljava/nio/Buffer;II[FI)V
+ * Signature: (Ljava/nio/Buffer;III[F)V
  */
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_utils_BufferUtils_transformV2M3Jni
-  (JNIEnv *, jclass, jobject, jint, jint, jfloatArray, jint);
-
-/*
- * Class:     com_badlogic_gdx_utils_BufferUtils
- * Method:    find
- * Signature: (Ljava/nio/Buffer;IILjava/nio/Buffer;II)J
- */
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_utils_BufferUtils_find__Ljava_nio_Buffer_2IILjava_nio_Buffer_2II
-  (JNIEnv *, jclass, jobject, jint, jint, jobject, jint, jint);
-
-/*
- * Class:     com_badlogic_gdx_utils_BufferUtils
- * Method:    find
- * Signature: ([FIILjava/nio/Buffer;II)J
- */
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_utils_BufferUtils_find___3FIILjava_nio_Buffer_2II
-  (JNIEnv *, jclass, jfloatArray, jint, jint, jobject, jint, jint);
-
-/*
- * Class:     com_badlogic_gdx_utils_BufferUtils
- * Method:    find
- * Signature: (Ljava/nio/Buffer;II[FII)J
- */
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_utils_BufferUtils_find__Ljava_nio_Buffer_2II_3FII
-  (JNIEnv *, jclass, jobject, jint, jint, jfloatArray, jint, jint);
-
-/*
- * Class:     com_badlogic_gdx_utils_BufferUtils
- * Method:    find
- * Signature: ([FII[FII)J
- */
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_utils_BufferUtils_find___3FII_3FII
-  (JNIEnv *, jclass, jfloatArray, jint, jint, jfloatArray, jint, jint);
-
-/*
- * Class:     com_badlogic_gdx_utils_BufferUtils
- * Method:    find
- * Signature: (Ljava/nio/Buffer;IILjava/nio/Buffer;IIF)J
- */
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_utils_BufferUtils_find__Ljava_nio_Buffer_2IILjava_nio_Buffer_2IIF
-  (JNIEnv *, jclass, jobject, jint, jint, jobject, jint, jint, jfloat);
-
-/*
- * Class:     com_badlogic_gdx_utils_BufferUtils
- * Method:    find
- * Signature: ([FIILjava/nio/Buffer;IIF)J
- */
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_utils_BufferUtils_find___3FIILjava_nio_Buffer_2IIF
-  (JNIEnv *, jclass, jfloatArray, jint, jint, jobject, jint, jint, jfloat);
-
-/*
- * Class:     com_badlogic_gdx_utils_BufferUtils
- * Method:    find
- * Signature: (Ljava/nio/Buffer;II[FIIF)J
- */
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_utils_BufferUtils_find__Ljava_nio_Buffer_2II_3FIIF
-  (JNIEnv *, jclass, jobject, jint, jint, jfloatArray, jint, jint, jfloat);
-
-/*
- * Class:     com_badlogic_gdx_utils_BufferUtils
- * Method:    find
- * Signature: ([FII[FIIF)J
- */
-JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_utils_BufferUtils_find___3FII_3FIIF
-  (JNIEnv *, jclass, jfloatArray, jint, jint, jfloatArray, jint, jint, jfloat);
+  (JNIEnv *, jclass, jobject, jint, jint, jint, jfloatArray);
 
 #ifdef __cplusplus
 }
diff --git a/gdx/src/com/badlogic/gdx/files/FileHandle.java b/gdx/src/com/badlogic/gdx/files/FileHandle.java
index 7614cc3..64a1824 100644
--- a/gdx/src/com/badlogic/gdx/files/FileHandle.java
+++ b/gdx/src/com/badlogic/gdx/files/FileHandle.java
@@ -188,7 +188,6 @@ public class FileHandle {
 	}
 
 	/** Reads the entire file into a string using the specified charset.
-	 * @param charset If null the default charset is used.
 	 * @throws GdxRuntimeException if the file handle represents a directory, doesn't exist, or could not be read. */
 	public String readString (String charset) {
 		StringBuilder output = new StringBuilder(estimateLength());
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFont.java b/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFont.java
index d89ca1e..76da653 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFont.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFont.java
@@ -319,7 +319,7 @@ public class BitmapFont implements Disposable {
 	/** Returns the bounds of the specified text. Note the returned TextBounds instance is reused.
 	 * @see #getBounds(CharSequence, int, int, TextBounds) */
 	public TextBounds getBounds (CharSequence str) {
-		return getBounds(str, 0, str.length(), cache.getBounds());
+		return getBounds(str, 0, str.length());
 	}
 
 	/** Returns the bounds of the specified text.
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java b/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java
index 598caff..f90d2d7 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java
@@ -40,13 +40,16 @@ public class BitmapFontCache {
 
 	private float x, y;
 	private float color = Color.WHITE.toFloatBits();
-	private final Color tempColor = new Color(1, 1, 1, 1);
+	private final Color tempColor = new Color(Color.WHITE);
 	private final TextBounds textBounds = new TextBounds();
 	private boolean integer = true;
+	
 	private int glyphCount = 0;
 
-	/** An array for each page containing an entry for each glyph from that page, where the entry is the index of the character in
-	 * the full text being cached. */
+	// For multi-page fonts, the vertices are not laid out in order.
+	// This means that we have no frame of reference for setColor(Color, int, int)
+	// since the "start" and "end" indices will not work here.
+	// So for multi-page fonts, we need to store the INDEX of the glyph in terms of the full string
 	private IntArray[] glyphIndices;
 
 	public BitmapFontCache (BitmapFont font) {
@@ -59,12 +62,13 @@ public class BitmapFontCache {
 	public BitmapFontCache (BitmapFont font, boolean integer) {
 		this.font = font;
 		this.integer = integer;
-
+		
 		int regionsLength = font.regions.length;
-		if (regionsLength == 0) throw new IllegalArgumentException("The specified font must contain at least 1 texture page");
-
+		if (regionsLength == 0)
+			throw new IllegalArgumentException("The specified font must contain at least 1 texture page");
+		
 		this.vertexData = new float[regionsLength][];
-
+		
 		this.idx = new int[regionsLength];
 		int vertexDataLength = vertexData.length;
 		if (vertexDataLength > 1) { // if we have multiple pages...
@@ -106,8 +110,9 @@ public class BitmapFontCache {
 		}
 	}
 
-	/** Sets the color of all text currently in the cache. Does not affect subsequently added text. */
-	public void setColors (float color) {
+	public void setColor (float color) {
+		if (color == this.color) return;
+		this.color = color;
 		for (int j = 0, length = vertexData.length; j < length; j++) {
 			float[] vertices = vertexData[j];
 			for (int i = 2, n = idx[j]; i < n; i += 5)
@@ -115,9 +120,10 @@ public class BitmapFontCache {
 		}
 	}
 
-	/** Sets the color of all text currently in the cache. Does not affect subsequently added text. */
-	public void setColors (Color tint) {
+	public void setColor (Color tint) {
 		final float color = tint.toFloatBits();
+		if (color == this.color) return;
+		this.color = color;
 		for (int j = 0, length = vertexData.length; j < length; j++) {
 			float[] vertices = vertexData[j];
 			for (int i = 2, n = idx[j]; i < n; i += 5)
@@ -125,10 +131,11 @@ public class BitmapFontCache {
 		}
 	}
 
-	/** Sets the color of all text currently in the cache. Does not affect subsequently added text. */
-	public void setColors (float r, float g, float b, float a) {
+	public void setColor (float r, float g, float b, float a) {
 		int intBits = ((int)(255 * a) << 24) | ((int)(255 * b) << 16) | ((int)(255 * g) << 8) | ((int)(255 * r));
 		float color = NumberUtils.intToFloatColor(intBits);
+		if (color == this.color) return;
+		this.color = color;
 		for (int j = 0, length = vertexData.length; j < length; j++) {
 			float[] vertices = vertexData[j];
 			for (int i = 2, n = idx[j]; i < n; i += 5)
@@ -138,7 +145,7 @@ public class BitmapFontCache {
 
 	/** Sets the color of the specified characters. This may only be called after {@link #setText(CharSequence, float, float)} and
 	 * is reset every time setText is called. */
-	public void setColors (Color tint, int start, int end) {
+	public void setColor (Color tint, int start, int end) {
 		final float color = tint.toFloatBits();
 
 		if (vertexData.length == 1) { // only one page...
@@ -171,36 +178,10 @@ public class BitmapFontCache {
 		}
 	}
 
-	/** Sets the color of subsequently added text. Does not affect text currently in the cache. */
-	public void setColor (Color tint) {
-		color = tint.toFloatBits();
-	}
-
-	/** Sets the color of subsequently added text. Does not affect text currently in the cache. */
-	public void setColor (float r, float g, float b, float a) {
-		int intBits = (int)(255 * a) << 24 | (int)(255 * b) << 16 | (int)(255 * g) << 8 | (int)(255 * r);
-		color = NumberUtils.intToFloatColor(intBits);
-	}
-
-	/** Sets the color of subsequently added text. Does not affect text currently in the cache. */
-	public void setColor (float color) {
-		this.color = color;
-	}
-
-	public Color getColor () {
-		int intBits = NumberUtils.floatToIntColor(color);
-		Color color = tempColor;
-		color.r = (intBits & 0xff) / 255f;
-		color.g = ((intBits >>> 8) & 0xff) / 255f;
-		color.b = ((intBits >>> 16) & 0xff) / 255f;
-		color.a = ((intBits >>> 24) & 0xff) / 255f;
-		return color;
-	}
-
 	public void draw (Batch spriteBatch) {
 		TextureRegion[] regions = font.getRegions();
 		for (int j = 0, n = vertexData.length; j < n; j++) {
-			if (idx[j] >= 0) { // ignore if this texture has no glyphs
+			if (idx[j] >= 0) { //ignore if this texture has no glyphs
 				float[] vertices = vertexData[j];
 				spriteBatch.draw(regions[j].getTexture(), vertices, 0, idx[j]);
 			}
@@ -260,10 +241,21 @@ public class BitmapFontCache {
 		Color color = getColor();
 		float oldAlpha = color.a;
 		color.a *= alphaModulation;
-		setColors(color);
+		setColor(color);
 		draw(spriteBatch);
 		color.a = oldAlpha;
-		setColors(color);
+		setColor(color);
+	}
+
+	public Color getColor () {
+		float floatBits = color;
+		int intBits = NumberUtils.floatToIntColor(color);
+		Color color = tempColor;
+		color.r = (intBits & 0xff) / 255f;
+		color.g = ((intBits >>> 8) & 0xff) / 255f;
+		color.b = ((intBits >>> 16) & 0xff) / 255f;
+		color.a = ((intBits >>> 24) & 0xff) / 255f;
+		return color;
 	}
 
 	/** Removes all glyphs in the cache. */
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteBatch.java b/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteBatch.java
index d084d53..0956bc6 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteBatch.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteBatch.java
@@ -237,7 +237,7 @@ public class SpriteBatch implements Batch {
 	@Override
 	public Color getColor () {
 		int intBits = NumberUtils.floatToIntColor(color);
-		Color color = tempColor;
+		Color color = this.tempColor;
 		color.r = (intBits & 0xff) / 255f;
 		color.g = ((intBits >>> 8) & 0xff) / 255f;
 		color.b = ((intBits >>> 16) & 0xff) / 255f;
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/Renderable.java b/gdx/src/com/badlogic/gdx/graphics/g3d/Renderable.java
index 042c620..16a290b 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/Renderable.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/Renderable.java
@@ -18,84 +18,49 @@ package com.badlogic.gdx.graphics.g3d;
 
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.Mesh;
-import com.badlogic.gdx.graphics.VertexAttributes;
-import com.badlogic.gdx.graphics.g3d.model.MeshPart;
 import com.badlogic.gdx.graphics.g3d.model.Node;
 import com.badlogic.gdx.graphics.g3d.utils.ShaderProvider;
 import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.Pool;
 
-/** A Renderable contains all information about a single render instruction (typically a draw call).</p>
- * 
- * It defines what (the shape), how (the material) and where (the transform) should be rendered by which shader.</p>
- * 
- * The shape is defined using the {@link #mesh}, {@link #meshPartOffset}, {@link #meshPartSize} and {@link #primitiveType}
- * members. This matches the members of the {@link MeshPart} class. The {@link #meshPartOffset} is used to specify
- * the offset within the mesh and the {@link #meshPartSize} is used to specify the part (in total number of vertices)
- * to render. If the mesh is indexed (which is when {@link Mesh#getNumIndices()} > 0) then both values are in number
- * of indices within the indices array of the mesh, otherwise they are in number of vertices within the vertices array
- * of the mesh. Note that some classes might require the mesh to be indexed.</p>
- * 
- * The {@link #material} and (optional) {@link #environment} values are combined to specify how the shape should look like.
- * Typically these are used to specify uniform values or other OpenGL state changes. When a value is present in both
- * the {@link #material} and {@link #environment}, then the value of the {@link #material} will be used.</p>
+/** A renderable defines a world transform, the {@link Mesh} to render
+ * along with the offset into the mesh's indices and the number of indices to use plus the
+ * primitive type to render the part of the mesh with. Finally, a renderable defines
+ * a {@link Material} to be applied to the mesh.</p>
  * 
- * Renderables can be rendered directly using a {@link Shader} (in which case the {@link #shader} member is ignored).
- * Though more typically Renderables are rendered via a {@link ModelBatch}, either directly, or by passing a
- * {@link RenderableProvider} like {@link ModelInstance} to the RenderBatch.</p>
- *  
- * A ModelInstance returns all Renderables via its {@link ModelInstance#getRenderables(Array, Pool)} method.
- * In which case the value of {@link ModelInstance#userData} will be set to the {@link #userData} member.
- * The {@link #userData} member can be used to pass additional data to the shader. However, in most scenerario's
- * it is advised to use the {@link #material} or {@link #environment} member with custom {@link Attribute}s
- * to pass data to the shader.</p>
- * 
- * In some cases, (for example for non-hierarchical basic game objects requiring only a single draw call) it is
- * possible to extend the Renderable class and add additional fields to pass to the shader.
- * While extending the Renderable class can be useful, the shader should not rely on it. Similar to the {@link #userData}
- * member it is advised to use the {@link #material} and {@link #environment} members to pass data to the shader.</p>  
+ * Renderables can be rendered via a {@link ModelBatch}, either directly, or by passing a
+ * {@link RenderableProvider} like {@link ModelInstance} to the RenderBatch. 
+ * A ModelInstance returns all Renderables via its {@link ModelInstance#getRenderables(Array, Pool)} method.</p>
  * 
- * When using a ModelBatch to render a Renderable, The Renderable and all its values must not be changed
- * in between the call to {@link ModelBatch#begin(com.badlogic.gdx.graphics.Camera)} and {@link ModelBatch#end()}.
- * Therefor Renderable instances cannot be reused for multiple render calls.</p>
+ * When using a ModelBatch to render a renderable, The renderable and all its values must not be changed
+ * in between the call to {@link ModelBatch#begin(com.badlogic.gdx.graphics.Camera)} and {@link ModelBatch#end()}.</p>
  * 
  * When the {@link #shader} member of the Renderable is set, the {@link ShaderProvider} of the {@link ModelBatch}
- * may decide to use that shader instead of the default shader. Therefor, to assure the default shader is used, the
- * {@link #shader} member must be set to null.</p>
+ * may try to use that shader instead of the default shader. Therefor, to assure the default shader is used, the
+ * {@link #shader} member must be set to null. 
  * @author badlogic, xoppa */
 public class Renderable {
-	/** Used to specify the transformations (like translation, scale and rotation) to apply to the shape.
-	 * In other words: it is used to transform the vertices from model space into world space. **/
+	/** the model transform **/
 	public final Matrix4 worldTransform = new Matrix4();
-	/** The {@link Mesh} which contains the part to render **/
+	/** the {@link Mesh} to render **/
 	public Mesh mesh;
-	/** The offset in the {@link #mesh} to the part to render. If the mesh is indexed ({@link Mesh#getNumIndices()} > 0),
-	 * this is the offset in the indices array, otherwise it is the offset in the vertices array. **/
+	/** the offset into the mesh's indices **/
 	public int meshPartOffset;
-	/** The size (in total number of vertices) of the part in the {@link #mesh} to render. When the mesh is indexed
-	 * ({@link Mesh#getNumIndices()} > 0), this is the number of indices, otherwise it is the number of vertices. **/
+	/** the number of indices/vertices to use **/
 	public int meshPartSize;
-	/** The primitive type, OpenGL constant e.g: {@link GL20#GL_TRIANGLES}, {@link GL20#GL_POINTS}, {@link GL20#GL_LINES},
-	 * {@link GL20#GL_LINE_STRIP}, {@link GL20#GL_TRIANGLE_STRIP} **/
+	/** the primitive type, encoded as an OpenGL constant, like {@link GL20#GL_TRIANGLES} **/
 	public int primitiveType;
-	/** The {@link Material} to be applied to the shape (part of the mesh), must not be null.
-	 * @see #environment **/
+	/** the {@link Material} to be applied to the mesh **/
 	public Material material;
-	/** The {@link Environment} to be used to render this Renderable, may be null. When specified it will be combined
-	 * by the shader with the {@link #material}. When both the material and environment contain an attribute of the
-	 * same type, the attribute of the material will be used. **/
-	public Environment environment;
-	/** The bone transformations used for skinning, or null if not applicable. When specified and the mesh contains one or more
-	 * {@link com.badlogic.gdx.graphics.VertexAttributes.Usage#BoneWeight} vertex attributes, then the BoneWeight index is used as
-	 * index in the array. If the array isn't large enough then the identity matrix is used. Each BoneWeight weight is used to
-	 * combine multiple bones into a single transformation matrix, which is used to transform the vertex to model space. In other
-	 * words: the bone transformation is applied prior to the {@link #worldTransform}. */
+	/** the bones transformations used for skinning, or null if not applicable */  
 	public Matrix4 bones[];
-	/** The {@link Shader} to be used to render this Renderable using a {@link ModelBatch}, may be null.
+	/** the {@link Environment} to be used to render this Renderable, may be null **/
+	public Environment environment;
+	/** the {@link Shader} to be used to render this Renderable, may be null.
 	 * It is not guaranteed that the shader will be used, the used {@link ShaderProvider} is responsible
 	 * for actually choosing the correct shader to use. **/
 	public Shader shader;
-	/** User definable value, may be null. */
+	/** user definable value. */
 	public Object userData;
 }
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loader/ObjLoader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loader/ObjLoader.java
index b7a9e74..4646364 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loader/ObjLoader.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/loader/ObjLoader.java
@@ -38,8 +38,6 @@ import com.badlogic.gdx.graphics.VertexAttribute;
 import com.badlogic.gdx.graphics.VertexAttributes.Usage;
 import com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute;
 import com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute;
-import com.badlogic.gdx.graphics.g3d.Attribute;
-import com.badlogic.gdx.graphics.g3d.Attributes;
 import com.badlogic.gdx.graphics.g3d.Material;
 import com.badlogic.gdx.graphics.g3d.Model;
 import com.badlogic.gdx.graphics.g3d.model.data.ModelData;
@@ -56,27 +54,10 @@ import com.badlogic.gdx.math.Vector3;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.FloatArray;
 
-/** {@link ModelLoader} to load Wavefront OBJ files. Only intended for testing basic models/meshes and educational usage.
- * The Wavefront specification is NOT fully implemented, only a subset of the specification is supported. Especially the
- * {@link Material} ({@link Attributes}), e.g. the color or texture applied, might not or not correctly be loaded.</p>
+/** Loads Wavefront OBJ files.
  * 
- * This {@link ModelLoader} can be used to load very basic models without having to convert them to a more suitable format.
- * Therefore it can be used for educational purposes and to quickly test a basic model, but should not be used in production.
- * Instead use {@link G3dModelLoader}.</p>
- * 
- * Because of above reasons, when an OBJ file is loaded using this loader, it will log and error. To prevent this error from
- * being logged, set the {@link #logWarning} flag to false. However, it is advised not to do so.</p>
- * 
- * An OBJ file only contains the mesh (shape). It may link to a separate MTL file, which is used to describe one or more materials.
- * In that case the MTL filename (might be case-sensitive) is expected to be located relative to the OBJ file. The MTL file might
- * reference one or more texture files, in which case those filename(s) are expected to be located relative to the MTL file.</p> 
- * @author mzechner, espitz, xoppa */
+ * @author mzechner, espitz */
 public class ObjLoader extends ModelLoader<ObjLoader.ObjLoaderParameters> {
-	/** Set to false to prevent a warning from being logged when this class is used.
-	 * Do not change this value, unless you are absolutely sure what you are doing.
-	 * Consult the documentation for more information. */
-	public static boolean logWarning = false;
-	
 	public static class ObjLoaderParameters extends AssetLoaderParameters<Model> {
 		public boolean flipV;
 		public ObjLoaderParameters() {}
@@ -127,8 +108,6 @@ public class ObjLoader extends ModelLoader<ObjLoader.ObjLoaderParameters> {
 	}
 	
 	protected ModelData loadModelData (FileHandle file, boolean flipV) {
-		if (logWarning)
-			Gdx.app.error("ObjLoader", "Wavefront (OBJ) is not fully supported, consult the documentation for more information");
 		String line;
 		String[] tokens;
 		char firstChar;
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/MeshPart.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/MeshPart.java
index b23fc63..45ac20c 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/MeshPart.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/model/MeshPart.java
@@ -16,82 +16,46 @@
 
 package com.badlogic.gdx.graphics.g3d.model;
 
-import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.Mesh;
 import com.badlogic.gdx.graphics.g3d.Model;
 
-/** A MeshPart is composed of a subset of vertices of a {@link Mesh}, along with the primitive type.
- * The vertices subset is described by an offset and size. When the mesh is indexed
- * (which is when {@link Mesh#getNumIndices()} > 0), then the {@link #indexOffset} represents the
- * offset in the indices array and {@link #numVertices} represents the number of indices.
- * When the mesh isn't indexed, then the {@link #indexOffset} member represents the offset in the
- * vertices array and the {@link #numVertices} member represents the number of vertices.</p>
- * 
- * In other words: Regardless whether the mesh is indexed or not, when {@link #primitiveType} is not a strip,
- * then {@link #numVertices} equals the number of primitives multiplied by the number of vertices per
- * primitive. So if the MeshPart represents 4 triangles ({@link #primitiveType} is GL_TRIANGLES),
- * then the {@link #numVertices} member is 12 (4 triangles * 3 vertices = 12 vertices total). 
- * Likewise, if the part represents 12 lines ({@link #primitiveType} is GL_LINES), then the size is 24
- * (12 lines * 2 vertices = 24 vertices total).</p>
- * 
- * Note that some classes might require the mesh (part) to be indexed.</p>
- * 
- * The {@link Mesh} referenced by the {@link #mesh} member must outlive the MeshPart. When the mesh is
- * disposed, the MeshPart is unusable.
- * @author badlogic, Xoppa */
+/**
+ * A mesh part is composed of a subset of vertices
+ * of a {@link Mesh}, along with the primitive type.
+ * The vertices subset is described by an offset into
+ * the Mesh's indices array and the number of vertices.
+ * @author badlogic
+ *
+ */
 public class MeshPart {
-	/** Unique id within model, may be null. Will be ignored by {@link #equals(MeshPart)} **/
+	/** unique id within model, may be null (FIXME?) **/
 	public String id;
-	/** The primitive type, OpenGL constant e.g: {@link GL20#GL_TRIANGLES}, {@link GL20#GL_POINTS}, {@link GL20#GL_LINES},
-	 * {@link GL20#GL_LINE_STRIP}, {@link GL20#GL_TRIANGLE_STRIP} **/
+	/** the primitive type, OpenGL constant like GL_TRIANGLES **/
 	public int primitiveType;
-	/** The offset in the {@link #mesh} to this part. If the mesh is indexed ({@link Mesh#getNumIndices()} > 0),
-	 * this is the offset in the indices array, otherwise it is the offset in the vertices array. **/
+	/** the offset into a Mesh's indices array **/
 	public int indexOffset;
-	/** The size (in total number of vertices) of this part in the {@link #mesh}. When the mesh is indexed
-	 * ({@link Mesh#getNumIndices()} > 0), this is the number of indices, otherwise it is the number of vertices. **/
+	/** the number of vertices that make up this part **/
 	public int numVertices;
-	/** The Mesh the part references, also stored in {@link Model} **/
+	/** the Mesh the part references, also stored in {@link Model} **/
 	public Mesh mesh;
 	
-	/** Construct a new MeshPart, with null values. The MeshPart is unusable until you set all members. **/
 	public MeshPart() {}
 	
-	/** Construct a new MeshPart and set all its values.
-	 * @param id The id of the new part, may be null.
-	 * @param mesh The mesh which holds all vertices and (optional) indices of this part.
-	 * @param offset The offset within the mesh to this part.
-	 * @param size The size (in total number of vertices) of the part.
-	 * @param type The primitive type of the part (e.g. GL_TRIANGLES, GL_LINE_STRIP, etc.). */
 	public MeshPart(final String id, final Mesh mesh, final int offset, final int size, final int type) {
 		this.id = id;
 		this.mesh = mesh;
 		this.indexOffset = offset;
 		this.numVertices = size;
 		this.primitiveType = type;
-	}
-	
-	/** Construct a new MeshPart which is an exact copy of the provided MeshPart.
-	 * @param copyFrom The MeshPart to copy. */
-	public MeshPart(final MeshPart copyFrom) {
-		this(copyFrom.id, copyFrom.mesh, copyFrom.indexOffset, copyFrom.numVertices, copyFrom.primitiveType);
-	}
-	
-	/** Compares this MeshPart to the specified MeshPart and returns true if they both reference the same
-	 * {@link Mesh} and the {@link #indexOffset}, {@link #numVertices} and {@link #primitiveType} members are equal.
-	 * The {@link #id} member is ignored.
-	 * @param other The other MeshPart to compare this MeshPart to.
-	 * @return True when this MeshPart equals the other MeshPart (ignoring the {@link #id} member), false otherwise. */
-	public boolean equals (final MeshPart other) {
-		return other == this || (other != null && other.mesh == mesh && other.primitiveType == primitiveType && 
-			other.indexOffset == indexOffset && other.numVertices == numVertices);		
 	}
 	
 	@Override
-	public boolean equals (final Object arg0) {
+	public boolean equals (Object arg0) {
 		if (arg0 == null) return false;
 		if (arg0 == this) return true;
-		if (!(arg0 instanceof MeshPart)) return false;
-		return equals((MeshPart)arg0);
+		if (!(arg0 instanceof MeshPart)) return false;
+		final MeshPart other = (MeshPart)arg0;
+		return other.mesh == mesh && other.primitiveType == primitiveType && 
+			other.indexOffset == indexOffset && other.numVertices == numVertices;
 	}
 }
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/Node.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/Node.java
index bc8f2e2..52c7c5d 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/Node.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/model/Node.java
@@ -58,8 +58,12 @@ public class Node {
 	 * @return the local transform
 	 */
 	public Matrix4 calculateLocalTransform() {
-		if (!isAnimated)
-			localTransform.set(translation, rotation, scale);
+		if (!isAnimated) {
+			localTransform.idt();
+			localTransform.translate(translation);
+			localTransform.rotate(rotation);
+			localTransform.scale(scale.x, scale.y, scale.z);
+		}
 		return localTransform;
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/NodePart.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/NodePart.java
index da3658c..a5d3375 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/NodePart.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/model/NodePart.java
@@ -17,49 +17,30 @@
 package com.badlogic.gdx.graphics.g3d.model;
 
 import com.badlogic.gdx.graphics.g3d.Material;
-import com.badlogic.gdx.graphics.g3d.Model;
-import com.badlogic.gdx.graphics.g3d.ModelInstance;
 import com.badlogic.gdx.graphics.g3d.Renderable;
 import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.ArrayMap;
 
-/** A combination of {@link MeshPart} and {@link Material}, used to represent a {@link Node}'s graphical
- * properties. A NodePart is the smallest visible part of a {@link Model}, each NodePart implies a render
- * call.
- * @author badlogic, Xoppa */
-public class NodePart {
-	/** The MeshPart (shape) to render. Must not be null. */
-	public MeshPart meshPart;
-	/** The Material used to render the {@link #meshPart}. Must not be null. */
-	public Material material;
-	/** Mapping to each bone (node) and the inverse transform of the bind pose.
-	 * Will be used to fill the {@link #bones} array. May be null. */
-	public ArrayMap<Node, Matrix4> invBoneBindTransforms;
-	/** The current transformation (relative to the bind pose) of each bone, may be null.
-	 * When the part is skinned, this will be updated by a call to {@link ModelInstance#calculateTransforms()}.
-	 * Do not set or change this value manually. */
+/**
+ * A combination of {@link MeshPart} and {@link Material}, used to represent a {@link Node}'s graphical
+ * properties
+ * @author badlogic
+ */
+public class NodePart {
+	public MeshPart meshPart;
+	public Material material;
+	public ArrayMap<Node, Matrix4> invBoneBindTransforms;
 	public Matrix4[] bones;
-	
-	/** Construct a new NodePart with null values. At least the {@link #meshPart} and {@link #material} member
-	 * must be set before the newly created part can be used. */
+	
 	public NodePart() {}
-	
-	/** Construct a new NodePart referencing the provided {@link MeshPart} and {@link Material}.
-	 * @param meshPart The MeshPart to reference.
-	 * @param material The Material to reference. */
+	
 	public NodePart(final MeshPart meshPart, final Material material) {
 		this.meshPart = meshPart;
 		this.material = material;
-	}
-	
-	// FIXME add copy constructor and override #equals.
+	}
 	
-	/** Convenience method to set the material, mesh, meshPartOffset, meshPartSize, primitiveType and bones
-	 * members of the specified Renderable. The other member of the provided {@link Renderable} remain untouched.
-	 * Note that the material, mesh and bones members are referenced, not copied. Any changes made to those objects
-	 * will be reflected in both the NodePart and Renderable object.
-	 * @param out The Renderable of which to set the members to the values of this NodePart. */
+	/** Convenience method to set the material, meshpart and bones values of the renderable. */
 	public Renderable setRenderable(final Renderable out) {
 		out.material = material;
 		out.mesh = meshPart.mesh;
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/BaseShader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/BaseShader.java
index abccbfd..03d8cd4 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/BaseShader.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/BaseShader.java
@@ -12,355 +12,355 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g3d.shaders;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.graphics.GLTexture;
-import com.badlogic.gdx.graphics.Camera;
-import com.badlogic.gdx.graphics.Color;
-import com.badlogic.gdx.graphics.Mesh;
-import com.badlogic.gdx.graphics.Texture;
-import com.badlogic.gdx.graphics.VertexAttribute;
-import com.badlogic.gdx.graphics.VertexAttributes;
-import com.badlogic.gdx.graphics.g3d.Attributes;
-import com.badlogic.gdx.graphics.g3d.Material;
-import com.badlogic.gdx.graphics.g3d.Renderable;
-import com.badlogic.gdx.graphics.g3d.Shader;
-import com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute;
-import com.badlogic.gdx.graphics.g3d.utils.RenderContext;
-import com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor;
-import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-import com.badlogic.gdx.math.Matrix3;
-import com.badlogic.gdx.math.Matrix4;
-import com.badlogic.gdx.math.Vector2;
-import com.badlogic.gdx.math.Vector3;
-import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-import com.badlogic.gdx.utils.IntArray;
-import com.badlogic.gdx.utils.IntIntMap;
-import com.badlogic.gdx.utils.Pool;
-
-/** @author Xoppa
- * A BaseShader is a wrapper around a ShaderProgram that keeps track of the uniform and attribute locations.
- * It does not manage the ShaderPogram, you are still responsible for disposing the ShaderProgram. */
-public abstract class BaseShader implements Shader {
-	public interface Validator {
-		/** @return True if the input is valid for the renderable, false otherwise. */
-		boolean validate(final BaseShader shader, final int inputID, final Renderable renderable);
-	}
-	public interface Setter {
-		/** @return True if the uniform only has to be set once per render call, false if the uniform must be set for each renderable. */
-		boolean isGlobal(final BaseShader shader, final int inputID);
-		void set(final BaseShader shader, final int inputID, final Renderable renderable, final Attributes combinedAttributes);
-	}
-	public static class Uniform implements Validator {
-		public final String alias;
-		public final long materialMask;
-		public final long environmentMask;
-		public final long overallMask;
-		public Uniform(final String alias, final long materialMask, final long environmentMask, final long overallMask) {
-			this.alias = alias;
-			this.materialMask = materialMask;
-			this.environmentMask = environmentMask;
-			this.overallMask = overallMask;
-		}
-		public Uniform(final String alias, final long materialMask, final long environmentMask) {
-			this(alias, materialMask, environmentMask, 0);
-		}
-		public Uniform(final String alias, final long overallMask) {
-			this(alias, 0, 0, overallMask);
-		}
-		public Uniform(final String alias) {
-			this(alias, 0, 0);
-		}
-		public boolean validate(final BaseShader shader, final int inputID, final Renderable renderable) {
-			final long matFlags = (renderable != null && renderable.material != null) ? renderable.material.getMask() : 0;
-			final long envFlags = (renderable != null && renderable.environment != null) ? renderable.environment.getMask() : 0;
-			return ((matFlags & materialMask) == materialMask) 
-				&& ((envFlags & environmentMask) == environmentMask) 
-				&& (((matFlags | envFlags) & overallMask) == overallMask);
-		}
-	}
-	
-	private final Array<String> uniforms = new Array<String>();
-	private final Array<Validator> validators = new Array<Validator>();
-	private final Array<Setter> setters = new Array<Setter>();
-	private int locations[];
-	private final IntArray globalUniforms = new IntArray();
-	private final IntArray localUniforms = new IntArray();
-	private final IntIntMap attributes = new IntIntMap();
-	
-	public ShaderProgram program;
-	public RenderContext context;
-	public Camera camera;
-	private Mesh currentMesh;
-	
-	/** Register an uniform which might be used by this shader. Only possible prior to the call to init().
-	 * @return The ID of the uniform to use in this shader. */
-	public int register(final String alias, final Validator validator, final Setter setter) {
-		if (locations != null)
-			throw new GdxRuntimeException("Cannot register an uniform after initialization");
-		final int existing = getUniformID(alias);
-		if (existing >= 0) {
-			validators.set(existing, validator);
-			setters.set(existing, setter);
-			return existing;
-		}
-		uniforms.add(alias);
-		validators.add(validator);
-		setters.add(setter);
-		return uniforms.size - 1;
-	}
-	public int register(final String alias, final Validator validator) {
-		return register(alias, validator, null);
-	}
-	public int register(final String alias, final Setter setter) {
-		return register(alias, null, setter);
-	}
-	public int register(final String alias) {
-		return register(alias, null, null);
-	}
-	public int register(final Uniform uniform, final Setter setter) {
-		return register(uniform.alias, uniform, setter);
-	}
-	public int register(final Uniform uniform) {
-		return register(uniform, null);
-	}
-	
-	/** @return the ID of the input or negative if not available. */
-	public int getUniformID(final String alias) {
-		final int n = uniforms.size;
-		for (int i = 0; i < n; i++)
-			if (uniforms.get(i).equals(alias))
-				return i;
-		return -1;
-	}
-	
-	/** @return The input at the specified id. */
-	public String getUniformAlias(final int id) {
-		return uniforms.get(id);
-	}
-
-	/** Initialize this shader, causing all registered uniforms/attributes to be fetched. */
-	public void init(final ShaderProgram program, final Renderable renderable) {
-		if (locations != null)
-			throw new GdxRuntimeException("Already initialized");
-		if (!program.isCompiled())
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g3d.shaders;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.GLTexture;
+import com.badlogic.gdx.graphics.Camera;
+import com.badlogic.gdx.graphics.Color;
+import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.Texture;
+import com.badlogic.gdx.graphics.VertexAttribute;
+import com.badlogic.gdx.graphics.VertexAttributes;
+import com.badlogic.gdx.graphics.g3d.Attributes;
+import com.badlogic.gdx.graphics.g3d.Material;
+import com.badlogic.gdx.graphics.g3d.Renderable;
+import com.badlogic.gdx.graphics.g3d.Shader;
+import com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute;
+import com.badlogic.gdx.graphics.g3d.utils.RenderContext;
+import com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor;
+import com.badlogic.gdx.graphics.glutils.ShaderProgram;
+import com.badlogic.gdx.math.Matrix3;
+import com.badlogic.gdx.math.Matrix4;
+import com.badlogic.gdx.math.Vector2;
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+import com.badlogic.gdx.utils.IntArray;
+import com.badlogic.gdx.utils.IntIntMap;
+import com.badlogic.gdx.utils.Pool;
+
+/** @author Xoppa
+ * A BaseShader is a wrapper around a ShaderProgram that keeps track of the uniform and attribute locations.
+ * It does not manage the ShaderPogram, you are still responsible for disposing the ShaderProgram. */
+public abstract class BaseShader implements Shader {
+	public interface Validator {
+		/** @return True if the input is valid for the renderable, false otherwise. */
+		boolean validate(final BaseShader shader, final int inputID, final Renderable renderable);
+	}
+	public interface Setter {
+		/** @return True if the uniform only has to be set once per render call, false if the uniform must be set for each renderable. */
+		boolean isGlobal(final BaseShader shader, final int inputID);
+		void set(final BaseShader shader, final int inputID, final Renderable renderable, final Attributes combinedAttributes);
+	}
+	public static class Uniform implements Validator {
+		public final String alias;
+		public final long materialMask;
+		public final long environmentMask;
+		public final long overallMask;
+		public Uniform(final String alias, final long materialMask, final long environmentMask, final long overallMask) {
+			this.alias = alias;
+			this.materialMask = materialMask;
+			this.environmentMask = environmentMask;
+			this.overallMask = overallMask;
+		}
+		public Uniform(final String alias, final long materialMask, final long environmentMask) {
+			this(alias, materialMask, environmentMask, 0);
+		}
+		public Uniform(final String alias, final long overallMask) {
+			this(alias, 0, 0, overallMask);
+		}
+		public Uniform(final String alias) {
+			this(alias, 0, 0);
+		}
+		public boolean validate(final BaseShader shader, final int inputID, final Renderable renderable) {
+			final long matFlags = (renderable != null && renderable.material != null) ? renderable.material.getMask() : 0;
+			final long envFlags = (renderable != null && renderable.environment != null) ? renderable.environment.getMask() : 0;
+			return ((matFlags & materialMask) == materialMask) 
+				&& ((envFlags & environmentMask) == environmentMask) 
+				&& (((matFlags | envFlags) & overallMask) == overallMask);
+		}
+	}
+	
+	private final Array<String> uniforms = new Array<String>();
+	private final Array<Validator> validators = new Array<Validator>();
+	private final Array<Setter> setters = new Array<Setter>();
+	private int locations[];
+	private final IntArray globalUniforms = new IntArray();
+	private final IntArray localUniforms = new IntArray();
+	private final IntIntMap attributes = new IntIntMap();
+	
+	public ShaderProgram program;
+	public RenderContext context;
+	public Camera camera;
+	private Mesh currentMesh;
+	
+	/** Register an uniform which might be used by this shader. Only possible prior to the call to init().
+	 * @return The ID of the uniform to use in this shader. */
+	public int register(final String alias, final Validator validator, final Setter setter) {
+		if (locations != null)
+			throw new GdxRuntimeException("Cannot register an uniform after initialization");
+		final int existing = getUniformID(alias);
+		if (existing >= 0) {
+			validators.set(existing, validator);
+			setters.set(existing, setter);
+			return existing;
+		}
+		uniforms.add(alias);
+		validators.add(validator);
+		setters.add(setter);
+		return uniforms.size - 1;
+	}
+	public int register(final String alias, final Validator validator) {
+		return register(alias, validator, null);
+	}
+	public int register(final String alias, final Setter setter) {
+		return register(alias, null, setter);
+	}
+	public int register(final String alias) {
+		return register(alias, null, null);
+	}
+	public int register(final Uniform uniform, final Setter setter) {
+		return register(uniform.alias, uniform, setter);
+	}
+	public int register(final Uniform uniform) {
+		return register(uniform, null);
+	}
+	
+	/** @return the ID of the input or negative if not available. */
+	public int getUniformID(final String alias) {
+		final int n = uniforms.size;
+		for (int i = 0; i < n; i++)
+			if (uniforms.get(i).equals(alias))
+				return i;
+		return -1;
+	}
+	
+	/** @return The input at the specified id. */
+	public String getUniformAlias(final int id) {
+		return uniforms.get(id);
+	}
+
+	/** Initialize this shader, causing all registered uniforms/attributes to be fetched. */
+	public void init(final ShaderProgram program, final Renderable renderable) {
+		if (locations != null)
+			throw new GdxRuntimeException("Already initialized");
+		if (!program.isCompiled())
 			throw new GdxRuntimeException(program.getLog());
-		this.program = program;
-		
-		final int n = uniforms.size;
-		locations = new int[n];
-		for (int i = 0; i < n; i++) {
-			final String input = uniforms.get(i);
-			final Validator validator = validators.get(i);
-			final Setter setter = setters.get(i);
-			if (validator != null && !validator.validate(this, i, renderable))
-				locations[i] = -1;
-			else {
-				locations[i] = program.fetchUniformLocation(input, false);
-				if (locations[i] >= 0 && setter != null) {
-					if (setter.isGlobal(this, i))
-						globalUniforms.add(i);
-					else
-						localUniforms.add(i);
-				}
-			}
-			if (locations[i] < 0) {
-				validators.set(i, null);
-				setters.set(i, null);
-			}
-		}
-		if (renderable != null) {
-			final VertexAttributes attrs = renderable.mesh.getVertexAttributes();
-			final int c = attrs.size();
-			for (int i = 0; i < c; i++) {
-				final VertexAttribute attr = attrs.get(i);
-				final int location = program.getAttributeLocation(attr.alias);
-				if (location >= 0)
-					attributes.put(attr.getKey(), location);
-			}
-		}
-	}
-	
-	@Override
-	public void begin (Camera camera, RenderContext context) {
-		this.camera = camera;
-		this.context = context;
-		program.begin();
-		currentMesh = null;
-		for (int u, i = 0; i < globalUniforms.size; ++i)
-			if (setters.get(u = globalUniforms.get(i)) != null)
-				setters.get(u).set(this, u, null, null);
-	}
-	
-	private final IntArray tempArray = new IntArray();
-	private final int[] getAttributeLocations(final VertexAttributes attrs) {
-		tempArray.clear();
-		final int n = attrs.size();
-		for (int i = 0; i < n; i++) {
-			tempArray.add(attributes.get(attrs.get(i).getKey(), -1));
-		}
-		return tempArray.items;
-	}
-
-	private Attributes combinedAttributes = new Attributes();
-	@Override
-	public void render (Renderable renderable) {
-		combinedAttributes.clear();
-		if (renderable.environment != null)
-			combinedAttributes.set(renderable.environment);
-		if (renderable.material != null)
-			combinedAttributes.set(renderable.material);
-		render(renderable, combinedAttributes);
-	}
-	
-	public void render (Renderable renderable, final Attributes combinedAttributes) {
-		for (int u, i = 0; i < localUniforms.size; ++i)
-			if (setters.get(u = localUniforms.get(i)) != null)
-				setters.get(u).set(this, u, renderable, combinedAttributes);
-		if (currentMesh != renderable.mesh) {
-			if (currentMesh != null)
-				currentMesh.unbind(program, tempArray.items);
-			currentMesh = renderable.mesh;
-			currentMesh.bind(program, getAttributeLocations(renderable.mesh.getVertexAttributes()));
-		}
-		renderable.mesh.render(program, renderable.primitiveType, renderable.meshPartOffset, renderable.meshPartSize, false);
-	}
-
-	@Override
-	public void end () {
-		if (currentMesh != null) {
-			currentMesh.unbind(program, tempArray.items);
-			currentMesh = null;
-		}
-		program.end();
-	}
-
-	@Override
-	public void dispose () {
-		program = null;
-		uniforms.clear();
-		validators.clear();
-		setters.clear();
-		localUniforms.clear();
-		globalUniforms.clear();
-		locations = null;
-	}
-	
-	/** Whether this Shader instance implements the specified uniform, only valid after a call to init(). */
-	public final boolean has(final int inputID) {
-		return inputID >= 0 && inputID < locations.length && locations[inputID] >= 0;
-	}
-	
-	public final int loc(final int inputID) {
-		return (inputID >= 0 && inputID < locations.length) ? locations[inputID] : -1;
-	}
-	
-	public final boolean set(final int uniform, final Matrix4 value) {
-		if (locations[uniform] < 0)
-			return false;
-		program.setUniformMatrix(locations[uniform], value);
-		return true;
-	}
-	
-	public final boolean set(final int uniform, final Matrix3 value) {
-		if (locations[uniform] < 0)
-			return false;
-		program.setUniformMatrix(locations[uniform], value);
-		return true;
-	}
-	
-	public final boolean set(final int uniform, final Vector3 value) {
-		if (locations[uniform] < 0)
-			return false;
-		program.setUniformf(locations[uniform], value);
-		return true;
-	}
-	
-	public final boolean set(final int uniform, final Vector2 value) {
-		if (locations[uniform] < 0)
-			return false;
-		program.setUniformf(locations[uniform], value);
-		return true;
-	}
-	
-	public final boolean set(final int uniform, final Color value) {
-		if (locations[uniform] < 0)
-			return false;
-		program.setUniformf(locations[uniform], value);
-		return true;
-	}
-	
-	public final boolean set(final int uniform, final float value) {
-		if (locations[uniform] < 0)
-			return false;
-		program.setUniformf(locations[uniform], value);
-		return true;
-	}
-	
-	public final boolean set(final int uniform, final float v1, final float v2) {
-		if (locations[uniform] < 0)
-			return false;
-		program.setUniformf(locations[uniform], v1, v2);
-		return true;
-	}
-	
-	public final boolean set(final int uniform, final float v1, final float v2, final float v3) {
-		if (locations[uniform] < 0)
-			return false;
-		program.setUniformf(locations[uniform], v1, v2, v3);
-		return true;
-	}
-	
-	public final boolean set(final int uniform, final float v1, final float v2, final float v3, final float v4) {
-		if (locations[uniform] < 0)
-			return false;
-		program.setUniformf(locations[uniform], v1, v2, v3, v4);
-		return true;
-	}
-	
-	public final boolean set(final int uniform, final int value) {
-		if (locations[uniform] < 0)
-			return false;
-		program.setUniformi(locations[uniform], value);
-		return true;
-	}
-	
-	public final boolean set(final int uniform, final int v1, final int v2) {
-		if (locations[uniform] < 0)
-			return false;
-		program.setUniformi(locations[uniform], v1, v2);
-		return true;
-	}
-	
-	public final boolean set(final int uniform, final int v1, final int v2, final int v3) {
-		if (locations[uniform] < 0)
-			return false;
-		program.setUniformi(locations[uniform], v1, v2, v3);
-		return true;
-	}
-	
-	public final boolean set(final int uniform, final int v1, final int v2, final int v3, final int v4) {
-		if (locations[uniform] < 0)
-			return false;
-		program.setUniformi(locations[uniform], v1, v2, v3, v4);
-		return true;
-	}
-	
-	public final boolean set(final int uniform, final TextureDescriptor textureDesc) {
-		if (locations[uniform] < 0)
-			return false;
-		program.setUniformi(locations[uniform], context.textureBinder.bind(textureDesc));
-		return true;
-	}
-	
-	public final boolean set(final int uniform, final GLTexture texture) {
-		if (locations[uniform] < 0)
-			return false;
-		program.setUniformi(locations[uniform], context.textureBinder.bind(texture));
-		return true;
-	}
-}
+		this.program = program;
+		
+		final int n = uniforms.size;
+		locations = new int[n];
+		for (int i = 0; i < n; i++) {
+			final String input = uniforms.get(i);
+			final Validator validator = validators.get(i);
+			final Setter setter = setters.get(i);
+			if (validator != null && !validator.validate(this, i, renderable))
+				locations[i] = -1;
+			else {
+				locations[i] = program.fetchUniformLocation(input, false);
+				if (locations[i] >= 0 && setter != null) {
+					if (setter.isGlobal(this, i))
+						globalUniforms.add(i);
+					else
+						localUniforms.add(i);
+				}
+			}
+			if (locations[i] < 0) {
+				validators.set(i, null);
+				setters.set(i, null);
+			}
+		}
+		if (renderable != null) {
+			final VertexAttributes attrs = renderable.mesh.getVertexAttributes();
+			final int c = attrs.size();
+			for (int i = 0; i < c; i++) {
+				final VertexAttribute attr = attrs.get(i);
+				final int location = program.getAttributeLocation(attr.alias);
+				if (location >= 0)
+					attributes.put(attr.getKey(), location);
+			}
+		}
+	}
+	
+	@Override
+	public void begin (Camera camera, RenderContext context) {
+		this.camera = camera;
+		this.context = context;
+		program.begin();
+		currentMesh = null;
+		for (final int i: globalUniforms.items)
+			if (setters.get(i) != null)
+				setters.get(i).set(this, i, null, null);
+	}
+	
+	private final IntArray tempArray = new IntArray();
+	private final int[] getAttributeLocations(final VertexAttributes attrs) {
+		tempArray.clear();
+		final int n = attrs.size();
+		for (int i = 0; i < n; i++) {
+			tempArray.add(attributes.get(attrs.get(i).getKey(), -1));
+		}
+		return tempArray.items;
+	}
+
+	private Attributes combinedAttributes = new Attributes();
+	@Override
+	public void render (Renderable renderable) {
+		combinedAttributes.clear();
+		if (renderable.environment != null)
+			combinedAttributes.set(renderable.environment);
+		if (renderable.material != null)
+			combinedAttributes.set(renderable.material);
+		render(renderable, combinedAttributes);
+	}
+	
+	public void render (Renderable renderable, final Attributes combinedAttributes) {
+		for (final int i: localUniforms.items)
+			if (setters.get(i) != null)
+				setters.get(i).set(this, i, renderable, combinedAttributes);
+		if (currentMesh != renderable.mesh) {
+			if (currentMesh != null)
+				currentMesh.unbind(program, tempArray.items);
+			currentMesh = renderable.mesh;
+			currentMesh.bind(program, getAttributeLocations(renderable.mesh.getVertexAttributes()));
+		}
+		renderable.mesh.render(program, renderable.primitiveType, renderable.meshPartOffset, renderable.meshPartSize, false);
+	}
+
+	@Override
+	public void end () {
+		if (currentMesh != null) {
+			currentMesh.unbind(program, tempArray.items);
+			currentMesh = null;
+		}
+		program.end();
+	}
+
+	@Override
+	public void dispose () {
+		program = null;
+		uniforms.clear();
+		validators.clear();
+		setters.clear();
+		localUniforms.clear();
+		globalUniforms.clear();
+		locations = null;
+	}
+	
+	/** Whether this Shader instance implements the specified uniform, only valid after a call to init(). */
+	public final boolean has(final int inputID) {
+		return inputID >= 0 && inputID < locations.length && locations[inputID] >= 0;
+	}
+	
+	public final int loc(final int inputID) {
+		return (inputID >= 0 && inputID < locations.length) ? locations[inputID] : -1;
+	}
+	
+	public final boolean set(final int uniform, final Matrix4 value) {
+		if (locations[uniform] < 0)
+			return false;
+		program.setUniformMatrix(locations[uniform], value);
+		return true;
+	}
+	
+	public final boolean set(final int uniform, final Matrix3 value) {
+		if (locations[uniform] < 0)
+			return false;
+		program.setUniformMatrix(locations[uniform], value);
+		return true;
+	}
+	
+	public final boolean set(final int uniform, final Vector3 value) {
+		if (locations[uniform] < 0)
+			return false;
+		program.setUniformf(locations[uniform], value);
+		return true;
+	}
+	
+	public final boolean set(final int uniform, final Vector2 value) {
+		if (locations[uniform] < 0)
+			return false;
+		program.setUniformf(locations[uniform], value);
+		return true;
+	}
+	
+	public final boolean set(final int uniform, final Color value) {
+		if (locations[uniform] < 0)
+			return false;
+		program.setUniformf(locations[uniform], value);
+		return true;
+	}
+	
+	public final boolean set(final int uniform, final float value) {
+		if (locations[uniform] < 0)
+			return false;
+		program.setUniformf(locations[uniform], value);
+		return true;
+	}
+	
+	public final boolean set(final int uniform, final float v1, final float v2) {
+		if (locations[uniform] < 0)
+			return false;
+		program.setUniformf(locations[uniform], v1, v2);
+		return true;
+	}
+	
+	public final boolean set(final int uniform, final float v1, final float v2, final float v3) {
+		if (locations[uniform] < 0)
+			return false;
+		program.setUniformf(locations[uniform], v1, v2, v3);
+		return true;
+	}
+	
+	public final boolean set(final int uniform, final float v1, final float v2, final float v3, final float v4) {
+		if (locations[uniform] < 0)
+			return false;
+		program.setUniformf(locations[uniform], v1, v2, v3, v4);
+		return true;
+	}
+	
+	public final boolean set(final int uniform, final int value) {
+		if (locations[uniform] < 0)
+			return false;
+		program.setUniformi(locations[uniform], value);
+		return true;
+	}
+	
+	public final boolean set(final int uniform, final int v1, final int v2) {
+		if (locations[uniform] < 0)
+			return false;
+		program.setUniformi(locations[uniform], v1, v2);
+		return true;
+	}
+	
+	public final boolean set(final int uniform, final int v1, final int v2, final int v3) {
+		if (locations[uniform] < 0)
+			return false;
+		program.setUniformi(locations[uniform], v1, v2, v3);
+		return true;
+	}
+	
+	public final boolean set(final int uniform, final int v1, final int v2, final int v3, final int v4) {
+		if (locations[uniform] < 0)
+			return false;
+		program.setUniformi(locations[uniform], v1, v2, v3, v4);
+		return true;
+	}
+	
+	public final boolean set(final int uniform, final TextureDescriptor textureDesc) {
+		if (locations[uniform] < 0)
+			return false;
+		program.setUniformi(locations[uniform], context.textureBinder.bind(textureDesc));
+		return true;
+	}
+	
+	public final boolean set(final int uniform, final GLTexture texture) {
+		if (locations[uniform] < 0)
+			return false;
+		program.setUniformi(locations[uniform], context.textureBinder.bind(texture));
+		return true;
+	}
+}
\ No newline at end of file
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/OrthogonalTiledMapRenderer.java b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/OrthogonalTiledMapRenderer.java
index 5c823f0..202eeb2 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/renderers/OrthogonalTiledMapRenderer.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/renderers/OrthogonalTiledMapRenderer.java
@@ -206,8 +206,8 @@ public class OrthogonalTiledMapRenderer extends BatchTiledMapRenderer {
 						}
 					}
 					spriteBatch.draw(region.getTexture(), vertices, 0, 20);
+					x += layerTileWidth;
 				}
-				x += layerTileWidth;
 			}
 			y += layerTileHeight;
 		}
diff --git a/gdx/src/com/badlogic/gdx/math/MathUtils.java b/gdx/src/com/badlogic/gdx/math/MathUtils.java
index d695460..7b2015c 100644
--- a/gdx/src/com/badlogic/gdx/math/MathUtils.java
+++ b/gdx/src/com/badlogic/gdx/math/MathUtils.java
@@ -32,8 +32,6 @@ public class MathUtils {
 	static public final float PI = 3.1415927f;
 	static public final float PI2 = PI * 2;
 
-    static public final float E = 2.7182818f;
-
 	static private final int SIN_BITS = 14; // 16KB. Adjust for accuracy.
 	static private final int SIN_MASK = ~(-1 << SIN_BITS);
 	static private final int SIN_COUNT = SIN_MASK + 1;
diff --git a/gdx/src/com/badlogic/gdx/net/NetJavaImpl.java b/gdx/src/com/badlogic/gdx/net/NetJavaImpl.java
index 375dc6e..d349464 100644
--- a/gdx/src/com/badlogic/gdx/net/NetJavaImpl.java
+++ b/gdx/src/com/badlogic/gdx/net/NetJavaImpl.java
@@ -43,10 +43,17 @@ public class NetJavaImpl {
 	static class HttpClientResponse implements HttpResponse {
 		private HttpURLConnection connection;
 		private HttpStatus status;
+		private InputStream inputStream;
 
 		public HttpClientResponse (HttpURLConnection connection) throws IOException {
 			this.connection = connection;
 			try {
+				this.inputStream = connection.getInputStream();
+			} catch (IOException e) {
+				this.inputStream = connection.getErrorStream();
+			}
+
+			try {
 				this.status = new HttpStatus(connection.getResponseCode());
 			} catch (IOException e) {
 				this.status = new HttpStatus(-1);
@@ -56,7 +63,7 @@ public class NetJavaImpl {
 		@Override
 		public byte[] getResult () {
 			try {
-				return StreamUtils.copyStreamToByteArray(getInputStream(), connection.getContentLength());
+				return StreamUtils.copyStreamToByteArray(inputStream, connection.getContentLength());
 			} catch (IOException e) {
 				return StreamUtils.EMPTY_BYTES;
 			}
@@ -65,7 +72,7 @@ public class NetJavaImpl {
 		@Override
 		public String getResultAsString () {
 			try {
-				return StreamUtils.copyStreamToString(getInputStream(), connection.getContentLength());
+				return StreamUtils.copyStreamToString(inputStream, connection.getContentLength());
 			} catch (IOException e) {
 				return "";
 			}
@@ -73,7 +80,7 @@ public class NetJavaImpl {
 
 		@Override
 		public InputStream getResultAsStream () {
-			return getInputStream();
+			return inputStream;
 		}
 
 		@Override
@@ -90,14 +97,6 @@ public class NetJavaImpl {
 		public Map<String, List<String>> getHeaders () {
 			return connection.getHeaderFields();
 		}
-
-		private InputStream getInputStream () {
-			try {
-				return connection.getInputStream();
-			} catch (IOException e) {
-				return connection.getErrorStream();
-			}
-		}
 	}
 
 	private final ExecutorService executorService;
@@ -114,6 +113,7 @@ public class NetJavaImpl {
 
 		try {
 			final String method = httpRequest.getMethod();
+
 			URL url;
 
 			if (method.equalsIgnoreCase(HttpMethods.GET)) {
@@ -144,27 +144,23 @@ public class NetJavaImpl {
 				@Override
 				public void run () {
 					try {
+
 						// Set the content for POST and PUT (GET has the information embedded in the URL)
 						if (doingOutPut) {
 							// we probably need to use the content as stream here instead of using it as a string.
 							String contentAsString = httpRequest.getContent();
+							InputStream contentAsStream = httpRequest.getContentStream();
+
+							OutputStream outputStream = connection.getOutputStream();
 							if (contentAsString != null) {
-								OutputStreamWriter writer = new OutputStreamWriter(connection.getOutputStream());
-								try {
-									writer.write(contentAsString);
-								} finally {
-									StreamUtils.closeQuietly(writer);
-								}
-							} else {
-								InputStream contentAsStream = httpRequest.getContentStream();
-								if (contentAsStream != null) {
-									OutputStream os = connection.getOutputStream();
-									try {
-										StreamUtils.copyStream(contentAsStream, os);
-									} finally {
-										StreamUtils.closeQuietly(os);
-									}
-								}
+								OutputStreamWriter writer = new OutputStreamWriter(outputStream);
+								writer.write(contentAsString);
+								writer.flush();
+								writer.close();
+							} else if (contentAsStream != null) {
+								StreamUtils.copyStream(contentAsStream, outputStream);
+								outputStream.flush();
+								outputStream.close();
 							}
 						}
 
diff --git a/gdx/src/com/badlogic/gdx/physics/box2d/Box2DDebugRenderer.java b/gdx/src/com/badlogic/gdx/physics/box2d/Box2DDebugRenderer.java
index 09c3e6b..6f13535 100644
--- a/gdx/src/com/badlogic/gdx/physics/box2d/Box2DDebugRenderer.java
+++ b/gdx/src/com/badlogic/gdx/physics/box2d/Box2DDebugRenderer.java
@@ -78,14 +78,14 @@ public class Box2DDebugRenderer {
 		renderBodies(world);
 	}
 
-	public final Color SHAPE_NOT_ACTIVE = new Color(0.5f, 0.5f, 0.3f, 1);
-	public final Color SHAPE_STATIC = new Color(0.5f, 0.9f, 0.5f, 1);
-	public final Color SHAPE_KINEMATIC = new Color(0.5f, 0.5f, 0.9f, 1);
-	public final Color SHAPE_NOT_AWAKE = new Color(0.6f, 0.6f, 0.6f, 1);
-	public final Color SHAPE_AWAKE = new Color(0.9f, 0.7f, 0.7f, 1);
-	public final Color JOINT_COLOR = new Color(0.5f, 0.8f, 0.8f, 1);
-	public final Color AABB_COLOR = new Color(1.0f, 0, 1.0f, 1f);
-	public final Color VELOCITY_COLOR = new Color(1.0f, 0, 0f, 1f);
+	private final Color SHAPE_NOT_ACTIVE = new Color(0.5f, 0.5f, 0.3f, 1);
+	private final Color SHAPE_STATIC = new Color(0.5f, 0.9f, 0.5f, 1);
+	private final Color SHAPE_KINEMATIC = new Color(0.5f, 0.5f, 0.9f, 1);
+	private final Color SHAPE_NOT_AWAKE = new Color(0.6f, 0.6f, 0.6f, 1);
+	private final Color SHAPE_AWAKE = new Color(0.9f, 0.7f, 0.7f, 1);
+	private final Color JOINT_COLOR = new Color(0.5f, 0.8f, 0.8f, 1);
+	private final Color AABB_COLOR = new Color(1.0f, 0, 1.0f, 1f);
+	private final Color VELOCITY_COLOR = new Color(1.0f, 0, 0f, 1f);
 
 	private void renderBodies (World world) {
 		renderer.begin(ShapeType.Line);
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Button.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Button.java
index bc786e6..e5fb413 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Button.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Button.java
@@ -46,14 +46,16 @@ public class Button extends Table implements Disableable {
 		super(skin);
 		initialize();
 		setStyle(skin.get(ButtonStyle.class));
-		setSize(getPrefWidth(), getPrefHeight());
+		setWidth(getPrefWidth());
+		setHeight(getPrefHeight());
 	}
 
 	public Button (Skin skin, String styleName) {
 		super(skin);
 		initialize();
 		setStyle(skin.get(styleName, ButtonStyle.class));
-		setSize(getPrefWidth(), getPrefHeight());
+		setWidth(getPrefWidth());
+		setHeight(getPrefHeight());
 	}
 
 	public Button (Actor child, Skin skin, String styleName) {
@@ -64,13 +66,15 @@ public class Button extends Table implements Disableable {
 		initialize();
 		add(child);
 		setStyle(style);
-		setSize(getPrefWidth(), getPrefHeight());
+		setWidth(getPrefWidth());
+		setHeight(getPrefHeight());
 	}
 
 	public Button (ButtonStyle style) {
 		initialize();
 		setStyle(style);
-		setSize(getPrefWidth(), getPrefHeight());
+		setWidth(getPrefWidth());
+		setHeight(getPrefHeight());
 	}
 
 	/** Creates a button without setting the style or size. At least a style must be set before using this button. */
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/CheckBox.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/CheckBox.java
index 7dd4021..266c048 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/CheckBox.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/CheckBox.java
@@ -43,7 +43,8 @@ public class CheckBox extends TextButton {
 		Label label = getLabel();
 		add(label);
 		label.setAlignment(Align.left);
-		setSize(getPrefWidth(), getPrefHeight());
+		setWidth(getPrefWidth());
+		setHeight(getPrefHeight());
 	}
 
 	public void setStyle (ButtonStyle style) {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Image.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Image.java
index 65c3b4d..bc0c323 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Image.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Image.java
@@ -81,7 +81,8 @@ public class Image extends Widget {
 		setDrawable(drawable);
 		this.scaling = scaling;
 		this.align = align;
-		setSize(getPrefWidth(), getPrefHeight());
+		setWidth(getPrefWidth());
+		setHeight(getPrefHeight());
 	}
 
 	public void layout () {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ImageButton.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ImageButton.java
index f2bac7e..83fde6f 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ImageButton.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ImageButton.java
@@ -45,7 +45,8 @@ public class ImageButton extends Button {
 		image.setScaling(Scaling.fit);
 		add(image);
 		setStyle(style);
-		setSize(getPrefWidth(), getPrefHeight());
+		setWidth(getPrefWidth());
+		setHeight(getPrefHeight());
 	}
 
 	public ImageButton (Drawable imageUp) {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ImageTextButton.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ImageTextButton.java
index c697e5d..103f6e7 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ImageTextButton.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ImageTextButton.java
@@ -63,7 +63,8 @@ public class ImageTextButton extends Button {
 
 		setStyle(style);
 
-		setSize(getPrefWidth(), getPrefHeight());
+		setWidth(getPrefWidth());
+		setHeight(getPrefHeight());
 	}
 
 	public void setStyle (ButtonStyle style) {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Label.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Label.java
index e3d1eac..ec09438 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Label.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Label.java
@@ -31,8 +31,6 @@ import com.badlogic.gdx.utils.StringBuilder;
  * The preferred size of the label is determined by the actual text bounds, unless {@link #setWrap(boolean) word wrap} is enabled.
  * @author Nathan Sweet */
 public class Label extends Widget {
-	static private final Color tempColor = new Color();
-
 	private LabelStyle style;
 	private final TextBounds bounds = new TextBounds();
 	private final StringBuilder text = new StringBuilder();
@@ -69,7 +67,8 @@ public class Label extends Widget {
 	public Label (CharSequence text, LabelStyle style) {
 		if (text != null) this.text.append(text);
 		setStyle(style);
-		setSize(getPrefWidth(), getPrefHeight());
+		setWidth(getPrefWidth());
+		setHeight(getPrefHeight());
 	}
 
 	public void setStyle (LabelStyle style) {
@@ -119,17 +118,6 @@ public class Label extends Widget {
 		sizeInvalid = true;
 	}
 
-	private void scaleAndComputeSize () {
-		BitmapFont font = cache.getFont();
-		float oldScaleX = font.getScaleX();
-		float oldScaleY = font.getScaleY();
-		if (fontScaleX != 1 || fontScaleY != 1) font.setScale(fontScaleX, fontScaleY);
-
-		computeSize();
-
-		if (fontScaleX != 1 || fontScaleY != 1) font.setScale(oldScaleX, oldScaleY);
-	}
-
 	private void computeSize () {
 		sizeInvalid = false;
 		if (wrap) {
@@ -138,14 +126,13 @@ public class Label extends Widget {
 			bounds.set(cache.getFont().getWrappedBounds(text, width));
 		} else
 			bounds.set(cache.getFont().getMultiLineBounds(text));
+		if (!wrap) {
+			bounds.width *= fontScaleX;
+			bounds.height *= fontScaleY;
+		}
 	}
 
 	public void layout () {
-		BitmapFont font = cache.getFont();
-		float oldScaleX = font.getScaleX();
-		float oldScaleY = font.getScaleY();
-		if (fontScaleX != 1 || fontScaleY != 1) font.setScale(fontScaleX, fontScaleY);
-
 		if (sizeInvalid) computeSize();
 
 		if (wrap) {
@@ -156,6 +143,11 @@ public class Label extends Widget {
 			}
 		}
 
+		BitmapFont font = cache.getFont();
+		float oldScaleX = font.getScaleX();
+		float oldScaleY = font.getScaleY();
+		if (fontScaleX != 1 || fontScaleY != 1) font.setScale(fontScaleX, fontScaleY);
+
 		float width = getWidth(), height = getHeight();
 		StringBuilder text;
 		if (ellipse && width < bounds.width) {
@@ -204,21 +196,19 @@ public class Label extends Widget {
 
 	public void draw (Batch batch, float parentAlpha) {
 		validate();
-		Color color = tempColor.set(getColor());
-		color.a *= parentAlpha;
+		Color color = getColor();
 		if (style.background != null) {
-			batch.setColor(color.r, color.g, color.b, color.a);
+			batch.setColor(color.r, color.g, color.b, color.a * parentAlpha);
 			style.background.draw(batch, getX(), getY(), getWidth(), getHeight());
 		}
-		if (style.fontColor != null) color.mul(style.fontColor);
-		cache.setColors(color);
+		cache.setColor(style.fontColor == null ? color : Color.tmp.set(color).mul(style.fontColor));
 		cache.setPosition(getX(), getY());
-		cache.draw(batch);
+		cache.draw(batch, parentAlpha);
 	}
 
 	public float getPrefWidth () {
 		if (wrap) return 0;
-		if (sizeInvalid) scaleAndComputeSize();
+		if (sizeInvalid) computeSize();
 		float width = bounds.width;
 		Drawable background = style.background;
 		if (background != null) width += background.getLeftWidth() + background.getRightWidth();
@@ -226,7 +216,7 @@ public class Label extends Widget {
 	}
 
 	public float getPrefHeight () {
-		if (sizeInvalid) scaleAndComputeSize();
+		if (sizeInvalid) computeSize();
 		float height = bounds.height - style.font.getDescent() * 2;
 		Drawable background = style.background;
 		if (background != null) height += background.getTopHeight() + background.getBottomHeight();
@@ -234,7 +224,7 @@ public class Label extends Widget {
 	}
 
 	public TextBounds getTextBounds () {
-		if (sizeInvalid) scaleAndComputeSize();
+		if (sizeInvalid) computeSize();
 		return bounds;
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/List.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/List.java
index c4bd3d1..8a86fd2 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/List.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/List.java
@@ -56,7 +56,8 @@ public class List extends Widget implements Cullable {
 	public List (Object[] items, ListStyle style) {
 		setStyle(style);
 		setItems(items);
-		setSize(getPrefWidth(), getPrefHeight());
+		setWidth(getPrefWidth());
+		setHeight(getPrefHeight());
 
 		addListener(new InputListener() {
 			public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SelectBox.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SelectBox.java
index 0596ae8..c9650bc 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SelectBox.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SelectBox.java
@@ -52,7 +52,7 @@ public class SelectBox extends Widget implements Disableable {
 	String[] items;
 	int selectedIndex = 0;
 	private final TextBounds bounds = new TextBounds();
-	ListScroll scroll;
+	SelectList list;
 	private float prefWidth, prefHeight;
 	private ClickListener clickListener;
 	int maxListCount;
@@ -69,15 +69,16 @@ public class SelectBox extends Widget implements Disableable {
 	public SelectBox (Object[] items, SelectBoxStyle style) {
 		setStyle(style);
 		setItems(items);
-		setSize(getPrefWidth(), getPrefHeight());
+		setWidth(getPrefWidth());
+		setHeight(getPrefHeight());
 
 		addListener(clickListener = new ClickListener() {
 			public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
 				if (pointer == 0 && button != 0) return false;
 				if (disabled) return false;
 				Stage stage = getStage();
-				if (scroll == null) scroll = new ListScroll();
-				scroll.show(stage);
+				if (list == null) list = new SelectList();
+				list.show(stage);
 				return true;
 			}
 		});
@@ -164,7 +165,7 @@ public class SelectBox extends Widget implements Disableable {
 		Drawable background;
 		if (disabled && style.backgroundDisabled != null)
 			background = style.backgroundDisabled;
-		else if (scroll != null && scroll.getParent() != null && style.backgroundOpen != null)
+		else if (list != null && list.getParent() != null && style.backgroundOpen != null)
 			background = style.backgroundOpen;
 		else if (clickListener.isOver() && style.backgroundOver != null)
 			background = style.backgroundOver;
@@ -231,21 +232,15 @@ public class SelectBox extends Widget implements Disableable {
 	}
 
 	public void hideList () {
-		if (scroll == null || scroll.getParent() == null) return;
-		scroll.addAction(sequence(fadeOut(0.15f, Interpolation.fade), removeActor()));
+		if (list == null || list.getParent() == null) return;
+		list.addAction(sequence(fadeOut(0.15f, Interpolation.fade), removeActor()));
 	}
 
-	/** Returns the list shown when the select box is open, or null of the select box is closed. */
-	public List getList () {
-		if (scroll == null || scroll.getParent() == null) return null;
-		return scroll.list;
-	}
-
-	class ListScroll extends ScrollPane {
+	class SelectList extends ScrollPane {
 		final List list;
 		final Vector2 screenCoords = new Vector2();
 
-		public ListScroll () {
+		public SelectList () {
 			super(null, style.scrollStyle);
 
 			setOverscroll(false, false);
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Slider.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Slider.java
index ebbf8f9..89d9a57 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Slider.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Slider.java
@@ -76,7 +76,8 @@ public class Slider extends Widget implements Disableable {
 		this.stepSize = stepSize;
 		this.vertical = vertical;
 		this.value = min;
-		setSize(getPrefWidth(), getPrefHeight());
+		setWidth(getPrefWidth());
+		setHeight(getPrefHeight());
 
 		addListener(new InputListener() {
 			public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SplitPane.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SplitPane.java
index 6c13e38..d06aeb3 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SplitPane.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SplitPane.java
@@ -73,7 +73,8 @@ public class SplitPane extends WidgetGroup {
 		setStyle(style);
 		setFirstWidget(firstWidget);
 		setSecondWidget(secondWidget);
-		setSize(getPrefWidth(), getPrefHeight());
+		setWidth(getPrefWidth());
+		setHeight(getPrefHeight());
 		initialize();
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextButton.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextButton.java
index 7d5a2c2..1e5c57b 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextButton.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextButton.java
@@ -48,7 +48,8 @@ public class TextButton extends Button {
 		label = new Label(text, new LabelStyle(style.font, style.fontColor));
 		label.setAlignment(Align.center);
 		add(label).expand().fill();
-		setSize(getPrefWidth(), getPrefHeight());
+		setWidth(getPrefWidth());
+		setHeight(getPrefHeight());
 	}
 
 	public void setStyle (ButtonStyle style) {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextField.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextField.java
index 3f89f7c..39eee98 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextField.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextField.java
@@ -114,7 +114,8 @@ public class TextField extends Widget implements Disableable {
 		setStyle(style);
 		clipboard = Gdx.app.getClipboard();
 		setText(text);
-		setSize(getPrefWidth(), getPrefHeight());
+		setWidth(getPrefWidth());
+		setHeight(getPrefHeight());
 		initialize();
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Touchpad.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Touchpad.java
index fe6b05f..9a7a0ef 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Touchpad.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Touchpad.java
@@ -62,7 +62,8 @@ public class Touchpad extends Widget {
 		knobPosition.set(getWidth() / 2f, getHeight() / 2f);
 
 		setStyle(style);
-		setSize(getPrefWidth(), getPrefHeight());
+		setWidth(getPrefWidth());
+		setHeight(getPrefHeight());
 
 		addListener(new InputListener() {
 			@Override
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/WidgetGroup.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/WidgetGroup.java
index 05d4345..c07a2df 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/WidgetGroup.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/WidgetGroup.java
@@ -130,14 +130,14 @@ public class WidgetGroup extends Group implements Layout {
 	}
 
 	public void pack () {
-		setSize(getPrefWidth(), getPrefHeight());
-		validate();
-		// Some situations require another layout. Eg, a wrapped label doesn't know its pref height until it knows its width, so it
-		// calls invalidateHierarchy() in layout() if its pref height has changed.
-		if (needsLayout) {
-			setSize(getPrefWidth(), getPrefHeight());
-			validate();
+		float newWidth = getPrefWidth();
+		float newHeight = getPrefHeight();
+		if (newWidth != getWidth() || newHeight != getHeight()) {
+			setWidth(newWidth);
+			setHeight(newHeight);
+			invalidate();
 		}
+		validate();
 	}
 
 	public void setFillParent (boolean fillParent) {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Window.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Window.java
index 7169470..ee5e6f6 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Window.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Window.java
@@ -255,7 +255,7 @@ public class Window extends Table {
 			else
 				y -= (padTop - bounds.height) / 2;
 		}
-		titleCache.setColors(Color.tmp.set(getColor()).mul(style.titleFontColor));
+		titleCache.setColor(Color.tmp.set(getColor()).mul(style.titleFontColor));
 		titleCache.setPosition((int)x, (int)y);
 		titleCache.draw(batch, parentAlpha);
 	}
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/Layout.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/Layout.java
index 0eb842f..a859046 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/Layout.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/Layout.java
@@ -43,12 +43,13 @@ public interface Layout {
 	 * {@link Actor#draw(Batch, float)} before drawing is performed. */
 	public void validate ();
 
-	/** Sizes this actor to its preferred width and height, then calls {@link #validate()}.
+	/** Sizes this actor to its preferred width and height and, if this changed the size, causes the actor to be laid out by calling
+	 * {@link #invalidate()} then {@link #validate()}.
 	 * <p>
 	 * Generally this method should not be called in an actor's constructor because it calls {@link #layout()}, which means a
-	 * subclass would have layout() called before the subclass' constructor. Instead, in constructors, simply set the actor's size
-	 * to {@link #getPrefWidth()} and {@link #getPrefHeight()}. This allows the actor to have a size at construction time for more
-	 * convenient use outside of a {@link Table}. */
+	 * subclass would have layout() called before the subclass' constructor. Instead, in constructors, simply set the actors width
+	 * and height to {@link #getPrefWidth()} and {@link #getPrefHeight()}. This allows the actor to have a size at construction
+	 * time for more convenient use outside of a {@link Table}. */
 	public void pack ();
 
 	/** If true, this actor will be sized to the parent in {@link #validate()}. If the parent is the stage, the actor will be sized
diff --git a/gdx/src/com/badlogic/gdx/utils/BufferUtils.java b/gdx/src/com/badlogic/gdx/utils/BufferUtils.java
index 5c59bbd..dbea410 100644
--- a/gdx/src/com/badlogic/gdx/utils/BufferUtils.java
+++ b/gdx/src/com/badlogic/gdx/utils/BufferUtils.java
@@ -236,27 +236,15 @@ public class BufferUtils {
 	 * @param count The number of vectors to transform
 	 * @param matrix The matrix to multiply the vector with */
 	public static void transform (Buffer data, int dimensions, int strideInBytes, int count, Matrix4 matrix) {
-		transform(data, dimensions, strideInBytes, count, matrix, 0);
-	}
-	
-	/** Multiply float vector components within the buffer with the specified matrix. The specified offset value
-	 * is added to the {@link Buffer#position()} and used as the offset.
-	 * @param data The buffer to transform.
-	 * @param dimensions The number of components of the vector (2 for xy, 3 for xyz or 4 for xyzw)
-	 * @param strideInBytes The offset between the first and the second vector to transform
-	 * @param count The number of vectors to transform
-	 * @param matrix The matrix to multiply the vector with
-	 * @param offset The offset within the buffer (in bytes relative to the current position) to the vector */
-	public static void transform (Buffer data, int dimensions, int strideInBytes, int count, Matrix4 matrix, int offset) {
 		switch (dimensions) {
 		case 4:
-			transformV4M4Jni (data, strideInBytes, count, matrix.val, positionInBytes(data) + offset);
+			transformV4M4Jni (data, positionInBytes(data), strideInBytes, count, matrix.val);
 			break;
 		case 3:
-			transformV3M4Jni (data, strideInBytes, count, matrix.val, positionInBytes(data) + offset);
+			transformV3M4Jni (data, positionInBytes(data), strideInBytes, count, matrix.val);
 			break;
 		case 2:
-			transformV2M4Jni (data, strideInBytes, count, matrix.val, positionInBytes(data) + offset);
+			transformV2M4Jni (data, positionInBytes(data), strideInBytes, count, matrix.val);
 			break;
 		default:
 			throw new IllegalArgumentException();
@@ -271,62 +259,18 @@ public class BufferUtils {
 	 * @param count The number of vectors to transform
 	 * @param matrix The matrix to multiply the vector with */
 	public static void transform (Buffer data, int dimensions, int strideInBytes, int count, Matrix3 matrix) {
-		transform(data, dimensions, strideInBytes, count, matrix, 0);
-	}
-	
-	/** Multiply float vector components within the buffer with the specified matrix. The specified offset value
-	 * is added to the {@link Buffer#position()} and used as the offset.
-	 * @param data The buffer to transform.
-	 * @param dimensions The number of components (x, y, z) of the vector (2 for xy or 3 for xyz)
-	 * @param strideInBytes The offset between the first and the second vector to transform
-	 * @param count The number of vectors to transform
-	 * @param matrix The matrix to multiply the vector with,
-	 * @param offset The offset within the buffer (in bytes relative to the current position) to the vector */
-	public static void transform (Buffer data, int dimensions, int strideInBytes, int count, Matrix3 matrix, int offset) {
 		switch (dimensions) {
 		case 3:
-			transformV3M3Jni (data, strideInBytes, count, matrix.val, positionInBytes(data) + offset * 3);
+			transformV3M3Jni (data, positionInBytes(data), strideInBytes, count, matrix.val);
 			break;
 		case 2:
-			transformV2M3Jni (data, strideInBytes, count, matrix.val, positionInBytes(data) + offset * 3);
+			transformV2M3Jni (data, positionInBytes(data), strideInBytes, count, matrix.val);
 			break;
 		default:
 			throw new IllegalArgumentException();
 		}
 	}
 	
-	public static long findFloats(Buffer vertex, int strideInBytes, Buffer vertices, int numVertices) {
-		return find(vertex, positionInBytes(vertex), strideInBytes, vertices, positionInBytes(vertices), numVertices);
-	}
-
-	public static long findFloats(float[] vertex, int strideInBytes, Buffer vertices, int numVertices) {
-		return find(vertex, 0, strideInBytes, vertices, positionInBytes(vertices), numVertices);
-	}
-	
-	public static long findFloats(Buffer vertex, int strideInBytes, float[] vertices, int numVertices) {
-		return find(vertex, positionInBytes(vertex), strideInBytes, vertices, 0, numVertices);
-	}
-	
-	public static long findFloats(float[] vertex, int strideInBytes, float[] vertices, int numVertices) {
-		return find(vertex, 0, strideInBytes, vertices, 0, numVertices);
-	}
-	
-	public static long findFloats(Buffer vertex, int strideInBytes, Buffer vertices, int numVertices, float epsilon) {
-		return find(vertex, positionInBytes(vertex), strideInBytes, vertices, positionInBytes(vertices), numVertices, epsilon);
-	}
-
-	public static long findFloats(float[] vertex, int strideInBytes, Buffer vertices, int numVertices, float epsilon) {
-		return find(vertex, 0, strideInBytes, vertices, positionInBytes(vertices), numVertices, epsilon);
-	}
-	
-	public static long findFloats(Buffer vertex, int strideInBytes, float[] vertices, int numVertices, float epsilon) {
-		return find(vertex, positionInBytes(vertex), strideInBytes, vertices, 0, numVertices, epsilon);
-	}
-	
-	public static long findFloats(float[] vertex, int strideInBytes, float[] vertices, int numVertices, float epsilon) {
-		return find(vertex, 0, strideInBytes, vertices, 0, numVertices, epsilon);
-	}
-
 	private static int positionInBytes (Buffer dst) {
 		if (dst instanceof ByteBuffer)
 			return dst.position();
@@ -494,7 +438,8 @@ public class BufferUtils {
 	 */
 	
 	private static native ByteBuffer newDisposableByteBuffer (int numBytes); /*
-		return env->NewDirectByteBuffer((char*)malloc(numBytes), numBytes);
+		char* ptr = (char*)malloc(numBytes);
+		return env->NewDirectByteBuffer(ptr, numBytes);
 	*/
 	
 	private static native long getBufferAddress (Buffer buffer); /*
@@ -543,149 +488,67 @@ public class BufferUtils {
 	*/
 	
 	/*JNI
-	template<size_t n1, size_t n2> void transform(float * const &src, float * const &m, float * const &dst) {}
+	template<size_t n1, size_t n2> void transform(float * const &v, const float * const &m) {}
 	
-	template<> inline void transform<4, 4>(float * const &src, float * const &m, float * const &dst) {
-		const float x = src[0], y = src[1], z = src[2], w = src[3];
-		dst[0] = x * m[ 0] + y * m[ 4] + z * m[ 8] + w * m[12]; 
-		dst[1] = x * m[ 1] + y * m[ 5] + z * m[ 9] + w * m[13];
-		dst[2] = x * m[ 2] + y * m[ 6] + z * m[10] + w * m[14];
-		dst[3] = x * m[ 3] + y * m[ 7] + z * m[11] + w * m[15]; 
+	template<> inline void transform<4, 4>(float * const &v, const float * const &m) {
+		const float x = v[0], y = v[1], z = v[2], w = v[3];
+		v[0] = x * m[ 0] + y * m[ 4] + z * m[ 8] + w * m[12]; 
+		v[1] = x * m[ 1] + y * m[ 5] + z * m[ 9] + w * m[13];
+		v[2] = x * m[ 2] + y * m[ 6] + z * m[10] + w * m[14];
+		v[3] = x * m[ 3] + y * m[ 7] + z * m[11] + w * m[15]; 
 	}
 	
-	template<> inline void transform<3, 4>(float * const &src, float * const &m, float * const &dst) {
-		const float x = src[0], y = src[1], z = src[2];
-		dst[0] = x * m[ 0] + y * m[ 4] + z * m[ 8] + m[12]; 
-		dst[1] = x * m[ 1] + y * m[ 5] + z * m[ 9] + m[13];
-		dst[2] = x * m[ 2] + y * m[ 6] + z * m[10] + m[14]; 
+	template<> inline void transform<3, 4>(float * const &v, const float * const &m) {
+		const float x = v[0], y = v[1], z = v[2];
+		v[0] = x * m[ 0] + y * m[ 4] + z * m[ 8] + m[12]; 
+		v[1] = x * m[ 1] + y * m[ 5] + z * m[ 9] + m[13];
+		v[2] = x * m[ 2] + y * m[ 6] + z * m[10] + m[14]; 
 	}
 	
-	template<> inline void transform<2, 4>(float * const &src, float * const &m, float * const &dst) {
-		const float x = src[0], y = src[1];
-		dst[0] = x * m[ 0] + y * m[ 4] + m[12]; 
-		dst[1] = x * m[ 1] + y * m[ 5] + m[13]; 
+	template<> inline void transform<2, 4>(float * const &v, const float * const &m) {
+		const float x = v[0], y = v[1], z = v[2], w = v[3];
+		v[0] = x * m[ 0] + y * m[ 4] + m[12]; 
+		v[1] = x * m[ 1] + y * m[ 5] + m[13]; 
 	}
 	
-	template<> inline void transform<3, 3>(float * const &src, float * const &m, float * const &dst) {
-		const float x = src[0], y = src[1], z = src[2];
-		dst[0] = x * m[0] + y * m[3] + z * m[6]; 
-		dst[1] = x * m[1] + y * m[4] + z * m[7];
-		dst[2] = x * m[2] + y * m[5] + z * m[8]; 
+	template<> inline void transform<3, 3>(float * const &v, const float * const &m) {
+		const float x = v[0], y = v[1], z = v[2];
+		v[0] = x * m[0] + y * m[3] + z * m[6]; 
+		v[1] = x * m[1] + y * m[4] + z * m[7];
+		v[2] = x * m[2] + y * m[5] + z * m[8]; 
 	}
 	
-	template<> inline void transform<2, 3>(float * const &src, float * const &m, float * const &dst) {
-		const float x = src[0], y = src[1];
-		dst[0] = x * m[0] + y * m[3] + m[6]; 
-		dst[1] = x * m[1] + y * m[4] + m[7]; 
+	template<> inline void transform<2, 3>(float * const &v, const float * const &m) {
+		const float x = v[0], y = v[1];
+		v[0] = x * m[0] + y * m[3] + m[6]; 
+		v[1] = x * m[1] + y * m[4] + m[7]; 
 	}
 	
-	template<size_t n1, size_t n2> void transform(float * const &v, int const &stride, int const &count, float * const &m, int offset) {
+	template<size_t n1, size_t n2> void transform(float * const &v, int offset, int const &stride, int const &count, const float * const &m) {
 		for (int i = 0; i < count; i++) {
-			transform<n1, n2>(&v[offset], m, &v[offset]);
+			transform<n1, n2>(&v[offset], m);
 			offset += stride;
 		}
 	}
-	
-	template<size_t n1, size_t n2> void transform(float * const &v, int const &stride, unsigned short * const &indices, int const &count, float * const &m, int offset) {
-		for (int i = 0; i < count; i++) {
-			transform<n1, n2>(&v[offset], m, &v[offset]);
-			offset += stride;
-		}
-	}
-	
-	inline bool compare(float * const &lhs, float * const & rhs, const unsigned int &size, const float &epsilon) {
-   	for (unsigned int i = 0; i < size; i++)
-   		if ((*(unsigned int*)&lhs[i] != *(unsigned int*)&rhs[i]) && ((lhs[i] > rhs[i] ? lhs[i] - rhs[i] : rhs[i] - lhs[i]) > epsilon))
-         	return false;
-		return true;
-	}
-	
-	long find(float * const &vertex, const unsigned int &size, float * const &vertices, const unsigned int &count, const float &epsilon) {
-		for (unsigned int i = 0; i < count; i++)
-			if (compare(&vertices[i*size], vertex, size, epsilon))
-				return (long)i;
-		return -1;
-	}
-
-	inline bool compare(float * const &lhs, float * const & rhs, const unsigned int &size) {
-   	for (unsigned int i = 0; i < size; i++)
-      	if ((*(unsigned int*)&lhs[i] != *(unsigned int*)&rhs[i]) && lhs[i] != rhs[i])
-         	return false;
-		return true;
-	}
-	
-	long find(float * const &vertex, const unsigned int &size, float * const &vertices, const unsigned int &count) {
-		for (unsigned int i = 0; i < count; i++)
-			if (compare(&vertices[i*size], vertex, size))
-				return (long)i;
-		return -1;
-	}
-
-	inline unsigned int calcHash(float * const &vertex, const unsigned int &size) {
-		unsigned int result = 0;
-		for (unsigned int i = 0; i < size; ++i)
-			result += ((*((unsigned int *)&vertex[i])) & 0xffffff80) >> (i & 0x7);
-		return result & 0x7fffffff;
-	}
-	
-	long find(float * const &vertex, const unsigned int &size, float * const &vertices, unsigned int * const &hashes, const unsigned int &count) {
-		const unsigned int hash = calcHash(vertex, size);
-		for (unsigned int i = 0; i < count; i++)
-			if (hashes[i] == hash && compare(&vertices[i*size], vertex, size))
-				return (long)i;
-		return -1;
-	}
 	*/
 	
-	private native static void transformV4M4Jni (Buffer data, int strideInBytes, int count, float[] matrix, int offsetInBytes); /*
-		transform<4, 4>((float*)data, strideInBytes / 4, count, (float*)matrix, offsetInBytes / 4);  
+	private native static void transformV4M4Jni (Buffer data, int offsetInBytes, int strideInBytes, int count, float[] matrix); /*
+		transform<4, 4>((float*)data, offsetInBytes / 4, strideInBytes / 4, count, (float*)matrix);  
 	*/
 	
-	private native static void transformV3M4Jni (Buffer data, int strideInBytes, int count, float[] matrix, int offsetInBytes); /*
-		transform<3, 4>((float*)data, strideInBytes / 4, count, (float*)matrix, offsetInBytes / 4);
+	private native static void transformV3M4Jni (Buffer data, int offsetInBytes, int strideInBytes, int count, float[] matrix); /*
+		transform<3, 4>((float*)data, offsetInBytes / 4, strideInBytes / 4, count, (float*)matrix);
 	*/
 	
-	private native static void transformV2M4Jni (Buffer data, int strideInBytes, int count, float[] matrix, int offsetInBytes); /*
-		transform<2, 4>((float*)data, strideInBytes / 4, count, (float*)matrix, offsetInBytes / 4);
+	private native static void transformV2M4Jni (Buffer data, int offsetInBytes, int strideInBytes, int count, float[] matrix); /*
+		transform<2, 4>((float*)data, offsetInBytes / 4, strideInBytes / 4, count, (float*)matrix);
 	*/
 
-	private native static void transformV3M3Jni (Buffer data, int strideInBytes, int count, float[] matrix, int offsetInBytes); /*
-		transform<3, 3>((float*)data, strideInBytes / 4, count, (float*)matrix, offsetInBytes / 4);
-	*/
-	
-	private native static void transformV2M3Jni (Buffer data, int strideInBytes, int count, float[] matrix, int offsetInBytes); /*
-		transform<2, 3>((float*)data, strideInBytes / 4, count, (float*)matrix, offsetInBytes / 4);
-	*/
-	
-	private native static long find(Buffer vertex, int vertexOffsetInBytes, int strideInBytes, Buffer vertices, int verticesOffsetInBytes, int numVertices); /*
-		return find((float *)&vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices);
-	*/
-	
-	private native static long find(float[] vertex, int vertexOffsetInBytes, int strideInBytes, Buffer vertices, int verticesOffsetInBytes, int numVertices); /*
-		return find((float *)&vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices);
-	*/
-	
-	private native static long find(Buffer vertex, int vertexOffsetInBytes, int strideInBytes, float[] vertices, int verticesOffsetInBytes, int numVertices); /*
-		return find((float *)&vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices);
-	*/
-	
-	private native static long find(float[] vertex, int vertexOffsetInBytes, int strideInBytes, float[] vertices, int verticesOffsetInBytes, int numVertices); /*
-		return find((float *)&vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices);
-	*/
-	
-	private native static long find(Buffer vertex, int vertexOffsetInBytes, int strideInBytes, Buffer vertices, int verticesOffsetInBytes, int numVertices, float epsilon); /*
-		return find((float *)&vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices, epsilon);
-	*/
-	
-	private native static long find(float[] vertex, int vertexOffsetInBytes, int strideInBytes, Buffer vertices, int verticesOffsetInBytes, int numVertices, float epsilon); /*
-		return find((float *)&vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices, epsilon);
-	*/
-	
-	private native static long find(Buffer vertex, int vertexOffsetInBytes, int strideInBytes, float[] vertices, int verticesOffsetInBytes, int numVertices, float epsilon); /*
-		return find((float *)&vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices, epsilon);
+	private native static void transformV3M3Jni (Buffer data, int offsetInBytes, int strideInBytes, int count, float[] matrix); /*
+		transform<3, 3>((float*)data, offsetInBytes / 4, strideInBytes / 4, count, (float*)matrix);
 	*/
 	
-	private native static long find(float[] vertex, int vertexOffsetInBytes, int strideInBytes, float[] vertices, int verticesOffsetInBytes, int numVertices, float epsilon); /*
-		return find((float *)&vertex[vertexOffsetInBytes / 4], (unsigned int)(strideInBytes / 4), (float*)&vertices[verticesOffsetInBytes / 4], (unsigned int)numVertices, epsilon);
+	private native static void transformV2M3Jni (Buffer data, int offsetInBytes, int strideInBytes, int count, float[] matrix); /*
+		transform<2, 3>((float*)data, offsetInBytes / 4, strideInBytes / 4, count, (float*)matrix);
 	*/
 }
diff --git a/gdx/src/com/badlogic/gdx/utils/StreamUtils.java b/gdx/src/com/badlogic/gdx/utils/StreamUtils.java
index a484b41..4987080 100644
--- a/gdx/src/com/badlogic/gdx/utils/StreamUtils.java
+++ b/gdx/src/com/badlogic/gdx/utils/StreamUtils.java
@@ -39,14 +39,10 @@ public class StreamUtils {
 	/** Copy the data from an {@link InputStream} to an {@link OutputStream}.
 	 * @throws IOException */
 	public static void copyStream (InputStream input, OutputStream output, int bufferSize) throws IOException {
-		try {
-			byte[] buffer = new byte[bufferSize];
-			int bytesRead;
-			while ((bytesRead = input.read(buffer)) != -1) {
-				output.write(buffer, 0, bytesRead);
-			}
-		} finally {
-			closeQuietly(input);
+		byte[] buffer = new byte[bufferSize];
+		int bytesRead;
+		while ((bytesRead = input.read(buffer)) != -1) {
+			output.write(buffer, 0, bytesRead);
 		}
 	}
 
@@ -95,7 +91,7 @@ public class StreamUtils {
 	public static void closeQuietly (Closeable c) {
 		if (c != null) try {
 			c.close();
-		} catch (Exception e) {
+		} catch (IOException e) {
 			// ignore
 		}
 	}
diff --git a/gdx/src/com/esotericsoftware/tablelayout/BaseTableLayout.java b/gdx/src/com/esotericsoftware/tablelayout/BaseTableLayout.java
index 9e1a9e9..f765507 100644
--- a/gdx/src/com/esotericsoftware/tablelayout/BaseTableLayout.java
+++ b/gdx/src/com/esotericsoftware/tablelayout/BaseTableLayout.java
@@ -715,7 +715,7 @@ abstract public class BaseTableLayout<C, T extends C, L extends BaseTableLayout,
 			columnWeightedWidth = this.columnWeightedWidth = ensureSize(this.columnWeightedWidth, columns);
 			for (int i = 0; i < columns; i++) {
 				float growWidth = columnPrefWidth[i] - columnMinWidth[i];
-				float growRatio = growWidth / totalGrowWidth;
+				float growRatio = growWidth / (float)totalGrowWidth;
 				columnWeightedWidth[i] = columnMinWidth[i] + extraWidth * growRatio;
 			}
 		}
@@ -729,7 +729,7 @@ abstract public class BaseTableLayout<C, T extends C, L extends BaseTableLayout,
 			float extraHeight = Math.min(totalGrowHeight, Math.max(0, layoutHeight - tableMinHeight));
 			for (int i = 0; i < rows; i++) {
 				float growHeight = rowPrefHeight[i] - rowMinHeight[i];
-				float growRatio = growHeight / totalGrowHeight;
+				float growRatio = growHeight / (float)totalGrowHeight;
 				rowWeightedHeight[i] = rowMinHeight[i] + extraHeight * growRatio;
 			}
 		}
diff --git a/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglHeadlessTest.java b/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglHeadlessTest.java
index 7a7d7f3..28bbc68 100644
--- a/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglHeadlessTest.java
+++ b/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglHeadlessTest.java
@@ -5,25 +5,14 @@ import javax.swing.UIManager;
 import com.badlogic.gdx.ApplicationAdapter;
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.backends.lwjgl.LwjglHeadlessApplication;
-import com.badlogic.gdx.backends.lwjgl.LwjglHeadlessApplicationConfiguration;
 
 public class LwjglHeadlessTest extends ApplicationAdapter {
 	@Override
 	public void create () {
-		Gdx.app.log(getClass().getSimpleName(), "create();");
-	}
-	
-	int counter;
-	@Override
-	public void render () {
-		Gdx.app.log(getClass().getSimpleName(), "render(); "+(++counter));
-		if (counter == 10)
-			Gdx.app.exit();
+		Gdx.app.log("LwjglHeadlessTest", "create();");
 	}
 	
 	public static void main (String[] argv) throws Exception {
-		LwjglHeadlessApplicationConfiguration config = new LwjglHeadlessApplicationConfiguration();
-		config.renderInterval = 0.5f;
-		LwjglHeadlessApplication app = new LwjglHeadlessApplication(new LwjglHeadlessTest(), config); 
+		LwjglHeadlessApplication app = new LwjglHeadlessApplication(new LwjglHeadlessTest()); 
 	}
 }
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontAlignmentTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontAlignmentTest.java
index 77274ed..2b7a044 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontAlignmentTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontAlignmentTest.java
@@ -109,7 +109,7 @@ public class BitmapFontAlignmentTest extends GdxTest {
 
 		// Obviously you wouldn't set the cache text every frame in real code.
 		TextBounds bounds = cache.setMultiLineText(text, 0, 0);
-		cache.setColors(Color.BLUE, 1, 4);
+		cache.setColor(Color.BLUE, 1, 4);
 
 		x += width / 2 - bounds.width / 2;
 		y += height / 2 + bounds.height / 2;
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontFlipTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontFlipTest.java
index d86125a..4698dda 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontFlipTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontFlipTest.java
@@ -147,7 +147,7 @@ public class BitmapFontFlipTest extends GdxTest {
 	}
 
 	private void renderCached () {
-		cache5.setColors(red);
+		cache5.setColor(red);
 		cache5.draw(spriteBatch);
 
 		cache1.draw(spriteBatch);
@@ -160,7 +160,7 @@ public class BitmapFontFlipTest extends GdxTest {
 	}
 
 	private void renderCachedScaled () {
-		cacheScaled5.setColors(red);
+		cacheScaled5.setColor(red);
 		cacheScaled5.draw(spriteBatch);
 
 		cacheScaled1.draw(spriteBatch);
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontTest.java
index 5b59aab..ee9ed51 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontTest.java
@@ -34,14 +34,14 @@ public class BitmapFontTest extends GdxTest {
 	private BitmapFont font;
 	private ShapeRenderer renderer;
 	private BitmapFont multiPageFont;
-
+	
 	@Override
 	public void create () {
 		spriteBatch = new SpriteBatch();
 		font = new BitmapFont(Gdx.files.internal("data/verdana39.fnt"), false);
-
+		
 		multiPageFont = new BitmapFont(Gdx.files.internal("data/multipagefont.fnt"));
-
+		
 		renderer = new ShapeRenderer();
 		renderer.setProjectionMatrix(spriteBatch.getProjectionMatrix());
 	}
@@ -61,7 +61,8 @@ public class BitmapFontTest extends GdxTest {
 
 		float x = 100, y = 20;
 		float alignmentWidth;
-
+		
+		
 		if (false) {
 			alignmentWidth = 0;
 			font.drawMultiLine(spriteBatch, text, x, viewHeight - y, alignmentWidth, HAlignment.RIGHT);
@@ -79,39 +80,28 @@ public class BitmapFontTest extends GdxTest {
 			font.drawWrapped(spriteBatch, text, x, viewHeight - y, alignmentWidth, HAlignment.RIGHT);
 		}
 
-		// 'R' and 'p' are in different pages
-		String txt2 = "this font uses " + multiPageFont.getRegions().length + " texture pages: RpRpRpRpRpNM";
+		//'R' and 'p' are in different pages
+		String txt2 = "this font uses "+multiPageFont.getRegions().length+" texture pages: RpRpRpRpRpNM";
 		spriteBatch.renderCalls = 0;
-
-		// regular draw function
+		
+		//regular draw function
 		multiPageFont.setColor(Color.BLUE);
 		multiPageFont.draw(spriteBatch, txt2, 10, 100);
-
-		// expert usage.. drawing with bitmap font cache
+		
+		
+		//expert usage.. drawing with bitmap font cache
 		BitmapFontCache cache = multiPageFont.getCache();
 		cache.clear();
 		cache.setColor(Color.BLACK);
 		cache.setText(txt2, 10, 50);
-		cache.setColors(Color.PINK, 3, 6);
-		cache.setColors(Color.ORANGE, 9, 12);
-		cache.setColors(Color.GREEN, 16, txt2.length());
-		cache.draw(spriteBatch, 5, txt2.length() - 5);
-
-		cache.clear();
-		cache.setColor(Color.BLACK);
-		float textX = 10;
-		textX += cache.setText("black ", textX, 150).width;
-		cache.setColor(Color.PINK);
-		textX += cache.addText("pink ", textX, 150).width;
-		cache.setColor(Color.ORANGE);
-		textX += cache.addText("orange ", textX, 150).width;
-		cache.setColor(Color.GREEN);
-		textX += cache.addText("green ", textX, 150).width;
-		cache.draw(spriteBatch);
-
+		cache.setColor(Color.PINK, 3, 6);
+		cache.setColor(Color.ORANGE, 9, 12);
+		cache.setColor(Color.GREEN, 16, txt2.length());
+		cache.draw(spriteBatch, 5, txt2.length()-5);
+		
 		spriteBatch.end();
-		// System.out.println(spriteBatch.renderCalls);
-
+//		System.out.println(spriteBatch.renderCalls);
+		
 		renderer.begin(ShapeType.Line);
 		renderer.setColor(Color.BLACK);
 		renderer.rect(x, viewHeight - y, x + alignmentWidth, 300);
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/ReflectionTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/ReflectionTest.java
deleted file mode 100644
index 2eb509b..0000000
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/ReflectionTest.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.tests;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.graphics.GL10;
-import com.badlogic.gdx.graphics.g2d.BitmapFont;
-import com.badlogic.gdx.graphics.g2d.SpriteBatch;
-import com.badlogic.gdx.math.Vector2;
-import com.badlogic.gdx.tests.utils.GdxTest;
-import com.badlogic.gdx.utils.reflect.ClassReflection;
-import com.badlogic.gdx.utils.reflect.Constructor;
-import com.badlogic.gdx.utils.reflect.Method;
-
-/** Performs some tests with {@link ClassReflection} and prints the results on the screen.
- * @author hneuer */
-public class ReflectionTest extends GdxTest {
-	String message = "";
-	BitmapFont font;
-	SpriteBatch batch;
-
-	@Override
-	public void create () {
-		font = new BitmapFont();
-		batch = new SpriteBatch();
-
-		try {
-			Vector2 fromDefaultConstructor = ClassReflection.newInstance(Vector2.class);
-			println("From default constructor: " + fromDefaultConstructor);
-
-			Method mSet = ClassReflection.getMethod(Vector2.class, "set", float.class, float.class);
-			mSet.invoke(fromDefaultConstructor, 10, 11);
-			println("Set to 10/11: " + fromDefaultConstructor);
-
-			Constructor copyConstroctor = ClassReflection.getConstructor(Vector2.class, Vector2.class);
-			Vector2 fromCopyConstructor = (Vector2)copyConstroctor.newInstance(fromDefaultConstructor);
-			println("From copy constructor: " + fromCopyConstructor);
-
-			Method mMul = ClassReflection.getMethod(Vector2.class, "mul", float.class);
-			println("Multiplied by 2; " + mMul.invoke(fromCopyConstructor, 2));
-
-			Method mNor = ClassReflection.getMethod(Vector2.class, "nor");
-			println("Normalized: " + mNor.invoke(fromCopyConstructor));
-		} catch (Exception e) {
-			message = "FAILED: " + e.getMessage();
-		}
-
-	}
-
-	private void println (String line) {
-		message += line + "\n";
-	}
-
-	@Override
-	public void render () {
-		Gdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
-		batch.begin();
-		font.drawMultiLine(batch, message, 20, Gdx.graphics.getHeight() - 20);
-		batch.end();
-	}
-
-	@Override
-	public void dispose () {
-		batch.dispose();
-		font.dispose();
-	}
-
-	@Override
-	public boolean needsGL20 () {
-		return true;
-	}
-
-}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/gwt/GwtTestWrapper.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/gwt/GwtTestWrapper.java
index 404c8b5..8b47e56 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/gwt/GwtTestWrapper.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/gwt/GwtTestWrapper.java
@@ -77,7 +77,6 @@ import com.badlogic.gdx.tests.ParallaxTest;
 import com.badlogic.gdx.tests.ParticleEmitterTest;
 import com.badlogic.gdx.tests.PixelsPerInchTest;
 import com.badlogic.gdx.tests.ProjectiveTextureTest;
-import com.badlogic.gdx.tests.ReflectionTest;
 import com.badlogic.gdx.tests.RotationTest;
 import com.badlogic.gdx.tests.ShapeRendererTest;
 import com.badlogic.gdx.tests.SimpleAnimationTest;
@@ -112,8 +111,8 @@ public class GwtTestWrapper extends GdxTest {
 	@Override
 	public void create () {
 		Gdx.app.setLogLevel(Application.LOG_DEBUG);
-		Gdx.app.log("GdxTestGwt", "Setting up for " + tests.length + " tests.");
-
+		Gdx.app.log("GdxTestGwt", "Setting up for " +tests.length+ " tests.");
+		
 		ui = new Stage(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), true);
 		skin = new Skin(Gdx.files.internal("data/uiskin.json"));
 		font = new BitmapFont(Gdx.files.internal("data/arial-15.fnt"), false);
@@ -157,8 +156,9 @@ public class GwtTestWrapper extends GdxTest {
 
 			@Override
 			public boolean touchDown (int screenX, int screenY, int pointer, int button) {
-				if (screenX < Gdx.graphics.getWidth() / 10.0 && screenY < Gdx.graphics.getHeight() / 10.0) {
-					if (test != null) {
+				if(screenX < Gdx.graphics.getWidth() / 10.0 &&
+					screenY < Gdx.graphics.getHeight() / 10.0) {
+					if(test != null) {
 						dispose = true;
 					}
 				}
@@ -166,10 +166,10 @@ public class GwtTestWrapper extends GdxTest {
 			}
 		};
 		((InputWrapper)Gdx.input).multiplexer.addProcessor(ui);
-
+		
 		Gdx.app.log("GdxTestGwt", "Test picker UI setup complete.");
 	}
-
+	
 	public void render () {
 		if (test == null) {
 			Gdx.gl.glViewport(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
@@ -588,7 +588,7 @@ public class GwtTestWrapper extends GdxTest {
 			public GdxTest instance () {
 				return new RotationTest();
 			}
-		},
+		}, 
 // new Instancer() {public GdxTest instance(){return new RunnablePostTest();}}, // Goes into infinite loop
 // new Instancer() {public GdxTest instance(){return new ScrollPaneTest();}}, // FIXME this messes up stuff, why?
 // new Instancer() {public GdxTest instance(){return new ShaderMultitextureTest();}}, // FIXME fucks up stuff
@@ -671,14 +671,10 @@ public class GwtTestWrapper extends GdxTest {
 				return new SuperKoalio();
 			}
 		}, new Instancer() {
-			public GdxTest instance () {
-				return new ReflectionTest();
-			}
-		}, new Instancer() {
-			public GdxTest instance () {
-				return new TiledMapAtlasAssetManagerTest();
-			}
-		}};
+		public GdxTest instance () {
+			return new TiledMapAtlasAssetManagerTest();
+		}
+	}};	
 
 	@Override
 	public boolean needsGL20 () {
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/net/NetAPITest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/net/NetAPITest.java
index 068f868..9f3d816 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/net/NetAPITest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/net/NetAPITest.java
@@ -42,16 +42,14 @@ public class NetAPITest extends GdxTest implements HttpResponseListener {
 	SpriteBatch batch;
 	Skin skin;
 	Stage stage;
-	TextButton btnDownloadImage;
-	TextButton btnDownloadText;
-	TextButton btnDownloadError;
-	TextButton btnPost;
+	TextButton textButton;
+	TextButton textButtonTxt;
 	Label statusLabel;
 	Texture texture;
 	String text;
 	BitmapFont font;
 
-	Object clickedButton;
+	boolean doImageDownload;
 
 	public boolean needsGL20 () {
 		// just because the non pot, we could change the image instead...
@@ -91,55 +89,39 @@ public class NetAPITest extends GdxTest implements HttpResponseListener {
 				public void clicked (InputEvent event, float x, float y) {
 					super.clicked(event, x, y);
 
-					clickedButton = event.getListenerActor();
-					setButtonDisabled(true);
+					doImageDownload = event.getListenerActor() == textButton;
+
+					textButton.setDisabled(true);
+					textButton.setTouchable(Touchable.disabled);
+
+					textButtonTxt.setDisabled(true);
+					textButtonTxt.setTouchable(Touchable.disabled);
+
 					if (texture != null) texture.dispose();
 					texture = null;
 					text = null;
 
-					String url;
-					String httpMethod = Net.HttpMethods.GET;
-					String requestContent = null;
-					if (clickedButton == btnDownloadImage)
-						url = "http://i.imgur.com/vxomF.jpg";
-					else if (clickedButton == btnDownloadText)
-						url = "http://www.apache.org/licenses/LICENSE-2.0.txt";
-					else if (clickedButton == btnDownloadError)
-						url = "http://www.badlogicgames.com/doesnotexist";
-					else {
-						url = "http://posttestserver.com/post.php?dump";
-						httpMethod = Net.HttpMethods.POST;
-						requestContent = "name1=value1&name2=value2";
-					}
-
-					HttpRequest httpRequest = new HttpRequest(httpMethod);
-					httpRequest.setUrl(url);
-					httpRequest.setContent(requestContent);
+					HttpRequest httpRequest = new HttpRequest(Net.HttpMethods.GET);
+					if (doImageDownload)
+						httpRequest.setUrl("http://i.imgur.com/vxomF.jpg");
+					else
+						httpRequest.setUrl("http://www.apache.org/licenses/LICENSE-2.0.txt");
+
 					Gdx.net.sendHttpRequest(httpRequest, NetAPITest.this);
 
 					statusLabel.setText("Downloading data from " + httpRequest.getUrl());
 				}
 			};
 
-			btnDownloadImage = new TextButton("GET Image", skin);
-			btnDownloadImage.setPosition(Gdx.graphics.getWidth() * 0.5f - btnDownloadImage.getWidth() * 1.5f, 60f);
-			btnDownloadImage.addListener(clickListener);
-			stage.addActor(btnDownloadImage);
-
-			btnDownloadText = new TextButton("GET Text", skin);
-			btnDownloadText.setPosition(btnDownloadImage.getX() + btnDownloadImage.getWidth() + 10, 60f);
-			btnDownloadText.addListener(clickListener);
-			stage.addActor(btnDownloadText);
-
-			btnDownloadError = new TextButton("GET Error", skin);
-			btnDownloadError.setPosition(btnDownloadText.getX() + btnDownloadText.getWidth() + 10, 60f);
-			btnDownloadError.addListener(clickListener);
-			stage.addActor(btnDownloadError);
-
-			btnPost = new TextButton("POST", skin);
-			btnPost.setPosition(btnDownloadError.getX() + btnDownloadError.getWidth() + 10, 60f);
-			btnPost.addListener(clickListener);
-			stage.addActor(btnPost);
+			textButton = new TextButton("Download image", skin);
+			textButton.setPosition(Gdx.graphics.getWidth() * 0.5f - textButton.getWidth(), 60f);
+			textButton.addListener(clickListener);
+			stage.addActor(textButton);
+
+			textButtonTxt = new TextButton("Download text", skin);
+			textButtonTxt.setPosition(Gdx.graphics.getWidth() * 0.5f, 60f);
+			textButtonTxt.addListener(clickListener);
+			stage.addActor(textButtonTxt);
 		}
 
 	}
@@ -153,17 +135,19 @@ public class NetAPITest extends GdxTest implements HttpResponseListener {
 			@Override
 			public void run () {
 				statusLabel.setText("HTTP Request status: " + statusCode);
-				setButtonDisabled(false);
+				textButton.setDisabled(false);
+				textButton.setTouchable(Touchable.enabled);
+				textButtonTxt.setDisabled(false);
+				textButtonTxt.setTouchable(Touchable.enabled);
 			}
 		});
 
 		if (statusCode != 200) {
 			Gdx.app.log("NetAPITest", "An error ocurred since statusCode is not OK");
-			setText(httpResponse);
 			return;
 		}
 
-		if (clickedButton == btnDownloadImage) {
+		if (doImageDownload) {
 			final byte[] rawImageBytes = httpResponse.getResult();
 			Gdx.app.postRunnable(new Runnable() {
 				public void run () {
@@ -174,38 +158,21 @@ public class NetAPITest extends GdxTest implements HttpResponseListener {
 				}
 			});
 		} else {
-			setText(httpResponse);
+			final String newText = httpResponse.getResultAsString();
+			Gdx.app.postRunnable(new Runnable() {
+				public void run () {
+					text = newText;
+				}
+			});
 		}
 	}
 
-	void setText (HttpResponse httpResponse) {
-		final String newText = httpResponse.getResultAsString();
-		Gdx.app.postRunnable(new Runnable() {
-			public void run () {
-				text = newText;
-			}
-		});
-	}
-
-	void setButtonDisabled (boolean disabled) {
-		Touchable t = disabled ? Touchable.disabled : Touchable.enabled;
-
-		btnDownloadImage.setDisabled(disabled);
-		btnDownloadImage.setTouchable(t);
-
-		btnDownloadText.setDisabled(disabled);
-		btnDownloadText.setTouchable(t);
-
-		btnDownloadError.setDisabled(disabled);
-		btnDownloadError.setTouchable(t);
-
-		btnPost.setDisabled(disabled);
-		btnPost.setTouchable(t);
-	}
-
 	@Override
 	public void failed (Throwable t) {
-		setButtonDisabled(false);
+		textButton.setDisabled(false);
+		textButton.setTouchable(Touchable.enabled);
+		textButtonTxt.setDisabled(false);
+		textButtonTxt.setTouchable(Touchable.enabled);
 		statusLabel.setText("Failed to perform the HTTP Request: " + t.getMessage());
 		t.printStackTrace();
 	}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
index cfc3965..16d3b1c 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
@@ -163,7 +163,6 @@ public class GdxTests {
 		PreferencesTest.class,
 		ProjectTest.class,
 		ProjectiveTextureTest.class,
-		ReflectionTest.class,
 		RemoteTest.class,
 		RotationTest.class,
 		RunnablePostTest.class,
