diff --git a/CHANGES b/CHANGES
index a8cc0e5..43ab6a3 100644
--- a/CHANGES
+++ b/CHANGES
@@ -1,14 +1,4 @@
-[1.5.6]
-- API Change: Refactored Window. https://github.com/libgdx/libgdx/commit/7d372b3c67d4fcfe4e82546b0ad6891d14d03242
-- Added VertexBufferObjectWithVAO, see https://github.com/libgdx/libgdx/pull/2527
-- API Change: Removed Mesh.create(...), use MeshBuilder instead
-- API Change: BitmapFontData, BitmapFont, and BitmapFontCache have been refactored. http://www.badlogicgames.com/wordpress/?p=3658
-- FreeTypeFontGenerator can now render glyphs on the fly.
-- Attribute now implements Comparable, custom attributes might need to be updated, see: https://github.com/libgdx/libgdx/wiki/Material-and-environment#custom-attributes
-- API Change: Removed (previously deprecated) GLTexture#createTextureData/createGLHandle, Ray#getEndPoint(float), Color#tmp, Node#parent/children, VertexAttribute#Color(), Usage#Color, ModelBuilder#createFromMesh, BoundingBox#getCenter()/updateCorners()/getCorners(), Matrix4.tmp
-
 [1.5.5]
-- Added iOS ARM-64 bit support for Bullet physics
 - 3D Animation, NodeAnimation keyframes are separated into translation, rotation and scaling
 - Added capability to enable color markup from inside skin json file.
 - Exposed method ControllerManager#clearListeners on Controllers class
@@ -18,6 +8,8 @@
 - API Change: Group#toString now returns actor hierarchy. Group#print is gone.
 - Added SpotLight class, see https://github.com/libgdx/libgdx/pull/2907
 - Added support for resolving file handles using classpaths (ClasspathFileHandleResolver)
+- Added FrameBufferCubemap
+- Added GLFrameBuffer
 
 [1.5.4]
 - Added support for image layers in Tiled maps (TiledMapImageLayer)
diff --git a/CONTRIBUTORS b/CONTRIBUTORS
index ae50b71..650fcf2 100644
--- a/CONTRIBUTORS
+++ b/CONTRIBUTORS
@@ -172,4 +172,5 @@ CodePoKE https://github.com/codepoke
 Konijnendijk https://github.com/Konijnendijk
 nooone https://github.com/nooone
 kotcrab https://github.com/kotcrab
-ClaudiuBele https://github.com/ClaudiuBele
\ No newline at end of file
+ClaudiuBele https://github.com/ClaudiuBele
+realitix https://github.com/realitix
diff --git a/backends/gdx-backend-android/pom.xml b/backends/gdx-backend-android/pom.xml
index faeeb41..9310b5d 100644
--- a/backends/gdx-backend-android/pom.xml
+++ b/backends/gdx-backend-android/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.5.6-SNAPSHOT</version>
+    <version>1.5.5-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/backends/gdx-backend-headless/pom.xml b/backends/gdx-backend-headless/pom.xml
index d3d0d7b..2d412a1 100644
--- a/backends/gdx-backend-headless/pom.xml
+++ b/backends/gdx-backend-headless/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.5.6-SNAPSHOT</version>
+    <version>1.5.5-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/HeadlessApplication.java b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/HeadlessApplication.java
index 5ecf0c5..57e4276 100644
--- a/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/HeadlessApplication.java
+++ b/backends/gdx-backend-headless/src/com/badlogic/gdx/backends/headless/HeadlessApplication.java
@@ -143,7 +143,7 @@ public class HeadlessApplication implements Application {
 	public boolean executeRunnables () {
 		synchronized (runnables) {
 			for (int i = runnables.size - 1; i >= 0; i--)
-				executedRunnables.add(runnables.get(i));
+				executedRunnables.addAll(runnables.get(i));
 			runnables.clear();
 		}
 		if (executedRunnables.size == 0) return false;
diff --git a/backends/gdx-backend-jglfw/pom.xml b/backends/gdx-backend-jglfw/pom.xml
index 87ab1a2..9bddcad 100644
--- a/backends/gdx-backend-jglfw/pom.xml
+++ b/backends/gdx-backend-jglfw/pom.xml
@@ -4,7 +4,7 @@
 	<parent>
 		<groupId>com.badlogicgames.gdx</groupId>
 		<artifactId>gdx-parent</artifactId>
-		<version>1.5.6-SNAPSHOT</version>
+		<version>1.5.5-SNAPSHOT</version>
 		<relativePath>../../pom.xml</relativePath>
 	</parent>
 
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwApplication.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwApplication.java
index 14a3b93..76248be 100644
--- a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwApplication.java
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwApplication.java
@@ -239,13 +239,12 @@ public class JglfwApplication implements Application {
 	public boolean executeRunnables () {
 		synchronized (runnables) {
 			for (int i = runnables.size - 1; i >= 0; i--)
-				executedRunnables.add(runnables.get(i));
+				executedRunnables.addAll(runnables.get(i));
 			runnables.clear();
 		}
 		if (executedRunnables.size == 0) return false;
-		do
-			executedRunnables.pop().run();
-		while (executedRunnables.size > 0);
+		for (int i = executedRunnables.size - 1; i >= 0; i--)
+			executedRunnables.removeIndex(i).run();
 		return true;
 	}
 
diff --git a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwInput.java b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwInput.java
index 8b44858..c0e7857 100644
--- a/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwInput.java
+++ b/backends/gdx-backend-jglfw/src/com/badlogic/gdx/backends/jglfw/JglfwInput.java
@@ -840,7 +840,6 @@ public class JglfwInput implements Input {
 		}
 
 		public void character (long window, char character) {
-			if ((character & 0xff00) == 0xf700) return;
 			lastCharacter = character;
 			processor.keyTyped(character);
 		}
diff --git a/backends/gdx-backend-lwjgl/pom.xml b/backends/gdx-backend-lwjgl/pom.xml
index debd01f..f11bb57 100644
--- a/backends/gdx-backend-lwjgl/pom.xml
+++ b/backends/gdx-backend-lwjgl/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.5.6-SNAPSHOT</version>
+    <version>1.5.5-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglAWTCanvas.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglAWTCanvas.java
index 56a5445..caeff83 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglAWTCanvas.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglAWTCanvas.java
@@ -244,9 +244,10 @@ public class LwjglAWTCanvas implements Application {
 			executedRunnables.clear();
 			executedRunnables.addAll(runnables);
 			runnables.clear();
-			while (executedRunnables.size() > 0) {
+
+			for (int i = 0; i < executedRunnables.size(); i++) {
 				try {
-					executedRunnables.remove(executedRunnables.size() - 1).run();
+					executedRunnables.get(i).run();
 				} catch (Throwable t) {
 					t.printStackTrace();
 				}
@@ -399,7 +400,7 @@ public class LwjglAWTCanvas implements Application {
 	}
 
 	@Override
-	public int getLogLevel () {
+	public int getLogLevel() {
 		return logLevel;
 	}
 
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplication.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplication.java
index f16659e..d21ecbb 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplication.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglApplication.java
@@ -73,7 +73,7 @@ public class LwjglApplication implements Application {
 	}
 
 	public LwjglApplication (ApplicationListener listener, LwjglApplicationConfiguration config, LwjglGraphics graphics) {
-		LwjglNativesLoader.load();
+		LwjglNativesLoader.load();		
 
 		if (config.title == null) config.title = listener.getClass().getSimpleName();
 
@@ -82,7 +82,7 @@ public class LwjglApplication implements Application {
 			try {
 				audio = new OpenALAudio(config.audioDeviceSimultaneousSources, config.audioDeviceBufferCount,
 					config.audioDeviceBufferSize);
-			} catch (Throwable t) {
+			} catch(Throwable t) {
 				log("LwjglApplication", "Couldn't initialize audio, disabling audio", t);
 				LwjglApplicationConfiguration.disableAudio = true;
 			}
@@ -167,7 +167,7 @@ public class LwjglApplication implements Application {
 					for (LifecycleListener listener : lifecycleListeners)
 						listener.resume();
 				}
-				listener.resume();
+				listener.resume();				
 			}
 
 			boolean shouldRender = false;
@@ -185,10 +185,9 @@ public class LwjglApplication implements Application {
 			} else {
 				graphics.config.x = Display.getX();
 				graphics.config.y = Display.getY();
-				if (graphics.resize || Display.wasResized()
-					|| (int)(Display.getWidth() * Display.getPixelScaleFactor()) != graphics.config.width
+				if (graphics.resize || Display.wasResized() || (int)(Display.getWidth() * Display.getPixelScaleFactor()) != graphics.config.width
 					|| (int)(Display.getHeight() * Display.getPixelScaleFactor()) != graphics.config.height) {
-					graphics.resize = false;
+					graphics.resize = false;					
 					graphics.config.width = (int)(Display.getWidth() * Display.getPixelScaleFactor());
 					graphics.config.height = (int)(Display.getHeight() * Display.getPixelScaleFactor());
 					Gdx.gl.glViewport(0, 0, graphics.config.width, graphics.config.height);
@@ -239,13 +238,12 @@ public class LwjglApplication implements Application {
 	public boolean executeRunnables () {
 		synchronized (runnables) {
 			for (int i = runnables.size - 1; i >= 0; i--)
-				executedRunnables.add(runnables.get(i));
+				executedRunnables.addAll(runnables.get(i));
 			runnables.clear();
 		}
 		if (executedRunnables.size == 0) return false;
-		do
-			executedRunnables.pop().run();
-		while (executedRunnables.size > 0);
+		for (int i = executedRunnables.size - 1; i >= 0; i--)
+			executedRunnables.removeIndex(i).run();
 		return true;
 	}
 
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglCanvas.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglCanvas.java
index b76f421..3d6472d 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglCanvas.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglCanvas.java
@@ -45,8 +45,6 @@ import com.badlogic.gdx.utils.SharedLibraryLoader;
  * call {@link #stop()} or a Swing application may deadlock on System.exit due to how LWJGL and/or Swing deal with shutdown hooks.
  * @author Nathan Sweet */
 public class LwjglCanvas implements Application {
-	static boolean isWindows = System.getProperty("os.name").contains("Windows");
-
 	LwjglGraphics graphics;
 	OpenALAudio audio;
 	LwjglFiles files;
@@ -209,7 +207,6 @@ public class LwjglCanvas implements Application {
 				}
 				try {
 					Display.processMessages();
-					if (cursor != null || !isWindows) canvas.setCursor(cursor);
 
 					boolean shouldRender = false;
 
@@ -241,6 +238,8 @@ public class LwjglCanvas implements Application {
 						Display.update(false);
 					}
 
+					canvas.setCursor(cursor);
+
 					Display.sync(getFrameRate());
 				} catch (Throwable ex) {
 					exception(ex);
@@ -257,9 +256,8 @@ public class LwjglCanvas implements Application {
 			runnables.clear();
 		}
 		if (executedRunnables.size == 0) return false;
-		do
-			executedRunnables.pop().run();
-		while (executedRunnables.size > 0);
+		for (int i = executedRunnables.size - 1; i >= 0; i--)
+			executedRunnables.removeIndex(i).run();
 		return true;
 	}
 
diff --git a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGraphics.java b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGraphics.java
index bd5146e..9eb97bb 100644
--- a/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGraphics.java
+++ b/backends/gdx-backend-lwjgl/src/com/badlogic/gdx/backends/lwjgl/LwjglGraphics.java
@@ -16,6 +16,14 @@
 
 package com.badlogic.gdx.backends.lwjgl;
 
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.Graphics;
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.gdx.graphics.GL30;
+import com.badlogic.gdx.graphics.Pixmap;
+import com.badlogic.gdx.graphics.Pixmap.Format;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
 import java.awt.Canvas;
 import java.awt.Toolkit;
 import java.nio.ByteBuffer;
@@ -26,14 +34,6 @@ import org.lwjgl.opengl.Display;
 import org.lwjgl.opengl.GL11;
 import org.lwjgl.opengl.PixelFormat;
 
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.Graphics;
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.GL30;
-import com.badlogic.gdx.graphics.Pixmap;
-import com.badlogic.gdx.graphics.Pixmap.Format;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-
 /** An implementation of the {@link Graphics} interface based on Lwjgl.
  * @author mzechner */
 public class LwjglGraphics implements Graphics {
@@ -247,7 +247,7 @@ public class LwjglGraphics implements Graphics {
 		major = Integer.parseInt("" + version.charAt(0));
 		minor = Integer.parseInt("" + version.charAt(2));
 
-		if (config.useGL30 && major >= 3) {
+		if (major >= 3) {
 			gl30 = new LwjglGL30();
 			gl20 = gl30;
 		} else {
@@ -447,23 +447,8 @@ public class LwjglGraphics implements Graphics {
 	}
 
 	@Override
-	public boolean supportsExtension(String extension) {
-		if (extensions == null) {
-			if(gl30 != null) {
-				//old style glGetString(GL_EXTENSIONS) is not valid in 3.2 core:
-				StringBuilder extensionsBuilder = new StringBuilder();
-
-				int numExtensions = GL11.glGetInteger(GL30.GL_NUM_EXTENSIONS);
-				for (int i = 0; i < numExtensions; ++i) {
-					extensionsBuilder.append(gl30.glGetStringi(GL20.GL_EXTENSIONS, i));
-					extensionsBuilder.append(" ");
-				}
-				extensions = extensionsBuilder.toString();
-			} else {
-				extensions = gl20.glGetString(GL20.GL_EXTENSIONS);
-			}
-		}
-
+	public boolean supportsExtension (String extension) {
+		if (extensions == null) extensions = gl20.glGetString(GL20.GL_EXTENSIONS);
 		return extensions.contains(extension);
 	}
 
diff --git a/backends/gdx-backend-robovm/pom.xml b/backends/gdx-backend-robovm/pom.xml
index f008434..1abb388 100644
--- a/backends/gdx-backend-robovm/pom.xml
+++ b/backends/gdx-backend-robovm/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.5.6-SNAPSHOT</version>
+    <version>1.5.5-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplication.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplication.java
index 9f2da11..cb53078 100644
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplication.java
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSApplication.java
@@ -350,7 +350,7 @@ public class IOSApplication implements Application {
 	@Override
 	public void debug (String tag, String message, Throwable exception) {
 		if (logLevel >= LOG_DEBUG) {
-			Foundation.log("%@", new NSString("[debug] " + tag + ": " + message));
+			Foundation.log("%@", new NSString("[error] " + tag + ": " + message));
 			exception.printStackTrace();
 		}
 	}
diff --git a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSInput.java b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSInput.java
index 8702e62..31ccd08 100644
--- a/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSInput.java
+++ b/backends/gdx-backend-robovm/src/com/badlogic/gdx/backends/iosrobovm/IOSInput.java
@@ -85,7 +85,7 @@ public class IOSInput implements Input {
 	}
 
 	private static final NSObjectWrapper<UITouch> UI_TOUCH_WRAPPER = new NSObjectWrapper<UITouch>(UITouch.class);
-	static final NSObjectWrapper<UIAcceleration> UI_ACCELERATION_WRAPPER = new NSObjectWrapper<UIAcceleration>(UIAcceleration.class);
+	private static final NSObjectWrapper<UIAcceleration> UI_ACCELERATION_WRAPPER = new NSObjectWrapper<UIAcceleration>(UIAcceleration.class);
 	
 	IOSApplication app;
 	IOSApplicationConfiguration config;
diff --git a/backends/gdx-backends-gwt/pom.xml b/backends/gdx-backends-gwt/pom.xml
index b77a877..1d03e99 100644
--- a/backends/gdx-backends-gwt/pom.xml
+++ b/backends/gdx-backends-gwt/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.5.6-SNAPSHOT</version>
+    <version>1.5.5-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtNet.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtNet.java
index c3fbed8..8a9479d 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtNet.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/GwtNet.java
@@ -79,16 +79,13 @@ public class GwtNet implements Net {
 			Map<String, List<String>> headers = new HashMap<String, List<String>>();
 			Header[] responseHeaders = response.getHeaders();
 			for (int i = 0; i < responseHeaders.length; i++) {
-				Header header = responseHeaders[i];
-				if (header != null) {
-					String headerName = responseHeaders[i].getName();
-					List<String> headerValues = headers.get(headerName);
-					if (headerValues == null) {
-						headerValues = new ArrayList<String>();
-						headers.put(headerName, headerValues);
-					}
-					headerValues.add(responseHeaders[i].getValue());
+				String headerName = responseHeaders[i].getName();
+				List<String> headerValues = headers.get(headerName);
+				if (headerValues == null) {
+					headerValues = new ArrayList<String>();
+					headers.put(headerName, headerValues);
 				}
+				headerValues.add(responseHeaders[i].getValue());
 			}
 			return headers;
 		}
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/Pixmap.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/Pixmap.java
index 9f6caad..fcf8250 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/Pixmap.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/Pixmap.java
@@ -358,7 +358,7 @@ public class Pixmap implements Disposable {
 		if (blending == Blending.None) {
 			context.setFillStyle(clearColor);
 			context.setStrokeStyle(clearColor);
-			context.setGlobalCompositeOperation("destination-out");
+			context.setGlobalCompositeOperation("clear");
 			context.beginPath();
 			context.arc(x, y, radius, 0, 2 * Math.PI, false);
 			fillOrStrokePath(drawType);
@@ -378,7 +378,7 @@ public class Pixmap implements Disposable {
 		if (blending == Blending.None) {
 			context.setFillStyle(clearColor);
 			context.setStrokeStyle(clearColor);
-			context.setGlobalCompositeOperation("destination-out");
+			context.setGlobalCompositeOperation("clear");
 			context.beginPath();
 			context.moveTo(x, y);
 			context.lineTo(x2, y2);
@@ -399,7 +399,7 @@ public class Pixmap implements Disposable {
 		if (blending == Blending.None) {
 			context.setFillStyle(clearColor);
 			context.setStrokeStyle(clearColor);
-			context.setGlobalCompositeOperation("destination-out");
+			context.setGlobalCompositeOperation("clear");
 			context.beginPath();
 			context.rect(x, y, width, height);
 			fillOrStrokePath(drawType);
@@ -419,7 +419,7 @@ public class Pixmap implements Disposable {
 		if (blending == Blending.None) {
 			context.setFillStyle(clearColor);
 			context.setStrokeStyle(clearColor);
-			context.setGlobalCompositeOperation("destination-out");
+			context.setGlobalCompositeOperation("clear");
 			context.beginPath();
 			context.moveTo(x1,y1);
 			context.lineTo(x2,y2);
@@ -445,7 +445,7 @@ public class Pixmap implements Disposable {
 		if (blending == Blending.None) {
 			context.setFillStyle(clearColor);
 			context.setStrokeStyle(clearColor);
-			context.setGlobalCompositeOperation("destination-out");
+			context.setGlobalCompositeOperation("clear");
 			context.beginPath();
 			context.rect(dstX, dstY, dstWidth, dstHeight);
 			fillOrStrokePath(DrawType.FILL);
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/glutils/VertexBufferObjectWithVAO.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/glutils/VertexBufferObjectWithVAO.java
deleted file mode 100644
index 76fd807..0000000
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/graphics/glutils/VertexBufferObjectWithVAO.java
+++ /dev/null
@@ -1,238 +0,0 @@
-package com.badlogic.gdx.graphics.glutils;
-
-import java.nio.ByteBuffer;
-import java.nio.FloatBuffer;
-import java.nio.IntBuffer;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.GL30;
-import com.badlogic.gdx.graphics.VertexAttribute;
-import com.badlogic.gdx.graphics.VertexAttributes;
-import com.badlogic.gdx.utils.BufferUtils;
-
-/**
- * <p>
- * A {@link VertexData} implementation that uses vertex buffer objects and vertex array objects.
- * (This is required for OpenGL 3.0+ core profiles. In particular, the default VAO has been
- * deprecated, as has the use of client memory for passing vertex attributes.) Use of VAOs should
- * give a slight performance benefit since you don't have to bind the attributes on every draw
- * anymore.
- * </p>
- *
- * <p>
- * If the OpenGL ES context was lost you can call {@link #invalidate()} to recreate a new OpenGL vertex buffer object.
- * </p>
- *
- * <p>
- * VertexBufferObjectWithVAO objects must be disposed via the {@link #dispose()} method when no longer needed
- * </p>
- *
- * Code adapted from {@link VertexBufferObject}.
- * @author mzechner, Dave Clayton <contact@redskyforge.com>, Nate Austin <nate.austin gmail>
- */
-public class VertexBufferObjectWithVAO implements VertexData {
-	final static IntBuffer tmpHandle = BufferUtils.newIntBuffer(1);
-
-	final VertexAttributes attributes;
-	final FloatBuffer buffer;
-	int bufferHandle;
-	final boolean isStatic;
-	final int usage;
-	boolean isDirty = false;
-	boolean isBound = false;
-	boolean vaoDirty = true;
-	int vaoHandle = -1;
-
-
-	/**
-	 * Constructs a new interleaved VertexBufferObjectWithVAO.
-	 *
-	 * @param isStatic    whether the vertex data is static.
-	 * @param numVertices the maximum number of vertices
-	 * @param attributes  the {@link com.badlogic.gdx.graphics.VertexAttribute}s.
-	 */
-	public VertexBufferObjectWithVAO(boolean isStatic, int numVertices, VertexAttribute... attributes) {
-		this(isStatic, numVertices, new VertexAttributes(attributes));
-	}
-
-	/**
-	 * Constructs a new interleaved VertexBufferObjectWithVAO.
-	 *
-	 * @param isStatic    whether the vertex data is static.
-	 * @param numVertices the maximum number of vertices
-	 * @param attributes  the {@link VertexAttributes}.
-	 */
-	public VertexBufferObjectWithVAO(boolean isStatic, int numVertices, VertexAttributes attributes) {
-		this.isStatic = isStatic;
-		this.attributes = attributes;
-
-		buffer = BufferUtils.newFloatBuffer(this.attributes.vertexSize / 4 * numVertices);
-		buffer.flip();
-		bufferHandle = Gdx.gl20.glGenBuffer();
-		usage = isStatic ? GL20.GL_STATIC_DRAW : GL20.GL_DYNAMIC_DRAW;
-	}
-
-	@Override
-	public VertexAttributes getAttributes() {
-		return attributes;
-	}
-
-	@Override
-	public int getNumVertices() {
-		return buffer.limit() * 4 / attributes.vertexSize;
-	}
-
-	@Override
-	public int getNumMaxVertices() {
-		return buffer.capacity() * 4 / attributes.vertexSize;
-	}
-
-	@Override
-	public FloatBuffer getBuffer() {
-		isDirty = true;
-		return buffer;
-	}
-
-	private void bufferChanged() {
-		if (isBound) {
-			Gdx.gl20.glBufferData(GL20.GL_ARRAY_BUFFER, buffer.limit(), buffer, usage);
-			isDirty = false;
-		}
-	}
-
-	@Override
-	public void setVertices (float[] vertices, int offset, int count) {
-		isDirty = true;
-		BufferUtils.copy(vertices, buffer, count, offset);
-		buffer.position(0);
-		buffer.limit(count);
-		bufferChanged();
-	}
-
-	@Override
-	public void updateVertices (int targetOffset, float[] vertices, int sourceOffset, int count) {
-		isDirty = true;
-		final int pos = buffer.position();
-		buffer.position(targetOffset);
-		BufferUtils.copy(vertices, sourceOffset, count, buffer);
-		buffer.position(pos);
-		bufferChanged();
-	}
-
-	/**
-	 * Binds this VertexBufferObject for rendering via glDrawArrays or glDrawElements
-	 *
-	 * @param shader the shader
-	 */
-	@Override
-	public void bind(ShaderProgram shader) {
-		bind(shader, null);
-	}
-
-	@Override
-	public void bind(ShaderProgram shader, int[] locations) {
-		GL30 gl = Gdx.gl30;
-		if (vaoDirty || !gl.glIsVertexArray(vaoHandle)) {
-			tmpHandle.clear();
-			gl.glGenVertexArrays(1, tmpHandle);
-			vaoHandle = tmpHandle.get(0);
-			gl.glBindVertexArray(vaoHandle);
-
-			//initialize the VAO with our vertex attributes and buffer:
-			bindAttributes(shader, locations);
-			vaoDirty = false;
-
-		} else {
-			//else simply bind the VAO.
-			gl.glBindVertexArray(vaoHandle);
-		}
-		//if our data has changed upload it:
-		bindData(gl);
-
-		isBound = true;
-	}
-
-	private void bindAttributes(ShaderProgram shader, int[] locations) {
-		final GL20 gl = Gdx.gl20;
-		gl.glBindBuffer(GL20.GL_ARRAY_BUFFER, bufferHandle);
-		final int numAttributes = attributes.size();
-		if (locations == null) {
-			for (int i = 0; i < numAttributes; i++) {
-				final VertexAttribute attribute = attributes.get(i);
-				final int location = shader.getAttributeLocation(attribute.alias);
-				if (location < 0) continue;
-				shader.enableVertexAttribute(location);
-
-				shader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,
-						attribute.offset);
-			}
-
-		} else {
-			for (int i = 0; i < numAttributes; i++) {
-				final VertexAttribute attribute = attributes.get(i);
-				final int location = locations[i];
-				if (location < 0) continue;
-				shader.enableVertexAttribute(location);
-
-				shader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,
-						attribute.offset);
-			}
-		}
-	}
-
-	private void bindData(GL20 gl) {
-		if (isDirty) {
-			gl.glBindBuffer(GL20.GL_ARRAY_BUFFER, bufferHandle);
-			buffer.limit(buffer.limit());
-			gl.glBufferData(GL20.GL_ARRAY_BUFFER, buffer.limit(), buffer, usage);
-			isDirty = false;
-		}
-	}
-
-	/**
-	 * Unbinds this VertexBufferObject.
-	 *
-	 * @param shader the shader
-	 */
-	@Override
-	public void unbind(final ShaderProgram shader) {
-		unbind(shader, null);
-	}
-
-	@Override
-	public void unbind(final ShaderProgram shader, final int[] locations) {
-		GL30 gl = Gdx.gl30;
-		gl.glBindVertexArray(0);
-		isBound = false;
-	}
-
-	/**
-	 * Invalidates the VertexBufferObject so a new OpenGL buffer handle is created. Use this in case of a context loss.
-	 */
-	@Override
-	public void invalidate() {
-		bufferHandle = Gdx.gl20.glGenBuffer();
-		isDirty = true;
-		vaoDirty = true;
-	}
-
-	/**
-	 * Disposes of all resources this VertexBufferObject uses.
-	 */
-	@Override
-	public void dispose() {
-		GL30 gl = Gdx.gl30;
-
-		gl.glBindBuffer(GL20.GL_ARRAY_BUFFER, 0);
-		gl.glDeleteBuffer(bufferHandle);
-		bufferHandle = 0;
-
-		if (gl.glIsVertexArray(vaoHandle)) {
-			tmpHandle.clear();
-			tmpHandle.put(vaoHandle);
-			tmpHandle.flip();
-			gl.glDeleteVertexArrays(1, tmpHandle);
-		}
-	}
-}
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/ClassReflection.java b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/ClassReflection.java
index 4c3ce98..b6a27a2 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/ClassReflection.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gdx/backends/gwt/emu/com/badlogic/gdx/utils/reflect/ClassReflection.java
@@ -60,11 +60,6 @@ public final class ClassReflection {
 		return ReflectionCache.getType(c).isStatic();
 	}
 
-	/** Determines if the supplied Class object represents an array class. */
-	static public boolean isArray (Class c) {
-		return ReflectionCache.getType(c).isArray();
-	}
-	
 	/** Creates a new instance of the class represented by the supplied Class. */
 	static public <T> T newInstance (Class<T> c) throws ReflectionException {
 		try {
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/GwtReflect.gwt.xml b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/GwtReflect.gwt.xml
index c265481..3fa7c56 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/GwtReflect.gwt.xml
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/GwtReflect.gwt.xml
@@ -11,8 +11,6 @@
 	<extend-configuration-property name="gdx.reflect.include"
 		value="com.badlogic.gdx.math" />
 	<extend-configuration-property name="gdx.reflect.include"
-		value="com.badlogic.gdx.graphics.g2d.GlyphLayout" />
-	<extend-configuration-property name="gdx.reflect.include"
 		value="com.badlogic.gdx.graphics.g2d.TextureRegion" />
 	<extend-configuration-property name="gdx.reflect.include"
 		value="com.badlogic.gdx.graphics.g2d.BitmapFont" />
@@ -41,26 +39,19 @@
 		value="com.badlogic.gdx.Net" />
 	
 	<extend-configuration-property name="gdx.reflect.include"
-		value="com.badlogic.gdx.graphics.g3d.particles.ParticleEffect" />
-	<extend-configuration-property name="gdx.reflect.include"
-		value="com.badlogic.gdx.graphics.g3d.particles.ParticleController" />
-	<extend-configuration-property name="gdx.reflect.include"
-		value="com.badlogic.gdx.graphics.g3d.particles.ResourceData" />
-	<extend-configuration-property name="gdx.reflect.include"
-		value="com.badlogic.gdx.graphics.g3d.particles.ResourceData.SaveData" />
-	<extend-configuration-property name="gdx.reflect.include"
-		value="com.badlogic.gdx.graphics.g3d.particles.ResourceData.AssetData" />
-	<extend-configuration-property name="gdx.reflect.include"
 		value="com.badlogic.gdx.graphics.g3d.particles.ParallelArray" />
+		
 	<extend-configuration-property name="gdx.reflect.include"
-		value="com.badlogic.gdx.graphics.g3d.particles.values" />
+		value="com.badlogic.gdx.graphics.g3d.particles.influencers" />
+	
 	<extend-configuration-property name="gdx.reflect.include"
-		value="com.badlogic.gdx.graphics.g3d.particles.emitters" />
+		value="com.badlogic.gdx.graphics.g3d.particles.renderers.BillboardControllerRenderData" />
 	<extend-configuration-property name="gdx.reflect.include"
-		value="com.badlogic.gdx.graphics.g3d.particles.influencers" />
+		value="com.badlogic.gdx.graphics.g3d.particles.renderers.ModelInstanceControllerRenderData" />
 	<extend-configuration-property name="gdx.reflect.include"
-		value="com.badlogic.gdx.graphics.g3d.particles.renderers" />
-	
+		value="com.badlogic.gdx.graphics.g3d.particles.renderers.ParticleControllerRenderData" />
+	<extend-configuration-property name="gdx.reflect.include"
+		value="com.badlogic.gdx.graphics.g3d.particles.renderers.PointSpriteControllerRenderData" />
     <extend-configuration-property name="gdx.reflect.include"
         value="java.util.Collection" />
 	<extend-configuration-property name="gdx.reflect.include"
diff --git a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/gen/ReflectionCacheSourceCreator.java b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/gen/ReflectionCacheSourceCreator.java
index c388aa9..9f2cc80 100644
--- a/backends/gdx-backends-gwt/src/com/badlogic/gwtref/gen/ReflectionCacheSourceCreator.java
+++ b/backends/gdx-backends-gwt/src/com/badlogic/gwtref/gen/ReflectionCacheSourceCreator.java
@@ -147,16 +147,6 @@ public class ReflectionCacheSourceCreator {
 			}
 		}
 
-		// gather all types from explicitely requested packages
-		try {
-			ConfigurationProperty prop = context.getPropertyOracle().getConfigurationProperty("gdx.reflect.include");
-			for (String s : prop.getValues()) {
-				JClassType type = typeOracle.findType(s);
-				if (type != null) gatherTypes(type.getErasedType(), types);
-			}
-		} catch (BadPropertyValueException e) {
-		}
-
 		gatherTypes(typeOracle.findType("java.util.List").getErasedType(), types);
 		gatherTypes(typeOracle.findType("java.util.ArrayList").getErasedType(), types);
 		gatherTypes(typeOracle.findType("java.util.HashMap").getErasedType(), types);
diff --git a/extensions/gdx-box2d/gdx-box2d-gwt/pom.xml b/extensions/gdx-box2d/gdx-box2d-gwt/pom.xml
index c556978..5c04000 100644
--- a/extensions/gdx-box2d/gdx-box2d-gwt/pom.xml
+++ b/extensions/gdx-box2d/gdx-box2d-gwt/pom.xml
@@ -4,7 +4,7 @@
 	<parent>
 		<groupId>com.badlogicgames.gdx</groupId>
 		<artifactId>gdx-box2d-parent</artifactId>
-		<version>1.5.6-SNAPSHOT</version>
+		<version>1.5.5-SNAPSHOT</version>
 		<relativePath>../pom.xml</relativePath>
 	</parent>
 
diff --git a/extensions/gdx-box2d/gdx-box2d/jni/build-ios32.xml b/extensions/gdx-box2d/gdx-box2d/jni/build-ios32.xml
index c3b584a..712691c 100644
--- a/extensions/gdx-box2d/gdx-box2d/jni/build-ios32.xml
+++ b/extensions/gdx-box2d/gdx-box2d/jni/build-ios32.xml
@@ -12,9 +12,9 @@
 	<!-- the compilerPrefix for the C & C++ compilers -->
 	<property name="compilerPrefix" value=""/>	
 	<property name="iphoneos-platform" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin"/>
-	<property name="iphoneos-sdk" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.2.sdk/"/>
+	<property name="iphoneos-sdk" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.1.sdk/"/>
 	<property name="iphonesimulator-platform" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin"/>
-	<property name="iphonesimulator-sdk" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.2.sdk"/>
+	<property name="iphonesimulator-sdk" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.1.sdk"/>
 	
 	<!-- define gcc compiler, options and files to compile -->
 	<property name="gcc" value="/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"/>	
diff --git a/extensions/gdx-box2d/gdx-box2d/jni/com.badlogic.gdx.physics.box2d.World.cpp b/extensions/gdx-box2d/gdx-box2d/jni/com.badlogic.gdx.physics.box2d.World.cpp
index 967a75f..d1674a3 100644
--- a/extensions/gdx-box2d/gdx-box2d/jni/com.badlogic.gdx.physics.box2d.World.cpp
+++ b/extensions/gdx-box2d/gdx-box2d/jni/com.badlogic.gdx.physics.box2d.World.cpp
@@ -211,7 +211,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDestroyBody(
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDestroyFixture(JNIEnv* env, jobject object, jlong addr, jlong bodyAddr, jlong fixtureAddr) {
 
 
-//@line:353
+//@line:354
 
 		b2World* world = (b2World*)(addr);
 		b2Body* body = (b2Body*)(bodyAddr);
@@ -230,7 +230,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDestroyFixtu
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDeactivateBody(JNIEnv* env, jobject object, jlong addr, jlong bodyAddr) {
 
 
-//@line:373
+//@line:374
 
 		b2World* world = (b2World*)(addr);
 		b2Body* body = (b2Body*)(bodyAddr);	
@@ -248,7 +248,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDeactivateBo
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateWheelJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat localAxisAX, jfloat localAxisAY, jboolean enableMotor, jfloat maxMotorTorque, jfloat motorSpeed, jfloat frequencyHz, jfloat dampingRatio) {
 
 
-//@line:478
+//@line:479
 
 		b2World* world = (b2World*)addr;
 		b2WheelJointDef def;
@@ -272,7 +272,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateWheel
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateRopeJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat maxLength) {
 
 
-//@line:497
+//@line:498
 
 		b2World* world = (b2World*)addr;
 		b2RopeJointDef def;
@@ -291,7 +291,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateRopeJ
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateDistanceJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat length, jfloat frequencyHz, jfloat dampingRatio) {
 
 
-//@line:511
+//@line:512
 
 		b2World* world = (b2World*)addr;
 		b2DistanceJointDef def;
@@ -312,7 +312,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateDista
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateFrictionJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat maxForce, jfloat maxTorque) {
 
 
-//@line:527
+//@line:528
 
 		b2World* world = (b2World*)addr;
 		b2FrictionJointDef def;
@@ -331,7 +331,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateFrict
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateGearJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jlong joint1, jlong joint2, jfloat ratio) {
 
 
-//@line:541
+//@line:542
 
 		b2World* world = (b2World*)addr;
 		b2GearJointDef def;
@@ -349,7 +349,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateGearJ
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateMotorJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat linearOffsetX, jfloat linearOffsetY, jfloat angularOffset, jfloat maxForce, jfloat maxTorque, jfloat correctionFactor) {
 
 
-//@line:554
+//@line:555
 
 		b2World* world = (b2World*)addr;
 		b2MotorJointDef def;
@@ -369,7 +369,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateMotor
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateMouseJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat targetX, jfloat targetY, jfloat maxForce, jfloat frequencyHz, jfloat dampingRatio) {
 
 
-//@line:569
+//@line:570
 
 		b2World* world = (b2World*)addr;
 		b2MouseJointDef def;
@@ -388,7 +388,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateMouse
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreatePrismaticJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat localAxisAX, jfloat localAxisAY, jfloat referenceAngle, jboolean enableLimit, jfloat lowerTranslation, jfloat upperTranslation, jboolean enableMotor, jfloat maxMotorForce, jfloat motorSpeed) {
 
 
-//@line:585
+//@line:586
 
 		b2World* world = (b2World*)addr;
 		b2PrismaticJointDef def;
@@ -413,7 +413,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreatePrism
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreatePulleyJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat groundAnchorAX, jfloat groundAnchorAY, jfloat groundAnchorBX, jfloat groundAnchorBY, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat lengthA, jfloat lengthB, jfloat ratio) {
 
 
-//@line:606
+//@line:607
 
 		b2World* world = (b2World*)addr;
 		b2PulleyJointDef def;
@@ -436,7 +436,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreatePulle
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateRevoluteJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat referenceAngle, jboolean enableLimit, jfloat lowerAngle, jfloat upperAngle, jboolean enableMotor, jfloat motorSpeed, jfloat maxMotorTorque) {
 
 
-//@line:625
+//@line:626
 
 		b2World* world = (b2World*)addr;
 		b2RevoluteJointDef def;
@@ -460,7 +460,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateRevol
 JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateWeldJoint(JNIEnv* env, jobject object, jlong addr, jlong bodyA, jlong bodyB, jboolean collideConnected, jfloat localAnchorAX, jfloat localAnchorAY, jfloat localAnchorBX, jfloat localAnchorBY, jfloat referenceAngle, jfloat frequencyHz, jfloat dampingRatio) {
 
 
-//@line:644
+//@line:645
 
 		b2World* world = (b2World*)addr;
 		b2WeldJointDef def;
@@ -481,7 +481,7 @@ JNIEXPORT jlong JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniCreateWeldJ
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDestroyJoint(JNIEnv* env, jobject object, jlong addr, jlong jointAddr) {
 
 
-//@line:669
+//@line:670
 
 		b2World* world = (b2World*)addr;
 		b2Joint* joint = (b2Joint*)jointAddr;
@@ -499,7 +499,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDestroyJoint
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniStep(JNIEnv* env, jobject object, jlong addr, jfloat timeStep, jint velocityIterations, jint positionIterations) {
 
 
-//@line:689
+//@line:690
 
 		b2World* world = (b2World*)addr;
 		CustomContactFilter contactFilter(env, object);
@@ -516,7 +516,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniStep(JNIEnv*
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniClearForces(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:709
+//@line:710
 
 		b2World* world = (b2World*)addr;
 		world->ClearForces();
@@ -527,7 +527,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniClearForces(
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniSetWarmStarting(JNIEnv* env, jobject object, jlong addr, jboolean flag) {
 
 
-//@line:719
+//@line:720
 
 		b2World* world = (b2World*)addr;
 		world->SetWarmStarting(flag);
@@ -538,7 +538,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniSetWarmStart
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniSetContiousPhysics(JNIEnv* env, jobject object, jlong addr, jboolean flag) {
 
 
-//@line:729
+//@line:730
 
 		b2World* world = (b2World*)addr;
 		world->SetContinuousPhysics(flag);
@@ -549,7 +549,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniSetContiousP
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetProxyCount(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:739
+//@line:740
 
 		b2World* world = (b2World*)addr;
 		return world->GetProxyCount();
@@ -560,7 +560,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetProxyCoun
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetBodyCount(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:749
+//@line:750
 
 		b2World* world = (b2World*)addr;
 		return world->GetBodyCount();
@@ -571,7 +571,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetBodyCount
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetJointcount(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:764
+//@line:765
 
 		b2World* world = (b2World*)addr;
 		return world->GetJointCount();
@@ -582,7 +582,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetJointcoun
 JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetContactCount(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:774
+//@line:775
 
 		b2World* world = (b2World*)addr;
 		return world->GetContactCount();
@@ -593,7 +593,7 @@ JNIEXPORT jint JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetContactCo
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniSetGravity(JNIEnv* env, jobject object, jlong addr, jfloat gravityX, jfloat gravityY) {
 
 
-//@line:784
+//@line:785
 
 		b2World* world = (b2World*)addr;
 		world->SetGravity( b2Vec2( gravityX, gravityY ) );
@@ -605,7 +605,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetGravity(J
 	float* gravity = (float*)env->GetPrimitiveArrayCritical(obj_gravity, 0);
 
 
-//@line:800
+//@line:801
 
 		b2World* world = (b2World*)addr;
 		b2Vec2 g = world->GetGravity();
@@ -619,7 +619,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetGravity(J
 JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniIsLocked(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:812
+//@line:813
 
 		b2World* world = (b2World*)addr;
 		return world->IsLocked();
@@ -630,7 +630,7 @@ JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniIsLocked
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniSetAutoClearForces(JNIEnv* env, jobject object, jlong addr, jboolean flag) {
 
 
-//@line:822
+//@line:823
 
 		b2World* world = (b2World*)addr;
 		world->SetAutoClearForces(flag);
@@ -641,7 +641,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniSetAutoClear
 JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetAutoClearForces(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:832
+//@line:833
 
 		b2World* world = (b2World*)addr;
 		return world->GetAutoClearForces();
@@ -652,7 +652,7 @@ JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetAutoC
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniQueryAABB(JNIEnv* env, jobject object, jlong addr, jfloat lowX, jfloat lowY, jfloat upX, jfloat upY) {
 
 
-//@line:850
+//@line:851
 
 		b2World* world = (b2World*)addr;
 		b2AABB aabb;
@@ -669,7 +669,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetContactLi
 	long long* contacts = (long long*)env->GetPrimitiveArrayCritical(obj_contacts, 0);
 
 
-//@line:935
+//@line:936
 
 		b2World* world = (b2World*)addr;
 	
@@ -688,7 +688,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniGetContactLi
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDispose(JNIEnv* env, jobject object, jlong addr) {
 
 
-//@line:951
+//@line:952
 
 		b2World* world = (b2World*)(addr);
 		delete world;
@@ -699,7 +699,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniDispose(JNIE
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_setVelocityThreshold(JNIEnv* env, jclass clazz, jfloat threshold) {
 
 
-//@line:1011
+//@line:1012
 
 		b2_velocityThreshold = threshold;
 	
@@ -709,7 +709,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_setVelocityThre
 JNIEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_box2d_World_getVelocityThreshold(JNIEnv* env, jclass clazz) {
 
 
-//@line:1016
+//@line:1017
 
 		return b2_velocityThreshold;
 	
@@ -719,7 +719,7 @@ JNIEXPORT jfloat JNICALL Java_com_badlogic_gdx_physics_box2d_World_getVelocityTh
 JNIEXPORT void JNICALL Java_com_badlogic_gdx_physics_box2d_World_jniRayCast(JNIEnv* env, jobject object, jlong addr, jfloat aX, jfloat aY, jfloat bX, jfloat bY) {
 
 
-//@line:1031
+//@line:1032
 
 		b2World *world = (b2World*)addr;
 		CustomRayCastCallback callback( env, object );	
diff --git a/extensions/gdx-box2d/gdx-box2d/jni/maven/pom.xml b/extensions/gdx-box2d/gdx-box2d/jni/maven/pom.xml
index 69765c4..523ca0a 100644
--- a/extensions/gdx-box2d/gdx-box2d/jni/maven/pom.xml
+++ b/extensions/gdx-box2d/gdx-box2d/jni/maven/pom.xml
@@ -4,7 +4,7 @@
     <parent>
         <groupId>com.badlogicgames.gdx</groupId>
         <artifactId>gdx-parent</artifactId>
-        <version>1.5.6-SNAPSHOT</version>
+        <version>1.5.5-SNAPSHOT</version>
         <relativePath>../../../../../</relativePath>
     </parent>
     
diff --git a/extensions/gdx-box2d/gdx-box2d/pom.xml b/extensions/gdx-box2d/gdx-box2d/pom.xml
index bca47ba..6d2ebb9 100644
--- a/extensions/gdx-box2d/gdx-box2d/pom.xml
+++ b/extensions/gdx-box2d/gdx-box2d/pom.xml
@@ -4,7 +4,7 @@
 	<parent>
 		<groupId>com.badlogicgames.gdx</groupId>
 		<artifactId>gdx-box2d-parent</artifactId>
-		<version>1.5.6-SNAPSHOT</version>
+		<version>1.5.5-SNAPSHOT</version>
 		<relativePath>../pom.xml</relativePath>
 	</parent>
 
diff --git a/extensions/gdx-box2d/pom.xml b/extensions/gdx-box2d/pom.xml
index 51de79b..3931559 100644
--- a/extensions/gdx-box2d/pom.xml
+++ b/extensions/gdx-box2d/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.5.6-SNAPSHOT</version>
+    <version>1.5.5-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/extensions/gdx-bullet/jni/build-ios32.xml b/extensions/gdx-bullet/jni/build-ios32.xml
index 0b39cd2..6ae41b3 100755
--- a/extensions/gdx-bullet/jni/build-ios32.xml
+++ b/extensions/gdx-bullet/jni/build-ios32.xml
@@ -12,9 +12,9 @@
 	<!-- the compilerPrefix for the C & C++ compilers -->
 	<property name="compilerPrefix" value=""/>	
 	<property name="iphoneos-platform" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin"/>
-	<property name="iphoneos-sdk" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.2.sdk/"/>
+	<property name="iphoneos-sdk" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.1.sdk/"/>
 	<property name="iphonesimulator-platform" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin"/>
-	<property name="iphonesimulator-sdk" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.2.sdk"/>
+	<property name="iphonesimulator-sdk" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.1.sdk"/>
 	
 	<!-- define gcc compiler, options and files to compile -->
 	<property name="gcc" value="/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"/>	
@@ -307,11 +307,11 @@
 
 	<target name="link-fat">
 		<exec executable="lipo" failonerror="true" dir="${libsDir}">
-			<arg line="-create -output ${libName} ${libName}.386 ${libName}.x86_64 ${libName}.armv7 ${libName}.arm64"/>
+			<arg line="-create -output ${libName} ${libName}.386 ${libName}.x86_64 ${libName}.armv7"/>
 		</exec>
 	</target>
 
-	<target name="postcompile" depends="link-386,link-x86_64,link-arm,link-arm64,link-fat">
+	<target name="postcompile" depends="link-386,link-x86_64,link-arm,link-fat">
 		
 	</target>
 </project>
diff --git a/extensions/gdx-bullet/jni/maven/pom.xml b/extensions/gdx-bullet/jni/maven/pom.xml
index 4e1b656..332ea45 100644
--- a/extensions/gdx-bullet/jni/maven/pom.xml
+++ b/extensions/gdx-bullet/jni/maven/pom.xml
@@ -4,7 +4,7 @@
     <parent>
         <groupId>com.badlogicgames.gdx</groupId>
         <artifactId>gdx-parent</artifactId>
-        <version>1.5.6-SNAPSHOT</version>
+        <version>1.5.5-SNAPSHOT</version>
         <relativePath>../../../../</relativePath>
     </parent>
     
diff --git a/extensions/gdx-bullet/jni/src/bullet/LinearMath/btVector3.cpp b/extensions/gdx-bullet/jni/src/bullet/LinearMath/btVector3.cpp
index 5b36453..9389a25 100644
--- a/extensions/gdx-bullet/jni/src/bullet/LinearMath/btVector3.cpp
+++ b/extensions/gdx-bullet/jni/src/bullet/LinearMath/btVector3.cpp
@@ -882,12 +882,10 @@ static long _mindot_large_sel( const float *vv, const float *vec, unsigned long
     return _mindot_large(vv, vec, count, dotResult);
 }
 
-#if defined __arm__
-# define vld1q_f32_aligned_postincrement( _ptr ) ({ float32x4_t _r; asm( "vld1.f32 {%0}, [%1, :128]!\n" : "=w" (_r), "+r" (_ptr) ); /*return*/ _r; })
-#else
-//support 64bit arm
-# define vld1q_f32_aligned_postincrement( _ptr) ({ float32x4_t _r = ((float32x4_t*)(_ptr))[0]; (_ptr) = (const float*) ((const char*)(_ptr) + 16L); /*return*/ _r; })
-#endif
+
+
+#define vld1q_f32_aligned_postincrement( _ptr ) ({ float32x4_t _r; asm( "vld1.f32  {%0}, [%1, :128]!\n" : "=w" (_r), "+r" (_ptr) ); /*return*/ _r; })
+
 
 long _maxdot_large_v0( const float *vv, const float *vec, unsigned long count, float *dotResult )
 {
diff --git a/extensions/gdx-bullet/pom.xml b/extensions/gdx-bullet/pom.xml
index 260cafd..1153354 100644
--- a/extensions/gdx-bullet/pom.xml
+++ b/extensions/gdx-bullet/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.5.6-SNAPSHOT</version>
+    <version>1.5.5-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/extensions/gdx-bullet/src/com/badlogic/gdx/physics/bullet/DebugDrawer.java b/extensions/gdx-bullet/src/com/badlogic/gdx/physics/bullet/DebugDrawer.java
index 3388c41..cac9361 100644
--- a/extensions/gdx-bullet/src/com/badlogic/gdx/physics/bullet/DebugDrawer.java
+++ b/extensions/gdx-bullet/src/com/badlogic/gdx/physics/bullet/DebugDrawer.java
@@ -19,12 +19,12 @@ package com.badlogic.gdx.physics.bullet;
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.Camera;
 import com.badlogic.gdx.graphics.g2d.BitmapFont;
+import com.badlogic.gdx.graphics.g2d.BitmapFont.TextBounds;
 import com.badlogic.gdx.graphics.g2d.SpriteBatch;
 import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
 import com.badlogic.gdx.graphics.glutils.ShapeRenderer.ShapeType;
 import com.badlogic.gdx.math.Vector3;
 import com.badlogic.gdx.physics.bullet.linearmath.btIDebugDraw;
-import com.badlogic.gdx.utils.Align;
 import com.badlogic.gdx.utils.Disposable;
 import com.badlogic.gdx.utils.viewport.Viewport;
 
@@ -90,7 +90,8 @@ public class DebugDrawer extends btIDebugDraw implements Disposable {
 			spriteBatch.begin();
 
 			// the text will be centered on the position
-			font.draw(spriteBatch, textString, location.x, location.y, 0, textString.length(), 0, Align.center, false);
+			TextBounds bounds = font.getBounds(textString);
+			font.draw(spriteBatch, textString, location.x - (bounds.width / 2), location.y + (bounds.height / 2));
 
 			spriteBatch.end();
 			shapeRenderer.begin(ShapeType.Line);
diff --git a/extensions/gdx-controllers/gdx-controllers-android/pom.xml b/extensions/gdx-controllers/gdx-controllers-android/pom.xml
index e87555f..7bffde2 100644
--- a/extensions/gdx-controllers/gdx-controllers-android/pom.xml
+++ b/extensions/gdx-controllers/gdx-controllers-android/pom.xml
@@ -4,7 +4,7 @@
 	<parent>
 		<groupId>com.badlogicgames.gdx</groupId>
 		<artifactId>gdx-controllers-parent</artifactId>
-		<version>1.5.6-SNAPSHOT</version>
+		<version>1.5.5-SNAPSHOT</version>
 		<relativePath>../pom.xml</relativePath>
 	</parent>
 
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/jni/maven/pom.xml b/extensions/gdx-controllers/gdx-controllers-desktop/jni/maven/pom.xml
index c0f49c9..6b1b3ce 100644
--- a/extensions/gdx-controllers/gdx-controllers-desktop/jni/maven/pom.xml
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/jni/maven/pom.xml
@@ -4,7 +4,7 @@
     <parent>
         <groupId>com.badlogicgames.gdx</groupId>
         <artifactId>gdx-controllers-parent</artifactId>
-        <version>1.5.6-SNAPSHOT</version>
+        <version>1.5.5-SNAPSHOT</version>
         <relativePath>../../../</relativePath>
     </parent>
     
diff --git a/extensions/gdx-controllers/gdx-controllers-desktop/pom.xml b/extensions/gdx-controllers/gdx-controllers-desktop/pom.xml
index 5e06ec3..d3a6d82 100644
--- a/extensions/gdx-controllers/gdx-controllers-desktop/pom.xml
+++ b/extensions/gdx-controllers/gdx-controllers-desktop/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-controllers-parent</artifactId>
-    <version>1.5.6-SNAPSHOT</version>
+    <version>1.5.5-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/extensions/gdx-controllers/gdx-controllers-gwt/pom.xml b/extensions/gdx-controllers/gdx-controllers-gwt/pom.xml
index bcb9046..6390ae9 100644
--- a/extensions/gdx-controllers/gdx-controllers-gwt/pom.xml
+++ b/extensions/gdx-controllers/gdx-controllers-gwt/pom.xml
@@ -4,7 +4,7 @@
 	<parent>
 		<groupId>com.badlogicgames.gdx</groupId>
 		<artifactId>gdx-controllers-parent</artifactId>
-		<version>1.5.6-SNAPSHOT</version>
+		<version>1.5.5-SNAPSHOT</version>
 		<relativePath>../pom.xml</relativePath>
 	</parent>
 
diff --git a/extensions/gdx-controllers/gdx-controllers/pom.xml b/extensions/gdx-controllers/gdx-controllers/pom.xml
index 259b931..68d90f1 100644
--- a/extensions/gdx-controllers/gdx-controllers/pom.xml
+++ b/extensions/gdx-controllers/gdx-controllers/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-controllers-parent</artifactId>
-    <version>1.5.6-SNAPSHOT</version>
+    <version>1.5.5-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
diff --git a/extensions/gdx-controllers/pom.xml b/extensions/gdx-controllers/pom.xml
index 70704df..c5f9e25 100644
--- a/extensions/gdx-controllers/pom.xml
+++ b/extensions/gdx-controllers/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.5.6-SNAPSHOT</version>
+    <version>1.5.5-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/extensions/gdx-freetype/.classpath b/extensions/gdx-freetype/.classpath
index d12c57e..1cab377 100644
--- a/extensions/gdx-freetype/.classpath
+++ b/extensions/gdx-freetype/.classpath
@@ -4,6 +4,5 @@
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/gdx"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/gdx-jnigen"/>
-	<classpathentry exported="true" kind="lib" path="libs/gdx-freetype-natives.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/extensions/gdx-freetype/jni/build-ios32.xml b/extensions/gdx-freetype/jni/build-ios32.xml
index 474e59f..4b72381 100755
--- a/extensions/gdx-freetype/jni/build-ios32.xml
+++ b/extensions/gdx-freetype/jni/build-ios32.xml
@@ -12,9 +12,9 @@
 	<!-- the compilerPrefix for the C & C++ compilers -->
 	<property name="compilerPrefix" value=""/>	
 	<property name="iphoneos-platform" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin"/>
-	<property name="iphoneos-sdk" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.2.sdk/"/>
+	<property name="iphoneos-sdk" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.1.sdk/"/>
 	<property name="iphonesimulator-platform" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin"/>
-	<property name="iphonesimulator-sdk" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.2.sdk"/>
+	<property name="iphonesimulator-sdk" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.1.sdk"/>
 	
 	<!-- define gcc compiler, options and files to compile -->
 	<property name="gcc" value="/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"/>	
diff --git a/extensions/gdx-freetype/jni/maven/pom.xml b/extensions/gdx-freetype/jni/maven/pom.xml
index d64e8fd..00511d6 100644
--- a/extensions/gdx-freetype/jni/maven/pom.xml
+++ b/extensions/gdx-freetype/jni/maven/pom.xml
@@ -4,7 +4,7 @@
     <parent>
         <groupId>com.badlogicgames.gdx</groupId>
         <artifactId>gdx-parent</artifactId>
-        <version>1.5.6-SNAPSHOT</version>
+        <version>1.5.5-SNAPSHOT</version>
         <relativePath>../../../../</relativePath>
     </parent>
     
diff --git a/extensions/gdx-freetype/pom.xml b/extensions/gdx-freetype/pom.xml
index 370c793..bf2f638 100644
--- a/extensions/gdx-freetype/pom.xml
+++ b/extensions/gdx-freetype/pom.xml
@@ -4,7 +4,7 @@
 	<parent>
 		<groupId>com.badlogicgames.gdx</groupId>
 		<artifactId>gdx-parent</artifactId>
-		<version>1.5.6-SNAPSHOT</version>
+		<version>1.5.5-SNAPSHOT</version>
 		<relativePath>../../pom.xml</relativePath>
 	</parent>
 
diff --git a/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeType.java b/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeType.java
index ec2c378..addebd4 100644
--- a/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeType.java
+++ b/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeType.java
@@ -73,11 +73,7 @@ public class FreeType {
 		public Face newMemoryFace(byte[] data, int dataSize, int faceIndex) {
 			ByteBuffer buffer = BufferUtils.newUnsafeByteBuffer(data.length);
 			BufferUtils.copy(data, 0, buffer, data.length);
-			return newMemoryFace(buffer, faceIndex);
-		}
-
-		public Face newMemoryFace(ByteBuffer buffer, int faceIndex) {
-			long face = newMemoryFace(address, buffer, buffer.remaining(), faceIndex);
+			long face = newMemoryFace(address, buffer, dataSize, faceIndex);
 			if(face == 0) {
 				BufferUtils.disposeUnsafeByteBuffer(buffer);
 				throw new GdxRuntimeException("Couldn't load font");
@@ -853,7 +849,7 @@ public class FreeType {
 
 	public static int toInt (int value) {
 		if (value < 0) return (int)((value - 32) >> 6);
-		return (int)((value + 32) >> 6);
+		else return (int)((value + 32) >> 6);
 	}
    
 //	public static void main (String[] args) throws Exception {
diff --git a/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGenerator.java b/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGenerator.java
index a467304..1f79525 100644
--- a/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGenerator.java
+++ b/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreeTypeFontGenerator.java
@@ -16,8 +16,6 @@
 
 package com.badlogic.gdx.graphics.g2d.freetype;
 
-import java.io.IOException;
-import java.io.InputStream;
 import java.nio.ByteBuffer;
 
 import com.badlogic.gdx.Gdx;
@@ -45,12 +43,10 @@ import com.badlogic.gdx.graphics.glutils.PixmapTextureData;
 import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.math.Rectangle;
 import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.BufferUtils;
 import com.badlogic.gdx.utils.Disposable;
 import com.badlogic.gdx.utils.GdxRuntimeException;
-import com.badlogic.gdx.utils.StreamUtils;
 
-/** Generates {@link BitmapFont} and {@link BitmapFontData} instances from TrueType, OTF, and other FreeType supported fonts.</p>
+/** Generates {@link BitmapFont} and {@link BitmapFontData} instances from TrueType font files.</p>
  * 
  * Usage example:
  * 
@@ -63,59 +59,56 @@ import com.badlogic.gdx.utils.StreamUtils;
  * The generator has to be disposed once it is no longer used. The returned {@link BitmapFont} instances are managed by the user
  * and have to be disposed as usual.
  * 
- * @author mzechner
- * @author Nathan Sweet */
+ * @author mzechner */
 public class FreeTypeFontGenerator implements Disposable {
-	static public final String DEFAULT_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890\"!`?'.,;:()[]{}<>|/@\\^$-%+=#_&~*\u0080\u0081\u0082\u0083\u0084\u0085\u0086\u0087\u0088\u0089\u008A\u008B\u008C\u008D\u008E\u008F\u0090\u0091\u0092\u0093\u0094\u0095\u0096\u0097\u0098\u0099\u009A\u009B\u009C\u009D\u009E\u009F\u00A0\u00A1\u00A2\u00A3\u00A4\u00A5\u00A6\u00A7\u00A8\u00A9\u00AA\u00AB\u00AC\u00AD\u00AE\u00AF\u00B0\u00B1\u00B2\u00B3\u00B4\u00B5\u00B6\u00B7\u00B8\u00B9\u00BA\u00BB\u00BC\u00BD\u00BE\u00BF\u00C0\u00C1\u00C2\u00C3\u00C4\u00C5\u00C6\u00C7\u00C8\u00C9\u00CA\u00CB\u00CC\u00CD\u00CE\u00CF\u00D0\u00D1\u00D2\u00D3\u00D4\u00D5\u00D6\u00D7\u00D8\u00D9\u00DA\u00DB\u00DC\u00DD\u00DE\u00DF\u00E0\u00E1\u00E2\u00E3\u00E4\u00E5\u00E6\u00E7\u00E8\u00E9\u00EA\u00EB\u00EC\u00ED\u00EE\u00EF\u00F0\u00F1\u00F2\u00F3\u00F4\u00F5\u00F6\u00F7\u00F8\u00F9\u00FA\u00FB\u00FC\u00FD\u00FE\u00FF";
+	public static final String DEFAULT_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890\"!`?'.,;:()[]{}<>|/@\\^$-%+=#_&~*\u0080\u0081\u0082\u0083\u0084\u0085\u0086\u0087\u0088\u0089\u008A\u008B\u008C\u008D\u008E\u008F\u0090\u0091\u0092\u0093\u0094\u0095\u0096\u0097\u0098\u0099\u009A\u009B\u009C\u009D\u009E\u009F\u00A0\u00A1\u00A2\u00A3\u00A4\u00A5\u00A6\u00A7\u00A8\u00A9\u00AA\u00AB\u00AC\u00AD\u00AE\u00AF\u00B0\u00B1\u00B2\u00B3\u00B4\u00B5\u00B6\u00B7\u00B8\u00B9\u00BA\u00BB\u00BC\u00BD\u00BE\u00BF\u00C0\u00C1\u00C2\u00C3\u00C4\u00C5\u00C6\u00C7\u00C8\u00C9\u00CA\u00CB\u00CC\u00CD\u00CE\u00CF\u00D0\u00D1\u00D2\u00D3\u00D4\u00D5\u00D6\u00D7\u00D8\u00D9\u00DA\u00DB\u00DC\u00DD\u00DE\u00DF\u00E0\u00E1\u00E2\u00E3\u00E4\u00E5\u00E6\u00E7\u00E8\u00E9\u00EA\u00EB\u00EC\u00ED\u00EE\u00EF\u00F0\u00F1\u00F2\u00F3\u00F4\u00F5\u00F6\u00F7\u00F8\u00F9\u00FA\u00FB\u00FC\u00FD\u00FE\u00FF";
+	final Library library;
+	final Face face;
+	final String filePath;
+	boolean bitmapped = false;
+
+	/** The maximum texture size allowed by generateData, when storing in a texture atlas. Multiple texture pages will be created if
+	 * necessary. */
+	private static int maxTextureSize = 1024;
 
 	/** A hint to scale the texture as needed, without capping it at any maximum size */
-	static public final int NO_MAXIMUM = -1;
+	public static final int NO_MAXIMUM = -1;
 
-	/** The maximum texture size allowed by generateData, when storing in a texture atlas. Multiple texture pages will be created if
-	 * necessary. Default is 1024.
-	 * @see #setMaxTextureSize(int) */
-	static private int maxTextureSize = 1024;
+	/** Sets the maximum size that will be used when generating texture atlases for glyphs with <tt>generateData()</tt>. The default
+	 * is 1024. By specifying NO_MAXIMUM, the texture atlas will scale as needed.
+	 * 
+	 * The power-of-two square texture size will be capped to the given <tt>texSize</tt>. It's recommended that a power-of-two
+	 * value be used here.
+	 * 
+	 * Multiple pages may be used to fit all the generated glyphs. You can query the resulting number of pages by calling
+	 * <tt>bitmapFont.getRegions().length</tt> or <tt>freeTypeBitmapFontData.getTextureRegions().length</tt>.
+	 * 
+	 * If PixmapPacker is specified when calling generateData, this parameter is ignored.
+	 * 
+	 * @param texSize the maximum texture size for one page of glyphs */
+	public static void setMaxTextureSize (int texSize) {
+		maxTextureSize = texSize;
+	}
 
-	final Library library;
-	final Face face;
-	final String name;
-	boolean bitmapped = false;
-	private int pixelWidth, pixelHeight;
+	/** Returns the maximum texture size that will be used by generateData() when creating a texture atlas for the glyphs.
+	 * @return the power-of-two max texture size */
+	public static int getMaxTextureSize () {
+		return maxTextureSize;
+	}
 
-	/** Creates a new generator from the given font file. Uses {@link FileHandle#length()} to determine the file size. If the file
-	 * length could not be determined (it was 0), an extra copy of the font bytes is performed. Throws a
-	 * {@link GdxRuntimeException} if loading did not succeed. */
+	/** Creates a new generator from the given TrueType font file. Throws a {@link GdxRuntimeException} in case loading did not
+	 * succeed.
+	 * @param font the {@link FileHandle} to the TrueType font file */
 	public FreeTypeFontGenerator (FileHandle font) {
-		name = font.pathWithoutExtension();
-		int fileSize = (int)font.length();
-
+		filePath = font.pathWithoutExtension();
 		library = FreeType.initFreeType();
 		if (library == null) throw new GdxRuntimeException("Couldn't initialize FreeType");
-
-		ByteBuffer buffer;
-		InputStream input = font.read();
-		try {
-			if (fileSize == 0) {
-				// Copy to a byte[] to get the file size, then copy to the buffer.
-				byte[] data = StreamUtils.copyStreamToByteArray(input, fileSize > 0 ? (int)(fileSize * 1.5f) : 1024 * 16);
-				buffer = BufferUtils.newUnsafeByteBuffer(data.length);
-				BufferUtils.copy(data, 0, buffer, data.length);
-			} else {
-				// Trust the specified file size.
-				buffer = BufferUtils.newUnsafeByteBuffer(fileSize);
-				StreamUtils.copyStream(input, buffer);
-			}
-		} catch (IOException ex) {
-			throw new GdxRuntimeException(ex);
-		} finally {
-			StreamUtils.closeQuietly(input);
+		face = library.newFace(font, 0);
+		if (face == null) throw new GdxRuntimeException("Couldn't create face for font '" + font + "'");
+		if (checkForBitmapFont()) {
+			return;
 		}
-
-		face = library.newMemoryFace(buffer, 0);
-		if (face == null) throw new GdxRuntimeException("Couldn't create face for font: " + font);
-
-		if (checkForBitmapFont()) return;
-		setPixelSizes(0, 15);
+		if (!face.setPixelSizes(0, 15)) throw new GdxRuntimeException("Couldn't set size for font '" + font + "'");
 	}
 
 	private boolean checkForBitmapFont () {
@@ -132,21 +125,21 @@ public class FreeTypeFontGenerator implements Disposable {
 	}
 
 	/** Generates a new {@link BitmapFont}, containing glyphs for the given characters. The size is expressed in pixels. Throws a
-	 * GdxRuntimeException if the font could not be generated. Using big sizes might cause such an exception. All characters need
-	 * to fit onto a single texture.
+	 * GdxRuntimeException in case the font could not be generated. Using big sizes might cause such an exception. All characters
+	 * need to fit onto a single texture.
 	 * @param size the size in pixels
 	 * @param characters the characters the font should contain
 	 * @param flip whether to flip the font vertically, see {@link BitmapFont#BitmapFont(FileHandle, TextureRegion, boolean)}
 	 * @deprecated use {@link #generateFont(FreeTypeFontParameter)} instead */
 	public BitmapFont generateFont (int size, String characters, boolean flip) {
 		FreeTypeBitmapFontData data = generateData(size, characters, flip, null);
-		BitmapFont font = new BitmapFont(data, data.regions, false);
+		BitmapFont font = new BitmapFont(data, data.getTextureRegions(), false);
 		font.setOwnsTexture(true);
 		return font;
 	}
 
-	/** Generates a new {@link BitmapFont}. The size is expressed in pixels. Throws a GdxRuntimeException if the font could not be
-	 * generated. Using big sizes might cause such an exception. All characters need to fit onto a single texture.
+	/** Generates a new {@link BitmapFont}. The size is expressed in pixels. Throws a GdxRuntimeException in case the font could not
+	 * be generated. Using big sizes might cause such an exception. All characters need to fit onto a single texture.
 	 * 
 	 * @param size the size of the font in pixels
 	 * @deprecated use {@link #generateFont(FreeTypeFontParameter)} instead */
@@ -154,17 +147,13 @@ public class FreeTypeFontGenerator implements Disposable {
 		return generateFont(size, DEFAULT_CHARS, false);
 	}
 
-	public BitmapFont generateFont (FreeTypeFontParameter parameter) {
-		return generateFont(parameter, new FreeTypeBitmapFontData());
-	}
-
-	/** Generates a new {@link BitmapFont}. The size is expressed in pixels. Throws a GdxRuntimeException if the font could not be
-	 * generated. Using big sizes might cause such an exception. All characters need to fit onto a single texture.
+	/** Generates a new {@link BitmapFont}. The size is expressed in pixels. Throws a GdxRuntimeException in case the font could not
+	 * be generated. Using big sizes might cause such an exception. All characters need to fit onto a single texture.
 	 * 
 	 * @param parameter configures how the font is generated */
-	public BitmapFont generateFont (FreeTypeFontParameter parameter, FreeTypeBitmapFontData data) {
-		generateData(parameter, data);
-		BitmapFont font = new BitmapFont(data, data.regions, false);
+	public BitmapFont generateFont (FreeTypeFontParameter parameter) {
+		FreeTypeBitmapFontData data = generateData(parameter);
+		BitmapFont font = new BitmapFont(data, data.getTextureRegions(), false);
 		font.setOwnsTexture(true);
 		return font;
 	}
@@ -172,34 +161,32 @@ public class FreeTypeFontGenerator implements Disposable {
 	/** Uses ascender and descender of font to calculate real height that makes all glyphs to fit in given pixel size. Source:
 	 * http://nothings.org/stb/stb_truetype.h / stbtt_ScaleForPixelHeight */
 	public int scaleForPixelHeight (int height) {
-		setPixelSizes(0, height);
+		if (!bitmapped && !face.setPixelSizes(0, height)) throw new GdxRuntimeException("Couldn't set size for font");
 		SizeMetrics fontMetrics = face.getSize().getMetrics();
 		int ascent = FreeType.toInt(fontMetrics.getAscender());
 		int descent = FreeType.toInt(fontMetrics.getDescender());
 		return height * height / (ascent - descent);
 	}
-
-	/** Uses max advance, ascender and descender of font to calculate real height that makes any n glyphs to fit in given pixel
-	 * width.
+	
+	/** Uses max advance, ascender and descender of font to calculate real height that makes any n glyphs to fit in given pixel width. 
 	 * @param width the max width to fit (in pixels)
 	 * @param numChars max number of characters that to fill width */
-	public int scaleForPixelWidth (int width, int numChars) {
+	public int scaleForPixelWidth(int width, int numChars) {
 		SizeMetrics fontMetrics = face.getSize().getMetrics();
 		int advance = FreeType.toInt(fontMetrics.getMaxAdvance());
 		int ascent = FreeType.toInt(fontMetrics.getAscender());
 		int descent = FreeType.toInt(fontMetrics.getDescender());
 		int unscaledHeight = ascent - descent;
 		int height = unscaledHeight * width / (advance * numChars);
-		setPixelSizes(0, height);
+		if (!bitmapped && !face.setPixelSizes(0, height)) throw new GdxRuntimeException("Couldn't set size for font");
 		return height;
 	}
-
-	/** Uses max advance, ascender and descender of font to calculate real height that makes any n glyphs to fit in given pixel
-	 * width and height.
+	
+	/** Uses max advance, ascender and descender of font to calculate real height that makes any n glyphs to fit in given pixel width and height. 
 	 * @param width the max width to fit (in pixels)
 	 * @param height the max height to fit (in pixels)
 	 * @param numChars max number of characters that to fill width */
-	public int scaleToFitSquare (int width, int height, int numChars) {
+	public int scaleToFitSquare(int width, int height, int numChars) {
 		return Math.min(scaleForPixelHeight(height), scaleForPixelWidth(width, numChars));
 	}
 
@@ -211,7 +198,7 @@ public class FreeTypeFontGenerator implements Disposable {
 	/** Returns null if glyph was not found. If there is nothing to render, for example with various space characters, then bitmap
 	 * is null. */
 	public GlyphAndBitmap generateGlyphAndBitmap (int c, int size, boolean flip) {
-		setPixelSizes(0, size);
+		if (!bitmapped && !face.setPixelSizes(0, size)) throw new GdxRuntimeException("Couldn't set size for font");
 
 		SizeMetrics fontMetrics = face.getSize().getMetrics();
 		int baseline = FreeType.toInt(fontMetrics.getAscender());
@@ -262,13 +249,15 @@ public class FreeTypeFontGenerator implements Disposable {
 		return result;
 	}
 
-	/** Generates a new {@link BitmapFontData} instance, expert usage only. Throws a GdxRuntimeException if something went wrong.
+	/** Generates a new {@link BitmapFontData} instance, expert usage only. Throws a GdxRuntimeException in case something went
+	 * wrong.
 	 * @param size the size in pixels */
 	public FreeTypeBitmapFontData generateData (int size) {
 		return generateData(size, DEFAULT_CHARS, false, null);
 	}
 
-	/** Generates a new {@link BitmapFontData} instance, expert usage only. Throws a GdxRuntimeException if something went wrong.
+	/** Generates a new {@link BitmapFontData} instance, expert usage only. Throws a GdxRuntimeException in case something went
+	 * wrong.
 	 * 
 	 * @param size the size in pixels
 	 * @param characters the characters the font should contain
@@ -278,7 +267,8 @@ public class FreeTypeFontGenerator implements Disposable {
 		return generateData(size, characters, flip, null);
 	}
 
-	/** Generates a new {@link BitmapFontData} instance, expert usage only. Throws a GdxRuntimeException if something went wrong.
+	/** Generates a new {@link BitmapFontData} instance, expert usage only. Throws a GdxRuntimeException in case something went
+	 * wrong.
 	 * 
 	 * @param size the size in pixels
 	 * @param characters the characters the font should contain
@@ -294,26 +284,16 @@ public class FreeTypeFontGenerator implements Disposable {
 		return generateData(parameter);
 	}
 
-	public FreeTypeBitmapFontData generateData (FreeTypeFontParameter parameter) {
-		return generateData(parameter, new FreeTypeBitmapFontData());
-	}
-
-	void setPixelSizes (int pixelWidth, int pixelHeight) {
-		this.pixelWidth = pixelWidth;
-		this.pixelHeight = pixelHeight;
-		if (!bitmapped && !face.setPixelSizes(pixelWidth, pixelHeight))
-			throw new GdxRuntimeException("Couldn't set size for font");
-	}
-
-	/** Generates a new {@link BitmapFontData} instance, expert usage only. Throws a GdxRuntimeException if something went wrong.
+	/** Generates a new {@link BitmapFontData} instance, expert usage only. Throws a GdxRuntimeException in case something went
+	 * wrong.
+	 * 
 	 * @param parameter configures how the font is generated */
-	public FreeTypeBitmapFontData generateData (FreeTypeFontParameter parameter, FreeTypeBitmapFontData data) {
+	public FreeTypeBitmapFontData generateData (FreeTypeFontParameter parameter) {
 		parameter = parameter == null ? new FreeTypeFontParameter() : parameter;
-		String characters = parameter.characters;
-		int charactersLength = characters.length();
-		boolean incremental = parameter.incremental;
 
-		setPixelSizes(0, parameter.size);
+		FreeTypeBitmapFontData data = new FreeTypeBitmapFontData();
+		if (!bitmapped && !face.setPixelSizes(0, parameter.size))
+			throw new GdxRuntimeException("Couldn't set size for font");
 
 		// set general font data
 		SizeMetrics fontMetrics = face.getSize().getMetrics();
@@ -345,13 +325,13 @@ public class FreeTypeFontGenerator implements Disposable {
 		data.setGlyph(' ', spaceGlyph);
 
 		// determine x-height
-		for (char xChar : data.xChars) {
+		for (char xChar : BitmapFont.xChars) {
 			if (!face.loadChar(xChar, FreeType.FT_LOAD_DEFAULT)) continue;
 			data.xHeight = FreeType.toInt(face.getGlyph().getMetrics().getHeight());
 			break;
 		}
 		if (data.xHeight == 0) throw new GdxRuntimeException("No x-height character found in font");
-		for (char capChar : data.capChars) {
+		for (char capChar : BitmapFont.capChars) {
 			if (!face.loadChar(capChar, FreeType.FT_LOAD_DEFAULT)) continue;
 			data.capHeight = FreeType.toInt(face.getGlyph().getMetrics().getHeight());
 			break;
@@ -371,215 +351,169 @@ public class FreeTypeFontGenerator implements Disposable {
 		PixmapPacker packer = parameter.packer;
 
 		if (packer == null) {
-			// Create a packer.
-			int size;
-			if (incremental)
-				size = maxTextureSize;
-			else {
-				int maxGlyphHeight = (int)Math.ceil(data.lineHeight);
-				size = MathUtils.nextPowerOfTwo((int)Math.sqrt(maxGlyphHeight * maxGlyphHeight * charactersLength));
-				if (maxTextureSize > 0) size = Math.min(size, maxTextureSize);
-			}
+			// generate the glyphs
+			int maxGlyphHeight = (int)Math.ceil(data.lineHeight);
+			int pageWidth = MathUtils
+				.nextPowerOfTwo((int)Math.sqrt(maxGlyphHeight * maxGlyphHeight * parameter.characters.length()));
+
+			if (maxTextureSize > 0) pageWidth = Math.min(pageWidth, maxTextureSize);
+
 			ownsAtlas = true;
-			packer = new PixmapPacker(size, size, Format.RGBA8888, 2, false);
+			packer = new PixmapPacker(pageWidth, pageWidth, Format.RGBA8888, 2, false);
 		}
 
 		// to minimize collisions we'll use this format : pathWithoutExtension_size[_flip]_glyph
-		String packPrefix = ownsAtlas ? "" : (name + '_' + parameter.size + (parameter.flip ? "_flip_" : '_'));
+		String packPrefix = ownsAtlas ? "" : (filePath + '_' + parameter.size + (parameter.flip ? "_flip_" : '_'));
 
 		Stroker stroker = null;
 		if (parameter.borderWidth > 0) {
 			stroker = library.createStroker();
-			stroker.set((int)(parameter.borderWidth * 64f), parameter.borderStraight ? FreeType.FT_STROKER_LINECAP_BUTT
-				: FreeType.FT_STROKER_LINECAP_ROUND, parameter.borderStraight ? FreeType.FT_STROKER_LINEJOIN_MITER_FIXED
-				: FreeType.FT_STROKER_LINEJOIN_ROUND, 0);
-		}
-
-		if (incremental) {
-			data.generator = this;
-			data.parameter = parameter;
-			data.stroker = stroker;
-			data.packPrefix = packPrefix;
-			data.packer = packer;
-			data.glyphs = new Array(charactersLength + 32);
+			stroker.set((int)(parameter.borderWidth * 64f),
+					parameter.borderStraight ? FreeType.FT_STROKER_LINECAP_BUTT : FreeType.FT_STROKER_LINECAP_ROUND,
+					parameter.borderStraight ? FreeType.FT_STROKER_LINEJOIN_MITER_FIXED : FreeType.FT_STROKER_LINEJOIN_ROUND, 0);
 		}
 
-		for (int i = 0; i < charactersLength; i++) {
-			char c = characters.charAt(i);
-			Glyph glyph = createGlyph(c, data, parameter, stroker, baseLine, packPrefix, packer);
-			if (glyph != null) {
-				data.setGlyph(c, glyph);
-				if (incremental) data.glyphs.add(glyph);
+		for (int i = 0; i < parameter.characters.length(); i++) {
+			char c = parameter.characters.charAt(i);
+			if (!face.loadChar(c, FreeType.FT_LOAD_DEFAULT)) {
+				Gdx.app.log("FreeTypeFontGenerator", "Couldn't load char '" + c + "'");
+				continue;
 			}
-		}
-
-		if (stroker != null && !incremental) stroker.dispose();
-
-		// Generate kerning.
-		if (parameter.kerning) {
-			for (int i = 0; i < charactersLength; i++) {
-				char firstChar = characters.charAt(i);
-				Glyph first = data.getGlyph(firstChar);
-				if (first == null) continue;
-				int firstIndex = face.getCharIndex(firstChar);
-				for (int j = i; j < charactersLength; j++) {
-					char secondChar = characters.charAt(j);
-					Glyph second = data.getGlyph(secondChar);
-					if (second == null) continue;
-					int secondIndex = face.getCharIndex(secondChar);
-
-					int kerning = face.getKerning(firstIndex, secondIndex, 0);
-					if (kerning != 0) first.setKerning(secondChar, FreeType.toInt(kerning));
-
-					kerning = face.getKerning(secondIndex, firstIndex, 0);
-					if (kerning != 0) second.setKerning(firstChar, FreeType.toInt(kerning));
+			GlyphSlot slot = face.getGlyph();
+			com.badlogic.gdx.graphics.g2d.freetype.FreeType.Glyph mainGlyph = slot.getGlyph();
+			try {
+				mainGlyph.toBitmap(FreeType.FT_RENDER_MODE_NORMAL);
+			} catch (GdxRuntimeException e) {
+				mainGlyph.dispose();
+				Gdx.app.log("FreeTypeFontGenerator", "Couldn't render char '" + c + "'");
+				continue;
+			}
+			Bitmap mainBitmap = mainGlyph.getBitmap();
+			Pixmap mainPixmap = mainBitmap.getPixmap(Format.RGBA8888, parameter.color);
+
+			if (parameter.borderWidth > 0 || parameter.shadowOffsetX != 0 || parameter.shadowOffsetY != 0) {
+				com.badlogic.gdx.graphics.g2d.freetype.FreeType.Glyph borderGlyph = mainGlyph;
+				Bitmap borderBitmap = mainBitmap;
+
+				if (parameter.borderWidth > 0) {
+					//execute stroker; this generates a glyph "extended" along the outline
+					borderGlyph = slot.getGlyph();
+					borderGlyph.strokeBorder(stroker, false);
+					borderGlyph.toBitmap(FreeType.FT_RENDER_MODE_NORMAL);
+					borderBitmap = borderGlyph.getBitmap();
+
+					//render border (pixmap is bigger than main)
+					Pixmap borderPixmap = borderBitmap.getPixmap(Format.RGBA8888, parameter.borderColor);
+					//draw main glyph on top of border
+					borderPixmap.drawPixmap(mainPixmap, mainGlyph.getLeft() - borderGlyph.getLeft(),
+						-(mainGlyph.getTop() - borderGlyph.getTop()));
+					mainPixmap.dispose();
+					mainGlyph.dispose();
+					mainPixmap = borderPixmap;
+					mainGlyph = borderGlyph;
+				}
+				if (parameter.shadowOffsetX != 0 || parameter.shadowOffsetY != 0) {
+					//render the shadow
+					Pixmap shadowPixmapSrc = borderBitmap.getPixmap(Format.RGBA8888, parameter.shadowColor);
+					//create a new bigger Pixmap with shadowOffset applied, and draw shadow glyph
+					Pixmap shadowPixmap = new Pixmap(shadowPixmapSrc.getWidth() + Math.abs(parameter.shadowOffsetX),
+						shadowPixmapSrc.getHeight() + Math.abs(parameter.shadowOffsetY), Format.RGBA8888);
+					Blending blending = Pixmap.getBlending();
+					Pixmap.setBlending(Blending.None);
+					shadowPixmap.drawPixmap(shadowPixmapSrc, Math.max(parameter.shadowOffsetX, 0), Math.max(parameter.shadowOffsetY, 0));
+					Pixmap.setBlending(blending);
+					//draw main glyph (with border) on top of shadow
+					shadowPixmap.drawPixmap(mainPixmap, Math.max(-parameter.shadowOffsetX, 0), Math.max(-parameter.shadowOffsetY, 0));
+					mainPixmap.dispose();
+					mainPixmap = shadowPixmap;
 				}
 			}
-		}
-
-		// Generate texture regions.
-		if (ownsAtlas) {
-			Array<Page> pages = packer.getPages();
-			data.regions = new Array(pages.size);
-			for (int i = 0; i < pages.size; i++)
-				data.regions.add(createRegion(pages.get(i), parameter));
-		}
 
-		return data;
-	}
+			GlyphMetrics metrics = slot.getMetrics();
+			Glyph glyph = new Glyph();
+			glyph.id = c;
+			glyph.width = mainPixmap.getWidth();
+			glyph.height = mainPixmap.getHeight();
+			glyph.xoffset = mainGlyph.getLeft();
+			glyph.yoffset = parameter.flip ? -mainGlyph.getTop() + (int)baseLine : -(glyph.height - mainGlyph.getTop())
+				- (int)baseLine;
+			glyph.xadvance = FreeType.toInt(metrics.getHoriAdvance()) + (int)parameter.borderWidth;
+
+			if (bitmapped) {
+				mainPixmap.setColor(Color.CLEAR);
+				mainPixmap.fill();
+				ByteBuffer buf = mainBitmap.getBuffer();
+				int whiteIntBits = Color.WHITE.toIntBits();
+				int clearIntBits = Color.CLEAR.toIntBits();
+				for (int h = 0; h < glyph.height; h++) {
+					int idx = h * mainBitmap.getPitch();
+					for (int w = 0; w < (glyph.width + glyph.xoffset); w++) {
+						int bit = (buf.get(idx + (w / 8)) >>> (7 - (w % 8))) & 1;
+						mainPixmap.drawPixel(w, h, ((bit == 1) ? whiteIntBits : clearIntBits));
+					}
+				}
 
-	private TextureRegion createRegion (Page p, FreeTypeFontParameter parameter) {
-		Texture tex = new Texture(
-			new PixmapTextureData(p.getPixmap(), p.getPixmap().getFormat(), parameter.genMipMaps, false, true)) {
-			@Override
-			public void dispose () {
-				super.dispose();
-				getTextureData().consumePixmap().dispose();
 			}
-		};
-		tex.setFilter(parameter.minFilter, parameter.magFilter);
-		return new TextureRegion(tex);
-	}
 
-	Glyph createGlyph (char c, FreeTypeBitmapFontData data, FreeTypeFontParameter parameter, Stroker stroker, float baseLine,
-		String packPrefix, PixmapPacker packer) {
+			String name = packPrefix + c;
+			Rectangle rect = packer.pack(name, mainPixmap);
 
-		boolean missing = face.getCharIndex(c) == 0;
-		if (missing) {
-			Glyph glyph = data.getGlyph((char)0);
-			if (glyph != null) return glyph;
-		}
+			// determine which page it was packed into
+			int pIndex = packer.getPageIndex(name);
+			if (pIndex == -1) // we should not get here
+				throw new IllegalStateException("packer was not able to insert '" + name + "' into a page");
 
-		if (!face.loadChar(c, FreeType.FT_LOAD_DEFAULT)) {
-			Gdx.app.log("FreeTypeFontGenerator", "Couldn't load char '" + c + "'");
-			return null;
-		}
-		GlyphSlot slot = face.getGlyph();
-		FreeType.Glyph mainGlyph = slot.getGlyph();
-		try {
-			mainGlyph.toBitmap(FreeType.FT_RENDER_MODE_NORMAL);
-		} catch (GdxRuntimeException e) {
+			glyph.page = pIndex;
+			glyph.srcX = (int)rect.x;
+			glyph.srcY = (int)rect.y;
+
+			data.setGlyph(c, glyph);
+			mainPixmap.dispose();
 			mainGlyph.dispose();
-			Gdx.app.log("FreeTypeFontGenerator", "Couldn't render char '" + c + "'");
-			return null;
-		}
-		Bitmap mainBitmap = mainGlyph.getBitmap();
-		Pixmap mainPixmap = mainBitmap.getPixmap(Format.RGBA8888, parameter.color);
-
-		if (parameter.borderWidth > 0 || parameter.shadowOffsetX != 0 || parameter.shadowOffsetY != 0) {
-			FreeType.Glyph borderGlyph = mainGlyph;
-			Bitmap borderBitmap = mainBitmap;
-
-			if (parameter.borderWidth > 0) {
-				// execute stroker; this generates a glyph "extended" along the outline
-				borderGlyph = slot.getGlyph();
-				borderGlyph.strokeBorder(stroker, false);
-				borderGlyph.toBitmap(FreeType.FT_RENDER_MODE_NORMAL);
-				borderBitmap = borderGlyph.getBitmap();
-
-				// render border (pixmap is bigger than main)
-				Pixmap borderPixmap = borderBitmap.getPixmap(Format.RGBA8888, parameter.borderColor);
-				// draw main glyph on top of border
-				borderPixmap.drawPixmap(mainPixmap, mainGlyph.getLeft() - borderGlyph.getLeft(),
-					-(mainGlyph.getTop() - borderGlyph.getTop()));
-				mainPixmap.dispose();
-				mainGlyph.dispose();
-				mainPixmap = borderPixmap;
-				mainGlyph = borderGlyph;
-			}
-			if (parameter.shadowOffsetX != 0 || parameter.shadowOffsetY != 0) {
-				// render the shadow
-				Pixmap shadowPixmapSrc = borderBitmap.getPixmap(Format.RGBA8888, parameter.shadowColor);
-				// create a new bigger Pixmap with shadowOffset applied, and draw shadow glyph
-				Pixmap shadowPixmap = new Pixmap(shadowPixmapSrc.getWidth() + Math.abs(parameter.shadowOffsetX),
-					shadowPixmapSrc.getHeight() + Math.abs(parameter.shadowOffsetY), Format.RGBA8888);
-				Blending blending = Pixmap.getBlending();
-				Pixmap.setBlending(Blending.None);
-				shadowPixmap.drawPixmap(shadowPixmapSrc, Math.max(parameter.shadowOffsetX, 0), Math.max(parameter.shadowOffsetY, 0));
-				Pixmap.setBlending(blending);
-				// draw main glyph (with border) on top of shadow
-				shadowPixmap.drawPixmap(mainPixmap, Math.max(-parameter.shadowOffsetX, 0), Math.max(-parameter.shadowOffsetY, 0));
-				mainPixmap.dispose();
-				mainPixmap = shadowPixmap;
-			}
 		}
 
-		GlyphMetrics metrics = slot.getMetrics();
-		Glyph glyph = new Glyph();
-		glyph.id = c;
-		glyph.width = mainPixmap.getWidth();
-		glyph.height = mainPixmap.getHeight();
-		glyph.xoffset = mainGlyph.getLeft();
-		glyph.yoffset = parameter.flip ? -mainGlyph.getTop() + (int)baseLine : -(glyph.height - mainGlyph.getTop()) - (int)baseLine;
-		glyph.xadvance = FreeType.toInt(metrics.getHoriAdvance()) + (int)parameter.borderWidth;
-
-		if (bitmapped) {
-			mainPixmap.setColor(Color.CLEAR);
-			mainPixmap.fill();
-			ByteBuffer buf = mainBitmap.getBuffer();
-			int whiteIntBits = Color.WHITE.toIntBits();
-			int clearIntBits = Color.CLEAR.toIntBits();
-			for (int h = 0; h < glyph.height; h++) {
-				int idx = h * mainBitmap.getPitch();
-				for (int w = 0; w < (glyph.width + glyph.xoffset); w++) {
-					int bit = (buf.get(idx + (w / 8)) >>> (7 - (w % 8))) & 1;
-					mainPixmap.drawPixel(w, h, ((bit == 1) ? whiteIntBits : clearIntBits));
-				}
-			}
-
+		if (stroker != null) {
+			stroker.dispose();
 		}
 
-		String name = packPrefix + c;
-		Rectangle rect = packer.pack(name, mainPixmap);
-
-		// determine which page it was packed into
-		int pageIndex = packer.getPageIndex(name);
-		if (pageIndex == -1) // we should not get here
-			throw new IllegalStateException("Packer was not able to insert glyph into a page: " + name);
-
-		glyph.page = pageIndex;
-		glyph.srcX = (int)rect.x;
-		glyph.srcY = (int)rect.y;
-
-		// If the data already has regions then this glyph is being added incrementally.
-		// Create a new texture for the new glyph or update the existing texture with the new glyph.
-		if (data.regions != null) {
-			if (pageIndex >= data.regions.size)
-				data.regions.add(createRegion(packer.getPages().get(pageIndex), parameter));
-			else {
-				Texture texture = data.regions.get(pageIndex).getTexture();
-				texture.bind();
-				Gdx.gl.glTexSubImage2D(texture.glTarget, 0, glyph.srcX, glyph.srcY, glyph.width, glyph.height,
-					mainPixmap.getGLFormat(), mainPixmap.getGLType(), mainPixmap.getPixels());
+		// generate kerning
+		if (parameter.kerning) {
+			for (int i = 0; i < parameter.characters.length(); i++) {
+				for (int j = 0; j < parameter.characters.length(); j++) {
+					char firstChar = parameter.characters.charAt(i);
+					Glyph first = data.getGlyph(firstChar);
+					if (first == null) continue;
+					char secondChar = parameter.characters.charAt(j);
+					Glyph second = data.getGlyph(secondChar);
+					if (second == null) continue;
+					int kerning = face.getKerning(face.getCharIndex(firstChar),
+						face.getCharIndex(secondChar), 0);
+					if (kerning == 0) continue;
+					first.setKerning(secondChar, FreeType.toInt(kerning));
+				}
 			}
 		}
+		if (ownsAtlas) {
+			Array<Page> pages = packer.getPages();
+			data.regions = new TextureRegion[pages.size];
 
-		mainPixmap.dispose();
-		mainGlyph.dispose();
+			for (int i = 0; i < pages.size; i++) {
+				Page p = pages.get(i);
 
-		if (missing) data.setGlyph(0, glyph);
+				Texture tex = new Texture(new PixmapTextureData(p.getPixmap(), p.getPixmap().getFormat(), parameter.genMipMaps,
+					false, true)) {
+					@Override
+					public void dispose () {
+						super.dispose();
+						getTextureData().consumePixmap().dispose();
+					}
+				};
+				tex.setFilter(parameter.minFilter, parameter.magFilter);
 
-		return glyph;
+				data.regions[i] = new TextureRegion(tex);
+			}
+		}
+		return data;
 	}
 
 	/** Cleans up all resources of the generator. Call this if you no longer use the generator. */
@@ -589,77 +523,22 @@ public class FreeTypeFontGenerator implements Disposable {
 		library.dispose();
 	}
 
-	/** Sets the maximum size that will be used when generating texture atlases for glyphs with <tt>generateData()</tt>. The default
-	 * is 1024. By specifying {@link #NO_MAXIMUM}, the texture atlas will scale as needed.
-	 * 
-	 * The power-of-two square texture size will be capped to the given <tt>texSize</tt>. It's recommended that a power-of-two
-	 * value be used here.
-	 * 
-	 * Multiple pages may be used to fit all the generated glyphs. You can query the resulting number of pages by calling
-	 * <tt>bitmapFont.getRegions().length</tt> or <tt>freeTypeBitmapFontData.getTextureRegions().length</tt>.
-	 * 
-	 * If PixmapPacker is specified when calling generateData, this parameter is ignored.
-	 * 
-	 * @param texSize the maximum texture size for one page of glyphs */
-	public static void setMaxTextureSize (int texSize) {
-		maxTextureSize = texSize;
-	}
-
-	/** Returns the maximum texture size that will be used by generateData() when creating a texture atlas for the glyphs.
-	 * @return the power-of-two max texture size */
-	public static int getMaxTextureSize () {
-		return maxTextureSize;
-	}
-
 	/** {@link BitmapFontData} used for fonts generated via the {@link FreeTypeFontGenerator}. The texture storing the glyphs is held
 	 * in memory, thus the {@link #getImagePaths()} and {@link #getFontFile()} methods will return null.
-	 * @author mzechner
-	 * @author Nathan Sweet */
-	static public class FreeTypeBitmapFontData extends BitmapFontData implements Disposable {
-		Array<TextureRegion> regions;
-
-		// Fields for incremental glyph generation.
-		FreeTypeFontGenerator generator;
-		FreeTypeFontParameter parameter;
-		Stroker stroker;
-		String packPrefix;
-		PixmapPacker packer;
-		Array<Glyph> glyphs;
-
-		@Override
-		public Glyph getGlyph (char ch) {
-			Glyph glyph = super.getGlyph(ch);
-			if (glyph == null && generator != null && ch != 0) {
-				generator.setPixelSizes(0, parameter.size);
-				glyph = generator.createGlyph(ch, this, parameter, stroker, (ascent + capHeight) / scaleY, packPrefix, packer);
-				if (glyph == null) return null;
-
-				setGlyph(ch, glyph);
-				setGlyphRegion(glyph, regions.get(glyph.page));
-				glyphs.add(glyph);
-
-				if (parameter.kerning) {
-					Face face = generator.face;
-					int glyphIndex = face.getCharIndex(ch);
-					for (int i = 0, n = glyphs.size; i < n; i++) {
-						Glyph other = glyphs.get(i);
-						int otherIndex = face.getCharIndex(other.id);
-
-						int kerning = face.getKerning(glyphIndex, otherIndex, 0);
-						if (kerning != 0) glyph.setKerning(other.id, FreeType.toInt(kerning));
-
-						kerning = face.getKerning(otherIndex, glyphIndex, 0);
-						if (kerning != 0) other.setKerning(ch, FreeType.toInt(kerning));
-					}
-				}
-			}
-			return glyph;
+	 * @author mzechner */
+	public static class FreeTypeBitmapFontData extends BitmapFontData {
+		TextureRegion[] regions;
+
+		/** Returns the first texture region. Use getTextureRegions() instead
+		 * @return the first texture region in the array
+		 * @deprecated use getTextureRegions() instead */
+		@Deprecated
+		public TextureRegion getTextureRegion () {
+			return regions[0];
 		}
 
-		@Override
-		public void dispose () {
-			if (stroker != null) stroker.dispose();
-			if (packer != null) packer.dispose();
+		public TextureRegion[] getTextureRegions () {
+			return regions;
 		}
 	}
 
@@ -671,8 +550,7 @@ public class FreeTypeFontGenerator implements Disposable {
 	 * a power-of-two sized texture, and the resulting {@link FreeTypeBitmapFontData} will have a valid {@link TextureRegion} which
 	 * can be used to construct a new {@link BitmapFont}.
 	 * 
-	 * @author siondream
-	 * @author Nathan Sweet */
+	 * @author siondream */
 	public static class FreeTypeFontParameter {
 		/** The size in pixels */
 		public int size = 16;
@@ -698,16 +576,11 @@ public class FreeTypeFontGenerator implements Disposable {
 		public PixmapPacker packer = null;
 		/** Whether to flip the font vertically */
 		public boolean flip = false;
-		/** Whether to generate mip maps for the resulting texture */
+		/** Whether or not to generate mip maps for the resulting texture */
 		public boolean genMipMaps = false;
 		/** Minification filter */
 		public TextureFilter minFilter = TextureFilter.Nearest;
 		/** Magnification filter */
 		public TextureFilter magFilter = TextureFilter.Nearest;
-		/** When true, glyphs are rendered on the fly to the font's glyph page textures as they are needed. The FreeTypeFontGenerator
-		 * must not be disposed until the font is no longer needed. The FreeTypeBitmapFontData must be disposed (separately from the
-		 * generator) when the font is no longer needed. The FreeTypeFontParameter should not be modified after creating a font. If
-		 * a PixmapPacker is not specified, the font glyph page textures will use {@link FreeTypeFontGenerator#getMaxTextureSize()}. */
-		public boolean incremental;
 	}
 }
diff --git a/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreetypeFontLoader.java b/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreetypeFontLoader.java
index 8848909..f56f0cb 100644
--- a/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreetypeFontLoader.java
+++ b/extensions/gdx-freetype/src/com/badlogic/gdx/graphics/g2d/freetype/FreetypeFontLoader.java
@@ -18,6 +18,7 @@ import com.badlogic.gdx.utils.Array;
  * file as well the parameters used to generate the BitmapFont (size, characters, etc.) 
  */
 public class FreetypeFontLoader extends AsynchronousAssetLoader<BitmapFont, FreetypeFontLoader.FreeTypeFontLoaderParameter>{
+
 	public FreetypeFontLoader (FileHandleResolver resolver) {
 		super(resolver);
 	}
@@ -39,7 +40,7 @@ public class FreetypeFontLoader extends AsynchronousAssetLoader<BitmapFont, Free
 		if(parameter == null) throw new RuntimeException("FreetypeFontParameter must be set in AssetManager#load to point at a TTF file!");
 		FreeTypeFontGenerator generator = manager.get(parameter.fontFileName + ".gen", FreeTypeFontGenerator.class);	
 		FreeTypeBitmapFontData data = generator.generateData(parameter.fontParameters);
-		BitmapFont font = new BitmapFont(data, data.regions, false);
+		BitmapFont font = new BitmapFont(data, data.getTextureRegions(), false);
 		font.setOwnsTexture(true);
 		return font;
 	}
diff --git a/extensions/gdx-jnigen/pom.xml b/extensions/gdx-jnigen/pom.xml
index 76c8862..0af97f4 100644
--- a/extensions/gdx-jnigen/pom.xml
+++ b/extensions/gdx-jnigen/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.5.6-SNAPSHOT</version>
+    <version>1.5.5-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/NativeCodeGenerator.java b/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/NativeCodeGenerator.java
index c3a1441..a4865cd 100644
--- a/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/NativeCodeGenerator.java
+++ b/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/NativeCodeGenerator.java
@@ -284,13 +284,11 @@ public class NativeCodeGenerator {
 		Process process = Runtime.getRuntime().exec(command);
 		process.waitFor();
 		if (process.exitValue() != 0) {
-			System.out.println();
 			InputStream errorStream = process.getErrorStream();
 			int c = 0;
 			while ((c = errorStream.read()) != -1) {
 				System.out.print((char)c);
 			}
-			System.out.println("Command: " + command);
 		}
 	}
 
@@ -324,8 +322,8 @@ public class NativeCodeGenerator {
 
 	private CMethod findCMethod (JavaMethod javaMethod, ArrayList<CMethod> cMethods) {
 		for (CMethod cMethod : cMethods) {
-			if (cMethod.getHead().endsWith(javaMethod.getClassName() + "_" + javaMethod.getName())
-				|| cMethod.getHead().contains(javaMethod.getClassName() + "_" + javaMethod.getName() + "__")) {
+			if (cMethod.getHead().endsWith(javaMethod.getClassName() + "_" + javaMethod.getName()) ||
+				 cMethod.getHead().contains(javaMethod.getClassName() + "_" + javaMethod.getName() + "__")) {
 				// FIXME poor man's overloaded method check...
 				// FIXME float test[] won't work, needs to be float[] test.
 				if (cMethod.getArgumentTypes().length - 2 == javaMethod.getArguments().size()) {
@@ -516,8 +514,8 @@ public class NativeCodeGenerator {
 		for (Argument arg : javaMethod.getArguments()) {
 			if (arg.getType().isBuffer()) {
 				String type = arg.getType().getBufferCType();
-				buffer.append("\t" + type + " " + arg.getName() + " = (" + type + ")(" + JNI_ARG_PREFIX + arg.getName()
-					+ "?env->GetDirectBufferAddress(" + JNI_ARG_PREFIX + arg.getName() + "):0);\n");
+				buffer.append("\t" + type + " " + arg.getName() + " = (" + type + ")(" + JNI_ARG_PREFIX
+					+ arg.getName() + "?env->GetDirectBufferAddress(" + JNI_ARG_PREFIX	+ arg.getName() + "):0);\n");
 				additionalArgs.append(", ");
 				additionalArgs.append(type);
 				additionalArgs.append(" ");
diff --git a/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/resources/scripts/build-ios.xml.template b/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/resources/scripts/build-ios.xml.template
index d384a82..ec01bd7 100755
--- a/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/resources/scripts/build-ios.xml.template
+++ b/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/resources/scripts/build-ios.xml.template
@@ -12,9 +12,9 @@
 	<!-- the compilerPrefix for the C & C++ compilers -->
 	<property name="compilerPrefix" value="%compilerPrefix%"/>	
 	<property name="iphoneos-platform" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin"/>
-	<property name="iphoneos-sdk" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.2.sdk/"/>
+	<property name="iphoneos-sdk" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.1.sdk/"/>
 	<property name="iphonesimulator-platform" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin"/>
-	<property name="iphonesimulator-sdk" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.2.sdk"/>
+	<property name="iphonesimulator-sdk" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.1.sdk"/>
 	
 	<!-- define gcc compiler, options and files to compile -->
 	<property name="gcc" value="/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"/>	
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/Dependency.java b/extensions/gdx-setup/src/com/badlogic/gdx/setup/Dependency.java
index 153bca3..3a90781 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/Dependency.java
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/Dependency.java
@@ -10,12 +10,10 @@ import java.util.List;
 public class Dependency {
 
 	private HashMap<ProjectType, String[]> subDependencyMap = new HashMap<ProjectType, String[]>();
-	private String[] gwtInherits;
 	private String name;
 
-	public Dependency (String name, String[] gwtInherits, String[]... subDependencies) {
+	public Dependency (String name, String[]... subDependencies) {
 		this.name = name;
-		this.gwtInherits = gwtInherits;
 		for (ProjectType type : ProjectType.values()) {
 			subDependencyMap.put(type, subDependencies[type.ordinal()]);
 		}
@@ -34,10 +32,6 @@ public class Dependency {
 		return incompat;
 	}
 
-	public String[] getGwtInherits () {
-		return gwtInherits;
-	}
-	
 	public String getName () {
 		return name;
 	}
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/DependencyBank.java b/extensions/gdx-setup/src/com/badlogic/gdx/setup/DependencyBank.java
index a29ab30..1e63fdb 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/DependencyBank.java
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/DependencyBank.java
@@ -2,14 +2,15 @@ package com.badlogic.gdx.setup;
 
 
 import java.util.HashMap;
+import java.util.LinkedHashMap;
 
 public class DependencyBank {
 
 	//Versions
-	static String libgdxVersion = "1.5.5";
+	static String libgdxVersion = "1.5.4";
 	//Temporary snapshot version, we need a more dynamic solution for pointing to the latest nightly
-	static String libgdxNightlyVersion = "1.5.6-SNAPSHOT";
-	static String roboVMVersion = "1.0.0";
+	static String libgdxNightlyVersion = "1.5.5-SNAPSHOT";
+	static String roboVMVersion = "1.0.1-SNAPSHOT";
 	static String buildToolsVersion = "20.0.0";
 	static String androidAPILevel = "20";
 	static String gwtVersion = "2.6.0";
@@ -31,11 +32,11 @@ public class DependencyBank {
 	static String aiVersion = "1.5.0";
 
 	HashMap<ProjectDependency, Dependency> gdxDependencies = new HashMap<ProjectDependency, Dependency>();
+	LinkedHashMap<ProjectDependency, String[]> gwtInheritances = new LinkedHashMap<ProjectDependency, String[]>();
 
 	public DependencyBank() {
 		for (ProjectDependency projectDep : ProjectDependency.values()) {
 			Dependency dependency = new Dependency(projectDep.name(),
-					projectDep.getGwtInherits(),
 					projectDep.getDependencies(ProjectType.CORE),
 					projectDep.getDependencies(ProjectType.DESKTOP),
 					projectDep.getDependencies(ProjectType.ANDROID),
@@ -43,12 +44,19 @@ public class DependencyBank {
 					projectDep.getDependencies(ProjectType.HTML));
 			gdxDependencies.put(projectDep, dependency);
 		}
+		gwtInheritances.put(ProjectDependency.GDX, new String[]{"com.badlogic.gdx.backends.gdx_backends_gwt"});
+		gwtInheritances.put(ProjectDependency.CONTROLLERS, new String[]{"com.badlogic.gdx.controllers.controllers-gwt"});
+		gwtInheritances.put(ProjectDependency.BOX2D, new String[]{"com.badlogic.gdx.physics.box2d.box2d-gwt"});
+		gwtInheritances.put(ProjectDependency.BOX2DLIGHTS, new String[]{"Box2DLights"});
+		gwtInheritances.put(ProjectDependency.ASHLEY, new String[]{"com.badlogic.ashley_gwt"});
+		gwtInheritances.put(ProjectDependency.AI, new String[]{"com.badlogic.gdx.ai"});
 	}
 
 	public Dependency getDependency(ProjectDependency gdx) {
 		return gdxDependencies.get(gdx);
 	}
 
+
 	/**
 	 * This enum will hold all dependencies available for libgdx, allowing the setup to pick the ones needed by default,
 	 * and allow the option to choose extensions as the user wishes.
@@ -66,7 +74,6 @@ public class DependencyBank {
 			new String[]{"com.badlogicgames.gdx:gdx-backend-android:$gdxVersion", "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-armeabi", "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-armeabi-v7a", "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-x86"},
 			new String[]{"org.robovm:robovm-rt:${roboVMVersion}", "org.robovm:robovm-cocoatouch:${roboVMVersion}", "com.badlogicgames.gdx:gdx-backend-robovm:$gdxVersion", "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-ios"},
 			new String[]{"com.badlogicgames.gdx:gdx-backend-gwt:$gdxVersion", "com.badlogicgames.gdx:gdx:$gdxVersion:sources", "com.badlogicgames.gdx:gdx-backend-gwt:$gdxVersion:sources"},
-			new String[]{"com.badlogic.gdx.backends.gdx_backends_gwt"},
 			
 			"Core Library for LibGDX"
 		),
@@ -76,7 +83,6 @@ public class DependencyBank {
 			new String[]{"com.badlogicgames.gdx:gdx-bullet:$gdxVersion", "com.badlogicgames.gdx:gdx-bullet-platform:$gdxVersion:natives-armeabi", "com.badlogicgames.gdx:gdx-bullet-platform:$gdxVersion:natives-armeabi-v7a", "com.badlogicgames.gdx:gdx-bullet-platform:$gdxVersion:natives-x86"},
 			new String[]{"com.badlogicgames.gdx:gdx-bullet-platform:$gdxVersion:natives-ios"},
 			null,
-			null,
 			
 			"3D Collision Detection and Rigid Body Dynamics"
 		),
@@ -86,7 +92,6 @@ public class DependencyBank {
 			new String[]{"com.badlogicgames.gdx:gdx-freetype:$gdxVersion", "com.badlogicgames.gdx:gdx-freetype-platform:$gdxVersion:natives-armeabi", "com.badlogicgames.gdx:gdx-freetype-platform:$gdxVersion:natives-armeabi-v7a", "com.badlogicgames.gdx:gdx-freetype-platform:$gdxVersion:natives-x86"},
 			new String[]{"com.badlogicgames.gdx:gdx-freetype-platform:$gdxVersion:natives-ios"},
 			null,
-			null,
 			
 			"Generate BitmapFonts from .ttf font files"
 		),
@@ -96,7 +101,6 @@ public class DependencyBank {
 			new String[]{},
 			new String[]{},
 			new String[]{},
-			new String[]{},
 			
 			"Collection of tools, including 2D/3D particle editors, texture packers, and file processors"
 		),
@@ -104,10 +108,9 @@ public class DependencyBank {
 			new String[]{"com.badlogicgames.gdx:gdx-controllers:$gdxVersion"},
 			new String[]{"com.badlogicgames.gdx:gdx-controllers-desktop:$gdxVersion", "com.badlogicgames.gdx:gdx-controllers-platform:$gdxVersion:natives-desktop"},
 			new String[]{"com.badlogicgames.gdx:gdx-controllers:$gdxVersion", "com.badlogicgames.gdx:gdx-controllers-android:$gdxVersion"},
-			new String[]{}, // works on iOS but never reports any controllers :)
+			new String[] {}, // works on iOS but never reports any controllers :)
 			new String[]{"com.badlogicgames.gdx:gdx-controllers:$gdxVersion:sources", "com.badlogicgames.gdx:gdx-controllers-gwt:$gdxVersion", "com.badlogicgames.gdx:gdx-controllers-gwt:$gdxVersion:sources"},
-			new String[]{"com.badlogic.gdx.controllers.controllers-gwt"},
-
+			
 			"Controller/Gamepad API"
 		),
 		BOX2D(
@@ -116,7 +119,6 @@ public class DependencyBank {
 			new String[]{"com.badlogicgames.gdx:gdx-box2d:$gdxVersion", "com.badlogicgames.gdx:gdx-box2d-platform:$gdxVersion:natives-armeabi", "com.badlogicgames.gdx:gdx-box2d-platform:$gdxVersion:natives-armeabi-v7a", "com.badlogicgames.gdx:gdx-box2d-platform:$gdxVersion:natives-x86"},
 			new String[]{"com.badlogicgames.gdx:gdx-box2d-platform:$gdxVersion:natives-ios"},
 			new String[]{"com.badlogicgames.gdx:gdx-box2d:$gdxVersion:sources", "com.badlogicgames.gdx:gdx-box2d-gwt:$gdxVersion:sources"},
-			new String[]{"com.badlogic.gdx.physics.box2d.box2d-gwt"},
 			
 			"2D Physics Library"
 		),	
@@ -126,7 +128,6 @@ public class DependencyBank {
 			new String[]{"com.badlogicgames.box2dlights:box2dlights:$box2DLightsVersion"},
 			new String[]{},
 			new String[]{"com.badlogicgames.box2dlights:box2dlights:$box2DLightsVersion:sources"},
-			new String[]{"Box2DLights"},
 			
 			"2D Lighting framework that utilises Box2D"
 		),
@@ -136,7 +137,6 @@ public class DependencyBank {
 			new String[]{"com.badlogicgames.ashley:ashley:$ashleyVersion"},
 			new String[]{},
 			new String[]{"com.badlogicgames.ashley:ashley:$ashleyVersion:sources"},
-			new String[]{"com.badlogic.ashley_gwt"},
 			
 			"Lightweight Entity framework"
 		),
@@ -146,7 +146,6 @@ public class DependencyBank {
 			new String[]{"com.badlogicgames.gdx:gdx-ai:$aiVersion"},
 			new String[]{},
 			new String[]{"com.badlogicgames.gdx:gdx-ai:$aiVersion:sources"},
-			new String[]{"com.badlogic.gdx.ai"},
 			
 			"Artificial Intelligence framework"
 		);
@@ -156,16 +155,14 @@ public class DependencyBank {
 		private String[] androidDependencies;
 		private String[] iosDependencies;
 		private String[] gwtDependencies;
-		private String[] gwtInherits;
 		private String description;
 
-		ProjectDependency(String[] coreDeps, String[] desktopDeps, String[] androidDeps, String[] iosDeps, String[] gwtDeps, String[] gwtInhertis, String description) {
+		ProjectDependency(String[] coreDeps, String[] desktopDeps, String[] androidDeps, String[] iosDeps, String[] gwtDeps, String description) {
 			this.coreDependencies = coreDeps;
 			this.desktopDependencies = desktopDeps;
 			this.androidDependencies = androidDeps;
 			this.iosDependencies = iosDeps;
 			this.gwtDependencies = gwtDeps;
-			this.gwtInherits = gwtInhertis;
 			this.description = description;
 		}
 
@@ -185,10 +182,6 @@ public class DependencyBank {
 			return null;
 		}
 		
-		public String[] getGwtInherits() {
-			return gwtInherits;
-		}
-		
 		public String getDescription() {
 			return description;
 		}
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/ExternalExtension.java b/extensions/gdx-setup/src/com/badlogic/gdx/setup/ExternalExtension.java
index 67e6c9a..9d3fbde 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/ExternalExtension.java
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/ExternalExtension.java
@@ -22,25 +22,23 @@ import java.util.Map;
 public class ExternalExtension {
 
 	private String name;
-	private String[] gwtInherits;
 	private String description;
 	private String version;
 
 	private Map<String, List<String>> dependencies;
 
-	public ExternalExtension (String name, String[] gwtInherits, String description, String version) {
+	public ExternalExtension (String name, String description, String version) {
 		this.name = name;
-		this.gwtInherits = gwtInherits;
 		this.description = description;
 		this.version = version;
 	}
-	
+
 	public void setDependencies (Map<String, List<String>> dependencies) {
 		this.dependencies = dependencies;
 	}
 
 	public Dependency generateDependency () {
-		Dependency dep = new Dependency(name, gwtInherits, getPlatformDependencies("core"), getPlatformDependencies("desktop"),
+		Dependency dep = new Dependency(name, getPlatformDependencies("core"), getPlatformDependencies("desktop"),
 			getPlatformDependencies("android"), getPlatformDependencies("ios"), getPlatformDependencies("html"));
 
 		return dep;
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/ExternalExtensionsDialog.java b/extensions/gdx-setup/src/com/badlogic/gdx/setup/ExternalExtensionsDialog.java
index cb217e3..dd762fe 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/ExternalExtensionsDialog.java
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/ExternalExtensionsDialog.java
@@ -42,14 +42,13 @@ import java.util.List;
 import java.util.Map;
 
 import javax.swing.BorderFactory;
+import javax.swing.JButton;
 import javax.swing.JDialog;
 import javax.swing.JLabel;
 import javax.swing.JPanel;
 import javax.swing.JScrollPane;
 import javax.swing.JSeparator;
 import javax.swing.JTable;
-import javax.swing.event.TableModelEvent;
-import javax.swing.event.TableModelListener;
 import javax.swing.table.DefaultTableModel;
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
@@ -63,7 +62,7 @@ import org.xml.sax.SAXException;
 
 import com.badlogic.gdx.setup.GdxSetupUI.SetupButton;
 
-public class ExternalExtensionsDialog extends JDialog implements TableModelListener {
+public class ExternalExtensionsDialog extends JDialog {
 
 	private JPanel contentPane;
 	private SetupButton buttonOK;
@@ -148,11 +147,24 @@ public class ExternalExtensionsDialog extends JDialog implements TableModelListe
 		table.setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN);
 
 		table.getTableHeader().setReorderingAllowed(false);
-		table.getModel().addTableModelListener(this);
 		table.addMouseListener(new MouseAdapter() {
 			public void mouseClicked (MouseEvent e) {
 				int row = table.getSelectedRow();
 				int column = table.getSelectedColumn();
+
+				if (column == 0) {
+					ExternalExtension extension = ((ExtensionTableModel)table.getModel()).getExtension(row);
+					Dependency dep = extension.generateDependency();
+					boolean selected = (Boolean)table.getModel().getValueAt(row, 0);
+					if (selected) {
+						if (!mainDependencies.contains(dep)) {
+							mainDependencies.add(dep);
+						}
+					} else {
+						mainDependencies.remove(dep);
+					}
+				}
+
 				if (column == 5) {
 					URI uri = ((ExtensionTableModel)table.getModel()).getURI(row, column);
 					if (uri != null) {
@@ -211,13 +223,6 @@ public class ExternalExtensionsDialog extends JDialog implements TableModelListe
 				String compatibility = eElement.getElementsByTagName("compatibility").item(0).getTextContent();
 				String url = eElement.getElementsByTagName("website").item(0).getTextContent();
 
-				String[] gwtInherits = null;
-				NodeList inheritsNode = eElement.getElementsByTagName("inherit");
-				gwtInherits = new String[inheritsNode.getLength()];
-
-				for (int j = 0; j < inheritsNode.getLength(); j++)
-					gwtInherits[j] = inheritsNode.item(j).getTextContent();
-
 				final HashMap<String, List<String>> dependencies = new HashMap<String, List<String>>();
 
 				addToDependencyMapFromXML(dependencies, eElement, "core");
@@ -234,7 +239,7 @@ public class ExternalExtensionsDialog extends JDialog implements TableModelListe
 				}
 
 				if (uri != null) {
-					final ExternalExtension extension = new ExternalExtension(name, gwtInherits, description, version);
+					final ExternalExtension extension = new ExternalExtension(name, description, version);
 					extension.setDependencies(dependencies);
 					tableModel.addExtension(extension, false, name, description, version, compatibility, uri);
 				}
@@ -398,24 +403,5 @@ public class ExternalExtensionsDialog extends JDialog implements TableModelListe
 		}
 
 	}
-	
-	@Override
-	public void tableChanged (TableModelEvent e) {
-		int row = e.getFirstRow();
-		int column = e.getColumn();
-
-		if (column == 0) {
-			ExternalExtension extension = ((ExtensionTableModel)table.getModel()).getExtension(row);
-			Dependency dep = extension.generateDependency();
-			boolean selected = (Boolean)table.getModel().getValueAt(row, 0);
-			if (selected) {
-				if (!mainDependencies.contains(dep)) {
-					mainDependencies.add(dep);
-				}
-			} else {
-				mainDependencies.remove(dep);
-			}
-		}
-	}
 
 }
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/GdxSetup.java b/extensions/gdx-setup/src/com/badlogic/gdx/setup/GdxSetup.java
index 62ae1d4..01d1229 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/GdxSetup.java
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/GdxSetup.java
@@ -332,7 +332,7 @@ public class GdxSetup {
 		values.put("%API_LEVEL%", DependencyBank.androidAPILevel);
 		values.put("%GWT_VERSION%", DependencyBank.gwtVersion);
 		if (builder.modules.contains(ProjectType.HTML)) {
-			values.put("%GWT_INHERITS%", parseGwtInherits(builder));
+			values.put("%GWT_INHERITS%", parseGwtInherits(builder.bank.gwtInheritances, builder));
 		}
 
 		copyAndReplace(outputDir, project, values);
@@ -499,17 +499,15 @@ public class GdxSetup {
 		return params;
 	}
 
-	private String parseGwtInherits (ProjectBuilder builder) {
+	private String parseGwtInherits (HashMap<ProjectDependency, String[]> gwtInheritances, ProjectBuilder builder) {
 		String parsed = "";
-		
-		for (Dependency dep : builder.dependencies) {
-			if (dep.getGwtInherits() != null) {
-				for (String inherit : dep.getGwtInherits()) {
+		for (ProjectDependency dep : gwtInheritances.keySet()) {
+			if (containsDependency(builder.dependencies, dep)) {
+				for (String inherit : gwtInheritances.get(dep)) {
 					parsed += "\t<inherits name='" + inherit + "' />\n";
 				}
 			}
 		}
-		
 		return parsed;
 	}
 
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/GdxSetupUI.java b/extensions/gdx-setup/src/com/badlogic/gdx/setup/GdxSetupUI.java
index 2aabaef..fd8466c 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/GdxSetupUI.java
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/GdxSetupUI.java
@@ -29,6 +29,7 @@ import java.awt.Desktop;
 import java.awt.Dimension;
 import java.awt.EventQueue;
 import java.awt.FileDialog;
+import java.awt.FlowLayout;
 import java.awt.Graphics;
 import java.awt.GridBagConstraints;
 import java.awt.GridBagLayout;
@@ -87,6 +88,7 @@ public class GdxSetupUI extends JFrame {
 	ProjectBuilder builder;
 	List<ProjectType> modules = new ArrayList<ProjectType>();
 	List<Dependency> dependencies = new ArrayList<Dependency>();
+	List<ExternalExtension> externalExtensions = new ArrayList<ExternalExtension>();
 
 	UI ui = new UI();
 	static Point point = new Point();
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/SettingsDialog.java b/extensions/gdx-setup/src/com/badlogic/gdx/setup/SettingsDialog.java
index 5106faa..60bc420 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/SettingsDialog.java
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/SettingsDialog.java
@@ -42,6 +42,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 import javax.swing.BorderFactory;
+import javax.swing.JCheckBox;
 import javax.swing.JDialog;
 import javax.swing.JLabel;
 import javax.swing.JOptionPane;
diff --git a/extensions/gdx-setup/src/com/badlogic/gdx/setup/data/extensions.xml b/extensions/gdx-setup/src/com/badlogic/gdx/setup/data/extensions.xml
index b8925cd..79d1c01 100644
--- a/extensions/gdx-setup/src/com/badlogic/gdx/setup/data/extensions.xml
+++ b/extensions/gdx-setup/src/com/badlogic/gdx/setup/data/extensions.xml
@@ -1,89 +1,20 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <extensions>
-	<extension>
-		<name>Overlap2D</name>
-		<description>Level and UI Editor Runtime</description>
-		<package>com.underwaterapps.overlap2druntime</package>
-		<version>0.0.8</version>
-		<compatibility>1.5.3</compatibility>
-		<website>http://overlap2d.com/</website>
-		<gwtInherits></gwtInherits>
-		<projects>
-			<core>
-				<dependency>com.underwaterapps.overlap2druntime:overlap2d-runtime-libgdx</dependency>
-			</core>
-			<desktop></desktop>
-			<android></android>
-			<ios></ios>
-			<html>null</html>
-		</projects>
-	</extension>
-	<extension>
-		<name>VisUI</name>
-		<description>Flat design skin for scene2d.ui and UI toolkit</description>
-		<package>com.kotcrab.vis.ui</package>
-		<version>0.7.1</version>
-		<compatibility>1.5.5</compatibility>
-		<website>https://github.com/kotcrab/VisEditor/wiki/VisUI</website>
-		<gwtInherits>
-		    <inherit>com.kotcrab.vis.vis-ui</inherit>
-		</gwtInherits>
-		<projects>
-			<core>
-				<dependency>com.kotcrab.vis:vis-ui</dependency>
-			</core>
-			<desktop></desktop>
-			<android></android>
-			<ios></ios>
-			<html>
-				<dependency>com.kotcrab.vis:vis-ui:sources</dependency>
-			</html>
-		</projects>
-	</extension>
-	<extension>
-		<name>libgdx-utils</name>
-		<description>additional features and helper classes</description>
-		<package>net.dermetfan.gdx</package>
-		<version>0.10.0</version>
-		<compatibility>1.5.5</compatibility>
-		<website>http://dermetfan.net/libgdx-utils.php</website>
-		<gwtInherits>
-			<inherit>libgdx-utils</inherit>
-		</gwtInherits>
-		<projects>
-			<core>
-				<dependency>net.dermetfan.libgdx-utils:libgdx-utils</dependency>
-			</core>
-			<desktop></desktop>
-			<android></android>
-			<ios></ios>
-			<html>
-				<dependency>net.dermetfan.libgdx-utils:libgdx-utils:sources</dependency>
-			</html>
-		</projects>
-	</extension>
-	<extension>
-		<name>libgdx-utils-box2d</name>
-		<description>additional features and helper classes for the official Box2D extension</description>
-		<package>net.dermetfan.gdx</package>
-		<version>0.10.0</version>
-		<compatibility>1.5.5</compatibility>
-		<website>http://dermetfan.net/libgdx-utils.php</website>
-		<gwtInherits>
-			<inherit>libgdx-utils-box2d-gwt</inherit>
-		</gwtInherits>
-		<projects>
-			<core>
-				<dependency>net.dermetfan.libgdx-utils:libgdx-utils-box2d</dependency>
-			</core>
-			<desktop></desktop>
-			<android></android>
-			<ios></ios>
-			<html>
-				<dependency>net.dermetfan.libgdx-utils:libgdx-utils:sources</dependency>
-				<dependency>net.dermetfan.libgdx-utils:libgdx-utils-box2d:sources</dependency>
-				<dependency>net.dermetfan.libgdx-utils:libgdx-utils-box2d-gwt:sources</dependency>
-			</html>
-		</projects>
-	</extension>
+    <extension>
+       <name>Overlap2D</name>
+       <description>Level and UI Editor Runtime</description>
+       <package>com.underwaterapps.overlap2druntime</package>
+       <version>0.0.8</version>
+       <compatibility>1.5.3</compatibility>
+       <website>http://overlap2d.com/</website>
+       <projects>
+           <core>
+               <dependency>com.underwaterapps.overlap2druntime:overlap2d-runtime-libgdx</dependency>
+           </core>
+           <desktop></desktop>
+           <android></android>
+           <ios></ios>
+           <html>null</html>
+       </projects>
+    </extension>
 </extensions>
diff --git a/extensions/gdx-tools/pom.xml b/extensions/gdx-tools/pom.xml
index c9079c7..7df5e2c 100644
--- a/extensions/gdx-tools/pom.xml
+++ b/extensions/gdx-tools/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.5.6-SNAPSHOT</version>
+    <version>1.5.5-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/hiero/Hiero.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/hiero/Hiero.java
index 9117910..a3d4a51 100644
--- a/extensions/gdx-tools/src/com/badlogic/gdx/tools/hiero/Hiero.java
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/hiero/Hiero.java
@@ -164,8 +164,8 @@ public class Hiero extends JFrame {
 	File saveBmFontFile;
 	String lastSaveFilename = "", lastSaveBMFilename = "", lastOpenFilename = "";
 
-	public Hiero (String[] args) {
-		super("Hiero v3.1 - Bitmap Font Tool");
+	public Hiero(String [] args) {
+		super("Hiero v3.0 - Bitmap Font Tool");
 		Splash splash = new Splash(this, "/splash.jpg", 2000);
 		initialize();
 		splash.close();
@@ -193,7 +193,7 @@ public class Hiero extends JFrame {
 		new EffectPanel(colorEffect);
 
 		parseArgs(args);
-
+		
 		addWindowListener(new WindowAdapter() {
 			public void windowClosed (WindowEvent event) {
 				System.exit(0);
@@ -259,6 +259,8 @@ public class Hiero extends JFrame {
 
 		int fontSize = ((Integer)fontSizeSpinner.getValue()).intValue();
 
+		
+		 
 		if (useFont2) {
 			File file = new File(fontFileText.getText());
 			if (file.exists() && file.isFile()) {
@@ -272,8 +274,8 @@ public class Hiero extends JFrame {
 				}
 			}
 		}
-
-		if (unicodeFont == null) {
+		
+		if(unicodeFont == null) {
 			// Load from java.awt.Font (kerning not available!).
 			unicodeFont = new UnicodeFont(Font.decode((String)fontList.getSelectedValue()), fontSize, boldCheckBox.isSelected(),
 				italicCheckBox.isSelected());
@@ -311,7 +313,7 @@ public class Hiero extends JFrame {
 		settings.setFontName((String)fontList.getSelectedValue());
 		settings.setFontSize(((Integer)fontSizeSpinner.getValue()).intValue());
 		settings.setFont2File(fontFileText.getText());
-		settings.setFont2Active(fontFileRadio.isSelected());
+	settings.setFont2Active(fontFileRadio.isSelected());
 		settings.setBold(boldCheckBox.isSelected());
 		settings.setItalic(italicCheckBox.isSelected());
 		settings.setPaddingTop(((Integer)padTopSpinner.getValue()).intValue());
@@ -352,7 +354,7 @@ public class Hiero extends JFrame {
 		if (gt.length() > 0) {
 			sampleTextPane.setText(settings.getGlyphText());
 		}
-
+		
 		final String font2 = settings.getFont2File();
 		if (font2.length() > 0)
 			fontFileText.setText(font2);
@@ -361,7 +363,7 @@ public class Hiero extends JFrame {
 
 		fontFileRadio.setSelected(settings.isFont2Active());
 		systemFontRadio.setSelected(!settings.isFont2Active());
-
+ 
 		for (Iterator iter = settings.getEffects().iterator(); iter.hasNext();) {
 			ConfigurableEffect settingsEffect = (ConfigurableEffect)iter.next();
 			for (int i = 0, n = effectsListModel.getSize(); i < n; i++) {
@@ -471,7 +473,7 @@ public class Hiero extends JFrame {
 				updateFont();
 			}
 		};
-
+		
 		systemFontRadio.addActionListener(al);
 		fontFileRadio.addActionListener(al);
 
@@ -1044,7 +1046,7 @@ public class Hiero extends JFrame {
 		JButton deleteButton;
 		private JPanel valuesPanel;
 		JLabel nameLabel;
-
+		
 		GridBagConstraints constrains = new GridBagConstraints(0, -1, 1, 1, 1.0, 0.0, GridBagConstraints.CENTER,
 			GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0), 0, 0);
 
@@ -1071,7 +1073,7 @@ public class Hiero extends JFrame {
 					}
 
 					public void layoutContainer (Container parent) {
-
+						
 						Dimension buttonSize = upButton.getPreferredSize();
 						int upButtonX = getWidth() - buttonSize.width * 3 - 6 - 5;
 						upButton.setBounds(upButtonX, 0, buttonSize.width, buttonSize.height);
@@ -1079,7 +1081,8 @@ public class Hiero extends JFrame {
 						deleteButton.setBounds(getWidth() - buttonSize.width - 5, 0, buttonSize.width, buttonSize.height);
 
 						Dimension labelSize = nameLabel.getPreferredSize();
-						nameLabel.setBounds(5, buttonSize.height / 2 - labelSize.height / 2, getWidth() - 5, labelSize.height);
+						nameLabel.setBounds(5, buttonSize.height / 2 - labelSize.height / 2, getWidth() - 5,
+							labelSize.height);
 					}
 
 					public void addLayoutComponent (String name, Component comp) {
@@ -1140,7 +1143,7 @@ public class Hiero extends JFrame {
 					}
 				}
 			});
-
+			
 			downButton.addActionListener(new ActionListener() {
 				@Override
 				public void actionPerformed (ActionEvent evt) {
@@ -1152,7 +1155,7 @@ public class Hiero extends JFrame {
 					}
 				}
 			});
-
+			
 			deleteButton.addActionListener(new ActionListener() {
 				public void actionPerformed (ActionEvent evt) {
 					remove();
@@ -1180,17 +1183,17 @@ public class Hiero extends JFrame {
 			for (Iterator iter = values.iterator(); iter.hasNext();)
 				addValue((Value)iter.next());
 		}
+		
+		public void updateUpDownButtons() {
 
-		public void updateUpDownButtons () {
-
-			for (int index = 0; index < effectPanels.size(); index++) {
+			for(int index = 0; index < effectPanels.size(); index++){
 				EffectPanel effectPanel = effectPanels.get(index);
 				if (index == 0) {
 					effectPanel.upButton.setEnabled(false);
 				} else {
 					effectPanel.upButton.setEnabled(true);
 				}
-
+				
 				if (index == effectPanels.size() - 1) {
 					effectPanel.downButton.setEnabled(false);
 				} else {
@@ -1198,7 +1201,7 @@ public class Hiero extends JFrame {
 				}
 			}
 		}
-
+		
 		public void moveEffect (int newIndex) {
 			appliedEffectsPanel.remove(this);
 			effectPanels.remove(this);
@@ -1255,7 +1258,7 @@ public class Hiero extends JFrame {
 			} else if (!effect.equals(other.effect)) return false;
 			return true;
 		}
-
+		
 	}
 
 	static private class Splash extends JWindow {
@@ -1339,13 +1342,7 @@ public class Hiero extends JFrame {
 				newUnicodeFont = null;
 			}
 
-			try {
-				sampleText = sampleTextPane.getText();
-			} catch (Exception ex) {
-			}
-			unicodeFont.addGlyphs(sampleText);
-
-			if (!unicodeFont.getEffects().isEmpty() && unicodeFont.loadGlyphs(64)) {
+			if (!unicodeFont.getEffects().isEmpty() && unicodeFont.loadGlyphs(25)) {
 				glyphPageComboModel.removeAllElements();
 				int pageCount = unicodeFont.getGlyphPages().size();
 				int glyphCount = 0;
@@ -1359,6 +1356,11 @@ public class Hiero extends JFrame {
 
 			if (unicodeFont == null) return;
 
+			try {
+				sampleText = sampleTextPane.getText();
+			} catch (Exception ex) {
+			}
+
 			if (sampleTextRadio.isSelected()) {
 				GL11.glClearColor(renderingBackgroundColor.r, renderingBackgroundColor.g, renderingBackgroundColor.b,
 					renderingBackgroundColor.a);
@@ -1369,6 +1371,7 @@ public class Hiero extends JFrame {
 			} else {
 				GL11.glClearColor(1, 1, 1, 1);
 				GL11.glClear(GL11.GL_COLOR_BUFFER_BIT);
+				unicodeFont.addGlyphs(sampleText);
 				// GL11.glColor4f(renderingBackgroundColor.r, renderingBackgroundColor.g, renderingBackgroundColor.b,
 				// renderingBackgroundColor.a);
 				// fillRect(0, 0, unicodeFont.getGlyphPageWidth() + 2, unicodeFont.getGlyphPageHeight() + 2);
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/hiero/Hiero4.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/hiero/Hiero4.java
index dbad81c..7658106 100644
--- a/extensions/gdx-tools/src/com/badlogic/gdx/tools/hiero/Hiero4.java
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/hiero/Hiero4.java
@@ -94,7 +94,6 @@ import com.badlogic.gdx.graphics.g2d.SpriteBatch;
 import com.badlogic.gdx.graphics.g2d.TextureRegion;
 import com.badlogic.gdx.tools.hiero.unicodefont.UnicodeFont;
 import com.badlogic.gdx.tools.hiero.unicodefont.effects.EffectUtil;
-import com.badlogic.gdx.utils.Align;
 
 import de.matthiasmann.twlthemeeditor.fontgen.CharSet;
 import de.matthiasmann.twlthemeeditor.fontgen.Effect;
@@ -987,7 +986,7 @@ public class Hiero4 extends JFrame {
 				GL11.glClear(GL11.GL_COLOR_BUFFER_BIT);
 
 				batch.begin();
-				font.draw(batch, sampleTextPane.getText(), 0, viewHeight, viewWidth, Align.left, true);
+				font.drawWrapped(batch, sampleTextPane.getText(), 0, viewHeight, viewWidth);
 				batch.end();
 			} else {
 				glClearColor(1, 1, 1, 1);
diff --git a/extensions/gdx-tools/src/com/badlogic/gdx/tools/particleeditor/GradientPanel.java b/extensions/gdx-tools/src/com/badlogic/gdx/tools/particleeditor/GradientPanel.java
index 2adeed5..58b136c 100644
--- a/extensions/gdx-tools/src/com/badlogic/gdx/tools/particleeditor/GradientPanel.java
+++ b/extensions/gdx-tools/src/com/badlogic/gdx/tools/particleeditor/GradientPanel.java
@@ -243,7 +243,6 @@ class GradientPanel extends EditorPanel {
 							colors.add(i, colors.get(i - 1));
 							dragIndex = selectedIndex = i;
 							handleSelected(colors.get(selectedIndex));
-							updateColor();
 							repaint();
 							break;
 						}
@@ -257,7 +256,6 @@ class GradientPanel extends EditorPanel {
 					percent = Math.max(percent, percentages.get(dragIndex - 1) + 0.01f);
 					percent = Math.min(percent, percentages.get(dragIndex + 1) - 0.01f);
 					percentages.set(dragIndex, percent);
-					updateColor();
 					repaint();
 				}
 			});
diff --git a/gdx/jni/build-ios32.xml b/gdx/jni/build-ios32.xml
index f3285bf..13fb8d2 100755
--- a/gdx/jni/build-ios32.xml
+++ b/gdx/jni/build-ios32.xml
@@ -12,9 +12,9 @@
 	<!-- the compilerPrefix for the C & C++ compilers -->
 	<property name="compilerPrefix" value=""/>	
 	<property name="iphoneos-platform" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin"/>
-	<property name="iphoneos-sdk" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.2.sdk/"/>
+	<property name="iphoneos-sdk" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.1.sdk/"/>
 	<property name="iphonesimulator-platform" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin"/>
-	<property name="iphonesimulator-sdk" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.2.sdk"/>
+	<property name="iphonesimulator-sdk" value="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator8.1.sdk"/>
 	
 	<!-- define gcc compiler, options and files to compile -->
 	<property name="gcc" value="/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang"/>	
diff --git a/gdx/jni/com.badlogic.gdx.math.Matrix4.cpp b/gdx/jni/com.badlogic.gdx.math.Matrix4.cpp
index 2d5afe7..95312c5 100644
--- a/gdx/jni/com.badlogic.gdx.math.Matrix4.cpp
+++ b/gdx/jni/com.badlogic.gdx.math.Matrix4.cpp
@@ -1,6 +1,6 @@
 #include <com.badlogic.gdx.math.Matrix4.h>
 
-//@line:1148
+//@line:1152
 
 	#include <memory.h>
 	#include <stdio.h>
@@ -145,7 +145,7 @@
 	float* matb = (float*)env->GetPrimitiveArrayCritical(obj_matb, 0);
 
 
-//@line:1294
+//@line:1298
 
 		matrix4_mul(mata, matb);
 	
@@ -159,7 +159,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_math_Matrix4_mulVec___3F_3F(JNIEnv*
 	float* vec = (float*)env->GetPrimitiveArrayCritical(obj_vec, 0);
 
 
-//@line:1304
+//@line:1308
 
 		matrix4_mulVec(mat, vec);
 	
@@ -173,7 +173,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_math_Matrix4_mulVec___3F_3FIII(JNIE
 	float* vecs = (float*)env->GetPrimitiveArrayCritical(obj_vecs, 0);
 
 
-//@line:1319
+//@line:1323
 
 		float* vecPtr = vecs + offset;
 		for(int i = 0; i < numVecs; i++) {
@@ -191,7 +191,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_math_Matrix4_prj___3F_3F(JNIEnv* en
 	float* vec = (float*)env->GetPrimitiveArrayCritical(obj_vec, 0);
 
 
-//@line:1333
+//@line:1337
 
 		matrix4_proj(mat, vec);
 	
@@ -205,7 +205,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_math_Matrix4_prj___3F_3FIII(JNIEnv*
 	float* vecs = (float*)env->GetPrimitiveArrayCritical(obj_vecs, 0);
 
 
-//@line:1348
+//@line:1352
 
 		float* vecPtr = vecs + offset;
 		for(int i = 0; i < numVecs; i++) {
@@ -223,7 +223,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_math_Matrix4_rot___3F_3F(JNIEnv* en
 	float* vec = (float*)env->GetPrimitiveArrayCritical(obj_vec, 0);
 
 
-//@line:1362
+//@line:1366
 
 		matrix4_rot(mat, vec);
 	
@@ -237,7 +237,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_math_Matrix4_rot___3F_3FIII(JNIEnv*
 	float* vecs = (float*)env->GetPrimitiveArrayCritical(obj_vecs, 0);
 
 
-//@line:1377
+//@line:1381
 
 		float* vecPtr = vecs + offset;
 		for(int i = 0; i < numVecs; i++) {
@@ -253,7 +253,7 @@ JNIEXPORT void JNICALL Java_com_badlogic_gdx_math_Matrix4_rot___3F_3FIII(JNIEnv*
 static inline jboolean wrapped_Java_com_badlogic_gdx_math_Matrix4_inv
 (JNIEnv* env, jclass clazz, jfloatArray obj_values, float* values) {
 
-//@line:1389
+//@line:1393
 
 		return matrix4_inv(values);
 	
@@ -272,7 +272,7 @@ JNIEXPORT jboolean JNICALL Java_com_badlogic_gdx_math_Matrix4_inv(JNIEnv* env, j
 static inline jfloat wrapped_Java_com_badlogic_gdx_math_Matrix4_det
 (JNIEnv* env, jclass clazz, jfloatArray obj_values, float* values) {
 
-//@line:1397
+//@line:1401
 
 		return matrix4_det(values);
 	
diff --git a/gdx/jni/maven/pom.xml b/gdx/jni/maven/pom.xml
index 1f9584e..a06008e 100644
--- a/gdx/jni/maven/pom.xml
+++ b/gdx/jni/maven/pom.xml
@@ -4,7 +4,7 @@
     <parent>
         <groupId>com.badlogicgames.gdx</groupId>
         <artifactId>gdx-parent</artifactId>
-        <version>1.5.6-SNAPSHOT</version>
+        <version>1.5.5-SNAPSHOT</version>
         <relativePath>../../..</relativePath>
     </parent>
     
diff --git a/gdx/pom.xml b/gdx/pom.xml
index ee617ce..c1d2404 100644
--- a/gdx/pom.xml
+++ b/gdx/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>com.badlogicgames.gdx</groupId>
     <artifactId>gdx-parent</artifactId>
-    <version>1.5.6-SNAPSHOT</version>
+    <version>1.5.5-SNAPSHOT</version>
   </parent>
 
   <artifactId>gdx</artifactId>
diff --git a/gdx/src/com/badlogic/gdx.gwt.xml b/gdx/src/com/badlogic/gdx.gwt.xml
index 9be82db..c0b389e 100644
--- a/gdx/src/com/badlogic/gdx.gwt.xml
+++ b/gdx/src/com/badlogic/gdx.gwt.xml
@@ -91,7 +91,6 @@
 		<include name="graphics/g2d/BitmapFontCache.java"/>
 		<include name="graphics/g2d/CpuSpriteBatch.java"/>
 		<exclude name="graphics/g2d/Gdx2DPixmap.java"/> <!-- Reason: JNI -->
-		<include name="graphics/g2d/GlyphLayout.java"/>
 		<include name="graphics/g2d/NinePatch.java"/>
 		<include name="graphics/g2d/ParticleEffect.java"/> <!-- Emulated: Not supporting save -->
 		<include name="graphics/g2d/ParticleEffectPool.java"/>
@@ -214,6 +213,8 @@
 		<include name="graphics/glutils/FloatFrameBuffer.java"/>
 		<include name="graphics/glutils/FloatTextureData.java"/>
 		<include name="graphics/glutils/FrameBuffer.java"/>
+		<include name="graphics/glutils/FrameBufferCubemap.java"/>
+		<include name="graphics/glutils/GLFrameBuffer.java"/>
 		<include name="graphics/glutils/ImmediateModeRenderer.java"/>
 		<include name="graphics/glutils/ImmediateModeRenderer10.java"/>
 		<include name="graphics/glutils/ImmediateModeRenderer20.java"/>
@@ -229,7 +230,6 @@
 		<include name="graphics/glutils/VertexArray.java"/> <!-- Emulated -->
 		<include name="graphics/glutils/VertexBufferObject.java"/> <!-- Emulated -->
 		<include name="graphics/glutils/VertexBufferObjectSubData.java"/>
-		<include name="graphics/glutils/VertexBufferObjectWithVAO.java"/> <!-- Emulated -->
 		<include name="graphics/glutils/VertexData.java"/>
 
 	<!-- graphics/profiling -->
diff --git a/gdx/src/com/badlogic/gdx/Version.java b/gdx/src/com/badlogic/gdx/Version.java
index 3cba522..33171ad 100644
--- a/gdx/src/com/badlogic/gdx/Version.java
+++ b/gdx/src/com/badlogic/gdx/Version.java
@@ -23,7 +23,7 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
  * @author mzechner */
 public class Version {
 	/** the current version of libgdx as a String in the major.minor.revision format **/
-	public static final String VERSION = "1.5.6";
+	public static final String VERSION = "1.5.5";
 
 	/** the current major version of libgdx **/
 	public static final int MAJOR;
diff --git a/gdx/src/com/badlogic/gdx/assets/AssetManager.java b/gdx/src/com/badlogic/gdx/assets/AssetManager.java
index 9a1731d..e211464 100644
--- a/gdx/src/com/badlogic/gdx/assets/AssetManager.java
+++ b/gdx/src/com/badlogic/gdx/assets/AssetManager.java
@@ -151,17 +151,6 @@ public class AssetManager implements Disposable {
 	/** Removes the asset and all its dependencies, if they are not used by other assets.
 	 * @param fileName the file name */
 	public synchronized void unload (String fileName) {
-		// check if it's currently processed (and the first element in the stack, thus not a dependency)
-		// and cancel if necessary
-		if (tasks.size() > 0) {
-			AssetLoadingTask currAsset = tasks.firstElement();
-			if (currAsset.assetDesc.fileName.equals(fileName)) {
-				currAsset.cancel = true;
-				log.debug("Unload (from tasks): " + fileName);
-				return;
-			}
-		}
-
 		// check if it's in the queue
 		int foundIndex = -1;
 		for (int i = 0; i < loadQueue.size; i++) {
@@ -177,6 +166,17 @@ public class AssetManager implements Disposable {
 			return;
 		}
 
+		// check if it's currently processed (and the first element in the stack, thus not a dependency)
+		// and cancel if necessary
+		if (tasks.size() > 0) {
+			AssetLoadingTask currAsset = tasks.firstElement();
+			if (currAsset.assetDesc.fileName.equals(fileName)) {
+				currAsset.cancel = true;
+				log.debug("Unload (from tasks): " + fileName);
+				return;
+			}
+		}
+
 		// get the asset and its type
 		Class type = assetTypes.get(fileName);
 		if (type == null) throw new GdxRuntimeException("Asset not loaded: " + fileName);
@@ -470,30 +470,34 @@ public class AssetManager implements Disposable {
 	}
 
 	/** Updates the current task on the top of the task stack.
-	 * @return true if the asset is loaded or the task was cancelled. */
+	 * @return true if the asset is loaded. */
 	private boolean updateTask () {
 		AssetLoadingTask task = tasks.peek();
-		// if the task has been cancelled or has finished loading
-		if (task.cancel || task.update()) {
+		// if the task has finished loading
+		if (task.update()) {
+			addAsset(task.assetDesc.fileName, task.assetDesc.type, task.getAsset());
+
 			// increase the number of loaded assets and pop the task from the stack
 			if (tasks.size() == 1) loaded++;
 			tasks.pop();
 
-			if (task.cancel) return true;
-
-			addAsset(task.assetDesc.fileName, task.assetDesc.type, task.getAsset());
+			// remove the asset if it was canceled.
+			if (task.cancel) {
+				unload(task.assetDesc.fileName);
+			} else {
+				// otherwise, if a listener was found in the parameter invoke it
+				if (task.assetDesc.params != null && task.assetDesc.params.loadedCallback != null) {
+					task.assetDesc.params.loadedCallback.finishedLoading(this, task.assetDesc.fileName, task.assetDesc.type);
+				}
 
-			// otherwise, if a listener was found in the parameter invoke it
-			if (task.assetDesc.params != null && task.assetDesc.params.loadedCallback != null) {
-				task.assetDesc.params.loadedCallback.finishedLoading(this, task.assetDesc.fileName, task.assetDesc.type);
+				long endTime = TimeUtils.nanoTime();
+				log.debug("Loaded: " + (endTime - task.startTime) / 1000000f + "ms " + task.assetDesc);
 			}
 
-			long endTime = TimeUtils.nanoTime();
-			log.debug("Loaded: " + (endTime - task.startTime) / 1000000f + "ms " + task.assetDesc);
-
 			return true;
+		} else {
+			return false;
 		}
-		return false;
 	}
 
 	private void incrementRefCountedDependencies (String parent) {
@@ -565,7 +569,7 @@ public class AssetManager implements Disposable {
 
 	/** @return the number of currently queued assets */
 	public synchronized int getQueuedAssets () {
-		return loadQueue.size + tasks.size();
+		return loadQueue.size + (tasks.size());
 	}
 
 	/** @return the progress in percent of completion. */
diff --git a/gdx/src/com/badlogic/gdx/assets/loaders/BitmapFontLoader.java b/gdx/src/com/badlogic/gdx/assets/loaders/BitmapFontLoader.java
index b738b53..8e4e618 100644
--- a/gdx/src/com/badlogic/gdx/assets/loaders/BitmapFontLoader.java
+++ b/gdx/src/com/badlogic/gdx/assets/loaders/BitmapFontLoader.java
@@ -86,14 +86,12 @@ public class BitmapFontLoader extends AsynchronousAssetLoader<BitmapFont, Bitmap
 			String name = file.sibling(data.imagePaths[0]).nameWithoutExtension().toString();
 			AtlasRegion region = atlas.findRegion(name);
 
-			if (region == null)
-				throw new GdxRuntimeException("Could not find font region " + name + " in atlas " + parameter.atlasName);
+			if (region == null) throw new GdxRuntimeException("Could not find font region " + name + " in atlas " + parameter.atlasName);
 			return new BitmapFont(file, region);
 		} else {
-			int n = data.getImagePaths().length;
-			Array<TextureRegion> regs = new Array(n);
-			for (int i = 0; i < n; i++) {
-				regs.add(new TextureRegion(manager.get(data.getImagePath(i), Texture.class)));
+			TextureRegion[] regs = new TextureRegion[data.getImagePaths().length];
+			for (int i = 0; i < regs.length; i++) {
+				regs[i] = new TextureRegion(manager.get(data.getImagePath(i), Texture.class));
 			}
 			return new BitmapFont(data, regs, true);
 		}
diff --git a/gdx/src/com/badlogic/gdx/assets/loaders/resolvers/ClasspathFileHandleResolver b/gdx/src/com/badlogic/gdx/assets/loaders/resolvers/ClasspathFileHandleResolver
new file mode 100644
index 0000000..eb39c55
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/assets/loaders/resolvers/ClasspathFileHandleResolver
@@ -0,0 +1,28 @@
+/*******************************************************************************
+ * Copyright 2015 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.assets.loaders.resolvers;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.assets.loaders.FileHandleResolver;
+import com.badlogic.gdx.files.FileHandle;
+
+public class ClasspathFileHandleResolver implements FileHandleResolver {
+	@Override
+	public FileHandle resolve (String fileName) {
+		return Gdx.files.classpath(fileName);
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/assets/loaders/resolvers/ClasspathFileHandleResolver.java b/gdx/src/com/badlogic/gdx/assets/loaders/resolvers/ClasspathFileHandleResolver.java
deleted file mode 100644
index eb39c55..0000000
--- a/gdx/src/com/badlogic/gdx/assets/loaders/resolvers/ClasspathFileHandleResolver.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*******************************************************************************
- * Copyright 2015 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.assets.loaders.resolvers;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.assets.loaders.FileHandleResolver;
-import com.badlogic.gdx.files.FileHandle;
-
-public class ClasspathFileHandleResolver implements FileHandleResolver {
-	@Override
-	public FileHandle resolve (String fileName) {
-		return Gdx.files.classpath(fileName);
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/files/FileHandle.java b/gdx/src/com/badlogic/gdx/files/FileHandle.java
index 4c6633e..c32e531 100644
--- a/gdx/src/com/badlogic/gdx/files/FileHandle.java
+++ b/gdx/src/com/badlogic/gdx/files/FileHandle.java
@@ -32,7 +32,6 @@ import java.io.OutputStreamWriter;
 import java.io.Reader;
 import java.io.UnsupportedEncodingException;
 import java.io.Writer;
-import java.nio.ByteBuffer;
 
 import com.badlogic.gdx.Files;
 import com.badlogic.gdx.Files.FileType;
@@ -292,7 +291,7 @@ public class FileHandle {
 		OutputStream output = null;
 		try {
 			output = write(append);
-			StreamUtils.copyStream(input, output);
+			StreamUtils.copyStream(input, output, 4096);
 		} catch (Exception ex) {
 			throw new GdxRuntimeException("Error stream writing to file: " + file + " (" + type + ")", ex);
 		} finally {
diff --git a/gdx/src/com/badlogic/gdx/graphics/Color.java b/gdx/src/com/badlogic/gdx/graphics/Color.java
index e5ce95b..a7a6300 100644
--- a/gdx/src/com/badlogic/gdx/graphics/Color.java
+++ b/gdx/src/com/badlogic/gdx/graphics/Color.java
@@ -43,6 +43,8 @@ public class Color {
 	public static final Color TEAL = new Color(0, 0.5f, 0.5f, 1);
 	public static final Color NAVY = new Color(0, 0, 0.5f, 1);
 
+	@Deprecated public static Color tmp = new Color();
+
 	/** the red, green, blue and alpha components **/
 	public float r, g, b, a;
 
@@ -456,6 +458,13 @@ public class Color {
 		color.b = ((value & 0x000000ff)) / 255f;
 	}
 
+	/** Returns a temporary copy of this color. This is not thread safe, do not save a reference to this instance.
+	 * 
+	 * @return a temporary copy of this color */
+	public Color tmp () {
+		return tmp.set(this);
+	}
+
 	/** @return a copy of this color */
 	public Color cpy () {
 		return new Color(this);
diff --git a/gdx/src/com/badlogic/gdx/graphics/Cubemap.java b/gdx/src/com/badlogic/gdx/graphics/Cubemap.java
index 435bcf4..f518262 100644
--- a/gdx/src/com/badlogic/gdx/graphics/Cubemap.java
+++ b/gdx/src/com/badlogic/gdx/graphics/Cubemap.java
@@ -1,12 +1,12 @@
 /*******************************************************************************
  * Copyright 2011 See AUTHORS file.
- * 
+ *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *   http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -31,6 +31,7 @@ import com.badlogic.gdx.graphics.Texture.TextureFilter;
 import com.badlogic.gdx.graphics.Texture.TextureWrap;
 import com.badlogic.gdx.graphics.glutils.FacedCubemapData;
 import com.badlogic.gdx.graphics.glutils.PixmapTextureData;
+import com.badlogic.gdx.math.Vector3;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 
@@ -43,32 +44,49 @@ public class Cubemap extends GLTexture {
 	/** Enum to identify each side of a Cubemap */
 	public enum CubemapSide {
 		/** The positive X and first side of the cubemap */
-		PositiveX(0, GL20.GL_TEXTURE_CUBE_MAP_POSITIVE_X),
+		PositiveX(0, GL20.GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, -1, 0, 1, 0, 0),
 		/** The negative X and second side of the cubemap */
-		NegativeX(1, GL20.GL_TEXTURE_CUBE_MAP_NEGATIVE_X),
+		NegativeX(1, GL20.GL_TEXTURE_CUBE_MAP_NEGATIVE_X, 0, -1, 0, -1, 0, 0),
 		/** The positive Y and third side of the cubemap */
-		PositiveY(2, GL20.GL_TEXTURE_CUBE_MAP_POSITIVE_Y),
+		PositiveY(2, GL20.GL_TEXTURE_CUBE_MAP_POSITIVE_Y, 0, 0, 1, 0, 1, 0),
 		/** The negative Y and fourth side of the cubemap */
-		NegativeY(3, GL20.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y),
+		NegativeY(3, GL20.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, 0, -1, 0, -1, 0),
 		/** The positive Z and fifth side of the cubemap */
-		PositiveZ(4, GL20.GL_TEXTURE_CUBE_MAP_POSITIVE_Z),
+		PositiveZ(4, GL20.GL_TEXTURE_CUBE_MAP_POSITIVE_Z, 0, -1, 0, 0, 0, 1),
 		/** The negative Z and sixth side of the cubemap */
-		NegativeZ(5, GL20.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z);
+		NegativeZ(5, GL20.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, -1, 0, 0, 0, -1);
 
 		/** The zero based index of the side in the cubemap */
 		public final int index;
 		/** The OpenGL target (used for glTexImage2D) of the side. */
 		public final int glEnum;
+		/** The up vector to target the side. */
+		public final Vector3 up;
+		/** The direction vector to target the side. */
+		public final Vector3 direction;
 
-		CubemapSide (int index, int glEnum) {
+		CubemapSide (int index, int glEnum, float upX, float upY, float upZ,
+			float directionX, float directionY, float directionZ) {
 			this.index = index;
 			this.glEnum = glEnum;
+			this.up = new Vector3(upX, upY, upZ);
+			this.direction = new Vector3(directionX, directionY, directionZ);
 		}
 
 		/** @return The OpenGL target (used for glTexImage2D) of the side. */
 		public int getGLEnum () {
 			return glEnum;
 		}
+
+		/** @return The up vector of the side. */
+		public Vector3 getUp (Vector3 out) {
+			return out.set(up);
+		}
+
+		/** @return The direction vector of the side. */
+		public Vector3 getDirection (Vector3 out) {
+			return out.set(direction);
+		}
 	}
 
 	protected CubemapData data;
@@ -89,9 +107,9 @@ public class Cubemap extends GLTexture {
 	/** Construct a Cubemap with the specified texture files for the sides, optionally generating mipmaps. */
 	public Cubemap (FileHandle positiveX, FileHandle negativeX, FileHandle positiveY, FileHandle negativeY, FileHandle positiveZ,
 		FileHandle negativeZ, boolean useMipMaps) {
-		this(TextureData.Factory.loadFromFile(positiveX, useMipMaps), TextureData.Factory.loadFromFile(negativeX, useMipMaps),
-			TextureData.Factory.loadFromFile(positiveY, useMipMaps), TextureData.Factory.loadFromFile(negativeY, useMipMaps),
-			TextureData.Factory.loadFromFile(positiveZ, useMipMaps), TextureData.Factory.loadFromFile(negativeZ, useMipMaps));
+		this(createTextureData(positiveX, useMipMaps), createTextureData(negativeX, useMipMaps), createTextureData(positiveY,
+			useMipMaps), createTextureData(negativeY, useMipMaps), createTextureData(positiveZ, useMipMaps), createTextureData(
+				negativeZ, useMipMaps));
 	}
 
 	/** Construct a Cubemap with the specified {@link Pixmap}s for the sides, does not generate mipmaps. */
@@ -104,9 +122,9 @@ public class Cubemap extends GLTexture {
 		boolean useMipMaps) {
 		this(positiveX == null ? null : new PixmapTextureData(positiveX, null, useMipMaps, false), negativeX == null ? null
 			: new PixmapTextureData(negativeX, null, useMipMaps, false), positiveY == null ? null : new PixmapTextureData(positiveY,
-			null, useMipMaps, false), negativeY == null ? null : new PixmapTextureData(negativeY, null, useMipMaps, false),
-			positiveZ == null ? null : new PixmapTextureData(positiveZ, null, useMipMaps, false), negativeZ == null ? null
-				: new PixmapTextureData(negativeZ, null, useMipMaps, false));
+				null, useMipMaps, false), negativeY == null ? null : new PixmapTextureData(negativeY, null, useMipMaps, false),
+					positiveZ == null ? null : new PixmapTextureData(positiveZ, null, useMipMaps, false), negativeZ == null ? null
+						: new PixmapTextureData(negativeZ, null, useMipMaps, false));
 	}
 
 	/** Construct a Cubemap with {@link Pixmap}s for each side of the specified size. */
@@ -151,7 +169,7 @@ public class Cubemap extends GLTexture {
 	@Override
 	protected void reload () {
 		if (!isManaged()) throw new GdxRuntimeException("Tried to reload an unmanaged Cubemap");
-		glHandle = Gdx.gl.glGenTexture();
+		glHandle = createGLHandle();
 		load(data);
 	}
 
@@ -171,6 +189,7 @@ public class Cubemap extends GLTexture {
 	}
 
 	/** Disposes all resources associated with the cubemap */
+	@Override
 	public void dispose () {
 		// this is a hack. reason: we have to set the glHandle to 0 for textures that are
 		// reloaded through the asset manager as we first remove (and thus dispose) the texture
@@ -243,7 +262,7 @@ public class Cubemap extends GLTexture {
 
 					// unload the c, create a new gl handle then reload it.
 					assetManager.unload(fileName);
-					cubemap.glHandle = Gdx.gl.glGenTexture();
+					cubemap.glHandle = GLTexture.createGLHandle();
 					assetManager.load(fileName, Cubemap.class, params);
 				}
 			}
diff --git a/gdx/src/com/badlogic/gdx/graphics/GL20.java b/gdx/src/com/badlogic/gdx/graphics/GL20.java
index b7866b5..17eb49e 100644
--- a/gdx/src/com/badlogic/gdx/graphics/GL20.java
+++ b/gdx/src/com/badlogic/gdx/graphics/GL20.java
@@ -664,11 +664,6 @@ public interface GL20 {
 
 	public void glVertexAttrib4fv (int indx, FloatBuffer values);
 
-	/**
-	 * In OpenGl core profiles (3.1+), passing a pointer to client memory is not valid.
-	 * In 3.0 and later, use the other version of this function instead, pass a zero-based
-	 * offset which references the buffer currently bound to GL_ARRAY_BUFFER.
-	 */
 	public void glVertexAttribPointer (int indx, int size, int type, boolean normalized, int stride, Buffer ptr);
 
 	public void glVertexAttribPointer (int indx, int size, int type, boolean normalized, int stride, int ptr);
diff --git a/gdx/src/com/badlogic/gdx/graphics/GL30.java b/gdx/src/com/badlogic/gdx/graphics/GL30.java
index 0a360ee..df17aa8 100644
--- a/gdx/src/com/badlogic/gdx/graphics/GL30.java
+++ b/gdx/src/com/badlogic/gdx/graphics/GL30.java
@@ -19,8 +19,6 @@
 
 package com.badlogic.gdx.graphics;
 
-import java.nio.Buffer;
-
 /** OpenGL ES 3.0 */
 public interface GL30 extends GL20 {
 	public final int GL_READ_BUFFER = 0x0C02;
@@ -1397,12 +1395,4 @@ public interface GL30 extends GL20 {
 // java.nio.IntBuffer params
 // );
 
-	@Override
-	@Deprecated
-	/**
-	 * In OpenGl core profiles (3.1+), passing a pointer to client memory is not valid.
-	 * Use the other version of this function instead, pass a zero-based offset which references
-	 * the buffer currently bound to GL_ARRAY_BUFFER.
-	 */
-	void glVertexAttribPointer(int indx, int size, int type, boolean normalized, int stride, Buffer ptr);
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/GLTexture.java b/gdx/src/com/badlogic/gdx/graphics/GLTexture.java
index 49f85e7..0d27d1f 100644
--- a/gdx/src/com/badlogic/gdx/graphics/GLTexture.java
+++ b/gdx/src/com/badlogic/gdx/graphics/GLTexture.java
@@ -17,7 +17,9 @@
 package com.badlogic.gdx.graphics;
 
 import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.files.FileHandle;
 import com.badlogic.gdx.graphics.Pixmap.Blending;
+import com.badlogic.gdx.graphics.Pixmap.Format;
 import com.badlogic.gdx.graphics.Texture.TextureFilter;
 import com.badlogic.gdx.graphics.Texture.TextureWrap;
 import com.badlogic.gdx.graphics.TextureData.TextureDataType;
@@ -177,6 +179,24 @@ public abstract class GLTexture implements Disposable {
 		delete();
 	}
 
+	/** @deprecated Use {@link TextureData.Factory#loadFromFile(FileHandle, Format, boolean)} instead. */
+	@Deprecated
+	protected static TextureData createTextureData (FileHandle file, Format format, boolean useMipMaps) {
+		return TextureData.Factory.loadFromFile(file, format, useMipMaps);
+	}
+
+	/** @deprecated Use {@link TextureData.Factory#loadFromFile(FileHandle, boolean)} instead. */
+	@Deprecated
+	protected static TextureData createTextureData (FileHandle file, boolean useMipMaps) {
+		return createTextureData(file, null, useMipMaps);
+	}
+
+	/** @deprecated Use {@link GL20#glGenTexture()} instead. */
+	@Deprecated
+	protected static int createGLHandle () {
+		return Gdx.gl.glGenTexture ();
+	}
+	
 	protected static void uploadImageData (int target, TextureData data) {
 		uploadImageData(target, data, 0);
 	}
diff --git a/gdx/src/com/badlogic/gdx/graphics/Mesh.java b/gdx/src/com/badlogic/gdx/graphics/Mesh.java
index 31bd521..6046f42 100644
--- a/gdx/src/com/badlogic/gdx/graphics/Mesh.java
+++ b/gdx/src/com/badlogic/gdx/graphics/Mesh.java
@@ -32,7 +32,6 @@ import com.badlogic.gdx.graphics.glutils.ShaderProgram;
 import com.badlogic.gdx.graphics.glutils.VertexArray;
 import com.badlogic.gdx.graphics.glutils.VertexBufferObject;
 import com.badlogic.gdx.graphics.glutils.VertexBufferObjectSubData;
-import com.badlogic.gdx.graphics.glutils.VertexBufferObjectWithVAO;
 import com.badlogic.gdx.graphics.glutils.VertexData;
 import com.badlogic.gdx.math.Matrix3;
 import com.badlogic.gdx.math.Matrix4;
@@ -66,7 +65,7 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
  * @author mzechner, Dave Clayton <contact@redskyforge.com>, Xoppa */
 public class Mesh implements Disposable {
 	public enum VertexDataType {
-		VertexArray, VertexBufferObject, VertexBufferObjectSubData, VertexBufferObjectWithVAO
+		VertexArray, VertexBufferObject, VertexBufferObjectSubData,
 	}
 
 	/** list of all meshes **/
@@ -93,7 +92,7 @@ public class Mesh implements Disposable {
 	 * @param attributes the {@link VertexAttribute}s. Each vertex attribute defines one property of a vertex such as position,
 	 *           normal or texture coordinate */
 	public Mesh (boolean isStatic, int maxVertices, int maxIndices, VertexAttribute... attributes) {
-		vertices = makeVertexBuffer(isStatic, maxVertices, new VertexAttributes(attributes));
+		vertices = new VertexBufferObject(isStatic, maxVertices, attributes);
 		indices = new IndexBufferObject(isStatic, maxIndices);
 		isVertexArray = false;
 
@@ -108,7 +107,7 @@ public class Mesh implements Disposable {
 	 * @param attributes the {@link VertexAttributes}. Each vertex attribute defines one property of a vertex such as position,
 	 *           normal or texture coordinate */
 	public Mesh (boolean isStatic, int maxVertices, int maxIndices, VertexAttributes attributes) {
-		vertices = makeVertexBuffer(isStatic, maxVertices, attributes);
+		vertices = new VertexBufferObject(isStatic, maxVertices, attributes);
 		indices = new IndexBufferObject(isStatic, maxIndices);
 		isVertexArray = false;
 
@@ -126,21 +125,13 @@ public class Mesh implements Disposable {
 	 * 
 	 * @author Jaroslaw Wisniewski <j.wisniewski@appsisle.com> **/
 	public Mesh (boolean staticVertices, boolean staticIndices, int maxVertices, int maxIndices, VertexAttributes attributes) {
-		vertices = makeVertexBuffer(staticVertices, maxVertices, attributes);
+		vertices = new VertexBufferObject(staticVertices, maxVertices, attributes);
 		indices = new IndexBufferObject(staticIndices, maxIndices);
 		isVertexArray = false;
 
 		addManagedMesh(Gdx.app, this);
 	}
 
-	private VertexData makeVertexBuffer(boolean isStatic, int maxVertices, VertexAttributes vertexAttributes) {
-		if(Gdx.gl30 != null) {
-			return new VertexBufferObjectWithVAO(isStatic, maxVertices, vertexAttributes);
-		} else {
-			return new VertexBufferObject(isStatic, maxVertices, vertexAttributes);
-		}
-	}
-
 	/** Creates a new Mesh with the given attributes. This is an expert method with no error checking. Use at your own risk.
 	 * 
 	 * @param type the {@link VertexDataType} to be used, VBO or VA.
@@ -150,33 +141,116 @@ public class Mesh implements Disposable {
 	 * @param attributes the {@link VertexAttribute}s. Each vertex attribute defines one property of a vertex such as position,
 	 *           normal or texture coordinate */
 	public Mesh (VertexDataType type, boolean isStatic, int maxVertices, int maxIndices, VertexAttribute... attributes) {
-		switch(type) {
-			case VertexBufferObject:
-				vertices = new VertexBufferObject(isStatic, maxVertices, attributes);
-				indices = new IndexBufferObject(isStatic, maxIndices);
-				isVertexArray = false;
-				break;
-			case VertexBufferObjectSubData:
-				vertices = new VertexBufferObjectSubData(isStatic, maxVertices, attributes);
-				indices = new IndexBufferObjectSubData(isStatic, maxIndices);
-				isVertexArray = false;
-				break;
-			case VertexBufferObjectWithVAO:
-				vertices = new VertexBufferObjectWithVAO(isStatic, maxVertices, attributes);
-				indices = new IndexBufferObjectSubData(isStatic, maxIndices);
-				isVertexArray = false;
-				break;
-			case VertexArray:
-			default:
-				vertices = new VertexArray(maxVertices, attributes);
-				indices = new IndexArray(maxIndices);
-				isVertexArray = true;
-				break;
+		if (type == VertexDataType.VertexBufferObject) {
+			vertices = new VertexBufferObject(isStatic, maxVertices, attributes);
+			indices = new IndexBufferObject(isStatic, maxIndices);
+			isVertexArray = false;
+		} else if (type == VertexDataType.VertexBufferObjectSubData) {
+			vertices = new VertexBufferObjectSubData(isStatic, maxVertices, attributes);
+			indices = new IndexBufferObjectSubData(isStatic, maxIndices);
+			isVertexArray = false;
+		} else {
+			vertices = new VertexArray(maxVertices, attributes);
+			indices = new IndexArray(maxIndices);
+			isVertexArray = true;
 		}
-
 		addManagedMesh(Gdx.app, this);
 	}
 
+	/** Create a new Mesh that is a combination of transformations of the supplied base mesh. Not all primitive types, like line
+	 * strip and triangle strip, can be combined.
+	 * @param isStatic whether this mesh is static or not. Allows for internal optimizations.
+	 * @param transformations the transformations to apply to the meshes
+	 * @return the combined mesh */
+	public static Mesh create (boolean isStatic, final Mesh base, final Matrix4[] transformations) {
+		final VertexAttribute posAttr = base.getVertexAttribute(Usage.Position);
+		final int offset = posAttr.offset / 4;
+		final int numComponents = posAttr.numComponents;
+		final int numVertices = base.getNumVertices();
+		final int vertexSize = base.getVertexSize() / 4;
+		final int baseSize = numVertices * vertexSize;
+		final int numIndices = base.getNumIndices();
+
+		final float vertices[] = new float[numVertices * vertexSize * transformations.length];
+		final short indices[] = new short[numIndices * transformations.length];
+
+		base.getIndices(indices);
+
+		for (int i = 0; i < transformations.length; i++) {
+			base.getVertices(0, baseSize, vertices, baseSize * i);
+			transform(transformations[i], vertices, vertexSize, offset, numComponents, numVertices * i, numVertices);
+			if (i > 0) for (int j = 0; j < numIndices; j++)
+				indices[(numIndices * i) + j] = (short)(indices[j] + (numVertices * i));
+		}
+
+		final Mesh result = new Mesh(isStatic, vertices.length / vertexSize, indices.length, base.getVertexAttributes());
+		result.setVertices(vertices);
+		result.setIndices(indices);
+		return result;
+	}
+
+	/** Create a new Mesh that is a combination of the supplied meshes. The meshes must have the same VertexAttributes signature.
+	 * Not all primitive types, like line strip and triangle strip, can be combined.
+	 * @param isStatic whether this mesh is static or not. Allows for internal optimizations.
+	 * @param meshes the meshes to combine
+	 * @return the combined mesh */
+	public static Mesh create (boolean isStatic, final Mesh[] meshes) {
+		return create(isStatic, meshes, null);
+	}
+
+	/** Create a new Mesh that is a combination of the supplied meshes. The meshes must have the same VertexAttributes signature. If
+	 * transformations is supplied, it must have the same length as meshes. Not all primitive types, like line strip and triangle
+	 * strip, can be combined.
+	 * @param isStatic whether this mesh is static or not. Allows for internal optimizations.
+	 * @param meshes the meshes to combine
+	 * @param transformations the transformations to apply to the meshes
+	 * @return the combined mesh */
+	public static Mesh create (boolean isStatic, final Mesh[] meshes, final Matrix4[] transformations) {
+		if (transformations != null && transformations.length < meshes.length)
+			throw new IllegalArgumentException("Not enough transformations specified");
+		final VertexAttributes attributes = meshes[0].getVertexAttributes();
+		int vertCount = meshes[0].getNumVertices();
+		int idxCount = meshes[0].getNumIndices();
+		for (int i = 1; i < meshes.length; i++) {
+			if (!meshes[i].getVertexAttributes().equals(attributes))
+				throw new IllegalArgumentException("Inconsistent VertexAttributes");
+			vertCount += meshes[i].getNumVertices();
+			idxCount += meshes[i].getNumIndices();
+		}
+		final VertexAttribute posAttr = meshes[0].getVertexAttribute(Usage.Position);
+		final int offset = posAttr.offset / 4;
+		final int numComponents = posAttr.numComponents;
+		final int vertexSize = attributes.vertexSize / 4;
+
+		final float vertices[] = new float[vertCount * vertexSize];
+		final short indices[] = new short[idxCount];
+
+		meshes[0].getVertices(vertices);
+		meshes[0].getIndices(indices);
+		int vcount = meshes[0].getNumVertices();
+		if (transformations != null) transform(transformations[0], vertices, vertexSize, offset, numComponents, 0, vcount);
+		int voffset = vcount;
+		int ioffset = meshes[0].getNumIndices();
+		for (int i = 1; i < meshes.length; i++) {
+			final Mesh mesh = meshes[i];
+			vcount = mesh.getNumVertices();
+			final int isize = mesh.getNumIndices();
+			mesh.getVertices(0, vcount * vertexSize, vertices, voffset * vertexSize);
+			if (transformations != null)
+				transform(transformations[i], vertices, vertexSize, offset, numComponents, voffset, vcount);
+			mesh.getIndices(indices, ioffset);
+			for (int j = 0; j < isize; j++)
+				indices[ioffset + j] = (short)(indices[ioffset + j] + voffset);
+			ioffset += isize;
+			voffset += vcount;
+		}
+
+		final Mesh result = new Mesh(isStatic, vertices.length / vertexSize, indices.length, attributes);
+		result.setVertices(vertices);
+		result.setIndices(indices);
+		return result;
+	}
+
 	/** Sets the vertices of this Mesh. The attributes are assumed to be given in float format.
 	 * 
 	 * @param vertices the vertices.
diff --git a/gdx/src/com/badlogic/gdx/graphics/Texture.java b/gdx/src/com/badlogic/gdx/graphics/Texture.java
index 4815c8e..aa75aad 100644
--- a/gdx/src/com/badlogic/gdx/graphics/Texture.java
+++ b/gdx/src/com/badlogic/gdx/graphics/Texture.java
@@ -16,9 +16,6 @@
 
 package com.badlogic.gdx.graphics;
 
-import java.util.HashMap;
-import java.util.Map;
-
 import com.badlogic.gdx.Application;
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.assets.AssetLoaderParameters.LoadedCallback;
@@ -27,10 +24,16 @@ import com.badlogic.gdx.assets.loaders.AssetLoader;
 import com.badlogic.gdx.assets.loaders.TextureLoader.TextureParameter;
 import com.badlogic.gdx.files.FileHandle;
 import com.badlogic.gdx.graphics.Pixmap.Format;
+import com.badlogic.gdx.graphics.glutils.ETC1TextureData;
+import com.badlogic.gdx.graphics.glutils.FileTextureData;
+import com.badlogic.gdx.graphics.glutils.KTXTextureData;
 import com.badlogic.gdx.graphics.glutils.PixmapTextureData;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 
+import java.util.HashMap;
+import java.util.Map;
+
 /** A Texture wraps a standard OpenGL ES texture.
  * <p>
  * A Texture can be managed. If the OpenGL context is lost all managed textures get invalidated. This happens when a user switches
@@ -97,7 +100,7 @@ public class Texture extends GLTexture {
 	}
 
 	public Texture (FileHandle file, Format format, boolean useMipMaps) {
-		this(TextureData.Factory.loadFromFile(file, format, useMipMaps));
+		this(createTextureData(file, format, useMipMaps));
 	}
 
 	public Texture (Pixmap pixmap) {
@@ -117,7 +120,7 @@ public class Texture extends GLTexture {
 	}
 
 	public Texture (TextureData data) {
-		super(GL20.GL_TEXTURE_2D, Gdx.gl.glGenTexture());
+		super(GL20.GL_TEXTURE_2D, createGLHandle());
 		load(data);
 		if (data.isManaged()) addManagedTexture(Gdx.app, this);
 	}
@@ -142,7 +145,7 @@ public class Texture extends GLTexture {
 	@Override
 	protected void reload () {
 		if (!isManaged()) throw new GdxRuntimeException("Tried to reload unmanaged Texture");
-		glHandle = Gdx.gl.glGenTexture();
+		glHandle = createGLHandle();
 		load(data);
 	}
 
@@ -258,7 +261,7 @@ public class Texture extends GLTexture {
 
 					// unload the texture, create a new gl handle then reload it.
 					assetManager.unload(fileName);
-					texture.glHandle = Gdx.gl.glGenTexture();
+					texture.glHandle = Texture.createGLHandle();
 					assetManager.load(fileName, Texture.class, params);
 				}
 			}
diff --git a/gdx/src/com/badlogic/gdx/graphics/VertexAttribute.java b/gdx/src/com/badlogic/gdx/graphics/VertexAttribute.java
index 928e6f0..298e632 100644
--- a/gdx/src/com/badlogic/gdx/graphics/VertexAttribute.java
+++ b/gdx/src/com/badlogic/gdx/graphics/VertexAttribute.java
@@ -89,13 +89,19 @@ public final class VertexAttribute {
 	public static VertexAttribute Normal () {
 		return new VertexAttribute(Usage.Normal, 3, ShaderProgram.NORMAL_ATTRIBUTE);
 	}
+
+	/** @deprecated use {@link #ColorPacked()} */
+	@Deprecated
+	public static VertexAttribute Color () {
+		return ColorPacked();
+	}
 	
 	public static VertexAttribute ColorPacked () {
 		return new VertexAttribute(Usage.ColorPacked, 4, GL20.GL_UNSIGNED_BYTE, true, ShaderProgram.COLOR_ATTRIBUTE);
 	}
 
 	public static VertexAttribute ColorUnpacked () {
-		return new VertexAttribute(Usage.ColorUnpacked, 4, GL20.GL_FLOAT, false, ShaderProgram.COLOR_ATTRIBUTE);
+		return new VertexAttribute(Usage.Color, 4, GL20.GL_FLOAT, false, ShaderProgram.COLOR_ATTRIBUTE);
 	}
 
 	public static VertexAttribute Tangent () {
diff --git a/gdx/src/com/badlogic/gdx/graphics/VertexAttributes.java b/gdx/src/com/badlogic/gdx/graphics/VertexAttributes.java
index 9464ff7..c36d907 100644
--- a/gdx/src/com/badlogic/gdx/graphics/VertexAttributes.java
+++ b/gdx/src/com/badlogic/gdx/graphics/VertexAttributes.java
@@ -24,13 +24,16 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
 /** Instances of this class specify the vertex attributes of a mesh. VertexAttributes are used by {@link Mesh} instances to define
  * its vertex structure. Vertex attributes have an order. The order is specified by the order they are added to this class.
  * 
- * @author mzechner, Xoppa */
-public final class VertexAttributes implements Iterable<VertexAttribute>, Comparable<VertexAttributes> {
+ * @author mzechner */
+public final class VertexAttributes implements Iterable<VertexAttribute> {
 	/** The usage of a vertex attribute.
 	 * 
 	 * @author mzechner */
 	public static final class Usage {
 		public static final int Position = 1;
+		/** @deprecated use {@link #ColorUnpacked} instead. */
+		@Deprecated
+		public static final int Color = 2;
 		public static final int ColorUnpacked = 2;
 		public static final int ColorPacked = 4;
 		public static final int Normal = 8;
@@ -127,24 +130,15 @@ public final class VertexAttributes implements Iterable<VertexAttribute>, Compar
 
 	@Override
 	public boolean equals (final Object obj) {
-		if (obj == this) return true;
 		if (!(obj instanceof VertexAttributes)) return false;
 		VertexAttributes other = (VertexAttributes)obj;
-		if (this.attributes.length != other.attributes.length) return false;
+		if (this.attributes.length != other.size()) return false;
 		for (int i = 0; i < attributes.length; i++) {
 			if (!attributes[i].equals(other.attributes[i])) return false;
 		}
 		return true;
 	}
 
-	@Override
-	public int hashCode () {
-		long result = 61 * attributes.length;
-		for (int i = 0; i < attributes.length; i++)
-			result = result * 61 + attributes[i].hashCode();
-		return (int)(result ^ (result >> 32));
-	}
-
 	/** Calculates a mask based on the contained {@link VertexAttribute} instances. The mask is a bit-wise or of each attributes
 	 * {@link VertexAttribute#usage}.
 	 * @return the mask */
@@ -160,24 +154,6 @@ public final class VertexAttributes implements Iterable<VertexAttribute>, Compar
 	}
 
 	@Override
-	public int compareTo (VertexAttributes o) {
-		if (attributes.length != o.attributes.length) return attributes.length - o.attributes.length;
-		final long m1 = getMask();
-		final long m2 = o.getMask();
-		if (m1 != m2) return m1 < m2 ? -1 : 1;
-		for (int i = attributes.length - 1; i >= 0; --i) {
-			final VertexAttribute va0 = attributes[i];
-			final VertexAttribute va1 = o.attributes[i];
-			if (va0.usage != va1.usage) return va0.usage - va1.usage;
-			if (va0.unit != va1.unit) return va0.unit - va1.unit;
-			if (va0.numComponents != va1.numComponents) return va0.numComponents - va1.numComponents;
-			if (va0.normalized != va1.normalized) return va0.normalized ? 1 : -1;
-			if (va0.type != va1.type) return va0.type - va1.type;
-		}
-		return 0;
-	}
-
-	@Override
 	public Iterator<VertexAttribute> iterator () {
 		if (iterable == null) iterable = new ReadonlyIterable<VertexAttribute>(attributes);
 		return iterable.iterator();
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFont.java b/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFont.java
index cebb2ba..866aba7 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFont.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFont.java
@@ -31,9 +31,7 @@ import com.badlogic.gdx.files.FileHandle;
 import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.graphics.Texture.TextureFilter;
-import com.badlogic.gdx.graphics.g2d.GlyphLayout.GlyphRun;
 import com.badlogic.gdx.graphics.g2d.TextureAtlas.AtlasRegion;
-import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.Disposable;
 import com.badlogic.gdx.utils.FloatArray;
 import com.badlogic.gdx.utils.GdxRuntimeException;
@@ -58,12 +56,18 @@ public class BitmapFont implements Disposable {
 	static private final int PAGE_SIZE = 1 << LOG2_PAGE_SIZE;
 	static private final int PAGES = 0x10000 / PAGE_SIZE;
 
+	public static final char[] xChars = {'x', 'e', 'a', 'o', 'n', 's', 'r', 'c', 'u', 'm', 'v', 'w', 'z'};
+	public static final char[] capChars = {'M', 'N', 'B', 'D', 'C', 'E', 'F', 'K', 'A', 'G', 'H', 'I', 'J', 'L', 'O', 'P', 'Q',
+		'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
+
 	final BitmapFontData data;
-	Array<TextureRegion> regions;
+	TextureRegion[] regions;
 	private final BitmapFontCache cache;
 	private boolean flipped;
 	private boolean integer;
 	private boolean ownsTexture;
+	boolean markupEnabled;
+	private char[] breakChars;
 
 	/** Creates a BitmapFont using the default 15pt Arial font included in the libgdx JAR file. This is convenient to easily display
 	 * text without bothering without generating a bitmap font yourself. */
@@ -140,33 +144,33 @@ public class BitmapFont implements Disposable {
 	 * manually with the TextureRegion[] constructor.
 	 * @param integer If true, rendering positions will be at integer values to avoid filtering artifacts. */
 	public BitmapFont (BitmapFontData data, TextureRegion region, boolean integer) {
-		this(data, region != null ? Array.with(region) : null, integer);
+		this(data, region != null ? new TextureRegion[] {region} : null, integer);
 	}
 
 	/** Constructs a new BitmapFont from the given {@link BitmapFontData} and array of {@link TextureRegion}. If the TextureRegion
 	 * is null or empty, the image path(s) will be read from the BitmapFontData. The dispose() method will not dispose the texture
 	 * of the region(s) if the regions array is != null and not empty.
 	 * @param integer If true, rendering positions will be at integer values to avoid filtering artifacts. */
-	public BitmapFont (BitmapFontData data, Array<TextureRegion> pageRegions, boolean integer) {
-		if (pageRegions == null || pageRegions.size == 0) {
+	public BitmapFont (BitmapFontData data, TextureRegion[] regions, boolean integer) {
+		if (regions == null || regions.length == 0) {
 			// Load each path.
-			int n = data.imagePaths.length;
-			regions = new Array(n);
-			for (int i = 0; i < n; i++) {
-				FileHandle file;
-				if (data.fontFile == null)
-					file = Gdx.files.internal(data.imagePaths[i]);
-				else
-					file = Gdx.files.getFileHandle(data.imagePaths[i], data.fontFile.type());
-				regions.add(new TextureRegion(new Texture(file, false)));
+			this.regions = new TextureRegion[data.imagePaths.length];
+			for (int i = 0; i < this.regions.length; i++) {
+				if (data.fontFile == null) {
+					this.regions[i] = new TextureRegion(new Texture(Gdx.files.internal(data.imagePaths[i]), false));
+				} else {
+					this.regions[i] = new TextureRegion(new Texture(Gdx.files.getFileHandle(data.imagePaths[i], data.fontFile.type()),
+						false));
+				}
 			}
 			ownsTexture = true;
 		} else {
-			regions = pageRegions;
+			this.regions = regions;
 			ownsTexture = false;
 		}
 
-		cache = new BitmapFontCache(this, integer);
+		cache = new BitmapFontCache(this);
+		cache.setUseIntegerPositions(integer);
 
 		this.flipped = data.flipped;
 		this.data = data;
@@ -180,66 +184,408 @@ public class BitmapFont implements Disposable {
 			for (Glyph glyph : page) {
 				if (glyph == null) continue;
 
-				TextureRegion region = regions.get(glyph.page);
+				TextureRegion region = regions[glyph.page];
+
 				if (region == null) {
 					// TODO: support null regions by parsing scaleW / scaleH ?
 					throw new IllegalArgumentException("BitmapFont texture region array cannot contain null elements.");
 				}
 
-				data.setGlyphRegion(glyph, region);
+				float invTexWidth = 1.0f / region.getTexture().getWidth();
+				float invTexHeight = 1.0f / region.getTexture().getHeight();
+
+				float offsetX = 0, offsetY = 0;
+				float u = region.u;
+				float v = region.v;
+				float regionWidth = region.getRegionWidth();
+				float regionHeight = region.getRegionHeight();
+				if (region instanceof AtlasRegion) {
+					// Compensate for whitespace stripped from left and top edges.
+					AtlasRegion atlasRegion = (AtlasRegion)region;
+					offsetX = atlasRegion.offsetX;
+					offsetY = atlasRegion.originalHeight - atlasRegion.packedHeight - atlasRegion.offsetY;
+				}
+
+				float x = glyph.srcX;
+				float x2 = glyph.srcX + glyph.width;
+				float y = glyph.srcY;
+				float y2 = glyph.srcY + glyph.height;
+
+				// Shift glyph for left and top edge stripped whitespace. Clip glyph for right and bottom edge stripped whitespace.
+				if (offsetX > 0) {
+					x -= offsetX;
+					if (x < 0) {
+						glyph.width += x;
+						glyph.xoffset -= x;
+						x = 0;
+					}
+					x2 -= offsetX;
+					if (x2 > regionWidth) {
+						glyph.width -= x2 - regionWidth;
+						x2 = regionWidth;
+					}
+				}
+				if (offsetY > 0) {
+					y -= offsetY;
+					if (y < 0) {
+						glyph.height += y;
+						y = 0;
+					}
+					y2 -= offsetY;
+					if (y2 > regionHeight) {
+						float amount = y2 - regionHeight;
+						glyph.height -= amount;
+						glyph.yoffset += amount;
+						y2 = regionHeight;
+					}
+				}
+
+				glyph.u = u + x * invTexWidth;
+				glyph.u2 = u + x2 * invTexWidth;
+				if (data.flipped) {
+					glyph.v = v + y * invTexHeight;
+					glyph.v2 = v + y2 * invTexHeight;
+				} else {
+					glyph.v2 = v + y * invTexHeight;
+					glyph.v = v + y2 * invTexHeight;
+				}
 			}
 		}
 	}
 
-	/** Draws text at the specified position.
-	 * @see BitmapFontCache#addText(CharSequence, float, float) */
-	public GlyphLayout draw (Batch batch, CharSequence str, float x, float y) {
+	/** Draws a string at the specified position.
+	 * @see BitmapFontCache#addText(CharSequence, float, float, int, int) */
+	public TextBounds draw (Batch batch, CharSequence str, float x, float y) {
 		cache.clear();
-		GlyphLayout layout = cache.addText(str, x, y);
+		TextBounds bounds = cache.addText(str, x, y, 0, str.length());
 		cache.draw(batch);
-		return layout;
+		return bounds;
 	}
 
-	/** Draws text at the specified position.
-	 * @see BitmapFontCache#addText(CharSequence, float, float, int, int, float, int, boolean) */
-	public GlyphLayout draw (Batch batch, CharSequence str, float x, float y, float targetWidth, int halign, boolean wrap) {
+	/** Draws a string at the specified position.
+	 * @see BitmapFontCache#addText(CharSequence, float, float, int, int) */
+	public TextBounds draw (Batch batch, CharSequence str, float x, float y, int start, int end) {
 		cache.clear();
-		GlyphLayout layout = cache.addText(str, x, y, targetWidth, halign, wrap);
+		TextBounds bounds = cache.addText(str, x, y, start, end);
 		cache.draw(batch);
-		return layout;
+		return bounds;
 	}
 
-	/** Draws text at the specified position.
-	 * @see BitmapFontCache#addText(CharSequence, float, float, int, int, float, int, boolean) */
-	public GlyphLayout draw (Batch batch, CharSequence str, float x, float y, int start, int end, float targetWidth, int halign,
-		boolean wrap) {
+	/** Draws a string, which may contain newlines (\n), at the specified position.
+	 * @see BitmapFontCache#addMultiLineText(CharSequence, float, float, float, HAlignment) */
+	public TextBounds drawMultiLine (Batch batch, CharSequence str, float x, float y) {
 		cache.clear();
-		GlyphLayout layout = cache.addText(str, x, y, start, end, targetWidth, halign, wrap);
+		TextBounds bounds = cache.addMultiLineText(str, x, y, 0, HAlignment.LEFT);
 		cache.draw(batch);
-		return layout;
+		return bounds;
 	}
 
-	/** Draws text at the specified position.
-	 * @see BitmapFontCache#addText(CharSequence, float, float, int, int, float, int, boolean) */
-	public void draw (Batch batch, GlyphLayout layout, float x, float y) {
+	/** Draws a string, which may contain newlines (\n), at the specified position.
+	 * @see BitmapFontCache#addMultiLineText(CharSequence, float, float, float, HAlignment) */
+	public TextBounds drawMultiLine (Batch batch, CharSequence str, float x, float y, float alignmentWidth, HAlignment alignment) {
 		cache.clear();
-		cache.addText(layout, x, y);
+		TextBounds bounds = cache.addMultiLineText(str, x, y, alignmentWidth, alignment);
 		cache.draw(batch);
+		return bounds;
 	}
 
-	/** Returns the color of text drawn with this font. */
-	public Color getColor () {
-		return cache.getColor();
+	/** Draws a string, which may contain newlines (\n), with the specified position. Each line is automatically wrapped within the
+	 * specified width.
+	 * @see BitmapFontCache#addWrappedText(CharSequence, float, float, float, HAlignment) */
+	public TextBounds drawWrapped (Batch batch, CharSequence str, float x, float y, float wrapWidth) {
+		cache.clear();
+		TextBounds bounds = cache.addWrappedText(str, x, y, wrapWidth, HAlignment.LEFT);
+		cache.draw(batch);
+		return bounds;
+	}
+
+	/** Draws a string, which may contain newlines (\n), with the specified position. Each line is automatically wrapped within the
+	 * specified width.
+	 * @see BitmapFontCache#addWrappedText(CharSequence, float, float, float, HAlignment) */
+	public TextBounds drawWrapped (Batch batch, CharSequence str, float x, float y, float wrapWidth, HAlignment alignment) {
+		cache.clear();
+		TextBounds bounds = cache.addWrappedText(str, x, y, wrapWidth, alignment);
+		cache.draw(batch);
+		return bounds;
+	}
+
+	/** Returns the bounds of the specified text. Note the returned TextBounds instance is reused.
+	 * @see #getBounds(CharSequence, int, int, TextBounds) */
+	public TextBounds getBounds (CharSequence str) {
+		return getBounds(str, 0, str.length(), cache.getBounds());
+	}
+
+	/** Returns the bounds of the specified text.
+	 * @see #getBounds(CharSequence, int, int, TextBounds) */
+	public TextBounds getBounds (CharSequence str, TextBounds textBounds) {
+		return getBounds(str, 0, str.length(), textBounds);
+	}
+
+	/** Returns the bounds of the specified text. Note the returned TextBounds instance is reused.
+	 * @see #getBounds(CharSequence, int, int, TextBounds) */
+	public TextBounds getBounds (CharSequence str, int start, int end) {
+		return getBounds(str, start, end, cache.getBounds());
+	}
+
+	/** Returns the size of the specified string. The height is the distance from the top of most capital letters in the font (the
+	 * {@link #getCapHeight() cap height}) to the baseline.
+	 * @param start The first character of the string.
+	 * @param end The last character of the string (exclusive). */
+	public TextBounds getBounds (CharSequence str, int start, int end, TextBounds textBounds) {
+		BitmapFontData data = this.data;
+		int width = 0;
+		Glyph lastGlyph = null;
+		while (start < end) {
+			char ch = str.charAt(start++);
+			if (ch == '[' && markupEnabled) {
+				if (!(start < end && str.charAt(start) == '[')) { // non escaped '['
+					while (start < end && str.charAt(start) != ']')
+						start++;
+					start++;
+					continue;
+				}
+				start++;
+			}
+			lastGlyph = data.getGlyph(ch);
+			if (lastGlyph != null) {
+				width = lastGlyph.xadvance;
+				break;
+			}
+		}
+		while (start < end) {
+			char ch = str.charAt(start++);
+			if (ch == '[' && markupEnabled) {
+				if (!(start < end && str.charAt(start) == '[')) { // non escaped '['
+					while (start < end && str.charAt(start) != ']')
+						start++;
+					start++;
+					continue;
+				}
+				start++;
+			}
+			Glyph g = data.getGlyph(ch);
+			if (g != null) {
+				width += lastGlyph.getKerning(ch);
+				lastGlyph = g;
+				width += g.xadvance;
+			}
+		}
+		textBounds.width = width * data.scaleX;
+		textBounds.height = data.capHeight;
+		return textBounds;
+	}
+
+	/** Returns the bounds of the specified text, which may contain newlines.
+	 * @see #getMultiLineBounds(CharSequence, TextBounds) */
+	public TextBounds getMultiLineBounds (CharSequence str) {
+		return getMultiLineBounds(str, cache.getBounds());
+	}
+
+	/** Returns the bounds of the specified text, which may contain newlines. The height is the distance from the top of most
+	 * capital letters in the font (the {@link #getCapHeight() cap height}) to the baseline of the last line of text. */
+	public TextBounds getMultiLineBounds (CharSequence str, TextBounds textBounds) {
+		int start = 0;
+		float maxWidth = 0;
+		int numLines = 0;
+		int length = str.length();
+		while (start < length) {
+			int lineEnd = indexOf(str, '\n', start);
+			float lineWidth = getBounds(str, start, lineEnd).width;
+			maxWidth = Math.max(maxWidth, lineWidth);
+			start = lineEnd + 1;
+			numLines++;
+		}
+		textBounds.width = maxWidth;
+		textBounds.height = data.capHeight + (numLines - 1) * data.lineHeight;
+		return textBounds;
+	}
+
+	/** Returns the bounds of the specified text, which may contain newlines and is wrapped within the specified width.
+	 * @see #getWrappedBounds(CharSequence, float, TextBounds) */
+	public TextBounds getWrappedBounds (CharSequence str, float wrapWidth) {
+		return getWrappedBounds(str, wrapWidth, cache.getBounds());
+	}
+
+	/** Returns the bounds of the specified text, which may contain newlines and is wrapped within the specified width. The height
+	 * is the distance from the top of most capital letters in the font (the {@link #getCapHeight() cap height}) to the baseline of
+	 * the last line of text.
+	 * @param wrapWidth Width to wrap the bounds within. */
+	public TextBounds getWrappedBounds (CharSequence str, float wrapWidth, TextBounds textBounds) {
+		if (wrapWidth <= 0) wrapWidth = Integer.MAX_VALUE;
+		int start = 0;
+		int numLines = 0;
+		int length = str.length();
+		float maxWidth = 0;
+		while (start < length) {
+			int newLine = BitmapFont.indexOf(str, '\n', start);
+			int lineEnd = start + computeVisibleGlyphs(str, start, newLine, wrapWidth);
+			int nextStart = lineEnd + 1;
+			if (lineEnd < newLine) {
+				// Find char to break on.
+				while (lineEnd > start) {
+					if (BitmapFont.isWhitespace(str.charAt(lineEnd))) break;
+					if (isBreakChar(str.charAt(lineEnd - 1))) break;
+					lineEnd--;
+				}
+				if (lineEnd == start) {
+					if (nextStart > start + 1) nextStart--;
+					lineEnd = nextStart; // If no characters to break, show all.
+				} else {
+					nextStart = lineEnd;
+					// Eat whitespace at start of wrapped line.
+					while (nextStart < length) {
+						char c = str.charAt(nextStart);
+						if (!BitmapFont.isWhitespace(c)) break;
+						nextStart++;
+						if (c == '\n') break; // Eat only the first wrapped newline.
+					}
+					// Eat whitespace at end of line.
+					while (lineEnd > start) {
+						if (!BitmapFont.isWhitespace(str.charAt(lineEnd - 1))) break;
+						lineEnd--;
+					}
+				}
+			}
+			if (lineEnd > start) {
+				float lineWidth = getBounds(str, start, lineEnd).width;
+				maxWidth = Math.max(maxWidth, lineWidth);
+			}
+			start = nextStart;
+			numLines++;
+		}
+		textBounds.width = maxWidth;
+		textBounds.height = data.capHeight + (numLines - 1) * data.lineHeight;
+		return textBounds;
+	}
+
+	/** Computes the glyph advances for the given character sequence and stores them in the provided {@link FloatArray}. The float
+	 * arrays are cleared. An additional element is added at the end.
+	 * @param glyphAdvances the glyph advances output array.
+	 * @param glyphPositions the glyph positions output array. */
+	public void computeGlyphAdvancesAndPositions (CharSequence str, FloatArray glyphAdvances, FloatArray glyphPositions) {
+		glyphAdvances.clear();
+		glyphPositions.clear();
+		int index = 0;
+		int end = str.length();
+		float width = 0;
+		Glyph lastGlyph = null;
+		BitmapFontData data = this.data;
+		if (data.scaleX == 1) {
+			for (; index < end; index++) {
+				char ch = str.charAt(index);
+				Glyph g = data.getGlyph(ch);
+				if (g != null) {
+					if (lastGlyph != null) width += lastGlyph.getKerning(ch);
+					lastGlyph = g;
+					glyphAdvances.add(g.xadvance);
+					glyphPositions.add(width);
+					width += g.xadvance;
+				}
+			}
+			glyphAdvances.add(0);
+			glyphPositions.add(width);
+		} else {
+			float scaleX = this.data.scaleX;
+			for (; index < end; index++) {
+				char ch = str.charAt(index);
+				Glyph g = data.getGlyph(ch);
+				if (g != null) {
+					if (lastGlyph != null) width += lastGlyph.getKerning(ch) * scaleX;
+					lastGlyph = g;
+					float xadvance = g.xadvance * scaleX;
+					glyphAdvances.add(xadvance);
+					glyphPositions.add(width);
+					width += xadvance;
+				}
+			}
+			glyphAdvances.add(0);
+			glyphPositions.add(width);
+		}
+	}
+
+	/** Returns the number of glyphs from the substring that can be rendered in the specified width.
+	 * @param start The first character of the string.
+	 * @param end The last character of the string (exclusive). */
+	public int computeVisibleGlyphs (CharSequence str, int start, int end, float availableWidth) {
+		BitmapFontData data = this.data;
+		int index = start;
+		float width = 0;
+		Glyph lastGlyph = null;
+		availableWidth /= data.scaleX;
+
+		for (; index < end; index++) {
+			char ch = str.charAt(index);
+			if (ch == '[' && markupEnabled) {
+				index++;
+				if (!(index < end && str.charAt(index) == '[')) { // non escaped '['
+					while (index < end && str.charAt(index) != ']')
+						index++;
+					continue;
+				}
+			}
+			Glyph g = data.getGlyph(ch);
+			if (g != null) {
+				if (lastGlyph != null) width += lastGlyph.getKerning(ch);
+				if ((width + g.xadvance) - availableWidth > 0.001f) break;
+				width += g.xadvance;
+				lastGlyph = g;
+			}
+		}
+		return index - start;
+	}
+
+	public void setColor (float color) {
+		cache.setColor(color);
 	}
 
-	/** A convenience method for setting the font color. The color can also be set by modifying {@link #getColor()}. */
 	public void setColor (Color color) {
-		cache.getColor().set(color);
+		cache.setColor(color);
 	}
 
-	/** A convenience method for setting the font color. The color can also be set by modifying {@link #getColor()}. */
 	public void setColor (float r, float g, float b, float a) {
-		cache.getColor().set(r, g, b, a);
+		cache.setColor(r, g, b, a);
+	}
+
+	/** Returns the color of this font. Changing the returned color will have no affect, {@link #setColor(Color)} or
+	 * {@link #setColor(float, float, float, float)} must be used. */
+	public Color getColor () {
+		return cache.getColor();
+	}
+
+	/** Scales the font by the specified amounts on both axes
+	 * <p>
+	 * Note that smoother scaling can be achieved if the texture backing the BitmapFont is using {@link TextureFilter#Linear}. The
+	 * default is Nearest, so use a BitmapFont constructor that takes a {@link TextureRegion}.
+	 * @throws IllegalArgumentException if scaleX or scaleY is zero. */
+	public void setScale (float scaleX, float scaleY) {
+		if (scaleX == 0) throw new IllegalArgumentException("scaleX cannot be 0.");
+		if (scaleY == 0) throw new IllegalArgumentException("scaleY cannot be 0.");
+		BitmapFontData data = this.data;
+		float x = scaleX / data.scaleX;
+		float y = scaleY / data.scaleY;
+		data.lineHeight = data.lineHeight * y;
+		data.spaceWidth = data.spaceWidth * x;
+		data.xHeight = data.xHeight * y;
+		data.capHeight = data.capHeight * y;
+		data.ascent = data.ascent * y;
+		data.descent = data.descent * y;
+		data.down = data.down * y;
+		data.scaleX = scaleX;
+		data.scaleY = scaleY;
+	}
+
+	/** Scales the font by the specified amount in both directions.
+	 * @see #setScale(float, float)
+	 * @throws IllegalArgumentException if scaleX or scaleY is zero. */
+	public void setScale (float scaleXY) {
+		setScale(scaleXY, scaleXY);
+	}
+
+	/** Sets the font's scale relative to the current scale.
+	 * @see #setScale(float, float)
+	 * @throws IllegalArgumentException if the resulting scale is zero. */
+	public void scale (float amount) {
+		setScale(data.scaleX + amount, data.scaleY + amount);
 	}
 
 	public float getScaleX () {
@@ -251,22 +597,23 @@ public class BitmapFont implements Disposable {
 	}
 
 	/** Returns the first texture region. This is included for backwards compatibility, and for convenience since most fonts only
-	 * use one texture page. For multi-page fonts, use {@link #getRegions()}.
+	 * use one texture page. For multi-page fonts, use getRegions().
 	 * @return the first texture region */
+	// TODO: deprecate?
 	public TextureRegion getRegion () {
-		return regions.first();
+		return regions[0];
 	}
 
 	/** Returns the array of TextureRegions that represents each texture page of glyphs.
 	 * @return the array of texture regions; modifying it may produce undesirable results */
-	public Array<TextureRegion> getRegions () {
+	public TextureRegion[] getRegions () {
 		return regions;
 	}
 
 	/** Returns the texture page at the given index.
 	 * @return the texture page at the given index */
 	public TextureRegion getRegion (int index) {
-		return regions.get(index);
+		return regions[index];
 	}
 
 	/** Returns the line height, which is the distance from one line of text to the next. */
@@ -306,11 +653,21 @@ public class BitmapFont implements Disposable {
 		return flipped;
 	}
 
+	/** Returns true if color markup is enabled for this BitmapFont */
+	public boolean isMarkupEnabled () {
+		return markupEnabled;
+	}
+
+	/** Sets color markup on/off for this BitmapFont */
+	public void setMarkupEnabled (boolean markupEnabled) {
+		this.markupEnabled = markupEnabled;
+	}
+
 	/** Disposes the texture used by this BitmapFont's region IF this BitmapFont created the texture. */
 	public void dispose () {
 		if (ownsTexture) {
-			for (int i = 0; i < regions.size; i++)
-				regions.get(i).getTexture().dispose();
+			for (int i = 0; i < regions.length; i++)
+				regions[i].getTexture().dispose();
 		}
 	}
 
@@ -332,7 +689,12 @@ public class BitmapFont implements Disposable {
 		}
 	}
 
-	/** Specifies whether to use integer positions. Default is to use them so filtering doesn't kick in as badly. */
+	/** Checks whether this BitmapFont data contains a given character. */
+	public boolean containsCharacter (char character) {
+		return data.getGlyph(character) != null;
+	}
+
+	/** Specifies whether to use integer positions or not. Default is to use them so filtering doesn't kick in as badly. */
 	public void setUseIntegerPositions (boolean integer) {
 		this.integer = integer;
 		cache.setUseIntegerPositions(integer);
@@ -360,15 +722,17 @@ public class BitmapFont implements Disposable {
 		return ownsTexture;
 	}
 
-	/** Sets whether the font owns the texture. In case it does, the font will also dispose of the texture when {@link #dispose()}
-	 * is called. Use with care!
+	/** Sets whether the font owns the texture or not. In case it does, the font will also dispose of the texture when
+	 * {@link #dispose()} is called. Use with care!
 	 * @param ownsTexture whether the font owns the texture */
 	public void setOwnsTexture (boolean ownsTexture) {
 		this.ownsTexture = ownsTexture;
 	}
 
 	public String toString () {
-		if (data.fontFile != null) return data.fontFile.nameWithoutExtension();
+		if (data.fontFile != null) {
+			return data.fontFile.nameWithoutExtension();
+		}
 		return super.toString();
 	}
 
@@ -400,10 +764,6 @@ public class BitmapFont implements Disposable {
 			if (page == null) kerning[ch >>> LOG2_PAGE_SIZE] = page = new byte[PAGE_SIZE];
 			page[ch & PAGE_SIZE - 1] = (byte)value;
 		}
-
-		public String toString () {
-			return Character.toString((char)id);
-		}
 	}
 
 	static int indexOf (CharSequence text, char ch, int start) {
@@ -413,51 +773,83 @@ public class BitmapFont implements Disposable {
 		return n;
 	}
 
+	/** Provide any additional characters that should act as break characters when the label is wrapped. By default, only whitespace
+	 * characters act as break chars. */
+	public void setBreakChars (char[] breakChars) {
+		this.breakChars = breakChars;
+	}
+
+	public boolean isBreakChar (char c) {
+		if (breakChars == null) return false;
+		for (char br : breakChars)
+			if (c == br) return true;
+		return false;
+	}
+
+	static boolean isWhitespace (char c) {
+		switch (c) {
+		case '\n':
+		case '\r':
+		case '\t':
+		case ' ':
+			return true;
+		default:
+			return false;
+		}
+	}
+
+	/** Arbitrarily definable text boundary */
+	static public class TextBounds {
+		public float width;
+		public float height;
+
+		public TextBounds () {
+		}
+
+		public TextBounds (TextBounds bounds) {
+			set(bounds);
+		}
+
+		public void set (TextBounds bounds) {
+			width = bounds.width;
+			height = bounds.height;
+		}
+	}
+
+	/** Defines possible horizontal alignments. */
+	static public enum HAlignment {
+		LEFT, CENTER, RIGHT
+	}
+
 	/** Backing data for a {@link BitmapFont}. */
-	static public class BitmapFontData {
+	public static class BitmapFontData {
+		/** The first image path.
+		 * @deprecated Use imagePaths[0]. */
+		@Deprecated public String imagePath;
+
 		/** An array of the image paths, for multiple texture pages. */
 		public String[] imagePaths;
 		public FileHandle fontFile;
 		public boolean flipped;
-		/** The distance from one line of text to the next. */
 		public float lineHeight;
-		/** The distance from the top of most uppercase characters to the baseline. Since the drawing position is the cap height of
-		 * the first line, the cap height can be used to get the location of the baseline. */
 		public float capHeight = 1;
-		/** The distance from the cap height to the top of the tallest glyph. */
 		public float ascent;
-		/** The distance from the bottom of the glyph that extends the lowest to the baseline. This number is negative. */
 		public float descent;
 		public float down;
 		public float scaleX = 1, scaleY = 1;
-		public boolean markupEnabled;
 
 		public final Glyph[][] glyphs = new Glyph[PAGES][];
-		/** The width of the space character. */
 		public float spaceWidth;
-		/** The x-height, which is the distance from the top of most lowercase characters to the baseline. */
 		public float xHeight = 1;
 
-		/** Additional characters besides whitespace where text is wrapped. Eg, a hypen (-). */
-		public char[] breakChars;
-		public char[] xChars = {'x', 'e', 'a', 'o', 'n', 's', 'r', 'c', 'u', 'm', 'v', 'w', 'z'};
-		public char[] capChars = {'M', 'N', 'B', 'D', 'C', 'E', 'F', 'K', 'A', 'G', 'H', 'I', 'J', 'L', 'O', 'P', 'Q', 'R', 'S',
-			'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
-
-		/** Creates an empty BitmapFontData for configuration before calling {@link #load(FileHandle, boolean)}, to subclass, or to
-		 * populate yourself, e.g. using stb-truetype or FreeType. */
+		/** Use this if you want to create BitmapFontData yourself, e.g. from stb-truetype or FreeType. */
 		public BitmapFontData () {
 		}
 
+		@SuppressWarnings("deprecation")
 		public BitmapFontData (FileHandle fontFile, boolean flip) {
 			this.fontFile = fontFile;
 			this.flipped = flip;
-			load(fontFile, flip);
-		}
-
-		public void load (FileHandle fontFile, boolean flip) {
-			if (imagePaths != null) throw new IllegalStateException("Already loaded.");
-
 			BufferedReader reader = new BufferedReader(new InputStreamReader(fontFile.read()), 512);
 			try {
 				reader.readLine(); // info
@@ -511,7 +903,9 @@ public class BitmapFont implements Disposable {
 						fileName = pageLine[2].substring(5, pageLine[2].length());
 					}
 
-					imagePaths[p] = fontFile.parent().child(fileName).path().replaceAll("\\\\", "/");
+					String path = fontFile.parent().child(fileName).path().replaceAll("\\\\", "/");
+					if (this.imagePath == null) this.imagePath = path;
+					imagePaths[p] = path;
 				}
 				descent = 0;
 
@@ -630,67 +1024,6 @@ public class BitmapFont implements Disposable {
 			}
 		}
 
-		public void setGlyphRegion (Glyph glyph, TextureRegion region) {
-			float invTexWidth = 1.0f / region.getTexture().getWidth();
-			float invTexHeight = 1.0f / region.getTexture().getHeight();
-
-			float offsetX = 0, offsetY = 0;
-			float u = region.u;
-			float v = region.v;
-			float regionWidth = region.getRegionWidth();
-			float regionHeight = region.getRegionHeight();
-			if (region instanceof AtlasRegion) {
-				// Compensate for whitespace stripped from left and top edges.
-				AtlasRegion atlasRegion = (AtlasRegion)region;
-				offsetX = atlasRegion.offsetX;
-				offsetY = atlasRegion.originalHeight - atlasRegion.packedHeight - atlasRegion.offsetY;
-			}
-
-			float x = glyph.srcX;
-			float x2 = glyph.srcX + glyph.width;
-			float y = glyph.srcY;
-			float y2 = glyph.srcY + glyph.height;
-
-			// Shift glyph for left and top edge stripped whitespace. Clip glyph for right and bottom edge stripped whitespace.
-			if (offsetX > 0) {
-				x -= offsetX;
-				if (x < 0) {
-					glyph.width += x;
-					glyph.xoffset -= x;
-					x = 0;
-				}
-				x2 -= offsetX;
-				if (x2 > regionWidth) {
-					glyph.width -= x2 - regionWidth;
-					x2 = regionWidth;
-				}
-			}
-			if (offsetY > 0) {
-				y -= offsetY;
-				if (y < 0) {
-					glyph.height += y;
-					y = 0;
-				}
-				y2 -= offsetY;
-				if (y2 > regionHeight) {
-					float amount = y2 - regionHeight;
-					glyph.height -= amount;
-					glyph.yoffset += amount;
-					y2 = regionHeight;
-				}
-			}
-
-			glyph.u = u + x * invTexWidth;
-			glyph.u2 = u + x2 * invTexWidth;
-			if (flipped) {
-				glyph.v = v + y * invTexHeight;
-				glyph.v2 = v + y2 * invTexHeight;
-			} else {
-				glyph.v2 = v + y * invTexHeight;
-				glyph.v = v + y2 * invTexHeight;
-			}
-		}
-
 		/** Sets the line height, which is the distance from one line of text to the next. */
 		public void setLineHeight (float height) {
 			lineHeight = height * scaleY;
@@ -714,74 +1047,18 @@ public class BitmapFont implements Disposable {
 			throw new GdxRuntimeException("No glyphs found.");
 		}
 
-		public boolean hasGlyph (char ch) {
-			return getGlyph(ch) != null;
-		}
-
-		/** Returns the glyph for the specified character, or null if no such glyph exists. Note that
-		 * {@link #getGlyphs(GlyphRun, CharSequence, int, int)} should be be used to shape a string of characters into a list of
-		 * glyphs. */
+		/** Returns the glyph for the specified character, or null if no such glyph exists. */
 		public Glyph getGlyph (char ch) {
 			Glyph[] page = glyphs[ch / PAGE_SIZE];
 			if (page != null) return page[ch & PAGE_SIZE - 1];
 			return null;
 		}
 
-		/** Using the specified string, populates the glyphs and positions of the specified glyph run.
-		 * @param str Characters to convert to glyphs. Will not contain newline or color tags. May contain "[[" for an escaped left
-		 *           square bracket. */
-		public void getGlyphs (GlyphRun run, CharSequence str, int start, int end) {
-			boolean markupEnabled = this.markupEnabled;
-			float scaleX = this.scaleX;
-			Array<Glyph> glyphs = run.glyphs;
-			FloatArray xAdvances = run.xAdvances;
-
-			Glyph lastGlyph = null;
-			while (start < end) {
-				char ch = str.charAt(start++);
-				Glyph glyph = getGlyph(ch);
-				if (glyph == null) continue;
-				glyphs.add(glyph);
-
-				if (lastGlyph != null) xAdvances.add((lastGlyph.xadvance + lastGlyph.getKerning(ch)) * scaleX);
-				lastGlyph = glyph;
-
-				// "[[" is an escaped left square bracket, skip second character.
-				if (markupEnabled && ch == '[' && start < end && str.charAt(start) == '[') start++;
-			}
-			if (lastGlyph != null) xAdvances.add(lastGlyph.xadvance * scaleX);
-		}
-
-		/** Returns the first valid glyph index to use to wrap to the next line, starting at the specified start index and moving
-		 * toward the beginning of the glyphs array. */
-		public int getWrapIndex (Array<Glyph> glyphs, int start) {
-			char ch = (char)glyphs.get(start).id;
-			if (isWhitespace(ch)) return start + 1;
-			for (int i = start - 1; i >= 1; i--) {
-				ch = (char)glyphs.get(i).id;
-				if (isWhitespace(ch)) return i + 1;
-				if (isBreakChar(ch)) return i;
-			}
-			return start;
-		}
-
-		public boolean isBreakChar (char c) {
-			if (breakChars == null) return false;
-			for (char br : breakChars)
-				if (c == br) return true;
-			return false;
-		}
-
-		public boolean isWhitespace (char c) {
-			switch (c) {
-			case '\n':
-			case '\r':
-			case '\t':
-			case ' ':
-				return true;
-			default:
-				return false;
-			}
+		/** Returns the first image path.
+		 * @deprecated Use {@link #getImagePath(int)}. */
+		@Deprecated
+		public String getImagePath () {
+			return imagePath;
 		}
 
 		/** Returns the image path for the texture page at the given index (the "id" in the BMFont file). */
@@ -796,40 +1073,5 @@ public class BitmapFont implements Disposable {
 		public FileHandle getFontFile () {
 			return fontFile;
 		}
-
-		/** Scales the font by the specified amounts on both axes
-		 * <p>
-		 * Note that smoother scaling can be achieved if the texture backing the BitmapFont is using {@link TextureFilter#Linear}.
-		 * The default is Nearest, so use a BitmapFont constructor that takes a {@link TextureRegion}.
-		 * @throws IllegalArgumentException if scaleX or scaleY is zero. */
-		public void setScale (float scaleX, float scaleY) {
-			if (scaleX == 0) throw new IllegalArgumentException("scaleX cannot be 0.");
-			if (scaleY == 0) throw new IllegalArgumentException("scaleY cannot be 0.");
-			float x = scaleX / this.scaleX;
-			float y = scaleY / this.scaleY;
-			lineHeight *= y;
-			spaceWidth *= x;
-			xHeight *= y;
-			capHeight *= y;
-			ascent *= y;
-			descent *= y;
-			down *= y;
-			this.scaleX = scaleX;
-			this.scaleY = scaleY;
-		}
-
-		/** Scales the font by the specified amount in both directions.
-		 * @see #setScale(float, float)
-		 * @throws IllegalArgumentException if scaleX or scaleY is zero. */
-		public void setScale (float scaleXY) {
-			setScale(scaleXY, scaleXY);
-		}
-
-		/** Sets the font's scale relative to the current scale.
-		 * @see #setScale(float, float)
-		 * @throws IllegalArgumentException if the resulting scale is zero. */
-		public void scale (float amount) {
-			setScale(scaleX + amount, scaleY + amount);
-		}
 	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java b/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java
index 9e78462..94d6e4b 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java
@@ -19,41 +19,44 @@ package com.badlogic.gdx.graphics.g2d;
 import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.BitmapFontData;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.Glyph;
-import com.badlogic.gdx.graphics.g2d.GlyphLayout.GlyphRun;
-import com.badlogic.gdx.utils.Align;
-import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.FloatArray;
+import com.badlogic.gdx.graphics.g2d.BitmapFont.HAlignment;
+import com.badlogic.gdx.graphics.g2d.BitmapFont.TextBounds;
 import com.badlogic.gdx.utils.IntArray;
 import com.badlogic.gdx.utils.NumberUtils;
-import com.badlogic.gdx.utils.Pools;
 
-/** Caches glyph geometry for a BitmapFont, providing a fast way to render static text. This saves needing to compute the glyph
- * geometry each frame.
+/** Caches glyph geometry for a BitmapFont, providing a fast way to render static text. This saves needing to compute the location
+ * of each glyph each frame.
  * @author Nathan Sweet
+ * @author Matthias Mann
  * @author davebaol
  * @author Alexander Dorokhov */
 public class BitmapFontCache {
-	static private final Color tempColor = new Color(1, 1, 1, 1);
-	static private final float whiteTint = Color.WHITE.toFloatBits();
 
 	private final BitmapFont font;
-	private boolean integer;
-	private final Array<GlyphLayout> layouts = new Array();
-	private final Array<GlyphLayout> pooledLayouts = new Array();
-	private int glyphCount;
-	private float x, y;
-	private final Color color = new Color(1, 1, 1, 1);
-	private float currentTint;
 
-	/** Vertex data per page. */
-	private float[][] pageVertices;
-	/** Number of vertex data entries per page. */
+	private float[][] vertexData;
+
 	private int[] idx;
-	/** For each page, an array with a value for each glyph from that page, where the value is the index of the character in the
-	 * full text being cached. */
-	private IntArray[] pageGlyphIndices;
 	/** Used internally to ensure a correct capacity for multi-page font vertex data. */
-	private int[] tempGlyphCount;
+	private int[] tmpGlyphCount;
+
+	private float x, y;
+	private float color = Color.WHITE.toFloatBits();
+	private final Color tempColor = new Color(1, 1, 1, 1);
+	private final TextBounds textBounds = new TextBounds();
+	private boolean integer = true;
+	private int glyphCount = 0;
+
+	/** An array for each page containing an entry for each glyph from that page, where the entry is the index of the character in
+	 * the full text being cached. */
+	private IntArray[] glyphIndices;
+
+	private boolean textChanged;
+	private float oldTint = 0;
+
+	private TextMarkup markup = new TextMarkup();
+
+	private int charsCount;
 
 	public BitmapFontCache (BitmapFont font) {
 		this(font, font.usesIntegerPositions());
@@ -64,18 +67,22 @@ public class BitmapFontCache {
 		this.font = font;
 		this.integer = integer;
 
-		int pageCount = font.regions.size;
-		if (pageCount == 0) throw new IllegalArgumentException("The specified font must contain at least one texture page.");
+		int regionsLength = font.regions.length;
+		if (regionsLength == 0) throw new IllegalArgumentException("The specified font must contain at least one texture page.");
+
+		this.vertexData = new float[regionsLength][];
+
+		this.idx = new int[regionsLength];
+		int vertexDataLength = vertexData.length;
+		if (vertexDataLength > 1) { // If we have multiple pages...
+			// Contains the indices of the glyph in the Cache as they are added.
+			glyphIndices = new IntArray[vertexDataLength];
+			for (int i = 0, n = glyphIndices.length; i < n; i++) {
+				glyphIndices[i] = new IntArray();
+			}
 
-		pageVertices = new float[pageCount][];
-		idx = new int[pageCount];
-		if (pageCount > 1) {
-			// Contains the indices of the glyph in the cache as they are added.
-			pageGlyphIndices = new IntArray[pageCount];
-			for (int i = 0, n = pageGlyphIndices.length; i < n; i++)
-				pageGlyphIndices[i] = new IntArray();
+			tmpGlyphCount = new int[vertexDataLength];
 		}
-		tempGlyphCount = new int[pageCount];
 	}
 
 	/** Sets the position of the text, relative to the position when the cached text was created.
@@ -97,8 +104,8 @@ public class BitmapFontCache {
 		x += xAmount;
 		y += yAmount;
 
-		for (int j = 0, length = pageVertices.length; j < length; j++) {
-			float[] vertices = pageVertices[j];
+		for (int j = 0, length = vertexData.length; j < length; j++) {
+			float[] vertices = vertexData[j];
 			for (int i = 0, n = idx[j]; i < n; i += 5) {
 				vertices[i] += xAmount;
 				vertices[i + 1] += yAmount;
@@ -106,32 +113,22 @@ public class BitmapFontCache {
 		}
 	}
 
+	private Color setColor (Color color, float floatColor) {
+		int intBits = NumberUtils.floatToIntColor(floatColor);
+		color.r = (intBits & 0xff) / 255f;
+		color.g = ((intBits >>> 8) & 0xff) / 255f;
+		color.b = ((intBits >>> 16) & 0xff) / 255f;
+		color.a = ((intBits >>> 24) & 0xff) / 255f;
+		return color;
+	}
+
 	/** Tints all text currently in the cache. Does not affect subsequently added text. */
 	public void tint (Color tint) {
-		float newTint = tint.toFloatBits();
-		if (currentTint == newTint) return;
-		currentTint = newTint;
-
-		int[] tempGlyphCount = this.tempGlyphCount;
-		for (int i = 0, n = tempGlyphCount.length; i < n; i++)
-			tempGlyphCount[i] = 0;
-
-		for (int i = 0, n = layouts.size; i < n; i++) {
-			GlyphLayout layout = layouts.get(i);
-			for (int ii = 0, nn = layout.runs.size; ii < nn; ii++) {
-				GlyphRun run = layout.runs.get(ii);
-				Array<Glyph> glyphs = run.glyphs;
-				float colorFloat = tempColor.set(run.color).mul(tint).toFloatBits();
-				for (int iii = 0, nnn = glyphs.size; iii < nnn; iii++) {
-					Glyph glyph = glyphs.get(iii);
-					int page = glyph.page;
-					int offset = tempGlyphCount[page] * 20 + 2;
-					tempGlyphCount[page]++;
-					float[] vertices = pageVertices[page];
-					for (int v = 0; v < 20; v += 5)
-						vertices[offset + v] = colorFloat;
-				}
-			}
+		final float floatTint = tint.toFloatBits();
+		if (textChanged || oldTint != floatTint) {
+			textChanged = false;
+			oldTint = floatTint;
+			markup.tint(this, tint);
 		}
 	}
 
@@ -139,8 +136,8 @@ public class BitmapFontCache {
 	public void setAlphas (float alpha) {
 		int alphaBits = ((int)(254 * alpha)) << 24;
 		float prev = 0, newColor = 0;
-		for (int j = 0, length = pageVertices.length; j < length; j++) {
-			float[] vertices = pageVertices[j];
+		for (int j = 0, length = vertexData.length; j < length; j++) {
+			float[] vertices = vertexData[j];
 			for (int i = 2, n = idx[j]; i < n; i += 5) {
 				float c = vertices[i];
 				if (c == prev && i != 2) {
@@ -158,8 +155,8 @@ public class BitmapFontCache {
 
 	/** Sets the color of all text currently in the cache. Does not affect subsequently added text. */
 	public void setColors (float color) {
-		for (int j = 0, length = pageVertices.length; j < length; j++) {
-			float[] vertices = pageVertices[j];
+		for (int j = 0, length = vertexData.length; j < length; j++) {
+			float[] vertices = vertexData[j];
 			for (int i = 2, n = idx[j]; i < n; i += 5)
 				vertices[i] = color;
 		}
@@ -167,13 +164,23 @@ public class BitmapFontCache {
 
 	/** Sets the color of all text currently in the cache. Does not affect subsequently added text. */
 	public void setColors (Color tint) {
-		setColors(tint.toFloatBits());
+		final float color = tint.toFloatBits();
+		for (int j = 0, length = vertexData.length; j < length; j++) {
+			float[] vertices = vertexData[j];
+			for (int i = 2, n = idx[j]; i < n; i += 5)
+				vertices[i] = color;
+		}
 	}
 
 	/** Sets the color of all text currently in the cache. Does not affect subsequently added text. */
 	public void setColors (float r, float g, float b, float a) {
 		int intBits = ((int)(255 * a) << 24) | ((int)(255 * b) << 16) | ((int)(255 * g) << 8) | ((int)(255 * r));
-		setColors(NumberUtils.intToFloatColor(intBits));
+		float color = NumberUtils.intToFloatColor(intBits);
+		for (int j = 0, length = vertexData.length; j < length; j++) {
+			float[] vertices = vertexData[j];
+			for (int i = 2, n = idx[j]; i < n; i += 5)
+				vertices[i] = color;
+		}
 	}
 
 	/** Sets the color of the specified characters. This may only be called after {@link #setText(CharSequence, float, float)} and
@@ -185,91 +192,117 @@ public class BitmapFontCache {
 	/** Sets the color of the specified characters. This may only be called after {@link #setText(CharSequence, float, float)} and
 	 * is reset every time setText is called. */
 	public void setColors (float color, int start, int end) {
-		if (pageVertices.length == 1) { // One page.
-			float[] vertices = pageVertices[0];
+		if (vertexData.length == 1) { // only one page...
+			float[] vertices = vertexData[0];
 			for (int i = start * 20 + 2, n = end * 20; i < n; i += 5)
 				vertices[i] = color;
-			return;
-		}
+		} else {
+			int pageCount = vertexData.length;
+
+			// for each page...
+			for (int i = 0; i < pageCount; i++) {
+				float[] vertices = vertexData[i];
+
+				// we need to loop through the indices and determine whether the glyph is inside begin/end
+				for (int j = 0, n = glyphIndices[i].size; j < n; j++) {
+					int gInd = glyphIndices[i].items[j];
+
+					// break early if the glyph is outside our bounds
+					if (gInd >= end) break;
 
-		int pageCount = pageVertices.length;
-		for (int i = 0; i < pageCount; i++) {
-			float[] vertices = pageVertices[i];
-			IntArray glyphIndices = pageGlyphIndices[i];
-			// Loop through the indices and determine whether the glyph is inside begin/end.
-			for (int j = 0, n = glyphIndices.size; j < n; j++) {
-				int glyphIndex = glyphIndices.items[j];
-
-				// Break early if the glyph is out of bounds.
-				if (glyphIndex >= end) break;
-
-				// If inside start and end, change its colour.
-				if (glyphIndex >= start) { // && glyphIndex < end
-					for (int off = 0; off < 20; off += 5)
-						vertices[off + (j * 20 + 2)] = color;
+					// if the glyph is inside start and end, then change it's colour
+					if (gInd >= start) { // && gInd < end
+						// modify color index
+						for (int off = 0; off < 20; off += 5)
+							vertices[off + (j * 20 + 2)] = color;
+					}
 				}
 			}
+
 		}
 	}
 
-	/** Returns the color used for subsequently added text. Modifying the color affects text subsequently added to the cache, but
-	 * does not affect existing text currently in the cache. */
-	public Color getColor () {
-		return color;
+	/** Sets the color of subsequently added text. Does not affect text currently in the cache. */
+	public void setColor (Color tint) {
+		color = tint.toFloatBits();
+		markup.setDefaultChunk(tint, charsCount);
 	}
 
-	/** A convenience method for setting the cache color. The color can also be set by modifying {@link #getColor()}. */
-	public void setColor (Color color) {
-		this.color.set(color);
+	/** Sets the color of subsequently added text. Does not affect text currently in the cache. */
+	public void setColor (float r, float g, float b, float a) {
+		int intBits = (int)(255 * a) << 24 | (int)(255 * b) << 16 | (int)(255 * g) << 8 | (int)(255 * r);
+		color = NumberUtils.intToFloatColor(intBits);
+		markup.setDefaultChunk(intBits, charsCount);
 	}
 
-	/** A convenience method for setting the cache color. The color can also be set by modifying {@link #getColor()}. */
-	public void setColor (float r, float g, float b, float a) {
-		color.set(r, g, b, a);
+	/** Sets the color of subsequently added text. Does not affect text currently in the cache. */
+	public void setColor (float color) {
+		this.color = color;
+		markup.setDefaultChunk(color, charsCount);
+	}
+
+	public Color getColor () {
+		int intBits = NumberUtils.floatToIntColor(color);
+		Color color = tempColor;
+		color.r = (intBits & 0xff) / 255f;
+		color.g = ((intBits >>> 8) & 0xff) / 255f;
+		color.b = ((intBits >>> 16) & 0xff) / 255f;
+		color.a = ((intBits >>> 24) & 0xff) / 255f;
+		return color;
 	}
 
 	public void draw (Batch spriteBatch) {
-		Array<TextureRegion> regions = font.getRegions();
-		for (int j = 0, n = pageVertices.length; j < n; j++) {
+		TextureRegion[] regions = font.getRegions();
+		for (int j = 0, n = vertexData.length; j < n; j++) {
 			if (idx[j] > 0) { // ignore if this texture has no glyphs
-				float[] vertices = pageVertices[j];
-				spriteBatch.draw(regions.get(j).getTexture(), vertices, 0, idx[j]);
+				float[] vertices = vertexData[j];
+				spriteBatch.draw(regions[j].getTexture(), vertices, 0, idx[j]);
 			}
 		}
 	}
 
 	public void draw (Batch spriteBatch, int start, int end) {
-		if (pageVertices.length == 1) { // 1 page.
-			spriteBatch.draw(font.getRegion().getTexture(), pageVertices[0], start * 20, (end - start) * 20);
-			return;
-		}
+		if (vertexData.length == 1) { // i.e. 1 page
+			spriteBatch.draw(font.getRegion().getTexture(), vertexData[0], start * 20, (end - start) * 20);
+		} else { // i.e. multiple pages
+			// TODO: bounds check?
 
-		// Determine vertex offset and count to render for each page. Some pages might not need to be rendered at all.
-		Array<TextureRegion> regions = font.getRegions();
-		for (int i = 0, pageCount = pageVertices.length; i < pageCount; i++) {
-			int offset = -1, count = 0;
+			// We basically need offset and len for each page
+			// Different pages might have different offsets and lengths
+			// Some pages might not need to be rendered at all..
 
-			// For each set of glyph indices, determine where to begin within the start/end bounds.
-			IntArray glyphIndices = pageGlyphIndices[i];
-			for (int ii = 0, n = glyphIndices.size; ii < n; ii++) {
-				int glyphIndex = glyphIndices.get(ii);
+			TextureRegion[] regions = font.getRegions();
 
-				// Break early if the glyph is out of bounds.
-				if (glyphIndex >= end) break;
+			// for each page...
+			for (int i = 0, pageCount = vertexData.length; i < pageCount; i++) {
 
-				// Determine if this glyph is within bounds. Use the first match of that for the offset.
-				if (offset == -1 && glyphIndex >= start) offset = ii;
+				int offset = -1;
+				int count = 0;
 
-				// Determine the vertex count by counting glyphs within bounds.
-				if (glyphIndex >= start) // && gInd < end
-					count++;
-			}
+				// we need to loop through the indices and determine where we begin within the start/end bounds
+				IntArray currentGlyphIndices = glyphIndices[i];
+				for (int j = 0, n = currentGlyphIndices.size; j < n; j++) {
+					int glyphIndex = currentGlyphIndices.items[j];
+
+					// break early if the glyph is outside our bounds
+					if (glyphIndex >= end) break;
 
-			// Page doesn't need to be rendered.
-			if (offset == -1 || count == 0) continue;
+					// determine if this glyph is "inside" our start/end bounds
+					// if so; use the first match of that for the offset
+					if (offset == -1 && glyphIndex >= start) offset = j;
 
-			// Render the page vertex data with the offset and count.
-			spriteBatch.draw(regions.get(i).getTexture(), pageVertices[i], offset * 20, count * 20);
+					// we also need to determine the length of our vertices array...
+					// we do so by counting the glyphs within our bounds
+					if (glyphIndex >= start) // && gInd < end
+						count++;
+				}
+
+				// this page isn't necessary to be rendered
+				if (offset == -1 || count == 0) continue;
+
+				// render the page vertex data with our determined offset and length
+				spriteBatch.draw(regions[i].getTexture(), vertexData[i], offset * 20, count * 20);
+			}
 		}
 	}
 
@@ -291,106 +324,210 @@ public class BitmapFontCache {
 	public void clear () {
 		x = 0;
 		y = 0;
-		Pools.freeAll(pooledLayouts, true);
-		pooledLayouts.clear();
-		layouts.clear();
+		glyphCount = 0;
+		charsCount = 0;
+		markup.clear();
 		for (int i = 0, n = idx.length; i < n; i++) {
-			if (pageGlyphIndices != null) pageGlyphIndices[i].clear();
+			if (glyphIndices != null) glyphIndices[i].clear();
 			idx[i] = 0;
 		}
 	}
 
-	private void requireGlyphs (GlyphLayout layout) {
-		if (pageVertices.length == 1) {
-			// Simpler counting if we just have one page.
-			int newGlyphCount = 0;
-			for (int i = 0, n = layout.runs.size; i < n; i++)
-				newGlyphCount += layout.runs.get(i).glyphs.size;
-			requirePageGlyphs(0, newGlyphCount);
+	/** Counts the actual glyphs excluding characters used to markup the text. */
+	private int countGlyphs (CharSequence seq, int start, int end) {
+		int count = end - start;
+		if (font.markupEnabled) {
+			while (start < end) {
+				char ch = seq.charAt(start++);
+				if (ch == '[') {
+					if (start < end && seq.charAt(start) == '[') { // escaped '['
+						start++;
+						count--;
+					} else { // non escaped '['
+						int colorTagLen = markup.parseColorTag(seq, -1, start, end);
+						if (colorTagLen >= 0) {
+							start += colorTagLen + 1;
+							count -= colorTagLen + 2;
+						}
+					}
+				}
+			}
+		}
+		return count;
+	}
+
+	private void requireSequence (CharSequence seq, int start, int end) {
+		if (vertexData.length == 1) {
+			// don't scan sequence if we just have one page and markup is disabled
+			int newGlyphCount = countGlyphs(seq, start, end);
+			require(0, newGlyphCount);
 		} else {
-			int[] tempGlyphCount = this.tempGlyphCount;
-			for (int i = 0, n = tempGlyphCount.length; i < n; i++)
-				tempGlyphCount[i] = 0;
-			// Determine # of glyphs in each page.
-			for (int i = 0, n = layout.runs.size; i < n; i++) {
-				Array<Glyph> glyphs = layout.runs.get(i).glyphs;
-				for (int ii = 0, nn = glyphs.size; ii < nn; ii++)
-					tempGlyphCount[glyphs.get(ii).page]++;
+			for (int i = 0, n = tmpGlyphCount.length; i < n; i++)
+				tmpGlyphCount[i] = 0;
+
+			// determine # of glyphs in each page
+			while (start < end) {
+				char ch = seq.charAt(start++);
+				if (ch == '[' && font.markupEnabled) {
+					if (!(start < end && seq.charAt(start) == '[')) { // non escaped '['
+						int colorTagLen = markup.parseColorTag(seq, -1, start, end);
+						if (colorTagLen >= 0) {
+							start += colorTagLen + 1;
+							continue;
+						}
+					}
+					start++;
+				}
+				Glyph g = font.data.getGlyph(ch);
+				if (g == null) continue;
+				tmpGlyphCount[g.page]++;
 			}
-			// Require that many for each page.
-			for (int i = 0, n = tempGlyphCount.length; i < n; i++)
-				requirePageGlyphs(i, tempGlyphCount[i]);
+			// require that many for each page
+			for (int i = 0, n = tmpGlyphCount.length; i < n; i++)
+				require(i, tmpGlyphCount[i]);
 		}
 	}
 
-	private void requirePageGlyphs (int page, int glyphCount) {
-		if (pageGlyphIndices != null) {
-			if (glyphCount > pageGlyphIndices[page].items.length)
-				pageGlyphIndices[page].ensureCapacity(glyphCount - pageGlyphIndices[page].items.length);
+	private void require (int page, int glyphCount) {
+		if (glyphIndices != null) {
+			if (glyphCount > glyphIndices[page].items.length)
+				glyphIndices[page].ensureCapacity(glyphCount - glyphIndices[page].items.length);
 		}
 
 		int vertexCount = idx[page] + glyphCount * 20;
-		float[] vertices = pageVertices[page];
+		float[] vertices = vertexData[page];
 		if (vertices == null) {
-			pageVertices[page] = new float[vertexCount];
+			vertexData[page] = new float[vertexCount];
 		} else if (vertices.length < vertexCount) {
 			float[] newVertices = new float[vertexCount];
 			System.arraycopy(vertices, 0, newVertices, 0, idx[page]);
-			pageVertices[page] = newVertices;
+			vertexData[page] = newVertices;
 		}
 	}
 
-	private void addToCache (GlyphLayout layout, float x, float y) {
-		// Check if the number of font pages has changed.
-		int pageCount = font.regions.size;
-		if (pageVertices.length < pageCount) {
-			float[][] newPageVertices = new float[pageCount][];
-			System.arraycopy(pageVertices, 0, newPageVertices, 0, pageVertices.length);
-			pageVertices = newPageVertices;
-
-			int[] newIdx = new int[pageCount];
-			System.arraycopy(idx, 0, newIdx, 0, idx.length);
-			idx = newIdx;
-
-			IntArray[] newPageGlyphIndices = new IntArray[pageCount];
-			int pageGlyphIndicesLength = 0;
-			if (pageGlyphIndices != null) {
-				pageGlyphIndicesLength = pageGlyphIndices.length;
-				System.arraycopy(pageGlyphIndices, 0, newPageGlyphIndices, 0, pageGlyphIndices.length);
+	private float addToCache (CharSequence str, float x, float y, int start, int end) {
+		float startX = x;
+		BitmapFont font = this.font;
+		Glyph lastGlyph = null;
+		BitmapFontData data = font.data;
+		textChanged = start < end;
+		if (data.scaleX == 1 && data.scaleY == 1) {
+			while (start < end) {
+				char ch = str.charAt(start++);
+				if (ch == '[' && font.markupEnabled) {
+					if (start < end && str.charAt(start) == '[') // escaped '['
+						start++;
+					else { // non escaped '['
+						int colorTagLen = markup.parseColorTag(str, charsCount, start, end);
+						if (colorTagLen >= 0) {
+							color = markup.getLastColor().toFloatBits();
+							start += colorTagLen + 1;
+							continue;
+						}
+					}
+				}
+				lastGlyph = data.getGlyph(ch);
+				if (lastGlyph != null) {
+					addGlyph(lastGlyph, x + lastGlyph.xoffset, y + lastGlyph.yoffset, lastGlyph.width, lastGlyph.height);
+					x += lastGlyph.xadvance;
+					break;
+				}
 			}
-			for (int i = pageGlyphIndicesLength; i < pageCount; i++)
-				newPageGlyphIndices[i] = new IntArray();
-			pageGlyphIndices = newPageGlyphIndices;
-
-			tempGlyphCount = new int[pageCount];
-		}
-
-		layouts.add(layout);
-		requireGlyphs(layout);
-		for (int i = 0, n = layout.runs.size; i < n; i++) {
-			GlyphRun run = layout.runs.get(i);
-			Array<Glyph> glyphs = run.glyphs;
-			FloatArray xAdvances = run.xAdvances;
-			float color = run.color.toFloatBits();
-			float gx = x + run.x, gy = y + run.y;
-			for (int ii = 0, nn = glyphs.size; ii < nn; ii++) {
-				Glyph glyph = glyphs.get(ii);
-				addGlyph(glyph, gx, gy, color);
-				gx += xAdvances.get(ii);
+			while (start < end) {
+				char ch = str.charAt(start++);
+				if (ch == '[' && font.markupEnabled) {
+					if (start < end && str.charAt(start) == '[') // escaped '['
+						start++;
+					else { // non escaped '['
+						int colorTagLen = markup.parseColorTag(str, charsCount, start, end);
+						if (colorTagLen >= 0) {
+							color = markup.getLastColor().toFloatBits();
+							start += colorTagLen + 1;
+							continue;
+						}
+					}
+				}
+				Glyph g = data.getGlyph(ch);
+				if (g != null) {
+					x += lastGlyph.getKerning(ch);
+					lastGlyph = g;
+					addGlyph(lastGlyph, x + g.xoffset, y + g.yoffset, g.width, g.height);
+					x += g.xadvance;
+				}
+			}
+		} else {
+			float scaleX = data.scaleX, scaleY = data.scaleY;
+			while (start < end) {
+				char ch = str.charAt(start++);
+				if (ch == '[' && font.markupEnabled) {
+					if (start < end && str.charAt(start) == '[') // escaped '['
+						start++;
+					else { // non escaped '['
+						int colorTagLen = markup.parseColorTag(str, charsCount, start, end);
+						if (colorTagLen >= 0) {
+							color = markup.getLastColor().toFloatBits();
+							start += colorTagLen + 1;
+							continue;
+						}
+					}
+				}
+				lastGlyph = data.getGlyph(ch);
+				if (lastGlyph != null) {
+					addGlyph(lastGlyph, //
+						x + lastGlyph.xoffset * scaleX, //
+						y + lastGlyph.yoffset * scaleY, //
+						lastGlyph.width * scaleX, //
+						lastGlyph.height * scaleY);
+					x += lastGlyph.xadvance * scaleX;
+					break;
+				}
+			}
+			while (start < end) {
+				char ch = str.charAt(start++);
+				if (ch == '[' && font.markupEnabled) {
+					if (start < end && str.charAt(start) == '[') // escaped '['
+						start++;
+					else { // non escaped '['
+						int colorTagLen = markup.parseColorTag(str, charsCount, start, end);
+						if (colorTagLen >= 0) {
+							color = markup.getLastColor().toFloatBits();
+							start += colorTagLen + 1;
+							continue;
+						}
+					}
+				}
+				Glyph g = data.getGlyph(ch);
+				if (g != null) {
+					x += lastGlyph.getKerning(ch) * scaleX;
+					lastGlyph = g;
+					addGlyph(lastGlyph, //
+						x + g.xoffset * scaleX, //
+						y + g.yoffset * scaleY, //
+						g.width * scaleX, //
+						g.height * scaleY);
+					x += g.xadvance * scaleX;
+				}
 			}
 		}
-
-		currentTint = whiteTint; // Cached glyphs have changed, reset the current tint.
+		return x - startX;
 	}
 
-	private void addGlyph (Glyph glyph, float x, float y, float color) {
-		final float scaleX = font.data.scaleX, scaleY = font.data.scaleY;
-		x += glyph.xoffset * scaleX;
-		y += glyph.yoffset * scaleY;
-		final float width = glyph.width * scaleX, height = glyph.height * scaleY;
-		final float u = glyph.u, u2 = glyph.u2, v = glyph.v, v2 = glyph.v2;
+	private void addGlyph (Glyph glyph, float x, float y, float width, float height) {
+		float x2 = x + width;
+		float y2 = y + height;
+		final float u = glyph.u;
+		final float u2 = glyph.u2;
+		final float v = glyph.v;
+		final float v2 = glyph.v2;
+
+		final int page = glyph.page;
+
+		if (glyphIndices != null) {
+			glyphIndices[page].add(glyphCount++);
+		}
+
+		final float[] vertices = vertexData[page];
 
-		float x2 = x + width, y2 = y + height;
 		if (integer) {
 			x = Math.round(x);
 			y = Math.round(y);
@@ -398,13 +535,9 @@ public class BitmapFontCache {
 			y2 = Math.round(y2);
 		}
 
-		final int page = glyph.page;
 		int idx = this.idx[page];
 		this.idx[page] += 20;
 
-		if (pageGlyphIndices != null) pageGlyphIndices[page].add(glyphCount++);
-
-		final float[] vertices = pageVertices[page];
 		vertices[idx++] = x;
 		vertices[idx++] = y;
 		vertices[idx++] = color;
@@ -428,65 +561,201 @@ public class BitmapFontCache {
 		vertices[idx++] = color;
 		vertices[idx++] = u2;
 		vertices[idx] = v;
+
+		charsCount++;
 	}
 
 	/** Clears any cached glyphs and adds glyphs for the specified text.
-	 * @see #addText(CharSequence, float, float, int, int, float, int, boolean) */
-	public GlyphLayout setText (CharSequence str, float x, float y) {
+	 * @see #addText(CharSequence, float, float, int, int) */
+	public TextBounds setText (CharSequence str, float x, float y) {
 		clear();
-		return addText(str, x, y, 0, str.length(), 0, Align.left, false);
+		return addText(str, x, y, 0, str.length());
 	}
 
 	/** Clears any cached glyphs and adds glyphs for the specified text.
-	 * @see #addText(CharSequence, float, float, int, int, float, int, boolean) */
-	public GlyphLayout setText (CharSequence str, float x, float y, float targetWidth, int halign, boolean wrap) {
+	 * @see #addText(CharSequence, float, float, int, int) */
+	public TextBounds setText (CharSequence str, float x, float y, int start, int end) {
 		clear();
-		return addText(str, x, y, 0, str.length(), targetWidth, halign, wrap);
+		return addText(str, x, y, start, end);
 	}
 
-	/** Clears any cached glyphs and adds glyphs for the specified text.
-	 * @see #addText(CharSequence, float, float, int, int, float, int, boolean) */
-	public GlyphLayout setText (CharSequence str, float x, float y, int start, int end, float targetWidth, int halign, boolean wrap) {
+	/** Adds glyphs for the specified text.
+	 * @see #addText(CharSequence, float, float, int, int) */
+	public TextBounds addText (CharSequence str, float x, float y) {
+		return addText(str, x, y, 0, str.length());
+	}
+
+	/** Adds glyphs for the the specified text.
+	 * @param x The x position for the left most character.
+	 * @param y The y position for the top of most capital letters in the font (the {@link BitmapFont#getCapHeight() cap height}).
+	 * @param start The first character of the string to draw.
+	 * @param end The last character of the string to draw (exclusive).
+	 * @return The bounds of the cached string (the height is the distance from y to the baseline). */
+	public TextBounds addText (CharSequence str, float x, float y, int start, int end) {
+		requireSequence(str, start, end);
+		y += font.data.ascent;
+		textBounds.width = addToCache(str, x, y, start, end);
+		textBounds.height = font.data.capHeight;
+		return textBounds;
+	}
+
+	/** Clears any cached glyphs and adds glyphs for the specified text, which may contain newlines (\n).
+	 * @see #addMultiLineText(CharSequence, float, float, float, HAlignment) */
+	public TextBounds setMultiLineText (CharSequence str, float x, float y) {
 		clear();
-		return addText(str, x, y, start, end, targetWidth, halign, wrap);
+		return addMultiLineText(str, x, y, 0, HAlignment.LEFT);
 	}
 
-	/** Clears any cached glyphs and adds the specified glyphs.
-	 * @see #addText(CharSequence, float, float, int, int, float, int, boolean) */
-	public void setText (GlyphLayout layout, float x, float y) {
+	/** Clears any cached glyphs and adds glyphs for the specified text, which may contain newlines (\n).
+	 * @see #addMultiLineText(CharSequence, float, float, float, HAlignment) */
+	public TextBounds setMultiLineText (CharSequence str, float x, float y, float alignmentWidth, HAlignment alignment) {
 		clear();
-		addText(layout, x, y);
+		return addMultiLineText(str, x, y, alignmentWidth, alignment);
 	}
 
-	/** Adds glyphs for the specified text.
-	 * @see #addText(CharSequence, float, float, int, int, float, int, boolean) */
-	public GlyphLayout addText (CharSequence str, float x, float y) {
-		return addText(str, x, y, 0, str.length(), 0, Align.left, false);
+	/** Adds glyphs for the specified text, which may contain newlines (\n).
+	 * @see #addMultiLineText(CharSequence, float, float, float, HAlignment) */
+	public TextBounds addMultiLineText (CharSequence str, float x, float y) {
+		return addMultiLineText(str, x, y, 0, HAlignment.LEFT);
 	}
 
-	/** Adds glyphs for the specified text.
-	 * @see #addText(CharSequence, float, float, int, int, float, int, boolean) */
-	public GlyphLayout addText (CharSequence str, float x, float y, float targetWidth, int halign, boolean wrap) {
-		return addText(str, x, y, 0, str.length(), targetWidth, halign, wrap);
+	/** Adds glyphs for the specified text, which may contain newlines (\n). Each line is aligned horizontally within a rectangle of
+	 * the specified width.
+	 * @param x The x position for the left most character.
+	 * @param y The y position for the top of most capital letters in the font (the {@link BitmapFont#getCapHeight() cap height}).
+	 * @param alignment The horizontal alignment of wrapped line.
+	 * @return The bounds of the cached string (the height is the distance from y to the baseline of the last line). */
+	public TextBounds addMultiLineText (CharSequence str, float x, float y, float alignmentWidth, HAlignment alignment) {
+		BitmapFont font = this.font;
+
+		int length = str.length();
+		requireSequence(str, 0, length);
+
+		y += font.data.ascent;
+		float down = font.data.down;
+
+		float maxWidth = 0;
+		float startY = y;
+		int start = 0;
+		int numLines = 0;
+		while (start < length) {
+			int lineEnd = BitmapFont.indexOf(str, '\n', start);
+			float xOffset = 0;
+			if (alignment != HAlignment.LEFT) {
+				float lineWidth = font.getBounds(str, start, lineEnd).width;
+				xOffset = alignmentWidth - lineWidth;
+				if (alignment == HAlignment.CENTER) xOffset /= 2;
+			}
+			float lineWidth = addToCache(str, x + xOffset, y, start, lineEnd);
+			maxWidth = Math.max(maxWidth, lineWidth);
+			start = lineEnd + 1;
+			y += down;
+			numLines++;
+		}
+		textBounds.width = maxWidth;
+		textBounds.height = font.data.capHeight + (numLines - 1) * font.data.lineHeight;
+		return textBounds;
 	}
 
-	/** Adds glyphs for the the specified text.
+	/** Clears any cached glyphs and adds glyphs for the specified text, which may contain newlines (\n) and is automatically
+	 * wrapped within the specified width.
+	 * @see #addWrappedText(CharSequence, float, float, float, HAlignment) */
+	public TextBounds setWrappedText (CharSequence str, float x, float y, float wrapWidth) {
+		clear();
+		return addWrappedText(str, x, y, wrapWidth, HAlignment.LEFT);
+	}
+
+	/** Clears any cached glyphs and adds glyphs for the specified text, which may contain newlines (\n) and is automatically
+	 * wrapped within the specified width.
+	 * @see #addWrappedText(CharSequence, float, float, float, HAlignment) */
+	public TextBounds setWrappedText (CharSequence str, float x, float y, float wrapWidth, HAlignment alignment) {
+		clear();
+		return addWrappedText(str, x, y, wrapWidth, alignment);
+	}
+
+	/** Adds glyphs for the specified text, which may contain newlines (\n) and is automatically wrapped within the specified width.
+	 * @see #addWrappedText(CharSequence, float, float, float, HAlignment) */
+	public TextBounds addWrappedText (CharSequence str, float x, float y, float wrapWidth) {
+		return addWrappedText(str, x, y, wrapWidth, HAlignment.LEFT);
+	}
+
+	/** Adds glyphs for the specified text, which may contain newlines (\n) and is automatically wrapped within the specified width.
 	 * @param x The x position for the left most character.
-	 * @param y The y position for the top of most capital letters in the font (the {@link BitmapFontData#capHeight cap height}).
-	 * @param start The first character of the string to draw.
-	 * @param end The last character of the string to draw (exclusive).
-	 * @return The glyph layout for the cached string (the layout's height is the distance from y to the baseline). */
-	public GlyphLayout addText (CharSequence str, float x, float y, int start, int end, float targetWidth, int halign, boolean wrap) {
-		GlyphLayout layout = Pools.obtain(GlyphLayout.class);
-		pooledLayouts.add(layout);
-		layout.setText(font, str, start, end, color, targetWidth, halign, wrap, null);
-		addText(layout, x, y);
-		return layout;
+	 * @param y The y position for the top of most capital letters in the font (the {@link BitmapFont#getCapHeight() cap height}).
+	 * @param alignment The horizontal alignment of wrapped line.
+	 * @return The bounds of the cached string (the height is the distance from y to the baseline of the last line). */
+	public TextBounds addWrappedText (CharSequence str, float x, float y, float wrapWidth, HAlignment alignment) {
+		BitmapFont font = this.font;
+
+		int length = str.length();
+		requireSequence(str, 0, length);
+
+		y += font.data.ascent;
+		float down = font.data.down;
+
+		if (wrapWidth <= 0) wrapWidth = Integer.MAX_VALUE;
+		float maxWidth = 0;
+		int start = 0;
+		int numLines = 0;
+		while (start < length) {
+			int newLine = BitmapFont.indexOf(str, '\n', start);
+			int lineEnd = start + font.computeVisibleGlyphs(str, start, newLine, wrapWidth);
+			int nextStart = lineEnd + 1;
+			if (lineEnd < newLine) {
+				// Find char to break on.
+				while (lineEnd > start) {
+					if (BitmapFont.isWhitespace(str.charAt(lineEnd))) break;
+					if (font.isBreakChar(str.charAt(lineEnd - 1))) break;
+					lineEnd--;
+				}
+				if (lineEnd == start) {
+					if (nextStart > start + 1) nextStart--;
+					lineEnd = nextStart; // If no characters to break, show all.
+				} else {
+					nextStart = lineEnd;
+					// Eat whitespace at start of wrapped line.
+					while (nextStart < length) {
+						char c = str.charAt(nextStart);
+						if (!BitmapFont.isWhitespace(c)) break;
+						nextStart++;
+						if (c == '\n') break; // Eat only the first wrapped newline.
+					}
+					// Eat whitespace at end of line.
+					while (lineEnd > start) {
+						if (!BitmapFont.isWhitespace(str.charAt(lineEnd - 1))) break;
+						lineEnd--;
+					}
+				}
+			}
+			if (lineEnd > start) {
+				float xOffset = 0;
+				if (alignment != HAlignment.LEFT) {
+					float lineWidth = font.getBounds(str, start, lineEnd).width;
+					xOffset = wrapWidth - lineWidth;
+					if (alignment == HAlignment.CENTER) xOffset /= 2;
+				}
+				float lineWidth = addToCache(str, x + xOffset, y, start, lineEnd);
+				maxWidth = Math.max(maxWidth, lineWidth);
+			}
+			start = nextStart;
+			y += down;
+			numLines++;
+		}
+		textBounds.width = maxWidth;
+		textBounds.height = font.data.capHeight + (numLines - 1) * font.data.lineHeight;
+		return textBounds;
+	}
+
+	/** Provide any additional characters that should act as break characters when the label is wrapped. By default, only whitespace
+	 * characters act as break chars. */
+	public void setBreakChars (char[] breakChars) {
+		font.setBreakChars(breakChars);
 	}
 
-	/** Adds the specified glyphs. */
-	public void addText (GlyphLayout layout, float x, float y) {
-		addToCache(layout, x, y + font.data.ascent);
+	/** Returns the size of the cached string. The height is the distance from the top of most capital letters in the font (the
+	 * {@link BitmapFont#getCapHeight() cap height}) to the baseline of the last line of text. */
+	public TextBounds getBounds () {
+		return textBounds;
 	}
 
 	/** Returns the x position of the cached string, relative to the position when the string was cached. */
@@ -519,10 +788,11 @@ public class BitmapFontCache {
 	}
 
 	public float[] getVertices (int page) {
-		return pageVertices[page];
+		return vertexData[page];
 	}
 
-	public Array<GlyphLayout> getLayouts () {
-		return layouts;
+	/** Count of characters currently being in cache */
+	public int getCharsCount () {
+		return charsCount;
 	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/GlyphLayout.java b/gdx/src/com/badlogic/gdx/graphics/g2d/GlyphLayout.java
deleted file mode 100644
index b25f786..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/GlyphLayout.java
+++ /dev/null
@@ -1,362 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.graphics.g2d;
-
-import com.badlogic.gdx.graphics.Color;
-import com.badlogic.gdx.graphics.Colors;
-import com.badlogic.gdx.graphics.g2d.BitmapFont.BitmapFontData;
-import com.badlogic.gdx.graphics.g2d.BitmapFont.Glyph;
-import com.badlogic.gdx.utils.Align;
-import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.FloatArray;
-import com.badlogic.gdx.utils.Pool;
-import com.badlogic.gdx.utils.Pool.Poolable;
-import com.badlogic.gdx.utils.Pools;
-
-/** Stores runs of glyphs for a piece of text. The text may contain newlines and color markup tags.
- * @author Nathan Sweet
- * @author davebaol
- * @author Alexander Dorokhov */
-public class GlyphLayout implements Poolable {
-	static private final Array<Color> colorStack = new Array(4);
-
-	public final Array<GlyphRun> runs = new Array();
-	public float width, height;
-
-	/** Creates an empty GlyphLayout. */
-	public GlyphLayout () {
-	}
-
-	/** @see #setText(BitmapFont, CharSequence) */
-	public GlyphLayout (BitmapFont font, CharSequence str) {
-		setText(font, str);
-	}
-
-	/** @see #setText(BitmapFont, CharSequence) */
-	public GlyphLayout (BitmapFont font, CharSequence str, Color color, float targetWidth, int halign, boolean wrap) {
-		setText(font, str, color, targetWidth, halign, wrap);
-	}
-
-	/** @see #setText(BitmapFont, CharSequence) */
-	public GlyphLayout (BitmapFont font, CharSequence str, int start, int end, Color color, float targetWidth, int halign,
-		boolean wrap, String truncate) {
-		setText(font, str, start, end, color, targetWidth, halign, wrap, truncate);
-	}
-
-	/** Calls {@link #setText(BitmapFont, CharSequence, int, int, Color, float, int, boolean, String) setText} with the whole
-	 * string, the font's current color, and no alignment or wrapping. */
-	public void setText (BitmapFont font, CharSequence str) {
-		setText(font, str, 0, str.length(), font.getColor(), 0, Align.left, false, null);
-	}
-
-	/** Calls {@link #setText(BitmapFont, CharSequence, int, int, Color, float, int, boolean, String) setText} with the whole string
-	 * and no truncation. */
-	public void setText (BitmapFont font, CharSequence str, Color color, float targetWidth, int halign, boolean wrap) {
-		setText(font, str, 0, str.length(), color, targetWidth, halign, wrap, null);
-	}
-
-	/** @param color The default color to use for the text. If {@link BitmapFontData#markupEnabled} is true, color markup tags in the
-	 *           specified string may change the color for portions of the text.
-	 * @param targetWidth The width used for alignment, line wrapping, and truncation. May be zero if those features are not used.
-	 * @param truncate If not null and the width of the glyphs exceed targetWidth, the glyphs are truncated and the glyphs for the
-	 *           specified truncate string are placed at the end. Empty string can be used to truncate without adding glyphs. */
-	public void setText (BitmapFont font, CharSequence str, int start, int end, Color color, float targetWidth, int halign,
-		boolean wrap, String truncate) {
-		if (targetWidth == 0) wrap = false; // Avoid wrapping every character to it's own line/run, which is very inefficient.
-		if (truncate != null) wrap = true; // Causes truncate code to run, doesn't actually cause wrapping.
-
-		BitmapFontData fontData = font.data;
-		boolean markupEnabled = fontData.markupEnabled;
-
-		Pool<GlyphRun> glyphRunPool = Pools.get(GlyphRun.class);
-		glyphRunPool.freeAll(runs);
-		runs.clear();
-
-		float x = 0, y = 0, width = 0;
-		int lines = 0;
-
-		Color nextColor = color;
-		colorStack.add(color);
-		Pool<Color> colorPool = Pools.get(Color.class);
-
-		int runStart = start;
-		outer:
-		while (true) {
-			// Each run is delimited by newline or left square bracket.
-			int runEnd = -1;
-			boolean newline = false;
-			if (start == end) {
-				if (runStart == end) break; // End of string with no run to process, we're done.
-				runEnd = end; // End of string, process last run.
-			} else {
-				switch (str.charAt(start++)) {
-				case '\n':
-					// End of line.
-					runEnd = start - 1;
-					newline = true;
-					break;
-				case '[':
-					// Possible color tag.
-					if (markupEnabled) {
-						int length = parseColorMarkup(str, start, end, colorPool);
-						if (length >= 0) {
-							runEnd = start - 1;
-							start += length + 1;
-							nextColor = colorStack.peek();
-						}
-					}
-					break;
-				}
-			}
-
-			if (runEnd != -1) {
-				// Store the run that has ended.
-				GlyphRun run = glyphRunPool.obtain();
-				runs.add(run);
-				run.color.set(color);
-				run.x = x;
-				run.y = y;
-				fontData.getGlyphs(run, str, runStart, runEnd);
-
-				// Compute the run width, wrap if necessary, and position the run.
-				FloatArray xAdvances = run.xAdvances;
-				for (int i = 0, n = xAdvances.size; i < n; i++) {
-					float xAdvance = xAdvances.get(i);
-					x += xAdvance;
-					// Don't wrap if the glyph would fit with just its width (no x-advance or kerning).
-					if (wrap && x > targetWidth && i > 0 && x - (xAdvance - run.glyphs.get(i).width) > targetWidth) {
-						if (truncate != null) {
-							truncate(fontData, run, targetWidth, truncate, i, glyphRunPool);
-							break outer;
-						}
-
-						GlyphRun next = glyphRunPool.obtain();
-						runs.add(next);
-						wrap(fontData, run, next, Math.max(1, fontData.getWrapIndex(run.glyphs, i)), i);
-
-						// Start the loop over with the new run on the next line.
-						width = Math.max(width, run.width);
-						x = 0;
-						y += fontData.down;
-						lines++;
-						next.x = 0;
-						next.y = y;
-						i = -1;
-						n = next.xAdvances.size;
-						xAdvances = next.xAdvances;
-						run = next;
-					} else
-						run.width += xAdvance;
-				}
-
-				if (newline) {
-					width = Math.max(width, x);
-					x = 0;
-					y += fontData.down;
-					lines++;
-				}
-
-				runStart = start;
-				color = nextColor;
-			}
-		}
-		width = Math.max(width, x);
-
-		for (int i = 1, n = colorStack.size; i < n; i++)
-			colorPool.free(colorStack.get(i));
-		colorStack.clear();
-
-		// Align runs to center or right of targetWidth.
-		if ((halign & Align.left) == 0) { // Not left aligned, so must be center or right aligned.
-			boolean center = (halign & Align.center) != 0;
-			float lineWidth = 0, lineY = Integer.MIN_VALUE;
-			int lineStart = 0, n = runs.size;
-			for (int i = 0; i < n; i++) {
-				GlyphRun run = runs.get(i);
-				if (run.y != lineY) {
-					lineY = run.y;
-					float shift = targetWidth - lineWidth;
-					if (center) shift /= 2;
-					while (lineStart < i)
-						runs.get(lineStart++).x += shift;
-					lineWidth = 0;
-				}
-				lineWidth += run.width;
-			}
-			float shift = targetWidth - lineWidth;
-			if (center) shift /= 2;
-			while (lineStart < n)
-				runs.get(lineStart++).x += shift;
-		}
-
-		this.width = width;
-		this.height = fontData.capHeight + lines * fontData.lineHeight;
-	}
-
-	private void truncate (BitmapFontData fontData, GlyphRun run, float targetWidth, String truncate, int widthIndex,
-		Pool<GlyphRun> glyphRunPool) {
-
-		GlyphRun truncateRun = glyphRunPool.obtain();
-		fontData.getGlyphs(truncateRun, truncate, 0, truncate.length());
-
-		// Truncate glyphs to make room.
-		float truncateWidth = targetWidth;
-		int n = truncateRun.glyphs.size;
-		for (int i = 0; i < n; i++)
-			truncateWidth -= truncateRun.xAdvances.get(i);
-		while (run.width > truncateWidth) {
-			widthIndex--;
-			run.width -= run.xAdvances.get(widthIndex);
-		}
-		run.glyphs.truncate(widthIndex);
-		run.xAdvances.truncate(widthIndex);
-
-		// Append truncate glyphs.
-		run.glyphs.addAll(truncateRun.glyphs);
-		run.xAdvances.addAll(truncateRun.xAdvances);
-		run.width += truncateWidth;
-
-		glyphRunPool.free(truncateRun);
-	}
-
-	private int parseColorMarkup (CharSequence str, int start, int end, Pool<Color> colorPool) {
-		if (start == end) return -1; // String ended with "[".
-		switch (str.charAt(start)) {
-		case '#':
-			// Parse hex color RRGGBBAA where AA is optional and defaults to 0xFF if less than 6 chars are used.
-			int colorInt = 0;
-			for (int i = start + 1; i < end; i++) {
-				char ch = str.charAt(i);
-				if (ch == ']') {
-					if (i < start + 2 || i > start + 9) break; // Illegal number of hex digits.
-					Color color = colorPool.obtain();
-					colorStack.add(color);
-					Color.rgb888ToColor(color, colorInt);
-					if (i <= start + 7) color.a = 1f; // RRGGBB
-					return i - start;
-				}
-				if (ch >= '0' && ch <= '9')
-					colorInt = colorInt * 16 + (ch - '0');
-				else if (ch >= 'a' && ch <= 'f')
-					colorInt = colorInt * 16 + (ch - ('a' - 10));
-				else if (ch >= 'A' && ch <= 'F')
-					colorInt = colorInt * 16 + (ch - ('A' - 10));
-				else
-					break; // Unexpected character in hex color.
-			}
-			return -1;
-		case '[': // "[[" is an escaped left square bracket.
-			return -1;
-		case ']': // "[]" is a "pop" color tag.
-			if (colorStack.size > 1) colorPool.free(colorStack.pop());
-			return 0;
-		}
-		// Parse named color.
-		int colorStart = start;
-		for (int i = start + 1; i < end; i++) {
-			char ch = str.charAt(i);
-			if (ch != ']') continue;
-			Color namedColor = Colors.get(str.subSequence(colorStart, i).toString());
-			if (namedColor == null) return -1; // Unknown color name.
-			Color color = colorPool.obtain();
-			colorStack.add(color);
-			color.set(namedColor);
-			return i - start;
-		}
-		return -1; // Unclosed color tag.
-	}
-
-	private void wrap (BitmapFontData fontData, GlyphRun first, GlyphRun second, int wrapIndex, int widthIndex) {
-		second.color.set(first.color);
-
-		// Reduce first run width by wrapped glyphs.
-		while (widthIndex-- > wrapIndex)
-			first.width -= first.xAdvances.get(widthIndex);
-
-		// Wrap glyphs and xAdvances.
-		second.glyphs.addAll(first.glyphs, wrapIndex, first.glyphs.size - wrapIndex);
-		second.xAdvances.addAll(first.xAdvances, wrapIndex, first.xAdvances.size - wrapIndex);
-		first.glyphs.truncate(wrapIndex);
-		first.xAdvances.truncate(wrapIndex);
-
-		// Eat whitespace at end of first run.
-		for (int i = wrapIndex - 1; i >= 0; i--) {
-			char ch = (char)first.glyphs.get(i).id;
-			if (fontData.isWhitespace(ch)) {
-				first.width -= first.xAdvances.get(i);
-				continue;
-			}
-			if (i > 0) {
-				first.glyphs.truncate(i + 1);
-				first.xAdvances.truncate(i + 1);
-			}
-			break;
-		}
-	}
-
-	public void reset () {
-		Pools.get(GlyphRun.class).freeAll(runs);
-		runs.clear();
-
-		width = 0;
-		height = 0;
-	}
-
-	public String toString () {
-		if (runs.size == 0) return "";
-		StringBuilder buffer = new StringBuilder(128);
-		for (int i = 0, n = runs.size; i < n; i++) {
-			buffer.append(runs.get(i).toString());
-			buffer.append('\n');
-		}
-		buffer.setLength(buffer.length() - 1);
-		return buffer.toString();
-	}
-
-	/** Stores glyphs and positions for a piece of text.
-	 * @author Nathan Sweet */
-	static public class GlyphRun implements Poolable {
-		public final Array<Glyph> glyphs = new Array();
-		public final FloatArray xAdvances = new FloatArray(); // X advance relative to previous glyph.
-		public float x, y, width;
-		public final Color color = new Color();
-
-		public void reset () {
-			glyphs.clear();
-			xAdvances.clear();
-			width = 0;
-		}
-
-		public String toString () {
-			StringBuilder buffer = new StringBuilder(glyphs.size);
-			Array<Glyph> glyphs = this.glyphs;
-			for (int i = 0, n = glyphs.size; i < n; i++) {
-				Glyph g = glyphs.get(i);
-				buffer.append((char)g.id);
-			}
-			buffer.append(", #");
-			buffer.append(color);
-			buffer.append(", ");
-			buffer.append(x);
-			buffer.append(", ");
-			buffer.append(y);
-			buffer.append(", ");
-			buffer.append(width);
-			return buffer.toString();
-		}
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/PolygonSpriteBatch.java b/gdx/src/com/badlogic/gdx/graphics/g2d/PolygonSpriteBatch.java
index 94ed08f..b507332 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/PolygonSpriteBatch.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/PolygonSpriteBatch.java
@@ -114,11 +114,7 @@ public class PolygonSpriteBatch implements Batch {
 		// 32767 is max index, so 32767 / 3 - (32767 / 3 % 3) = 10920.
 		if (size > 10920) throw new IllegalArgumentException("Can't have more than 10920 triangles per batch: " + size);
 
-		Mesh.VertexDataType vertexDataType = Mesh.VertexDataType.VertexArray;
-		if (Gdx.gl30 != null) {
-			vertexDataType = VertexDataType.VertexBufferObjectWithVAO;
-		}
-		mesh = new Mesh(vertexDataType, false, size, size * 3, new VertexAttribute(Usage.Position, 2,
+		mesh = new Mesh(VertexDataType.VertexArray, false, size, size * 3, new VertexAttribute(Usage.Position, 2,
 			ShaderProgram.POSITION_ATTRIBUTE), new VertexAttribute(Usage.ColorPacked, 4, ShaderProgram.COLOR_ATTRIBUTE),
 			new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + "0"));
 
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteBatch.java b/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteBatch.java
index b05d3f4..fa945a3 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteBatch.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteBatch.java
@@ -92,11 +92,7 @@ public class SpriteBatch implements Batch {
 		// 32767 is max index, so 32767 / 6 - (32767 / 6 % 3) = 5460.
 		if (size > 5460) throw new IllegalArgumentException("Can't have more than 5460 sprites per batch: " + size);
 
-		Mesh.VertexDataType vertexDataType = Mesh.VertexDataType.VertexArray;
-		if (Gdx.gl30 != null) {
-			vertexDataType = Mesh.VertexDataType.VertexBufferObjectWithVAO;
-		}
-		mesh = new Mesh(vertexDataType, false, size * 4, size * 6, new VertexAttribute(Usage.Position, 2,
+		mesh = new Mesh(VertexDataType.VertexArray, false, size * 4, size * 6, new VertexAttribute(Usage.Position, 2,
 			ShaderProgram.POSITION_ATTRIBUTE), new VertexAttribute(Usage.ColorPacked, 4, ShaderProgram.COLOR_ATTRIBUTE),
 			new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + "0"));
 
diff --git a/gdx/src/com/badlogic/gdx/graphics/g2d/TextMarkup.java b/gdx/src/com/badlogic/gdx/graphics/g2d/TextMarkup.java
new file mode 100644
index 0000000..cdf0dae
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/g2d/TextMarkup.java
@@ -0,0 +1,202 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.g2d;
+
+import com.badlogic.gdx.Application;
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.Color;
+import com.badlogic.gdx.graphics.Colors;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.NumberUtils;
+import com.badlogic.gdx.utils.Pool;
+import com.badlogic.gdx.utils.StringBuilder;
+
+/** @see com.badlogic.gdx.graphics.g2d.BitmapFontCache
+ *
+ * @author davebaol
+ * @author Alexander Dorokhov */
+class TextMarkup {
+	private static final Color tempColor = new Color();
+	private static final StringBuilder tempColorBuffer = new StringBuilder();
+
+	/** Parses a color tag.
+	 * @param str the input string
+	 * @param nomarkupStart the index of the string, excluding characters used to markup the text, where color info will be added.
+	 *           if it's negative color info is not set.
+	 * @param start the begin index
+	 * @param end the end index
+	 * @return the number of characters in the tag; {@code -1} in case of unknown color. */
+	public int parseColorTag (CharSequence str, int nomarkupStart, int start, int end) {
+		if (start < end) {
+			final Color hexColor = tempColor;
+			if (str.charAt(start) == '#') {
+				// Parse hex color RRGGBBAA where AA is optional and defaults to 0xFF if less than 6 chars are used
+				int colorInt = 0;
+				for (int i = start + 1; i < end; i++) {
+					char ch = str.charAt(i);
+					if (ch == ']') {
+						if (i < start + 2 || i > start + 9) return -1; // Illegal number of hex digits
+						if (i <= start + 7) { // RRGGBB
+							Color.rgb888ToColor(hexColor, colorInt);
+							hexColor.a = 1f;
+						} else { // RRGGBBAA
+							Color.rgba8888ToColor(hexColor, colorInt);
+						}
+						if (nomarkupStart >= 0) beginChunk(hexColor, nomarkupStart);
+						return i - start;
+					}
+					if (ch >= '0' && ch <= '9')
+						colorInt = colorInt * 16 + (ch - '0');
+					else if (ch >= 'a' && ch <= 'f')
+						colorInt = colorInt * 16 + (ch - ('a' - 10));
+					else if (ch >= 'A' && ch <= 'F')
+						colorInt = colorInt * 16 + (ch - ('A' - 10));
+					else
+						return -1; // Unexpected character in hex color
+				}
+			} else {
+				// Parse named color
+				tempColorBuffer.setLength(0);
+				for (int i = start; i < end; i++) {
+					char ch = str.charAt(i);
+					if (ch == ']') {
+						if (i == start) { // end tag []
+							if (nomarkupStart >= 0) endChunk(nomarkupStart);
+						} else {
+							String colorString = tempColorBuffer.toString();
+							Color newColor = Colors.get(colorString);
+							if (newColor == null) return -1; // Unknown color
+							if (nomarkupStart >= 0) beginChunk(newColor, nomarkupStart);
+						}
+						return i - start;
+					} else {
+						tempColorBuffer.append(ch);
+					}
+				}
+			}
+		}
+		return -1; // Unclosed color tag
+	}
+
+	private static Pool<ColorChunk> colorChunkPool;
+	private static Application app = null;
+
+	private Array<ColorChunk> colorChunks = new Array<ColorChunk>();
+	private Array<Color> currentColorStack = new Array<Color>();
+	private Color lastColor = Color.WHITE;
+	private Color defaultColor = Color.WHITE;
+
+	public TextMarkup () {
+		if (Gdx.app != app) {
+			colorChunkPool = new Pool<ColorChunk>(32) {
+				protected ColorChunk newObject () {
+					return new ColorChunk();
+				}
+			};
+			app = Gdx.app;
+		}
+	}
+
+	public void beginChunk (Color color, int start) {
+		ColorChunk newChunk = colorChunkPool.obtain();
+		newChunk.color.set(color);
+		newChunk.start = start;
+		colorChunks.add(newChunk);
+		currentColorStack.add(lastColor);
+		lastColor = newChunk.color;
+	}
+
+	public void endChunk (int start) {
+		if (currentColorStack.size > 0) {
+			lastColor = currentColorStack.pop();
+			ColorChunk newChunk = colorChunkPool.obtain();
+			newChunk.color.set(lastColor);
+			newChunk.start = start;
+			colorChunks.add(newChunk);
+		}
+	}
+
+	public void tint (BitmapFontCache cache, Color tint) {
+		int current = 0;
+		float floatColor = tempColor.set(defaultColor).mul(tint).toFloatBits();
+		for (ColorChunk chunk : colorChunks) {
+			int next = chunk.start;
+			if (current < next) {
+				cache.setColors(floatColor, current, next);
+				current = next;
+			}
+			floatColor = tempColor.set(chunk.color).mul(tint).toFloatBits();
+		}
+		int charsCount = cache.getCharsCount();
+		if (current < charsCount) {
+			cache.setColors(floatColor, current, charsCount);
+		}
+	}
+
+	/** Removes all the color chunks from the list and releases them to the internal pool */
+	public void clear () {
+		final int size = colorChunks.size;
+		for (int i = 0; i < size; i++) {
+			colorChunkPool.free(colorChunks.get(i));
+			colorChunks.set(i, null);
+		}
+		colorChunks.size = 0;
+		currentColorStack.clear();
+		setDefaultChunk(defaultColor, 0);
+	}
+
+	public Color getLastColor () {
+		return lastColor;
+	}
+
+	private void setDefaultColor (Color defaultColor) {
+		if (currentColorStack.size == 0) {
+			this.defaultColor = defaultColor;
+			this.lastColor = defaultColor;
+		}
+	}
+
+	public void setDefaultChunk (float color, int start) {
+		int abgr = NumberUtils.floatToIntColor(color);
+		setDefaultChunk(abgr, start);
+	}
+
+	public void setDefaultChunk (int abgr, int start) {
+		ColorChunk newChunk = colorChunkPool.obtain();
+		Color color = newChunk.color;
+		color.r = (abgr & 0xff) / 255f;
+		color.g = ((abgr >>> 8) & 0xff) / 255f;
+		color.b = ((abgr >>> 16) & 0xff) / 255f;
+		color.a = ((abgr >>> 24) & 0xff) / 255f;
+		newChunk.start = start;
+		colorChunks.add(newChunk);
+		setDefaultColor(newChunk.color);
+	}
+
+	public void setDefaultChunk (Color color, int start) {
+		ColorChunk newChunk = colorChunkPool.obtain();
+		newChunk.color.set(color);
+		newChunk.start = start;
+		colorChunks.add(newChunk);
+		setDefaultColor(newChunk.color);
+	}
+
+	public static class ColorChunk {
+		public int start;
+		public final Color color = new Color();
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/Attribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/Attribute.java
index b03a001..dda510c 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/Attribute.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/Attribute.java
@@ -22,7 +22,7 @@ import com.badlogic.gdx.utils.Array;
  * {@link #register(String)} method, whose return value should be used to instantiate the attribute. A class can implement
  * multiple types
  * @author Xoppa */
-public abstract class Attribute implements Comparable<Attribute> {
+public abstract class Attribute {
 	/** The registered type aliases */
 	private final static Array<String> types = new Array<String>();
 
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/Attributes.java b/gdx/src/com/badlogic/gdx/graphics/g3d/Attributes.java
index 79224f4..4608d2e 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/Attributes.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/Attributes.java
@@ -21,7 +21,7 @@ import java.util.Iterator;
 
 import com.badlogic.gdx.utils.Array;
 
-public class Attributes implements Iterable<Attribute>, Comparator<Attribute>, Comparable<Attributes> {
+public class Attributes implements Iterable<Attribute>, Comparator<Attribute> {
 	protected long mask;
 	protected final Array<Attribute> attributes = new Array<Attribute>();
 
@@ -132,7 +132,7 @@ public class Attributes implements Iterable<Attribute>, Comparator<Attribute>, C
 	/** Removes the attribute from the material, i.e.: material.remove(BlendingAttribute.ID); Can also be used to remove multiple
 	 * attributes also, i.e. remove(AttributeA.ID | AttributeB.ID); */
 	public final void remove (final long mask) {
-		for (int i = attributes.size - 1; i >= 0; i--) {
+		for (int i = 0; i < attributes.size; i++) {
 			final long type = attributes.get(i).type;
 			if ((mask & type) == type) {
 				attributes.removeIndex(i);
@@ -177,7 +177,7 @@ public class Attributes implements Iterable<Attribute>, Comparator<Attribute>, C
 		return same(other, false);
 	}
 
-	/** Used for sorting attributes by type (not by value) */
+	/** Used for sorting attributes */
 	@Override
 	public final int compare (final Attribute arg0, final Attribute arg1) {
 		return (int)(arg0.type - arg1.type);
@@ -188,44 +188,23 @@ public class Attributes implements Iterable<Attribute>, Comparator<Attribute>, C
 	public final Iterator<Attribute> iterator () {
 		return attributes.iterator();
 	}
-
-	/** @return A hash code based on only the attribute values, which might be different compared to {@link #hashCode()} because the latter
-	 * might include other properties as well, i.e. the material id. */
-	public int attributesHash () {
+	
+	@Override
+	public int hashCode () {
 		sort();
 		final int n = attributes.size;
-		long result = 71 + mask;
+		int result = 71 + (int)mask;
 		int m = 1;
 		for (int i = 0; i < n; i++)
 			result += mask * attributes.get(i).hashCode() * (m = (m * 7) & 0xFFFF);
-		return (int)(result ^ (result >> 32));
+		return result;
 	}
-
-	@Override
-	public int hashCode () {
-		return attributesHash();
-	}
-
+	
 	@Override
 	public boolean equals (Object other) {
-		if (!(other instanceof Attributes)) return false;
+		if (other == null) return false;
 		if (other == this) return true;
-		return same((Attributes)other, true);
-	}
-
-	@Override
-	public int compareTo (Attributes other) {
-		if (other == this)
-			return 0;
-		if (mask != other.mask)
-			return mask < other.mask ? -1 : 1;
-		sort();
-		other.sort();
-		for (int i = 0; i < attributes.size; i++) {
-			final int c = attributes.get(i).compareTo(other.attributes.get(i));
-			if (c != 0)
-				return c;
-		}
-		return 0;
+		if (!(other instanceof Attributes)) return false;
+		return hashCode() == other.hashCode();
 	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/Material.java b/gdx/src/com/badlogic/gdx/graphics/g3d/Material.java
index bd39056..fa811c3 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/Material.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/Material.java
@@ -16,7 +16,12 @@
 
 package com.badlogic.gdx.graphics.g3d;
 
+import java.util.Comparator;
+import java.util.Iterator;
+
+import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.Disposable;
 
 public class Material extends Attributes {
 	private static int counter = 0;
@@ -78,9 +83,4 @@ public class Material extends Attributes {
 	public int hashCode () {
 		return super.hashCode() + 3 * id.hashCode();
 	}
-	
-	@Override
-	public boolean equals (Object other) {
-		return (other instanceof Material) && ((other == this) || ((((Material)other).id.equals(id)) && super.equals(other)));
-	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/BlendingAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/BlendingAttribute.java
index 0be46c4..382ab6c 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/BlendingAttribute.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/BlendingAttribute.java
@@ -18,7 +18,6 @@ package com.badlogic.gdx.graphics.g3d.attributes;
 
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.g3d.Attribute;
-import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.utils.NumberUtils;
 
 public class BlendingAttribute extends Attribute {
@@ -77,7 +76,7 @@ public class BlendingAttribute extends Attribute {
 	public BlendingAttribute copy () {
 		return new BlendingAttribute(this);
 	}
-
+	
 	@Override
 	public int hashCode () {
 		int result = super.hashCode();
@@ -85,16 +84,6 @@ public class BlendingAttribute extends Attribute {
 		result = 947 * result + sourceFunction;
 		result = 947 * result + destFunction;
 		result = 947 * result + NumberUtils.floatToRawIntBits(opacity);
-		return result;
-	}
-
-	@Override
-	public int compareTo (Attribute o) {
-		if (type != o.type) return (int)(type - o.type);
-		BlendingAttribute other = (BlendingAttribute)o;
-		if (blended != other.blended) return blended ? 1 : -1;
-		if (sourceFunction != other.sourceFunction) return sourceFunction - other.sourceFunction;
-		if (destFunction != other.destFunction) return destFunction - other.destFunction;
-		return (MathUtils.isEqual(opacity, other.opacity)) ? 0 : (opacity < other.opacity ? 1 : -1);
+		return result; 
 	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/ColorAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/ColorAttribute.java
index 503949a..9be2516 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/ColorAttribute.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/ColorAttribute.java
@@ -103,13 +103,7 @@ public class ColorAttribute extends Attribute {
 	@Override
 	public int hashCode () {
 		int result = super.hashCode();
-		result = 953 * result + color.toIntBits();
+		result = 953 * result + color.hashCode();
 		return result; 
 	}
-	
-	@Override
-	public int compareTo (Attribute o) {
-		if (type != o.type) return (int)(type - o.type);
-		return ((ColorAttribute)o).color.toIntBits() - color.toIntBits();
-	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/CubemapAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/CubemapAttribute.java
index 30fd027..8033bf4 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/CubemapAttribute.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/CubemapAttribute.java
@@ -17,6 +17,7 @@
 package com.badlogic.gdx.graphics.g3d.attributes;
 
 import com.badlogic.gdx.graphics.Cubemap;
+import com.badlogic.gdx.graphics.GLTexture;
 import com.badlogic.gdx.graphics.g3d.Attribute;
 import com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor;
 import com.badlogic.gdx.utils.GdxRuntimeException;
@@ -25,6 +26,10 @@ public class CubemapAttribute extends Attribute {
 	public final static String EnvironmentMapAlias = "environmentMapTexture";
 	public final static long EnvironmentMap = register(EnvironmentMapAlias);
 
+	// FIXME add more types!
+	// FIXME add scaling + offset?
+	// FIXME add filter settings? MipMap needs to be obeyed during loading :/
+
 	protected static long Mask = EnvironmentMap;
 
 	public final static boolean is (final long mask) {
@@ -64,10 +69,4 @@ public class CubemapAttribute extends Attribute {
 		result = 967 * result + textureDescription.hashCode();
 		return result;
 	}
-	
-	@Override
-	public int compareTo (Attribute o) {
-		if (type != o.type) return (int)(type - o.type);
-		return textureDescription.compareTo(((CubemapAttribute)o).textureDescription);
-	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/DepthTestAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/DepthTestAttribute.java
index 3e8c9fb..e890d66 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/DepthTestAttribute.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/DepthTestAttribute.java
@@ -18,7 +18,6 @@ package com.badlogic.gdx.graphics.g3d.attributes;
 
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.g3d.Attribute;
-import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 import com.badlogic.gdx.utils.NumberUtils;
 
@@ -92,17 +91,4 @@ public class DepthTestAttribute extends Attribute {
 		result = 971 * result + (depthMask ? 1 : 0);
 		return result; 
 	}
-	
-	@Override
-	public int compareTo (Attribute o) {
-		if (type != o.type) return (int)(type - o.type);
-		DepthTestAttribute other = (DepthTestAttribute)o;
-		if (depthFunc != other.depthFunc) return depthFunc - other.depthFunc;
-		if (depthMask != other.depthMask) return depthMask ? -1 : 1;
-		if (!MathUtils.isEqual(depthRangeNear, other.depthRangeNear))
-			return depthRangeNear < other.depthRangeNear ? -1 : 1;
-		if (!MathUtils.isEqual(depthRangeFar, other.depthRangeFar))
-			return depthRangeFar < other.depthRangeFar ? -1 : 1;
-		return 0;
-	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/FloatAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/FloatAttribute.java
index 1b62b70..011c768 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/FloatAttribute.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/FloatAttribute.java
@@ -17,7 +17,7 @@
 package com.badlogic.gdx.graphics.g3d.attributes;
 
 import com.badlogic.gdx.graphics.g3d.Attribute;
-import com.badlogic.gdx.math.MathUtils;
+import com.badlogic.gdx.utils.GdxRuntimeException;
 import com.badlogic.gdx.utils.NumberUtils;
 
 public class FloatAttribute extends Attribute {
@@ -57,11 +57,4 @@ public class FloatAttribute extends Attribute {
 		result = 977 * result + NumberUtils.floatToRawIntBits(value);
 		return result; 
 	}
-	
-	@Override
-	public int compareTo (Attribute o) {
-		if (type != o.type) return (int)(type - o.type);
-		final float v = ((FloatAttribute)o).value;
-		return MathUtils.isEqual(value, v) ? 0 : value < v ? -1 : 1;
-	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/IntAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/IntAttribute.java
index 1056c96..3339ba1 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/IntAttribute.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/IntAttribute.java
@@ -48,10 +48,4 @@ public class IntAttribute extends Attribute {
 		result = 983 * result + value;
 		return result; 
 	}
-	
-	@Override
-	public int compareTo (Attribute o) {
-		if (type != o.type) return (int)(type - o.type);
-		return value - ((IntAttribute)o).value;
-	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/TextureAttribute.java b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/TextureAttribute.java
index 4a76113..9b198bb 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/TextureAttribute.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/attributes/TextureAttribute.java
@@ -16,11 +16,11 @@
 
 package com.badlogic.gdx.graphics.g3d.attributes;
 
+import com.badlogic.gdx.graphics.GLTexture;
 import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.graphics.g2d.TextureRegion;
 import com.badlogic.gdx.graphics.g3d.Attribute;
 import com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor;
-import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 import com.badlogic.gdx.utils.NumberUtils;
 
@@ -174,21 +174,7 @@ public class TextureAttribute extends Attribute {
 		result = 991 * result + NumberUtils.floatToRawIntBits(offsetV);
 		result = 991 * result + NumberUtils.floatToRawIntBits(scaleU);
 		result = 991 * result + NumberUtils.floatToRawIntBits(scaleV);
-		result = 991 * result + uvIndex;
+		result = 991 * result + NumberUtils.floatToRawIntBits(uvIndex);
 		return result;
 	}
-	
-	@Override
-	public int compareTo (Attribute o) {
-		if (type != o.type) return type < o.type ? -1 : 1;
-		TextureAttribute other = (TextureAttribute)o;
-		final int c = textureDescription.compareTo(other.textureDescription);
-		if (c != 0) return c;
-		if (uvIndex != other.uvIndex) return uvIndex - other.uvIndex;
-		if (!MathUtils.isEqual(offsetU, other.offsetU)) return offsetU < other.offsetU ? 1 : -1;
-		if (!MathUtils.isEqual(offsetV, other.offsetV)) return offsetV < other.offsetV ? 1 : -1;
-		if (!MathUtils.isEqual(scaleU, other.scaleU)) return scaleU < other.scaleU ? 1 : -1;
-		if (!MathUtils.isEqual(scaleV, other.scaleV)) return scaleV < other.scaleV ? 1 : -1;
-		return 0;
-	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/decals/DecalBatch.java b/gdx/src/com/badlogic/gdx/graphics/g3d/decals/DecalBatch.java
index 86a02b7..94df4c7 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/decals/DecalBatch.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/decals/DecalBatch.java
@@ -16,7 +16,6 @@
 
 package com.badlogic.gdx.graphics.g3d.decals;
 
-import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.Mesh;
 import com.badlogic.gdx.graphics.VertexAttribute;
@@ -87,15 +86,10 @@ public class DecalBatch implements Disposable {
 	 * @param size Maximum size of decal objects to hold in memory */
 	public void initialize (int size) {
 		vertices = new float[size * Decal.SIZE];
-
-		Mesh.VertexDataType vertexDataType = Mesh.VertexDataType.VertexArray;
-		if(Gdx.gl30 != null) {
-			vertexDataType = Mesh.VertexDataType.VertexBufferObjectWithVAO;
-		}
-		mesh = new Mesh(vertexDataType, false, size * 4, size * 6, new VertexAttribute(
-				VertexAttributes.Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE), new VertexAttribute(
-				VertexAttributes.Usage.ColorPacked, 4, ShaderProgram.COLOR_ATTRIBUTE), new VertexAttribute(
-				VertexAttributes.Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + "0"));
+		mesh = new Mesh(Mesh.VertexDataType.VertexArray, false, size * 4, size * 6, new VertexAttribute(
+			VertexAttributes.Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE), new VertexAttribute(
+			VertexAttributes.Usage.ColorPacked, 4, ShaderProgram.COLOR_ATTRIBUTE), new VertexAttribute(
+			VertexAttributes.Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + "0"));
 
 		short[] indices = new short[size * 6];
 		int v = 0;
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/loader/ObjLoader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/loader/ObjLoader.java
index cb19210..cd9ea7b 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/loader/ObjLoader.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/loader/ObjLoader.java
@@ -90,6 +90,27 @@ public class ObjLoader extends ModelLoader<ObjLoader.ObjLoaderParameters> {
 		super(resolver);
 	}
 
+	/** @deprecated Use {@link ObjLoader#loadModel(FileHandle)} instead.
+	 *             <p>
+	 *             Loads a Wavefront OBJ file from a given file handle.
+	 * 
+	 * @param file the FileHandle */
+	@Deprecated
+ 	public Model loadObj (FileHandle file) {
+		return loadModel(file);
+	}
+
+	/** @deprecated Use {@link ObjLoader#loadModel(FileHandle, boolean)} instead.
+	 *             <p>
+	 *             Loads a Wavefront OBJ file from a given file handle.
+	 * 
+	 * @param file the FileHandle
+	 * @param flipV whether to flip the v texture coordinate (Blender, Wings3D, et al) */
+	@Deprecated
+ 	public Model loadObj (FileHandle file, boolean flipV) {
+		return loadModel(file, flipV);
+	}
+
 	/** Directly load the model on the calling thread. The model with not be managed by an {@link AssetManager}. */
 	public Model loadModel (final FileHandle fileHandle, boolean flipV) {
 		return loadModel(fileHandle, new ObjLoaderParameters(flipV));
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/model/Node.java b/gdx/src/com/badlogic/gdx/graphics/g3d/model/Node.java
index dc0a786..3208eef 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/model/Node.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/model/Node.java
@@ -31,6 +31,10 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
 public class Node {
 	/** the id, may be null, FIXME is this unique? **/
 	public String id;
+	/** @deprecated Use {@link #getParent()} instead. **/
+	@Deprecated public Node parent; // TODO: Make private
+	/** @deprecated Use {@link #getChildren()} instead. **/
+	@Deprecated public final Array<Node> children = new Array<Node>(2); // TODO: Make private
 	/** Whether this node should inherit the transformation of its parent node, defaults to true. When this flag is false the value
 	 * of {@link #globalTransform} will be the same as the value of {@link #localTransform} causing the transform to be independent
 	 * of its parent transform. */
@@ -50,9 +54,6 @@ public class Node {
 	public final Matrix4 globalTransform = new Matrix4();
 
 	public Array<NodePart> parts = new Array<NodePart>(2);
-	
-	protected Node parent;
-	private final Array<Node> children = new Array<Node>(2);
 
 	/** Calculates the local transform based on the translation, scale and rotation
 	 * @return the local transform */
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleEffectLoader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleEffectLoader.java
index 2dc0798..33cf656 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleEffectLoader.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ParticleEffectLoader.java
@@ -1,4 +1,3 @@
-
 package com.badlogic.gdx.graphics.g3d.particles;
 
 import java.io.File;
@@ -6,7 +5,6 @@ import java.io.FileWriter;
 import java.io.IOException;
 import java.io.Writer;
 
-import com.badlogic.gdx.Application.ApplicationType;
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.assets.AssetDescriptor;
 import com.badlogic.gdx.assets.AssetLoaderParameters;
@@ -21,24 +19,22 @@ import com.badlogic.gdx.utils.Json;
 import com.badlogic.gdx.utils.ObjectMap;
 import com.badlogic.gdx.utils.reflect.ClassReflection;
 
-/** This class can save and load a {@link ParticleEffect}. It should be added as {@link AsynchronousAssetLoader} to the
- * {@link AssetManager} so it will be able to load the effects. It's important to note that the two classes
- * {@link ParticleEffectLoadParameter} and {@link ParticleEffectSaveParameter} should be passed in whenever possible, because when
- * present the batches settings will be loaded automatically. When the load and save parameters are absent, once the effect will
- * be created, one will have to set the required batches manually otherwise the {@link ParticleController} instances contained
- * inside the effect will not be able to render themselves.
+/**This class can save and load a {@link ParticleEffect}.
+ * It should be added as {@link AsynchronousAssetLoader} to the {@link AssetManager} so it will be able to load the effects.
+ * It's important to note that the two classes {@link ParticleEffectLoadParameter} and {@link ParticleEffectSaveParameter} should
+ * be passed in whenever possible, because when present the batches settings will be loaded automatically.
+ * When the load and save parameters are absent, once the effect will be created, one will have to set the required batches
+ * manually otherwise the {@link ParticleController} instances contained inside the effect will not be able to render themselves. 
  * @author inferno */
-public class ParticleEffectLoader extends
-	AsynchronousAssetLoader<ParticleEffect, ParticleEffectLoader.ParticleEffectLoadParameter> {
-	protected Array<ObjectMap.Entry<String, ResourceData<ParticleEffect>>> items = new Array<ObjectMap.Entry<String, ResourceData<ParticleEffect>>>();
-
+public class ParticleEffectLoader extends AsynchronousAssetLoader<ParticleEffect, ParticleEffectLoader.ParticleEffectLoadParameter> {
+	protected Array<ObjectMap.Entry<String, ResourceData<ParticleEffect>>> items = new Array<ObjectMap.Entry<String, ResourceData<ParticleEffect>>>(); 
+	
 	public ParticleEffectLoader (FileHandleResolver resolver) {
 		super(resolver);
 	}
 
 	@Override
-	public void loadAsync (AssetManager manager, String fileName, FileHandle file, ParticleEffectLoadParameter parameter) {
-	}
+	public void loadAsync (AssetManager manager, String fileName, FileHandle file, ParticleEffectLoadParameter parameter) {}
 
 	@Override
 	public Array<AssetDescriptor> getDependencies (String fileName, FileHandle file, ParticleEffectLoadParameter parameter) {
@@ -52,59 +48,61 @@ public class ParticleEffectLoader extends
 			items.add(entry);
 			assets = data.getAssets();
 		}
-
+		
 		Array<AssetDescriptor> descriptors = new Array<AssetDescriptor>();
-		for (AssetData<?> assetData : assets) {
-
-			// If the asset doesn't exist try to load it from loading effect directory
-			if (!resolve(assetData.filename).exists()) {
-				assetData.filename = file.parent().child(Gdx.files.internal(assetData.filename).name()).path();
+		for(AssetData<?> assetData : assets){
+			
+			//If the asset doesn't exist try to load it from loading effect directory
+			if (!resolve(assetData.filename).exists()){
+				assetData.filename = file.parent().child(Gdx.files.absolute(assetData.filename).name()).path();
 			}
 
-			if (assetData.type == ParticleEffect.class) {
+			if(assetData.type == ParticleEffect.class){
 				descriptors.add(new AssetDescriptor(assetData.filename, assetData.type, parameter));
-			} else
+			}
+			else 
 				descriptors.add(new AssetDescriptor(assetData.filename, assetData.type));
 		}
-
+		
 		return descriptors;
-
+		
 	}
-
+	
 	/** Saves the effect to the given file contained in the passed in parameter. */
-	public void save (ParticleEffect effect, ParticleEffectSaveParameter parameter) throws IOException {
-		ResourceData<ParticleEffect> data = new ResourceData<ParticleEffect>(effect);
-
-		// effect assets
+	public void save(ParticleEffect effect, ParticleEffectSaveParameter parameter) throws IOException{
+		ResourceData<ParticleEffect> data =  new ResourceData<ParticleEffect>(effect);
+		
+		//effect assets
 		effect.save(parameter.manager, data);
-
-		// Batches configurations
-		if (parameter.batches != null) {
-			for (ParticleBatch<?> batch : parameter.batches) {
+		
+		//Batches configurations
+		if(parameter.batches != null){
+			for(ParticleBatch<?> batch : parameter.batches){
 				boolean save = false;
-				for (ParticleController controller : effect.getControllers()) {
-					if (controller.renderer.isCompatible(batch)) {
+				for(ParticleController controller : effect.getControllers()){
+					if(controller.renderer.isCompatible(batch)){
 						save = true;
 						break;
 					}
 				}
-
-				if (save) batch.save(parameter.manager, data);
+				
+				if(save)
+					batch.save(parameter.manager, data);
 			}
 		}
-
-		// save
+		
+		//save
 		Json json = new Json();
 		json.toJson(data, parameter.file);
 	}
-
+	
 	@Override
 	public ParticleEffect loadSync (AssetManager manager, String fileName, FileHandle file, ParticleEffectLoadParameter parameter) {
 		ResourceData<ParticleEffect> effectData = null;
-		synchronized (items) {
-			for (int i = 0; i < items.size; ++i) {
+		synchronized(items) {
+			for(int i=0; i < items.size; ++i){
 				ObjectMap.Entry<String, ResourceData<ParticleEffect>> entry = items.get(i);
-				if (entry.key.equals(fileName)) {
+				if(entry.key.equals(fileName)){
 					effectData = entry.value;
 					items.removeIndex(i);
 					break;
@@ -113,45 +111,45 @@ public class ParticleEffectLoader extends
 		}
 
 		effectData.resource.load(manager, effectData);
-		if (parameter != null) {
-			if (parameter.batches != null) {
-				for (ParticleBatch<?> batch : parameter.batches) {
+		if(parameter != null){
+			if(parameter.batches != null){
+				for(ParticleBatch<?> batch : parameter.batches){
 					batch.load(manager, effectData);
 				}
 			}
-			effectData.resource.setBatch(parameter.batches);
+			effectData.resource.setBatch(parameter.batches);	
 		}
 		return effectData.resource;
 	}
-
-	private <T> T find (Array<?> array, Class<T> type) {
-		for (Object object : array) {
-			if (ClassReflection.isAssignableFrom(type, object.getClass())) return (T)object;
+	
+	private <T> T find(Array<?> array, Class<T> type){
+		for(Object object : array){
+			if(ClassReflection.isAssignableFrom(type, object.getClass()))
+				return (T)object;
 		}
 		return null;
 	}
-
+	
 	public static class ParticleEffectLoadParameter extends AssetLoaderParameters<ParticleEffect> {
 		Array<ParticleBatch<?>> batches;
-
-		public ParticleEffectLoadParameter (Array<ParticleBatch<?>> batches) {
+		
+		public ParticleEffectLoadParameter(Array<ParticleBatch<?>>batches){
 			this.batches = batches;
 		}
 	}
-
+	
 	public static class ParticleEffectSaveParameter extends AssetLoaderParameters<ParticleEffect> {
-		/** Optional parameters, but should be present to correctly load the settings */
+		/**Optional parameters, but should be present to correctly load the settings*/
 		Array<ParticleBatch<?>> batches;
-
+		
 		/** Required parameters */
 		FileHandle file;
 		AssetManager manager;
-
-		public ParticleEffectSaveParameter (FileHandle file, AssetManager manager, Array<ParticleBatch<?>> batches) {
+		public ParticleEffectSaveParameter(FileHandle file, AssetManager manager, Array<ParticleBatch<?>> batches){
 			this.batches = batches;
 			this.file = file;
 			this.manager = manager;
 		}
 	}
-
+	
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ResourceData.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ResourceData.java
index 82551e3..1e48289 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ResourceData.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/ResourceData.java
@@ -209,7 +209,7 @@ public class ResourceData<T> implements Json.Serializable{
 			saveData.resources = this;
 		}
 		
-		sharedAssets.addAll(json.readValue("assets", Array.class, AssetData.class, jsonData));
+		sharedAssets.addAll(json.readValue("assets", AssetData[].class, jsonData));
 		resource = json.readValue("resource", null, jsonData);
 	}
 
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/BillboardParticleBatch.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/BillboardParticleBatch.java
index b59927c..f40baa6 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/BillboardParticleBatch.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/BillboardParticleBatch.java
@@ -44,7 +44,7 @@ public class BillboardParticleBatch extends BufferedParticleBatch<BillboardContr
 	private static final VertexAttributes 
 		GPU_ATTRIBUTES = new VertexAttributes(new VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE), 
 															new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE+"0"), 
-															new VertexAttribute(Usage.ColorUnpacked, 4, ShaderProgram.COLOR_ATTRIBUTE), 
+															new VertexAttribute(Usage.Color, 4, ShaderProgram.COLOR_ATTRIBUTE), 
 															new VertexAttribute(sizeAndRotationUsage, 4, "a_sizeAndRotation")),
 															/*
 		GPU_EXT_ATTRIBUTES = new VertexAttributes(new VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE), 
@@ -55,13 +55,13 @@ public class BillboardParticleBatch extends BufferedParticleBatch<BillboardContr
 									*/
 		CPU_ATTRIBUTES = new VertexAttributes(	new VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE), 
 															new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE+"0"), 
-															new VertexAttribute(Usage.ColorUnpacked, 4, ShaderProgram.COLOR_ATTRIBUTE) );
+															new VertexAttribute(Usage.Color, 4, ShaderProgram.COLOR_ATTRIBUTE) );
 	
 	//Offsets
 	private static final int 	GPU_POSITION_OFFSET = (short)(GPU_ATTRIBUTES.findByUsage(Usage.Position).offset/4),
 										GPU_UV_OFFSET = (short)(GPU_ATTRIBUTES.findByUsage(Usage.TextureCoordinates).offset/4),
 										GPU_SIZE_ROTATION_OFFSET = (short)(GPU_ATTRIBUTES.findByUsage(sizeAndRotationUsage).offset/4),
-										GPU_COLOR_OFFSET = (short)(GPU_ATTRIBUTES.findByUsage(Usage.ColorUnpacked).offset/4),
+										GPU_COLOR_OFFSET = (short)(GPU_ATTRIBUTES.findByUsage(Usage.Color).offset/4),
 										GPU_VERTEX_SIZE = GPU_ATTRIBUTES.vertexSize/4,
 
 										//Ext
@@ -77,7 +77,7 @@ public class BillboardParticleBatch extends BufferedParticleBatch<BillboardContr
 										//Cpu
 										CPU_POSITION_OFFSET = (short)(CPU_ATTRIBUTES.findByUsage(Usage.Position).offset/4),
 										CPU_UV_OFFSET = (short)(CPU_ATTRIBUTES.findByUsage(Usage.TextureCoordinates).offset/4),
-										CPU_COLOR_OFFSET = (short)(CPU_ATTRIBUTES.findByUsage(Usage.ColorUnpacked).offset/4),
+										CPU_COLOR_OFFSET = (short)(CPU_ATTRIBUTES.findByUsage(Usage.Color).offset/4),
 										CPU_VERTEX_SIZE= CPU_ATTRIBUTES.vertexSize/4;
 	private final static int 	MAX_PARTICLES_PER_MESH = Short.MAX_VALUE/4,
 										MAX_VERTICES_PER_MESH = MAX_PARTICLES_PER_MESH*4;
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/PointSpriteParticleBatch.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/PointSpriteParticleBatch.java
index eb03a6f..ea27aae 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/PointSpriteParticleBatch.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/batches/PointSpriteParticleBatch.java
@@ -34,12 +34,12 @@ public class PointSpriteParticleBatch extends BufferedParticleBatch<PointSpriteC
 	protected static final int sizeAndRotationUsage = 1 << 9;
 	protected static final VertexAttributes CPU_ATTRIBUTES = new VertexAttributes(
 		new VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE),
-		new VertexAttribute(Usage.ColorUnpacked, 4, ShaderProgram.COLOR_ATTRIBUTE),
+		new VertexAttribute(Usage.Color, 4, ShaderProgram.COLOR_ATTRIBUTE),
 		new VertexAttribute(Usage.TextureCoordinates, 4, "a_region"),
 		new VertexAttribute(sizeAndRotationUsage, 3, "a_sizeAndRotation"));
 	protected static final int CPU_VERTEX_SIZE = (short)(CPU_ATTRIBUTES.vertexSize / 4),
 										CPU_POSITION_OFFSET = (short)(CPU_ATTRIBUTES.findByUsage(Usage.Position).offset/4),
-										CPU_COLOR_OFFSET = (short)(CPU_ATTRIBUTES.findByUsage(Usage.ColorUnpacked).offset/4),
+										CPU_COLOR_OFFSET = (short)(CPU_ATTRIBUTES.findByUsage(Usage.Color).offset/4),
 										CPU_REGION_OFFSET = (short)(CPU_ATTRIBUTES.findByUsage(Usage.TextureCoordinates).offset/4),
 										CPU_SIZE_AND_ROTATION_OFFSET = (short)(CPU_ATTRIBUTES.findByUsage(sizeAndRotationUsage).offset/4);
 
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/particles.vertex.glsl b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/particles.vertex.glsl
index 12b333e..159c519 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/particles.vertex.glsl
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/particles.vertex.glsl
@@ -1,14 +1,3 @@
-#ifdef GL_ES 
-#define LOWP lowp
-#define MED mediump
-#define HIGH highp
-precision mediump float;
-#else
-#define MED
-#define LOWP
-#define HIGH
-#endif
-
 #ifdef billboard
 //Billboard particles
 //In
@@ -18,7 +7,7 @@ attribute vec4 a_sizeAndRotation;
 attribute vec4 a_color;
 
 //out
-varying MED vec2 v_texCoords0;
+varying vec2 v_texCoords0;
 varying vec4 v_color;
 
 //Camera
@@ -83,7 +72,7 @@ attribute vec4 a_region;
 //out
 varying vec4 v_color;
 varying mat2 v_rotation;
-varying MED vec4 v_region;
+varying vec4 v_region;
 varying vec2 v_uvRegionCenter;
 
 //Camera
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/MeshSpawnShapeValue.java b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/MeshSpawnShapeValue.java
index 48d7b66..3151762 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/MeshSpawnShapeValue.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/particles/values/MeshSpawnShapeValue.java
@@ -14,7 +14,7 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
 /** The base class of all the {@link ParticleValue} values which spawn a particle on a mesh shape.
 * @author Inferno */
 public abstract class MeshSpawnShapeValue extends SpawnShapeValue {
-	public static class Triangle{
+	protected static class Triangle{
 		float x1, y1, z1,
 				x2, y2, z2,
 				x3, y3, z3;
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/DefaultShader.java b/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/DefaultShader.java
index 8aa3a56..6b1ecb9 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/DefaultShader.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/shaders/DefaultShader.java
@@ -593,7 +593,7 @@ public class DefaultShader extends BaseShader {
 		final long attributesMask = attributes.getMask();
 		final long vertexMask = renderable.mesh.getVertexAttributes().getMask();
 		if (and(vertexMask, Usage.Position)) prefix += "#define positionFlag\n";
-		if (or(vertexMask, Usage.ColorUnpacked | Usage.ColorPacked)) prefix += "#define colorFlag\n";
+		if (or(vertexMask, Usage.Color | Usage.ColorPacked)) prefix += "#define colorFlag\n";
 		if (and(vertexMask, Usage.BiNormal)) prefix += "#define binormalFlag\n";
 		if (and(vertexMask, Usage.Tangent)) prefix += "#define tangentFlag\n";
 		if (and(vertexMask, Usage.Normal)) prefix += "#define normalFlag\n";
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/utils/CameraInputController.java b/gdx/src/com/badlogic/gdx/graphics/g3d/utils/CameraInputController.java
index 34a0f90..6f1dac1 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/utils/CameraInputController.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/utils/CameraInputController.java
@@ -163,7 +163,7 @@ public class CameraInputController extends GestureDetector {
 			startY = screenY;
 			this.button = button;
 		}
-		return super.touchDown(screenX, screenY, pointer, button) || (activateKey == 0 || activatePressed);
+		return super.touchDown(screenX, screenY, pointer, button) || activatePressed;
 	}
 
 	@Override
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/utils/MeshBuilder.java b/gdx/src/com/badlogic/gdx/graphics/g3d/utils/MeshBuilder.java
index d5b4654..742e03e 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/utils/MeshBuilder.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/utils/MeshBuilder.java
@@ -119,7 +119,7 @@ public class MeshBuilder implements MeshPartBuilder {
 		final Array<VertexAttribute> attrs = new Array<VertexAttribute>();
 		if ((usage & Usage.Position) == Usage.Position)
 			attrs.add(new VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE));
-		if ((usage & Usage.ColorUnpacked) == Usage.ColorUnpacked) attrs.add(new VertexAttribute(Usage.ColorUnpacked, 4, ShaderProgram.COLOR_ATTRIBUTE));
+		if ((usage & Usage.Color) == Usage.Color) attrs.add(new VertexAttribute(Usage.Color, 4, ShaderProgram.COLOR_ATTRIBUTE));
 		if ((usage & Usage.ColorPacked) == Usage.ColorPacked)
 			attrs.add(new VertexAttribute(Usage.ColorPacked, 4, ShaderProgram.COLOR_ATTRIBUTE));
 		if ((usage & Usage.Normal) == Usage.Normal)
@@ -162,15 +162,14 @@ public class MeshBuilder implements MeshPartBuilder {
 		this.istart = 0;
 		this.part = null;
 		this.stride = attributes.vertexSize / 4;
-		if (this.vertex == null || this.vertex.length < stride)
-			this.vertex = new float[stride];
+		this.vertex = new float[stride];
 		VertexAttribute a = attributes.findByUsage(Usage.Position);
 		if (a == null) throw new GdxRuntimeException("Cannot build mesh without position attribute");
 		posOffset = a.offset / 4;
 		posSize = a.numComponents;
 		a = attributes.findByUsage(Usage.Normal);
 		norOffset = a == null ? -1 : a.offset / 4;
-		a = attributes.findByUsage(Usage.ColorUnpacked);
+		a = attributes.findByUsage(Usage.Color);
 		colOffset = a == null ? -1 : a.offset / 4;
 		colSize = a == null ? 0 : a.numComponents;
 		a = attributes.findByUsage(Usage.ColorPacked);
@@ -193,22 +192,12 @@ public class MeshBuilder implements MeshPartBuilder {
 	}
 
 	/** Starts a new MeshPart. The mesh part is not usable until end() is called. This will reset the current color and vertex
-	 * transformation.
-	 * @see #part(String, int, MeshPart) */
+	 * transformation. */
 	public MeshPart part (final String id, int primitiveType) {
-		return part(id, primitiveType, new MeshPart());
-	}
-
-	/** Starts a new MeshPart. The mesh part is not usable until end() is called. This will reset the current color and vertex
-	 * transformation.
-	 * @param id The id (name) of the part
-	 * @param primitiveType e.g. {@link GL20#GL_TRIANGLES} or {@link GL20#GL_LINES}
-	 * @param meshPart The part to receive the result */
-	public MeshPart part (final String id, final int primitiveType, MeshPart meshPart) {
 		if (this.attributes == null) throw new RuntimeException("Call begin() first");
 		endpart();
 
-		part = meshPart;
+		part = new MeshPart();
 		part.id = id;
 		this.primitiveType = part.primitiveType = primitiveType;
 		parts.add(part);
@@ -376,7 +365,7 @@ public class MeshBuilder implements MeshPartBuilder {
 	 * adding many vertices to avoid multiple backing array resizes.
 	 * @param numVertices The number of vertices you are about to add */
 	public void ensureVertices (int numVertices) {
-		vertices.ensureCapacity(stride * numVertices);
+		vertices.ensureCapacity(vertex.length * numVertices);
 	}
 
 	/** Increases the size of the backing indices array to accommodate the specified number of additional indices. Useful before
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/utils/ModelBuilder.java b/gdx/src/com/badlogic/gdx/graphics/g3d/utils/ModelBuilder.java
index b10530f..f5d2026 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/utils/ModelBuilder.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/utils/ModelBuilder.java
@@ -19,6 +19,7 @@ package com.badlogic.gdx.graphics.g3d.utils;
 import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.Mesh;
+import com.badlogic.gdx.graphics.VertexAttribute;
 import com.badlogic.gdx.graphics.VertexAttributes;
 import com.badlogic.gdx.graphics.g3d.Material;
 import com.badlogic.gdx.graphics.g3d.Model;
@@ -379,6 +380,47 @@ public class ModelBuilder {
 			rebuildReferences(model, child);
 	}
 
+	// Old code below this line, as for now still useful for testing.
+	@Deprecated
+	public static Model createFromMesh (final Mesh mesh, int primitiveType, final Material material) {
+		return createFromMesh(mesh, 0, mesh.getNumIndices(), primitiveType, material);
+	}
+
+	@Deprecated
+	public static Model createFromMesh (final Mesh mesh, int indexOffset, int vertexCount, int primitiveType,
+		final Material material) {
+		Model result = new Model();
+		MeshPart meshPart = new MeshPart();
+		meshPart.id = "part1";
+		meshPart.indexOffset = indexOffset;
+		meshPart.numVertices = vertexCount;
+		meshPart.primitiveType = primitiveType;
+		meshPart.mesh = mesh;
+
+		NodePart partMaterial = new NodePart();
+		partMaterial.material = material;
+		partMaterial.meshPart = meshPart;
+		Node node = new Node();
+		node.id = "node1";
+		node.parts.add(partMaterial);
+
+		result.meshes.add(mesh);
+		result.materials.add(material);
+		result.nodes.add(node);
+		result.meshParts.add(meshPart);
+		result.manageDisposable(mesh);
+		return result;
+	}
+
+	@Deprecated
+	public static Model createFromMesh (final float[] vertices, final VertexAttribute[] attributes, final short[] indices,
+		int primitiveType, final Material material) {
+		final Mesh mesh = new Mesh(false, vertices.length, indices.length, attributes);
+		mesh.setVertices(vertices);
+		mesh.setIndices(indices);
+		return createFromMesh(mesh, 0, indices.length, primitiveType, material);
+	}
+
 	/** Convenience method to create a model with three orthonormal vectors shapes. The resources the Material might contain are not
 	 * managed, use {@link Model#manageDisposable(Disposable)} to add those to the model.
 	 * @param axisLength Length of each axis.
diff --git a/gdx/src/com/badlogic/gdx/graphics/g3d/utils/TextureDescriptor.java b/gdx/src/com/badlogic/gdx/graphics/g3d/utils/TextureDescriptor.java
index 2b01a7d..83f0a30 100644
--- a/gdx/src/com/badlogic/gdx/graphics/g3d/utils/TextureDescriptor.java
+++ b/gdx/src/com/badlogic/gdx/graphics/g3d/utils/TextureDescriptor.java
@@ -19,7 +19,7 @@ package com.badlogic.gdx.graphics.g3d.utils;
 import com.badlogic.gdx.graphics.GLTexture;
 import com.badlogic.gdx.graphics.Texture;
 
-public class TextureDescriptor<T extends GLTexture> implements Comparable<TextureDescriptor<T>> {
+public class TextureDescriptor<T extends GLTexture> {
 	public T texture = null;
 	public Texture.TextureFilter minFilter;
 	public Texture.TextureFilter magFilter;
@@ -66,29 +66,4 @@ public class TextureDescriptor<T extends GLTexture> implements Comparable<Textur
 		return other.texture == texture && other.minFilter == minFilter && other.magFilter == magFilter && other.uWrap == uWrap
 			&& other.vWrap == vWrap;
 	}
-	
-	@Override
-	public int hashCode () {
-		long result = texture.glTarget;
-		result = 811 * result + texture.getTextureObjectHandle();
-		result = 811 * result + minFilter.getGLEnum();
-		result = 811 * result + magFilter.getGLEnum();
-		result = 811 * result + uWrap.getGLEnum();
-		result = 811 * result + vWrap.getGLEnum();
-		return (int)(result ^ (result >> 32));
-	}
-
-	@Override
-	public int compareTo (TextureDescriptor<T> o) {
-		if (o == this) return 0;
-		if (texture.glTarget != o.texture.glTarget)
-			return texture.glTarget - o.texture.glTarget;
-		if (texture.getTextureObjectHandle() != o.texture.getTextureObjectHandle())
-			return texture.getTextureObjectHandle() - o.texture.getTextureObjectHandle();
-		if (minFilter != o.minFilter) return minFilter.getGLEnum() - o.minFilter.getGLEnum();
-		if (magFilter != o.magFilter) return magFilter.getGLEnum() - o.magFilter.getGLEnum();
-		if (uWrap != o.uWrap) return uWrap.getGLEnum() - o.uWrap.getGLEnum();
-		if (vWrap != o.vWrap) return vWrap.getGLEnum() - o.vWrap.getGLEnum();
-		return 0;
-	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/FrameBuffer.java b/gdx/src/com/badlogic/gdx/graphics/glutils/FrameBuffer.java
index feafab0..0286d6b 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/FrameBuffer.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/FrameBuffer.java
@@ -1,12 +1,12 @@
 /*******************************************************************************
  * Copyright 2011 See AUTHORS file.
- * 
+ *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *   http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -16,79 +16,31 @@
 
 package com.badlogic.gdx.graphics.glutils;
 
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.nio.IntBuffer;
-import java.util.HashMap;
-import java.util.Map;
-
-import com.badlogic.gdx.Application;
-import com.badlogic.gdx.Application.ApplicationType;
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.Pixmap;
 import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.graphics.Texture.TextureFilter;
 import com.badlogic.gdx.graphics.Texture.TextureWrap;
-import com.badlogic.gdx.utils.Array;
-import com.badlogic.gdx.utils.BufferUtils;
-import com.badlogic.gdx.utils.Disposable;
 
 /** <p>
  * Encapsulates OpenGL ES 2.0 frame buffer objects. This is a simple helper class which should cover most FBO uses. It will
  * automatically create a texture for the color attachment and a renderbuffer for the depth buffer. You can get a hold of the
  * texture by {@link FrameBuffer#getColorBufferTexture()}. This class will only work with OpenGL ES 2.0.
  * </p>
- * 
+ *
  * <p>
  * FrameBuffers are managed. In case of an OpenGL context loss, which only happens on Android when a user switches to another
  * application or receives an incoming call, the framebuffer will be automatically recreated.
  * </p>
- * 
+ *
  * <p>
  * A FrameBuffer must be disposed if it is no longer needed
  * </p>
- * 
- * @author mzechner */
-public class FrameBuffer implements Disposable {
-	/** the frame buffers **/
-	private final static Map<Application, Array<FrameBuffer>> buffers = new HashMap<Application, Array<FrameBuffer>>();
-
-	/** the color buffer texture **/
-	protected Texture colorTexture;
-
-	/** the default framebuffer handle, a.k.a screen. */
-	private static int defaultFramebufferHandle;
-	/** true if we have polled for the default handle already. */
-	private static boolean defaultFramebufferHandleInitialized = false;
-
-	/** the framebuffer handle **/
-	private int framebufferHandle;
-
-	/** the depthbuffer render object handle **/
-	private int depthbufferHandle;
-
-	/** the stencilbuffer render object handle **/
-	private int stencilbufferHandle;
-
-	/** width **/
-	protected final int width;
-
-	/** height **/
-	protected final int height;
-
-	/** depth **/
-	protected final boolean hasDepth;
+ *
+ * @author mzechner, realitix */
+public class FrameBuffer extends GLFrameBuffer<Texture> {
 
-	/** stencil **/
-	protected final boolean hasStencil;
-
-	/** format **/
-	protected final Pixmap.Format format;
-
-	
 	/** Creates a new FrameBuffer having the given dimensions and potentially a depth buffer attached.
-	 * 
+	 *
 	 * @param format
 	 * @param width
 	 * @param height
@@ -97,10 +49,10 @@ public class FrameBuffer implements Disposable {
 	public FrameBuffer (Pixmap.Format format, int width, int height, boolean hasDepth) {
 		this(format, width, height, hasDepth, false);
 	}
-	
-	
+
+
 	/** Creates a new FrameBuffer having the given dimensions and potentially a depth and a stencil buffer attached.
-	 * 
+	 *
 	 * @param format the format of the color buffer; according to the OpenGL ES 2.0 spec, only RGB565, RGBA4444 and RGB5_A1 are
 	 *           color-renderable
 	 * @param width the width of the framebuffer in pixels
@@ -108,214 +60,19 @@ public class FrameBuffer implements Disposable {
 	 * @param hasDepth whether to attach a depth buffer
 	 * @throws com.badlogic.gdx.utils.GdxRuntimeException in case the FrameBuffer could not be created */
 	public FrameBuffer (Pixmap.Format format, int width, int height, boolean hasDepth, boolean hasStencil) {
-		this.width = width;
-		this.height = height;
-		this.format = format;
-		this.hasDepth = hasDepth;
-		this.hasStencil = hasStencil;
-		build();
-
-		addManagedFrameBuffer(Gdx.app, this);
+		super(format, width, height, hasDepth, hasStencil);
 	}
 
 	/** Override this method in a derived class to set up the backing texture as you like. */
+	@Override
 	protected void setupTexture () {
 		colorTexture = new Texture(width, height, format);
 		colorTexture.setFilter(TextureFilter.Linear, TextureFilter.Linear);
 		colorTexture.setWrap(TextureWrap.ClampToEdge, TextureWrap.ClampToEdge);
 	}
 
-	private void build () {
-		GL20 gl = Gdx.gl20;
-
-		// iOS uses a different framebuffer handle! (not necessarily 0)
-		if (!defaultFramebufferHandleInitialized) {
-			defaultFramebufferHandleInitialized = true;
-			if (Gdx.app.getType() == ApplicationType.iOS) {
-				IntBuffer intbuf = ByteBuffer.allocateDirect(16 * Integer.SIZE / 8).order(ByteOrder.nativeOrder()).asIntBuffer();
-				gl.glGetIntegerv(GL20.GL_FRAMEBUFFER_BINDING, intbuf);
-				defaultFramebufferHandle = intbuf.get(0);
-			} else {
-				defaultFramebufferHandle = 0;
-			}
-		}
-
-		setupTexture();
-
-		
-		framebufferHandle = gl.glGenFramebuffer();
-
-		if (hasDepth) {
-			depthbufferHandle = gl.glGenRenderbuffer();
-		}
-
-		if (hasStencil) {
-			stencilbufferHandle = gl.glGenRenderbuffer();
-		}
-
-		gl.glBindTexture(GL20.GL_TEXTURE_2D, colorTexture.getTextureObjectHandle());
-
-		if (hasDepth) {
-			gl.glBindRenderbuffer(GL20.GL_RENDERBUFFER, depthbufferHandle);
-			gl.glRenderbufferStorage(GL20.GL_RENDERBUFFER, GL20.GL_DEPTH_COMPONENT16, colorTexture.getWidth(),
-				colorTexture.getHeight());
-		}
-
-		if (hasStencil) {
-			gl.glBindRenderbuffer(GL20.GL_RENDERBUFFER, stencilbufferHandle);
-			gl.glRenderbufferStorage(GL20.GL_RENDERBUFFER, GL20.GL_STENCIL_INDEX8, colorTexture.getWidth(), colorTexture.getHeight());
-		}
-
-		gl.glBindFramebuffer(GL20.GL_FRAMEBUFFER, framebufferHandle);
-		gl.glFramebufferTexture2D(GL20.GL_FRAMEBUFFER, GL20.GL_COLOR_ATTACHMENT0, GL20.GL_TEXTURE_2D,
-			colorTexture.getTextureObjectHandle(), 0);
-		if (hasDepth) {
-			gl.glFramebufferRenderbuffer(GL20.GL_FRAMEBUFFER, GL20.GL_DEPTH_ATTACHMENT, GL20.GL_RENDERBUFFER, depthbufferHandle);
-		}
-
-		if (hasStencil) {
-			gl.glFramebufferRenderbuffer(GL20.GL_FRAMEBUFFER, GL20.GL_STENCIL_ATTACHMENT, GL20.GL_RENDERBUFFER, stencilbufferHandle);
-		}
-
-		int result = gl.glCheckFramebufferStatus(GL20.GL_FRAMEBUFFER);
-
-		gl.glBindRenderbuffer(GL20.GL_RENDERBUFFER, 0);
-		gl.glBindTexture(GL20.GL_TEXTURE_2D, 0);
-		gl.glBindFramebuffer(GL20.GL_FRAMEBUFFER, defaultFramebufferHandle);
-
-		if (result != GL20.GL_FRAMEBUFFER_COMPLETE) {
-			colorTexture.dispose();
-			
-			if (hasDepth)
-				gl.glDeleteRenderbuffer(depthbufferHandle);
-
-			if (hasStencil)
-				gl.glDeleteRenderbuffer(stencilbufferHandle);
-
-			gl.glDeleteFramebuffer(framebufferHandle);
-
-			if (result == GL20.GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT)
-				throw new IllegalStateException("frame buffer couldn't be constructed: incomplete attachment");
-			if (result == GL20.GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS)
-				throw new IllegalStateException("frame buffer couldn't be constructed: incomplete dimensions");
-			if (result == GL20.GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT)
-				throw new IllegalStateException("frame buffer couldn't be constructed: missing attachment");
-			if (result == GL20.GL_FRAMEBUFFER_UNSUPPORTED)
-				throw new IllegalStateException("frame buffer couldn't be constructed: unsupported combination of formats");
-			throw new IllegalStateException("frame buffer couldn't be constructed: unknown error " + result);
-		}
-	}
-
-	/** Releases all resources associated with the FrameBuffer. */
-	public void dispose () {
-		GL20 gl = Gdx.gl20;
-
-		IntBuffer handle = BufferUtils.newIntBuffer(1);
-
-		colorTexture.dispose();
-		if (hasDepth)
-			gl.glDeleteRenderbuffer(depthbufferHandle);
-
-		if (hasStencil)
-			gl.glDeleteRenderbuffer(stencilbufferHandle);
-
-		gl.glDeleteFramebuffer(framebufferHandle);
-
-		if (buffers.get(Gdx.app) != null) buffers.get(Gdx.app).removeValue(this, true);
-	}
-
-	/** Makes the frame buffer current so everything gets drawn to it. */
-	public void bind () {
-		Gdx.gl20.glBindFramebuffer(GL20.GL_FRAMEBUFFER, framebufferHandle);
-	}
-
-	/** Unbinds the framebuffer, all drawing will be performed to the normal framebuffer from here on. */
-	public static void unbind () {
-		Gdx.gl20.glBindFramebuffer(GL20.GL_FRAMEBUFFER, defaultFramebufferHandle);
-	}
-
-	/** Binds the frame buffer and sets the viewport accordingly, so everything gets drawn to it. */
-	public void begin () {
-		bind();
-		setFrameBufferViewport();
-	}
-
-	/** Sets viewport to the dimensions of framebuffer. Called by {@link #begin()}. */
-	protected void setFrameBufferViewport () {
-		Gdx.gl20.glViewport(0, 0, colorTexture.getWidth(), colorTexture.getHeight());
-	}
-
-	/** Unbinds the framebuffer, all drawing will be performed to the normal framebuffer from here on. */
-	public void end () {
-		unbind();
-		setDefaultFrameBufferViewport();
-	}
-
-	/** Sets viewport to the dimensions of default framebuffer (window). Called by {@link #end()}. */
-	protected void setDefaultFrameBufferViewport () {
-		Gdx.gl20.glViewport(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
-	}
-
-	/** Unbinds the framebuffer and sets viewport sizes, all drawing will be performed to the normal framebuffer from here on.
-	 * 
-	 * @param x the x-axis position of the viewport in pixels
-	 * @param y the y-asis position of the viewport in pixels
-	 * @param width the width of the viewport in pixels
-	 * @param height the height of the viewport in pixels */
-	public void end (int x, int y, int width, int height) {
-		unbind();
-		Gdx.gl20.glViewport(x, y, width, height);
-	}
-
 	/** @return the color buffer texture */
 	public Texture getColorBufferTexture () {
 		return colorTexture;
 	}
-
-	/** @return the height of the framebuffer in pixels */
-	public int getHeight () {
-		return colorTexture.getHeight();
-	}
-
-	/** @return the width of the framebuffer in pixels */
-	public int getWidth () {
-		return colorTexture.getWidth();
-	}
-
-	private static void addManagedFrameBuffer (Application app, FrameBuffer frameBuffer) {
-		Array<FrameBuffer> managedResources = buffers.get(app);
-		if (managedResources == null) managedResources = new Array<FrameBuffer>();
-		managedResources.add(frameBuffer);
-		buffers.put(app, managedResources);
-	}
-
-	/** Invalidates all frame buffers. This can be used when the OpenGL context is lost to rebuild all managed frame buffers. This
-	 * assumes that the texture attached to this buffer has already been rebuild! Use with care. */
-	public static void invalidateAllFrameBuffers (Application app) {
-		if (Gdx.gl20 == null) return;
-
-		Array<FrameBuffer> bufferArray = buffers.get(app);
-		if (bufferArray == null) return;
-		for (int i = 0; i < bufferArray.size; i++) {
-			bufferArray.get(i).build();
-		}
-	}
-
-	public static void clearAllFrameBuffers (Application app) {
-		buffers.remove(app);
-	}
-
-	public static StringBuilder getManagedStatus (final StringBuilder builder) {
-		builder.append("Managed buffers/app: { ");
-		for (Application app : buffers.keySet()) {
-			builder.append(buffers.get(app).size);
-			builder.append(" ");
-		}
-		builder.append("}");
-		return builder;
-	}
-
-	public static String getManagedStatus () {
-		return getManagedStatus(new StringBuilder()).toString();
-	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/FrameBufferCubemap.java b/gdx/src/com/badlogic/gdx/graphics/glutils/FrameBufferCubemap.java
new file mode 100644
index 0000000..5bd4745
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/FrameBufferCubemap.java
@@ -0,0 +1,155 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.glutils;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.Cubemap;
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.gdx.graphics.Pixmap;
+import com.badlogic.gdx.graphics.Texture.TextureFilter;
+import com.badlogic.gdx.graphics.Texture.TextureWrap;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+/** <p>
+ * Encapsulates OpenGL ES 2.0 frame buffer objects. This is a simple helper class which should cover most FBO uses. It will
+ * automatically create a cubemap for the color attachment and a renderbuffer for the depth buffer. You can get a hold of the
+ * cubemap by {@link FrameBufferCubemap#getColorBufferCubemap()}. This class will only work with OpenGL ES 2.0.
+ * </p>
+ *
+ * <p>
+ * FrameBuffers are managed. In case of an OpenGL context loss, which only happens on Android when a user switches to another
+ * application or receives an incoming call, the framebuffer will be automatically recreated.
+ * </p>
+ *
+ * <p>
+ * A FrameBuffer must be disposed if it is no longer needed
+ * </p>
+ *
+ * <p>
+ * Typical use: <br />
+ * FrameBufferCubemap frameBuffer = new FrameBufferCubemap(Format.RGBA8888, fSize, fSize, true); <br />
+ * frameBuffer.begin(); <br />
+ * while( frameBuffer.nextSide() ) { <br />
+ * frameBuffer.getSide().getUp(camera.up); <br />
+ * frameBuffer.getSide().getDirection(camera.direction);<br />
+ * camera.update(); <br />
+ *
+ * Gdx.gl.glClearColor(0, 0, 0, 1); <br />
+ * Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT | GL20.GL_DEPTH_BUFFER_BIT); <br />
+ * modelBatch.begin(camera); <br />
+ * modelBatch.render(renderableProviders); <br />
+ * modelBatch.end(); <br />
+ * } <br />
+ * frameBuffer.end(); <br />
+ * Cubemap cubemap = frameBuffer.getColorBufferCubemap();
+ * </p>
+ *
+ * @author realitix */
+public class FrameBufferCubemap extends GLFrameBuffer<Cubemap> {
+
+	/** the index of last side rendered **/
+	protected int nbSides;
+
+	/** Creates a new FrameBuffer having the given dimensions and potentially a depth buffer attached.
+	 *
+	 * @param format
+	 * @param width
+	 * @param height
+	 * @param hasDepth
+	 */
+	public FrameBufferCubemap (Pixmap.Format format, int width, int height, boolean hasDepth) {
+		this(format, width, height, hasDepth, false);
+	}
+
+
+	/** Creates a new FrameBuffer having the given dimensions and potentially a depth and a stencil buffer attached.
+	 *
+	 * @param format the format of the color buffer; according to the OpenGL ES 2.0 spec, only RGB565, RGBA4444 and RGB5_A1 are
+	 *           color-renderable
+	 * @param width the width of the cubemap in pixels
+	 * @param height the height of the cubemap in pixels
+	 * @param hasDepth whether to attach a depth buffer
+	 * @param hasStencil whether to attach a stencil buffer
+	 * @throws com.badlogic.gdx.utils.GdxRuntimeException in case the FrameBuffer could not be created */
+	public FrameBufferCubemap (Pixmap.Format format, int width, int height, boolean hasDepth, boolean hasStencil) {
+		super(format, width, height, hasDepth, hasStencil);
+	}
+
+	/** Override this method in a derived class to set up the backing texture as you like. */
+	@Override
+	protected void setupTexture () {
+		colorTexture = new Cubemap(width, height, width, format);
+		colorTexture.setFilter(TextureFilter.Linear, TextureFilter.Linear);
+		colorTexture.setWrap(TextureWrap.ClampToEdge, TextureWrap.ClampToEdge);
+	}
+
+	/**
+	 * Binds the frame buffer and sets the viewport accordingly, so everything gets drawn to it.
+	 */
+	@Override
+	public void begin() {
+		nbSides = -1;
+		super.begin();
+	}
+
+	/** Bind the next side of cubemap and return false if no more side. */
+	public boolean nextSide() {
+		if( nbSides > 5 ) {
+			throw new GdxRuntimeException("No remaining sides.");
+		}
+		else if ( nbSides == 5 ) {
+			return false;
+		}
+
+		nbSides++;
+		bindSide(getSide());
+		return true;
+	}
+
+	/**
+	 * Bind the side.
+	 * @param side Side to bind
+	 */
+	protected void bindSide(final Cubemap.CubemapSide side) {
+		Gdx.gl20.glFramebufferTexture2D(GL20.GL_FRAMEBUFFER, GL20.GL_COLOR_ATTACHMENT0,
+			side.glEnum, colorTexture.getTextureObjectHandle(), 0);
+	}
+
+	/**
+	 * Get binded side.
+	 */
+	public Cubemap.CubemapSide getSide() {
+		return Cubemap.CubemapSide.values()[nbSides];
+	}
+
+	/** Unbinds the framebuffer and sets viewport sizes, all drawing will be performed to the normal framebuffer from here on.
+	 *
+	 * @param x the x-axis position of the viewport in pixels
+	 * @param y the y-asis position of the viewport in pixels
+	 * @param width the width of the viewport in pixels
+	 * @param height the height of the viewport in pixels */
+	@Override
+	public void end (int x, int y, int width, int height) {
+		if( nbSides < 5 ) throw new GdxRuntimeException("Not all sides have been rendered.");
+		super.end(x, y, width, height);
+	}
+
+	/** @return the color buffer cubemap */
+	public Cubemap getColorBufferCubemap () {
+		return colorTexture;
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/GLFrameBuffer.java b/gdx/src/com/badlogic/gdx/graphics/glutils/GLFrameBuffer.java
new file mode 100644
index 0000000..c8972a0
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/GLFrameBuffer.java
@@ -0,0 +1,312 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.graphics.glutils;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.IntBuffer;
+import java.util.HashMap;
+import java.util.Map;
+
+import com.badlogic.gdx.Application;
+import com.badlogic.gdx.Application.ApplicationType;
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.gdx.graphics.GLTexture;
+import com.badlogic.gdx.graphics.Pixmap;
+import com.badlogic.gdx.utils.Array;
+import com.badlogic.gdx.utils.BufferUtils;
+import com.badlogic.gdx.utils.Disposable;
+import com.badlogic.gdx.utils.GdxRuntimeException;
+
+/** <p>
+ * Encapsulates OpenGL ES 2.0 frame buffer objects. This is a simple helper class which should cover most FBO uses. It will
+ * automatically create a gltexture for the color attachment and a renderbuffer for the depth buffer. You can get a hold of the
+ * gltexture by {@link GLFrameBuffer#getGLTexture()}. This class will only work with OpenGL ES 2.0.
+ * </p>
+ *
+ * <p>
+ * FrameBuffers are managed. In case of an OpenGL context loss, which only happens on Android when a user switches to another
+ * application or receives an incoming call, the framebuffer will be automatically recreated.
+ * </p>
+ *
+ * <p>
+ * A FrameBuffer must be disposed if it is no longer needed
+ * </p>
+ *
+ * @author mzechner, realitix */
+public class GLFrameBuffer<T extends GLTexture> implements Disposable {
+	/** the frame buffers **/
+	private final static Map<Application, Array<GLFrameBuffer>> buffers = new HashMap<Application, Array<GLFrameBuffer>>();
+
+	/** the color buffer texture **/
+	protected T colorTexture;
+
+	/** the default framebuffer handle, a.k.a screen. */
+	private static int defaultFramebufferHandle;
+	/** true if we have polled for the default handle already. */
+	private static boolean defaultFramebufferHandleInitialized = false;
+
+	/** the framebuffer handle **/
+	private int framebufferHandle;
+
+	/** the depthbuffer render object handle **/
+	private int depthbufferHandle;
+
+	/** the stencilbuffer render object handle **/
+	private int stencilbufferHandle;
+
+	/** width **/
+	protected final int width;
+
+	/** height **/
+	protected final int height;
+
+	/** depth **/
+	protected final boolean hasDepth;
+
+	/** stencil **/
+	protected final boolean hasStencil;
+
+	/** format **/
+	protected final Pixmap.Format format;
+
+
+	/** Creates a new FrameBuffer having the given dimensions and potentially a depth buffer attached.
+	 *
+	 * @param format
+	 * @param width
+	 * @param height
+	 * @param hasDepth
+	 */
+	public GLFrameBuffer (Pixmap.Format format, int width, int height, boolean hasDepth) {
+		this(format, width, height, hasDepth, false);
+	}
+
+
+	/** Creates a new FrameBuffer having the given dimensions and potentially a depth and a stencil buffer attached.
+	 *
+	 * @param format the format of the color buffer; according to the OpenGL ES 2.0 spec, only RGB565, RGBA4444 and RGB5_A1 are
+	 *           color-renderable
+	 * @param width the width of the framebuffer in pixels
+	 * @param height the height of the framebuffer in pixels
+	 * @param hasDepth whether to attach a depth buffer
+	 * @throws com.badlogic.gdx.utils.GdxRuntimeException in case the FrameBuffer could not be created */
+	public GLFrameBuffer (Pixmap.Format format, int width, int height, boolean hasDepth, boolean hasStencil) {
+		this.width = width;
+		this.height = height;
+		this.format = format;
+		this.hasDepth = hasDepth;
+		this.hasStencil = hasStencil;
+		build();
+
+		addManagedFrameBuffer(Gdx.app, this);
+	}
+
+	/** Override this method in a derived class to set up the backing texture as you like. */
+	protected void setupTexture () {
+		throw new GdxRuntimeException("Texture must be setup");
+	}
+
+	private void build () {
+		GL20 gl = Gdx.gl20;
+
+		// iOS uses a different framebuffer handle! (not necessarily 0)
+		if (!defaultFramebufferHandleInitialized) {
+			defaultFramebufferHandleInitialized = true;
+			if (Gdx.app.getType() == ApplicationType.iOS) {
+				IntBuffer intbuf = ByteBuffer.allocateDirect(16 * Integer.SIZE / 8).order(ByteOrder.nativeOrder()).asIntBuffer();
+				gl.glGetIntegerv(GL20.GL_FRAMEBUFFER_BINDING, intbuf);
+				defaultFramebufferHandle = intbuf.get(0);
+			} else {
+				defaultFramebufferHandle = 0;
+			}
+		}
+
+		setupTexture();
+
+		framebufferHandle = gl.glGenFramebuffer();
+
+		if (hasDepth) {
+			depthbufferHandle = gl.glGenRenderbuffer();
+		}
+
+		if (hasStencil) {
+			stencilbufferHandle = gl.glGenRenderbuffer();
+		}
+
+		gl.glBindTexture(GL20.GL_TEXTURE_2D, colorTexture.getTextureObjectHandle());
+
+		if (hasDepth) {
+			gl.glBindRenderbuffer(GL20.GL_RENDERBUFFER, depthbufferHandle);
+			gl.glRenderbufferStorage(GL20.GL_RENDERBUFFER, GL20.GL_DEPTH_COMPONENT16, colorTexture.getWidth(),
+				colorTexture.getHeight());
+		}
+
+		if (hasStencil) {
+			gl.glBindRenderbuffer(GL20.GL_RENDERBUFFER, stencilbufferHandle);
+			gl.glRenderbufferStorage(GL20.GL_RENDERBUFFER, GL20.GL_STENCIL_INDEX8, colorTexture.getWidth(), colorTexture.getHeight());
+		}
+
+		gl.glBindFramebuffer(GL20.GL_FRAMEBUFFER, framebufferHandle);
+		gl.glFramebufferTexture2D(GL20.GL_FRAMEBUFFER, GL20.GL_COLOR_ATTACHMENT0, GL20.GL_TEXTURE_2D,
+			colorTexture.getTextureObjectHandle(), 0);
+		if (hasDepth) {
+			gl.glFramebufferRenderbuffer(GL20.GL_FRAMEBUFFER, GL20.GL_DEPTH_ATTACHMENT, GL20.GL_RENDERBUFFER, depthbufferHandle);
+		}
+
+		if (hasStencil) {
+			gl.glFramebufferRenderbuffer(GL20.GL_FRAMEBUFFER, GL20.GL_STENCIL_ATTACHMENT, GL20.GL_RENDERBUFFER, stencilbufferHandle);
+		}
+
+		int result = gl.glCheckFramebufferStatus(GL20.GL_FRAMEBUFFER);
+
+		gl.glBindRenderbuffer(GL20.GL_RENDERBUFFER, 0);
+		gl.glBindTexture(GL20.GL_TEXTURE_2D, 0);
+		gl.glBindFramebuffer(GL20.GL_FRAMEBUFFER, defaultFramebufferHandle);
+
+		if (result != GL20.GL_FRAMEBUFFER_COMPLETE) {
+			colorTexture.dispose();
+
+			if (hasDepth)
+				gl.glDeleteRenderbuffer(depthbufferHandle);
+
+			if (hasStencil)
+				gl.glDeleteRenderbuffer(stencilbufferHandle);
+
+			gl.glDeleteFramebuffer(framebufferHandle);
+
+			if (result == GL20.GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT)
+				throw new IllegalStateException("frame buffer couldn't be constructed: incomplete attachment");
+			if (result == GL20.GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS)
+				throw new IllegalStateException("frame buffer couldn't be constructed: incomplete dimensions");
+			if (result == GL20.GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT)
+				throw new IllegalStateException("frame buffer couldn't be constructed: missing attachment");
+			if (result == GL20.GL_FRAMEBUFFER_UNSUPPORTED)
+				throw new IllegalStateException("frame buffer couldn't be constructed: unsupported combination of formats");
+			throw new IllegalStateException("frame buffer couldn't be constructed: unknown error " + result);
+		}
+	}
+
+	/** Releases all resources associated with the FrameBuffer. */
+	@Override
+	public void dispose () {
+		GL20 gl = Gdx.gl20;
+
+		IntBuffer handle = BufferUtils.newIntBuffer(1);
+
+		colorTexture.dispose();
+		if (hasDepth)
+			gl.glDeleteRenderbuffer(depthbufferHandle);
+
+		if (hasStencil)
+			gl.glDeleteRenderbuffer(stencilbufferHandle);
+
+		gl.glDeleteFramebuffer(framebufferHandle);
+
+		if (buffers.get(Gdx.app) != null) buffers.get(Gdx.app).removeValue(this, true);
+	}
+
+	/** Makes the frame buffer current so everything gets drawn to it. */
+	public void bind () {
+		Gdx.gl20.glBindFramebuffer(GL20.GL_FRAMEBUFFER, framebufferHandle);
+	}
+
+	/** Unbinds the framebuffer, all drawing will be performed to the normal framebuffer from here on. */
+	public static void unbind () {
+		Gdx.gl20.glBindFramebuffer(GL20.GL_FRAMEBUFFER, defaultFramebufferHandle);
+	}
+
+	/** Binds the frame buffer and sets the viewport accordingly, so everything gets drawn to it. */
+	public void begin () {
+		bind();
+		setFrameBufferViewport();
+	}
+
+	/** Sets viewport to the dimensions of framebuffer. Called by {@link #begin()}. */
+	protected void setFrameBufferViewport () {
+		Gdx.gl20.glViewport(0, 0, colorTexture.getWidth(), colorTexture.getHeight());
+	}
+
+	/** Unbinds the framebuffer, all drawing will be performed to the normal framebuffer from here on. */
+	public void end () {
+		end(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
+	}
+
+	/** Unbinds the framebuffer and sets viewport sizes, all drawing will be performed to the normal framebuffer from here on.
+	 *
+	 * @param x the x-axis position of the viewport in pixels
+	 * @param y the y-asis position of the viewport in pixels
+	 * @param width the width of the viewport in pixels
+	 * @param height the height of the viewport in pixels */
+	public void end (int x, int y, int width, int height) {
+		unbind();
+		Gdx.gl20.glViewport(x, y, width, height);
+	}
+
+	/** @return the gl texture */
+	public GLTexture getGLTexture () {
+		return colorTexture;
+	}
+
+	/** @return the height of the framebuffer in pixels */
+	public int getHeight () {
+		return colorTexture.getHeight();
+	}
+
+	/** @return the width of the framebuffer in pixels */
+	public int getWidth () {
+		return colorTexture.getWidth();
+	}
+
+	private static void addManagedFrameBuffer (Application app, GLFrameBuffer frameBuffer) {
+		Array<GLFrameBuffer> managedResources = buffers.get(app);
+		if (managedResources == null) managedResources = new Array<GLFrameBuffer>();
+		managedResources.add(frameBuffer);
+		buffers.put(app, managedResources);
+	}
+
+	/** Invalidates all frame buffers. This can be used when the OpenGL context is lost to rebuild all managed frame buffers. This
+	 * assumes that the texture attached to this buffer has already been rebuild! Use with care. */
+	public static void invalidateAllFrameBuffers (Application app) {
+		if (Gdx.gl20 == null) return;
+
+		Array<GLFrameBuffer> bufferArray = buffers.get(app);
+		if (bufferArray == null) return;
+		for (int i = 0; i < bufferArray.size; i++) {
+			bufferArray.get(i).build();
+		}
+	}
+
+	public static void clearAllFrameBuffers (Application app) {
+		buffers.remove(app);
+	}
+
+	public static StringBuilder getManagedStatus (final StringBuilder builder) {
+		builder.append("Managed buffers/app: { ");
+		for (Application app : buffers.keySet()) {
+			builder.append(buffers.get(app).size);
+			builder.append(" ");
+		}
+		builder.append("}");
+		return builder;
+	}
+
+	public static String getManagedStatus () {
+		return getManagedStatus(new StringBuilder()).toString();
+	}
+}
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/IndexArray.java b/gdx/src/com/badlogic/gdx/graphics/glutils/IndexArray.java
index 3d6b46e..782d32c 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/IndexArray.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/IndexArray.java
@@ -29,19 +29,10 @@ public class IndexArray implements IndexData {
 	ShortBuffer buffer;
 	ByteBuffer byteBuffer;
 
-	// used to work around bug: https://android-review.googlesource.com/#/c/73175/
-	private final boolean empty;
-
 	/** Creates a new IndexArray to be used with vertex arrays.
 	 * 
 	 * @param maxIndices the maximum number of indices this buffer can hold */
 	public IndexArray (int maxIndices) {
-
-		empty = maxIndices == 0;
-		if (empty) {
-			maxIndices = 1; // avoid allocating a zero-sized buffer because of bug in Android's ART < Android 5.0
-		}
-
 		byteBuffer = BufferUtils.newUnsafeByteBuffer(maxIndices * 2);
 		buffer = byteBuffer.asShortBuffer();
 		buffer.flip();
@@ -50,12 +41,12 @@ public class IndexArray implements IndexData {
 
 	/** @return the number of indices currently stored in this buffer */
 	public int getNumIndices () {
-		return empty ? 0 : buffer.limit();
+		return buffer.limit();
 	}
 
 	/** @return the maximum number of indices this IndexArray can store. */
 	public int getNumMaxIndices () {
-		return empty ? 0 : buffer.capacity();
+		return buffer.capacity();
 	}
 
 	/** <p>
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/IndexBufferObject.java b/gdx/src/com/badlogic/gdx/graphics/glutils/IndexBufferObject.java
index b2fbed6..dc69df4 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/IndexBufferObject.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/IndexBufferObject.java
@@ -43,7 +43,7 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
  * VertexBufferObjects must be disposed via the {@link #dispose()} method when no longer needed
  * </p>
  * 
- * @author mzechner, Thorsten Schleinzer */
+ * @author mzechner */
 public class IndexBufferObject implements IndexData {
 	ShortBuffer buffer;
 	ByteBuffer byteBuffer;
@@ -53,27 +53,11 @@ public class IndexBufferObject implements IndexData {
 	boolean isBound = false;
 	final int usage;
 
-	// used to work around bug: https://android-review.googlesource.com/#/c/73175/
-	private final boolean empty;
-
-	/** Creates a new static IndexBufferObject to be used with vertex arrays.
-	 * 
-	 * @param maxIndices the maximum number of indices this buffer can hold */
-	public IndexBufferObject (int maxIndices) {
-		this(true, maxIndices);
-	}
-
 	/** Creates a new IndexBufferObject.
 	 * 
 	 * @param isStatic whether the index buffer is static
 	 * @param maxIndices the maximum number of indices this buffer can hold */
 	public IndexBufferObject (boolean isStatic, int maxIndices) {
-
-		empty = maxIndices == 0;
-		if (empty) {
-			maxIndices = 1; // avoid allocating a zero-sized buffer because of bug in Android's ART < Android 5.0
-		}
-
 		byteBuffer = BufferUtils.newUnsafeByteBuffer(maxIndices * 2);
 		isDirect = true;
 
@@ -84,14 +68,28 @@ public class IndexBufferObject implements IndexData {
 		usage = isStatic ? GL20.GL_STATIC_DRAW : GL20.GL_DYNAMIC_DRAW;
 	}
 
+	/** Creates a new IndexBufferObject to be used with vertex arrays.
+	 * 
+	 * @param maxIndices the maximum number of indices this buffer can hold */
+	public IndexBufferObject (int maxIndices) {
+		byteBuffer = BufferUtils.newUnsafeByteBuffer(maxIndices * 2);
+		this.isDirect = true;
+
+		buffer = byteBuffer.asShortBuffer();
+		buffer.flip();
+		byteBuffer.flip();
+		bufferHandle = Gdx.gl20.glGenBuffer();
+		usage = GL20.GL_STATIC_DRAW;
+	}
+
 	/** @return the number of indices currently stored in this buffer */
 	public int getNumIndices () {
-		return empty ? 0 : buffer.limit();
+		return buffer.limit();
 	}
 
 	/** @return the maximum number of indices this IndexBufferObject can store. */
 	public int getNumMaxIndices () {
-		return empty ? 0 : buffer.capacity();
+		return buffer.capacity();
 	}
 
 	/** <p>
@@ -119,7 +117,7 @@ public class IndexBufferObject implements IndexData {
 			isDirty = false;
 		}
 	}
-
+	
 	public void setIndices (ShortBuffer indices) {
 		isDirty = true;
 		int pos = indices.position();
@@ -129,13 +127,14 @@ public class IndexBufferObject implements IndexData {
 		indices.position(pos);
 		byteBuffer.position(0);
 		byteBuffer.limit(buffer.limit() << 1);
-
+		
 		if (isBound) {
 			Gdx.gl20.glBufferData(GL20.GL_ELEMENT_ARRAY_BUFFER, byteBuffer.limit(), byteBuffer, usage);
 			isDirty = false;
 		}
 	}
 
+
 	/** <p>
 	 * Returns the underlying ShortBuffer. If you modify the buffer contents they wil be uploaded on the call to {@link #bind()}.
 	 * If you need immediate uploading use {@link #setIndices(short[], int, int)}.
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexArray.java b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexArray.java
index 639e7ed..1e1bdcd 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexArray.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexArray.java
@@ -19,9 +19,11 @@ package com.badlogic.gdx.graphics.glutils;
 import java.nio.ByteBuffer;
 import java.nio.FloatBuffer;
 
+import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.VertexAttribute;
 import com.badlogic.gdx.graphics.VertexAttributes;
+import com.badlogic.gdx.graphics.VertexAttributes.Usage;
 import com.badlogic.gdx.utils.BufferUtils;
 
 /** <p>
@@ -30,7 +32,7 @@ import com.badlogic.gdx.utils.BufferUtils;
  * </p>
  * 
  * <p>
- * This class is not compatible with OpenGL 3+ core profiles. For this {@link VertexBufferObject}s are needed.
+ * This class does not support shaders and for that matter OpenGL ES 2.0. For this {@link VertexBufferObject}s are needed.
  * </p>
  * 
  * @author mzechner, Dave Clayton <contact@redskyforge.com> */
@@ -101,6 +103,7 @@ public class VertexArray implements VertexData {
 
 	@Override
 	public void bind (final ShaderProgram shader, final int[] locations) {
+		final GL20 gl = Gdx.gl20;
 		final int numAttributes = attributes.size();
 		byteBuffer.limit(buffer.limit() * 4);
 		if (locations == null) {
@@ -151,6 +154,7 @@ public class VertexArray implements VertexData {
 
 	@Override
 	public void unbind (ShaderProgram shader, int[] locations) {
+		final GL20 gl = Gdx.gl20;
 		final int numAttributes = attributes.size();
 		if (locations == null) {
 			for (int i = 0; i < numAttributes; i++) {
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java
index 17714db..6e0aff3 100644
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java
+++ b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObject.java
@@ -16,7 +16,6 @@
 
 package com.badlogic.gdx.graphics.glutils;
 
-import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.FloatBuffer;
 
@@ -25,7 +24,6 @@ import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.VertexAttribute;
 import com.badlogic.gdx.graphics.VertexAttributes;
 import com.badlogic.gdx.utils.BufferUtils;
-import com.badlogic.gdx.utils.GdxRuntimeException;
 
 /** <p>
  * A {@link VertexData} implementation based on OpenGL vertex buffer objects.
@@ -51,12 +49,12 @@ import com.badlogic.gdx.utils.GdxRuntimeException;
  * 
  * @author mzechner, Dave Clayton <contact@redskyforge.com> */
 public class VertexBufferObject implements VertexData {
-	private VertexAttributes attributes;
-	private FloatBuffer buffer;
-	private ByteBuffer byteBuffer;
-	private boolean ownsBuffer;
-	private int bufferHandle;
-	private int usage;
+	final VertexAttributes attributes;
+	final FloatBuffer buffer;
+	final ByteBuffer byteBuffer;
+	int bufferHandle;
+	final boolean isStatic;
+	final int usage;
 	boolean isDirty = false;
 	boolean isBound = false;
 
@@ -75,19 +73,15 @@ public class VertexBufferObject implements VertexData {
 	 * @param numVertices the maximum number of vertices
 	 * @param attributes the {@link VertexAttributes}. */
 	public VertexBufferObject (boolean isStatic, int numVertices, VertexAttributes attributes) {
-		bufferHandle = Gdx.gl20.glGenBuffer();
+		this.isStatic = isStatic;
+		this.attributes = attributes;
 
-		ByteBuffer data = BufferUtils.newUnsafeByteBuffer(attributes.vertexSize * numVertices);
-		data.limit(0);
-		setBuffer(data, true, attributes);
-		setUsage(isStatic ? GL20.GL_STATIC_DRAW : GL20.GL_DYNAMIC_DRAW);
-	}
-	
-	protected VertexBufferObject (int usage, ByteBuffer data, boolean ownsBuffer, VertexAttributes attributes) {
+		byteBuffer = BufferUtils.newUnsafeByteBuffer(this.attributes.vertexSize * numVertices);
+		buffer = byteBuffer.asFloatBuffer();
+		buffer.flip();
+		byteBuffer.flip();
 		bufferHandle = Gdx.gl20.glGenBuffer();
-		
-		setBuffer(data, ownsBuffer, attributes);
-		setUsage(usage);
+		usage = isStatic ? GL20.GL_STATIC_DRAW : GL20.GL_DYNAMIC_DRAW;
 	}
 
 	@Override
@@ -111,28 +105,6 @@ public class VertexBufferObject implements VertexData {
 		return buffer;
 	}
 
-	/** Low level method to reset the buffer and attributes to the specified values. Use with care!
-	 * @param data
-	 * @param ownsBuffer
-	 * @param value */
-	protected void setBuffer (Buffer data, boolean ownsBuffer, VertexAttributes value) {
-		if (isBound) throw new GdxRuntimeException("Cannot change attributes while VBO is bound");
-		if (this.ownsBuffer && byteBuffer != null)
-			BufferUtils.disposeUnsafeByteBuffer(byteBuffer);
-		attributes = value;
-		if (data instanceof ByteBuffer)
-			byteBuffer = (ByteBuffer)data;
-		else
-			throw new GdxRuntimeException("Only ByteBuffer is currently supported");
-		this.ownsBuffer = ownsBuffer;
-		
-		final int l = byteBuffer.limit();
-		byteBuffer.limit(byteBuffer.capacity());
-		buffer = byteBuffer.asFloatBuffer();
-		byteBuffer.limit(l);
-		buffer.limit(l / 4);
-	}
-
 	private void bufferChanged () {
 		if (isBound) {
 			Gdx.gl20.glBufferData(GL20.GL_ARRAY_BUFFER, byteBuffer.limit(), byteBuffer, usage);
@@ -160,20 +132,8 @@ public class VertexBufferObject implements VertexData {
 		bufferChanged();
 	}
 
-	/** @return The GL enum used in the call to {@link GL20#glBufferData(int, int, java.nio.Buffer, int)}, e.g. GL_STATIC_DRAW or
-	 *         GL_DYNAMIC_DRAW */
-	protected int getUsage () {
-		return usage;
-	}
-
-	/** Set the GL enum used in the call to {@link GL20#glBufferData(int, int, java.nio.Buffer, int)}, can only be called when the
-	 * VBO is not bound. */
-	protected void setUsage (int value) {
-		if (isBound) throw new GdxRuntimeException("Cannot change usage while VBO is bound");
-		usage = value;
-	}
-
 	/** Binds this VertexBufferObject for rendering via glDrawArrays or glDrawElements
+	 * 
 	 * @param shader the shader */
 	@Override
 	public void bind (ShaderProgram shader) {
@@ -199,10 +159,10 @@ public class VertexBufferObject implements VertexData {
 				if (location < 0) continue;
 				shader.enableVertexAttribute(location);
 
-				shader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized,
-					attributes.vertexSize, attribute.offset);
+				shader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,
+						attribute.offset);
 			}
-
+			
 		} else {
 			for (int i = 0; i < numAttributes; i++) {
 				final VertexAttribute attribute = attributes.get(i);
@@ -210,8 +170,8 @@ public class VertexBufferObject implements VertexData {
 				if (location < 0) continue;
 				shader.enableVertexAttribute(location);
 
-				shader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized,
-					attributes.vertexSize, attribute.offset);
+				shader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,
+					attribute.offset);
 			}
 		}
 		isBound = true;
@@ -244,7 +204,6 @@ public class VertexBufferObject implements VertexData {
 	}
 
 	/** Invalidates the VertexBufferObject so a new OpenGL buffer handle is created. Use this in case of a context loss. */
-	@Override
 	public void invalidate () {
 		bufferHandle = Gdx.gl20.glGenBuffer();
 		isDirty = true;
@@ -257,6 +216,6 @@ public class VertexBufferObject implements VertexData {
 		gl.glBindBuffer(GL20.GL_ARRAY_BUFFER, 0);
 		gl.glDeleteBuffer(bufferHandle);
 		bufferHandle = 0;
-		if (ownsBuffer) BufferUtils.disposeUnsafeByteBuffer(byteBuffer);
+		BufferUtils.disposeUnsafeByteBuffer(byteBuffer);
 	}
 }
diff --git a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObjectWithVAO.java b/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObjectWithVAO.java
deleted file mode 100644
index 8bdd22e..0000000
--- a/gdx/src/com/badlogic/gdx/graphics/glutils/VertexBufferObjectWithVAO.java
+++ /dev/null
@@ -1,243 +0,0 @@
-package com.badlogic.gdx.graphics.glutils;
-
-import java.nio.ByteBuffer;
-import java.nio.FloatBuffer;
-import java.nio.IntBuffer;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.GL30;
-import com.badlogic.gdx.graphics.VertexAttribute;
-import com.badlogic.gdx.graphics.VertexAttributes;
-import com.badlogic.gdx.utils.BufferUtils;
-
-/**
- * <p>
- * A {@link VertexData} implementation that uses vertex buffer objects and vertex array objects.
- * (This is required for OpenGL 3.0+ core profiles. In particular, the default VAO has been
- * deprecated, as has the use of client memory for passing vertex attributes.) Use of VAOs should
- * give a slight performance benefit since you don't have to bind the attributes on every draw
- * anymore.
- * </p>
- *
- * <p>
- * If the OpenGL ES context was lost you can call {@link #invalidate()} to recreate a new OpenGL vertex buffer object.
- * </p>
- *
- * <p>
- * VertexBufferObjectWithVAO objects must be disposed via the {@link #dispose()} method when no longer needed
- * </p>
- *
- * Code adapted from {@link VertexBufferObject}.
- * @author mzechner, Dave Clayton <contact@redskyforge.com>, Nate Austin <nate.austin gmail>
- */
-public class VertexBufferObjectWithVAO implements VertexData {
-	final static IntBuffer tmpHandle = BufferUtils.newIntBuffer(1);
-
-	final VertexAttributes attributes;
-	final FloatBuffer buffer;
-	final ByteBuffer byteBuffer;
-	int bufferHandle;
-	final boolean isStatic;
-	final int usage;
-	boolean isDirty = false;
-	boolean isBound = false;
-	boolean vaoDirty = true;
-	int vaoHandle = -1;
-
-
-	/**
-	 * Constructs a new interleaved VertexBufferObjectWithVAO.
-	 *
-	 * @param isStatic    whether the vertex data is static.
-	 * @param numVertices the maximum number of vertices
-	 * @param attributes  the {@link com.badlogic.gdx.graphics.VertexAttribute}s.
-	 */
-	public VertexBufferObjectWithVAO(boolean isStatic, int numVertices, VertexAttribute... attributes) {
-		this(isStatic, numVertices, new VertexAttributes(attributes));
-	}
-
-	/**
-	 * Constructs a new interleaved VertexBufferObjectWithVAO.
-	 *
-	 * @param isStatic    whether the vertex data is static.
-	 * @param numVertices the maximum number of vertices
-	 * @param attributes  the {@link VertexAttributes}.
-	 */
-	public VertexBufferObjectWithVAO(boolean isStatic, int numVertices, VertexAttributes attributes) {
-		this.isStatic = isStatic;
-		this.attributes = attributes;
-
-		byteBuffer = BufferUtils.newUnsafeByteBuffer(this.attributes.vertexSize * numVertices);
-		buffer = byteBuffer.asFloatBuffer();
-		buffer.flip();
-		byteBuffer.flip();
-		bufferHandle = Gdx.gl20.glGenBuffer();
-		usage = isStatic ? GL20.GL_STATIC_DRAW : GL20.GL_DYNAMIC_DRAW;
-	}
-
-	@Override
-	public VertexAttributes getAttributes() {
-		return attributes;
-	}
-
-	@Override
-	public int getNumVertices() {
-		return buffer.limit() * 4 / attributes.vertexSize;
-	}
-
-	@Override
-	public int getNumMaxVertices() {
-		return byteBuffer.capacity() / attributes.vertexSize;
-	}
-
-	@Override
-	public FloatBuffer getBuffer() {
-		isDirty = true;
-		return buffer;
-	}
-
-	private void bufferChanged() {
-		if (isBound) {
-			Gdx.gl20.glBufferData(GL20.GL_ARRAY_BUFFER, byteBuffer.limit(), byteBuffer, usage);
-			isDirty = false;
-		}
-	}
-
-	@Override
-	public void setVertices(float[] vertices, int offset, int count) {
-		isDirty = true;
-		BufferUtils.copy(vertices, byteBuffer, count, offset);
-		buffer.position(0);
-		buffer.limit(count);
-		bufferChanged();
-	}
-
-	@Override
-	public void updateVertices(int targetOffset, float[] vertices, int sourceOffset, int count) {
-		isDirty = true;
-		final int pos = byteBuffer.position();
-		byteBuffer.position(targetOffset * 4);
-		BufferUtils.copy(vertices, sourceOffset, count, byteBuffer);
-		byteBuffer.position(pos);
-		buffer.position(0);
-		bufferChanged();
-	}
-
-	/**
-	 * Binds this VertexBufferObject for rendering via glDrawArrays or glDrawElements
-	 *
-	 * @param shader the shader
-	 */
-	@Override
-	public void bind(ShaderProgram shader) {
-		bind(shader, null);
-	}
-
-	@Override
-	public void bind(ShaderProgram shader, int[] locations) {
-		GL30 gl = Gdx.gl30;
-		if (vaoDirty || !gl.glIsVertexArray(vaoHandle)) {
-			tmpHandle.clear();
-			gl.glGenVertexArrays(1, tmpHandle);
-			vaoHandle = tmpHandle.get(0);
-			gl.glBindVertexArray(vaoHandle);
-
-			//initialize the VAO with our vertex attributes and buffer:
-			bindAttributes(shader, locations);
-			vaoDirty = false;
-
-		} else {
-			//else simply bind the VAO.
-			gl.glBindVertexArray(vaoHandle);
-		}
-		//if our data has changed upload it:
-		bindData(gl);
-
-		isBound = true;
-	}
-
-	private void bindAttributes(ShaderProgram shader, int[] locations) {
-		final GL20 gl = Gdx.gl20;
-		gl.glBindBuffer(GL20.GL_ARRAY_BUFFER, bufferHandle);
-		final int numAttributes = attributes.size();
-		if (locations == null) {
-			for (int i = 0; i < numAttributes; i++) {
-				final VertexAttribute attribute = attributes.get(i);
-				final int location = shader.getAttributeLocation(attribute.alias);
-				if (location < 0) continue;
-				shader.enableVertexAttribute(location);
-
-				shader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,
-						attribute.offset);
-			}
-
-		} else {
-			for (int i = 0; i < numAttributes; i++) {
-				final VertexAttribute attribute = attributes.get(i);
-				final int location = locations[i];
-				if (location < 0) continue;
-				shader.enableVertexAttribute(location);
-
-				shader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,
-						attribute.offset);
-			}
-		}
-	}
-
-	private void bindData(GL20 gl) {
-		if (isDirty) {
-			gl.glBindBuffer(GL20.GL_ARRAY_BUFFER, bufferHandle);
-			byteBuffer.limit(buffer.limit() * 4);
-			gl.glBufferData(GL20.GL_ARRAY_BUFFER, byteBuffer.limit(), byteBuffer, usage);
-			isDirty = false;
-		}
-	}
-
-	/**
-	 * Unbinds this VertexBufferObject.
-	 *
-	 * @param shader the shader
-	 */
-	@Override
-	public void unbind(final ShaderProgram shader) {
-		unbind(shader, null);
-	}
-
-	@Override
-	public void unbind(final ShaderProgram shader, final int[] locations) {
-		GL30 gl = Gdx.gl30;
-		gl.glBindVertexArray(0);
-		isBound = false;
-	}
-
-	/**
-	 * Invalidates the VertexBufferObject so a new OpenGL buffer handle is created. Use this in case of a context loss.
-	 */
-	@Override
-	public void invalidate() {
-		bufferHandle = Gdx.gl20.glGenBuffer();
-		isDirty = true;
-		vaoDirty = true;
-	}
-
-	/**
-	 * Disposes of all resources this VertexBufferObject uses.
-	 */
-	@Override
-	public void dispose() {
-		GL30 gl = Gdx.gl30;
-
-		gl.glBindBuffer(GL20.GL_ARRAY_BUFFER, 0);
-		gl.glDeleteBuffer(bufferHandle);
-		bufferHandle = 0;
-		BufferUtils.disposeUnsafeByteBuffer(byteBuffer);
-
-		if (gl.glIsVertexArray(vaoHandle)) {
-			tmpHandle.clear();
-			tmpHandle.put(vaoHandle);
-			tmpHandle.flip();
-			gl.glDeleteVertexArrays(1, tmpHandle);
-		}
-	}
-}
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/AtlasTmxMapLoader.java b/gdx/src/com/badlogic/gdx/maps/tiled/AtlasTmxMapLoader.java
index 286615b..f443eff 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/AtlasTmxMapLoader.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/AtlasTmxMapLoader.java
@@ -139,10 +139,8 @@ public class AtlasTmxMapLoader extends BaseTmxMapLoader<AtlasTmxMapLoader.AtlasT
 		try {
 			if (parameter != null) {
 				convertObjectToTileSpace = parameter.convertObjectToTileSpace;
-				flipY = parameter.flipY;
 			} else {
 				convertObjectToTileSpace = false;
-				flipY = true;
 			}
 
 			FileHandle tmxFile = resolve(fileName);
@@ -205,10 +203,8 @@ public class AtlasTmxMapLoader extends BaseTmxMapLoader<AtlasTmxMapLoader.AtlasT
 
 		if (parameter != null) {
 			convertObjectToTileSpace = parameter.convertObjectToTileSpace;
-			flipY = parameter.flipY;
 		} else {
 			convertObjectToTileSpace = false;
-			flipY = true;
 		}
 
 		try {
@@ -373,7 +369,7 @@ public class AtlasTmxMapLoader extends BaseTmxMapLoader<AtlasTmxMapLoader.AtlasT
 					int tileid = firstgid + region.index;
 					tile.setId(tileid);
 					tile.setOffsetX(offsetX);
-					tile.setOffsetY(flipY ? -offsetY : offsetY);
+					tile.setOffsetY(-offsetY);
 					tileset.putTile(tileid, tile);
 				}
 			}
@@ -392,7 +388,7 @@ public class AtlasTmxMapLoader extends BaseTmxMapLoader<AtlasTmxMapLoader.AtlasT
 						tile = new StaticTiledMapTile(region);
 						tile.setId(tileid);
 						tile.setOffsetX(offsetX);
-						tile.setOffsetY(flipY ? -offsetY : offsetY);
+						tile.setOffsetY(-offsetY);
 						tileset.putTile(tileid, tile);
 					}
 				}
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/BaseTmxMapLoader.java b/gdx/src/com/badlogic/gdx/maps/tiled/BaseTmxMapLoader.java
index 5c829c2..f8dd3bc 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/BaseTmxMapLoader.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/BaseTmxMapLoader.java
@@ -42,9 +42,6 @@ public abstract class BaseTmxMapLoader<P extends AssetLoaderParameters<TiledMap>
 		public TextureFilter textureMagFilter = TextureFilter.Nearest;
 		/** Whether to convert the objects' pixel position and size to the equivalent in tile space. **/
 		public boolean convertObjectToTileSpace = false;
-		/** Whether to flip all Y coordinates so that Y positive is down. All LibGDX renderers require flipped Y coordinates, and
-		 * thus flipY set to true. This parameter is included for non-rendering related purposes of TMX files, or custom renderers. */
-		public boolean flipY = true;
 	}
 
 	protected static final int FLAG_FLIP_HORIZONTALLY = 0x80000000;
@@ -55,7 +52,6 @@ public abstract class BaseTmxMapLoader<P extends AssetLoaderParameters<TiledMap>
 	protected XmlReader xml = new XmlReader();
 	protected Element root;
 	protected boolean convertObjectToTileSpace;
-	protected boolean flipY = true;
 
 	protected int mapTileWidth;
 	protected int mapTileHeight;
@@ -91,7 +87,7 @@ public abstract class BaseTmxMapLoader<P extends AssetLoaderParameters<TiledMap>
 					if (tile != null) {
 						Cell cell = createTileLayerCell(flipHorizontally, flipVertically, flipDiagonally);
 						cell.setTile(tile);
-						layer.setCell(x, flipY ? height - 1 - y : y, cell);
+						layer.setCell(x, height - 1 - y, cell);
 					}
 				}
 			}
@@ -125,10 +121,7 @@ public abstract class BaseTmxMapLoader<P extends AssetLoaderParameters<TiledMap>
 	protected void loadImageLayer (TiledMap map, Element element, FileHandle tmxFile, ImageResolver imageResolver) {
 		if (element.getName().equals("imagelayer")) {
 			int x = Integer.parseInt(element.getAttribute("x", "0"));
-			int y = Integer.parseInt(element.getAttribute("y", "0"));
-
-			if (flipY) y = mapHeightInPixels - y;
-
+			int y = mapHeightInPixels - Integer.parseInt(element.getAttribute("y", "0"));
 			TextureRegion texture = null;
 
 			Element image = element.getChildByName("image");
@@ -171,7 +164,7 @@ public abstract class BaseTmxMapLoader<P extends AssetLoaderParameters<TiledMap>
 			float scaleY = convertObjectToTileSpace ? 1.0f / mapTileHeight : 1.0f;
 
 			float x = element.getFloatAttribute("x", 0) * scaleX;
-			float y = (flipY ? (mapHeightInPixels - element.getFloatAttribute("y", 0)) : element.getFloatAttribute("y", 0)) * scaleY;
+			float y = (mapHeightInPixels - element.getFloatAttribute("y", 0)) * scaleY;
 
 			float width = element.getFloatAttribute("width", 0) * scaleX;
 			float height = element.getFloatAttribute("height", 0) * scaleY;
@@ -184,7 +177,7 @@ public abstract class BaseTmxMapLoader<P extends AssetLoaderParameters<TiledMap>
 					for (int i = 0; i < points.length; i++) {
 						String[] point = points[i].split(",");
 						vertices[i * 2] = Float.parseFloat(point[0]) * scaleX;
-						vertices[i * 2 + 1] = Float.parseFloat(point[1]) * scaleY * (flipY ? -1 : 1);
+						vertices[i * 2 + 1] = -Float.parseFloat(point[1]) * scaleY;
 					}
 					Polygon polygon = new Polygon(vertices);
 					polygon.setPosition(x, y);
@@ -195,13 +188,13 @@ public abstract class BaseTmxMapLoader<P extends AssetLoaderParameters<TiledMap>
 					for (int i = 0; i < points.length; i++) {
 						String[] point = points[i].split(",");
 						vertices[i * 2] = Float.parseFloat(point[0]) * scaleX;
-						vertices[i * 2 + 1] = Float.parseFloat(point[1]) * scaleY * (flipY ? -1 : 1);
+						vertices[i * 2 + 1] = -Float.parseFloat(point[1]) * scaleY;
 					}
 					Polyline polyline = new Polyline(vertices);
 					polyline.setPosition(x, y);
 					object = new PolylineMapObject(polyline);
 				} else if ((child = element.getChildByName("ellipse")) != null) {
-					object = new EllipseMapObject(x, flipY ? y - height : y, width, height);
+					object = new EllipseMapObject(x, y - height, width, height);
 				}
 			}
 			if (object == null) {
@@ -217,13 +210,13 @@ public abstract class BaseTmxMapLoader<P extends AssetLoaderParameters<TiledMap>
 					TextureMapObject textureMapObject = new TextureMapObject(textureRegion);
 					textureMapObject.getProperties().put("gid", id);
 					textureMapObject.setX(x);
-					textureMapObject.setY(flipY ? y - height : y);
+					textureMapObject.setY(y - height);
 					textureMapObject.setScaleX(scaleX);
 					textureMapObject.setScaleY(scaleY);
 					textureMapObject.setRotation(element.getFloatAttribute("rotation", 0));
 					object = textureMapObject;
 				} else {
-					object = new RectangleMapObject(x, flipY ? y - height : y, width, height);
+					object = new RectangleMapObject(x, y - height, width, height);
 				}
 			}
 			object.setName(element.getAttribute("name", null));
@@ -240,7 +233,7 @@ public abstract class BaseTmxMapLoader<P extends AssetLoaderParameters<TiledMap>
 				object.getProperties().put("id", id);
 			}
 			object.getProperties().put("x", x * scaleX);
-			object.getProperties().put("y", (flipY ? y - height : y) * scaleY);
+			object.getProperties().put("y", (y - height) * scaleY);
 			object.getProperties().put("width", width);
 			object.getProperties().put("height", height);
 			object.setVisible(element.getIntAttribute("visible", 1) == 1);
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/TideMapLoader.java b/gdx/src/com/badlogic/gdx/maps/tiled/TideMapLoader.java
index e86fa3c..b1a314f 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/TideMapLoader.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/TideMapLoader.java
@@ -106,7 +106,7 @@ public class TideMapLoader extends SynchronousAssetLoader<TiledMap, TideMapLoade
 	 * @return the {@link TiledMap} */
 	private TiledMap loadMap (Element root, FileHandle tmxFile, ImageResolver imageResolver) {
 		TiledMap map = new TiledMap();
-		Element properties = root.getChildByName("Properties");
+		Element properties = root.getChildByName("properties");
 		if (properties != null) {
 			loadProperties(map.getProperties(), properties);
 		}
@@ -261,12 +261,6 @@ public class TideMapLoader extends SynchronousAssetLoader<TiledMap, TideMapLoade
 					}
 				}
 			}
-			
-			Element properties = element.getChildByName("Properties");
-			if (properties != null) {
-				loadProperties(layer.getProperties(), properties);
-			}
-			
 			map.getLayers().add(layer);
 		}
 	}
diff --git a/gdx/src/com/badlogic/gdx/maps/tiled/TmxMapLoader.java b/gdx/src/com/badlogic/gdx/maps/tiled/TmxMapLoader.java
index 67de6aa..a64e068 100644
--- a/gdx/src/com/badlogic/gdx/maps/tiled/TmxMapLoader.java
+++ b/gdx/src/com/badlogic/gdx/maps/tiled/TmxMapLoader.java
@@ -73,7 +73,6 @@ public class TmxMapLoader extends BaseTmxMapLoader<TmxMapLoader.Parameters> {
 	public TiledMap load (String fileName, TmxMapLoader.Parameters parameters) {
 		try {
 			this.convertObjectToTileSpace = parameters.convertObjectToTileSpace;
-			this.flipY = parameters.flipY;
 			FileHandle tmxFile = resolve(fileName);
 			root = xml.parse(tmxFile);
 			ObjectMap<String, Texture> textures = new ObjectMap<String, Texture>();
@@ -101,10 +100,8 @@ public class TmxMapLoader extends BaseTmxMapLoader<TmxMapLoader.Parameters> {
 
 		if (parameter != null) {
 			convertObjectToTileSpace = parameter.convertObjectToTileSpace;
-			flipY = parameter.flipY;
 		} else {
 			convertObjectToTileSpace = false;
-			flipY = true;
 		}
 		try {
 			map = loadTilemap(root, tmxFile, new AssetManagerImageResolver(manager));
@@ -382,7 +379,7 @@ public class TmxMapLoader extends BaseTmxMapLoader<TmxMapLoader.Parameters> {
 						TiledMapTile tile = new StaticTiledMapTile(tileRegion);
 						tile.setId(id);
 						tile.setOffsetX(offsetX);
-						tile.setOffsetY(flipY ? -offsetY : offsetY);
+						tile.setOffsetY(-offsetY);
 						tileset.putTile(id++, tile);
 					}
 				}
@@ -400,7 +397,7 @@ public class TmxMapLoader extends BaseTmxMapLoader<TmxMapLoader.Parameters> {
 					TiledMapTile tile = new StaticTiledMapTile(texture);
 					tile.setId(firstgid + tileElement.getIntAttribute("id"));
 					tile.setOffsetX(offsetX);
-					tile.setOffsetY(flipY ? -offsetY : offsetY);
+					tile.setOffsetY(-offsetY);
 					tileset.putTile(tile.getId(), tile);
 				}
 			}
diff --git a/gdx/src/com/badlogic/gdx/math/Frustum.java b/gdx/src/com/badlogic/gdx/math/Frustum.java
index b997887..1150d02 100644
--- a/gdx/src/com/badlogic/gdx/math/Frustum.java
+++ b/gdx/src/com/badlogic/gdx/math/Frustum.java
@@ -38,8 +38,6 @@ public class Frustum {
 			clipSpacePlanePointsArray[j++] = v.z;
 		}
 	}
-	
-	private final static Vector3 tmpV = new Vector3();
 
 	/** the six clipping planes, near, far, left, right, top, bottom **/
 	public final Plane[] planes = new Plane[6];
@@ -157,16 +155,16 @@ public class Frustum {
 	 * @param bounds The bounding box
 	 * @return Whether the bounding box is in the frustum */
 	public boolean boundsInFrustum (BoundingBox bounds) {
+		Vector3[] corners = bounds.getCorners();
+		int len = corners.length;
+
 		for (int i = 0, len2 = planes.length; i < len2; i++) {
-			if (planes[i].testPoint(bounds.getCorner000(tmpV)) != PlaneSide.Back) continue;
-			if (planes[i].testPoint(bounds.getCorner001(tmpV)) != PlaneSide.Back) continue;
-			if (planes[i].testPoint(bounds.getCorner010(tmpV)) != PlaneSide.Back) continue;
-			if (planes[i].testPoint(bounds.getCorner011(tmpV)) != PlaneSide.Back) continue;
-			if (planes[i].testPoint(bounds.getCorner100(tmpV)) != PlaneSide.Back) continue;
-			if (planes[i].testPoint(bounds.getCorner101(tmpV)) != PlaneSide.Back) continue;
-			if (planes[i].testPoint(bounds.getCorner110(tmpV)) != PlaneSide.Back) continue;
-			if (planes[i].testPoint(bounds.getCorner111(tmpV)) != PlaneSide.Back) continue;
-			return false;
+			int out = 0;
+
+			for (int j = 0; j < len; j++)
+				if (planes[i].testPoint(corners[j]) == PlaneSide.Back) out++;
+
+			if (out == 8) return false;
 		}
 
 		return true;
diff --git a/gdx/src/com/badlogic/gdx/math/GeometryUtils.java b/gdx/src/com/badlogic/gdx/math/GeometryUtils.java
index 10a0297..a75cfba 100644
--- a/gdx/src/com/badlogic/gdx/math/GeometryUtils.java
+++ b/gdx/src/com/badlogic/gdx/math/GeometryUtils.java
@@ -165,14 +165,9 @@ public final class GeometryUtils {
 		x += (x0 + x1) * a;
 		y += (y0 + y1) * a;
 
-		if (signedArea == 0) {
-			centroid.x = 0;
-			centroid.y = 0;
-		} else {
-			signedArea *= 0.5f;
-			centroid.x = x / (6 * signedArea);
-			centroid.y = y / (6 * signedArea);
-		}
+		signedArea *= 0.5f;
+		centroid.x = x / (6 * signedArea);
+		centroid.y = y / (6 * signedArea);
 		return centroid;
 	}
 
@@ -183,11 +178,7 @@ public final class GeometryUtils {
 			int x1 = i;
 			int y1 = i + 1;
 			int x2 = (i + 2) % n;
-			if(x2 < offset)
-				x2 += offset;
 			int y2 = (i + 3) % n;
-			if(y2 < offset)
-				y2 += offset;
 			area += polygon[x1] * polygon[y2];
 			area -= polygon[x2] * polygon[y1];
 		}
diff --git a/gdx/src/com/badlogic/gdx/math/Intersector.java b/gdx/src/com/badlogic/gdx/math/Intersector.java
index e400b72..1de50f5 100644
--- a/gdx/src/com/badlogic/gdx/math/Intersector.java
+++ b/gdx/src/com/badlogic/gdx/math/Intersector.java
@@ -16,14 +16,14 @@
 
 package com.badlogic.gdx.math;
 
-import java.util.Arrays;
-import java.util.List;
-
 import com.badlogic.gdx.math.Plane.PlaneSide;
 import com.badlogic.gdx.math.collision.BoundingBox;
 import com.badlogic.gdx.math.collision.Ray;
 import com.badlogic.gdx.utils.Array;
 
+import java.util.Arrays;
+import java.util.List;
+
 /** Class offering various static methods for intersection testing between different geometric objects.
  * 
  * @author badlogicgames@gmail.com
@@ -460,7 +460,7 @@ public final class Intersector {
 	 * @param box The bounding box
 	 * @return Whether the ray and the bounding box intersect. */
 	static public boolean intersectRayBoundsFast (Ray ray, BoundingBox box) {
-		return intersectRayBoundsFast(ray, box.getCenter(tmp1), box.getDimensions(tmp2));
+		return intersectRayBoundsFast(ray, box.getCenter(), box.getDimensions());
 	}
 
 	/** Quick check whether the given {@link Ray} and {@link BoundingBox} intersect.
diff --git a/gdx/src/com/badlogic/gdx/math/Matrix3.java b/gdx/src/com/badlogic/gdx/math/Matrix3.java
index 4fd6fc5..4768ec4 100644
--- a/gdx/src/com/badlogic/gdx/math/Matrix3.java
+++ b/gdx/src/com/badlogic/gdx/math/Matrix3.java
@@ -57,7 +57,6 @@ public class Matrix3 implements Serializable {
 	/** Sets this matrix to the identity matrix
 	 * @return This matrix for the purpose of chaining operations. */
 	public Matrix3 idt () {
-		float[] val = this.val;
 		val[M00] = 1;
 		val[M10] = 0;
 		val[M20] = 0;
@@ -78,8 +77,6 @@ public class Matrix3 implements Serializable {
 	 * @param m Matrix to multiply by.
 	 * @return This matrix for the purpose of chaining operations together. */
 	public Matrix3 mul (Matrix3 m) {
-		float[] val = this.val;
-
 		float v00 = val[M00] * m.val[M00] + val[M01] * m.val[M10] + val[M02] * m.val[M20];
 		float v01 = val[M00] * m.val[M01] + val[M01] * m.val[M11] + val[M02] * m.val[M21];
 		float v02 = val[M00] * m.val[M02] + val[M01] * m.val[M12] + val[M02] * m.val[M22];
@@ -113,8 +110,6 @@ public class Matrix3 implements Serializable {
 	 * @param m The other Matrix to multiply by
 	 * @return This matrix for the purpose of chaining operations. */
 	public Matrix3 mulLeft (Matrix3 m) {
-		float[] val = this.val;
-
 		float v00 = m.val[M00] * val[M00] + m.val[M01] * val[M10] + m.val[M02] * val[M20];
 		float v01 = m.val[M00] * val[M01] + m.val[M01] * val[M11] + m.val[M02] * val[M21];
 		float v02 = m.val[M00] * val[M02] + m.val[M01] * val[M12] + m.val[M02] * val[M22];
@@ -153,19 +148,18 @@ public class Matrix3 implements Serializable {
 	public Matrix3 setToRotationRad (float radians) {
 		float cos = (float)Math.cos(radians);
 		float sin = (float)Math.sin(radians);
-		float[] val = this.val;
 
-		val[M00] = cos;
-		val[M10] = sin;
-		val[M20] = 0;
+		this.val[M00] = cos;
+		this.val[M10] = sin;
+		this.val[M20] = 0;
 
-		val[M01] = -sin;
-		val[M11] = cos;
-		val[M21] = 0;
+		this.val[M01] = -sin;
+		this.val[M11] = cos;
+		this.val[M21] = 0;
 
-		val[M02] = 0;
-		val[M12] = 0;
-		val[M22] = 1;
+		this.val[M02] = 0;
+		this.val[M12] = 0;
+		this.val[M22] = 1;
 
 		return this;
 	}
@@ -175,7 +169,6 @@ public class Matrix3 implements Serializable {
 	}
 
 	public Matrix3 setToRotation (Vector3 axis, float cos, float sin) {
-		float[] val = this.val;
 		float oc = 1.0f - cos;
 		val[M00] = oc * axis.x * axis.x + cos;
 		val[M10] = oc * axis.x * axis.y - axis.z * sin;
@@ -194,19 +187,17 @@ public class Matrix3 implements Serializable {
 	 * @param y the translation in y
 	 * @return This matrix for the purpose of chaining operations. */
 	public Matrix3 setToTranslation (float x, float y) {
-		float[] val = this.val;
-
-		val[M00] = 1;
-		val[M10] = 0;
-		val[M20] = 0;
+		this.val[M00] = 1;
+		this.val[M10] = 0;
+		this.val[M20] = 0;
 
-		val[M01] = 0;
-		val[M11] = 1;
-		val[M21] = 0;
+		this.val[M01] = 0;
+		this.val[M11] = 1;
+		this.val[M21] = 0;
 
-		val[M02] = x;
-		val[M12] = y;
-		val[M22] = 1;
+		this.val[M02] = x;
+		this.val[M12] = y;
+		this.val[M22] = 1;
 
 		return this;
 	}
@@ -215,19 +206,17 @@ public class Matrix3 implements Serializable {
 	 * @param translation The translation vector.
 	 * @return This matrix for the purpose of chaining operations. */
 	public Matrix3 setToTranslation (Vector2 translation) {
-		float[] val = this.val;
-
-		val[M00] = 1;
-		val[M10] = 0;
-		val[M20] = 0;
+		this.val[M00] = 1;
+		this.val[M10] = 0;
+		this.val[M20] = 0;
 
-		val[M01] = 0;
-		val[M11] = 1;
-		val[M21] = 0;
+		this.val[M01] = 0;
+		this.val[M11] = 1;
+		this.val[M21] = 0;
 
-		val[M02] = translation.x;
-		val[M12] = translation.y;
-		val[M22] = 1;
+		this.val[M02] = translation.x;
+		this.val[M12] = translation.y;
+		this.val[M22] = 1;
 
 		return this;
 	}
@@ -238,7 +227,6 @@ public class Matrix3 implements Serializable {
 	 * @param scaleY the scale in y
 	 * @return This matrix for the purpose of chaining operations. */
 	public Matrix3 setToScaling (float scaleX, float scaleY) {
-		float[] val = this.val;
 		val[M00] = scaleX;
 		val[M10] = 0;
 		val[M20] = 0;
@@ -255,7 +243,6 @@ public class Matrix3 implements Serializable {
 	 * @param scale The scale vector.
 	 * @return This matrix for the purpose of chaining operations. */
 	public Matrix3 setToScaling (Vector2 scale) {
-		float[] val = this.val;
 		val[M00] = scale.x;
 		val[M10] = 0;
 		val[M20] = 0;
@@ -269,15 +256,12 @@ public class Matrix3 implements Serializable {
 	}
 
 	public String toString () {
-		float[] val = this.val;
-		return "[" + val[M00] + "|" + val[M01] + "|" + val[M02] + "]\n" //
-			+ "[" + val[M10] + "|" + val[M11] + "|" + val[M12] + "]\n" //
-			+ "[" + val[M20] + "|" + val[M21] + "|" + val[M22] + "]";
+		return "[" + val[0] + "|" + val[3] + "|" + val[6] + "]\n" + "[" + val[1] + "|" + val[4] + "|" + val[7] + "]\n" + "["
+			+ val[2] + "|" + val[5] + "|" + val[8] + "]";
 	}
 
 	/** @return The determinant of this matrix */
 	public float det () {
-		float[] val = this.val;
 		return val[M00] * val[M11] * val[M22] + val[M01] * val[M12] * val[M20] + val[M02] * val[M10] * val[M21] - val[M00]
 			* val[M12] * val[M21] - val[M01] * val[M10] * val[M22] - val[M02] * val[M11] * val[M20];
 	}
@@ -290,7 +274,6 @@ public class Matrix3 implements Serializable {
 		if (det == 0) throw new GdxRuntimeException("Can't invert a singular matrix");
 
 		float inv_det = 1.0f / det;
-		float[] tmp = this.tmp, val = this.val;
 
 		tmp[M00] = val[M11] * val[M22] - val[M21] * val[M12];
 		tmp[M10] = val[M20] * val[M12] - val[M10] * val[M22];
@@ -327,8 +310,6 @@ public class Matrix3 implements Serializable {
 	 * @param affine The affine matrix to copy.
 	 * @return This matrix for the purposes of chaining. */
 	public Matrix3 set (Affine2 affine) {
-		float[] val = this.val;
-
 		val[M00] = affine.m00;
 		val[M10] = affine.m10;
 		val[M20] = 0;
@@ -346,7 +327,6 @@ public class Matrix3 implements Serializable {
 	 * @param mat The matrix whose top left corner will be copied. This matrix will not be modified.
 	 * @return This matrix for the purpose of chaining operations. */
 	public Matrix3 set (Matrix4 mat) {
-		float[] val = this.val;
 		val[M00] = mat.val[Matrix4.M00];
 		val[M10] = mat.val[Matrix4.M10];
 		val[M20] = mat.val[Matrix4.M20];
@@ -404,7 +384,6 @@ public class Matrix3 implements Serializable {
 	 * @param y The y-component of the translation vector.
 	 * @return This matrix for the purpose of chaining. */
 	public Matrix3 translate (float x, float y) {
-		float[] val = this.val;
 		tmp[M00] = 1;
 		tmp[M10] = 0;
 		tmp[M20] = 0;
@@ -425,7 +404,6 @@ public class Matrix3 implements Serializable {
 	 * @param translation The translation vector.
 	 * @return This matrix for the purpose of chaining. */
 	public Matrix3 translate (Vector2 translation) {
-		float[] val = this.val;
 		tmp[M00] = 1;
 		tmp[M10] = 0;
 		tmp[M20] = 0;
@@ -457,7 +435,6 @@ public class Matrix3 implements Serializable {
 		if (radians == 0) return this;
 		float cos = (float)Math.cos(radians);
 		float sin = (float)Math.sin(radians);
-		float[] tmp = this.tmp;
 
 		tmp[M00] = cos;
 		tmp[M10] = sin;
@@ -480,7 +457,6 @@ public class Matrix3 implements Serializable {
 	 * @param scaleY The scale in the y-axis.
 	 * @return This matrix for the purpose of chaining. */
 	public Matrix3 scale (float scaleX, float scaleY) {
-		float[] tmp = this.tmp;
 		tmp[M00] = scaleX;
 		tmp[M10] = 0;
 		tmp[M20] = 0;
@@ -499,7 +475,6 @@ public class Matrix3 implements Serializable {
 	 * @param scale The vector to scale the matrix by.
 	 * @return This matrix for the purpose of chaining. */
 	public Matrix3 scale (Vector2 scale) {
-		float[] tmp = this.tmp;
 		tmp[M00] = scale.x;
 		tmp[M10] = 0;
 		tmp[M20] = 0;
@@ -526,7 +501,6 @@ public class Matrix3 implements Serializable {
 	}
 
 	public Vector2 getScale (Vector2 scale) {
-		float[] val = this.val;
 		scale.x = (float)Math.sqrt(val[M00] * val[M00] + val[M01] * val[M01]);
 		scale.y = (float)Math.sqrt(val[M10] * val[M10] + val[M11] * val[M11]);
 		return scale;
@@ -571,7 +545,6 @@ public class Matrix3 implements Serializable {
 	 * @return This matrix for the purpose of chaining methods together. */
 	public Matrix3 transpose () {
 		// Where MXY you do not have to change MXX
-		float[] val = this.val;
 		float v01 = val[M10];
 		float v02 = val[M20];
 		float v10 = val[M01];
diff --git a/gdx/src/com/badlogic/gdx/math/Matrix4.java b/gdx/src/com/badlogic/gdx/math/Matrix4.java
index fb69d80..f664362 100644
--- a/gdx/src/com/badlogic/gdx/math/Matrix4.java
+++ b/gdx/src/com/badlogic/gdx/math/Matrix4.java
@@ -70,7 +70,8 @@ public class Matrix4 implements Serializable {
 	/** WW: Typically the value one. On Vector3 multiplication this value is ignored. */
 	public static final int M33 = 15;
 
-	private static final float tmp[] = new float[16];
+	/** @Deprecated Do not use this member, instead use a temporary Matrix4 instance, or create a temporary float array. */
+	@Deprecated public static final float tmp[] = new float[16]; // FIXME Change to private access
 	public final float val[] = new float[16];
 
 	/** Constructs an identity matrix */
diff --git a/gdx/src/com/badlogic/gdx/math/collision/BoundingBox.java b/gdx/src/com/badlogic/gdx/math/collision/BoundingBox.java
index c5d83e2..a3bebda 100644
--- a/gdx/src/com/badlogic/gdx/math/collision/BoundingBox.java
+++ b/gdx/src/com/badlogic/gdx/math/collision/BoundingBox.java
@@ -37,6 +37,15 @@ public class BoundingBox implements Serializable {
 	private final Vector3 cnt = new Vector3();
 	private final Vector3 dim = new Vector3();
 
+	@Deprecated private Vector3[] corners;
+
+	/** @deprecated Use {@link #getCenter(Vector3)}
+	 * @return the center of the bounding box */
+	@Deprecated
+	public Vector3 getCenter () {
+		return cnt;
+	}
+
 	/** @param out The {@link Vector3} to receive the center of the bounding box.
 	 * @return The vector specified with the out argument. */
 	public Vector3 getCenter (Vector3 out) {
@@ -55,6 +64,30 @@ public class BoundingBox implements Serializable {
 		return cnt.z;
 	}
 
+	@Deprecated
+	protected void updateCorners () {
+	}
+
+	/** @deprecated Use the getCornerXYZ methods instead
+	 * @return the corners of this bounding box */
+	@Deprecated
+	public Vector3[] getCorners () {
+		if (corners == null) {
+			corners = new Vector3[8];
+			for (int i = 0; i < 8; i++)
+				corners[i] = new Vector3();
+		}
+		corners[0].set(min.x, min.y, min.z);
+		corners[1].set(max.x, min.y, min.z);
+		corners[2].set(max.x, max.y, min.z);
+		corners[3].set(min.x, max.y, min.z);
+		corners[4].set(min.x, min.y, max.z);
+		corners[5].set(max.x, min.y, max.z);
+		corners[6].set(max.x, max.y, max.z);
+		corners[7].set(min.x, max.y, max.z);
+		return corners;
+	}
+
 	public Vector3 getCorner000 (final Vector3 out) {
 		return out.set(min.x, min.y, min.z);
 	}
@@ -87,6 +120,13 @@ public class BoundingBox implements Serializable {
 		return out.set(max.x, max.y, max.z);
 	}
 
+	/** @deprecated Use {@link #getDimensions(Vector3)} instead
+	 * @return The dimensions of this bounding box on all three axis */
+	@Deprecated
+	public Vector3 getDimensions () {
+		return dim;
+	}
+
 	/** @param out The {@link Vector3} to receive the dimensions of this bounding box on all three axis.
 	 * @return The vector specified with the out argument */
 	public Vector3 getDimensions (final Vector3 out) {
@@ -105,12 +145,26 @@ public class BoundingBox implements Serializable {
 		return dim.z;
 	}
 
+	/** @deprecated Use {@link #getMin(Vector3)} instead.
+	 * @return The minimum vector */
+	@Deprecated
+	public Vector3 getMin () {
+		return min;
+	}
+
 	/** @param out The {@link Vector3} to receive the minimum values.
 	 * @return The vector specified with the out argument */
 	public Vector3 getMin (final Vector3 out) {
 		return out.set(min);
 	}
 
+	/** @deprecated Use {@link #getMax(Vector3)} instead
+	 * @return The maximum vector */
+	@Deprecated
+	public Vector3 getMax () {
+		return max;
+	}
+
 	/** @param out The {@link Vector3} to receive the maximum values.
 	 * @return The vector specified with the out argument */
 	public Vector3 getMax (final Vector3 out) {
diff --git a/gdx/src/com/badlogic/gdx/math/collision/Ray.java b/gdx/src/com/badlogic/gdx/math/collision/Ray.java
index 7755df9..673641d 100644
--- a/gdx/src/com/badlogic/gdx/math/collision/Ray.java
+++ b/gdx/src/com/badlogic/gdx/math/collision/Ray.java
@@ -43,6 +43,15 @@ public class Ray implements Serializable {
 		return new Ray(this.origin, this.direction);
 	}
 
+	/** @deprecated Use {@link #getEndPoint(Vector3, float)} instead. Returns the endpoint given the distance. This is calculated as
+	 *             startpoint + distance * direction.
+	 * @param distance The distance from the end point to the start point.
+	 * @return The end point */
+	@Deprecated
+	public Vector3 getEndPoint (float distance) {
+		return getEndPoint(new Vector3(), distance);
+	}
+
 	/** Returns the endpoint given the distance. This is calculated as startpoint + distance * direction.
 	 * @param out The vector to set to the result
 	 * @param distance The distance from the end point to the start point.
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/Actor.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/Actor.java
index 9c0799e..e1f3f11 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/Actor.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/Actor.java
@@ -16,7 +16,7 @@
 
 package com.badlogic.gdx.scenes.scene2d;
 
-import static com.badlogic.gdx.utils.Align.*;
+import static com.badlogic.gdx.scenes.scene2d.utils.Align.*;
 
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.Color;
@@ -28,9 +28,9 @@ import com.badlogic.gdx.math.Rectangle;
 import com.badlogic.gdx.math.Vector2;
 import com.badlogic.gdx.scenes.scene2d.InputEvent.Type;
 import com.badlogic.gdx.scenes.scene2d.utils.ActorGestureListener;
+import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
 import com.badlogic.gdx.scenes.scene2d.utils.ScissorStack;
-import com.badlogic.gdx.utils.Align;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.DelayedRemovalArray;
 import com.badlogic.gdx.utils.Pools;
@@ -804,7 +804,7 @@ public class Actor {
 		if (!debug) return;
 		shapes.set(ShapeType.Line);
 		shapes.setColor(stage.getDebugColor());
-		shapes.rect(x, y, originX, originY, width, height, scaleX, scaleY, rotation);
+		shapes.rect(x, y, originX, originY, width - 1, height - 1, scaleX, scaleY, rotation);
 	}
 
 	/** If true, {@link #drawDebug(ShapeRenderer)} will be called for this actor. */
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/Event.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/Event.java
index 3430b84..1810110 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/Event.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/Event.java
@@ -43,7 +43,7 @@ public class Event implements Poolable {
 	private boolean cancelled; // true means propagation was stopped and any action that this event would cause should not happen
 
 	/** Marks this event as handled. This does not affect event propagation inside scene2d, but causes the {@link Stage} event
-	 * methods to return true, which will eat the event so it is not passed on to the application under the stage. */
+	 * methods to return false, which will eat the event so it is not passed on to the application under the stage. */
 	public void handle () {
 		handled = true;
 	}
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/Group.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/Group.java
index 07bc6b1..8d82e34 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/Group.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/Group.java
@@ -152,7 +152,6 @@ public class Group extends Actor implements Cullable {
 			for (int i = 0, n = children.size; i < n; i++) {
 				Actor child = actors[i];
 				if (!child.isVisible()) continue;
-				if (!child.getDebug()) continue;
 				child.drawDebug(shapes);
 			}
 			shapes.flush();
@@ -164,7 +163,6 @@ public class Group extends Actor implements Cullable {
 			for (int i = 0, n = children.size; i < n; i++) {
 				Actor child = actors[i];
 				if (!child.isVisible()) continue;
-				if (!child.getDebug()) continue;
 				float cx = child.x, cy = child.y;
 				child.x = cx + offsetX;
 				child.y = cy + offsetY;
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/InputEvent.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/InputEvent.java
index 7837d72..ecfc772 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/InputEvent.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/InputEvent.java
@@ -136,7 +136,7 @@ public class InputEvent extends Event {
 		return type.toString();
 	}
 
-	/** Types of low-level input events supported by scene2d. */
+	/** Types of low-level input events supported by stage2d. */
 	static public enum Type {
 		/** A new touch for a pointer on the stage was detected */
 		touchDown,
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/Stage.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/Stage.java
index 5f731c4..883167c 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/Stage.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/Stage.java
@@ -635,7 +635,7 @@ public class Stage extends InputAdapter implements Disposable {
 		FocusEvent event = Pools.obtain(FocusEvent.class);
 		event.setStage(this);
 		event.setType(FocusEvent.Type.scroll);
-		Actor oldScrollFocus = scrollFocus;
+		Actor oldScrollFocus = keyboardFocus;
 		if (oldScrollFocus != null) {
 			event.setFocused(false);
 			event.setRelatedActor(actor);
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/MoveToAction.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/MoveToAction.java
index bbe3e13..fab2ed6 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/MoveToAction.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/actions/MoveToAction.java
@@ -16,7 +16,7 @@
 
 package com.badlogic.gdx.scenes.scene2d.actions;
 
-import com.badlogic.gdx.utils.Align;
+import com.badlogic.gdx.scenes.scene2d.utils.Align;
 
 /** Moves an actor from its current position to a specific position.
  * @author Nathan Sweet */
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Cell.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Cell.java
index 1c0693e..2014e76 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Cell.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Cell.java
@@ -3,7 +3,7 @@ package com.badlogic.gdx.scenes.scene2d.ui;
 
 import com.badlogic.gdx.scenes.scene2d.Actor;
 import com.badlogic.gdx.scenes.scene2d.ui.Value.Fixed;
-import com.badlogic.gdx.utils.Align;
+import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.utils.Pool.Poolable;
 
 /** A cell for a {@link Table}.
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/CheckBox.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/CheckBox.java
index e42874d..cc95503 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/CheckBox.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/CheckBox.java
@@ -19,8 +19,8 @@ package com.badlogic.gdx.scenes.scene2d.ui;
 import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.g2d.Batch;
 import com.badlogic.gdx.graphics.g2d.BitmapFont;
+import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
-import com.badlogic.gdx.utils.Align;
 
 /** A checkbox is a button that contains an image indicating the checked or unchecked state and a label.
  * @author Nathan Sweet */
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Container.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Container.java
index 2bba07e..c7a66ab 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Container.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Container.java
@@ -7,9 +7,9 @@ import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
 import com.badlogic.gdx.scenes.scene2d.Actor;
 import com.badlogic.gdx.scenes.scene2d.Touchable;
 import com.badlogic.gdx.scenes.scene2d.ui.Value.Fixed;
+import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
 import com.badlogic.gdx.scenes.scene2d.utils.Layout;
-import com.badlogic.gdx.utils.Align;
 
 /** A group with a single child that sizes and positions the child using constraints. This provides layout similar to a
  * {@link Table} with a single cell but is more lightweight.
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/HorizontalGroup.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/HorizontalGroup.java
index 7834e65..631833c 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/HorizontalGroup.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/HorizontalGroup.java
@@ -18,8 +18,8 @@ package com.badlogic.gdx.scenes.scene2d.ui;
 
 import com.badlogic.gdx.scenes.scene2d.Actor;
 import com.badlogic.gdx.scenes.scene2d.Touchable;
+import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.scenes.scene2d.utils.Layout;
-import com.badlogic.gdx.utils.Align;
 import com.badlogic.gdx.utils.SnapshotArray;
 
 /** A group that lays out its children side by side in a single row. This can be easier than using {@link Table} when actors need
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Image.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Image.java
index 9757f3f..b8757db 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Image.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Image.java
@@ -22,11 +22,11 @@ import com.badlogic.gdx.graphics.g2d.Batch;
 import com.badlogic.gdx.graphics.g2d.NinePatch;
 import com.badlogic.gdx.graphics.g2d.TextureRegion;
 import com.badlogic.gdx.math.Vector2;
+import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
 import com.badlogic.gdx.scenes.scene2d.utils.NinePatchDrawable;
 import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
 import com.badlogic.gdx.scenes.scene2d.utils.TransformDrawable;
-import com.badlogic.gdx.utils.Align;
 import com.badlogic.gdx.utils.Scaling;
 
 /** Displays a {@link Drawable}, scaled various way within the widgets bounds. The preferred size is the min size of the drawable.
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ImageTextButton.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ImageTextButton.java
index 9ed95ff..2ff205f 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ImageTextButton.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ImageTextButton.java
@@ -21,8 +21,8 @@ import com.badlogic.gdx.graphics.g2d.Batch;
 import com.badlogic.gdx.graphics.g2d.BitmapFont;
 import com.badlogic.gdx.scenes.scene2d.ui.Label.LabelStyle;
 import com.badlogic.gdx.scenes.scene2d.ui.TextButton.TextButtonStyle;
+import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
-import com.badlogic.gdx.utils.Align;
 import com.badlogic.gdx.utils.Scaling;
 
 /** A button with a child {@link Image} and {@link Label}.
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Label.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Label.java
index e25268c..b7c6d2f 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Label.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Label.java
@@ -19,11 +19,11 @@ package com.badlogic.gdx.scenes.scene2d.ui;
 import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.g2d.Batch;
 import com.badlogic.gdx.graphics.g2d.BitmapFont;
+import com.badlogic.gdx.graphics.g2d.BitmapFont.HAlignment;
+import com.badlogic.gdx.graphics.g2d.BitmapFont.TextBounds;
 import com.badlogic.gdx.graphics.g2d.BitmapFontCache;
-import com.badlogic.gdx.graphics.g2d.GlyphLayout;
-import com.badlogic.gdx.math.Vector2;
+import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
-import com.badlogic.gdx.utils.Align;
 import com.badlogic.gdx.utils.StringBuilder;
 
 /** A text label, with optional word wrapping.
@@ -34,12 +34,12 @@ public class Label extends Widget {
 	static private final Color tempColor = new Color();
 
 	private LabelStyle style;
-	private final GlyphLayout layout = new GlyphLayout();
-	private final Vector2 bounds = new Vector2();
+	private final TextBounds bounds = new TextBounds();
 	private final StringBuilder text = new StringBuilder();
+	private StringBuilder tempText;
 	private BitmapFontCache cache;
 	private int labelAlign = Align.left;
-	private int lineAlign = Align.left;
+	private HAlignment lineAlign = HAlignment.LEFT;
 	private boolean wrap;
 	private float lastPrefHeight;
 	private boolean sizeInvalid = true;
@@ -69,7 +69,7 @@ public class Label extends Widget {
 	public Label (CharSequence text, LabelStyle style) {
 		if (text != null) this.text.append(text);
 		setStyle(style);
-		if (text != null && text.length() > 0) setSize(getPrefWidth(), getPrefHeight());
+		setSize(getPrefWidth(), getPrefHeight());
 	}
 
 	public void setStyle (LabelStyle style) {
@@ -123,11 +123,11 @@ public class Label extends Widget {
 		BitmapFont font = cache.getFont();
 		float oldScaleX = font.getScaleX();
 		float oldScaleY = font.getScaleY();
-		if (fontScaleX != 1 || fontScaleY != 1) font.getData().setScale(fontScaleX, fontScaleY);
+		if (fontScaleX != 1 || fontScaleY != 1) font.setScale(fontScaleX, fontScaleY);
 
 		computeSize();
 
-		if (fontScaleX != 1 || fontScaleY != 1) font.getData().setScale(oldScaleX, oldScaleY);
+		if (fontScaleX != 1 || fontScaleY != 1) font.setScale(oldScaleX, oldScaleY);
 	}
 
 	private void computeSize () {
@@ -135,17 +135,16 @@ public class Label extends Widget {
 		if (wrap) {
 			float width = getWidth();
 			if (style.background != null) width -= style.background.getLeftWidth() + style.background.getRightWidth();
-			layout.setText(cache.getFont(), text, Color.WHITE, width, Align.left, true);
+			bounds.set(cache.getFont().getWrappedBounds(text, width));
 		} else
-			layout.setText(cache.getFont(), text);
-		bounds.set(layout.width, layout.height);
+			bounds.set(cache.getFont().getMultiLineBounds(text));
 	}
 
 	public void layout () {
 		BitmapFont font = cache.getFont();
 		float oldScaleX = font.getScaleX();
 		float oldScaleY = font.getScaleY();
-		if (fontScaleX != 1 || fontScaleY != 1) font.getData().setScale(fontScaleX, fontScaleY);
+		if (fontScaleX != 1 || fontScaleY != 1) font.setScale(fontScaleX, fontScaleY);
 
 		if (sizeInvalid) computeSize();
 
@@ -158,7 +157,18 @@ public class Label extends Widget {
 		}
 
 		float width = getWidth(), height = getHeight();
-		float textWidth = layout.width, textHeight = layout.height;
+		StringBuilder text;
+		if (ellipsis && width < bounds.width) {
+			float ellipseWidth = font.getBounds("...").width;
+			text = tempText != null ? tempText : (tempText = new StringBuilder());
+			text.setLength(0);
+			if (width > ellipseWidth) {
+				text.append(this.text, 0, font.computeVisibleGlyphs(this.text, 0, this.text.length, width - ellipseWidth));
+				text.append("...");
+			}
+		} else
+			text = this.text;
+
 		Drawable background = style.background;
 		float x = 0, y = 0;
 		if (background != null) {
@@ -168,28 +178,29 @@ public class Label extends Widget {
 			height -= background.getBottomHeight() + background.getTopHeight();
 		}
 		if ((labelAlign & Align.top) != 0) {
-			y += cache.getFont().isFlipped() ? 0 : height - textHeight;
+			y += cache.getFont().isFlipped() ? 0 : height - bounds.height;
 			y += style.font.getDescent();
 		} else if ((labelAlign & Align.bottom) != 0) {
-			y += cache.getFont().isFlipped() ? height - textHeight : 0;
+			y += cache.getFont().isFlipped() ? height - bounds.height : 0;
 			y -= style.font.getDescent();
 		} else
-			y += (int)((height - textHeight) / 2);
-		if (!cache.getFont().isFlipped()) y += textHeight;
+			y += (int)((height - bounds.height) / 2);
+		if (!cache.getFont().isFlipped()) y += bounds.height;
 
 		if ((labelAlign & Align.left) == 0) {
 			if ((labelAlign & Align.right) != 0)
-				x += width - textWidth;
+				x += width - bounds.width;
 			else
-				x += (int)((width - textWidth) / 2);
+				x += (int)((width - bounds.width) / 2);
 		}
 
-		layout.setText(font, text, 0, text.length, Color.WHITE, //
-			(ellipsis && width < textWidth) ? width : textWidth, //
-			lineAlign, wrap, ellipsis ? "..." : null);
-		cache.setText(layout, x, y);
+		cache.setColor(Color.WHITE);
+		if (wrap)
+			cache.setWrappedText(text, x, y, bounds.width, lineAlign);
+		else
+			cache.setMultiLineText(text, x, y, bounds.width, lineAlign);
 
-		if (fontScaleX != 1 || fontScaleY != 1) font.getData().setScale(oldScaleX, oldScaleY);
+		if (fontScaleX != 1 || fontScaleY != 1) font.setScale(oldScaleX, oldScaleY);
 	}
 
 	public void draw (Batch batch, float parentAlpha) {
@@ -209,7 +220,7 @@ public class Label extends Widget {
 	public float getPrefWidth () {
 		if (wrap) return 0;
 		if (sizeInvalid) scaleAndComputeSize();
-		float width = bounds.x;
+		float width = bounds.width;
 		Drawable background = style.background;
 		if (background != null) width += background.getLeftWidth() + background.getRightWidth();
 		return width;
@@ -217,13 +228,13 @@ public class Label extends Widget {
 
 	public float getPrefHeight () {
 		if (sizeInvalid) scaleAndComputeSize();
-		float height = bounds.y - style.font.getDescent() * 2;
+		float height = bounds.height - style.font.getDescent() * 2;
 		Drawable background = style.background;
 		if (background != null) height += background.getTopHeight() + background.getBottomHeight();
 		return height;
 	}
 
-	public Vector2 getTextBounds () {
+	public TextBounds getTextBounds () {
 		if (sizeInvalid) scaleAndComputeSize();
 		return bounds;
 	}
@@ -240,6 +251,13 @@ public class Label extends Widget {
 		invalidateHierarchy();
 	}
 
+	/** Provide any additional characters that should act as break characters when the label is wrapped. By default, only whitespace
+	 * characters act as break chars. */
+	public void setBreakChars (char[] breakChars) {
+		cache.setBreakChars(breakChars);
+		invalidateHierarchy();
+	}
+
 	/** @param alignment Aligns each line of text horizontally and all the text vertically.
 	 * @see Align */
 	public void setAlignment (int alignment) {
@@ -253,11 +271,11 @@ public class Label extends Widget {
 		this.labelAlign = labelAlign;
 
 		if ((lineAlign & Align.left) != 0)
-			this.lineAlign = Align.left;
+			this.lineAlign = HAlignment.LEFT;
 		else if ((lineAlign & Align.right) != 0)
-			this.lineAlign = Align.right;
+			this.lineAlign = HAlignment.RIGHT;
 		else
-			this.lineAlign = Align.center;
+			this.lineAlign = HAlignment.CENTER;
 
 		invalidate();
 	}
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/List.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/List.java
index 81062c1..3cdb2e3 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/List.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/List.java
@@ -19,7 +19,7 @@ package com.badlogic.gdx.scenes.scene2d.ui;
 import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.g2d.Batch;
 import com.badlogic.gdx.graphics.g2d.BitmapFont;
-import com.badlogic.gdx.graphics.g2d.GlyphLayout;
+import com.badlogic.gdx.graphics.g2d.BitmapFont.TextBounds;
 import com.badlogic.gdx.math.Rectangle;
 import com.badlogic.gdx.scenes.scene2d.InputEvent;
 import com.badlogic.gdx.scenes.scene2d.InputListener;
@@ -29,8 +29,6 @@ import com.badlogic.gdx.scenes.scene2d.utils.Cullable;
 import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.ObjectSet;
-import com.badlogic.gdx.utils.Pool;
-import com.badlogic.gdx.utils.Pools;
 
 /** A list (aka list box) displays textual items and highlights the currently selected item.
  * <p>
@@ -108,13 +106,10 @@ public class List<T> extends Widget implements Cullable {
 		textOffsetY = selectedDrawable.getTopHeight() - font.getDescent();
 
 		prefWidth = 0;
-		Pool<GlyphLayout> layoutPool = Pools.get(GlyphLayout.class);
-		GlyphLayout layout = layoutPool.obtain();
 		for (int i = 0; i < items.size; i++) {
-			layout.setText(font, items.get(i).toString());
-			prefWidth = Math.max(layout.width, prefWidth);
+			TextBounds bounds = font.getBounds(items.get(i).toString());
+			prefWidth = Math.max(bounds.width, prefWidth);
 		}
-		layoutPool.free(layout);
 		prefWidth += selectedDrawable.getLeftWidth() + selectedDrawable.getRightWidth();
 		prefHeight = items.size * itemHeight;
 
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ProgressBar.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ProgressBar.java
index 64b32dc..cd5f978 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ProgressBar.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/ProgressBar.java
@@ -203,7 +203,7 @@ public class ProgressBar extends Widget implements Disableable {
 	}
 
 	public float getVisualPercent () {
-		return visualInterpolation.apply((getVisualValue() - min) / (max - min));
+		return visualInterpolation.apply(getPercent());
 	}
 
 	/** Returns progress bar visual position within the range. */
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SelectBox.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SelectBox.java
index f353e43..5e1da03 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SelectBox.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/SelectBox.java
@@ -22,7 +22,7 @@ import com.badlogic.gdx.Input.Keys;
 import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.g2d.Batch;
 import com.badlogic.gdx.graphics.g2d.BitmapFont;
-import com.badlogic.gdx.graphics.g2d.GlyphLayout;
+import com.badlogic.gdx.graphics.g2d.BitmapFont.TextBounds;
 import com.badlogic.gdx.math.Interpolation;
 import com.badlogic.gdx.math.Vector2;
 import com.badlogic.gdx.scenes.scene2d.Actor;
@@ -37,11 +37,9 @@ import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener.ChangeEvent;
 import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
 import com.badlogic.gdx.scenes.scene2d.utils.Disableable;
 import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
-import com.badlogic.gdx.utils.Align;
+import com.badlogic.gdx.scenes.scene2d.utils.Selection;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.ObjectSet;
-import com.badlogic.gdx.utils.Pool;
-import com.badlogic.gdx.utils.Pools;
 
 /** A select box (aka a drop-down list) allows a user to choose one of a number of values from a list. When inactive, the selected
  * value is displayed. When activated, it shows the list of values that may be selected.
@@ -59,10 +57,10 @@ public class SelectBox<T> extends Widget implements Disableable {
 	final Array<T> items = new Array();
 	final ArraySelection<T> selection = new ArraySelection(items);
 	SelectBoxList<T> selectBoxList;
+	private final TextBounds bounds = new TextBounds();
 	private float prefWidth, prefHeight;
 	private ClickListener clickListener;
 	boolean disabled;
-	private GlyphLayout layout = new GlyphLayout();
 
 	public SelectBox (Skin skin) {
 		this(skin.get(SelectBoxStyle.class));
@@ -174,13 +172,8 @@ public class SelectBox<T> extends Widget implements Disableable {
 			prefHeight = font.getCapHeight() - font.getDescent() * 2;
 
 		float maxItemWidth = 0;
-		Pool<GlyphLayout> layoutPool = Pools.get(GlyphLayout.class);
-		GlyphLayout layout = layoutPool.obtain();
-		for (int i = 0; i < items.size; i++) {
-			layout.setText(font, items.get(i).toString());
-			maxItemWidth = Math.max(layout.width, maxItemWidth);
-		}
-		layoutPool.free(layout);
+		for (int i = 0; i < items.size; i++)
+			maxItemWidth = Math.max(font.getBounds(items.get(i).toString()).width, maxItemWidth);
 
 		prefWidth = maxItemWidth;
 		if (bg != null) prefWidth += bg.getLeftWidth() + bg.getRightWidth();
@@ -228,17 +221,18 @@ public class SelectBox<T> extends Widget implements Disableable {
 		T selected = selection.first();
 		if (selected != null) {
 			String string = selected.toString();
+			bounds.set(font.getBounds(string));
 			if (background != null) {
 				width -= background.getLeftWidth() + background.getRightWidth();
 				height -= background.getBottomHeight() + background.getTopHeight();
 				x += background.getLeftWidth();
-				y += (int)(height / 2 + background.getBottomHeight() + font.getData().capHeight / 2);
+				y += (int)(height / 2 + background.getBottomHeight() + bounds.height / 2);
 			} else {
-				y += (int)(height / 2 + font.getData().capHeight / 2);
+				y += (int)(height / 2 + bounds.height / 2);
 			}
+			int numGlyphs = font.computeVisibleGlyphs(string, 0, string.length(), width);
 			font.setColor(fontColor.r, fontColor.g, fontColor.b, fontColor.a * parentAlpha);
-			layout.setText(font, string, 0, string.length(), Color.WHITE, width, Align.left, false, "...");
-			font.draw(batch, layout, x, y);
+			font.draw(batch, string, x, y, 0, numGlyphs);
 		}
 	}
 
@@ -333,7 +327,6 @@ public class SelectBox<T> extends Widget implements Disableable {
 
 			setOverscroll(false, false);
 			setFadeScrollBars(false);
-			setScrollingDisabled(true, false);
 
 			list = new List(selectBox.style.listStyle);
 			list.setTouchable(Touchable.disabled);
@@ -407,11 +400,7 @@ public class SelectBox<T> extends Widget implements Disableable {
 			else
 				setY(screenPosition.y + selectBox.getHeight());
 			setX(screenPosition.x);
-			setHeight(height);
-			validate();
-			float width = Math.max(getPrefWidth(), selectBox.getWidth());
-			if (getPrefHeight() > height) width += getScrollBarWidth();
-			setWidth(width);
+			setSize(Math.max(getPrefWidth(), selectBox.getWidth()), height);
 
 			validate();
 			scrollTo(0, list.getHeight() - selectBox.getSelectedIndex() * itemHeight - itemHeight / 2, 0, 0, true, true);
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Skin.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Skin.java
index 3345f6e..754264e 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Skin.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Skin.java
@@ -459,9 +459,9 @@ public class Skin implements Disposable {
 						else
 							font = new BitmapFont(fontFile, flip);
 					}
-					font.getData().markupEnabled = markupEnabled;
+					font.setMarkupEnabled(markupEnabled);
 					// Scaled size is the desired cap height to scale the font to.
-					if (scaledSize != -1) font.getData().setScale(scaledSize / font.getCapHeight());
+					if (scaledSize != -1) font.setScale(scaledSize / font.getCapHeight());
 					return font;
 				} catch (RuntimeException ex) {
 					throw new SerializationException("Error loading bitmap font: " + fontFile, ex);
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Table.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Table.java
index c648096..5e6e31f 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Table.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Table.java
@@ -25,9 +25,9 @@ import com.badlogic.gdx.scenes.scene2d.Actor;
 import com.badlogic.gdx.scenes.scene2d.Touchable;
 import com.badlogic.gdx.scenes.scene2d.ui.Label.LabelStyle;
 import com.badlogic.gdx.scenes.scene2d.ui.Value.Fixed;
+import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
 import com.badlogic.gdx.scenes.scene2d.utils.Layout;
-import com.badlogic.gdx.utils.Align;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.Pool;
 import com.badlogic.gdx.utils.Pools;
@@ -282,11 +282,7 @@ public class Table extends WidgetGroup {
 	}
 
 	public boolean removeActor (Actor actor) {
-		return removeActor(actor, true);
-	}
-
-	public boolean removeActor (Actor actor, boolean unfocus) {
-		if (!super.removeActor(actor, unfocus)) return false;
+		if (!super.removeActor(actor)) return false;
 		Cell cell = getCell(actor);
 		if (cell != null) cell.actor = null;
 		return true;
@@ -1201,11 +1197,6 @@ public class Table extends WidgetGroup {
 		}
 	}
 
-	/** @return The skin that was passed to this table in its constructor, or null if none was given. */
-	public Skin getSkin () {
-		return skin;
-	}
-
 	/** @author Nathan Sweet */
 	static public class DebugRect extends Rectangle {
 		static Pool<DebugRect> pool = Pools.get(DebugRect.class);
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextArea.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextArea.java
index 0d06f98..567a7c9 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextArea.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextArea.java
@@ -20,15 +20,11 @@ import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.Input;
 import com.badlogic.gdx.graphics.g2d.Batch;
 import com.badlogic.gdx.graphics.g2d.BitmapFont;
-import com.badlogic.gdx.graphics.g2d.GlyphLayout;
 import com.badlogic.gdx.scenes.scene2d.InputEvent;
 import com.badlogic.gdx.scenes.scene2d.InputListener;
 import com.badlogic.gdx.scenes.scene2d.Stage;
 import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
-import com.badlogic.gdx.utils.Align;
 import com.badlogic.gdx.utils.IntArray;
-import com.badlogic.gdx.utils.Pool;
-import com.badlogic.gdx.utils.Pools;
 
 /** A multiple-line text input field, entirely based on {@link TextField} */
 public class TextArea extends TextField {
@@ -247,7 +243,7 @@ public class TextArea extends TextField {
 	protected void drawText (Batch batch, BitmapFont font, float x, float y) {
 		float offsetY = 0;
 		for (int i = firstLineShowing * 2; i < (firstLineShowing + linesShowing) * 2 && i < linesBreak.size; i += 2) {
-			font.draw(batch, displayText, x, y + offsetY, linesBreak.items[i], linesBreak.items[i + 1], 0, Align.left, false);
+			font.draw(batch, displayText, x, y + offsetY, linesBreak.items[i], linesBreak.items[i + 1]);
 			offsetY -= font.getLineHeight();
 		}
 	}
@@ -266,6 +262,7 @@ public class TextArea extends TextField {
 		super.calculateOffsets();
 		if (!this.text.equals(lastText)) {
 			this.lastText = text;
+			BitmapFont.TextBounds bounds = new BitmapFont.TextBounds();
 			BitmapFont font = style.font;
 			float maxWidthLine = this.getWidth()
 				- (style.background != null ? style.background.getLeftWidth() + style.background.getRightWidth() : 0);
@@ -273,8 +270,6 @@ public class TextArea extends TextField {
 			int lineStart = 0;
 			int lastSpace = 0;
 			char lastCharacter;
-			Pool<GlyphLayout> layoutPool = Pools.get(GlyphLayout.class);
-			GlyphLayout layout = layoutPool.obtain();
 			for (int i = 0; i < text.length(); i++) {
 				lastCharacter = text.charAt(i);
 				if (lastCharacter == ENTER_DESKTOP || lastCharacter == ENTER_ANDROID) {
@@ -283,8 +278,8 @@ public class TextArea extends TextField {
 					lineStart = i + 1;
 				} else {
 					lastSpace = (continueCursor(i, 0) ? lastSpace : i);
-					layout.setText(font, text.subSequence(lineStart, i + 1));
-					if (layout.width > maxWidthLine) {
+					font.getBounds(text, lineStart, i + 1, bounds);
+					if (bounds.width > maxWidthLine) {
 						if (lineStart >= lastSpace) {
 							lastSpace = i - 1;
 						}
@@ -295,7 +290,6 @@ public class TextArea extends TextField {
 					}
 				}
 			}
-			layoutPool.free(layout);
 			// Add last line
 			if (lineStart < text.length()) {
 				linesBreak.add(lineStart);
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextButton.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextButton.java
index 3178041..07cf67c 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextButton.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextButton.java
@@ -20,8 +20,8 @@ import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.g2d.Batch;
 import com.badlogic.gdx.graphics.g2d.BitmapFont;
 import com.badlogic.gdx.scenes.scene2d.ui.Label.LabelStyle;
+import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
-import com.badlogic.gdx.utils.Align;
 
 /** A button with a child {@link Label} to display text.
  * @author Nathan Sweet */
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextField.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextField.java
index 735176d..2fb173b 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextField.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/TextField.java
@@ -22,9 +22,6 @@ import com.badlogic.gdx.Input.Keys;
 import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.g2d.Batch;
 import com.badlogic.gdx.graphics.g2d.BitmapFont;
-import com.badlogic.gdx.graphics.g2d.BitmapFont.BitmapFontData;
-import com.badlogic.gdx.graphics.g2d.GlyphLayout;
-import com.badlogic.gdx.graphics.g2d.GlyphLayout.GlyphRun;
 import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.math.Vector2;
 import com.badlogic.gdx.scenes.scene2d.Actor;
@@ -32,11 +29,11 @@ import com.badlogic.gdx.scenes.scene2d.Group;
 import com.badlogic.gdx.scenes.scene2d.InputEvent;
 import com.badlogic.gdx.scenes.scene2d.InputListener;
 import com.badlogic.gdx.scenes.scene2d.Stage;
+import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
 import com.badlogic.gdx.scenes.scene2d.utils.Disableable;
 import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
 import com.badlogic.gdx.scenes.scene2d.utils.UIUtils;
-import com.badlogic.gdx.utils.Align;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.Clipboard;
 import com.badlogic.gdx.utils.FloatArray;
@@ -79,8 +76,7 @@ public class TextField extends Widget implements Disableable {
 	protected int cursor, selectionStart;
 	protected boolean hasSelection;
 	protected boolean writeEnters;
-	protected final GlyphLayout layout = new GlyphLayout();
-	protected final FloatArray glyphPositions = new FloatArray();
+	protected final FloatArray glyphAdvances = new FloatArray(), glyphPositions = new FloatArray();
 
 	TextFieldStyle style;
 	private String messageText;
@@ -108,7 +104,7 @@ public class TextField extends Widget implements Disableable {
 	long lastBlink;
 
 	KeyRepeatTask keyRepeatTask = new KeyRepeatTask();
-
+	
 	public TextField (String text, Skin skin) {
 		this(text, skin.get(TextFieldStyle.class));
 	}
@@ -336,7 +332,7 @@ public class TextField extends Widget implements Disableable {
 	}
 
 	protected void drawText (Batch batch, BitmapFont font, float x, float y) {
-		font.draw(batch, displayText, x + textOffset, y, visibleTextStart, visibleTextEnd, 0, Align.left, false);
+		font.draw(batch, displayText, x + textOffset, y, visibleTextStart, visibleTextEnd);
 	}
 
 	protected void drawCursor (Drawable cursorPatch, Batch batch, BitmapFont font, float x, float y) {
@@ -346,18 +342,17 @@ public class TextField extends Widget implements Disableable {
 
 	void updateDisplayText () {
 		BitmapFont font = style.font;
-		BitmapFontData data = font.getData();
 		String text = this.text;
 		int textLength = text.length();
 
 		StringBuilder buffer = new StringBuilder();
 		for (int i = 0; i < textLength; i++) {
 			char c = text.charAt(i);
-			buffer.append(data.hasGlyph(c) ? c : ' ');
+			buffer.append(font.containsCharacter(c) ? c : ' ');
 		}
 		String newDisplayText = buffer.toString();
 
-		if (passwordMode && data.hasGlyph(passwordCharacter)) {
+		if (passwordMode && font.containsCharacter(passwordCharacter)) {
 			if (passwordBuffer == null) passwordBuffer = new StringBuilder(newDisplayText.length());
 			if (passwordBuffer.length() > textLength)
 				passwordBuffer.setLength(textLength);
@@ -368,20 +363,7 @@ public class TextField extends Widget implements Disableable {
 			displayText = passwordBuffer;
 		} else
 			displayText = newDisplayText;
-
-		layout.setText(font, displayText);
-		glyphPositions.clear();
-		float x = 0;
-		if (layout.runs.size > 0) {
-			GlyphRun run = layout.runs.first();
-			FloatArray xAdvances = run.xAdvances;
-			for (int i = 0, n = xAdvances.size; i < n; i++) {
-				glyphPositions.add(x);
-				x += xAdvances.get(i);
-			}
-		}
-		glyphPositions.add(x);
-
+		font.computeGlyphAdvancesAndPositions(displayText, glyphAdvances, glyphPositions);
 		if (selectionStart > newDisplayText.length()) selectionStart = textLength;
 	}
 
@@ -415,19 +397,18 @@ public class TextField extends Widget implements Disableable {
 
 	/** Pastes the content of the {@link Clipboard} implementation set on this Textfield to this TextField. */
 	void paste () {
-		paste(clipboard.getContents());
+		paste(clipboard.getContents(), true);
 	}
 
-	void paste (String content) {
+	void paste (String content, boolean onlyFontChars) {
 		if (content == null) return;
 		StringBuilder buffer = new StringBuilder();
 		int textLength = text.length();
-		BitmapFontData data = style.font.getData();
 		for (int i = 0, n = content.length(); i < n; i++) {
 			if (!withinMaxLength(textLength + buffer.length())) break;
 			char c = content.charAt(i);
 			if (!(writeEnters && (c == ENTER_ANDROID || c == ENTER_DESKTOP))) {
-				if (onlyFontChars && !data.hasGlyph(c)) continue;
+				if (onlyFontChars && !style.font.containsCharacter(c)) continue;
 				if (filter != null && !filter.acceptChar(this, c)) continue;
 			}
 			buffer.append(c);
@@ -543,7 +524,7 @@ public class TextField extends Widget implements Disableable {
 
 		clearSelection();
 		cursor = text.length();
-		paste(str);
+		paste(str, onlyFontChars);
 	}
 
 	public void setText (String str) {
@@ -552,7 +533,7 @@ public class TextField extends Widget implements Disableable {
 
 		clearSelection();
 		text = "";
-		paste(str);
+		paste(str, onlyFontChars);
 		cursor = 0;
 	}
 
@@ -637,7 +618,8 @@ public class TextField extends Widget implements Disableable {
 
 	/** Sets text horizontal alignment (left, center or right). */
 	public void setAlignment (int alignment) {
-		if (alignment == Align.left || alignment == Align.center || alignment == Align.right) this.textHAlign = alignment;
+		if (alignment == Align.left || alignment == Align.center || alignment == Align.right) 
+			this.textHAlign = alignment;
 	}
 
 	/** If true, the text in this text field will be shown as bullet characters.
@@ -889,17 +871,7 @@ public class TextField extends Widget implements Disableable {
 
 		public boolean keyTyped (InputEvent event, char character) {
 			if (disabled) return false;
-
-			// Disallow "typing" most ASCII control characters, which would show up as a space when onlyFontChars is true.
-			switch (character) {
-			case BACKSPACE:
-			case TAB:
-			case ENTER_ANDROID:
-			case ENTER_DESKTOP:
-				break;
-			default:
-				if (character < 32) return false;
-			}
+			if (character == 0) return false;
 
 			Stage stage = getStage();
 			if (stage == null || stage.getKeyboardFocus() != TextField.this) return false;
@@ -909,7 +881,7 @@ public class TextField extends Widget implements Disableable {
 			} else {
 				boolean delete = character == DELETE;
 				boolean backspace = character == BACKSPACE;
-				boolean add = (!onlyFontChars || style.font.getData().hasGlyph(character))
+				boolean add = style.font.containsCharacter(character)
 					|| (writeEnters && (character == ENTER_ANDROID || character == ENTER_DESKTOP));
 				boolean remove = backspace || delete;
 				if (add || remove) {
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/VerticalGroup.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/VerticalGroup.java
index b763ab0..193d459 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/VerticalGroup.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/VerticalGroup.java
@@ -18,8 +18,8 @@ package com.badlogic.gdx.scenes.scene2d.ui;
 
 import com.badlogic.gdx.scenes.scene2d.Actor;
 import com.badlogic.gdx.scenes.scene2d.Touchable;
+import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.scenes.scene2d.utils.Layout;
-import com.badlogic.gdx.utils.Align;
 import com.badlogic.gdx.utils.SnapshotArray;
 
 /** A group that lays out its children on top of each other in a single column. This can be easier than using {@link Table} when
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Window.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Window.java
index 67ac406..4245081 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Window.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/ui/Window.java
@@ -21,15 +21,16 @@ import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.OrthographicCamera;
 import com.badlogic.gdx.graphics.g2d.Batch;
 import com.badlogic.gdx.graphics.g2d.BitmapFont;
+import com.badlogic.gdx.graphics.g2d.BitmapFont.TextBounds;
+import com.badlogic.gdx.graphics.g2d.BitmapFontCache;
 import com.badlogic.gdx.math.Vector2;
 import com.badlogic.gdx.scenes.scene2d.Actor;
 import com.badlogic.gdx.scenes.scene2d.InputEvent;
 import com.badlogic.gdx.scenes.scene2d.InputListener;
 import com.badlogic.gdx.scenes.scene2d.Stage;
 import com.badlogic.gdx.scenes.scene2d.Touchable;
-import com.badlogic.gdx.scenes.scene2d.ui.Label.LabelStyle;
+import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
-import com.badlogic.gdx.utils.Align;
 
 /** A table that can be dragged and act as a modal window. The top padding is used as the window's title height.
  * <p>
@@ -42,13 +43,14 @@ public class Window extends Table {
 	static private final int MOVE = 1 << 5;
 
 	private WindowStyle style;
+	private String title;
+	private BitmapFontCache titleCache;
 	boolean isMovable = true, isModal, isResizable;
 	int resizeBorder = 8;
 	boolean dragging;
+	private int titleAlignment = Align.center;
 	boolean keepWithinStage = true;
-	Label titleLabel;
-	Table titleTable;
-	boolean drawTitleTable;
+	Table buttonTable;
 
 	public Window (String title, Skin skin) {
 		this(title, skin.get(WindowStyle.class));
@@ -62,22 +64,16 @@ public class Window extends Table {
 
 	public Window (String title, WindowStyle style) {
 		if (title == null) throw new IllegalArgumentException("title cannot be null.");
+		this.title = title;
 		setTouchable(Touchable.enabled);
 		setClip(true);
-
-		titleLabel = new Label(title, new LabelStyle(style.titleFont, style.titleFontColor));
-
-		titleTable = new Table() {
-			public void draw (Batch batch, float parentAlpha) {
-				if (drawTitleTable) super.draw(batch, parentAlpha);
-			}
-		};
-		titleTable.add(titleLabel).expandX().fillX();
-		addActor(titleTable);
-
 		setStyle(style);
 		setWidth(150);
 		setHeight(150);
+		setTitle(title);
+
+		buttonTable = new Table();
+		addActor(buttonTable);
 
 		addCaptureListener(new InputListener() {
 			public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
@@ -192,7 +188,9 @@ public class Window extends Table {
 		if (style == null) throw new IllegalArgumentException("style cannot be null.");
 		this.style = style;
 		setBackground(style.background);
-		titleLabel.setStyle(new LabelStyle(style.titleFont, style.titleFontColor));
+		titleCache = new BitmapFontCache(style.titleFont);
+		titleCache.setColor(style.titleFontColor);
+		if (title != null) setTitle(title);
 		invalidateHierarchy();
 	}
 
@@ -207,7 +205,7 @@ public class Window extends Table {
 		Stage stage = getStage();
 		Camera camera = stage.getCamera();
 		if (camera instanceof OrthographicCamera) {
-			OrthographicCamera orthographicCamera = (OrthographicCamera)camera;
+			OrthographicCamera orthographicCamera = (OrthographicCamera) camera;
 			float parentWidth = stage.getWidth();
 			float parentHeight = stage.getHeight();
 			if (getX(Align.right) - camera.position.x > parentWidth / 2 / orthographicCamera.zoom)
@@ -251,16 +249,35 @@ public class Window extends Table {
 	}
 
 	protected void drawBackground (Batch batch, float parentAlpha, float x, float y) {
+		float width = getWidth(), height = getHeight();
+		float padTop = getPadTop();
+
 		super.drawBackground(batch, parentAlpha, x, y);
 
-		// Manually draw the title table before clipping is done.
-		titleTable.getColor().a = getColor().a;
-		float padTop = getPadTop(), padLeft = getPadLeft();
-		titleTable.setSize(getWidth() - padLeft - getPadRight(), padTop);
-		titleTable.setPosition(padLeft, getHeight() - padTop);
-		drawTitleTable = true;
-		titleTable.draw(batch, parentAlpha);
-		drawTitleTable = false; // Avoid drawing the title table again in drawChildren.
+		// Draw button table.
+		buttonTable.getColor().a = getColor().a;
+		buttonTable.pack();
+		buttonTable.setPosition(width - buttonTable.getWidth(), Math.min(height - padTop, height - buttonTable.getHeight()));
+		buttonTable.draw(batch, parentAlpha);
+
+		// Draw the title without the batch transformed or clipping applied.
+		y += height;
+		TextBounds bounds = titleCache.getBounds();
+		if ((titleAlignment & Align.left) != 0)
+			x += getPadLeft();
+		else if ((titleAlignment & Align.right) != 0)
+			x += width - bounds.width - getPadRight();
+		else
+			x += (width - bounds.width) / 2;
+		if ((titleAlignment & Align.top) == 0) {
+			if ((titleAlignment & Align.bottom) != 0)
+				y -= padTop - bounds.height;
+			else
+				y -= (padTop - bounds.height) / 2;
+		}
+		titleCache.tint(Color.tmp.set(getColor()).mul(style.titleFontColor));
+		titleCache.setPosition((int)x, (int)y);
+		titleCache.draw(batch, parentAlpha);
 	}
 
 	public Actor hit (float x, float y, boolean touchable) {
@@ -278,6 +295,20 @@ public class Window extends Table {
 		return hit;
 	}
 
+	public void setTitle (String title) {
+		this.title = title;
+		titleCache.setMultiLineText(title, 0, 0);
+	}
+
+	public String getTitle () {
+		return title;
+	}
+
+	/** @param titleAlignment {@link Align} */
+	public void setTitleAlignment (int titleAlignment) {
+		this.titleAlignment = titleAlignment;
+	}
+
 	public boolean isMovable () {
 		return isMovable;
 	}
@@ -314,16 +345,16 @@ public class Window extends Table {
 		return dragging;
 	}
 
-	public float getPrefWidth () {
-		return Math.max(super.getPrefWidth(), titleLabel.getPrefWidth() + getPadLeft() + getPadRight());
+	public float getTitleWidth () {
+		return titleCache.getBounds().width;
 	}
 
-	public Table getTitleTable () {
-		return titleTable;
+	public float getPrefWidth () {
+		return Math.max(super.getPrefWidth(), getTitleWidth() + getPadLeft() + getPadRight());
 	}
 
-	public Label getTitleLabel () {
-		return titleLabel;
+	public Table getButtonTable () {
+		return buttonTable;
 	}
 
 	/** The style for a window, see {@link Window}.
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/Align.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/Align.java
new file mode 100644
index 0000000..c644552
--- /dev/null
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/Align.java
@@ -0,0 +1,32 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.scenes.scene2d.utils;
+
+/** Provides bit flag constants for alignment.
+ * @author Nathan Sweet */
+public class Align {
+	static public final int center = 1 << 0;
+	static public final int top = 1 << 1;
+	static public final int bottom = 1 << 2;
+	static public final int left = 1 << 3;
+	static public final int right = 1 << 4;
+
+	static public final int topLeft = top | left;
+	static public final int topRight = top | right;
+	static public final int bottomLeft = bottom | left;
+	static public final int bottomRight = bottom | right;
+}
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/SpriteDrawable.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/SpriteDrawable.java
index 3b4d667..604d3dc 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/SpriteDrawable.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/SpriteDrawable.java
@@ -43,7 +43,6 @@ public class SpriteDrawable extends BaseDrawable implements TransformDrawable {
 		draw(batch, x, y, width / 2f, height / 2f, width, height, 1f, 1f, 0f);
 	}
 
-	private static Color tmpColor = new Color();
 	public void draw (Batch batch, float x, float y, float originX, float originY, float width, float height, float scaleX,
 		float scaleY, float rotation) {
 		sprite.setOrigin(originX, originY);
@@ -51,7 +50,7 @@ public class SpriteDrawable extends BaseDrawable implements TransformDrawable {
 		sprite.setScale(scaleX, scaleY);
 		sprite.setBounds(x, y, width, height);
 		Color color = sprite.getColor();
-		sprite.setColor(tmpColor.set(color).mul(batch.getColor()));
+		sprite.setColor(Color.tmp.set(color).mul(batch.getColor()));
 		sprite.draw(batch);
 		sprite.setColor(color);
 	}
diff --git a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/TiledDrawable.java b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/TiledDrawable.java
index 30b0d3a..056e0b8 100644
--- a/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/TiledDrawable.java
+++ b/gdx/src/com/badlogic/gdx/scenes/scene2d/utils/TiledDrawable.java
@@ -38,13 +38,12 @@ public class TiledDrawable extends TextureRegionDrawable {
 	public void draw (Batch batch, float x, float y, float width, float height) {
 		TextureRegion region = getRegion();
 		float regionWidth = region.getRegionWidth(), regionHeight = region.getRegionHeight();
-		int fullX = (int)(width / regionWidth), fullY = (int)(height / regionHeight);
-		float remainingX = width - regionWidth * fullX, remainingY = height - regionHeight * fullY;
+		float remainingX = width % regionWidth, remainingY = height % regionHeight;
 		float startX = x, startY = y;
 		float endX = x + width - remainingX, endY = y + height - remainingY;
-		for (int i = 0; i < fullX; i++) {
+		while (x < endX) {
 			y = startY;
-			for (int ii = 0; ii < fullY; ii++) {
+			while (y < endY) {
 				batch.draw(region, x, y, regionWidth, regionHeight);
 				y += regionHeight;
 			}
@@ -58,7 +57,7 @@ public class TiledDrawable extends TextureRegionDrawable {
 			float u2 = u + remainingX / texture.getWidth();
 			float v = region.getV();
 			y = startY;
-			for (int ii = 0; ii < fullY; ii++) {
+			while (y < endY) {
 				batch.draw(texture, x, y, remainingX, regionHeight, u, v2, u2, v);
 				y += regionHeight;
 			}
@@ -73,7 +72,7 @@ public class TiledDrawable extends TextureRegionDrawable {
 			float u2 = region.getU2();
 			float v = v2 - remainingY / texture.getHeight();
 			x = startX;
-			for (int i = 0; i < fullX; i++) {
+			while (x < endX) {
 				batch.draw(texture, x, y, regionWidth, remainingY, u, v2, u2, v);
 				x += regionWidth;
 			}
diff --git a/gdx/src/com/badlogic/gdx/utils/Align.java b/gdx/src/com/badlogic/gdx/utils/Align.java
deleted file mode 100644
index c2fe5c8..0000000
--- a/gdx/src/com/badlogic/gdx/utils/Align.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.utils;
-
-/** Provides bit flag constants for alignment.
- * @author Nathan Sweet */
-public class Align {
-	static public final int center = 1 << 0;
-	static public final int top = 1 << 1;
-	static public final int bottom = 1 << 2;
-	static public final int left = 1 << 3;
-	static public final int right = 1 << 4;
-
-	static public final int topLeft = top | left;
-	static public final int topRight = top | right;
-	static public final int bottomLeft = bottom | left;
-	static public final int bottomRight = bottom | right;
-}
diff --git a/gdx/src/com/badlogic/gdx/utils/BufferUtils.java b/gdx/src/com/badlogic/gdx/utils/BufferUtils.java
index a674f80..191d81d 100644
--- a/gdx/src/com/badlogic/gdx/utils/BufferUtils.java
+++ b/gdx/src/com/badlogic/gdx/utils/BufferUtils.java
@@ -47,12 +47,12 @@ public final class BufferUtils {
 	 * @param numFloats the number of floats to copy
 	 * @param offset the offset in src to start copying from */
 	public static void copy (float[] src, Buffer dst, int numFloats, int offset) {
+		copyJni(src, dst, numFloats, offset);
+		dst.position(0);
+
 		if (dst instanceof ByteBuffer)
 			dst.limit(numFloats << 2);
 		else if (dst instanceof FloatBuffer) dst.limit(numFloats);
-
-		copyJni(src, dst, numFloats, offset);
-		dst.position(0);
 	}
 
 	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
@@ -65,8 +65,8 @@ public final class BufferUtils {
 	 * @param dst the destination Buffer, its position is used as an offset.
 	 * @param numElements the number of elements to copy. */
 	public static void copy (byte[] src, int srcOffset, Buffer dst, int numElements) {
-		dst.limit(dst.position() + bytesToElements(dst, numElements));
 		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements);
+		dst.limit(dst.position() + bytesToElements(dst, numElements));
 	}
 
 	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
@@ -79,8 +79,8 @@ public final class BufferUtils {
 	 * @param dst the destination Buffer, its position is used as an offset.
 	 * @param numElements the number of elements to copy. */
 	public static void copy (short[] src, int srcOffset, Buffer dst, int numElements) {
-		dst.limit(dst.position() + bytesToElements(dst, numElements << 1));
 		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements << 1);
+		dst.limit(dst.position() + bytesToElements(dst, numElements << 1));
 	}
 
 	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
@@ -153,8 +153,8 @@ public final class BufferUtils {
 	 * @param dst the destination Buffer, its position is used as an offset.
 	 * @param numElements the number of elements to copy. */
 	public static void copy (char[] src, int srcOffset, Buffer dst, int numElements) {
-		dst.limit(dst.position() + bytesToElements(dst, numElements << 1));
 		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements << 1);
+		dst.limit(dst.position() + bytesToElements(dst, numElements << 1));
 	}
 
 	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
@@ -167,8 +167,8 @@ public final class BufferUtils {
 	 * @param dst the destination Buffer, its position is used as an offset.
 	 * @param numElements the number of elements to copy. */
 	public static void copy (int[] src, int srcOffset, Buffer dst, int numElements) {
-		dst.limit(dst.position() + bytesToElements(dst, numElements << 2));
 		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements << 2);
+		dst.limit(dst.position() + bytesToElements(dst, numElements << 2));
 	}
 
 	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
@@ -181,8 +181,8 @@ public final class BufferUtils {
 	 * @param dst the destination Buffer, its position is used as an offset.
 	 * @param numElements the number of elements to copy. */
 	public static void copy (long[] src, int srcOffset, Buffer dst, int numElements) {
-		dst.limit(dst.position() + bytesToElements(dst, numElements << 3));
 		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements << 3);
+		dst.limit(dst.position() + bytesToElements(dst, numElements << 3));
 	}
 
 	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
@@ -195,8 +195,8 @@ public final class BufferUtils {
 	 * @param dst the destination Buffer, its position is used as an offset.
 	 * @param numElements the number of elements to copy. */
 	public static void copy (float[] src, int srcOffset, Buffer dst, int numElements) {
-		dst.limit(dst.position() + bytesToElements(dst, numElements << 2));
 		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements << 2);
+		dst.limit(dst.position() + bytesToElements(dst, numElements << 2));
 	}
 
 	/** Copies the contents of src to dst, starting from src[srcOffset], copying numElements elements. The {@link Buffer} instance's
@@ -209,8 +209,8 @@ public final class BufferUtils {
 	 * @param dst the destination Buffer, its position is used as an offset.
 	 * @param numElements the number of elements to copy. */
 	public static void copy (double[] src, int srcOffset, Buffer dst, int numElements) {
-		dst.limit(dst.position() + bytesToElements(dst, numElements << 3));
 		copyJni(src, srcOffset, dst, positionInBytes(dst), numElements << 3);
+		dst.limit(dst.position() + bytesToElements(dst, numElements << 3));
 	}
 
 	/** Copies the contents of src to dst, starting from the current position of src, copying numElements elements (using the data
@@ -224,8 +224,8 @@ public final class BufferUtils {
 	 * @param numElements the number of elements to copy. */
 	public static void copy (Buffer src, Buffer dst, int numElements) {
 		int numBytes = elementsToBytes(src, numElements);
-		dst.limit(dst.position() + bytesToElements(dst, numBytes));
 		copyJni(src, positionInBytes(src), dst, positionInBytes(dst), numBytes);
+		dst.limit(dst.position() + bytesToElements(dst, numBytes));
 	}
 
 	/** Multiply float vector components within the buffer with the specified matrix. The {@link Buffer#position()} is used as the
diff --git a/gdx/src/com/badlogic/gdx/utils/JsonWriter.java b/gdx/src/com/badlogic/gdx/utils/JsonWriter.java
index 3e872dd..e4dc1c7 100644
--- a/gdx/src/com/badlogic/gdx/utils/JsonWriter.java
+++ b/gdx/src/com/badlogic/gdx/utils/JsonWriter.java
@@ -64,13 +64,33 @@ public class JsonWriter extends Writer {
 	}
 
 	public JsonWriter object () throws IOException {
-		requireCommaOrName();
+		if (current != null) {
+			if (current.array) {
+				if (!current.needsComma)
+					current.needsComma = true;
+				else
+					writer.write(',');
+			} else {
+				if (!named && !current.array) throw new IllegalStateException("Name must be set.");
+				named = false;
+			}
+		}
 		stack.add(current = new JsonObject(false));
 		return this;
 	}
 
 	public JsonWriter array () throws IOException {
-		requireCommaOrName();
+		if (current != null) {
+			if (current.array) {
+				if (!current.needsComma)
+					current.needsComma = true;
+				else
+					writer.write(',');
+			} else {
+				if (!named && !current.array) throw new IllegalStateException("Name must be set.");
+				named = false;
+			}
+		}
 		stack.add(current = new JsonObject(true));
 		return this;
 	}
@@ -78,37 +98,27 @@ public class JsonWriter extends Writer {
 	public JsonWriter value (Object value) throws IOException {
 		if (quoteLongValues
 			&& (value instanceof Long || value instanceof Double || value instanceof BigDecimal || value instanceof BigInteger)) {
-			value = value.toString();
+			value = String.valueOf(value);
 		} else if (value instanceof Number) {
 			Number number = (Number)value;
 			long longValue = number.longValue();
 			if (number.doubleValue() == longValue) value = longValue;
 		}
-		requireCommaOrName();
+		if (current != null) {
+			if (current.array) {
+				if (!current.needsComma)
+					current.needsComma = true;
+				else
+					writer.write(',');
+			} else {
+				if (!named) throw new IllegalStateException("Name must be set.");
+				named = false;
+			}
+		}
 		writer.write(outputType.quoteValue(value));
 		return this;
 	}
 
-	/** Writes the specified JSON value, without quoting or escaping. */
-	public JsonWriter json (String json) throws IOException {
-		requireCommaOrName();
-		writer.write(json);
-		return this;
-	}
-
-	private void requireCommaOrName () throws IOException {
-		if (current == null) return;
-		if (current.array) {
-			if (!current.needsComma)
-				current.needsComma = true;
-			else
-				writer.write(',');
-		} else {
-			if (!named) throw new IllegalStateException("Name must be set.");
-			named = false;
-		}
-	}
-
 	public JsonWriter object (String name) throws IOException {
 		return name(name).object();
 	}
@@ -121,11 +131,6 @@ public class JsonWriter extends Writer {
 		return name(name).value(value);
 	}
 
-	/** Writes the specified JSON value, without quoting or escaping. */
-	public JsonWriter json (String name, String json) throws IOException {
-		return name(name).json(json);
-	}
-
 	public JsonWriter pop () throws IOException {
 		if (named) throw new IllegalStateException("Expected an object, array, or value since a name was set.");
 		stack.pop().close();
@@ -183,10 +188,9 @@ public class JsonWriter extends Writer {
 		static private Pattern minimalValuePattern = Pattern.compile("^[^\":,{\\[\\]/ ][^}\\],]*$");
 
 		public String quoteValue (Object value) {
-			if (value == null) return "null";
-			String string = value.toString();
-			if (value instanceof Number || value instanceof Boolean) return string;
-			string = string.replace("\\", "\\\\").replace("\r", "\\r").replace("\n", "\\n").replace("\t", "\\t");
+			if (value == null || value instanceof Number || value instanceof Boolean) return String.valueOf(value);
+			String string = String.valueOf(value).replace("\\", "\\\\").replace("\r", "\\r").replace("\n", "\\n")
+				.replace("\t", "\\t");
 			if (this == OutputType.minimal && !string.equals("true") && !string.equals("false") && !string.equals("null")
 				&& !string.contains("//") && !string.contains("/*")) {
 				int length = string.length();
diff --git a/gdx/src/com/badlogic/gdx/utils/StreamUtils.java b/gdx/src/com/badlogic/gdx/utils/StreamUtils.java
index dc598c0..7cf0730 100644
--- a/gdx/src/com/badlogic/gdx/utils/StreamUtils.java
+++ b/gdx/src/com/badlogic/gdx/utils/StreamUtils.java
@@ -16,6 +16,7 @@
 
 package com.badlogic.gdx.utils;
 
+import java.io.BufferedReader;
 import java.io.ByteArrayOutputStream;
 import java.io.Closeable;
 import java.io.IOException;
@@ -23,111 +24,75 @@ import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.io.StringWriter;
-import java.nio.ByteBuffer;
 
-/** Provides utility methods to copy streams. */
+/** Provides utility methods to copy streams */
 public final class StreamUtils {
-	public static final int DEFAULT_BUFFER_SIZE = 4096;
+	public static final int DEFAULT_BUFFER_SIZE = 8192;
 	public static final byte[] EMPTY_BYTES = new byte[0];
 
-	/** Allocates a {@value #DEFAULT_BUFFER_SIZE} byte[] for use as a temporary buffer and calls
-	 * {@link #copyStream(InputStream, OutputStream, byte[])}. */
+	/** Copy the data from an {@link InputStream} to an {@link OutputStream} without closing the stream.
+	 * @throws IOException */
 	public static void copyStream (InputStream input, OutputStream output) throws IOException {
-		copyStream(input, output, new byte[DEFAULT_BUFFER_SIZE]);
+		copyStream(input, output, DEFAULT_BUFFER_SIZE);
 	}
 
-	/** Allocates a byte[] of the specified size for use as a temporary buffer and calls
-	 * {@link #copyStream(InputStream, OutputStream, byte[])}. */
+	/** Copy the data from an {@link InputStream} to an {@link OutputStream} without closing the stream.
+	 * @throws IOException */
 	public static void copyStream (InputStream input, OutputStream output, int bufferSize) throws IOException {
-		copyStream(input, output, new byte[bufferSize]);
-	}
-
-	/** Copy the data from an {@link InputStream} to an {@link OutputStream}, using the specified byte[] as a temporary buffer. The
-	 * stream is not closed. */
-	public static void copyStream (InputStream input, OutputStream output, byte[] buffer) throws IOException {
+		byte[] buffer = new byte[bufferSize];
 		int bytesRead;
 		while ((bytesRead = input.read(buffer)) != -1) {
 			output.write(buffer, 0, bytesRead);
 		}
 	}
 
-	/** Allocates a {@value #DEFAULT_BUFFER_SIZE} byte[] for use as a temporary buffer and calls
-	 * {@link #copyStream(InputStream, OutputStream, byte[])}. */
-	public static void copyStream (InputStream input, ByteBuffer output) throws IOException {
-		copyStream(input, output, new byte[DEFAULT_BUFFER_SIZE]);
-	}
-
-	/** Allocates a byte[] of the specified size for use as a temporary buffer and calls
-	 * {@link #copyStream(InputStream, ByteBuffer, byte[])}. */
-	public static void copyStream (InputStream input, ByteBuffer output, int bufferSize) throws IOException {
-		copyStream(input, output, new byte[bufferSize]);
-	}
-
-	/** Copy the data from an {@link InputStream} to a {@link ByteBuffer}, using the specified byte[] as a temporary buffer. The
-	 * buffer's limit is increased by the number of bytes copied, the position is left unchanged. The stream is not closed.
-	 * @param output Must be a direct Buffer with native byte order and the buffer MUST be large enough to hold all the bytes in
-	 *           the stream. No error checking is performed.
-	 * @return the number of bytes copied. */
-	public static int copyStream (InputStream input, ByteBuffer output, byte[] buffer) throws IOException {
-		int startPosition = output.position(), total = 0, bytesRead;
-		while ((bytesRead = input.read(buffer)) != -1) {
-			BufferUtils.copy(buffer, 0, output, bytesRead);
-			total += bytesRead;
-			output.position(startPosition + total);
-		}
-		output.position(startPosition);
-		return total;
-	}
-
-	/** Copy the data from an {@link InputStream} to a byte array. The stream is not closed. */
+	/** Copy the data from an {@link InputStream} to a byte array without closing the stream.
+	 * @throws IOException */
 	public static byte[] copyStreamToByteArray (InputStream input) throws IOException {
 		return copyStreamToByteArray(input, input.available());
 	}
 
-	/** Copy the data from an {@link InputStream} to a byte array. The stream is not closed.
-	 * @param estimatedSize Used to allocate the output byte[] to possibly avoid an array copy. */
+	/** Copy the data from an {@link InputStream} to a byte array without closing the stream.
+	 * @param estimatedSize Used to preallocate a possibly correct sized byte array to avoid an array copy.
+	 * @throws IOException */
 	public static byte[] copyStreamToByteArray (InputStream input, int estimatedSize) throws IOException {
 		ByteArrayOutputStream baos = new OptimizedByteArrayOutputStream(Math.max(0, estimatedSize));
 		copyStream(input, baos);
 		return baos.toByteArray();
 	}
 
-	/** Calls {@link #copyStreamToString(InputStream, int, String)} using the input's {@link InputStream#available() available} size
-	 * and the platform's default charset. */
+	/** Copy the data from an {@link InputStream} to a string using the default charset without closing the stream.
+	 * @throws IOException */
 	public static String copyStreamToString (InputStream input) throws IOException {
-		return copyStreamToString(input, input.available(), null);
+		return copyStreamToString(input, input.available());
 	}
 
-	/** Calls {@link #copyStreamToString(InputStream, int, String)} using the platform's default charset. */
-	public static String copyStreamToString (InputStream input, int estimatedSize) throws IOException {
-		return copyStreamToString(input, estimatedSize, null);
-	}
-
-	/** Copy the data from an {@link InputStream} to a string using the specified charset.
-	 * @param estimatedSize Used to allocate the output buffer to possibly avoid an array copy.
-	 * @param charset May be null to use the platform's default charset. */
-	public static String copyStreamToString (InputStream input, int estimatedSize, String charset) throws IOException {
-		InputStreamReader reader = charset == null ? new InputStreamReader(input) : new InputStreamReader(input, charset);
-		StringWriter writer = new StringWriter(Math.max(0, estimatedSize));
+	/** Copy the data from an {@link InputStream} to a string using the default charset.
+	 * @param approxStringLength Used to preallocate a possibly correct sized StringBulder to avoid an array copy.
+	 * @throws IOException */
+	public static String copyStreamToString (InputStream input, int approxStringLength) throws IOException {
+		BufferedReader reader = new BufferedReader(new InputStreamReader(input));
+		StringWriter w = new StringWriter(Math.max(0, approxStringLength));
 		char[] buffer = new char[DEFAULT_BUFFER_SIZE];
+
 		int charsRead;
 		while ((charsRead = reader.read(buffer)) != -1) {
-			writer.write(buffer, 0, charsRead);
+			w.write(buffer, 0, charsRead);
 		}
-		return writer.toString();
+
+		return w.toString();
 	}
 
 	/** Close and ignore all errors. */
 	public static void closeQuietly (Closeable c) {
-		if (c != null) {
-			try {
-				c.close();
-			} catch (Exception ignored) {
-			}
+		if (c != null) try {
+			c.close();
+		} catch (Exception e) {
+			// ignore
 		}
 	}
 
-	/** A ByteArrayOutputStream which avoids copying of the byte array if possible. */
+	/** A ByteArrayOutputStream which avoids copying of the byte array if not necessary. */
 	static public class OptimizedByteArrayOutputStream extends ByteArrayOutputStream {
 		public OptimizedByteArrayOutputStream (int initialSize) {
 			super(initialSize);
diff --git a/gdx/src/com/badlogic/gdx/utils/reflect/ClassReflection.java b/gdx/src/com/badlogic/gdx/utils/reflect/ClassReflection.java
index b110e84..9030770 100644
--- a/gdx/src/com/badlogic/gdx/utils/reflect/ClassReflection.java
+++ b/gdx/src/com/badlogic/gdx/utils/reflect/ClassReflection.java
@@ -56,11 +56,6 @@ public final class ClassReflection {
 	static public boolean isStaticClass (Class c) {
 		return Modifier.isStatic(c.getModifiers());
 	}
-	
-	/** Determines if the supplied Class object represents an array class. */
-	static public boolean isArray (Class c) {
-		return c.isArray();
-	}
 
 	/** Creates a new instance of the class represented by the supplied Class. */
 	static public <T> T newInstance (Class<T> c) throws ReflectionException {
diff --git a/pom.xml b/pom.xml
index c13d2aa..2ca0597 100644
--- a/pom.xml
+++ b/pom.xml
@@ -10,7 +10,7 @@
   <groupId>com.badlogicgames.gdx</groupId>
   <artifactId>gdx-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.5.6-SNAPSHOT</version>
+  <version>1.5.5-SNAPSHOT</version>
 
   <name>libGDX Parent</name>
   <description>Android/Desktop/iOS/HTML5 game development framework.</description>
@@ -46,7 +46,7 @@
     <gwt.version>2.6.1</gwt.version>
     <lwjgl.version>2.9.2</lwjgl.version>
     <jglfw.version>1.1</jglfw.version>
-    <robovm.version>1.0.0</robovm.version>
+    <robovm.version>1.0.0-SNAPSHOT</robovm.version>
   </properties>
 
   <modules>
diff --git a/tests/gdx-tests-android/assets/data/cjsongeb.ttf.gz b/tests/gdx-tests-android/assets/data/cjsongeb.ttf.gz
deleted file mode 100644
index ce581ef..0000000
Binary files a/tests/gdx-tests-android/assets/data/cjsongeb.ttf.gz and /dev/null differ
diff --git a/tests/gdx-tests-android/assets/data/shaders/cubemap-frag.glsl b/tests/gdx-tests-android/assets/data/shaders/cubemap-frag.glsl
new file mode 100644
index 0000000..d3e2089
--- /dev/null
+++ b/tests/gdx-tests-android/assets/data/shaders/cubemap-frag.glsl
@@ -0,0 +1,13 @@
+#ifdef GL_ES 
+precision mediump float;
+#endif
+ 
+uniform samplerCube u_environmentMapTexture;
+ 
+varying vec4 v_position;
+ 
+void main() {
+	vec3 center = vec3(0.0);
+	vec3 dir = vec3(v_position) - center;
+	gl_FragColor = textureCube(u_environmentMapTexture, dir); 
+}
\ No newline at end of file
diff --git a/tests/gdx-tests-android/assets/data/shaders/cubemap-vert.glsl b/tests/gdx-tests-android/assets/data/shaders/cubemap-vert.glsl
new file mode 100644
index 0000000..34f37c8
--- /dev/null
+++ b/tests/gdx-tests-android/assets/data/shaders/cubemap-vert.glsl
@@ -0,0 +1,11 @@
+uniform mat4 u_projViewTrans;
+uniform mat4 u_worldTrans;
+
+attribute vec3 a_position;
+
+varying vec4 v_position; 
+
+void main() {
+	v_position = vec4(a_position, 1.0);
+	gl_Position = u_projViewTrans * u_worldTrans *  v_position;
+}
\ No newline at end of file
diff --git a/tests/gdx-tests-android/src/com/badlogic/gdx/tests/android/MatrixTest.java b/tests/gdx-tests-android/src/com/badlogic/gdx/tests/android/MatrixTest.java
index f922ffb..141cf15 100644
--- a/tests/gdx-tests-android/src/com/badlogic/gdx/tests/android/MatrixTest.java
+++ b/tests/gdx-tests-android/src/com/badlogic/gdx/tests/android/MatrixTest.java
@@ -75,7 +75,7 @@ public class MatrixTest extends GdxTest {
 	public void render () {
 		Gdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
 		batch.begin();
-		font.draw(batch, results, 20, 300);
+		font.drawMultiLine(batch, results, 20, 300);
 		batch.end();
 	}
 }
diff --git a/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java b/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java
index f1ee878..18ab9d7 100644
--- a/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java
+++ b/tests/gdx-tests-lwjgl/src/com/badlogic/gdx/tests/lwjgl/LwjglDebugStarter.java
@@ -22,7 +22,6 @@ import com.badlogic.gdx.tests.BitmapFontTest;
 import com.badlogic.gdx.tests.FullscreenTest;
 import com.badlogic.gdx.tests.JsonTest;
 import com.badlogic.gdx.tests.extensions.ControllersTest;
-import com.badlogic.gdx.tests.extensions.FreeTypeIncrementalTest;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
 public class LwjglDebugStarter {
@@ -34,7 +33,7 @@ public class LwjglDebugStarter {
 //		new SharedLibraryLoader("../../extensions/gdx-controllers/gdx-controllers-desktop/libs/gdx-controllers-desktop-natives.jar").load("gdx-controllers-desktop");
 //		new SharedLibraryLoader("../../gdx/libs/gdx-natives.jar").load("gdx");
 
-		GdxTest test = new FreeTypeIncrementalTest();		
+		GdxTest test = new BitmapFontTest();		
 		LwjglApplicationConfiguration config = new LwjglApplicationConfiguration();
 		config.r = config.g = config.b = config.a = 8;
 //		config.width = 320;
diff --git a/tests/gdx-tests/.settings/org.eclipse.core.resources.prefs b/tests/gdx-tests/.settings/org.eclipse.core.resources.prefs
index ab22f00..cb82fdf 100644
--- a/tests/gdx-tests/.settings/org.eclipse.core.resources.prefs
+++ b/tests/gdx-tests/.settings/org.eclipse.core.resources.prefs
@@ -1,6 +1,5 @@
 eclipse.preferences.version=1
 encoding//src/com/badlogic/gdx/tests/IntegerBitmapFontTest.java=UTF-8
 encoding//src/com/badlogic/gdx/tests/UtfFontTest.java=UTF-8
-encoding//src/com/badlogic/gdx/tests/extensions/FreeTypeIncrementalTest.java=UTF-8
 encoding//src/com/badlogic/gdx/tests/extensions/FreeTypeTest.java=UTF-8
 encoding//src/com/badlogic/gdx/tests/extensions/InternationalFontsTest.java=UTF-8
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/GdxTests.gwt.xml b/tests/gdx-tests/src/com/badlogic/gdx/GdxTests.gwt.xml
index b9049c7..d860fb3 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/GdxTests.gwt.xml
+++ b/tests/gdx-tests/src/com/badlogic/gdx/GdxTests.gwt.xml
@@ -13,7 +13,10 @@
 		<exclude name="**/ETC1Test.java"/> <!-- native -->
 		<exclude name="**/FFTTest.java"/> <!-- native -->
 		<exclude name="**/FramebufferToTextureTest.java"/> <!-- ScreenUtils missing -->
-		<exclude name="**/FreeType*.java"/> <!-- native  -->
+		<exclude name="**/FreeTypeFontLoaderTest.java"/> <!-- native  -->
+		<exclude name="**/FreeTypeTest.java"/> <!-- native  -->
+		<exclude name="**/FreeTypePackTest.java"/> <!-- native  -->
+		<exclude name="**/FreeTypeDisposeTest.java"/> <!-- native  -->
 		<exclude name="**/Gdx2DTest.java"/> <!-- native -->
 		<exclude name="**/I18NMessageTest.java"/> <!-- MessageBundle -->
 		<exclude name="**/InterpolationTest.java"/> <!-- reflection -->
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/AccelerometerTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/AccelerometerTest.java
index 581df0c..9617517 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/AccelerometerTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/AccelerometerTest.java
@@ -36,7 +36,7 @@ public class AccelerometerTest extends GdxTest {
 	public void render () {
 		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
 		batch.begin();
-		font.draw(batch, "accel: [" + Gdx.input.getAccelerometerX() + "," + Gdx.input.getAccelerometerY() + ","
+		font.drawMultiLine(batch, "accel: [" + Gdx.input.getAccelerometerX() + "," + Gdx.input.getAccelerometerY() + ","
 			+ Gdx.input.getAccelerometerZ() + "]\n" + "orientation: " + Gdx.input.getNativeOrientation() + "\n" + "rotation: "
 			+ Gdx.input.getRotation() + "\n" + "wh: " + Gdx.graphics.getDesktopDisplayMode() + "\n", 0, 100);
 		batch.end();
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/AnnotationTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/AnnotationTest.java
index 265b38d..c59e1ec 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/AnnotationTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/AnnotationTest.java
@@ -103,7 +103,7 @@ public class AnnotationTest extends GdxTest {
 	public void render () {
 		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
 		batch.begin();
-		font.draw(batch, message, 20, Gdx.graphics.getHeight() - 20);
+		font.drawMultiLine(batch, message, 20, Gdx.graphics.getHeight() - 20);
 		batch.end();
 	}
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontAlignmentTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontAlignmentTest.java
index b70556d..0478d40 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontAlignmentTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontAlignmentTest.java
@@ -23,12 +23,11 @@ import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.graphics.g2d.BitmapFont;
+import com.badlogic.gdx.graphics.g2d.BitmapFont.TextBounds;
 import com.badlogic.gdx.graphics.g2d.BitmapFontCache;
-import com.badlogic.gdx.graphics.g2d.GlyphLayout;
 import com.badlogic.gdx.graphics.g2d.Sprite;
 import com.badlogic.gdx.graphics.g2d.SpriteBatch;
 import com.badlogic.gdx.tests.utils.GdxTest;
-import com.badlogic.gdx.utils.Align;
 
 /** Shows how to align single line, wrapped, and multi line text within a rectangle. */
 public class BitmapFontAlignmentTest extends GdxTest {
@@ -38,7 +37,6 @@ public class BitmapFontAlignmentTest extends GdxTest {
 	private BitmapFontCache cache;
 	private Sprite logoSprite;
 	int renderMode;
-	GlyphLayout layout;
 
 	@Override
 	public void create () {
@@ -58,7 +56,6 @@ public class BitmapFontAlignmentTest extends GdxTest {
 		font = new BitmapFont(Gdx.files.getFileHandle("data/verdana39.fnt", FileType.Internal), Gdx.files.getFileHandle(
 			"data/verdana39.png", FileType.Internal), false);
 		cache = new BitmapFontCache(font);
-		layout = new GlyphLayout();
 	}
 
 	@Override
@@ -97,9 +94,9 @@ public class BitmapFontAlignmentTest extends GdxTest {
 		float width = logoSprite.getWidth();
 		float height = logoSprite.getHeight();
 
-		layout.setText(font, text);
-		x += width / 2 - layout.width / 2;
-		y += height / 2 + layout.height / 2;
+		TextBounds bounds = font.getBounds(text);
+		x += width / 2 - bounds.width / 2;
+		y += height / 2 + bounds.height / 2;
 
 		font.draw(spriteBatch, text, x, y);
 	}
@@ -112,11 +109,11 @@ public class BitmapFontAlignmentTest extends GdxTest {
 		float height = logoSprite.getHeight();
 
 		// Obviously you wouldn't set the cache text every frame in real code.
-		GlyphLayout layout = cache.setText(text, 0, 0);
+		TextBounds bounds = cache.setMultiLineText(text, 0, 0);
 		cache.setColors(Color.BLUE, 1, 4);
 
-		x += width / 2 - layout.width / 2;
-		y += height / 2 + layout.height / 2;
+		x += width / 2 - bounds.width / 2;
+		y += height / 2 + bounds.height / 2;
 		cache.setPosition(x, y);
 
 		cache.draw(spriteBatch);
@@ -129,17 +126,14 @@ public class BitmapFontAlignmentTest extends GdxTest {
 		float width = logoSprite.getWidth();
 		float height = logoSprite.getHeight();
 
-		layout.setText(font, text, Color.WHITE, width, Align.left, true);
-		x += width / 2 - layout.width / 2;
-		y += height / 2 + layout.height / 2;
+		TextBounds bounds = font.getWrappedBounds(text, width);
+		x += width / 2 - bounds.width / 2;
+		y += height / 2 + bounds.height / 2;
 
-		font.draw(spriteBatch, text, x, y, width, Align.left, true);
-
-		// More efficient to draw the layout used for bounds:
-		// font.draw(spriteBatch, layout, x, y);
+		font.drawWrapped(spriteBatch, text, x, y, width);
 
 		// Note that wrapped text can be aligned:
-		// font.draw(spriteBatch, text, x, y, width, Align.center, true);
+		// font.drawWrapped(spriteBatch, text, x, y, width, HAlignment.CENTER);
 	}
 
 	private void renderWrappedCached () {
@@ -150,13 +144,13 @@ public class BitmapFontAlignmentTest extends GdxTest {
 		float height = logoSprite.getHeight();
 
 		// Obviously you wouldn't set the cache text every frame in real code.
-		GlyphLayout layout = cache.setText(text, 0, 0, width, Align.left, true);
+		TextBounds bounds = cache.setWrappedText(text, 0, 0, width);
 
 		// Note that wrapped text can be aligned:
 		// cache.setWrappedText(text, 0, 0, width, HAlignment.CENTER);
 
-		x += width / 2 - layout.width / 2;
-		y += height / 2 + layout.height / 2;
+		x += width / 2 - bounds.width / 2;
+		y += height / 2 + bounds.height / 2;
 		cache.setPosition(x, y);
 
 		cache.draw(spriteBatch);
@@ -169,14 +163,14 @@ public class BitmapFontAlignmentTest extends GdxTest {
 		float width = logoSprite.getWidth();
 		float height = logoSprite.getHeight();
 
-		layout.setText(font, text);
-		x += width / 2 - layout.width / 2;
-		y += height / 2 + layout.height / 2;
+		TextBounds bounds = font.getMultiLineBounds(text);
+		x += width / 2 - bounds.width / 2;
+		y += height / 2 + bounds.height / 2;
 
-		font.draw(spriteBatch, text, x, y);
+		font.drawMultiLine(spriteBatch, text, x, y);
 
 		// Note that multi line text can be aligned:
-		// font.draw(spriteBatch, text, x, y, width, Align.center, false);
+		// font.drawMultiLine(spriteBatch, text, x, y, width, HAlignment.CENTER);
 	}
 
 	private void renderMultiLineCached () {
@@ -188,13 +182,13 @@ public class BitmapFontAlignmentTest extends GdxTest {
 		float height = logoSprite.getHeight();
 
 		// Obviously you wouldn't set the cache text every frame in real code.
-		GlyphLayout layout = cache.setText(text, 0, 0);
+		TextBounds bounds = cache.setMultiLineText(text, 0, 0);
 
 		// Note that multi line text can be aligned:
-		// cache.setText(text, 0, 0, width, Align.center, false);
+		// cache.setMultiLineText(text, 0, 0, width, HAlignment.CENTER);
 
-		x += width / 2 - layout.width / 2;
-		y += height / 2 + layout.height / 2;
+		x += width / 2 - bounds.width / 2;
+		y += height / 2 + bounds.height / 2;
 		cache.setPosition(x, y);
 
 		cache.draw(spriteBatch);
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontAtlasRegionTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontAtlasRegionTest.java
index aab388c..acda62f 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontAtlasRegionTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontAtlasRegionTest.java
@@ -7,7 +7,11 @@ import com.badlogic.gdx.assets.loaders.BitmapFontLoader.BitmapFontParameter;
 import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.g2d.BitmapFont;
+import com.badlogic.gdx.graphics.g2d.BitmapFontCache;
 import com.badlogic.gdx.graphics.g2d.SpriteBatch;
+import com.badlogic.gdx.graphics.g2d.BitmapFont.HAlignment;
+import com.badlogic.gdx.graphics.g2d.BitmapFont.TextBounds;
+import com.badlogic.gdx.graphics.glutils.ShapeRenderer.ShapeType;
 import com.badlogic.gdx.tests.utils.GdxTest;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.reflect.ClassReflection;
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontDistanceFieldTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontDistanceFieldTest.java
index 857a70a..7f8f8e6 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontDistanceFieldTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontDistanceFieldTest.java
@@ -23,13 +23,11 @@ import com.badlogic.gdx.graphics.OrthographicCamera;
 import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.graphics.Texture.TextureFilter;
 import com.badlogic.gdx.graphics.g2d.BitmapFont;
-import com.badlogic.gdx.graphics.g2d.GlyphLayout;
 import com.badlogic.gdx.graphics.g2d.SpriteBatch;
 import com.badlogic.gdx.graphics.g2d.TextureRegion;
 import com.badlogic.gdx.graphics.glutils.ShaderProgram;
 import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.tests.utils.GdxTest;
-import com.badlogic.gdx.utils.Align;
 
 public class BitmapFontDistanceFieldTest extends GdxTest {
 
@@ -62,7 +60,6 @@ public class BitmapFontDistanceFieldTest extends GdxTest {
 	private BitmapFont regularFont;
 	private BitmapFont distanceFieldFont;
 	private DistanceFieldShader distanceFieldShader;
-	private GlyphLayout layout = new GlyphLayout();
 
 	@Override
 	public void create () {
@@ -107,14 +104,14 @@ public class BitmapFontDistanceFieldTest extends GdxTest {
 		float maxWidth = 0;
 
 		spriteBatch.setShader(null);
-		descriptionFont.draw(spriteBatch, description, x, y);
+		descriptionFont.drawMultiLine(spriteBatch, description, x, y);
 		spriteBatch.flush();
 		y += 10 + 2 * descriptionFont.getLineHeight();
 
 		// set filters for each page
 		TextureFilter minFilter = linearFiltering ? TextureFilter.MipMapLinearNearest : TextureFilter.Nearest;
 		TextureFilter magFilter = linearFiltering ? TextureFilter.Linear : TextureFilter.Nearest;
-		for (int i = 0; i < font.getRegions().size; i++) {
+		for (int i = 0; i < font.getRegions().length; i++) {
 			font.getRegion(i).getTexture().setFilter(minFilter, magFilter);
 		}
 
@@ -125,13 +122,12 @@ public class BitmapFontDistanceFieldTest extends GdxTest {
 		}
 
 		for (float scale : SCALES) {
-			font.getData().setScale(scale);
-			layout.setText(font, TEXT);
-			maxWidth = Math.max(maxWidth, layout.width);
+			font.setScale(scale);
+			maxWidth = Math.max(maxWidth, font.getBounds(TEXT).width);
 			if (useShader) {
 				distanceFieldShader.setSmoothing(smoothing / scale);
 			}
-			font.draw(spriteBatch, layout, x, y + scale * getBaselineShift(font));
+			font.draw(spriteBatch, TEXT, x, y + scale * getBaselineShift(font));
 			y += font.getLineHeight();
 			spriteBatch.flush();
 		}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontFlipTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontFlipTest.java
index f2801b1..1c30b6b 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontFlipTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontFlipTest.java
@@ -22,12 +22,12 @@ import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.Texture;
 import com.badlogic.gdx.graphics.g2d.BitmapFont;
+import com.badlogic.gdx.graphics.g2d.BitmapFont.HAlignment;
 import com.badlogic.gdx.graphics.g2d.BitmapFontCache;
 import com.badlogic.gdx.graphics.g2d.Sprite;
 import com.badlogic.gdx.graphics.g2d.SpriteBatch;
 import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.tests.utils.GdxTest;
-import com.badlogic.gdx.utils.Align;
 
 public class BitmapFontFlipTest extends GdxTest {
 	private SpriteBatch spriteBatch;
@@ -66,7 +66,7 @@ public class BitmapFontFlipTest extends GdxTest {
 		cache5 = new BitmapFontCache(font);
 		createCaches("cached", cache1, cache2, cache3, cache4, cache5);
 
-		font.getData().setScale(1.33f);
+		font.setScale(1.33f);
 		cacheScaled1 = new BitmapFontCache(font);
 		cacheScaled2 = new BitmapFontCache(font);
 		cacheScaled3 = new BitmapFontCache(font);
@@ -81,18 +81,18 @@ public class BitmapFontFlipTest extends GdxTest {
 
 		String text = "Sphinx of black quartz,\njudge my vow.";
 		cache2.setColor(Color.RED);
-		cache2.setText(text, 5, 320 - 300);
+		cache2.setMultiLineText(text, 5, 320 - 300);
 
 		text = "How quickly\ndaft jumping zebras vex.";
 		cache3.setColor(Color.BLUE);
-		cache3.setText(text, 5, 320 - 200, 470, Align.center, false);
+		cache3.setMultiLineText(text, 5, 320 - 200, 470, BitmapFont.HAlignment.CENTER);
 
 		text = "Kerning: LYA moo";
-		cache4.setText(text, 210, 320 - 66, 0, text.length() - 3, 0, Align.left, false);
+		cache4.setText(text, 210, 320 - 66, 0, text.length() - 3);
 
 		text = "Forsaking monastic tradition, twelve jovial friars gave\nup their vocation for a questionable existence on the flying trapeze.";
 		cache5.setColor(red);
-		cache5.setText(text, 0, 320 - 300, 480, Align.center, false);
+		cache5.setWrappedText(text, 0, 320 - 300, 480, HAlignment.CENTER);
 	}
 
 	@Override
@@ -104,19 +104,19 @@ public class BitmapFontFlipTest extends GdxTest {
 		logoSprite.draw(spriteBatch);
 		switch (renderMode) {
 		case 0:
-			font.getData().setScale(1);
+			font.setScale(1);
 			renderNormal("normal");
 			break;
 		case 1:
-			font.getData().setScale(1);
+			font.setScale(1);
 			renderCached();
 			break;
 		case 2:
-			font.getData().setScale(red.a + 0.5f);
+			font.setScale(red.a + 0.5f);
 			renderNormal("normal scaled");
 			break;
 		case 3:
-			font.getData().setScale(1);
+			font.setScale(1);
 			renderCachedScaled();
 			break;
 		}
@@ -126,7 +126,7 @@ public class BitmapFontFlipTest extends GdxTest {
 	private void renderNormal (String type) {
 		String text = "Forsaking monastic tradition, twelve jovial friars gave\nup their vocation for a questionable existence on the flying trapeze.";
 		font.setColor(red);
-		font.draw(spriteBatch, text, 0, 320 - 300, 480, Align.center, false);
+		font.drawWrapped(spriteBatch, text, 0, 320 - 300, 480, HAlignment.CENTER);
 
 		font.setColor(Color.WHITE);
 		font.draw(spriteBatch, "(" + type + ")", 10, 320 - 66);
@@ -135,15 +135,15 @@ public class BitmapFontFlipTest extends GdxTest {
 
 		text = "Sphinx of black quartz,\njudge my vow.";
 		font.setColor(Color.RED);
-		font.draw(spriteBatch, text, 5, 320 - 300);
+		font.drawMultiLine(spriteBatch, text, 5, 320 - 300);
 
 		text = "How quickly\ndaft jumping zebras vex.";
 		font.setColor(Color.BLUE);
-		font.draw(spriteBatch, text, 5, 320 - 200, 470, Align.right, false);
+		font.drawMultiLine(spriteBatch, text, 5, 320 - 200, 470, BitmapFont.HAlignment.RIGHT);
 
 		text = "Kerning: LYA moo";
 		font.setColor(Color.WHITE);
-		font.draw(spriteBatch, text, 210, 320 - 66, 0, text.length() - 3, 0, Align.left, false);
+		font.draw(spriteBatch, text, 210, 320 - 66, 0, text.length() - 3);
 	}
 
 	private void renderCached () {
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontMetricsTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontMetricsTest.java
index 939ba86..212dc5c 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontMetricsTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontMetricsTest.java
@@ -20,7 +20,7 @@ import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.g2d.BitmapFont;
-import com.badlogic.gdx.graphics.g2d.GlyphLayout;
+import com.badlogic.gdx.graphics.g2d.BitmapFont.TextBounds;
 import com.badlogic.gdx.graphics.g2d.SpriteBatch;
 import com.badlogic.gdx.graphics.g2d.TextureAtlas;
 import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
@@ -78,7 +78,7 @@ public class BitmapFontMetricsTest extends GdxTest {
 		smallFont.draw(spriteBatch, "cap height", 20, viewHeight - 140);
 
 		font.setColor(Color.BLACK);
-		GlyphLayout layout = font.draw(spriteBatch, text, x, y);
+		TextBounds bounds = font.drawMultiLine(spriteBatch, text, x, y);
 
 		spriteBatch.end();
 
@@ -105,7 +105,7 @@ public class BitmapFontMetricsTest extends GdxTest {
 
 		renderer.begin(ShapeType.Line);
 		renderer.setColor(Color.BLUE);
-		renderer.rect(x, y, layout.width, -layout.height);
+		renderer.rect(x, y, bounds.width, -bounds.height);
 		renderer.end();
 	}
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontTest.java
index d6acc7f..11c4909 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/BitmapFontTest.java
@@ -21,8 +21,9 @@ import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.graphics.Colors;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.g2d.BitmapFont;
+import com.badlogic.gdx.graphics.g2d.BitmapFont.HAlignment;
+import com.badlogic.gdx.graphics.g2d.BitmapFont.TextBounds;
 import com.badlogic.gdx.graphics.g2d.BitmapFontCache;
-import com.badlogic.gdx.graphics.g2d.GlyphLayout;
 import com.badlogic.gdx.graphics.g2d.SpriteBatch;
 import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
 import com.badlogic.gdx.graphics.glutils.ShapeRenderer.ShapeType;
@@ -31,8 +32,6 @@ import com.badlogic.gdx.scenes.scene2d.ui.Label;
 import com.badlogic.gdx.scenes.scene2d.ui.Skin;
 import com.badlogic.gdx.scenes.scene2d.ui.Window;
 import com.badlogic.gdx.tests.utils.GdxTest;
-import com.badlogic.gdx.utils.Align;
-import com.badlogic.gdx.utils.viewport.ScreenViewport;
 
 public class BitmapFontTest extends GdxTest {
 	private Stage stage;
@@ -54,12 +53,12 @@ public class BitmapFontTest extends GdxTest {
 		renderer = new ShapeRenderer();
 		renderer.setProjectionMatrix(spriteBatch.getProjectionMatrix());
 
-		stage = new Stage(new ScreenViewport());
+		stage = new Stage();
 
 		Skin skin = new Skin(Gdx.files.internal("data/uiskin.json"));
 
 		BitmapFont labelFont = skin.get("default-font", BitmapFont.class);
-		labelFont.getData().markupEnabled = true;
+		labelFont.setMarkupEnabled(true);
 
 		// Notice that the last [] has been deliberately added to test the effect of excessive pop operations.
 		// They are silently ignored, as expected.
@@ -92,21 +91,23 @@ public class BitmapFontTest extends GdxTest {
 
 		if (false) {
 			alignmentWidth = 0;
-			font.draw(spriteBatch, text, x, viewHeight - y, alignmentWidth, Align.right, false);
+			font.drawMultiLine(spriteBatch, text, x, viewHeight - y, alignmentWidth, HAlignment.RIGHT);
+		}
+
+		if (false) {
+			TextBounds bounds = font.getMultiLineBounds(text);
+			alignmentWidth = bounds.width;
+			font.drawMultiLine(spriteBatch, text, x, viewHeight - y, alignmentWidth, HAlignment.RIGHT);
 		}
 
 		if (true) {
 			alignmentWidth = 280;
-			font.draw(spriteBatch, text, x, viewHeight - y, alignmentWidth, Align.right, true);
+			// font.drawMultiLine(spriteBatch, text, x, viewHeight - y, alignmentWidth, HAlignment.RIGHT);
+			font.drawWrapped(spriteBatch, text, x, viewHeight - y, alignmentWidth, HAlignment.RIGHT);
 		}
 
-		font.draw(spriteBatch, "[", 50, 60, 100, Align.left, true);
-		font.getData().markupEnabled = true;
-		font.draw(spriteBatch, "[", 100, 60, 100, Align.left, true);
-		font.getData().markupEnabled = false;
-
 		// 'R' and 'p' are in different pages
-		String txt2 = "this font uses " + multiPageFont.getRegions().size + " texture pages: RpRpRpRpRpNM";
+		String txt2 = "this font uses " + multiPageFont.getRegions().length + " texture pages: RpRpRpRpRpNM";
 		spriteBatch.renderCalls = 0;
 
 		// regular draw function
@@ -127,14 +128,14 @@ public class BitmapFontTest extends GdxTest {
 		cache.setColor(Color.BLACK);
 		float textX = 10;
 		textX += cache.setText("[black] ", textX, 150).width;
-		multiPageFont.getData().markupEnabled = true;
+		multiPageFont.setMarkupEnabled(true);
 		textX += cache.addText("[[[PINK]pink[]] ", textX, 150).width;
 		textX += cache.addText("[PERU][[peru] ", textX, 150).width;
 		cache.setColor(Color.GREEN);
 		textX += cache.addText("green ", textX, 150).width;
 		textX += cache.addText("[#A52A2A]br[#A52A2ADF]ow[#A52A2ABF]n f[#A52A2A9F]ad[#A52A2A7F]in[#A52A2A5F]g o[#A52A2A3F]ut ",
 			textX, 150).width;
-		multiPageFont.getData().markupEnabled = false;
+		multiPageFont.setMarkupEnabled(false);
 
 		cache.draw(spriteBatch);
 
@@ -148,19 +149,13 @@ public class BitmapFontTest extends GdxTest {
 
 		renderer.begin(ShapeType.Line);
 		renderer.setColor(Color.BLACK);
-		renderer.rect(x, viewHeight - y - 200, alignmentWidth, 200);
+		renderer.rect(x, viewHeight - y, x + alignmentWidth, 300);
 		renderer.end();
 
 		stage.act(Gdx.graphics.getDeltaTime());
 		stage.draw();
 	}
 
-	public void resize (int width, int height) {
-		spriteBatch.getProjectionMatrix().setToOrtho2D(0, 0, width, height);
-		renderer.setProjectionMatrix(spriteBatch.getProjectionMatrix());
-		stage.getViewport().update(width, height);
-	}
-
 	@Override
 	public void dispose () {
 		spriteBatch.dispose();
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/Box2DCharacterControllerTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/Box2DCharacterControllerTest.java
index 276d25a..708d668 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/Box2DCharacterControllerTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/Box2DCharacterControllerTest.java
@@ -280,7 +280,8 @@ public class Box2DCharacterControllerTest extends GdxTest implements Application
 
 		cam.project(point.set(pos.x, pos.y, 0));
 		batch.begin();
-		font.draw(batch, "friction: " + playerPhysicsFixture.getFriction() + "\ngrounded: " + grounded, point.x + 20, point.y);
+		font.drawMultiLine(batch, "friction: " + playerPhysicsFixture.getFriction() + "\ngrounded: " + grounded, point.x + 20,
+			point.y);
 		batch.end();
 	}
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/BulletTestCollection.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/BulletTestCollection.java
index a4ac457..d57806e 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/BulletTestCollection.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/BulletTestCollection.java
@@ -29,9 +29,9 @@ import com.badlogic.gdx.input.GestureDetector.GestureListener;
 import com.badlogic.gdx.math.Vector2;
 import com.badlogic.gdx.scenes.scene2d.Stage;
 import com.badlogic.gdx.scenes.scene2d.ui.Label;
+import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.tests.bullet.*;
 import com.badlogic.gdx.tests.utils.GdxTest;
-import com.badlogic.gdx.utils.Align;
 
 /** @author xoppa */
 public class BulletTestCollection extends GdxTest implements InputProcessor, GestureListener {
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/CpuSpriteBatchTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/CpuSpriteBatchTest.java
index 6cf4b76..ea3a192 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/CpuSpriteBatchTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/CpuSpriteBatchTest.java
@@ -29,10 +29,10 @@ import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.scenes.scene2d.Actor;
 import com.badlogic.gdx.scenes.scene2d.Group;
 import com.badlogic.gdx.scenes.scene2d.Stage;
+import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
 import com.badlogic.gdx.scenes.scene2d.utils.TransformDrawable;
 import com.badlogic.gdx.tests.utils.GdxTest;
-import com.badlogic.gdx.utils.Align;
 import com.badlogic.gdx.utils.TimeUtils;
 import com.badlogic.gdx.utils.viewport.ExtendViewport;
 import com.badlogic.gdx.utils.viewport.Viewport;
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/EdgeDetectionTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/EdgeDetectionTest.java
index 1531e2a..c8d08c4 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/EdgeDetectionTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/EdgeDetectionTest.java
@@ -67,7 +67,7 @@ public class EdgeDetectionTest extends GdxTest {
 		}
 
 		ObjLoader objLoader = new ObjLoader();
-		scene = objLoader.loadModel(Gdx.files.internal("data/scene.obj"));
+		scene = objLoader.loadObj(Gdx.files.internal("data/scene.obj"));
 		sceneInstance = new ModelInstance(scene);
 		modelBatch = new ModelBatch();
 		fbo = new FrameBuffer(Format.RGB565, Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), true);
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/FilesTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/FilesTest.java
index 8b87b91..14f714e 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/FilesTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/FilesTest.java
@@ -459,7 +459,7 @@ public class FilesTest extends GdxTest {
 	public void render () {
 		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
 		batch.begin();
-		font.draw(batch, message, 20, Gdx.graphics.getHeight() - 20);
+		font.drawMultiLine(batch, message, 20, Gdx.graphics.getHeight() - 20);
 		batch.end();
 	}
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/FloatTextureTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/FloatTextureTest.java
index 4a527b6..6376f8c 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/FloatTextureTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/FloatTextureTest.java
@@ -139,7 +139,7 @@ public class FloatTextureTest extends GdxTest {
 
 	private void createQuad () {
 		if (quad != null) return;
-		quad = new Mesh(true, 4, 6, new VertexAttribute(Usage.Position, 3, "a_position"), new VertexAttribute(Usage.ColorUnpacked, 4,
+		quad = new Mesh(true, 4, 6, new VertexAttribute(Usage.Position, 3, "a_position"), new VertexAttribute(Usage.Color, 4,
 			"a_color"), new VertexAttribute(Usage.TextureCoordinates, 2, "a_texCoords"));
 
 		quad.setVertices(new float[] {-1, -1, 0, 1, 1, 1, 1, 0, 1, 1, -1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, -1, 1, 0,
@@ -149,7 +149,7 @@ public class FloatTextureTest extends GdxTest {
 
 	private void createScreenQuad () {
 		if (screenQuad != null) return;
-		screenQuad = new Mesh(true, 4, 6, new VertexAttribute(Usage.Position, 3, "a_position"), new VertexAttribute(Usage.ColorUnpacked, 4,
+		screenQuad = new Mesh(true, 4, 6, new VertexAttribute(Usage.Position, 3, "a_position"), new VertexAttribute(Usage.Color, 4,
 			"a_color"), new VertexAttribute(Usage.TextureCoordinates, 2, "a_texCoords"));
 
 		Vector3 vec0 = new Vector3(0, 0, 0);
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/FrameBufferCubemapTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/FrameBufferCubemapTest.java
new file mode 100644
index 0000000..796a741
--- /dev/null
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/FrameBufferCubemapTest.java
@@ -0,0 +1,119 @@
+package com.badlogic.gdx.tests;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.graphics.Camera;
+import com.badlogic.gdx.graphics.Cubemap;
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.gdx.graphics.PerspectiveCamera;
+import com.badlogic.gdx.graphics.Pixmap.Format;
+import com.badlogic.gdx.graphics.g3d.Model;
+import com.badlogic.gdx.graphics.g3d.ModelBatch;
+import com.badlogic.gdx.graphics.g3d.ModelInstance;
+import com.badlogic.gdx.graphics.g3d.attributes.CubemapAttribute;
+import com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute;
+import com.badlogic.gdx.graphics.g3d.loader.ObjLoader;
+import com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor;
+import com.badlogic.gdx.graphics.glutils.FrameBufferCubemap;
+import com.badlogic.gdx.math.Vector3;
+import com.badlogic.gdx.tests.g3d.Animation3DTest;
+import com.badlogic.gdx.tests.g3d.Basic3DSceneTest;
+
+/**
+ * Render a basic scene in a FrameBufferCubemap and displays it
+ * in a rotating cube.
+ */
+public class FrameBufferCubemapTest extends Basic3DSceneTest {
+	protected PerspectiveCamera camFb;
+	protected PerspectiveCamera camCube;
+	protected FrameBufferCubemap fb;
+	protected Cubemap cubemap;
+	protected Model cubeMesh;
+	protected ModelInstance cubeInstance;
+	protected ModelBatch cubeBatch;
+	
+	@Override
+	public void create () {
+		super.create();
+		
+		camFb = new PerspectiveCamera(90, 800, 800);
+		camFb.position.set(10f, 10f, 10f);
+		camFb.lookAt(0, 0, 0);
+		camFb.near = 0.1f;
+		camFb.far = 1000f;
+		camFb.update();
+		
+		fb = new FrameBufferCubemap(Format.RGBA8888, 800, 800, false);
+		
+		ObjLoader objLoader = new ObjLoader();
+		cubeMesh = objLoader.loadModel(Gdx.files.internal("data/cube.obj"));
+		cubeInstance = new ModelInstance(cubeMesh);
+		
+		cubeBatch = new ModelBatch(Gdx.files.internal("data/shaders/cubemap-vert.glsl"),
+											 Gdx.files.internal("data/shaders/cubemap-frag.glsl"));
+		
+		cubeMesh.materials.get(0).set(new CubemapAttribute(CubemapAttribute.EnvironmentMap, cubemap));
+		
+		camCube = new PerspectiveCamera(67, Gdx.graphics.getWidth()*0.5f, Gdx.graphics.getHeight()*0.5f);
+		camCube.position.set(0f, 2f, 2f);
+		camCube.lookAt(0, 0, 0);
+		camCube.near = 0.1f;
+		camCube.far = 300f;
+		camCube.update();
+	}
+	
+	@Override
+	public void render () {
+		renderScene();
+		renderCube();
+	}
+	
+	public void renderScene() {
+		Gdx.gl.glViewport(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
+		Gdx.gl.glDisable(GL20.GL_SCISSOR_TEST);
+		
+		// Render scene to screen
+		super.render();
+		
+		// Render scene to cubemap
+		camFb.position.set(cam.position);
+		camFb.near = cam.near;
+		camFb.far = cam.far;
+		fb.begin();
+		while( fb.nextSide() ) {
+			fb.getSide().getUp(camFb.up);
+			fb.getSide().getDirection(camFb.direction);
+			camFb.update();
+			
+			Gdx.gl.glClearColor(1, 1, 1, 1);
+			Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT | GL20.GL_DEPTH_BUFFER_BIT);
+
+			modelBatch.begin(camFb);
+			for (ModelInstance instance : instances)
+				modelBatch.render(instance, lights);
+			if (space != null) modelBatch.render(space);
+			modelBatch.end();
+		}
+		fb.end();
+		cubemap = fb.getColorBufferCubemap();
+	}
+	
+	public void renderCube() {
+		int w = Gdx.graphics.getWidth();
+		int h = Gdx.graphics.getHeight();
+		int x = (int)(w - w*0.5f);
+		int y = (int)(h - h*0.5f);
+		w *= 0.5f;
+		h *= 0.5f;
+		
+		Gdx.gl.glViewport(x, y, w, h);
+		Gdx.gl.glEnable(GL20.GL_SCISSOR_TEST);
+		Gdx.gl.glScissor(x, y, w, h);
+		Gdx.gl.glClearColor(1, 1, 1, 1);
+		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT | GL20.GL_DEPTH_BUFFER_BIT);
+		
+		cubeInstance.transform.rotate(Vector3.Y, 45 * Gdx.graphics.getDeltaTime());
+		cubeBatch.begin(camCube);
+		cubeBatch.render(cubeInstance);
+		cubeBatch.end();
+	}
+}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/FramebufferToTextureTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/FramebufferToTextureTest.java
index 3683b74..3801f11 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/FramebufferToTextureTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/FramebufferToTextureTest.java
@@ -52,7 +52,7 @@ public class FramebufferToTextureTest extends GdxTest {
 		texture = new Texture(Gdx.files.internal("data/badlogic.jpg"), true);
 		texture.setFilter(TextureFilter.MipMap, TextureFilter.Linear);
 		ObjLoader objLoader = new ObjLoader();
-		mesh = objLoader.loadModel(Gdx.files.internal("data/cube.obj"));
+		mesh = objLoader.loadObj(Gdx.files.internal("data/cube.obj"));
 		mesh.materials.get(0).set(new TextureAttribute(TextureAttribute.Diffuse, texture));
 		modelInstance = new ModelInstance(mesh);
 		modelBatch = new ModelBatch();
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/FreeTypeDisposeTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/FreeTypeDisposeTest.java
new file mode 100644
index 0000000..ed34518
--- /dev/null
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/FreeTypeDisposeTest.java
@@ -0,0 +1,56 @@
+/*******************************************************************************
+ * Copyright 2011 See AUTHORS file.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package com.badlogic.gdx.tests;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.files.FileHandle;
+import com.badlogic.gdx.graphics.g2d.BitmapFont;
+import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator;
+import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator.FreeTypeBitmapFontData;
+import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator.FreeTypeFontParameter;
+import com.badlogic.gdx.tests.utils.GdxTest;
+
+public class FreeTypeDisposeTest extends GdxTest {
+	BitmapFont font;
+
+	@Override
+	public void create () {
+		super.create();
+	}
+
+	public void render () {
+		if (Gdx.input.justTouched()) {
+			for (int i = 0; i < 10; i++) {
+				if (font != null) {
+					font.dispose();
+				}
+				FileHandle fontFile = Gdx.files.internal("data/arial.ttf");
+				FreeTypeFontGenerator generator = new FreeTypeFontGenerator(fontFile);
+
+				FreeTypeFontParameter parameter = new FreeTypeFontParameter();
+				parameter.size = 15;
+
+				font = generator.generateFont(parameter);
+				generator.dispose();
+			}
+			for (int i = 0; i < 10; i++)
+				System.gc();
+			Gdx.app.log("FreeTypeDisposeTest", "generated 10 fonts");
+			Gdx.app.log("FreeTypeDisposeTest", Gdx.app.getJavaHeap() + ", " + Gdx.app.getNativeHeap());
+		}
+	}
+}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/FreeTypeFontLoaderTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/FreeTypeFontLoaderTest.java
new file mode 100644
index 0000000..e92f921
--- /dev/null
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/FreeTypeFontLoaderTest.java
@@ -0,0 +1,79 @@
+package com.badlogic.gdx.tests;
+
+import com.badlogic.gdx.Gdx;
+import com.badlogic.gdx.assets.AssetManager;
+import com.badlogic.gdx.assets.loaders.FileHandleResolver;
+import com.badlogic.gdx.assets.loaders.resolvers.InternalFileHandleResolver;
+import com.badlogic.gdx.graphics.GL20;
+import com.badlogic.gdx.graphics.g2d.BitmapFont;
+import com.badlogic.gdx.graphics.g2d.SpriteBatch;
+import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator;
+import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGeneratorLoader;
+import com.badlogic.gdx.graphics.g2d.freetype.FreetypeFontLoader;
+import com.badlogic.gdx.graphics.g2d.freetype.FreetypeFontLoader.FreeTypeFontLoaderParameter;
+import com.badlogic.gdx.tests.utils.GdxTest;
+
+public class FreeTypeFontLoaderTest extends GdxTest {
+	AssetManager manager;
+	SpriteBatch batch;
+
+	@Override
+	public void create () {
+		manager = new AssetManager();
+		
+		// set the loaders for the generator and the fonts themselves
+		FileHandleResolver resolver = new InternalFileHandleResolver();
+		manager.setLoader(FreeTypeFontGenerator.class, new FreeTypeFontGeneratorLoader(resolver));
+		manager.setLoader(BitmapFont.class, ".ttf", new FreetypeFontLoader(resolver));
+		
+		// load to fonts via the generator (implicitely done by the FreetypeFontLoader).
+		// Note: you MUST specify a FreetypeFontGenerator defining the ttf font file name and the size
+		// of the font to be generated. The names of the fonts are arbitrary and are not pointing
+		// to a file on disk!
+		FreeTypeFontLoaderParameter size1Params = new FreeTypeFontLoaderParameter();
+		size1Params.fontFileName = "data/arial.ttf";
+		size1Params.fontParameters.size = 10;
+		manager.load("size10.ttf", BitmapFont.class, size1Params);
+		
+		FreeTypeFontLoaderParameter size2Params = new FreeTypeFontLoaderParameter();
+		size2Params.fontFileName = "data/arial.ttf";
+		size2Params.fontParameters.size = 20;
+		manager.load("size20.ttf", BitmapFont.class, size2Params);
+		
+		// we also load a "normal" font generated via Hiero
+		manager.load("data/default.fnt", BitmapFont.class);
+		
+		batch = new SpriteBatch();
+	}
+
+	@Override
+	public void render () {
+		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
+		if(manager.update() && manager.isLoaded("size10.ttf")) {
+			batch.begin();
+			manager.get("size10.ttf", BitmapFont.class).draw(batch, "First font!", 20, 20);
+			manager.get("size20.ttf", BitmapFont.class).draw(batch, "Second font!", 20, 50);
+			manager.get("data/default.fnt", BitmapFont.class).draw(batch, "Default font!", 20, 100);
+			batch.end();
+		}
+		
+		if(Gdx.input.justTouched() && manager.isLoaded("size10.ttf")) {
+			// unload all the things and check if they really get disposed properly
+			manager.unload("size10.ttf");
+			manager.finishLoading();
+			if(!manager.isLoaded("size20.ttf")) throw new RuntimeException("broken");
+			if(!manager.isLoaded("data/arial.ttf")) throw new RuntimeException("broken");
+			
+			manager.unload("size20.ttf");
+			manager.finishLoading();
+			if(manager.isLoaded("size20.ttf")) throw new RuntimeException("broken");
+			if(manager.isLoaded("data/arial.ttf")) throw new RuntimeException("broken");
+		}
+	}
+
+	@Override
+	public void dispose () {
+		manager.dispose();
+		batch.dispose();
+	}
+}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/I18NMessageTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/I18NMessageTest.java
index edadb07..826e333 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/I18NMessageTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/I18NMessageTest.java
@@ -98,7 +98,7 @@ public class I18NMessageTest extends GdxTest {
 	public void render () {
 		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
 		batch.begin();
-		font.draw(batch, message, 20, Gdx.graphics.getHeight() - 20);
+		font.drawMultiLine(batch, message, 20, Gdx.graphics.getHeight() - 20);
 		batch.end();
 	}
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/I18NSimpleMessageTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/I18NSimpleMessageTest.java
index fe29968..2784e2b 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/I18NSimpleMessageTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/I18NSimpleMessageTest.java
@@ -100,7 +100,7 @@ public class I18NSimpleMessageTest extends GdxTest {
 	public void render () {
 		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
 		batch.begin();
-		font.draw(batch, message, 20, Gdx.graphics.getHeight() - 20);
+		font.drawMultiLine(batch, message, 20, Gdx.graphics.getHeight() - 20);
 		batch.end();
 	}
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/IntegerBitmapFontTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/IntegerBitmapFontTest.java
index ab3ae6f..2018f02 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/IntegerBitmapFontTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/IntegerBitmapFontTest.java
@@ -19,11 +19,11 @@ package com.badlogic.gdx.tests;
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.g2d.BitmapFont;
+import com.badlogic.gdx.graphics.g2d.BitmapFont.HAlignment;
 import com.badlogic.gdx.graphics.g2d.BitmapFontCache;
 import com.badlogic.gdx.graphics.g2d.SpriteBatch;
 import com.badlogic.gdx.graphics.g2d.TextureAtlas;
 import com.badlogic.gdx.tests.utils.GdxTest;
-import com.badlogic.gdx.utils.Align;
 
 public class IntegerBitmapFontTest extends GdxTest {
 
@@ -72,17 +72,17 @@ public class IntegerBitmapFontTest extends GdxTest {
 		singleLineCache.setColor(0, 0, 1, 1);
 		singleLineCache.setText(text, 10.2f, 30.5f);
 		multiLineCache.setColor(0, 0, 1, 1);
-		multiLineCache.setText(text, 10.5f, 180.5f, 200, Align.center, false);
+		multiLineCache.setMultiLineText(text, 10.5f, 180.5f, 200, HAlignment.CENTER);
 		singleLineCacheNonInteger.setColor(0, 1, 0, 1);
 		singleLineCacheNonInteger.setText(text, 10.2f, 30.5f);
 		multiLineCacheNonInteger.setColor(0, 1, 0, 1);
-		multiLineCacheNonInteger.setText(text, 10.5f, 180.5f, 200, Align.center, false);
+		multiLineCacheNonInteger.setMultiLineText(text, 10.5f, 180.5f, 200, HAlignment.CENTER);
 	}
 
 	private void drawTexts () {
 		String text = "This is a TEST\nxahsdhwekjhasd23$%$%/%&";
 		font.draw(batch, text, 10.2f, 30.5f);
-		font.draw(batch, text, 10.5f, 120.5f);
-		font.draw(batch, text, 10.5f, 180.5f, 200, Align.center, false);
+		font.drawMultiLine(batch, text, 10.5f, 120.5f);
+		font.drawMultiLine(batch, text, 10.5f, 180.5f, 200, HAlignment.CENTER);
 	}
 }
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/InterpolationTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/InterpolationTest.java
index 0c16718..f326b94 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/InterpolationTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/InterpolationTest.java
@@ -35,7 +35,6 @@ import com.badlogic.gdx.scenes.scene2d.ui.Skin;
 import com.badlogic.gdx.scenes.scene2d.ui.Table;
 import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
 import com.badlogic.gdx.tests.utils.GdxTest;
-import com.badlogic.gdx.utils.Align;
 import com.badlogic.gdx.utils.reflect.ClassReflection;
 import com.badlogic.gdx.utils.reflect.Field;
 import com.badlogic.gdx.utils.viewport.ScreenViewport;
@@ -147,8 +146,8 @@ public class InterpolationTest extends GdxTest {
 		if (text.length() > 4) text = text.substring(0, text.lastIndexOf('.') + 3);
 		text = "duration: " + text + " s (ctrl + scroll to change)";
 		stage.getBatch().begin();
-		list.getStyle().font.draw(stage.getBatch(), text, bottomLeftX + graphSize / 2, bottomLeftY + graphSize
-			+ list.getStyle().font.getLineHeight(), 0, Align.center, false);
+		list.getStyle().font.draw(stage.getBatch(), text, bottomLeftX + graphSize / 2 - list.getStyle().font.getBounds(text).width
+			/ 2, bottomLeftY + graphSize + list.getStyle().font.getLineHeight());
 		stage.getBatch().end();
 
 		renderer.begin(ShapeType.Line);
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/LabelTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/LabelTest.java
index ebd8df7..0d86586 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/LabelTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/LabelTest.java
@@ -29,9 +29,8 @@ import com.badlogic.gdx.scenes.scene2d.Stage;
 import com.badlogic.gdx.scenes.scene2d.ui.Label;
 import com.badlogic.gdx.scenes.scene2d.ui.Skin;
 import com.badlogic.gdx.scenes.scene2d.ui.Table;
+import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.tests.utils.GdxTest;
-import com.badlogic.gdx.utils.Align;
-import com.badlogic.gdx.utils.viewport.ScreenViewport;
 
 public class LabelTest extends GdxTest {
 	Skin skin;
@@ -46,10 +45,8 @@ public class LabelTest extends GdxTest {
 		renderer = new ShapeRenderer();
 		skin = new Skin(Gdx.files.internal("data/uiskin.json"));
 		skin.getAtlas().getTextures().iterator().next().setFilter(TextureFilter.Nearest, TextureFilter.Nearest);
-		skin.getFont("default-font").getData().markupEnabled = true;
-		float scale = 1;
-		skin.getFont("default-font").getData().setScale(scale);
-		stage = new Stage(new ScreenViewport());
+		skin.getFont("default-font").setMarkupEnabled(true);
+		stage = new Stage();
 		Gdx.input.setInputProcessor(stage);
 
 		Table table = new Table();
@@ -64,17 +61,17 @@ public class LabelTest extends GdxTest {
 		Label label3 = new Label("This is [RED]regular text\n\nwith newlines,\naligned bottom, right.", skin);
 		label3.setColor(Color.GREEN);
 		label3.setAlignment(Align.bottom | Align.right);
-		table.add(label3).minWidth(200 * scale).minHeight(110 * scale).fill();
+		table.add(label3).minWidth(200).minHeight(110).fill();
 		table.row();
 		Label label4 = new Label("This is regular text with NO newlines, wrap enabled and aligned bottom, right.", skin);
 		label4.setWrap(true);
 		label4.setAlignment(Align.bottom | Align.right);
-		table.add(label4).minWidth(200 * scale).minHeight(110 * scale).fill();
+		table.add(label4).minWidth(200).minHeight(110).fill();
 		table.row();
 		Label label5 = new Label("This is regular text with\n\nnewlines, wrap\nenabled and aligned bottom, right.", skin);
 		label5.setWrap(true);
 		label5.setAlignment(Align.bottom | Align.right);
-		table.add(label5).minWidth(200 * scale).minHeight(110 * scale).fill();
+		table.add(label5).minWidth(200).minHeight(110).fill();
 
 		table.pack();
 	}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/ProjectTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/ProjectTest.java
index 5d403f8..72ed95f 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/ProjectTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/ProjectTest.java
@@ -50,7 +50,7 @@ public class ProjectTest extends GdxTest {
 	@Override
 	public void create () {
 		ObjLoader objLoader = new ObjLoader();
-		sphere = objLoader.loadModel(Gdx.files.internal("data/sphere.obj"));
+		sphere = objLoader.loadObj(Gdx.files.internal("data/sphere.obj"));
 		sphere.materials.get(0).set(new ColorAttribute(ColorAttribute.Diffuse, Color.WHITE));
 		cam = new PerspectiveCamera(45, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
 		cam.far = 200;
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/ReflectionTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/ReflectionTest.java
index f13a1a7..4d34f20 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/ReflectionTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/ReflectionTest.java
@@ -96,7 +96,7 @@ public class ReflectionTest extends GdxTest {
 	public void render () {
 		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
 		batch.begin();
-		font.draw(batch, message, 20, Gdx.graphics.getHeight() - 20);
+		font.drawMultiLine(batch, message, 20, Gdx.graphics.getHeight() - 20);
 		batch.end();
 	}
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/SimpleStageCullingTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/SimpleStageCullingTest.java
index b34761e..f99c23c 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/SimpleStageCullingTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/SimpleStageCullingTest.java
@@ -28,10 +28,10 @@ import com.badlogic.gdx.math.Rectangle;
 import com.badlogic.gdx.scenes.scene2d.Actor;
 import com.badlogic.gdx.scenes.scene2d.Stage;
 import com.badlogic.gdx.scenes.scene2d.ui.Image;
+import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.scenes.scene2d.utils.Cullable;
 import com.badlogic.gdx.tests.utils.GdxTest;
 import com.badlogic.gdx.tests.utils.OrthoCamController;
-import com.badlogic.gdx.utils.Align;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.Scaling;
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/SoftKeyboardTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/SoftKeyboardTest.java
index 0249647..91be587 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/SoftKeyboardTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/SoftKeyboardTest.java
@@ -64,7 +64,7 @@ public class SoftKeyboardTest extends GdxTest {
 	public void render () {
 		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
 		batch.begin();
-		font.draw(batch, textBuffer, 0, Gdx.graphics.getHeight() - 20);
+		font.drawMultiLine(batch, textBuffer, 0, Gdx.graphics.getHeight() - 20);
 		batch.end();
 
 		// bring up the keyboard if we touch the screen
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/SoundTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/SoundTest.java
index 8308589..a5fe658 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/SoundTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/SoundTest.java
@@ -28,10 +28,10 @@ import com.badlogic.gdx.scenes.scene2d.ui.Skin;
 import com.badlogic.gdx.scenes.scene2d.ui.Slider;
 import com.badlogic.gdx.scenes.scene2d.ui.Table;
 import com.badlogic.gdx.scenes.scene2d.ui.TextButton;
+import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
 import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
 import com.badlogic.gdx.tests.utils.GdxTest;
-import com.badlogic.gdx.utils.Align;
 
 public class SoundTest extends GdxTest {
 	Sound sound;
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/StagePerformanceTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/StagePerformanceTest.java
index 6b66527..982423f 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/StagePerformanceTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/StagePerformanceTest.java
@@ -102,7 +102,7 @@ public class StagePerformanceTest extends GdxTest {
 		batch.enableBlending();
 		batch.begin();
 		font.setColor(0, 0, 1, 1);
-		font.getData().setScale(2);
+		font.setScale(2);
 		font.draw(batch, "fps: " + Gdx.graphics.getFramesPerSecond() + (useStage ? ", stage" : "sprite"), 10, 40);
 		batch.end();
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/StageTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/StageTest.java
index 0713589..fb54c27 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/StageTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/StageTest.java
@@ -35,8 +35,8 @@ import com.badlogic.gdx.scenes.scene2d.Stage;
 import com.badlogic.gdx.scenes.scene2d.Touchable;
 import com.badlogic.gdx.scenes.scene2d.ui.Image;
 import com.badlogic.gdx.scenes.scene2d.ui.Label;
+import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.tests.utils.GdxTest;
-import com.badlogic.gdx.utils.Align;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.Scaling;
 import com.badlogic.gdx.utils.viewport.ScreenViewport;
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/UITest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/UITest.java
index 25d3d5d..1f4b314 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/UITest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/UITest.java
@@ -42,10 +42,10 @@ import com.badlogic.gdx.scenes.scene2d.ui.TextButton;
 import com.badlogic.gdx.scenes.scene2d.ui.TextField;
 import com.badlogic.gdx.scenes.scene2d.ui.TextField.TextFieldListener;
 import com.badlogic.gdx.scenes.scene2d.ui.Window;
+import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
 import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
 import com.badlogic.gdx.tests.utils.GdxTest;
-import com.badlogic.gdx.utils.Align;
 import com.badlogic.gdx.utils.viewport.ScreenViewport;
 
 public class UITest extends GdxTest {
@@ -101,16 +101,16 @@ public class UITest extends GdxTest {
 		TextField textfield = new TextField("", skin);
 		textfield.setMessageText("Click here!");
 		textfield.setAlignment(Align.center);
-		final SelectBox selectBox = new SelectBox(skin);
-		selectBox.addListener(new ChangeListener() {
+		final SelectBox dropdown = new SelectBox(skin);
+		dropdown.addListener(new ChangeListener() {
 			public void changed (ChangeEvent event, Actor actor) {
-				System.out.println(selectBox.getSelected());
+				System.out.println(dropdown.getSelected());
 			}
 		});
-		selectBox.setItems("Android1", "Windows1 long text in item", "Linux1", "OSX1", "Android2", "Windows2", "Linux2", "OSX2", "Android3",
+		dropdown.setItems("Android1", "Windows1", "Linux1", "OSX1", "Android2", "Windows2", "Linux2", "OSX2", "Android3",
 			"Windows3", "Linux3", "OSX3", "Android4", "Windows4", "Linux4", "OSX4", "Android5", "Windows5", "Linux5", "OSX5",
 			"Android6", "Windows6", "Linux6", "OSX6", "Android7", "Windows7", "Linux7", "OSX7");
-		selectBox.setSelected("Linux6");
+		dropdown.setSelected("Linux6");
 		Image imageActor = new Image(image2);
 		ScrollPane scrollPane = new ScrollPane(imageActor);
 		List list = new List(skin);
@@ -132,7 +132,7 @@ public class UITest extends GdxTest {
 
 		// window.debug();
 		Window window = new Window("Dialog", skin);
-		window.getTitleTable().add(new TextButton("X", skin)).height(window.getPadTop());
+		window.getButtonTable().add(new TextButton("X", skin)).height(window.getPadTop());
 		window.setPosition(0, 0);
 		window.defaults().spaceBottom(10);
 		window.row().fill().expandX();
@@ -144,7 +144,7 @@ public class UITest extends GdxTest {
 		window.add(checkBox);
 		window.add(slider).minWidth(100).fillX().colspan(3);
 		window.row();
-		window.add(selectBox).maxWidth(100);
+		window.add(dropdown);
 		window.add(textfield).minWidth(100).expandX().fillX().colspan(3);
 		window.row();
 		window.add(splitPane).fill().expand().colspan(4).maxHeight(200);
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletConstructor.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletConstructor.java
index 2e79af4..635cf09 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletConstructor.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/BulletConstructor.java
@@ -57,7 +57,8 @@ public class BulletConstructor extends BaseWorld.Constructor<BulletEntity> {
 	public BulletConstructor (final Model model, final float mass) {
 		final BoundingBox boundingBox = new BoundingBox();
 		model.calculateBoundingBox(boundingBox);
-		create(model, mass, boundingBox.getWidth(), boundingBox.getHeight(), boundingBox.getDepth());
+		final Vector3 dimensions = boundingBox.getDimensions();
+		create(model, mass, dimensions.x, dimensions.y, dimensions.z);
 	}
 
 	/** Creates a btBoxShape with the same dimensions as the shape and NO rigidbody. */
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/FrustumCullingTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/FrustumCullingTest.java
index 5b1fe31..f4312fa 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/FrustumCullingTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/FrustumCullingTest.java
@@ -25,7 +25,6 @@ import com.badlogic.gdx.graphics.VertexAttributes.Usage;
 import com.badlogic.gdx.graphics.g3d.Material;
 import com.badlogic.gdx.graphics.g3d.Model;
 import com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute;
-import com.badlogic.gdx.graphics.g3d.utils.MeshPartBuilder;
 import com.badlogic.gdx.graphics.g3d.utils.ModelBuilder;
 import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.math.Vector3;
@@ -111,17 +110,14 @@ public class FrustumCullingTest extends BaseBulletTest {
 	}
 
 	public static Model createFrustumModel (final Vector3... p) {
-		ModelBuilder builder = new ModelBuilder();
-		MeshPartBuilder mpb = builder.part("", GL20.GL_LINES, Usage.Position | Usage.Normal, new Material(new ColorAttribute(ColorAttribute.Diffuse, Color.WHITE)));
-		mpb.vertex(p[0].x, p[0].y, p[0].z, 0, 0, 1, p[1].x, p[1].y, p[1].z, 0, 0, 1, p[2].x,
+		return ModelBuilder.createFromMesh(new float[] {p[0].x, p[0].y, p[0].z, 0, 0, 1, p[1].x, p[1].y, p[1].z, 0, 0, 1, p[2].x,
 			p[2].y, p[2].z, 0, 0, 1, p[3].x, p[3].y, p[3].z, 0, 0,
 			1, // near
 			p[4].x, p[4].y, p[4].z, 0, 0, -1, p[5].x, p[5].y, p[5].z, 0, 0, -1, p[6].x, p[6].y, p[6].z, 0, 0, -1, p[7].x, p[7].y,
-			p[7].z, 0, 0, -1);
-		mpb.index((short)0, (short)1, (short)1, (short)2, (short)2, (short)3, (short)3, (short)0);
-		mpb.index((short)4, (short)5, (short)5, (short)6, (short)6, (short)7, (short)7, (short)4);
-		mpb.index((short)0, (short)4, (short)1, (short)5, (short)2, (short)6, (short)3, (short)7);
-		return builder.end();
+			p[7].z, 0, 0, -1},// far
+			new VertexAttribute[] {new VertexAttribute(Usage.Position, 3, "a_position"),
+				new VertexAttribute(Usage.Normal, 3, "a_normal")}, new short[] {0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4,
+				1, 5, 2, 6, 3, 7}, GL20.GL_LINES, new Material(new ColorAttribute(ColorAttribute.Diffuse, Color.WHITE)));
 	}
 
 	private float angleX, angleY, angleZ;
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/SoftBodyTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/SoftBodyTest.java
index 17de3bd..9477805 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/SoftBodyTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/SoftBodyTest.java
@@ -30,7 +30,6 @@ import com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute;
 import com.badlogic.gdx.graphics.g3d.attributes.FloatAttribute;
 import com.badlogic.gdx.graphics.g3d.attributes.IntAttribute;
 import com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute;
-import com.badlogic.gdx.graphics.g3d.model.MeshPart;
 import com.badlogic.gdx.graphics.g3d.utils.ModelBuilder;
 import com.badlogic.gdx.graphics.glutils.ShaderProgram;
 import com.badlogic.gdx.math.Matrix4;
@@ -117,14 +116,8 @@ public class SoftBodyTest extends BaseBulletTest {
 		mesh.setVertices(verts);
 		texture = new Texture(Gdx.files.internal("data/badlogic.jpg"));
 
-		ModelBuilder builder = new ModelBuilder();
-		builder.begin();
-		builder.part(
-			new MeshPart("", mesh, 0, mesh.getNumIndices(), GL20.GL_TRIANGLES),
-			new Material(TextureAttribute.createDiffuse(texture), ColorAttribute.createSpecular(Color.WHITE), FloatAttribute
-				.createShininess(64f), IntAttribute.createCullFace(0)));
-		model = builder.end();
-
+		model = ModelBuilder.createFromMesh(mesh, GL20.GL_TRIANGLES, new Material(TextureAttribute.createDiffuse(texture),
+			ColorAttribute.createSpecular(Color.WHITE), FloatAttribute.createShininess(64f), IntAttribute.createCullFace(0)));
 		instance = new ModelInstance(model);
 		world.add(new BulletEntity(instance, null));
 	}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/VehicleTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/VehicleTest.java
index 7215b6f..4070a0a 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/VehicleTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/bullet/VehicleTest.java
@@ -80,8 +80,8 @@ public class VehicleTest extends BaseBulletTest {
 		world.addConstructor("largeground", new BulletConstructor(largeGroundModel, 0f));
 
 		BoundingBox bounds = new BoundingBox();
-		Vector3 chassisHalfExtents = chassisModel.calculateBoundingBox(bounds).getDimensions(new Vector3()).scl(0.5f);
-		Vector3 wheelHalfExtents = wheelModel.calculateBoundingBox(bounds).getDimensions(new Vector3()).scl(0.5f);
+		Vector3 chassisHalfExtents = new Vector3(chassisModel.calculateBoundingBox(bounds).getDimensions()).scl(0.5f);
+		Vector3 wheelHalfExtents = new Vector3(wheelModel.calculateBoundingBox(bounds).getDimensions()).scl(0.5f);
 
 		world.addConstructor("chassis", new BulletConstructor(chassisModel, 5f, new btBoxShape(chassisHalfExtents)));
 		world.addConstructor("wheel", new BulletConstructor(wheelModel, 0, null));
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/extensions/FreeTypeDisposeTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/extensions/FreeTypeDisposeTest.java
deleted file mode 100644
index 7ac2d1b..0000000
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/extensions/FreeTypeDisposeTest.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.tests.extensions;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.g2d.BitmapFont;
-import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator;
-import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator.FreeTypeBitmapFontData;
-import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator.FreeTypeFontParameter;
-import com.badlogic.gdx.tests.utils.GdxTest;
-
-public class FreeTypeDisposeTest extends GdxTest {
-	BitmapFont font;
-
-	@Override
-	public void create () {
-		super.create();
-	}
-
-	public void render () {
-		if (Gdx.input.justTouched()) {
-			for (int i = 0; i < 10; i++) {
-				if (font != null) {
-					font.dispose();
-				}
-				FileHandle fontFile = Gdx.files.internal("data/arial.ttf");
-				FreeTypeFontGenerator generator = new FreeTypeFontGenerator(fontFile);
-
-				FreeTypeFontParameter parameter = new FreeTypeFontParameter();
-				parameter.size = 15;
-
-				font = generator.generateFont(parameter);
-				generator.dispose();
-			}
-			for (int i = 0; i < 10; i++)
-				System.gc();
-			Gdx.app.log("FreeTypeDisposeTest", "generated 10 fonts");
-			Gdx.app.log("FreeTypeDisposeTest", Gdx.app.getJavaHeap() + ", " + Gdx.app.getNativeHeap());
-		}
-	}
-}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/extensions/FreeTypeFontLoaderTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/extensions/FreeTypeFontLoaderTest.java
deleted file mode 100644
index 878727e..0000000
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/extensions/FreeTypeFontLoaderTest.java
+++ /dev/null
@@ -1,80 +0,0 @@
-
-package com.badlogic.gdx.tests.extensions;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.assets.AssetManager;
-import com.badlogic.gdx.assets.loaders.FileHandleResolver;
-import com.badlogic.gdx.assets.loaders.resolvers.InternalFileHandleResolver;
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.g2d.BitmapFont;
-import com.badlogic.gdx.graphics.g2d.SpriteBatch;
-import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator;
-import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGeneratorLoader;
-import com.badlogic.gdx.graphics.g2d.freetype.FreetypeFontLoader;
-import com.badlogic.gdx.graphics.g2d.freetype.FreetypeFontLoader.FreeTypeFontLoaderParameter;
-import com.badlogic.gdx.tests.utils.GdxTest;
-
-public class FreeTypeFontLoaderTest extends GdxTest {
-	AssetManager manager;
-	SpriteBatch batch;
-
-	@Override
-	public void create () {
-		manager = new AssetManager();
-
-		// set the loaders for the generator and the fonts themselves
-		FileHandleResolver resolver = new InternalFileHandleResolver();
-		manager.setLoader(FreeTypeFontGenerator.class, new FreeTypeFontGeneratorLoader(resolver));
-		manager.setLoader(BitmapFont.class, ".ttf", new FreetypeFontLoader(resolver));
-
-		// load to fonts via the generator (implicitely done by the FreetypeFontLoader).
-		// Note: you MUST specify a FreetypeFontGenerator defining the ttf font file name and the size
-		// of the font to be generated. The names of the fonts are arbitrary and are not pointing
-		// to a file on disk!
-		FreeTypeFontLoaderParameter size1Params = new FreeTypeFontLoaderParameter();
-		size1Params.fontFileName = "data/arial.ttf";
-		size1Params.fontParameters.size = 10;
-		manager.load("size10.ttf", BitmapFont.class, size1Params);
-
-		FreeTypeFontLoaderParameter size2Params = new FreeTypeFontLoaderParameter();
-		size2Params.fontFileName = "data/arial.ttf";
-		size2Params.fontParameters.size = 20;
-		manager.load("size20.ttf", BitmapFont.class, size2Params);
-
-		// we also load a "normal" font generated via Hiero
-		manager.load("data/default.fnt", BitmapFont.class);
-
-		batch = new SpriteBatch();
-	}
-
-	@Override
-	public void render () {
-		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
-		if (manager.update() && manager.isLoaded("size10.ttf")) {
-			batch.begin();
-			manager.get("size10.ttf", BitmapFont.class).draw(batch, "First font!", 20, 20);
-			manager.get("size20.ttf", BitmapFont.class).draw(batch, "Second font!", 20, 50);
-			manager.get("data/default.fnt", BitmapFont.class).draw(batch, "Default font!", 20, 100);
-			batch.end();
-		}
-
-		if (Gdx.input.justTouched() && manager.isLoaded("size10.ttf")) {
-			// unload all the things and check if they really get disposed properly
-			manager.unload("size10.ttf");
-			manager.finishLoading();
-			if (manager.isLoaded("size10.ttf")) throw new RuntimeException("broken");
-			if (!manager.isLoaded("size20.ttf")) throw new RuntimeException("broken");
-
-			manager.unload("size20.ttf");
-			manager.finishLoading();
-			if (manager.isLoaded("size10.ttf")) throw new RuntimeException("broken");
-			if (manager.isLoaded("size20.ttf")) throw new RuntimeException("broken");
-		}
-	}
-
-	@Override
-	public void dispose () {
-		manager.dispose();
-		batch.dispose();
-	}
-}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/extensions/FreeTypeIncrementalTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/extensions/FreeTypeIncrementalTest.java
deleted file mode 100644
index c9f3350..0000000
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/extensions/FreeTypeIncrementalTest.java
+++ /dev/null
@@ -1,233 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See AUTHORS file.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package com.badlogic.gdx.tests.extensions;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.zip.GZIPInputStream;
-
-import com.badlogic.gdx.Gdx;
-import com.badlogic.gdx.files.FileHandleStream;
-import com.badlogic.gdx.graphics.Color;
-import com.badlogic.gdx.graphics.GL20;
-import com.badlogic.gdx.graphics.g2d.BitmapFont;
-import com.badlogic.gdx.graphics.g2d.BitmapFont.Glyph;
-import com.badlogic.gdx.graphics.g2d.SpriteBatch;
-import com.badlogic.gdx.graphics.g2d.TextureRegion;
-import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator;
-import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator.FreeTypeBitmapFontData;
-import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator.FreeTypeFontParameter;
-import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
-import com.badlogic.gdx.graphics.glutils.ShapeRenderer.ShapeType;
-import com.badlogic.gdx.tests.utils.GdxTest;
-import com.badlogic.gdx.utils.Align;
-import com.badlogic.gdx.utils.Array;
-
-public class FreeTypeIncrementalTest extends GdxTest {
-	SpriteBatch batch;
-	ShapeRenderer shapes;
-	BitmapFont font;
-	FreeTypeFontGenerator generator;
-
-	public void create () {
-		batch = new SpriteBatch();
-		shapes = new ShapeRenderer();
-		shapes.setColor(Color.RED);
-
-		FreeTypeFontGenerator.setMaxTextureSize(128);
-
-		// GZIP decode the font. When the font is inside a JAR it is already compressed and this is not needed.
-		FileHandleStream file = new FileHandleStream("data/cjsongeb.ttf.gz") {
-			public InputStream read () {
-				try {
-					return new GZIPInputStream(Gdx.files.internal("data/cjsongeb.ttf.gz").read(), 4096);
-				} catch (IOException ex) {
-					throw new RuntimeException(ex);
-				}
-			}
-
-			public long length () {
-				return 3275360;
-			}
-		};
-		generator = new FreeTypeFontGenerator(file);
-
-		FreeTypeFontParameter param = new FreeTypeFontParameter();
-		param.incremental = true;
-		param.size = 24;
-		param.characters = "howdY";
-
-		FreeTypeBitmapFontData data = new FreeTypeBitmapFontData() {
-			public int getWrapIndex (Array<Glyph> glyphs, int start) {
-				return SimplifiedChinese.getWrapIndex(glyphs, start);
-			}
-		};
-
-		// By default latin chars are used for x and cap height, causing some fonts to display non-latin chars out of bounds.
-		data.xChars = new char[] {''};
-		data.capChars = new char[] {''};
-
-		font = generator.generateFont(param, data);
-	}
-
-	public void render () {
-		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
-
-		// Draw rects.
-		shapes.begin(ShapeType.Line);
-		float x = 0, y = Gdx.graphics.getHeight() - font.getRegion().getRegionHeight() - 1;
-		for (int i = 0, n = font.getRegions().size; i < n; i++) {
-			TextureRegion region = font.getRegions().get(i);
-			shapes.rect(x, y, region.getRegionWidth(), region.getRegionHeight());
-			x += region.getRegionWidth() + 2;
-		}
-		shapes.rect(10, 250, Gdx.graphics.getWidth() - 20, -240);
-		shapes.end();
-
-		batch.begin();
-		x = 0;
-		for (int i = 0, n = font.getRegions().size; i < n; i++) {
-			TextureRegion region = font.getRegions().get(i);
-			batch.draw(region, x, y);
-			x += region.getRegionWidth() + 2;
-		}
-		font.draw(batch, "LYA", 10, 300); // Shows kerning.
-		font.draw(batch, "hello world", 100, 300);
-		font.draw(batch, " B "
-			+ "Spine", 10, 250, //
-			Gdx.graphics.getWidth() - 20, Align.left, true);
-		batch.end();
-	}
-
-	public void resize (int width, int height) {
-		batch.getProjectionMatrix().setToOrtho2D(0, 0, width, height);
-		shapes.setProjectionMatrix(batch.getProjectionMatrix());
-	}
-
-	static public class SimplifiedChinese {
-		public static int getWrapIndex (Array<Glyph> glyphs, int start) {
-			for (int i = start; i > 0; i--) {
-				int startChar = glyphs.get(i).id;
-				if (!SimplifiedChinese.legalAtStart(startChar)) continue;
-				int endChar = glyphs.get(i - 1).id;
-				if (!SimplifiedChinese.legalAtEnd(endChar)) continue;
-				if (startChar < 127 && endChar < 127) continue; // Don't wrap between ASCII chars.
-				return i;
-			}
-			return start;
-		}
-
-		static private boolean legalAtStart (int ch) {
-			switch (ch) {
-			case '!':
-			case '%':
-			case ')':
-			case ',':
-			case '.':
-			case ':':
-			case ';':
-			case '>':
-			case '?':
-			case ']':
-			case '}':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-				return false;
-			}
-			return true;
-		}
-
-		static private boolean legalAtEnd (int ch) {
-			switch (ch) {
-			case '$':
-			case '(':
-			case '*':
-			case ',':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-			case '':
-				return false;
-			}
-			return true;
-		}
-	}
-
-}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/extensions/FreeTypePackTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/extensions/FreeTypePackTest.java
index be7cd6d..5171848 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/extensions/FreeTypePackTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/extensions/FreeTypePackTest.java
@@ -66,7 +66,7 @@ public class FreeTypePackTest extends GdxTest {
 
 	OrthographicCamera camera;
 	SpriteBatch batch;
-	Array<TextureRegion> regions;
+	TextureRegion[] regions;
 	String text;
 
 	FontMap<BitmapFont> fontMap;
@@ -91,7 +91,7 @@ public class FreeTypePackTest extends GdxTest {
 		long start = System.currentTimeMillis();
 		int glyphCount = createFonts();
 		long time = System.currentTimeMillis() - start;
-		text = glyphCount + " glyphs packed in " + regions.size + " page(s) in " + time + " ms";
+		text = glyphCount + " glyphs packed in " + regions.length + " page(s) in " + time + " ms";
 
 	}
 
@@ -126,7 +126,7 @@ public class FreeTypePackTest extends GdxTest {
 
 		// draw all glyphs in background
 		batch.setColor(1f, 1f, 1f, 0.15f);
-		batch.draw(regions.first(), 0, 0);
+		batch.draw(regions[0], 0, 0);
 		batch.setColor(1f, 1f, 1f, 1f);
 		batch.end();
 	}
@@ -187,17 +187,17 @@ public class FreeTypePackTest extends GdxTest {
 		Array<Page> pages = packer.getPages();
 
 		// our resulting regions
-		regions = new Array(pages.size);
+		regions = new TextureRegion[pages.size];
 
 		// Now generate a TextureRegion from each pixmap page
-		for (int i = 0; i < pages.size; i++) {
+		for (int i = 0; i < regions.length; i++) {
 			Page page = pages.get(i);
 
 			// create a Texture from the pixmap
 			Texture tex = new Texture(page.getPixmap());
 			tex.setFilter(TextureFilter.Nearest, TextureFilter.Nearest);
 
-			regions.add(new TextureRegion(tex));
+			regions[i] = new TextureRegion(tex);
 		}
 
 		// No more need for our CPU-based pixmap packer, as our textures are now on GPU
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/extensions/FreeTypeTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/extensions/FreeTypeTest.java
index b847248..ec40cf6 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/extensions/FreeTypeTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/extensions/FreeTypeTest.java
@@ -65,8 +65,8 @@ public class FreeTypeTest extends GdxTest {
 
 		batch.begin();
 		font.setColor(Color.RED);
-		font.draw(batch, "This is a test\nAnd another line\n()$%&/!12390#", 100, 112);
-		ftFont.draw(batch, "This is a test\nAnd another line\n()$%&/!12390#", 100, 112);
+		font.drawMultiLine(batch, "This is a test\nAnd another line\n()$%&/!12390#", 100, 112);
+		ftFont.drawMultiLine(batch, "This is a test\nAnd another line\n()$%&/!12390#", 100, 112);
 // batch.disableBlending();
 		batch.draw(ftFont.getRegion(), 300, 0);
 // batch.enableBlending();
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/BaseG3dTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/BaseG3dTest.java
index f43d8ce..ef9ee4f 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/BaseG3dTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/BaseG3dTest.java
@@ -69,13 +69,13 @@ public abstract class BaseG3dTest extends GdxTest {
 	private void createAxes () {
 		ModelBuilder modelBuilder = new ModelBuilder();
 		modelBuilder.begin();
-		MeshPartBuilder builder = modelBuilder.part("grid", GL20.GL_LINES, Usage.Position | Usage.ColorUnpacked, new Material());
+		MeshPartBuilder builder = modelBuilder.part("grid", GL20.GL_LINES, Usage.Position | Usage.Color, new Material());
 		builder.setColor(Color.LIGHT_GRAY);
 		for (float t = GRID_MIN; t <= GRID_MAX; t += GRID_STEP) {
 			builder.line(t, 0, GRID_MIN, t, 0, GRID_MAX);
 			builder.line(GRID_MIN, 0, t, GRID_MAX, 0, t);
 		}
-		builder = modelBuilder.part("axes", GL20.GL_LINES, Usage.Position | Usage.ColorUnpacked, new Material());
+		builder = modelBuilder.part("axes", GL20.GL_LINES, Usage.Position | Usage.Color, new Material());
 		builder.setColor(Color.RED);
 		builder.line(0, 0, 0, 100, 0, 0);
 		builder.setColor(Color.GREEN);
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/LightsTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/LightsTest.java
index ed4b9f1..5cddfd2 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/LightsTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/LightsTest.java
@@ -56,8 +56,8 @@ public class LightsTest extends ModelTest {
 	protected void onLoaded () {
 		super.onLoaded();
 		BoundingBox bounds = instances.get(0).calculateBoundingBox(new BoundingBox());
-		bounds.getCenter(center);
-		radius = bounds.getDimensions(tmpV).len() * .5f;
+		center.set(bounds.getCenter());
+		radius = bounds.getDimensions().len() * .5f;
 		pointLight.position.set(0, radius, 0).add(transformedCenter.set(center).mul(transform));
 		pointLight.intensity = radius * radius;
 		((ColorAttribute)pLight.material.get(ColorAttribute.Diffuse)).color.set(pointLight.color);
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ModelTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ModelTest.java
index 482deaa..2c48dc8 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ModelTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ModelTest.java
@@ -53,7 +53,7 @@ public class ModelTest extends BaseG3dHudTest {
 		onModelClicked("g3d/teapot.g3db");
 	}
 
-	private final Vector3 tmpV1 = new Vector3(), tmpV2 = new Vector3();
+	private final Vector3 tmpV = new Vector3();
 	private final Quaternion tmpQ = new Quaternion();
 	private final BoundingBox bounds = new BoundingBox();
 
@@ -100,10 +100,10 @@ public class ModelTest extends BaseG3dHudTest {
 		currentlyLoading = null;
 
 		instance.calculateBoundingBox(bounds);
-		cam.position.set(1, 1, 1).nor().scl(bounds.getDimensions(tmpV1).len() * 0.75f + bounds.getCenter(tmpV2).len());
+		cam.position.set(1, 1, 1).nor().scl(bounds.getDimensions().len() * 0.75f + bounds.getCenter().len());
 		cam.up.set(0, 1, 0);
 		cam.lookAt(0, 0, 0);
-		cam.far = 50f + bounds.getDimensions(tmpV1).len() * 2.0f;
+		cam.far = 50f + bounds.getDimensions().len() * 2.0f;
 		cam.update();
 	}
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ShaderCollectionTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ShaderCollectionTest.java
index 966e569..f9309b1 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ShaderCollectionTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ShaderCollectionTest.java
@@ -288,12 +288,12 @@ public class ShaderCollectionTest extends BaseG3dHudTest {
 			if (instance.animations.size > 0) animationControllers.put(instance, new AnimationController(instance));
 
 			instance.calculateBoundingBox(bounds);
-			cam.position.set(1, 1, 1).nor().scl(bounds.getDimensions(tmpV).len() * 0.75f).add(bounds.getCenter(tmpV));
+			cam.position.set(1, 1, 1).nor().scl(bounds.getDimensions().len() * 0.75f).add(bounds.getCenter());
 			cam.up.set(0, 1, 0);
-			cam.lookAt(inputController.target.set(bounds.getCenter(tmpV)));
-			cam.far = Math.max(100f, bounds.getDimensions(tmpV).len() * 2.0f);
+			cam.lookAt(inputController.target.set(bounds.getCenter()));
+			cam.far = Math.max(100f, bounds.getDimensions().len() * 2.0f);
 			cam.update();
-			moveRadius = bounds.getDimensions(tmpV).len() * 0.25f;
+			moveRadius = bounds.getDimensions().len() * 0.25f;
 		}
 	}
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ShaderTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ShaderTest.java
index acb4bff..e11e585 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ShaderTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ShaderTest.java
@@ -38,7 +38,6 @@ import com.badlogic.gdx.graphics.g3d.utils.DefaultShaderProvider;
 import com.badlogic.gdx.graphics.g3d.utils.ModelBuilder;
 import com.badlogic.gdx.graphics.g3d.utils.RenderContext;
 import com.badlogic.gdx.graphics.glutils.ShaderProgram;
-import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.math.Matrix4;
 import com.badlogic.gdx.tests.utils.GdxTest;
 import com.badlogic.gdx.utils.Array;
@@ -67,13 +66,6 @@ public class ShaderTest extends GdxTest {
 		protected boolean equals (Attribute other) {
 			return ((TestAttribute)other).value == value;
 		}
-		
-		@Override
-		public int compareTo (Attribute o) {
-			if (type != o.type) return type < o.type ? -1 : 1;
-			float otherValue = ((TestAttribute)o).value;
-			return MathUtils.isEqual(value, otherValue) ? 0 : (value < otherValue ? -1 : 1);
-		}
 	}
 
 	// Create a custom shader, see also http://blog.xoppa.com/creating-a-shader-with-libgdx
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ShadowMappingTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ShadowMappingTest.java
index 7bfdfbb..33f0997 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ShadowMappingTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/g3d/ShadowMappingTest.java
@@ -65,7 +65,7 @@ public class ShadowMappingTest extends GdxTest {
 
 		ModelBuilder modelBuilder = new ModelBuilder();
 		modelBuilder.begin();
-		MeshPartBuilder mpb = modelBuilder.part("parts", GL20.GL_TRIANGLES, Usage.Position | Usage.Normal | Usage.ColorUnpacked,
+		MeshPartBuilder mpb = modelBuilder.part("parts", GL20.GL_TRIANGLES, Usage.Position | Usage.Normal | Usage.Color,
 			new Material(ColorAttribute.createDiffuse(Color.WHITE)));
 		mpb.setColor(1f, 1f, 1f, 1f);
 		mpb.box(0, -1.5f, 0, 10, 1, 10);
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/gwt/GwtTest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/gwt/GwtTest.java
index c2cec58..edc105b 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/gwt/GwtTest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/gwt/GwtTest.java
@@ -85,7 +85,7 @@ public class GwtTest extends GdxTest {
 		font = new BitmapFont(Gdx.files.internal("data/arial-15.fnt"), false);
 		cache = new BitmapFontCache(font);
 		cache.setColor(Color.RED);
-		cache.setText("This is a Test", 0, 0);
+		cache.setMultiLineText("This is a Test", 0, 0);
 
 		atlas = new TextureAtlas(Gdx.files.internal("data/pack"));
 	}
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/net/NetAPITest.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/net/NetAPITest.java
index 06d19e3..be43725 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/net/NetAPITest.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/net/NetAPITest.java
@@ -33,9 +33,9 @@ import com.badlogic.gdx.scenes.scene2d.Touchable;
 import com.badlogic.gdx.scenes.scene2d.ui.Label;
 import com.badlogic.gdx.scenes.scene2d.ui.Skin;
 import com.badlogic.gdx.scenes.scene2d.ui.TextButton;
+import com.badlogic.gdx.scenes.scene2d.utils.Align;
 import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
 import com.badlogic.gdx.tests.utils.GdxTest;
-import com.badlogic.gdx.utils.Align;
 
 public class NetAPITest extends GdxTest implements HttpResponseListener {
 
@@ -271,7 +271,7 @@ public class NetAPITest extends GdxTest implements HttpResponseListener {
 			batch.end();
 		} else if (text != null) {
 			batch.begin();
-			font.draw(batch, text, 10, Gdx.graphics.getHeight() - 10);
+			font.drawMultiLine(batch, text, 10, Gdx.graphics.getHeight() - 10);
 			batch.end();
 		}
 
diff --git a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
index 1dfe81c..3fe432b 100644
--- a/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
+++ b/tests/gdx-tests/src/com/badlogic/gdx/tests/utils/GdxTests.java
@@ -28,24 +28,11 @@
 
 package com.badlogic.gdx.tests.utils;
 
-import java.io.BufferedReader;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-
+import com.badlogic.gdx.graphics.g2d.freetype.FreetypeFontLoader;
 import com.badlogic.gdx.tests.*;
 import com.badlogic.gdx.tests.bench.TiledMapBench;
 import com.badlogic.gdx.tests.examples.MoveSpriteExample;
 import com.badlogic.gdx.tests.extensions.ControllersTest;
-import com.badlogic.gdx.tests.extensions.FreeTypeDisposeTest;
-import com.badlogic.gdx.tests.extensions.FreeTypeFontLoaderTest;
-import com.badlogic.gdx.tests.extensions.FreeTypeIncrementalTest;
-import com.badlogic.gdx.tests.extensions.FreeTypePackTest;
-import com.badlogic.gdx.tests.extensions.FreeTypeTest;
-import com.badlogic.gdx.tests.extensions.InternationalFontsTest;
 import com.badlogic.gdx.tests.g3d.Animation3DTest;
 import com.badlogic.gdx.tests.g3d.Basic3DSceneTest;
 import com.badlogic.gdx.tests.g3d.Basic3DTest;
@@ -68,6 +55,14 @@ import com.badlogic.gdx.tests.superkoalio.SuperKoalio;
 import com.badlogic.gdx.utils.ObjectMap;
 import com.badlogic.gdx.utils.StreamUtils;
 
+import java.io.BufferedReader;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
 /** List of GdxTest classes. To be used by the test launchers. If you write your own test, add it in here!
  * 
  * @author badlogicgames@gmail.com */
@@ -118,6 +113,7 @@ public class GdxTests {
 		FilterPerformanceTest.class,
 		FloatTextureTest.class,
 		FogTest.class,
+		FrameBufferCubemapTest.class,
 		FrameBufferTest.class,
 		FramebufferToTextureTest.class,
 		FullscreenTest.class,
@@ -235,17 +231,12 @@ public class GdxTests {
 		ViewportTest3.class,
 		YDownTest.class,
 		FreeTypeFontLoaderTest.class,
-		FreeTypeDisposeTest.class,
-		FreeTypeIncrementalTest.class,
-		FreeTypePackTest.class,
-		FreeTypeTest.class,
-		InternationalFontsTest.class,
 		PngTest.class,
 		JsonTest.class
 		// @on
 
 		// SoundTouchTest.class, Mpg123Test.class, WavTest.class, FreeTypeTest.class,
-		// VorbisTest.class
+		// InternationalFontsTest.class, VorbisTest.class
 		));
 
 	static final ObjectMap<String, String> obfuscatedToOriginal = new ObjectMap();
